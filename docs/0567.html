<html>
<head>
<title>Container-Optimized OS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器优化的操作系统</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/container-optimized-os-d32ea15c9ef4?source=collection_archive---------0-----------------------#2018-04-13">https://medium.com/google-cloud/container-optimized-os-d32ea15c9ef4?source=collection_archive---------0-----------------------#2018-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="483f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">感谢我的同事让我开始使用带有容器优化操作系统的挂载。</em></p><p id="f0f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你读过我最近的帖子，我会遵循一条一贯的道路:</p><ul class=""><li id="9070" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">go run...</code></li><li id="309a" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">go build...</code></li><li id="1b2b" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">docker run ...</code></li><li id="84a1" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">kubectl apply ...</code></li></ul><p id="c9b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，有一个可能有用的替代步骤，虽然我在这里使用Golang，但它适用于任何可以容器化的代码:</p><ul class=""><li id="3e3c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">gcloud compute instances create-with-container ...</code></li></ul><p id="b3db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jw" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a> (GCP)提供了一个<a class="ae jw" href="https://cloud.google.com/container-optimized-os/" rel="noopener ugc nofollow" target="_blank">容器优化的操作系统</a>(又名“COS”)，可以在<a class="ae jw" href="https://cloud.google.com/compute/" rel="noopener ugc nofollow" target="_blank">谷歌计算引擎</a>上使用，并且是<a class="ae jw" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Kubernetes引擎</a>(节点)使用的默认映像。COS基于Chromium OS。Chromium OS 是一款专注于安全性的小型Linux操作系统。Chromium OS专注于网页浏览，而COS则专注于运行容器。</p><p id="d92d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我没有使用COS的一个原因是，对我来说，专注于在Kubernetes引擎中建立能力以帮助我的客户更有用，但我总是面临将一些更复杂的容器环境映射到COS的挑战。</p><p id="fba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章旨在帮助你在不需要Kubernetes更强大的特性时，考虑将COS作为一种将容器部署到GCP的方式</p><h2 id="7457" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">设置</h2><p id="2790" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我比较受欢迎的一个帖子是“<a class="ae jw" rel="noopener" href="/google-cloud/app-engine-flex-container-engine-946fbc2fe00a">App Engine Flex | | Kubernetes Engine—？？</a>”。在这个项目中，我们使用了一个Google Golang <a class="ae jw" href="https://cloud.google.com/appengine/docs/flexible/go/using-cloud-datastore" rel="noopener ugc nofollow" target="_blank">示例应用</a>，它可以与云数据存储进行对话，我们将这个应用打包并部署到Flex和Kubernetes上。在本文中，我们将把该应用程序部署到COS。</p><p id="1fb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很有趣，因为它演示了如何将volume|bind挂载转换为COS，以及如何将<a class="ae jw" href="https://cloud.google.com/docs/authentication/production" rel="noopener ugc nofollow" target="_blank">应用程序默认凭证</a>用于COS。</p><p id="3b44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请按照上面提到的帖子中的设置下载示例应用程序。你不需要启用Kubernetes。你*必须*！？)由于GCP在使用云数据存储时的限制，创建一个App Engine应用程序:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="0f41" class="jx jy hi jq b fi lf lg l lh li">gcloud app create --region=us-central --project=${PROJECT}</span></pre><h2 id="e1a4" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">本地-本地</h2><p id="93f6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果你能达到这样一个点:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="1817" class="jx jy hi jq b fi lf lg l lh li">GCLOUD_DATASET_ID=${PROJECT} \<br/>go run main.go</span></pre><p id="0831" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行，并命中其服务器的端点，结果如下:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="cf96" class="jx jy hi jq b fi lf lg l lh li">curl localhost:8080<br/>Previous visits:<br/>[2018-04-12 12:25:30.587515 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:25:29.504421 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:25:06.727592 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:25:04.619761 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:25:03.801524 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:25:00.902566 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:24:59.831409 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:24:56.524133 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:24:55.978291 -0700 PDT] 127.0.0.1:80<br/>[2018-04-12 12:24:53.472835 -0700 PDT] 127.0.0.1:80</span><span id="c09e" class="jx jy hi jq b fi lj lg l lh li">Successfully stored an entry of the current request.</span></pre><p id="1a79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者:</p><figure class="kx ky kz la fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/ff9ddc99e5c450c7815b349be372aa65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfXygJtDQkUwAgdyO4RDwA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">云数据存储:实体</figcaption></figure><p id="13b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们很好。-)</p><blockquote class="lw lx ly"><p id="ea56" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>发布的代码要求将环境变量<code class="du jn jo jp jq b">GCLOUD_DATASET_ID</code>设置为我们的GCP项目ID。该设置将反映在下面这段代码的每次调用中。</p></blockquote><h2 id="708d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">应用程序默认凭据</h2><p id="fc10" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">认证我们代码的更好方法是使用<a class="ae jw" href="https://cloud.google.com/docs/authentication/production" rel="noopener ugc nofollow" target="_blank">应用默认凭证</a>(ADC)。ADC使我们能够使用服务帐户进行身份验证，虽然这通常是一种好的做法，但一旦应用程序容器化，使用服务帐户将是一项要求。</p><p id="7eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的(样板文件)创建了一个服务帐户，为它下载了一个密钥，并授权(！idspnonenote)使用它。)使用云数据存储的帐户:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="a45d" class="jx jy hi jq b fi lf lg l lh li">export ROBOT="datastore"<br/>export EMAIL=${ROBOT}@${PROJECT}.iam.gserviceaccount.com</span><span id="c665" class="jx jy hi jq b fi lj lg l lh li">gcloud iam service-accounts create $ROBOT \<br/>--display-name=$ROBOT \<br/>--project=$PROJECT</span><span id="d3bf" class="jx jy hi jq b fi lj lg l lh li">gcloud iam service-accounts keys create ./${ROBOT}.key.json \<br/>--iam-account=${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--project=$PROJECT</span><span id="347e" class="jx jy hi jq b fi lj lg l lh li">gcloud projects add-iam-policy-binding $PROJECT \<br/>--member=serviceAccount:${EMAIL} \<br/>--role=roles/datastore.user</span></pre><p id="cce5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些步骤以前被用作创建Kubernetes使用的服务帐户密钥的推荐方法的一部分。在这种情况下，我们能够将密钥作为秘密上传到Kubernetes，然后使用卷挂载从容器中安全地引用这个密钥。</p><p id="6769" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切正常，你应该能够重新运行应用程序认证为服务帐户，它应该继续工作。如果它不能立即工作，请等待几秒钟以允许帐户及其权限传播，然后重试:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="65b3" class="jx jy hi jq b fi lf lg l lh li">GCLOUD_DATASET_ID=${PROJECT} \<br/>GOOGLE_APPLICATION_CREDENTIALS=${ROBOT}.key.json \<br/>go run main.go</span></pre><blockquote class="lw lx ly"><p id="59e0" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">唯一的变化是我们在代码中添加了另一个环境变量<code class="du jn jo jp jq b">GOOGLE_APPLICATION_CREDENTIALS</code>,它被Google库(/-ies)用于应用程序默认凭证。我们不需要更改代码来更改凭据。</p></blockquote><p id="7abf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请确保在尝试运行Docker容器之前终止它。如果没有，系统会告诉您该端口已经在使用中。</p><h2 id="36d2" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">码头工人</h2><p id="a325" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">因此，这一步可能没什么意思，但它是一个先决条件。</p><p id="00cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将构建一个静态二进制文件并将其容器化。因为二进制文件现在仅限于——在本例中是Docker的——容器运行时，它无法访问我们的gcloud凭据，所以从现在开始，我们必须使用服务帐户进行身份验证。</p><p id="5b33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建您的二进制文件:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="dde1" class="jx jy hi jq b fi lf lg l lh li">CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o datastore</span></pre><p id="b937" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次测试:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="21d1" class="jx jy hi jq b fi lf lg l lh li">GCLOUD_DATASET_ID=${PROJECT} \<br/>GOOGLE_APPLICATION_CREDENTIALS=${ROBOT}.key.json \<br/>./datastore</span></pre><blockquote class="lw lx ly"><p id="cdc9" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">这里唯一的不同是我们用二进制代码替换了我们的T2。</p></blockquote><p id="3a59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dockerfile:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="8741" class="jx jy hi jq b fi lf lg l lh li">FROM scratch</span><span id="5d1c" class="jx jy hi jq b fi lj lg l lh li">LABEL maintainer="Your Name &lt;<a class="ae jw" href="mailto:your@email.com" rel="noopener ugc nofollow" target="_blank">your@email.com</a>&gt;"</span><span id="a42b" class="jx jy hi jq b fi lj lg l lh li">ADD ca-certificates.crt /etc/ssl/certs/</span><span id="70f9" class="jx jy hi jq b fi lj lg l lh li">ADD dumb-init /<br/>ADD datastore /</span><span id="38d3" class="jx jy hi jq b fi lj lg l lh li">ENTRYPOINT ["/dumb-init","--"]<br/>CMD ["/datastore"]</span></pre><blockquote class="lw lx ly"><p id="2010" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>请查看我以前的帖子，以获得关于<a class="ae jw" href="https://github.com/Yelp/dumb-init" rel="noopener ugc nofollow" target="_blank">哑初始化</a>以及为什么出现“ca-certificates.crt”的指导。</p></blockquote><p id="e231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">建立你的码头工人形象:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="a66d" class="jx jy hi jq b fi lf lg l lh li">docker build --tag=gcr.io/${PROJECT}/datastore .</span></pre><p id="d0d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您最近没有使用它(或忽略它)，<code class="du jn jo jp jq b">gcloud docker -- push</code>现在建议返回到纯粹的<code class="du jn jo jp jq b">docker</code> cli命令，您可能需要:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="0dca" class="jx jy hi jq b fi lf lg l lh li">gcloud auth configure-docker</span></pre><p id="aee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="6add" class="jx jy hi jq b fi lf lg l lh li">IMAGE=datastore<br/>docker push gcr.io/${PROJECT}/${IMAGE}</span></pre><p id="1bf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当推送成功完成时，它将最终生成图像摘要，请捕获该摘要<code class="du jn jo jp jq b">sha256:...</code>(包含):</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="440b" class="jx jy hi jq b fi lf lg l lh li">...<br/>latest: digest: sha256:f70dd40d260d6c79fdf79c678e468302c0a18084b830ea2680cbb14c433c1749 size: 947</span></pre><p id="3c36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你像我一样忘记了一个步骤，你可以:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="b526" class="jx jy hi jq b fi lf lg l lh li">cloud services enable containerregistry.googleapis.com \<br/>--project=${PROJECT}</span></pre><p id="be77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并再次尝试推动；-)</p><p id="6f4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OK…确保<code class="du jn jo jp jq b">go run main.go</code>命令*未*运行，并且:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="52b0" class="jx jy hi jq b fi lf lg l lh li">docker run \<br/>--interactive \<br/>--tty \<br/>--publish=127.0.0.1:8080:8080 \<br/>--env=GCLOUD_DATASET_ID=${PROJECT} \<br/>--env=GOOGLE_APPLICATION_CREDENTIALS=/tmp/${ROBOT}.key.json \<br/>--volume=$PWD/${ROBOT}.key.json:/tmp/${ROBOT}.key.json \<br/>gcr.io/${PROJECT}/datastore</span></pre><blockquote class="lw lx ly"><p id="951e" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">两个<code class="du jn jo jp jq b">-env</code>标志像以前一样设置环境变量。此外，我们必须为容器提供访问存储在主机上的密钥的方法。这是通过<code class="du jn jo jp jq b">--volume</code>映射实现的。</p></blockquote><p id="5de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该能够继续成功卷曲端点。</p><h2 id="c885" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">一个容器优化的操作系统虚拟机</h2><p id="26cf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在让我们将这个映像部署到COS并在那里运行它。我们需要(1)创建配置为从GCR拉映像的COS虚拟机；(2)将密钥复制到虚拟机。如果您尚未在项目中启用计算引擎:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="c838" class="jx jy hi jq b fi lf lg l lh li">gcloud services enable compute.googleapis.com --project=${PROJECT}</span></pre><p id="4eb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="8a32" class="jx jy hi jq b fi lf lg l lh li">DIGEST=[[ The digest from your push ]]<br/>INSTANCE=datastore-cos<br/>ZONE=us-west1-a</span><span id="0016" class="jx jy hi jq b fi lj lg l lh li">gcloud beta compute instances create-with-container ${INSTANCE} \<br/>--zone=${ZONE} \<br/>--image-family=cos-stable \<br/>--image-project=cos-cloud \<br/>--container-image=gcr.io/${PROJECT}/${IMAGE}@${DIGEST} \<br/>--container-restart-policy=always \<br/>--container-env=\<br/>GCLOUD_DATASET_ID=${PROJECT},\<br/>GOOGLE_APPLICATION_CREDENTIALS=/tmp/${ROBOT}.key.json \<br/>--container-mount-host-path=\<br/>mount-path=/tmp,\<br/>host-path=/tmp,\<br/>mode=rw \<br/>--project=${PROJECT}</span></pre><blockquote class="lw lx ly"><p id="83dc" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">这是一个<code class="du jn jo jp jq b">gcloud beta</code>命令。我们将COS VM上的<code class="du jn jo jp jq b">/tmp</code>挂载到我们的容器实例中。如果您以前没有使用过<code class="du jn jo jp jq b">API [compute.googleapis.com]</code>，可能会提示您启用它，请接受(Y)并注意，在COS VM实例运行时，您将被收费。</p><p id="3056" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>有更多的标志来运行这个命令，因为我们正在创建一个COS VM并在其上运行我们的容器映像。但是，您仍然可以看到我们的原始环境变量<code class="du jn jo jp jq b">GCLOUD_DATASET_ID</code>和<code class="du jn jo jp jq b">GOOGLE_APPLICATION_CREDENTIALS</code>反映在这个命令中。和以前一样，我们必须将我们的服务帐户映射到(远程)容器中。这是通过<code class="du jn jo jp jq b">--container-mount-host-path</code>启用的，但这不会将密钥复制到虚拟机。见下文。</p><p id="5a26" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">NB 我们在使用COS时不会显式暴露端口<code class="du jn jo jp jq b">8080</code>。COS上的容器通过<code class="du jn jo jp jq b">--net=host</code>有效运行。这呈现了容器的(多个)端口，就好像它们是由主机直接公开的一样。在我们的例子中，当我们将。)港口<code class="du jn jo jp jq b">8080</code>我们的集装箱就是通过它进入的。这样做的一个缺点是，您的COS容器在端口使用上可能不会冲突。</p></blockquote><p id="e026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切顺利，我们将从GCP那里得到实例已经创建并运行的确认。希望我们的容器也在运行。但是，在它正确运行之前，我们必须将服务帐户复制到VM，以便容器可以通过卷挂载来访问它。从您的工作目录:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="09dd" class="jx jy hi jq b fi lf lg l lh li">gcloud compute scp \<br/>  ${ROBOT}.key.json \<br/>  ${INSTANCE}:/tmp \<br/>--project=${PROJECT}</span></pre><p id="0077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">怎么分辨？让我们ssh到图像和检查。当我们使用ssh时，让我们也使用port-forward端口<code class="du jn jo jp jq b">8080</code>,以便我们可以访问服务:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="b46e" class="jx jy hi jq b fi lf lg l lh li">gcloud compute ssh ${INSTANCE} \<br/>--ssh-flag="-L 8080:localhost:8080" \<br/>--project=${PROJECT}</span></pre><p id="560d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦这个命令成功，从另一个ssh会话(！idspnonenote)中。)，尝试使用<code class="du jn jo jp jq b">localhost:8080</code> ( <code class="du jn jo jp jq b">localhost</code>感谢端口转发)卷曲端点。</p><p id="09b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">观察(COS)虚拟机状态的一个有用方法是获取串行控制台输出:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="6df7" class="jx jy hi jq b fi lf lg l lh li">gcloud compute instances get-serial-port-output ${INSTANCE} \<br/>--zone=${ZONE} \<br/>--project=${PROJECT} \<br/>| grep konlet-startup</span></pre><p id="7e81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该会看到成功消息，包括<code class="du jn jo jp jq b">pull complete</code>、<code class="du jn jo jp jq b">Create a container...</code>、<code class="du jn jo jp jq b">Starting a container...</code>等。</p><p id="a13c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从实例的(！)ssh会话，您可以使用Docker CLI:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="42bf" class="jx jy hi jq b fi lf lg l lh li">docker container ls</span></pre><p id="625e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它应该有一个<code class="du jn jo jp jq b">Up..</code>状态:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="909e" class="jx jy hi jq b fi lf lg l lh li">CONTAINER ID    IMAGE                                   STATUS<br/>d06da5bee1f0    gcr.io/${PROJECT}/datastore@${DIGEST}   Up 1 minutes</span></pre><p id="4ab5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将无法使用<code class="du jn jo jp jq b">docker logs...</code>,但是您可以使用<code class="du jn jo jp jq b">journalctl</code>来实现类似的(以及更广泛的)目的:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="90d6" class="jx jy hi jq b fi lf lg l lh li">sudo journalctl --unit=konlet-startup \<br/>| grep ${INSTANCE}</span></pre><blockquote class="lw lx ly"><p id="8460" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>如果你想通过它过滤<code class="du jn jo jp jq b">journalctl</code>日志，你需要重新创建<code class="du jn jo jp jq b">${INSTANCE}</code>，但是除非你在COS VM上运行多个容器，否则这是多余的。</p></blockquote><h2 id="85f2" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">实例组:许多容器优化的操作系统虚拟机</h2><p id="439a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用COS VMs的一个有趣的副作用是，它们可以被模板化，然后用于创建实例组。顾名思义，这些是(克隆的)实例组。因此，我们没有直接创建COS虚拟机，而是创建一个模板，然后创建一个实例组来为我们清除X个(让我们做3个)克隆:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="c0be" class="jx jy hi jq b fi lf lg l lh li">REGION=us-west1</span><span id="1d5a" class="jx jy hi jq b fi lj lg l lh li">gcloud beta compute instance-templates create-with-container ${INSTANCE}-template \<br/>--image-family=cos-stable \<br/>--image-project=cos-cloud \<br/>--container-image=gcr.io/${PROJECT}/${IMAGE}@${DIGEST} \<br/>--container-restart-policy=always \<br/>--container-env=\<br/>GCLOUD_DATASET_ID=${PROJECT},\<br/>GOOGLE_APPLICATION_CREDENTIALS=/tmp/${ROBOT}.key.json \<br/>--container-mount-host-path=\<br/>mount-path=/tmp,\<br/>host-path=/tmp,\<br/>mode=rw \<br/>--region=${REGION} \<br/>--project=${PROJECT}</span></pre><blockquote class="lw lx ly"><p id="14d4" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>这里唯一的区别是我决定使用一个区域实例组，所以我们用<code class="du jn jo jp jq b">--region=${REGION}</code>替换<code class="du jn jo jp jq b">--zone=${ZONE}</code>，并为<code class="du jn jo jp jq b">REGION</code>添加一个设置。</p></blockquote><p id="b642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">带来克隆人:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="8013" class="jx jy hi jq b fi lf lg l lh li">CLONES=3</span><span id="3ebf" class="jx jy hi jq b fi lj lg l lh li">gcloud compute instance-groups managed create ${INSTANCE}-group \<br/>--base-instance-name=${INSTANCE} \<br/>--template=${INSTANCE}-template \<br/>--size=${CLONES} \<br/>--region=${REGION} \<br/>--project=${PROJECT}</span></pre><p id="c359" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很快地:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="5af9" class="jx jy hi jq b fi lf lg l lh li">gcloud compute instance-groups managed list-instances ${INSTANCE}-group --region=$REGION --project=$PROJECT</span><span id="4188" class="jx jy hi jq b fi lj lg l lh li">NAME                ZONE        STATUS   ACTION  LAST_ERROR<br/>datastore-cos-qnkg  us-west1-a  RUNNING  NONE<br/>datastore-cos-q5wd  us-west1-b  RUNNING  NONE<br/>datastore-cos-3t60  us-west1-c  RUNNING  NONE</span></pre><blockquote class="lw lx ly"><p id="4e19" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>在<code class="du jn jo jp jq b">us-west1</code>中，我不仅得到了我的模板的3个克隆体，而且它们被涂上了花生酱。太棒了。</p></blockquote><p id="9468" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，我给自己制造了一个问题。我现在有x个(其中x可能很大)容器实例在运行，并且每个实例都希望服务帐户密钥出现在它的主机中(映射到它的主机中)<code class="du jn jo jp jq b">/tmp</code>。我们可以作弊:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="1150" class="jx jy hi jq b fi lf lg l lh li">CLONES=$(gcloud compute instance-groups managed list-instances ${INSTANCE}-group --region=$REGION --project=$PROJECT --format="value(instance)")</span><span id="6c5f" class="jx jy hi jq b fi lj lg l lh li">for CLONE in ${CLONES}<br/>do<br/>  gcloud compute scp \<br/>    ${ROBOT}.key.json \<br/>    ${CLONE}:/tmp \<br/>--project=${PROJECT}<br/>done</span></pre><p id="2a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，实例组的一个好处是可以自动扩展它们，不健康的克隆将被淘汰和替换。在任一情况下，新的克隆都不能访问服务帐户密钥。</p><p id="46f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们真正想要的是每个容器能够主动引用的密钥的单一来源。想法？持久磁盘过度使用。这里有一个使用<a class="ae jw" href="https://cloud.google.com/storage/" rel="noopener ugc nofollow" target="_blank">谷歌云存储</a> (GCS)的解决方案。</p><p id="b487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个(区域)桶，并将我们的密钥放入其中。该项目的任何用户都可以访问该密钥:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="ddb6" class="jx jy hi jq b fi lf lg l lh li">BUCKET=[[YOUR-BUCKET-NAME]]</span><span id="eab6" class="jx jy hi jq b fi lj lg l lh li">gsutil mb -c regional -l ${REGION} -p ${PROJECT} gs://${BUCKET}<br/>gsutil cp ./${ROBOT}.key.json gs://${BUCKET}/</span></pre><p id="2294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以修改实例模板来运行获取容器密钥的启动脚本。</p><p id="a2e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动. sh:</p><figure class="kx ky kz la fd ll"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="1c96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要删除现有模板(和实例组)或修改名称:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="bcbe" class="jx jy hi jq b fi lf lg l lh li">gcloud beta compute instance-templates create-with-container ${INSTANCE}-template \<br/>--region=${REGION} \<br/>--image-family=cos-stable \<br/>--image-project=cos-cloud \<br/>--container-image=gcr.io/${PROJECT}/${IMAGE}@${DIGEST} \<br/>--container-env=\<br/>GCLOUD_DATASET_ID=${PROJECT},\<br/>GOOGLE_APPLICATION_CREDENTIALS=/tmp/${ROBOT}.key.json \<br/>--container-mount-host-path=\<br/>mount-path=/tmp,\<br/>host-path=/tmp,\<br/>mode=rw \<br/>--project=$PROJECT \<br/>--metadata-from-file=startup-script=./startup.sh</span></pre><p id="60e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>唉。这个启动脚本比它应该的更复杂。我们必须四处寻找，为COS VM的服务帐户获取一个访问令牌，然后使用它从GCS获取服务帐户密钥，并按照容器的预期将它存储在<code class="du jn jo jp jq b">/tmp/${ROBOT}.key.json</code>中。</p><blockquote class="lw lx ly"><p id="2bcd" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>请用实际值替换<code class="du jn jo jp jq b">[[YOUR-BUCKET]]</code>和<code class="du jn jo jp jq b">[[YOUR-KEY-FILE]]</code>。</p></blockquote><p id="e81f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用与前面相同的命令创建一个实例组:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="dbdb" class="jx jy hi jq b fi lf lg l lh li">gcloud compute instance-groups managed create ${INSTANCE}-group \<br/>--base-instance-name=${INSTANCE} \<br/>--template=${INSTANCE}-template \<br/>--size=${CLONES} \<br/>--region=${REGION} \<br/>--project=${PROJECT}</span></pre><p id="e743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，集装箱应该可以上路了。让我们随机选择一个:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="9831" class="jx jy hi jq b fi lf lg l lh li">NODES=$(\<br/>  gcloud compute instance-groups managed \<br/>  list-instances ${INSTANCE}-group \<br/>  --region=$REGION \<br/>  --project=$PROJECT \<br/>  --format="value(instance)")</span><span id="7a95" class="jx jy hi jq b fi lj lg l lh li">RANDOM_NODE=$(shuf -n1 -e ${NODES})</span><span id="d7f8" class="jx jy hi jq b fi lj lg l lh li">gcloud compute ssh ${RANDOM_NODE} \<br/>--project=${PROJECT} \<br/>--ssh-flag="-L 8080:localhost:8080"</span></pre><p id="fb61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且，希望你能成功卷曲【T3:-)</p><p id="d88e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您遇到问题，我建议您确保正确复制了启动脚本。您可以检查一个实例的串行控制台，尽管它没有报告<code class="du jn jo jp jq b">startup-script</code>。从COS虚拟机中，您可以检查:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="51bb" class="jx jy hi jq b fi lf lg l lh li">sudo journalctl | grep startup-script</span></pre><p id="751a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及VM的<code class="du jn jo jp jq b">/tmp</code>目录中服务账户密钥的存在。</p><p id="0388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很简单(耶！)我将让您为我们的实例组创建一个HTTP负载平衡器。</p><h2 id="0bc6" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">库伯内特斯</h2><p id="cd1f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">哦，那好吧；-)</p><p id="18ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是这篇文章的重点，但我把它放在这里是为了完整，因为我希望通过这样做，它能揭示所有这些方法的一致性。</p><p id="bb74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您正在运行“a Kubernetes ”,我们将创建一个名称空间，上传服务密钥作为密码，运行容器将密码中的密钥转换为卷挂载。最好完全用YAMLs来完成，但要避免密钥的复杂性:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="a9d3" class="jx jy hi jq b fi lf lg l lh li">NAMESPACE=datastore<br/>kubectl create namespace ${NAMESPACE}</span><span id="65e7" class="jx jy hi jq b fi lj lg l lh li">kubectl create secret generic ${ROBOT} \<br/>--from-file=${ROBOT}.key.json=${PWD}/${ROBOT}.key.json \<br/>--namespace=${NAMESPACE}</span></pre><blockquote class="lw lx ly"><p id="23eb" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">Kubernetes <code class="du jn jo jp jq b">secrets</code>的NB 是在集群中托管安全数据(在名称空间中)的一种更优雅的方式。</p></blockquote><p id="f091" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署如下:</p><figure class="kx ky kz la fd ll"><div class="bz dy l di"><div class="mc md l"/></div></figure><blockquote class="lw lx ly"><p id="bbdb" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>在应用之前，不要忘记用<code class="du jn jo jp jq b">${PROJECT}</code>的值替换<code class="du jn jo jp jq b">${PROJECT}</code>的出现次数。我假设您使用了<code class="du jn jo jp jq b">datastore</code>作为<code class="du jn jo jp jq b">${ROBOT}</code>的值，但是，如果您没有使用，请更改<code class="du jn jo jp jq b">datastore.key.json</code>以反映正确的值。</p><p id="c0ca" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>在第27–31行你会看到我们的环境变量<code class="du jn jo jp jq b">GCLOUD_DATASET_ID</code>和<code class="du jn jo jp jq b">GOOGLE_APPLICATION_CREDENTIALS</code>被反映出来。我们使用和以前一样的服务帐户和密钥，尽管按照惯例，我们要在这里安装一个<code class="du jn jo jp jq b">/var/secrets/google</code>的挂载点。与Docker本地使用不同，我们需要显式公开端口<code class="du jn jo jp jq b">8080</code>。否则，这应该看起来与其他方法非常一致。</p></blockquote><p id="2848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="e2da" class="jx jy hi jq b fi lf lg l lh li">kubectl apply --filename=deployment.yaml</span></pre><p id="6e71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其在防火墙上打一个洞，不如让我们获取一个集群的底层节点名，确定创建服务的节点端口，并将其转发到端口。我们将保留节点端口到本地端口的映射，因此您可以在其他地方继续使用<code class="du jn jo jp jq b">8080</code>:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="4092" class="jx jy hi jq b fi lf lg l lh li">NODE_HOST=$(\<br/>  kubectl get nodes \<br/>  --output=jsonpath="{.items[0].metadata.name}")</span><span id="1ba7" class="jx jy hi jq b fi lj lg l lh li">NODE_PORT=$(\<br/>  kubectl get services/datastore \<br/>  --namespace=datastore \<br/>  --output=jsonpath="{.spec.ports[0].nodePort}")</span><span id="ec61" class="jx jy hi jq b fi lj lg l lh li">echo ${NODE_PORT}</span><span id="1458" class="jx jy hi jq b fi lj lg l lh li">gcloud compute ssh ${NODE_HOST} \<br/>--ssh-flag="-L ${NODE_PORT}:localhost:${NODE_PORT}" \<br/>--project=${PROJECT}</span></pre><p id="45db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，当ssh会话运行时，从您的本地机器:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="8bf8" class="jx jy hi jq b fi lf lg l lh li">curl http://localhost:${NODE_PORT}</span></pre><blockquote class="lw lx ly"><p id="bdb3" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>您需要重新创建变量或键入<code class="du jn jo jp jq b">${NODE_PORT}</code>的值，因为它不会在单独的ssh会话中设置。</p></blockquote><p id="0792" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且，您应该会继续看到返回给您的最后10次“访问”的输出(对应于创建的数据存储实体)。</p><h2 id="c4a0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">结论</h2><p id="8794" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Containers三种方式，但主要展示了如何满足需要共享卷和/或服务帐户密钥的容器的共同需求，并在本地将单个映像部署到运行Google的容器优化操作系统的虚拟机和Kubernetes。一路上，我试图反映所有这些方法的一致性。</p><p id="b751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总是寻求反馈！</p><h2 id="ebfa" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">整理一下！</h2><p id="186a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当您使用完图像后，请将其删除:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="94e4" class="jx jy hi jq b fi lf lg l lh li">gcloud compute instances delete ${INSTANCE} \<br/>--project=${PROJECT} \<br/>--quiet</span></pre><p id="c12b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您使用完模板和实例组后，请删除它们:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="e7b5" class="jx jy hi jq b fi lf lg l lh li">gcloud compute instance-groups managed delete ${INSTANCE}-group \<br/>--region=${REGION} \<br/>--project=${PROJECT}</span><span id="4a73" class="jx jy hi jq b fi lj lg l lh li">gcloud compute instance-templates delete ${INSTANCE}-template \<br/>--region=${REGION} \<br/>--project=${PROJECT}</span></pre><p id="aa5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您完全完成了项目，您可以删除虚拟机和数据存储数据，方法是不可撤销的:</p><pre class="kx ky kz la fd lb jq lc ld aw le bi"><span id="eb05" class="jx jy hi jq b fi lf lg l lh li">gcloud projects delete ${PROJECT} --quiet</span></pre><p id="76fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样<em class="jd">！！</em></p></div></div>    
</body>
</html>