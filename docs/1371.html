<html>
<head>
<title>Exporting data from Firebase (Firestore) to BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将数据从Firebase (Firestore)导出到BigQuery</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/exporting-data-from-firebase-firestore-to-bigquery-e5a067849645?source=collection_archive---------2-----------------------#2020-04-14">https://medium.com/google-cloud/exporting-data-from-firebase-firestore-to-bigquery-e5a067849645?source=collection_archive---------2-----------------------#2020-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="24fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Firebase是一个流行的web和移动应用程序开发平台。在Firebase平台上开发应用程序时，主要的数据库选项是NoSQL数据库云Firestore，它也是谷歌云平台的一部分。由于Firestore是一个NoSQL数据库，与SQL数据库相比，在关系的建模和设计方面有不同的考虑。NoSQL数据库的薄弱环节是有限的分析能力。这里BigQuery开始发挥作用，因为它是一个专门为OLAP分析设计的无服务器数据仓库。问题是如何从Firestore获取数据到BigQuery？</p><p id="e58c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我想描述两种方法。一种是导入整批Firestore导出，第二种方法是Firestore和BigQuery之间的在线同步。当然，根据Firestore建模，可以通过使用计数器或Firestore中的简单查询提取大量分析数据，但没有什么比SQL更直接了:)</p><h1 id="d339" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据</h1><p id="5614" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">所有代码样本和脚本都在这个库<a class="ae kg" href="https://github.com/zdenulo/firestore2bigquery" rel="noopener ugc nofollow" target="_blank">https://github.com/zdenulo/firestore2bigquery</a>中。作为数据源，我将使用虚构的YAFTA应用程序(另一个健身跟踪应用程序)，它包含了<strong class="ih hj">用户</strong>(用户名、电子邮件、性别等基本信息)的集合，并且这个集合包含了<strong class="ih hj">日志</strong>的子集合，其中记录了每次锻炼。每个日志条目都包含锻炼的开始/结束时间以及所做锻炼种类的列表。我创建了一个脚本来生成随机数据，并将其插入Firestore，可以在这里找到<a class="ae kg" href="https://github.com/zdenulo/firestore2bigquery/blob/master/generate_data.py" rel="noopener ugc nofollow" target="_blank"/>。我上传了几百个用户，每个人都有几十篇日志。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/565096db2181073326e779ea88fabe31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*Eiv9w4xx9kQU37Hk.png"/></div></figure><h1 id="48ca" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">完全出口</h1><p id="61f7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Firestore支持集合到云存储的导出/导入操作，BigQuery支持这些导出的导入。我们只需要把这些放在一起。</p><h2 id="fe5d" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">1)创建/选择存储桶</h2><p id="b376" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在你要做Firestore导出的地方，在我的例子中，一个桶将被称为<strong class="ih hj"> f2b-exports </strong></p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="829f" class="kp je hi le b fi li lj l lk ll">gsutil mb -p $GCP_PROJECT gs://f2b-exports</span></pre><h2 id="69eb" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">2)导出Firestore系列</h2><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="5aad" class="kp je hi le b fi li lj l lk ll">gcloud firestore export gs://f2b-exports/export-01 --collection-ids=users,journals</span></pre><p id="b090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在一个桶中设置了路径‘export-01 ’,否则，它将是datetime时间戳。它打印以下输出:</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="293e" class="kp je hi le b fi li lj l lk ll">Waiting for [projects/zdenky-15ba5/databases/(default)/operations/ASAyNjkxMzMwOTMyChp0bHVhZmVkBxJsYXJ0bmVjc3Utc2Jvai1uaW1kYRQKLRI] to finish...done.           <br/>metadata:<br/>  '@type': type.googleapis.com/google.firestore.admin.v1.ExportDocumentsMetadata<br/>  collectionIds:<br/>  - users<br/>  - journals<br/>  operationState: PROCESSING<br/>  outputUriPrefix: gs://f2b-exports/export-01<br/>  startTime: '2020-03-20T10:49:24.973411Z'<br/>name: projects/zdenky-15ba5/databases/(default)/operations/ASAyNjkxMzMwOTMyChp0bHVhZmVkBxJsYXJ0bmVjc3Utc2Jvai1uaW1kYRQKLRI</span></pre><p id="e5bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在打印本文档时，作业已经完成，尽管它显示处于处理状态。对于更大的集合，最好使用async标志来异步完成。要获得有关操作的信息，可以使用以下命令:</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="f48f" class="kp je hi le b fi li lj l lk ll">gcloud firestore operations describe ASAyNjkxMzMwOTMyChp0bHVhZmVkBxJsYXJ0bmVjc3Utc2Jvai1uaW1kYRQKLRI<br/>done: true<br/>metadata:<br/>  '@type': type.googleapis.com/google.firestore.admin.v1.ExportDocumentsMetadata<br/>  collectionIds:<br/>  - users<br/>  - journals<br/>  endTime: '2020-03-20T10:49:41.312303Z'<br/>  operationState: SUCCESSFUL<br/>  outputUriPrefix: gs://f2b-exports/export-01<br/>  progressBytes:<br/>    completedWork: '8222613'<br/>  progressDocuments:<br/>    completedWork: '14702'<br/>    estimatedWork: '12928'<br/>  startTime: '2020-03-20T10:49:24.973411Z'<br/>name: projects/zdenky-15ba5/databases/(default)/operations/ASAyNjkxMzMwOTMyChp0bHVhZmVkBxJsYXJ0bmVjc3Utc2Jvai1uaW1kYRQKLRI<br/>response:<br/>  '@type': type.googleapis.com/google.firestore.admin.v1.ExportDocumentsResponse<br/>  outputUriPrefix: gs://f2b-exports/export-01</span></pre><h2 id="6948" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">3)将数据导入BigQuery</h2><p id="80b9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们需要将每个集合逐个导入到单独的BigQuery表中。我将导入到数据集'<strong class="ih hj"> f2b </strong>'中，表将与集合同名。</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="f231" class="kp je hi le b fi li lj l lk ll">bq load --source_format=DATASTORE_BACKUP f2b.users gs://f2b-exports/export-01/all_namespaces/kind_users/all_namespaces_kind_users.export_metadata<br/>Waiting on bqjob_r4f696fee02205f3e_00000170f79ef5c8_1 ... (1s) Current status: DONE</span><span id="cf6c" class="kp je hi le b fi lm lj l lk ll">bq load --source_format=DATASTORE_BACKUP f2b.journals gs://f2b-exports/export-01/all_namespaces/kind_journals/all_namespaces_kind_journals.export_metadata<br/>Waiting on bqjob_r1fffa3bf31a8debd_00000170f7a0ed20_1 ... (10s) Current status: DONE</span></pre><p id="292b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Github库中，有一个Python代码可以用来部署云功能，或者稍加调整，它可以用作脚本来完成这3个步骤。</p><h2 id="ccc2" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">BigQuery模式和查询</h2><p id="955d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在导入数据时，Bigquery将Firestore数据类型转换为其“原生类型”,并添加了几个分组到<strong class="ih hj"> __key__ </strong>记录中的字段，其中最有用的是<strong class="ih hj"> __key__。名称</strong>，包含文件的密钥和<strong class="ih hj"> __key__。路径</strong>包含文档的完整路径。这在连接表(集合)时是必要的。下图是“journals”表的模式。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ln"><img src="../Images/558cecc600117eba1f04160c54eee5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*k2jzvKaGjkc2Sd2U.png"/></div></figure><p id="4ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以做任何想到的SQL查询。我想，在这种数据的背景下，我们希望将用户和期刊结合起来，并在此基础上进行分析。这里变得有点棘手。列<strong class="ih hj">__键_ _。子集合中的name </strong> path(在本例中为表journals)包含如下字符串值:</p><p id="009d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"用户"，" virginiamoran@gmail.com "，"期刊"，" ZPs9vH2mzR58MFpTQzqc "，即结构:</p><p id="fa6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><parent collection="" name="">、<parent document="" key="">、<subcollection name="">、<subcollection document="" key="">。</subcollection></subcollection></parent></parent></p><p id="d158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将这个表与'<strong class="ih hj"> users </strong>'表连接起来，我们需要提取“父文档关键字”并连接到那个值上。例如，下面是一个计算每个用户锻炼时间总数的基本查询。</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="57e0" class="kp je hi le b fi li lj l lk ll">WITH journals_data AS (<br/>SELECT TRIM(REPLACE(SPLIT(__key__.path, ',')[OFFSET(1)], '"', '')) AS user_key, exercise_time FROM f2b.journals<br/>)<br/><br/>SELECT users.__key__.name AS email, users.name AS name, SUM(journals.exercise_time) AS total_time FROM journals_data AS journals<br/><br/>JOIN f2b.users AS users ON users.__key__.name=journals.user_key<br/>GROUP BY email, name<br/>ORDER BY total_time DESC</span></pre><p id="b089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了提取密钥，我们需要拆分字符串、替换双引号并进行修剪。除此之外，根据我的经验，其他一切通常都像其他BigQuery表一样工作。</p><h2 id="1d5a" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">使用这种方法时，需要记住几件事:</h2><p id="e65b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">-它总是从Firestore完全导出，您不能通过查询或类似方式进行限制。这将计入Firestore账单，因为每个Firestore操作都是有账单的。</p><p id="2b56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-您需要像示例中那样明确定义要导出的集合/子集合。如果不指定集合，Firestore会进行完全导出，而这在BigQuery中是无法导入的</p><p id="0022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-对于BigQuery导入，可以指定要导入的具体字段/列</p><p id="0a5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-通过在BigQuery中创建外部表，无需导出即可查询Firestore导出</p><p id="5206" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-当您不需要经常查询数据并且每次都可以进行完全导出时，这种方法很好(取决于Firestore数据量和您的预算)</p><p id="f0d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://firebase.google.com/docs/firestore/manage-data/export-import#export_data" rel="noopener ugc nofollow" target="_blank"> Firestore导出/导入</a>和<a class="ae kg" href="https://cloud.google.com/bigquery/docs/loading-data-cloud-firestore" rel="noopener ugc nofollow" target="_blank"> BigQuery导入</a>的官方文档。</p><h1 id="d94b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Firestore和BigQuery之间的同步。</h1><p id="a30f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这种方法依赖于在Firestore集合发生变化时触发云功能，并将这些变化传输到BigQuery表中。这样，BigQuery中的数据与Firestore中的数据相同。Firebase使用“Export Collections to big query”Firebase扩展提供了一种自动设置的方法。</p><p id="989c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我提到的，除了将数据插入BigQuery之外，它还会自动创建一个插入数据的表，并基于该表创建一个视图，以便只获取文档的最新数据。为了设置Firebase扩展，您需要登录Firebase(如果您没有使用它，请在那里导入GCP项目)。在这个URL上<a class="ae kg" href="https://firebase.google.com/products/extensions/firestore-bigquery-export" rel="noopener ugc nofollow" target="_blank">https://firebase . Google . com/products/extensions/firestore-big query-export</a>是关于这个扩展的描述和文档。所以你只需要点击“在控制台中安装”按钮，通过Firebase UI或使用Firebase CLI进行设置。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lo"><img src="../Images/be58c085d821e1a9381060ed921c9899.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*0WGZG6bj4PiNT7nw.png"/></div></figure><p id="85b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置总共有4个步骤。作为第一步，它设置一个云功能，检查计费设置，创建一个具有BigQuery数据编辑器角色的服务帐户(如果需要),在最后一步，您为Firebase集合设置一个集合路径，以及BigQuery数据集和数据将被导出到的表名。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/836f6b84aabbce1ff9640b781e4c3097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*gB9JGoif3PWy77OH.png"/></div></figure><p id="1ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之后，需要几分钟来部署云功能。BigQuery中的表是在第一次执行云函数时创建的，并插入到BigQuery中。BigQuery中有以“<strong class="ih hj"> _raw_changelog </strong>”结尾的表，在我这里是“<strong class="ih hj">journals _ sync _ raw _ changelog</strong>”。这是存储所有更改的地方。每一次更新、删除、插入。基本上在这张表中，你有你的收藏的全部变化历史。模式相当简单并且总是相同的:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/fd9e7a90a7c3c1c011225fa0c505e14c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*zwXe8G-KZ2NeLp9c.png"/></div></figure><p id="ddee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在“数据”列中有JSON表示的整个文档，字段“文档名”包含文档关键字的完整路径。</p><p id="0562" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了总是获得最新的数据(并排除已删除的数据)，还会自动创建一个基于"<strong class="ih hj"> raw_changelog </strong>"表的视图，其名称以"<strong class="ih hj"> _raw_latest </strong>"结尾，在上面的例子中，它是"<strong class="ih hj">journals _ sync _ raw _ latest</strong>"。</p><p id="6160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过安装该扩展，您可以将Firestore集合中的更改流设置为BigQuery。但是如果你从Firestore中已经有数据的集合开始呢？为此，您还需要执行一个脚本来上传对BigQuery的初始更改。</p><h2 id="e047" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">上传现有文档</h2><p id="289d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你可以通过访问URL<a class="ae kg" href="https://console.firebase.google.com/u/0/project/zdenky-15ba5/extensions" rel="noopener ugc nofollow" target="_blank">https://console.firebase.google.com/u/0/project/&lt;项目id&gt;/扩展</a>或者点击Firebase菜单中的扩展按钮来查看已安装的扩展细节。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/1cf822054926dd7c1c1170da35f0e809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*PwXv0LYueY2Xp4V6.png"/></div></figure><p id="dd7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你点击“这个扩展如何工作”时，你会看到这个扩展如何工作的详细概述。在描述的底部，有一个指向Github repository的URL，那里有一个关于如何导入现有文档的描述。我应该强调，目前(2020年4月)脚本不支持子集合的直接导入。在问题中，提到了解决方法，但它涉及到修改源代码，所以我不会在这里描述它。</p><h2 id="1513" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">使用脚本导入现有文档</h2><p id="a15f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">要导入集合，步骤如下:</p><p id="c801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您没有通过Cloud SDK的身份验证，您需要执行:</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="56a8" class="kp je hi le b fi li lj l lk ll">gcloud auth application-default login</span></pre><p id="b0ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后当执行下一个命令时(这需要安装npm/NodeJS)，它下载必要的包并开始交互设置。在这里，您需要输入您的项目id、集合路径(与设置扩展时相同)、BigQuery数据集和表前缀(不带_raw_changes)。我就是这么做的。以...开头的行。是您需要输入值的地方。</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="f10c" class="kp je hi le b fi li lj l lk ll">npx @firebaseextensions/fs-bq-import-collection<br/>? What is your Firebase project ID? zdenky-15ba5<br/>? What is the path of the the Cloud Firestore Collection you would like to import from? (This may, or may not, be the same Collection for which you plan to mir<br/>ror changes.) users<br/>? What is the ID of the BigQuery dataset that you would like to use? (A dataset will be created if it doesn't already exist) f2b<br/>? What is the identifying prefix of the BigQuery table that you would like to import to? (A table will be created if one doesn't already exist) users<br/>? How many documents should the import stream into BigQuery at once? 300<br/>Importing data from Cloud Firestore Collection: users, to BigQuery Dataset: f2b, Table: users_raw_changelog<br/>BigQuery dataset already exists: f2b<br/>BigQuery table with name users_raw_changelog already exists in dataset f2b!<br/>View with id users_raw_latest already exists in dataset f2b.<br/>Inserting 300 row(s) of data into BigQuery<br/>Inserted 300 row(s) of data into BigQuery<br/>Inserting 211 row(s) of data into BigQuery<br/>Inserted 211 row(s) of data into BigQuery<br/>---------------------------------------------------------<br/>Finished importing 511 Firestore rows to BigQuery<br/>---------------------------------------------------------</span></pre><p id="2ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照预期将数据导入到表中。时间戳是Unix纪元时间0，即1970–01–01 00:00:00，这确保了如果在此期间有一些更改(并通过云功能上传)，它不会被初始导入覆盖。表中的操作被标记为“导入”。</p><p id="bbaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在文档中所提到的，这样做的运算量是O(集合大小)，所以如果您有一个相当大的集合，如本文第一部分所述，如果您有一个想要导入的子集合，那么完全导出到BigQuery会更可靠、更快。</p><h2 id="68a4" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">在BigQuery中从批量导出导入现有文档</h2><p id="2c14" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在这种情况下，需要一个额外的步骤，那就是将列从批量导出转换为JSON数据。在下一个例子中，我将演示它在<strong class="ih hj">‘journals’</strong>子集合中的情况。提醒一下，journals子集合有四个字段:start_datetime(时间戳)、end_datetime(时间戳)、exercise_time(整数)和exercises(字符串列表)。为了将Firestore batch export中的数据插入到'<strong class="ih hj">journals _ sync _ raw _ changelog</strong>'表中，在该表中插入了所有更改，我编写了以下查询:</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="34cd" class="kp je hi le b fi li lj l lk ll">INSERT f2b.journals_sync_raw_changelog<br/>SELECT TIMESTAMP('1970-01-01 00:00:00') as timestamp,<br/>"" AS event_id, <br/>CONCAT("projects/zdenky-15b5/databases/(default)/documents/users/", TRIM(REPLACE(SPLIT(__key__.path, ',')[OFFSET(1)], '"', '')), "/journals/", __key__.name) AS document_name, <br/>"IMPORT" AS operation, <br/>TO_JSON_STRING(<br/>  STRUCT( STRUCT(UNIX_SECONDS(start_datetime) AS _seconds, 0 AS _nanoseconds) as start_datetime, <br/>  STRUCT(UNIX_SECONDS(end_datetime) AS _seconds, 0 AS _nanoseconds) AS end_datetime, <br/>  exercise_time AS exercise_time, <br/>  exercises AS exercises)<br/>) AS data<br/>FROM f2b.journals</span></pre><p id="a7f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里最复杂的部分是正确构建子集合文档的关键路径，并正确格式化时间戳以符合Firestore导出的格式。通过该查询，changelog表被填充，并且所有数据被导出。</p><p id="0d53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用包含最新数据的视图中的数据，需要从JSON字符串中解析出<strong class="ih hj">数据</strong>列。不幸的是，目前BigQuery中的JSON转换很麻烦，所以需要显式完成，数组反序列化需要通过用户定义的函数来完成。因此，要从'<strong class="ih hj"> journals </strong>'表中提取JSON数据，查询如下所示:</p><pre class="ki kj kk kl fd ld le lf lg aw lh bi"><span id="d2d5" class="kp je hi le b fi li lj l lk ll">CREATE TEMP FUNCTION json_extract_arrayx(s STRING, key STRING) RETURNS ARRAY&lt;STRING&gt; LANGUAGE js AS """<br/>    try {<br/>        var xs = JSON.parse(s)[key];<br/>        return xs == null ? null : xs.filter((x,i) =&gt; x != null).map((x,i) =&gt; x.toString());<br/>    } catch (e) {<br/>        throw e + ', on input string s: ' + s;<br/>    }<br/>""";<br/><br/>SELECT <br/>TIMESTAMP_SECONDS(CAST (JSON_EXTRACT(JSON_EXTRACT(data, '$.start_datetime'), "$._seconds") AS INT64)) AS start_datetime,<br/>TIMESTAMP_SECONDS(CAST (JSON_EXTRACT(JSON_EXTRACT(data, '$.end_datetime'), "$._seconds") AS INT64)) AS end_datetime, <br/>json_extract_arrayx(data, 'exercises') AS exercises,<br/>JSON_EXTRACT(data, '$.exercise_time') AS exercise_time<br/>FROM `f2b.journals_sync_raw_changelog`</span></pre><p id="2925" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是在视图查询中使用时，使用UDF反序列化所有JSON数据。</p><h2 id="19d5" class="kp je hi bd jf kq kr ks jj kt ku kv jn iq kw kx jr iu ky kz jv iy la lb jz lc bi translated">结论</h2><p id="ef1f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">批量导出适用于一次性或更大的集合导出，因为主要部分是通过导出批量完成的。在Github repo中，有一个如何以编程方式开始批量导出的示例。这可以在云调度器和云功能中使用，以进行定期导出。</p><p id="e6ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用云功能在线同步看起来是一个显而易见的选择，因为它基本上将Firestore的收集状态镜像到BigQuery，并且您在BigQuery中有完整的数据更新历史。根据数据量和使用情况，云功能和Firestore运营可能会产生额外费用。</p></div></div>    
</body>
</html>