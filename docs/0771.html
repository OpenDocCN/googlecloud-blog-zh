<html>
<head>
<title>How to concatenate sharded files on Google Cloud Storage automatically using Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用云功能自动连接Google云存储上的分片文件</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-write-to-a-single-shard-on-google-cloud-storage-efficiently-using-cloud-dataflow-and-cloud-3aeef1732325?source=collection_archive---------0-----------------------#2018-09-25">https://medium.com/google-cloud/how-to-write-to-a-single-shard-on-google-cloud-storage-efficiently-using-cloud-dataflow-and-cloud-3aeef1732325?source=collection_archive---------0-----------------------#2018-09-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e16b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Apache Beam中，当您使用以下命令将文本文件写出到blob存储时:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ea81" class="jm jn hi ji b fi jo jp l jq jr">beam.io.WriteToText('gs://somebucket/somedir/csv/train')</span></pre><p id="dcb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将得到许多输出碎片，如下所示:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f2f8" class="jm jn hi ji b fi jo jp l jq jr">gs://somebucket/somedir/csv/train-00214-of-00262<br/>gs://somebucket/somedir/csv/train-00215-of-00262<br/>gs://somebucket/somedir/csv/train-00216-of-00262</span></pre><p id="64fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确切的数字取决于您的数据集、工人数量等。然而，很多时候，您会想要一个输出文件，因为您使用的软件只想要一个文件。</p><p id="3bb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单的方法是告诉Beam只写出一个shard:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2656" class="jm jn hi ji b fi jo jp l jq jr">beam.io.WriteToText(options.output_prefix, <strong class="ji hj">num_shards=1</strong>)</span></pre><p id="33d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这是非常低效的。分布式系统的强大之处在于能够完全并行化工作，并且拥有单个接收器会降低您的束管道的速度。</p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es js"><img src="../Images/100735c213d17bb968ddbba6a7551b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/0*U1vGlHY0lNMjDZEW.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">我希望理论是正确的，但我现在在GitHub中有我的例子，所以谁知道呢？(xkcd的漫画)</figcaption></figure><p id="cf9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近面临这个问题，用云函数解决了(GitHub 中的<a class="ae ka" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/blogs/inference/flights/compose_shards.py" rel="noopener ugc nofollow" target="_blank">代码)。</a></p><h2 id="6a3d" class="jm jn hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">写入碎片</h2><p id="5811" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在梁管线中，指定一些碎片。我们将使用的Google云存储的“合成”功能目前有32个文件的限制，所以你不希望你的管道产生更多的文件。同时，为了提高效率，您希望拥有比数据流作业中的工人数量更多的碎片:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2fc8" class="jm jn hi ji b fi jo jp l jq jr">beam.io.WriteToText(options.output_prefix, num_shards=10)</span></pre><p id="3bef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成后，您将拥有一堆文件。你如何连接它们？</p><h2 id="ab27" class="jm jn hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">云存储构成</h2><p id="8cc7" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在GCS上连接一堆文件的简单方法是将它们下载到一个VM上，用Unix的“cat”连接它们，然后上传。不要那样做！</p><p id="e234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌云存储支持一个叫做<a class="ae ka" href="https://cloud.google.com/storage/docs/json_api/v1/objects/compose" rel="noopener ugc nofollow" target="_blank">“合成”</a>的漂亮功能:它让你用多达32个源blob合成一个blob。您可以通过命令行执行以下操作来实现这一点:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="46d0" class="jm jn hi ji b fi jo jp l jq jr">gsutil compose \<br/>  gs://${BUCKET}/somedir/csv/train* \<br/>  gs://${BUCKET}/somedir/csv/full_training_data.csv</span></pre><p id="0ab7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无需下载或本地存储！您也可以在合成后删除碎片，以避免混乱。因此，创建单个输出文件的有效方法是运行数据流作业，告诉它产生多达32个碎片，然后使用合成功能连接输出。</p><p id="b431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，您可以运行数据流作业，等待它完成，然后调用compose命令。但是，当您可以设置一个云函数，每当分片文件出现在桶中时，它就会自动为您完成这项工作，为什么还要这样做呢？</p><h2 id="def8" class="jm jn hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">云函数做作曲</h2><p id="a156" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我转到GCP web控制台，导航到云函数控制台，在我的bucket中创建一个函数来触发创建事件，选择Python 3.7作为我的首选语言，然后在main.py中键入以下Python函数:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="37ce" class="jm jn hi ji b fi jo jp l jq jr">import google.cloud.storage.client as gcs<br/>import logging</span><span id="8dd3" class="jm jn hi ji b fi kz jp l jq jr">def compose_shards(data, context):<br/>  num_shards = 10<br/>  prefix = 'somedir/csv/train'<br/>  outfile = 'somedir/csv/full_training_data.csv'<br/>  # trigger on the last file only<br/>  filename = data['name']</span><span id="a435" class="jm jn hi ji b fi kz jp l jq jr">  last_shard = '-%05d-of-%05d' % (num_shards - 1, num_shards)<br/>  if (prefix in filename and last_shard in filename):<br/>    # verify that all 10 shards exist<br/>    prefix = filename.replace(last_shard, '')<br/>    client = gcs.Client()<br/>    bucket = client.bucket(data['bucket'])<br/>    blobs = []<br/>    for shard in range(num_shards):<br/>      sfile = '%s-%05d-of-%05d' % (prefix, shard + 1, num_shards)<br/>      blob = bucket.blob(sfile)<br/>      if not blob.exists():<br/>        # this causes a retry in 60s<br/>        raise ValueError('Shard {} not present'.format(sfile))<br/>      blobs.append(blob)<br/>    # all shards exist, so compose<br/>    bucket.blob(outfile).compose(blobs)<br/>    logging.info('Successfully created {}'.format(outfile))<br/>    for blob in blobs:<br/>      blob.delete()<br/>    logging.info('Deleted {} shards'.format(len(blobs)))</span></pre><p id="88b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还勾选了失败时“重试”的复选框，并在requirements.txt中指定了“google-cloud-storage”包。</p><p id="59c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码是做什么的？它验证它是在具有我的数据流管道正在写入的前缀的文件上触发的，并且这是最后一个碎片。</p><p id="7474" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，最后一个碎片不一定是最后一个被写出的。可能存在争用情况，或者某个早期文件可能非常大。所以，我做了一点防御性编程，确保我期望的所有10个碎片都存在。我可以通过用期望的文件名构造一个Blob并检查它是否存在来实现。如果不存在，我就抛出一个异常。回想一下，我们设置了这个函数，如果是这种情况，它将在60秒后重试。</p><p id="6570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我确认所有的碎片都存在，我就可以使用API调用将blob组合成一个大blob，并删除单个blob。</p><h2 id="a780" class="jm jn hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">下午茶时间</h2><p id="8c66" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">所以，现在，当我运行我的数据流管道时，它产生了10个斑点。一旦第10个blob到达Google云存储，Cloud函数就会运行，并将所有10个blob连接成一个blob。</p><p id="e195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我吗？我可以在作业运行时去喝茶，而函数会监视作业。</p></div></div>    
</body>
</html>