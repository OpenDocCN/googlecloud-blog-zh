<html>
<head>
<title>App Engine Flex || Kubernetes Engine — ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">app Engine Flex | | Kubernetes Engine—？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/app-engine-flex-container-engine-946fbc2fe00a?source=collection_archive---------0-----------------------#2017-10-11">https://medium.com/google-cloud/app-engine-flex-container-engine-946fbc2fe00a?source=collection_archive---------0-----------------------#2017-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3153" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在GCP部署容器化应用的两种方式</h2></div><p id="2477" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户寻求我们的帮助，以确定是<a class="ae jt" href="https://cloud.google.com/appengine/docs/flexible/" rel="noopener ugc nofollow" target="_blank">App Engine Flex(ible Environment)</a>还是谷歌<a class="ae jt" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Engine </a> (GKE)最适合他们的需求。</p><p id="caf0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有放之四海而皆准的答案，我们与客户的密切联系有助于我们根据他们的需求确定最佳答案。这篇文章总结了一个很好的方法，可以帮助任何人获得答案的证据:两者都尝试。</p><p id="a775" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将使用一个范例作为解决方案，将其部署到Flex和GKE，并对这两个解决方案进行负载测试。感谢容器提供的一致性，我们将有很高的信心，每个平台的不同体验是由于平台而不是我们的解决方案。</p><p id="dbb5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们开始吧！</p><h2 id="a67c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">典范</h2><p id="677e" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">使用NoSQL商店的网络产品？对我来说听起来是对的。幸运的是，App Engine Flex文档包括一个我们可以使用的<a class="ae jt" href="https://cloud.google.com/appengine/docs/flexible/go/using-cloud-datastore" rel="noopener ugc nofollow" target="_blank">示例应用</a>(GitHub<a class="ae jt" href="https://github.com/GoogleCloudPlatform/golang-samples/tree/master/appengine_flexible/datastore" rel="noopener ugc nofollow" target="_blank">这里是</a>)。你可以选择你的语言风格；我打算用Golang，因为我最近一直在用Python和Java写东西。我们将使用云数据存储(稍后可能会使用另一个)来实现持久性。</p><h2 id="2397" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">设置</h2><p id="43c6" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">你可以通过谷歌云平台(GCP)免费开始使用<a class="ae jt" href="https://cloud.google.com/free/" rel="noopener ugc nofollow" target="_blank">。我使用的是Linux (Debian)机器，这里将展示bash命令。一切都可以从Mac或Windows机器上运行，但你的里程数可能会有所不同，因为你需要做一些工作来转换命令。</a></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="af63" class="ju jv hi kz b fi ld le l lf lg">export PROJECT=[YOUR-PROJECT-ID]<br/>export REGION=[YOUR-PREFERRED-REGION]<br/>export BILLING=[YOUR-BILLING-ID]<br/>export GITHUB=[YOUR-GITHUB-PROFILE]</span><span id="2ea7" class="ju jv hi kz b fi lh le l lf lg">mkdir -p ${HOME}/Projects/${PROJECT}<br/>cd ${HOME}/Projects/${PROJECT}</span><span id="e5cc" class="ju jv hi kz b fi lh le l lf lg">gcloud projects create $PROJECT</span><span id="36bd" class="ju jv hi kz b fi lh le l lf lg">gcloud alpha billing projects link $PROJECT \<br/>--billing-account=$BILLING</span><span id="2df3" class="ju jv hi kz b fi lh le l lf lg"># Enable Datastore<br/>gcloud services enable datastore.googleapis.com \<br/>--project=$PROJECT</span><span id="cb34" class="ju jv hi kz b fi lh le l lf lg"># Enable Kubernetes Engine<br/>gcloud services enable container.googleapis.com \<br/>--project=$PROJECT</span></pre><h2 id="c8ff" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">App Engine Flex</h2><p id="884a" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">让我们在项目中创建一个App Engine Flex应用程序。您可以使用以下命令选择一个对您最方便的GCP地区，Cloud SDK将提示您选择一个提供App Engine Flex的地区<a class="ae jt" href="https://cloud.google.com/appengine/docs/locations" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="cc7d" class="ju jv hi kz b fi ld le l lf lg">gcloud app create --project=$PROJECT</span></pre><p id="9ef1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您已经知道您的首选地区，您可以在此处指定:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="18db" class="ju jv hi kz b fi ld le l lf lg">gcloud app create --region=$REGION --project=$PROJECT</span></pre><p id="1f7b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，GCP将为您提供应用程序:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="27e9" class="ju jv hi kz b fi ld le l lf lg">WARNING: Creating an App Engine application for a project is irreversible and the region<br/>cannot be changed. More information about regions is at<br/>&lt;<a class="ae jt" href="https://cloud.google.com/appengine/docs/locations" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/appengine/docs/locations</a>&gt;.</span><span id="c208" class="ju jv hi kz b fi lh le l lf lg">Creating App Engine application in project [${PROJECT}] and region [${REGION}]....done.                                                                                                           <br/>Success! The app is now created. Please use `gcloud app deploy` to deploy your first app.</span></pre><p id="a791" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果按照说明克隆包含示例的GitHub repo，您应该会发现自己位于包含两个文件的目录中:app.yaml和datastore.go。</p><blockquote class="li lj lk"><p id="29d0" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong> app.yaml是App Engine的配置文件。Kubernetes引擎不使用该文件。</p></blockquote><p id="80d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我有点吹毛求疵，喜欢用自己的方式干净利落地创造一切:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c6ed" class="ju jv hi kz b fi ld le l lf lg">mkdir -p $HOME/Projects/$PROJECT/go/src/github.com/$GITHUB/aeoke<br/>cd $HOME/Projects/$PROJECT/go/src/github.com/$GITHUB/aeoke</span></pre><p id="be76" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将调用app.yaml。如前所述，这为App Engine服务提供了配置指导:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="03cb" class="ju jv hi kz b fi ld le l lf lg">runtime: go<br/>env: flex</span><span id="5411" class="ju jv hi kz b fi lh le l lf lg">automatic_scaling:<br/>  min_num_instances: 1</span><span id="3c9e" class="ju jv hi kz b fi lh le l lf lg">#[START env_variables]<br/>env_variables:<br/>  GCLOUD_DATASET_ID: $PROJECT<br/>#[END env_variables]</span></pre><blockquote class="li lj lk"><p id="ac6a" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>用您的项目ID替换＄PROJECT。</p><p id="13b4" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong> GCLOUD_DATASET_ID作为环境变量传递给Golang运行时，用os访问。Getenv("GCLOUD_DATASET_ID ")。这是将配置传递给容器化应用程序的最佳实践。</p></blockquote><p id="f70d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要忘了创建数据存储区。也去拉依赖关系:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0e11" class="ju jv hi kz b fi ld le l lf lg">go get ./...</span></pre><p id="51f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一切顺利，那么您应该能够部署应用程序了。您需要部署该应用程序，以充分利用它的强大功能:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1457" class="ju jv hi kz b fi ld le l lf lg">gcloud app deploy --project=$PROJECT</span><span id="d20f" class="ju jv hi kz b fi lh le l lf lg">...<br/>Successfully built b4efec18970b<br/>Successfully tagged us.gcr.io/${PROJECT}/appengine/default.20171010t153004:latest<br/>PUSH<br/>Pushing us.gcr.io/${PROJECT}/appengine/default.20171010t153004:latest<br/>The push refers to a repository [us.gcr.io/${PROJECT}/appengine/default.20171010t153004]<br/>bf419b41a797: Preparing<br/>...<br/>bf419b41a797: Pushed<br/>...</span><span id="6e2f" class="ju jv hi kz b fi lh le l lf lg">Updating service [default]...done.<br/>Deployed service [default] to [<a class="ae jt" href="https://dazwilkin-171010-flex-or-gke.appspot.com" rel="noopener ugc nofollow" target="_blank">https://${PROJECT}.appspot.com</a>]</span><span id="1e7d" class="ju jv hi kz b fi lh le l lf lg">You can stream logs from the command line by running:<br/>  $ gcloud app logs tail -s default</span><span id="8ecc" class="ju jv hi kz b fi lh le l lf lg">To view your application in the web browser run:<br/>  $ gcloud app browse</span></pre><p id="50c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经包括了一些部署细节，因为您将从上面看到部署将容器推送到存储库。具体到usr.gcr.io/${PROJECT}/appengine…，这个URL指的是GCP托管的容器注册中心，叫做<a class="ae jt" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册中心</a> (GCR)。当我们部署到Kubernetes引擎时，我们将重用这个存储库中的映像。</p><p id="907f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能希望检查云控制台以监控应用程序的状态。不要忘记用您的项目ID替换${PROJECT}:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="10d6" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://pantheon.corp.google.com/appengine/services?project=dazwilkin-171010-flex-or-gke&amp;organizationId=433637338589&amp;serviceId=default" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/appengine/services?project=${PROJECT}&amp;serviceId=default</a></span></pre><p id="80d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该会看到类似这样的内容:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/ac949a48a06ba2f0b5cf6e27e3ac4b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYIXDol_ENAXQdJlvOOIiA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:应用引擎“服务”</figcaption></figure><p id="a43e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署应用后，您可以通过从云控制台单击“默认”服务来访问它，通过其URL直接访问服务(用您的项目ID替换$PROJECT)，或使用命令“gcloud app browse”:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d745" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://dazwilkin-171010-flex-or-gke.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://${PROJECT}.appspot.com/</a></span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div class="er es mb"><img src="../Images/bc0075e307f3b6bb4897e8bcca7aaab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*oGZgs1z2gphBbnaMuslFbA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">部署到App Engine Flex的范例</figcaption></figure><p id="e209" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该探索一下控制台。</p><p id="c709" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能有兴趣查看支持我们应用程序的实例。我们在app.yaml中显式地将min_num_instances设置为“1 ”,因此，在负载微不足道的情况下，有一个单独的实例支持我们的应用程序:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="be94" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://pantheon.corp.google.com/appengine/instances?project=dazwilkin-171010-flex-or-gke&amp;organizationId=433637338589&amp;serviceId=default&amp;versionId=20171010t153004&amp;duration=PT1H&amp;instancesTablequery=%255B%255D&amp;instancesTablepage=%257B%2522t%2522%253A%2522%2522%252C%2522i%2522%253A0%257D&amp;instancesTablesize=20&amp;instancesTablesort=%255B%255D" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/appengine/instances?project=${PROJECT}&amp;serviceId=default</a></span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/55702e2c68ad43a45e35301132508c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wg3nIMdaxOTMOhjPDnn5A.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:应用引擎“实例”</figcaption></figure><p id="72f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多次刷新页面可确保在云数据存储中保存大量数据:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="acb5" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://pantheon.corp.google.com/datastore/entities/query?project=dazwilkin-171010-flex-or-gke&amp;organizationId=433637338589&amp;ns=&amp;kind=Visit" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/datastore/entities/query?project=${PROJECT}&amp;kind=Visit</a></span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es md"><img src="../Images/2bfb503a9bf52acf388dfe121407fd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hzlrp17PwOlHY2DglrRdHw.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:数据存储</figcaption></figure><blockquote class="li lj lk"><p id="788a" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">我们应用程序的每一次页面刷新(GET)都会向数据存储“访问”类型添加另一个实体。Golang (queryVisits)函数只查询和显示10个最近的条目。</p></blockquote><p id="d2fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，Flex部署创建了一个(Docker)容器，并使用Google Container Registry持久化它。让我们看看我们项目的容器注册页面:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9c4f" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://pantheon.corp.google.com/gcr/images/dazwilkin-171010-flex-or-gke/US/appengine/default.20171010t153004?project=dazwilkin-171010-flex-or-gke&amp;organizationId=433637338589&amp;gcrImageListquery=%255B%255D&amp;gcrImageListpage=%257B%2522t%2522%253A%2522%2522%252C%2522i%2522%253A0%257D&amp;gcrImageListsize=50&amp;gcrImageListsort=%255B%257B%2522p%2522%253A%2522uploaded%2522%252C%2522s%2522%253Afalse%257D%255D" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/gcr/images/${Project}/US/appengine/?project=</a>${PROJECT}</span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es md"><img src="../Images/be49ac19a0ea5f5158580e401b3c6039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1A9GTCrkzJVIpl_fE0wVnA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:容器注册表</figcaption></figure><p id="0f45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经深入注册表显示更多的细节。图像名称为“appengine/default”。[部署时间]”，并被赋予“最新”标签。可以通过包含sha256哈希的摘要更明确地引用该映像。</p><p id="73d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您也可以使用Cloud SDK命令找到该图像。我们将在Kubernetes引擎部署中再次使用此图片，因此记住这一点可能会有所帮助:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="866f" class="ju jv hi kz b fi ld le l lf lg">gcloud container images list \<br/>--repository=us.gcr.io/${PROJECT}/appengine \<br/>--project=$PROJECT</span></pre><p id="3bf1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于好奇，Google Container Registry使用Google云存储(GCS)来存储图像层。你可以在这里调查:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a812" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://pantheon.corp.google.com/storage/browser?project=dazwilkin-171010-flex-or-gke&amp;organizationId=433637338589" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/storage/browser?project=$</a>{PROJECT}</span></pre><h2 id="22b1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">谷歌Kubernetes引擎(GKE)</h2><p id="f227" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">让我们首先创建一个集群，我们可以在其上部署Exemplar应用程序。</p><p id="572d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了保持一致性，我们将使用带有1个vCPU和1GB RAM的定制机器类型，因为这正是App Engine Flex所使用的。我们将从1个(worker)节点开始。GKE为我们管理主节点，但是主节点不用于运行我们的容器。我建议使用与App Engine相同的区域(最好是相同的区域)。在这种情况下，我使用us-east4，App Engine使用区域“c”。与App Engine一样，我将启用GKE自动扩展，但我们需要(有效地)提供最大节点数作为自动扩展的上限。我在这里选择了10个节点，但是您可能希望使用一个更小的数字。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0bd2" class="ju jv hi kz b fi ld le l lf lg">export CLUSTER=[YOUR-CLUSTER-ID]<br/>export ZONE=${REGION}-c</span><span id="903c" class="ju jv hi kz b fi lh le l lf lg">gcloud container clusters create $CLUSTER \<br/>--enable-kubernetes-alpha \<br/>--project=$PROJECT \<br/>--zone=$ZONE \<br/>--machine-type=custom-1-1024 \<br/>--image-type=COS \<br/>--num-nodes=1 \<br/>--enable-autoscaling \<br/>--max-nodes=10 \<br/>--quiet</span></pre><blockquote class="li lj lk"><p id="92b1" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">GKE提供了两种风格的自动缩放。第一个是Kubernetes的固有特性，允许随着服务负载的增加创建更多的pods。构成集群的节点数量保持不变。第二种(由enabled-autoscaling指定)使用集群自动缩放。顾名思义，我们现在允许集群随着需求的变化而增长(和收缩)。这会导致向群集中添加更多节点以扩大群集，以及从群集中删除节点以缩小群集。有了更多的节点，就有更多的容量来运行更多的单元。</p></blockquote><p id="5e24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建集群后，您可以在云控制台中观察它:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7dbb" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://pantheon.corp.google.com/kubernetes/list?project=dazwilkin-171010-flex-or-gke&amp;organizationId=433637338589&amp;persistent_volume_claim_tablequery=%255B%255D&amp;persistent_volume_claim_tablepage=%257B%2522t%2522%253A%2522%2522%252C%2522i%2522%253A0%257D&amp;persistent_volume_claim_tablesize=50&amp;persistent_volume_claim_tablesort=%255B%257B%2522p%2522%253A%2522metadata%252Fname%2522%252C%2522s%2522%253Atrue%257D%255D" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/kubernetes/list?project=</a>${PROJECT}</span></pre><p id="61a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了从命令行控制集群，我们需要对其进行认证。这通过云SDK (gcloud)便利命令来实现:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="cd45" class="ju jv hi kz b fi ld le l lf lg">gcloud container clusters get-credentials $CLUSTER \<br/>--zone=$ZONE \<br/>--project=$PROJECT</span></pre><p id="474e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要检查一切是否正常工作:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a3f8" class="ju jv hi kz b fi ld le l lf lg">kubectl get nodes</span><span id="9795" class="ju jv hi kz b fi lh le l lf lg">NAME                                        STATUS    AGE<br/>gke-cluster-01-default-pool-001b0e59-8dk8   Ready     56s</span></pre><p id="adca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">可选</strong>:你可以使用<a class="ae jt" href="https://github.com/kubernetes/dashboard" rel="noopener ugc nofollow" target="_blank"> Kubernetes仪表盘</a>控制集群。GKE使用集群部署仪表板。要访问仪表板，请配置API服务器的代理，然后在浏览器中打开URL。我使用port=0来随机获得一个可用端口。在这种情况下，选择的端口是42545。您应该使用运行命令时提供给您的任何端口:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e00e" class="ju jv hi kz b fi ld le l lf lg">kubectl proxy --port=0 &amp; </span><span id="70b3" class="ju jv hi kz b fi lh le l lf lg">Starting to serve on 127.0.0.1:42545</span></pre><p id="f43f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦代理运行，您就可以访问根目录(“/”)上的API服务器和“/ui”上的UI仪表板:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="645c" class="ju jv hi kz b fi ld le l lf lg">http://localhost:42545/ui</span></pre><p id="15c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我目前有一个小问题，UI不能正确呈现，所以我将提供一些关于云控制台和命令行的例子:-(</p><blockquote class="li lj lk"><p id="cfc6" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated"><strong class="iz hj">更新</strong>:UI问题正在<a class="ae jt" href="https://github.com/kubernetes/kubernetes/pull/52922" rel="noopener ugc nofollow" target="_blank">解决</a>。在使用“/”进行重定向后，您应该能够通过显式确定URL来访问UI，因此:</p><p id="03af" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">/API/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy<strong class="iz hj">/</strong></p><p id="118d" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">还有…</p></blockquote><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es me"><img src="../Images/cc2ce57b7363645e8f70e3cb6405f16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuuEZZnZXQ-lb9msQ6wEcA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Kubernetes UI幸福！</figcaption></figure><p id="93b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我会在这篇文章的最后添加一些这个界面的截图。</p><p id="5347" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过App Engine Flex部署，我们在GCR有一个可以重用的现有映像。将它变成GKE上的服务的最简单的方法是引用部署中的映像，将部署公开为服务，然后让GCP创建一个HTTP/S负载均衡器。</p><p id="bccf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请检查您的App Engine Flex部署，以确定App Engine Flex为您创建的容器映像的名称。您将需要引用部署YAML文件中的映像:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d437" class="ju jv hi kz b fi ld le l lf lg">us.gcr.io/$PROJECT/appengine/default/YYMMDDtHHMMSS:latest</span></pre><p id="4302" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，您可以使用以下命令找到图像名称。我们将使用标有“最新”的版本。因此，当我们创建部署配置时，请不要忘记在映像名称后面附加“:latest ”:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ff41" class="ju jv hi kz b fi ld le l lf lg">gcloud container images list \<br/>--repository=us.gcr.io/${PROJECT}/appengine</span></pre><p id="ef1f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在创建部署之前，我们需要创建一个<a class="ae jt" href="https://cloud.google.com/iam/docs/understanding-service-accounts" rel="noopener ugc nofollow" target="_blank">服务帐户</a>和一个密钥，并为其分配访问云数据存储的权限。然后我们必须将密钥作为秘密上传给GKE。这样，Exemplar应用程序的pod可以在需要访问云数据存储时访问密钥。</p><p id="a63f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这听起来很复杂(而且比它应该的要复杂)，但是有一个简单的模式，这里的<a class="ae jt" href="https://cloud.google.com/container-engine/docs/tutorials/authenticating-to-cloud-platform" rel="noopener ugc nofollow" target="_blank">记录了云发布/订阅的</a>。对于云数据存储，我只是稍微做了一些调整:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="cead" class="ju jv hi kz b fi ld le l lf lg">export ROBOT="gke-datastore"</span><span id="0089" class="ju jv hi kz b fi lh le l lf lg">gcloud iam service-accounts create $ROBOT \<br/>--display-name=$ROBOT \<br/>--project=$PROJECT</span><span id="0f30" class="ju jv hi kz b fi lh le l lf lg">gcloud iam service-accounts keys create ./key.json \<br/>--iam-account=${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--project=$PROJECT</span><span id="384a" class="ju jv hi kz b fi lh le l lf lg">gcloud projects add-iam-policy-binding $PROJECT \<br/>--member=serviceAccount:${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--role=roles/datastore.user</span><span id="86a6" class="ju jv hi kz b fi lh le l lf lg">kubectl create secret generic datastore-key \<br/>--from-file=key.json=./key.json<br/></span></pre><p id="5d43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以定义一个部署，它结合了GCR映像名称、上一步中创建的服务帐户密钥以及足以定义Exemplar应用程序的环境变量。</p><p id="d7bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个文件(我使用的是datastore-deployment.yaml)。将${IMAGE}替换为您的图像(us.gcr.io/$PROJECT/appengine….)的路径，将${PROJECT}替换为您的项目ID。</p><p id="bf3f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个配置中唯一真正复杂的地方是，它将前面步骤中创建的秘密公开为一个文件，pod可以通过一个环境变量(GOOGLE_APPLICATION_CREDENTIALS)引用这个文件。这个强大的机制叫做<a class="ae jt" href="https://developers.google.com/identity/protocols/application-default-credentials" rel="noopener ugc nofollow" target="_blank">应用默认凭证</a>:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0ff6" class="ju jv hi kz b fi ld le l lf lg">apiVersion: apps/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: datastore<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: datastore<br/>    spec:<br/>      volumes:<br/>      - name: google-cloud-key<br/>        secret:<br/>          secretName: datastore-key<br/>      containers:<br/>      - name: datastore<br/>        image: ${IMAGE}<br/>        ports:<br/>        - name: http<br/>          containerPort: 8080<br/>          protocol: TCP<br/>        volumeMounts:<br/>        - name: google-cloud-key<br/>          mountPath: /var/secrets/google<br/>        env:<br/>        - name: GOOGLE_APPLICATION_CREDENTIALS<br/>          value: /var/secrets/google/key.json<br/>        - name: GCLOUD_DATASET_ID<br/>          value: ${PROJECT}</span></pre><p id="0d67" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以创建部署:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c7e1" class="ju jv hi kz b fi ld le l lf lg">kubectl create --filename=datastore-deployment.yaml</span></pre><p id="7aba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一切都好，你应该被告知:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ffe9" class="ju jv hi kz b fi ld le l lf lg">deployment "datastore" created</span></pre><p id="f0ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们向部署添加一个(水平)机架自动缩放器，以允许它在达到CPU阈值(80%)时自动缩放机架数量:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="971b" class="ju jv hi kz b fi ld le l lf lg">kubectl autoscale deployment/datastore --max=20 --cpu-percent=80</span></pre><p id="baad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该能够:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a90c" class="ju jv hi kz b fi ld le l lf lg">kubectl get deployments</span><span id="1564" class="ju jv hi kz b fi lh le l lf lg">NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>datastore   1         1         1            0           2m</span><span id="e61a" class="ju jv hi kz b fi lh le l lf lg">kubectl get replicasets</span><span id="5cb7" class="ju jv hi kz b fi lh le l lf lg">NAME                   DESIRED   CURRENT   READY     AGE<br/>datastore-3517606568   1         1         0         2m</span><span id="9208" class="ju jv hi kz b fi lh le l lf lg">kubectl get pods</span><span id="9274" class="ju jv hi kz b fi lh le l lf lg">NAME                         READY     STATUS    RESTARTS<br/>datastore-3517606568-8ffn2   1/1       Running   0</span></pre><p id="8dd4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还可以使用云控制台观察此部署:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mf"><img src="../Images/aa60947a5b1f57960b5c34f120b86b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkRanQ06g4RjUZFdnptJ-A.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:Kubernetes引擎“工作负载”</figcaption></figure><p id="2e61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在需要向这个部署添加一个服务‘单板’,并使用HTTP/S负载平衡器上的入口公开结果。我们可以简单地从命令行做到这一点:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="28d5" class="ju jv hi kz b fi ld le l lf lg">kubectl expose deployment/datastore \<br/>--type=NodePort \<br/>--port=9999 \<br/>--target-port=8080</span></pre><p id="e532" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们可以创建一个入口。这将在GCP上创建一个HTTP/S负载均衡器，指向我们的服务……一切正常……应该允许我们访问以前的Flex-only服务，作为新部署的GKE服务。</p><p id="5f57" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个文件(我使用的是datastore-ingress.yaml):</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="4825" class="ju jv hi kz b fi ld le l lf lg">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: datastore<br/>spec:<br/>  backend:<br/>    serviceName: datastore<br/>    servicePort: 9999</span></pre><p id="aa9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后创建入口:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6866" class="ju jv hi kz b fi ld le l lf lg">kubectl create --filename=datastore-ingress.yaml</span></pre><p id="22a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦入口报告了一个外部地址，您应该能够使用它访问服务。在我的例子中(你的会不同)公共IP地址是107.178.252.137:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3399" class="ju jv hi kz b fi ld le l lf lg">kubectl get ingress/datastore</span><span id="2102" class="ju jv hi kz b fi lh le l lf lg">NAME        HOSTS     ADDRESS           PORTS     AGE<br/>datastore   *         107.178.252.137   80        6m</span></pre><p id="9cd6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过多种方式查看入口:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es md"><img src="../Images/0d6dea98691996ad7cd44dbda3b0fcd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_j1g8EXuLz977flDimEE3g.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:Kubernetes引擎“负载平衡”</figcaption></figure><p id="aac9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你也可以检查“网络服务”,在那里你会看到(可能)创建了2个HTTP/S负载平衡器。一个是由App Engine Flex创建的(习惯上称为“aef-um”)。第二个是由GKE创建的入口(习惯上叫做“k8s-um-default…”):</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9dc1" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://pantheon.corp.google.com/net-services/loadbalancing/loadBalancers/list?project=dazwilkin-171010-flex-or-gke&amp;organizationId=433637338589" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/net-services/loadbalancing/loadBalancers/list?$</a>{PROJECT}</span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/7030e87bd5045af8d2845e672d6add8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnmlRfnyRlxwaVMxVJ2b4A.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:网络服务“负载平衡”</figcaption></figure><p id="b59e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>此处定义的IP:Port与描述数据存储入口提供的IP地址相匹配(如您所料)。您的IP地址和其他详细信息可能会有所不同，但您应该使用您的IP地址:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d9ef" class="ju jv hi kz b fi ld le l lf lg">http://107.178.252.137/</span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mg"><img src="../Images/5b91154675dce56978a382b9d223c274.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*JbByA2vqvJX32KyIHxMMUQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">工作！</figcaption></figure><p id="fba0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们采用由App Engine Flex部署创建的映像，并在GKE的部署中重用它。部署完成后，我们使用GKE的入口将部署公开为HTTP/S负载平衡器。</p><p id="2b9b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在有同一个容器的两个部署，可以对它们进行负载测试，看看每个服务在负载下的表现。</p><blockquote class="li lj lk"><p id="d4ef" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated"><strong class="iz hj">一旁的</strong></p><p id="a662" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">App Engine Flex将容器注册表中的容器映像部署到由托管实例组自动扩展并通过HTTP/S负载平衡器公开的计算引擎虚拟机。</p><p id="2b67" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">Kubernetes引擎将容器注册表中的容器映像部署到计算引擎虚拟机，虚拟机由托管实例组自动扩展，并通过HTTP/S负载平衡器公开。</p><p id="cd8f" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">两个服务的底层资源(正确地说)是相同的。</p><p id="01ce" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">两种服务都使用声明式(有意)配置。</p><p id="de5c" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">这两种服务之间的一个重要区别是，App Engine Flex偏向于由谷歌控制自动化，而Kubernetes Engine需要客户更多的监督。Kubernetes引擎发展更快，并增加了更强大的自动化。</p><p id="853d" class="ix iy ll iz b ja jb ij jc jd je im jf lm jh ji jj ln jl jm jn lo jp jq jr js hb bi translated">一个微妙的区别是Flex使用容器作为达到目的的手段。通常，Flex的用户可以忽略容器的使用，因为这是在后台完成的。顾名思义，Kubernetes Engine是基于容器的，并且被明确设计为一种工具，用于方便管理从容器构建的服务。使用Flex，一个服务总是一种类型的n个容器。使用Kubernetes引擎，一个服务包含m-pod，而pod本身可能包含p-container。</p></blockquote><h2 id="31db" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">负载测试</h2><p id="1548" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">你们当中比我更精明的人会意识到，当我们考虑负载测试时，我已经引入了一个差异。虽然App Engine Flex落后于TLS，但Kubernetes Engine应用程序(目前)并不落后。让我们解决这个问题！</p><p id="cb8d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有许多方法可以达到这个目标，但这个方法是最简单的。我们将需要创建一个证书，作为一个秘密上传到GKE，然后修改入口引用它。我假设你有一个可以使用的域名。我会用云DNS。</p><p id="1825" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从决定GKE应用程序的名称开始。我将使用“gke.dazwilkin.com ”,并将它作为gke入口创建的HTTP/S负载平衡器的IP地址的别名:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/633c5834363306e225b0837284df89ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x32hzAs7aGmBsR2PltOA1Q.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:网络服务“云DNS”</figcaption></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e873" class="ju jv hi kz b fi ld le l lf lg">export NAME=[YOUR-DNS-NAME] // Mine is gke.dazwilkin.com</span><span id="fb2d" class="ju jv hi kz b fi lh le l lf lg">mkdir -p $HOME/Projects/$PROJECT/certs<br/>cd $HOME/Projects/$PROJECT/certs</span></pre><p id="4604" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用的是Google Cloud DNS，您的DNS更改将最快速地通过Google的公共DNS进行访问，您可以使用以下内容进行查询:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6610" class="ju jv hi kz b fi ld le l lf lg">nslookup ${NAME} 8.8.8.8</span><span id="9162" class="ju jv hi kz b fi lh le l lf lg">Server:  8.8.8.8<br/>Address: 8.8.8.8#53</span><span id="30de" class="ju jv hi kz b fi lh le l lf lg">Non-authoritative answer:<br/>Name: ${NAME}<br/>Address: ${IP} // The IP address of the HTTP/S Load-Balancer</span></pre><p id="d5fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有了一个DNS名称，我们可以使用openssl来生成一个证书进行测试。这不是你在生产中应该做的。我推荐<a class="ae jt" href="https://letsencrypt.org" rel="noopener ugc nofollow" target="_blank">让我们加密</a>或者其他cert authority。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e404" class="ju jv hi kz b fi ld le l lf lg">openssl req \<br/>-x509 \<br/>-nodes \<br/>-days 365 \<br/>-newkey rsa:2048 \<br/>-keyout ${NAME}.key \<br/>-out ${NAME}.crt \<br/>-subj '/CN=${NAME}'</span></pre><p id="a3ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以使用bash的这一优点进行base64编码，然后将“key”和“crt”文件作为GKE秘密上传，命名为我们的DNS名称:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b447" class="ju jv hi kz b fi ld le l lf lg">echo "<br/>apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: ${NAME}<br/>data:<br/>  tls.crt: `base64 --wrap 0 ./${NAME}.crt`<br/>  tls.key: `base64 --wrap 0 ./${NAME}.key`<br/>" | kubectl create --filename -</span></pre><p id="85e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们需要调整入口，通过引用秘密来包含证书:</p><p id="02be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开您的入口配置(我使用的是' datastore-ingress.yaml ')，用您的DNS名称替换$NAME，保存它:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3f2d" class="ju jv hi kz b fi ld le l lf lg">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: datastore<br/>spec:<br/>  tls:<br/>  - secretName: ${NAME}<br/>  backend:<br/>      serviceName: datastore<br/>      servicePort: 9999</span></pre><p id="6949" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后—你会得到一个警告，但你可能会忽略它—</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="f519" class="ju jv hi kz b fi ld le l lf lg">kubectl apply --filename=datastore-ingress.yaml</span></pre><p id="d9e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您刷新显示负载平衡器的云控制台页面。您应该会看到一个“HTTPS”前端添加到了GKE负载平衡器:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/39c8ea5c090fa9141c65c481599e6ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mrZGCYHuskPSwZbHpMRSw.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:网络服务“负载平衡”</figcaption></figure><p id="c6bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一切正常，您现在应该能够通过TLS访问GKE上的示例解决方案:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d099" class="ju jv hi kz b fi ld le l lf lg">curl --insecure https://${NAME}</span></pre><p id="7dc4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的。让我们给每个服务增加一些负载，看看会发生什么。您可以使用<a class="ae jt" href="http://httpd.apache.org/docs/current/programs/ab.html" rel="noopener ugc nofollow" target="_blank"> Apache的基准测试工具</a>“ab”，但是，我将使用‘wrk’(<a class="ae jt" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank">链接</a>):</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="01d3" class="ju jv hi kz b fi ld le l lf lg">cd $HOME/Projects/$PROJECT/<br/>git clone <a class="ae jt" href="https://github.com/wg/wrk.git" rel="noopener ugc nofollow" target="_blank">https://github.com/wg/wrk.git</a><br/>cd wrk &amp;&amp; make</span><span id="ceb6" class="ju jv hi kz b fi lh le l lf lg">./wrk<br/>Usage: wrk &lt;options&gt; &lt;url&gt;                            <br/>  Options:                                            <br/>    -c, --connections &lt;N&gt;  Connections to keep open   <br/>    -d, --duration    &lt;T&gt;  Duration of test           <br/>    -t, --threads     &lt;N&gt;  Number of threads to use   <br/>                                                      <br/>    -s, --script      &lt;S&gt;  Load Lua script file       <br/>    -H, --header      &lt;H&gt;  Add header to request      <br/>        --latency          Print latency statistics   <br/>        --timeout     &lt;T&gt;  Socket/request timeout     <br/>    -v, --version          Print version details      <br/>                                                      <br/>  Numeric arguments may include a SI unit (1k, 1M, 1G)<br/>  Time arguments may include a time unit (2s, 2m, 2h)</span></pre><p id="bd1d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从应用引擎Flex开始:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0a3d" class="ju jv hi kz b fi ld le l lf lg">./wrk \<br/>--threads=10 \<br/>--connections=250 \<br/>--duration=60s \<br/><a class="ae jt" href="https://dazwilkin-171010-flex-or-gke.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://${PROJECT}.appspot.com/</a></span></pre><p id="0303" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与任何负载测试一样，多次运行相同的测试是值得的。这是我的第一组结果。最上面一行是650 RPS(μ= 380毫秒δ= 77毫秒)</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="621d" class="ju jv hi kz b fi ld le l lf lg">Running 1m test @ <a class="ae jt" href="https://dazwilkin-171010-flex-or-gke.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://${PROJECT}.appspot.com/</a><br/>  10 threads and 250 connections<br/>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br/>    Latency   380.96ms   76.89ms   1.03s    83.37%<br/>    Req/Sec    66.71     31.44   240.00     64.34%<br/>  39336 requests in 1.00m, 71.94MB read<br/>Requests/sec:    654.64<br/>Transfer/sec:      1.20MB</span></pre><p id="d921" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，针对GKE的命令的唯一区别是使用${NAME}:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a1cd" class="ju jv hi kz b fi ld le l lf lg">./wrk \<br/>--threads=10 \<br/>--connections=250 \<br/>--duration=60s \<br/><a class="ae jt" href="https://${PROJECT}.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://${NAME}/</a></span></pre><p id="8a45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果呢。最上面一行是1420 RPS(μ= 175毫秒δ= 20毫秒):</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="42a7" class="ju jv hi kz b fi ld le l lf lg">Running 1m test @ <a class="ae jt" href="https://flex-or-gke.dazwilkin.com/" rel="noopener ugc nofollow" target="_blank">https://flex-or-gke.dazwilkin.com/</a><br/>  10 threads and 250 connections<br/>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br/>    Latency   175.39ms   19.73ms   1.17s    82.62%<br/>    Req/Sec   143.15     27.74   232.00     68.37%<br/>  85459 requests in 1.00m, 62.99MB read<br/>Requests/sec:   1422.64<br/>Transfer/sec:      1.05MB</span></pre><p id="8fc3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一次运行中，GKE的吞吐量是Flex的两倍(延迟减半),延迟分布更加紧密(5倍)。</p><p id="b150" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二次运行测试并进行监控…10分钟，25个线程和250个连接…</p><p id="afaa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">App Engine Flex实现了1740 RPS(μ= 150毫秒δ= 80毫秒)</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6ae5" class="ju jv hi kz b fi ld le l lf lg">./wrk \<br/>--threads=25 \<br/>--connections=250 \<br/>--duration=600s \<br/><a class="ae jt" href="https://${PROJECT}.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://${PROJECT}.appspot.com/</a></span><span id="64a3" class="ju jv hi kz b fi lh le l lf lg">Running 10m test @ <a class="ae jt" href="https://dazwilkin-171010-flex-or-gke.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://{$PROJECT}.appspot.com/</a><br/>  25 threads and 250 connections<br/>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br/>    Latency   148.86ms   82.94ms   1.98s    82.34%<br/>    Req/Sec    70.52     29.78   130.00     59.61%<br/>  1045679 requests in 10.00m, 1.87GB read<br/>Requests/sec:   1742.51<br/>Transfer/sec:      3.19MB</span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div class="er es mh"><img src="../Images/0fb0b73e10f9fcb32e8132d8d8c329bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*XBsfTfV2FLpMLre4XqWLbw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">堆栈驱动程序监控:应用程序引擎</figcaption></figure><p id="aba7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不是小事(对我来说？)来为GKE制定同等的衡量标准，但这是我最大的努力。GKE达到了1350转/秒(μ= 180毫秒δ= 20毫秒):</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="97c5" class="ju jv hi kz b fi ld le l lf lg">./wrk \<br/>--threads=25 \<br/>--connections=250 \<br/>--duration=600s \<br/><a class="ae jt" href="https://${NAME}/" rel="noopener ugc nofollow" target="_blank">https://${NAME}/</a></span><span id="076c" class="ju jv hi kz b fi lh le l lf lg">Running 10m test @ <a class="ae jt" href="https://flex-or-gke.dazwilkin.com/" rel="noopener ugc nofollow" target="_blank">https://${NAME}/</a><br/>  25 threads and 250 connections<br/>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br/>    Latency   184.78ms   22.99ms   1.27s    86.09%<br/>    Req/Sec    54.26     16.20   101.00     78.38%<br/>  812839 requests in 10.00m, 599.13MB read<br/>  Socket errors: connect 0, read 1, write 0, timeout 0<br/>Requests/sec:   1354.51<br/>Transfer/sec:      1.00MB</span></pre><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mi"><img src="../Images/a0b9950e711bdb23f120b80a14d3f936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnRBmiqUHwquZ6tPZoHaiA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:网络服务“负载平衡”</figcaption></figure><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mj"><img src="../Images/b599e36140daf4d350cfcdb8f334db1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMs_SNnT2TiZtwSl-L9jMQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Stackdriver自定义仪表板</figcaption></figure><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mk"><img src="../Images/4466f892a1f2727bda3defbff1b8e5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKUMoaHG9WmNrihZ6m1CMA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:计算引擎“虚拟机实例”</figcaption></figure><figure class="ku kv kw kx fd lq er es paragraph-image"><div class="er es ml"><img src="../Images/9cad6b8280f2cfe2eda68d68eb378256.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*fo-FbZ1h4L5hqlp_4nKxdA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云控制台:Kubernetes引擎“工作负载”</figcaption></figure><p id="c098" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了GKE，我会收到来自负载均衡器的“使用率已满”的通知，这让我很惊讶。GKE没有向池中添加节点(我认为应该添加)…啊，我只是不耐烦了…将虚拟机数量增加到3个，将pod数量增加到8个:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div class="er es mm"><img src="../Images/e9013571bb09aef6c44538b47a22d682.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*ChloInGHNG7ib1g7edgaRw.png"/></div></figure><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mn"><img src="../Images/83011f3bab5b879d327443069d11b0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0T_aWcYprlWFp3UlrpUhw.png"/></div></div></figure><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mo"><img src="../Images/b284c1a5f645272350585b07a2c00da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHF-APh-RpwqMsnU_j8C7w.png"/></div></div></figure><h2 id="7afc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论</h2><ul class=""><li id="cd8e" class="mp mq hi iz b ja kp jd kq jg mr jk ms jo mt js mu mv mw mx bi translated">将App Engine Flex部署迁移到GKE是可行的</li><li id="2c16" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">在这种情况下(！)Flex实现了比GKE更高的吞吐量。</li><li id="4639" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">速度增加是因为App引擎能够快速发出自动缩放事件信号；GKE可以在现有的节点群集中快速扩展pod，但扩展节点数量的速度稍慢。</li><li id="5e61" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">App Engine和GKE共享基本的GCP资源，包括HTTP/S负载平衡器服务和托管基础架构组自动扩展。</li><li id="b864" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">对于相同的负载，使用相同的虚拟机大小(1个vCPU和1GB RAM):应用引擎灵活扩展到6个实例虚拟机上的6个容器(1个实例/虚拟机)；GKE在3个虚拟机上扩展到10个机架(1个集装箱/机架)(50%)。</li><li id="0e86" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">我仍在努力寻找更好的方法来提供可比的监控。</li></ul><h2 id="12b4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">Kubernetes用户界面</h2><p id="13b5" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">有一个进入Kubernetes仪表板的临时黑客。将最后一个“/”添加到代理重定向到的URL。然后:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/d729a7a8b22b2795cf8b7eee41b8e315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWHNUEjSHTqlmUa8zEn75g.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Kubernetes仪表板</figcaption></figure><p id="a146" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仪表板提供了Kubernetes特有的UI，我是它的粉丝。</p><p id="c248" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，您可以看到该群集正在向GKE施加压力，以自动扩展… 6/8个机架并阻塞CPU:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/cb9f94c0506e00a351ae61df3e0dcd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhR7sIMQ7ZV3IZ2qqVQCug.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Kubernetes仪表板:等待集群自动缩放</figcaption></figure><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/b1efc7a0e8a257bcdda9d53052fddfb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7r0T5OiJvofG3SbsmGbv9Q.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Kubernetes仪表板:缩放</figcaption></figure><p id="d9c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第二个快照中，集群已经扩展(现在有3个GCE虚拟机),能够承受8个pod的负载。</p><p id="9621" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将进行调查，但我假设这意味着80%的群集(聚合)CPU，这对应于在80% CPU上扩展的(水平)自动扩展要求:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div class="er es nd"><img src="../Images/1775f5f7c22bdf83fbb4026f659aeb98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*iukR_2stYKKbcdfuz0wnqw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Kubernetes仪表板:CPU使用率</figcaption></figure><p id="b89f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div class="er es ne"><img src="../Images/beb3b061e55dc6e9768efef02cf734de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*X_tn1QY0_pgA6XwnGB0-Mw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Kubernetes仪表板:内存使用</figcaption></figure><h2 id="6bdb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">堆栈驱动程序</h2><p id="eb95" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">最后一句话:我试图找到一种等效的方式来介绍GKE服务的衡量标准:</p><figure class="ku kv kw kx fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es nf"><img src="../Images/636268d040efd604c5ea90088cd20c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNlcZaxUQ_gLnmvSOFDGIQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">Stackdriver:自定义仪表板</figcaption></figure></div></div>    
</body>
</html>