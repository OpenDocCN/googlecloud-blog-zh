<html>
<head>
<title>Accessing Google Cloud APIs from Azure DevOps using Workload Identity Federation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作负载身份联合从Azure DevOps访问Google Cloud APIs</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/accessing-google-cloud-apis-from-azure-devops-using-workload-identity-federation-6acc5ad1a071?source=collection_archive---------0-----------------------#2022-05-03">https://medium.com/google-cloud/accessing-google-cloud-apis-from-azure-devops-using-workload-identity-federation-6acc5ad1a071?source=collection_archive---------0-----------------------#2022-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/42225508b66983e759e9e97cd278fcf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuAbdwzjYfjIr_y0ndGKFg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@rocknrollmonkey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">摇滚猴子</a>在<a class="ae iu" href="https://unsplash.com/s/photos/robot-identity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a97f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在探索如何从Azure DevOps访问Google Cloud APIs时，我发现了一种方法，我想与您分享一下使用服务主体和服务连接的方法。为了自己实现它，你需要一个Azure订阅。一般来说，当使用谷歌云平台(GCP)时，你希望<a class="ae iu" href="https://cloud.google.com/iam/docs/best-practices-for-managing-service-account-keys#alternatives" rel="noopener ugc nofollow" target="_blank">避免导出服务账户密钥</a>。我们将使用GCP <a class="ae iu" href="https://cloud.google.com/iam/docs/workload-identity-federation" rel="noopener ugc nofollow" target="_blank">工作负载身份联盟</a>来允许Azure DevOps管道访问GCP API。</p><p id="cd8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的第一个方法是使用由Azure DevOps为每个作业提供的<a class="ae iu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens" rel="noopener ugc nofollow" target="_blank">作业访问令牌</a>。但是发行者是以不符合OIDC的方式格式化的(没有领先的模式)，JWT的公钥无处可寻，并且发行者没有在<code class="du jt ju jv jw b">.well-known/openid-configuration</code>下导出openid配置(事实上它没有公开任何OIDC配置)。所以这意味着现在，我们需要走另一条路。</p><p id="f414" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Azure DevOps中，您可以创建服务连接，这允许您使用服务主体与Azure进行交互。由于这依赖于Azure Active Directory，它是一个OIDC兼容的身份提供者，所以这种方法将与工作负载身份联合一起工作。</p><h2 id="36b6" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">在Azure DevOps和Azure中设置</h2><p id="1c7d" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">请注意，我不是Azure专家。一个真正的Azure专家可能会对服务主体以及如何设置它们有自己的看法。</p><p id="f2e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，为了设置好一切，请转到Azure DevOps项目，配置一个新的“Azure Resource Manager”(<code class="du jt ju jv jw b">Project Settings &gt; Pipelines &gt; Service Connections &gt; New Service Connection</code>)类型的服务连接。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/e49cecb939209374c43900e7f509bbac.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*pjsHMMPPj5v_gpxBm518xg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">创建Azure资源管理器类型服务连接</figcaption></figure><p id="e0e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用新创建的或已经生成的服务主体进行设置。我选择了自动选项，因为它是向导推荐给我的。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/75c5cb6c2062debdf753c48c5844f67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giRRsovfEpRHQDqE1kVjmA.png"/></div></div></figure><p id="d53d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要从服务连接的服务主体中提取一些id。选择您的服务连接，然后单击“管理服务主体”。这将把你带到Azure门户。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/8f72be2035b39b7e6c357ee556a9dfc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Svut_appkJHQdpObo7HFEA.png"/></div></div></figure><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/6e86c1130f1111faeee2291535398e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFRe2AZ4E5lxXKknIj3Vaw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">为了使JWT包含受众声明，您需要设置应用程序ID URI</figcaption></figure><p id="0e7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在接下来的步骤中，您需要捕获应用程序(客户机)ID和目录(租户)ID。您还应该设置一个应用程序ID URI，因此单击“添加一个应用程序ID URI”，然后在下一个屏幕上单击“设置”。在我的测试中，如果没有应用程序ID URI集，JWT不包含受众声明。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/964a187b2cfb3bc62b751a4eec7269fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RcXSVCvRU3PJMDKogAF5w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">设置应用程序ID URI，似乎对于这个流，建议的值是可以的</figcaption></figure><h2 id="2aef" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">Google Cloud中的设置</h2><p id="be08" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在GCP，我们需要为Azure订阅配置工作负载身份联合，并允许服务主体模拟GCP服务帐户。你可以在<a class="ae iu" href="https://cloud.google.com/iam/docs/configuring-workload-identity-federation#create_the_workload_identity_pool_and_provider" rel="noopener ugc nofollow" target="_blank"> GCP文档</a>中找到一个关于如何设置它的很好的指南，所以我将在这里重点关注一个简短的指南，重点是我们需要什么来使Azure DevOps/GCP集成工作。</p><pre class="ky kz la lb fd lg jw lh li aw lj bi"><span id="fc98" class="jx jy hi jw b fi lk ll l lm ln"># Create a workload identity pool<br/>gcloud iam workload-identity-pools create azure \<br/>    --location="global" \<br/>    --display-name="Azure"</span><span id="1dd4" class="jx jy hi jw b fi lo ll l lm ln"># Create a workload identity provider for the Azure Tenant<br/>gcloud iam workload-identity-pools providers create-oidc azure \<br/>    --location="global" \<br/>    --workload-identity-pool="azure" \<br/>    --issuer-uri="https://sts.windows.net/&lt;azure_tenant_id&gt;/" \<br/>    --attribute-mapping="google.subject=assertion.appid" \<br/>    --allowed-audiences="https://management.core.windows.net/"</span><span id="e83d" class="jx jy hi jw b fi lo ll l lm ln"># Create a Service Account and allow the Azure Service Principal to access it<br/>gcloud iam service-accounts create SERVICE_ACCOUNT_ID</span><span id="8bc6" class="jx jy hi jw b fi lo ll l lm ln">PRINCIPAL="principal://iam.googleapis.com/projects/&lt;project_number&gt;/locations/global/workloadIdentityPools/&lt;pool_id&gt;/subject/&lt;azure_app_id&gt;"</span><span id="4ed4" class="jx jy hi jw b fi lo ll l lm ln">gcloud iam service-accounts add-iam-policy-binding \<br/>    SERVICE_ACCOUNT_ID@PROJECT_ID.iam.gserviceaccount.com \<br/>    --member="$PRINCIPAL" \<br/>    --role="roles/iam.serviceAccountUser"</span><span id="cb5b" class="jx jy hi jw b fi lo ll l lm ln">gcloud iam service-accounts add-iam-policy-binding \<br/>    SERVICE_ACCOUNT_ID@PROJECT_ID.iam.gserviceaccount.com \<br/>    --member="$PRINCIPAL" \<br/>    --role="roles/iam.serviceAccountUser"</span></pre><p id="3170" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里需要指出的是:我们使用服务主体的App ID作为属性映射的主题。</p><h2 id="079f" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">我们的Azure DevOps管道</h2><p id="73da" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">请确保在服务连接的安全配置上，管道可以访问服务连接。下面是一个简单的示例管道，它使用AzureCLI任务来检索服务主体的Azure令牌，然后使用工作负载身份联合将其与服务帐户令牌进行交换。最后，调用一个内省端点来显示令牌工作正常。</p><pre class="ky kz la lb fd lg jw lh li aw lj bi"><span id="75ca" class="jx jy hi jw b fi lk ll l lm ln">name: $(Date:yyyyMMdd)$(Rev:.r)</span><span id="3945" class="jx jy hi jw b fi lo ll l lm ln">trigger:<br/>  - main</span><span id="80c7" class="jx jy hi jw b fi lo ll l lm ln">stages:<br/>  - stage: auth<br/>    displayName: "GCP WIF Auth"<br/>    jobs:<br/>      - job: demo<br/>        timeoutInMinutes: 20<br/>        steps:<br/>          - task: AzureCLI@2<br/>            inputs:<br/>              azureSubscription: '&lt;service_connection_name&gt;'<br/>              scriptType: 'bash'<br/>              scriptLocation: 'inlineScript'<br/>              inlineScript: |<br/>                SUBJECT_TOKEN_TYPE="urn:ietf:params:oauth:token-type:jwt"<br/>                SUBJECT_TOKEN=$(az account get-access-token --query accessToken --output tsv)<br/>                STS_TOKEN=$(curl --silent -0 -X POST <a class="ae iu" href="https://sts.googleapis.com/v1/token" rel="noopener ugc nofollow" target="_blank">https://sts.googleapis.com/v1/token</a> \<br/>                    -H 'Content-Type: text/json; charset=utf-8' \<br/>                    -d @- &lt;&lt;EOF | jq -r .access_token<br/>                    {<br/>                        "audience"           : "//iam.googleapis.com/projects/&lt;project_number&gt;/locations/global/workloadIdentityPools/&lt;pool_id&gt;/providers/&lt;provider_id&gt;",<br/>                        "grantType"          : "urn:ietf:params:oauth:grant-type:token-exchange",<br/>                        "requestedTokenType" : "urn:ietf:params:oauth:token-type:access_token",<br/>                        "scope"              : "<a class="ae iu" href="https://www.googleapis.com/auth/cloud-platform" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-platform</a>",<br/>                        "subjectTokenType"   : "$SUBJECT_TOKEN_TYPE",<br/>                        "subjectToken"       : "$SUBJECT_TOKEN"<br/>                    }<br/>                EOF)<br/>                echo $STS_TOKEN<br/>                ACCESS_TOKEN=$(curl --silent -0 -X POST <a class="ae iu" href="https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/" rel="noopener ugc nofollow" target="_blank">https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/</a>&lt;service_account_email&gt;:generateAccessToken \<br/>                    -H "Content-Type: text/json; charset=utf-8" \<br/>                    -H "Authorization: Bearer $STS_TOKEN" \<br/>                    -d @- &lt;&lt;EOF | jq -r .accessToken<br/>                    {<br/>                        "scope": [ "<a class="ae iu" href="https://www.googleapis.com/auth/cloud-platform" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-platform</a>" ]<br/>                    }<br/>                EOF)<br/>                echo $ACCESS_TOKEN<br/>                curl -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$ACCESS_TOKEN" <a class="ae iu" href="https://www.googleapis.com/oauth2/v1/tokeninfo" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/oauth2/v1/tokeninfo</a></span></pre><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/829a6f6870bebf16d673e2c575a23a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9nAKWhEVYb3PgBoIffBqg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">管道的输出应该如下所示(我省略了标记的打印)</figcaption></figure><p id="c509" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，现在您可以从Azure DevOps访问Google Cloud APIs，而无需导出服务帐户密钥。我认为这种方法非常好，因为你可以在Azure DevOps中对哪些管道可以访问服务连接进行适当的权限控制。可能还有一些改进的空间，但这给了你一个好的起点。</p></div></div>    
</body>
</html>