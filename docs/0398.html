<html>
<head>
<title>Kubernetes: from load balancer to pod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:从负载平衡器到pod</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-from-load-balancer-to-pod-3f2399637b0c?source=collection_archive---------0-----------------------#2017-10-09">https://medium.com/google-cloud/kubernetes-from-load-balancer-to-pod-3f2399637b0c?source=collection_archive---------0-----------------------#2017-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9a0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在工作中，我们使用Kubernetes。上周五，我和一位同事聊天，我们想知道负载平衡器、服务和pods是如何协同工作的。实际上，Kubernetes概念中的<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务、负载平衡和网络</a>部分已经很好地解释了一切。然而，你可能需要阅读几遍才能理解所有的东西，所以我真的需要自己去看一看，并使用一个例子。我试图回答的基本问题是:当您将服务定义为负载均衡器时会发生什么，以及数据包如何到达我的pod中？</p><p id="2fe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，让我们从例子开始。假设我们已经定义了这个服务:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="77b6" class="jn jo hi jj b fi jp jq l jr js">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: cloud-nginx<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: cloud-nginx<br/>  ports:<br/>    - port: 80<br/>      name: http-server<br/>    - port: 443<br/>      name: https-server</span></pre><p id="3125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个名为<em class="jt"> cloud-nginx的<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer" rel="noopener ugc nofollow" target="_blank"> <em class="jt">负载均衡器</em> </a>服务。</em>该服务所针对的pods也被命名为<em class="jt"> cloud-nginx </em>(参见<em class="jt">spec . selector . app:cloud-nginx</em>)并且pods将针对端口80和443。端口80基本上重定向(带有301 HTTP返回代码)到端口443。我们的<em class="jt">负载平衡器</em>服务将自动创建一些东西:一个集群IP(只能在Kubernetes集群内部访问)和一个服务节点端口。服务节点端口暴露在集群中的每个节点上。这很重要。</p><p id="b21e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">负载平衡器在群集外部，这意味着它将拥有一个外部IP，并将数据包转发到上面创建的服务节点端口。</p><p id="b05e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据包到达节点时(在节点被称为minions之前)，这完全取决于我们正在使用哪种类型的<a class="ae jd" href="https://kubernetes.io/docs/admin/kube-proxy/" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> kube-proxy </em> </a>。有两种模式:<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-userspace" rel="noopener ugc nofollow" target="_blank"> <em class="jt">用户空间</em> </a>或<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> iptables </em> </a>。在我们的例子中，我们使用<em class="jt">用户空间</em>，正如我们从节点上运行的命令中看到的:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="056a" class="jn jo hi jj b fi jp jq l jr js"># ps auxfww | grep kube-proxy<br/>...<br/>kube-proxy --master=<a class="ae jd" href="https://35.192.156.14/" rel="noopener ugc nofollow" target="_blank">https://30.191.106.1</a>2 --kubeconfig=/var/lib/kube-proxy/kubeconfig --cluster-cidr=<a class="ae jd" href="http://10.244.0.0/14" rel="noopener ugc nofollow" target="_blank">10.244.0.0/14</a> --resource-container= --v=2 --proxy-mode=userspace 1&gt;&gt;/var/log/kube-proxy.log 2&gt;&amp;1<br/>...</span></pre><p id="e1cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一个<em class="jt">用户空间</em>代理中，<em class="jt"> kube-proxy </em>打开一个代理端口，并安装<em class="jt"> iptables </em>规则，将流量从服务节点端口重定向到代理端口。这意味着两个端口都被<em class="jt"> kube-proxy </em>打开(下面将进一步解释端口31234和32855):</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="58a0" class="jn jo hi jj b fi jp jq l jr js"># lsof -i TCP:31234 -i TCP:32855<br/>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br/>kube-prox 3822 root 22u IPv6 272416 0t0 TCP *:31234 (LISTEN)<br/>kube-prox 3822 root 23u IPv6 269708 0t0 TCP *:32855 (LISTEN)</span></pre><p id="adf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据包到达服务节点端口时，新的<em class="jt"> iptables </em>规则开始生效。这些是我上面提到的由<em class="jt"> kube-proxy </em>设置的<em class="jt"> iptables </em>规则。因此，在我们的例子中，在端口80到达外部负载均衡器的数据包将到达我们的一个节点(即服务节点端口)，一旦它到达该节点，<em class="jt"> iptables </em>规则将把数据包重定向到代理端口。</p><p id="9af5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在iptables中，我们对nat表感兴趣。您可以使用以下命令列出所有的<em class="jt"> nat </em>规则:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="de97" class="jn jo hi jj b fi jp jq l jr js"># iptables -t nat -L -n</span></pre><p id="09b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后你可以寻找特定的规则。例如，在我的集群的一个节点中，有这些<em class="jt"> iptables </em>规则:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e37d" class="jn jo hi jj b fi jp jq l jr js"># iptables -t nat -S KUBE-NODEPORT-CONTAINER<br/>...<br/>-A KUBE-NODEPORT-CONTAINER -p tcp -m comment — comment “default/cloud-nginx:http-server” -m tcp — dport 31234 -j REDIRECT — to-ports 32855<br/>...</span></pre><p id="d7e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它告诉将所有本地数据包从端口31234重定向到本地端口32855。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b8e2" class="jn jo hi jj b fi jp jq l jr js"># iptables -t nat -S KUBE-NODEPORT-HOST<br/>...<br/>-A KUBE-NODEPORT-HOST -p tcp -m comment — comment “default/cloud-nginx:http-server” -m tcp — dport 31234 -j DNAT — to-destination <a class="ae jd" href="http://10.240.0.4:32855/" rel="noopener ugc nofollow" target="_blank">10.240.0.4:32855</a><br/>...</span></pre><p id="e1e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将所有去往端口31234的分组重写并路由到端口32855处的节点的内部集群IP。</p><p id="d09a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您连接到31234或32855，您可以看到它可以工作:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="64d4" class="jn jo hi jj b fi jp jq l jr js"># nc localhost 31234<br/>GET /<br/>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;<br/>&lt;body bgcolor=”white”&gt;<br/>&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;<br/>&lt;hr&gt;&lt;center&gt;nginx/1.11.5&lt;/center&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="9e36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">iptables中使用的端口31234和32855是什么？端口31234是服务节点端口，32855是代理端口。我们还可以看到使用<em class="jt"> kubectl </em>从端口80上的负载平衡器到服务节点端口31234的映射:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="2879" class="jn jo hi jj b fi jp jq l jr js">$ kubectl get services cloud-nginx<br/>NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br/>cloud-nginx 10.0.226.161 101.195.33.220 80:31234/TCP,443:30582/TCP 1d</span></pre><p id="0fb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到<em class="jt"> iptables </em>，我们可以看到另一个有趣的规则:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="a7f6" class="jn jo hi jj b fi jp jq l jr js"># iptables -t nat -S KUBE-PORTALS-HOST<br/>...<br/>-A KUBE-PORTALS-HOST -d <a class="ae jd" href="http://104.197.38.226/32" rel="noopener ugc nofollow" target="_blank">101.195.33.220/32</a> -p tcp -m comment — comment “default/cloud-nginx:http-server” -m tcp — dport 80 -j DNAT — to-destination <a class="ae jd" href="http://10.240.0.4:32855/" rel="noopener ugc nofollow" target="_blank">10.240.0.4:32855</a><br/>....</span></pre><p id="c811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将数据包从我的负载平衡器(101.195.33.220)直接重写到代理端口32855(不需要通过服务节点端口)。</p><p id="8419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个问题还有待回答，kube-proxy 如何将数据包从端口32855转发到cloud-nginx 容器？这个难题的缺失部分是每个Kubernetes pod都有自己的IP，并且kube-proxy知道它们。出于我们的目的，我们可以用<em class="jt"> kubectl </em>获得pod IP:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8aeb" class="jn jo hi jj b fi jp jq l jr js">$ kubectl get po cloud-nginx-3tvcp -o wide<br/>NAME READY STATUS RESTARTS AGE IP NODE<br/>cloud-nginx-3tvcp 1/1 Running 0 2d 10.244.1.5 aleix-minion-group-7f52</span></pre><p id="3840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着<em class="jt"> kube-proxy </em>基本上会将所有来自端口32855的数据包转发到端口80(这是我们服务文件中指定的端口)的10.244.1.5。从该节点，我们可以验证我们可以将pod IP访问到所需的端口:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b1dc" class="jn jo hi jj b fi jp jq l jr js"># nc 10.244.1.5 80<br/>GET /<br/>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;<br/>&lt;body bgcolor=”white”&gt;<br/>&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;<br/>&lt;hr&gt;&lt;center&gt;nginx/1.11.5&lt;/center&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="17df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，从高层次的角度来看，整个过程应该是这样的:</p><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ju"><img src="../Images/5893c0b62e4c441c1c3b27d535734b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KO2-WXF-As1b6nCvpCNW9Q.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">从负载平衡器到pod</figcaption></figure><p id="a389" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面我提到过端口31234也是由<em class="jt"> kube-proxy </em>处理的，但是正如我们在图中看到的，我们并没有真正在<em class="jt"> kube-proxy </em>中使用它。如果我在<a class="ae jd" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/iptables/proxier.go#L1673" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> kube-proxy </em>代码</a>中理解正确的话，这是为了确保该端口被保留，因此其他应用程序无法获取它。</p><p id="7bb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我相信就是这样。还有另一种<em class="jt"> kube-proxy </em>模式，带有<em class="jt"> iptables </em>性能更好，我相信这是因为数据包不需要进入用户空间。然而，由于它都是基于<em class="jt"> iptables </em>的，如果数据包无法到达pod(例如，因为pod关闭)，它将不会重试，因为iptables中没有这种东西。但那是以后的事了。</p></div></div>    
</body>
</html>