<html>
<head>
<title>Google CloudBuild : Build Specific Micro Services In a MonoRepo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google CloudBuild:在MonoRepo中构建特定的微服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloudbuild-build-specific-micro-services-in-a-monorepo-63a7f961ac63?source=collection_archive---------0-----------------------#2022-08-01">https://medium.com/google-cloud/google-cloudbuild-build-specific-micro-services-in-a-monorepo-63a7f961ac63?source=collection_archive---------0-----------------------#2022-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="301e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Google CloudBuild:在MonoRepo中构建特定的微服务</h1><p id="11d3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最近，我遇到了一个团队，他们试图从头开始构建一个基于微服务的应用程序(大约25-30个服务)。他们还打算利用<a class="ae kb" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> CloudBuild </strong> </a>的能力及其卓越的特性，并将其作为他们DevOps管道的事实。</p><p id="f33e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">出现的第一个问题是代码回购策略应该是什么？一开始应该是<a class="ae kb" href="https://en.wikipedia.org/wiki/Monorepo" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">单回购</strong> </a>还是<strong class="jf hj">多回购</strong>(每个微服务一个回购)。在讨论了两者的利弊之后，我们达成了使用MonoRepos的协议。我“个人”更喜欢MonoRepo作为任何新应用程序开发的默认代码源回购策略。</p><p id="9464" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">下一个任务是建立一个新的管道——第一步是建立一个云触发器，一旦特性分支中的代码发生变化，它就会提交一个构建。最直接的问题是——有没有什么流程可以让云构建只为那些代码已更改的服务进行构建？</p><p id="2691" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">答案是肯定的，你可以通过下面的方法来实现。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/4ededf6e5adfe0b70942ee7b48b82d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*q8fKp5XmJoMhxyBJ"/></div></figure><p id="30f4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">假设您的MonoRepo目录结构如上图所示。您有两个微服务service-one和service-two，每个都有自己的cloudbuild.yaml文件、k8s清单文件、src文件夹等..</p><p id="1906" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">此外，在根目录中有一个cloudBuild文件(下面是src ),它将由云构建管道触发。这个cloudBuild将识别在其中进行更改的微服务，并且只构建特定的服务。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="24c6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这个云构建包含两个步骤。</p><p id="9be2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">步骤1: </strong>使用git builder并执行一个diff，它将提供完成更改的目录。</p><p id="0274" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">因为Cloud Build执行repo的浅层克隆，这意味着在要构建的工作区中只签出启动构建的单个提交，而不签出任何其他分支或历史。因此，您需要运行一个git fetch — depth=2 origin main</p><p id="a58a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">命令，然后运行git Diff。git diff的输出被写入本地工作区的一个文件中，以便可以传递给下一步。</p><p id="4b2d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">步骤2: </strong>使用gcloud builder并逐行读取我们在步骤1中保存的文件的输出。由于特定的云构建文件存储在每个微服务文件夹下的根目录下，我们使用“${line}/cloudbuild.yaml”构建云构建配置路径，然后使用gcloud submit命令提交构建。</p><p id="8472" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">一旦微服务构建完成，特定的微服务构建被触发，并且流水线完成。</p><p id="aa73" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你可以在这里找到样品代码<a class="ae kb" href="https://github.com/ajiteshk/MicroServicesCI-In-MonoRepo" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">。</strong></a></p></div></div>    
</body>
</html>