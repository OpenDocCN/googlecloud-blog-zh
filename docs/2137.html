<html>
<head>
<title>Long running job with Cloud Workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云工作流的长期运行作业</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/long-running-job-with-cloud-workflows-38b57bea74a5?source=collection_archive---------0-----------------------#2022-03-21">https://medium.com/google-cloud/long-running-job-with-cloud-workflows-38b57bea74a5?source=collection_archive---------0-----------------------#2022-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/715663986e274e656b13f4f2eb217acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9iWTw4yxkq8Yf7sL4OAHw.png"/></div></div></figure><p id="29d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">无服务器服务</strong>旨在<strong class="is hj">运行实时和交互式工作负载</strong>:网站、REST APIs它们<strong class="is hj">并非真正为数小时、数天或数周内的长期运行任务</strong>而设计。没有专门的服务，虚拟机仍然是运行这些工作负载的最佳场所。</p><p id="d8ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近，<a class="jo jp ge" href="https://medium.com/u/6444b44155fa?source=post_page-----38b57bea74a5--------------------------------" rel="noopener" target="_blank"> Mete Atamel </a>在一篇<a class="ae jq" href="https://cloud.google.com/blog/topics/developers-practitioners/long-running-containers-workflows-and-compute-engine" rel="noopener ugc nofollow" target="_blank"> Google Cloud博客文章</a>中发布了一个带有<strong class="is hj">云工作流</strong>的解决方案。该解决方案结合了云工作流、无服务器产品和计算引擎，非常棒。</p><blockquote class="jr js jt"><p id="8971" class="iq ir ju is b it iu iv iw ix iy iz ja jv jc jd je jw jg jh ji jx jk jl jm jn hb bi translated">然而，我并不完全满意。</p></blockquote><p id="bc15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，Mete的解决方案让协调器(云工作流)选择在虚拟机上运行工作负载的持续时间。他的解决方案是:</p><ul class=""><li id="0048" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated"><strong class="is hj">必须知道工作负载的持续时间</strong>:如果工作负载<strong class="is hj">提前结束，那么虚拟机的时间就白白浪费了</strong>。如果不是，<strong class="is hj">在</strong>结束前停止(结果不会错)</li><li id="060b" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><strong class="is hj">必须实现一个web服务器</strong>来启动和停止工作负载</li><li id="d455" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><strong class="is hj">必须在互联网上打开一个端口</strong>以允许云工作流与网络服务器交互</li></ul><blockquote class="km"><p id="adee" class="kn ko hi bd kp kq kr ks kt ku kv jn dx translated">在不知道工作负载持续时间和没有web服务器的情况下，如何运行日志运行作业？</p></blockquote><p id="87e0" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated"><em class="ju">另外，不开放VM端口到野生互联网。</em></p><h1 id="ba51" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">回拨解决方案</h1><p id="d8b8" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">Mete的想法很好:云工作流和计算引擎的<strong class="is hj">组合</strong>是关键，但是作业的<strong class="is hj">端必须由工作负载本身</strong>控制。为此，云工作流提出了一个名为<a class="ae jq" href="https://cloud.google.com/workflows/docs/creating-callback-endpoints" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">回调</strong> </a> <strong class="is hj">的有用特性。</strong></p><p id="7e43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该功能基于<strong class="is hj">网钩模式。</strong></p><ul class=""><li id="cabe" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">你生成一个URL</li><li id="bd0f" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">您向客户端提供URL</li><li id="dccd" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">您等待客户端对回调URL调用</li></ul><p id="a493" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ju">您可以在等待上添加一个超时，并定制您想要监听的HTTP动词(GET、POST、PUT、DELETE)。除了回调通知之外，post对于接收数据也很有用。</em></p><h1 id="8886" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带回调的长时间运行的作业</h1><p id="7161" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">所以，<a class="ae jq" href="https://github.com/guillaumeblaquiere/workflow-long-running-job" rel="noopener ugc nofollow" target="_blank">我在GitHub </a>中的原型就是利用回调特性，在虚拟机上运行容器。</p><p id="16a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了我分享的无用例子，<strong class="is hj">这里最重要的是原理和工作流逻辑</strong>；<em class="ju">您可以重用和定制该原则，以获得更强大的解决方案！</em></p><h2 id="5706" class="me lc hi bd ld mf mg mh lh mi mj mk ll jb ml mm lp jf mn mo lt jj mp mq lx mr bi translated">回调的创建</h2><p id="f0f8" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">回调创建不需要特殊技巧。注意在回调被调用时你所期望的HTTP动词，特别是当回调通知的同时<strong class="is hj">得到一个主体响应(在这种情况下不要使用<code class="du ms mt mu mv b">GET</code>)</strong></p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="4fd1" class="me lc hi mv b fi ne nf l ng nh">- create_callback:<br/>    call: events.create_callback_endpoint<br/>    args:<br/>      http_callback_method: "GET"<br/>    result: callback_details</span></pre><h2 id="633f" class="me lc hi bd ld mf mg mh lh mi mj mk ll jb ml mm lp jf mn mo lt jj mp mq lx mr bi translated">创建计算引擎</h2><p id="53df" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">计算引擎也没有显示任何挑战。为了更快地了解和理解所需的参数，我使用了控制台上的<strong class="is hj">计算引擎创建UI和</strong> <code class="du ms mt mu mv b"><strong class="is hj">View equivalent</strong></code> <strong class="is hj">功能</strong></p><figure class="mw mx my mz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/7952e5b030571756d6ac884dd8f68c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjiJKANx1R4LDFX1KQCcMA.png"/></div></div></figure><p id="69c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并使JSON参数适应工作流中的YAML定义。</p></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><p id="2777" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，我们不必创建一个简单的虚拟机。我们必须<strong class="is hj">定制启动</strong>来运行工作负载，并在完成后调用云工作流回调。</p><p id="ec0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">所以，我们需要一个</strong> <a class="ae jq" href="https://cloud.google.com/compute/docs/instances/startup-scripts/linux" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">的启动脚本</strong> </a> <strong class="is hj">！</strong></p><h2 id="31ba" class="me lc hi bd ld mf mg mh lh mi mj mk ll jb ml mm lp jf mn mo lt jj mp mq lx mr bi translated">启动脚本焦点</h2><p id="85c4" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">启动脚本是该解决方案的核心，也是最具挑战性的云工作流约束。</p><p id="98e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们需要的是:</p><ul class=""><li id="01e8" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">要<strong class="is hj">知道命令才能运行</strong>。我们可以硬编码它，但是我更喜欢把它放在虚拟机的参数中，在<strong class="is hj">属性元数据</strong>中</li><li id="a0b4" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">到<strong class="is hj">知道了回叫就去叫</strong>。这里也没有硬编码，也没有放入虚拟机的<strong class="is hj">参数</strong></li><li id="0c34" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">被允许使用云工作流回调。因此，我们必须从<a class="ae jq" href="https://cloud.google.com/compute/docs/metadata/default-metadata-values" rel="noopener ugc nofollow" target="_blank">元数据服务器</a>获取一个访问令牌，并将其添加到回调的curl调用的安全头中。</li></ul><p id="503d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ju">在安全方面，如果你使用</em><a class="ae jq" href="https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances" rel="noopener ugc nofollow" target="_blank"><em class="ju">C</em><strong class="is hj"><em class="ju">Compute Engine服务账号</em> </strong> </a> <em class="ju">，你必须</em> <strong class="is hj"> <em class="ju">正确地限定你的Compute Engine </em> </strong> <em class="ju"> VM的范围。我使用了</em> <strong class="is hj"> <em class="ju">云平台作用域</em> </strong> <em class="ju">来避免任何问题(如果使用自定义服务帐户</em>  <em class="ju">，可以</em> <strong class="is hj"> <em class="ju">跳过作用域)。<br/>另外，所使用的服务账号(默认或自定义)</em> <strong class="is hj"> <em class="ju">必须有</em> </strong> <a class="ae jq" href="https://cloud.google.com/workflows/docs/access-control#roles" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="ju">工作流调用者角色</em> </strong> </a> <strong class="is hj"> <em class="ju">授予其上。</em>T47】</strong></strong></p></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><p id="9d03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，我们开始吧。获取元数据属性并不困难。调用<a class="ae jq" href="https://cloud.google.com/compute/docs/metadata/default-metadata-values#vm_instance_metadata" rel="noopener ugc nofollow" target="_blank">元数据服务器就足够了</a>，就像这样</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="5489" class="me lc hi mv b fi ne nf l ng nh"># Docker Command<br/>curl -H "Metadata-Flavor: Google" <a class="ae jq" href="http://metadata.google.internal/computeMetadata/v1/instance/attributes/docker-command" rel="noopener ugc nofollow" target="_blank">http://metadata.google.internal/computeMetadata/v1/instance/attributes/docker-command</a></span><span id="5194" class="me lc hi mv b fi nq nf l ng nh"># Callback URL<br/>curl -H "Metadata-Flavor: Google" <a class="ae jq" href="http://metadata.google.internal/computeMetadata/v1/instance/attributes/callback-url" rel="noopener ugc nofollow" target="_blank">http://metadata.google.internal/computeMetadata/v1/instance/attributes/callback-url</a> </span></pre><p id="ec36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取访问令牌更具挑战性。当然，元数据服务器提供了<code class="du ms mt mu mv b">/services-accounts/default/token</code>端点，答案在JSON中。</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="6ed4" class="me lc hi mv b fi ne nf l ng nh">curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token</span></pre><p id="0d12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在bash中很好地解析JSON，我们可以使用<a class="ae jq" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> JQ </a>。<br/>然而，出于<strong class="is hj">安全原因</strong>和<strong class="is hj">高效运行容器</strong>，我选择<strong class="is hj">使用一个</strong> <a class="ae jq" href="https://cloud.google.com/container-optimized-os/docs" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> COS </strong>(容器优化操作系统)</a>。出于安全原因，并且为了<strong class="is hj">减少攻击面</strong>，有<strong class="is hj">几个二进制文件安装在上面</strong>，并且<strong class="is hj">不可能安装额外的库。</strong></p><p id="a13f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ju">注:您可以看到一个名为</em> <code class="du ms mt mu mv b"><em class="ju">get_latest_image</em></code> <em class="ju">的附加步骤，自动选择最新的有效COS映像以保持最新，并增加安全性。</em></p><p id="c83a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，一个解决方案是存在的:你可以使用T2。这是一个<strong class="is hj">沙盒linux环境</strong>，我们可以在上面安装JQ！</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="ad32" class="me lc hi mv b fi ne nf l ng nh">toolbox apt-get install -y jq</span></pre><p id="e843" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，调用回调与所有的作品</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="61d2" class="me lc hi mv b fi ne nf l ng nh">toolbox bash -c "curl -s -H \"Metadata-Flavor: Google\" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token | jq -r .access_token"</span></pre></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><p id="81a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们有了所有的构建模块。<strong class="is hj">第二个挑战是在云工作流中以<strong class="is hj">清晰可读的方式</strong>编写启动脚本</strong>。</p><p id="3c60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初，我选择了<a class="ae jq" href="https://cloud.google.com/workflows/docs/reference/syntax/expressions#multi-line" rel="noopener ugc nofollow" target="_blank">多行表达式</a>来优雅地构建一个字符串。这里有几个挑战:</p><ul class=""><li id="05c8" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">表达式中不允许使用冒号<code class="du ms mt mu mv b">:</code>。你必须<a class="ae jq" href="https://cloud.google.com/workflows/docs/troubleshooting#expressions-colons" rel="noopener ugc nofollow" target="_blank">用单引号</a> <code class="du ms mt mu mv b">'</code>转义整个表达式。</li><li id="0ae4" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">因为你必须用双引号<code class="du ms mt mu mv b">"</code>来表示字符串，脚本行，单引号<code class="du ms mt mu mv b">'</code>来表示整个表达式，所以你开始玩，并且用反斜杠<code class="du ms mt mu mv b">\</code>转义字符来扭曲你的大脑…一场噩梦</li><li id="bf93" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">当我最终成功时，服务告诉我，我的每个表达式只能有400个字符…</li></ul><p id="f748" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我<strong class="is hj">忘记了第一个选项，用了一个老式的选项</strong>。正如你在我的代码的<a class="ae jq" href="https://github.com/guillaumeblaquiere/workflow-long-running-job/blob/d1ce29f75182241bceb02b292ca08a946d637619/long-run.yaml#L12" rel="noopener ugc nofollow" target="_blank">赋值步骤中看到的，我一行一行地定义了我的脚本。很好读，我不用用反斜杠<code class="du ms mt mu mv b">\</code>转义符。</a></p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="155e" class="me lc hi mv b fi ne nf l ng nh">- scriptCreation:<br/>    assign:<br/>      - scriptLine000: '#! /bin/bash'<br/>      - scriptLine001: '$(curl -H "Metadata-Flavor: Google" ...'<br/>      - scriptLine002: 'toolbox apt-get install -y jq'<br/>      - scriptLine003: 'TOKEN=$(toolbox bash -c "curl ...'<br/>      - scriptLine004: 'curl -H "Authorization: Bearer ...'</span></pre><p id="f89d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，启动脚本定义只是由回车符<code class="du ms mt mu mv b">\n</code>分隔的脚本行的串联。</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="d010" class="me lc hi mv b fi ne nf l ng nh">- key: "startup-script"<br/>  value: ${scriptLine000 + "\n" +<br/>    scriptLine001 + "\n" +<br/>    scriptLine002 + "\n" +<br/>    scriptLine003 + "\n" +<br/>    scriptLine004<br/>          }</span></pre><p id="21b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:工作流程限制告诉我们这不是最佳解决方案。那么长的脚本应该存储在其他地方，比如云存储，然后按原样加载，或者直接在T7中加载</p><h2 id="9bd2" class="me lc hi bd ld mf mg mh lh mi mj mk ll jb ml mm lp jf mn mo lt jj mp mq lx mr bi translated">等待回电</h2><p id="1af3" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">等待回调也是一个简单步骤。<em class="ju">不过，在测试过程中，我推荐使用一个</em> <a class="ae jq" href="https://cloud.google.com/workflows/docs/reference/stdlib/events/await_callback#arguments" rel="noopener ugc nofollow" target="_blank"> <em class="ju">超时</em> </a> <em class="ju">在几分钟后自动取消工作流程。它防止您在测试中出现错误时手动取消工作流。</em></p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="4c0e" class="me lc hi mv b fi ne nf l ng nh">- await_callback:<br/>    call: events.await_callback<br/>    args:<br/>      callback: ${callback_details}<br/>      timeout: 25920000 <em class="ju">#300 days. Max 365<br/>    </em>result: callback_request</span></pre><h2 id="7c07" class="me lc hi bd ld mf mg mh lh mi mj mk ll jb ml mm lp jf mn mo lt jj mp mq lx mr bi translated">删除虚拟机</h2><p id="d324" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">删除虚拟机是通过删除连接器对<a class="ae jq" href="https://cloud.google.com/workflows/docs/reference/googleapis/compute/v1/instances/delete" rel="noopener ugc nofollow" target="_blank">计算引擎API的调用。<em class="ju">那段代码是从Mete的代码</em>  <em class="ju">中纯粹复制/粘贴而来的</em> <strong class="is hj"> <em class="ju">！</em></strong></a></p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="6f09" class="me lc hi mv b fi ne nf l ng nh">- delete_vm:<br/>    call: googleapis.compute.v1.instances.delete<br/>    args:<br/>      instance: ${instanceName}<br/>      project: ${projectId}<br/>      zone: ${zone}</span></pre></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><p id="6d21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想亲自尝试一下，你可以在我的<a class="ae jq" href="https://github.com/guillaumeblaquiere/workflow-long-running-job/blob/d1ce29f75182241bceb02b292ca08a946d637619/long-run.yaml#L19L23" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的代码和说明！</p><h1 id="6013" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无服务器长期运行的未来</h1><p id="0335" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">由于云工作流和计算引擎，您拥有了一个<strong class="is hj">完全托管的解决方案</strong>，与无服务器服务相协调。</p><ul class=""><li id="a11e" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">你不需要管理虚拟机</li><li id="7bee" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">你不需要给虚拟机打补丁</li><li id="f50a" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">你总是拥有最新版本的COS操作系统</li><li id="0303" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">你只有在使用虚拟机时才付费。<em class="ju">当工作负载结束时，虚拟机会自动创建和销毁。</em></li></ul><p id="76e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次，您可以<strong class="is hj">运行可能需要数小时、数天、数周或数秒的工作负载</strong>、<strong class="is hj">，而无需提前知道其持续时间</strong>。例如，这对于ML培训工作来说是完美的！</p><p id="4b83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，您可以<strong class="is hj">运行您想要的工作负载</strong>，如果您<strong class="is hj">定制要运行的命令和要使用的计算引擎映像</strong>，那么<strong class="is hj">不仅仅是一个容器</strong>。</p></div></div>    
</body>
</html>