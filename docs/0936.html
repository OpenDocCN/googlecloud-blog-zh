<html>
<head>
<title>Building APIs with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用gRPC构建API</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/building-apis-with-grpc-50842234aec8?source=collection_archive---------2-----------------------#2019-02-25">https://medium.com/google-cloud/building-apis-with-grpc-50842234aec8?source=collection_archive---------2-----------------------#2019-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8ce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文讨论了如何使用协议缓冲区构建一个简单的单端点gRPC API服务，并使用gRPC工具准备其客户端和服务器端代码。它是<a class="ae jd" rel="noopener" href="/@ratrosy/building-api-services-a-beginners-guide-7274ae4c547f">构建API服务:初学者指南</a>教程系列的一部分。</p><blockquote class="je jf jg"><p id="4576" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">注意:本教程使用Python 3。当然，gRPC支持多种编程语言。</p></blockquote><h1 id="5c59" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">关于API服务</h1><p id="1880" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在本教程中，您将使用gRPC构建一个API服务，用户可以从中获取他们的配置文件。它只有一个资源<code class="du ko kp kq kr b">User</code>和一个方法(端点):</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h1 id="0b53" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">开始之前</h1><ul class=""><li id="ad60" class="kz la hi ih b ii kj im kk iq lb iu lc iy ld jc le lf lg lh bi translated"><a class="ae jd" href="https://cloud.google.com/python/setup" rel="noopener ugc nofollow" target="_blank">设置您的Python开发环境</a>。对于本教程，您不需要安装谷歌云SDK和谷歌云Python客户端库。</li><li id="ac85" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">安装gRPC和协议缓冲区:</li></ul><pre class="ks kt ku kv fd ln kr lo lp aw lq bi"><span id="eb0e" class="lr jm hi kr b fi ls lt l lu lv">pip install grpcio grpcio-tools</span></pre><p id="51c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ko kp kq kr b">grpcio</code>是Python的gRPC包。gRPC工具包<code class="du ko kp kq kr b">grpcio-tools</code>，包括带gRPC插件的协议缓冲编译器。</p><ul class=""><li id="ea1c" class="kz la hi ih b ii ij im in iq lw iu lx iy ly jc le lf lg lh bi translated"><a class="ae jd" href="https://github.com/michaelawyu/api_tutorial" rel="noopener ugc nofollow" target="_blank">下载源代码</a>。打开<code class="du ko kp kq kr b">/grpc/getting_started</code>。</li></ul><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h1 id="92d9" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">理解代码</h1><p id="9146" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">本质上，对方法(端点)的API调用只不过是一个输入(请求)、一个输出(响应)和一些将请求与响应关联起来的魔法。输入提供方法需要的所有参数，输出是方法返回的内容。</p><p id="8309" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在gRPC API服务中，输入(请求)和输出(响应)是特定类型的协议缓冲区消息，使用协议缓冲区语言在一个或多个<code class="du ko kp kq kr b">.proto</code>文件中定义。<code class="du ko kp kq kr b">.proto</code>文件中的服务定义将输入消息类型与输出消息类型相关联，协议缓冲编译器将<code class="du ko kp kq kr b">.proto</code>文件编译成代码工件。然后，您可以使用这些构件来构建您的API服务及其客户端库。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/b1d34a397862852899687854f4b6490f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHjhbQQc9DrJTcE24qHGeg.png"/></div></div></figure><h2 id="0693" class="lr jm hi bd jn mg mh mi jr mj mk ml jv iq mm mn jz iu mo mp kd iy mq mr kh ms bi translated">资源及其领域</h2><p id="edd5" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">这个gRPC API服务以一个资源为特色:<code class="du ko kp kq kr b">User</code>。</p><p id="0c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ko kp kq kr b">User</code>的资源名格式为<code class="du ko kp kq kr b">//myapiservice.com/users/USER-ID</code>。用户特征3个字段:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="7439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，为了简单起见，协议缓冲区没有对保留字段和必填字段的内置支持。<strong class="ih hj">所有字段都是可选的</strong>。开发人员必须在服务器端(和客户端，如果需要的话)验证数据</p><h2 id="8307" class="lr jm hi bd jn mg mh mi jr mj mk ml jv iq mm mn jz iu mo mp kd iy mq mr kh ms bi translated">写入协议缓冲区</h2><p id="24b4" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><code class="du ko kp kq kr b">example.proto</code> ( <code class="du ko kp kq kr b">grpc/getting_started/example.proto</code>)是该API服务的协议缓冲区规范。它包括3个部分:语法版本、消息类型和服务定义:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="663a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法版本</strong></p><p id="7fc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ko kp kq kr b">syntax = “proto3”;</code>，声明您想要使用的协议缓冲语言版本(<code class="du ko kp kq kr b">.proto</code>文件语法)。在大多数情况下，建议开发者使用版本<code class="du ko kp kq kr b"> proto3</code>；默认值为<code class="du ko kp kq kr b">proto2</code>。</p><p id="f5da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">消息类型</strong></p><p id="f785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ko kp kq kr b">.proto</code>文件有两种消息类型:<code class="du ko kp kq kr b">User</code>和<code class="du ko kp kq kr b">GetUserRequest</code>。<code class="du ko kp kq kr b">User</code>有三个字符串类型字段:<code class="du ko kp kq kr b">name</code>、<code class="du ko kp kq kr b">display_name</code>和<code class="du ko kp kq kr b">email</code>。<code class="du ko kp kq kr b">GetUserRequest</code>有一个字符串类型字段<code class="du ko kp kq kr b">name</code>。</p><p id="2fcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个字段后的数字是字段编号。协议缓冲区消息使用字段编号而不是字段名称来唯一标识该字段。</p><p id="448e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">服务定义</strong></p><p id="0852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ko kp kq kr b">.proto</code>文件有一个服务定义<code class="du ko kp kq kr b">ExampleUserService</code>，它由一个方法(端点)<code class="du ko kp kq kr b">GetUser</code>组成。它接受一条<code class="du ko kp kq kr b">GetUserRequest</code>类型的消息，并返回另一条<code class="du ko kp kq kr b">User</code>类型的消息。</p><h1 id="b463" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">准备代码</h1><p id="48d7" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">协议缓冲编译器现在可以准备服务器端和客户端工件:</p><pre class="ks kt ku kv fd ln kr lo lp aw lq bi"><span id="8fb1" class="lr jm hi kr b fi ls lt l lu lv">python -m grpc_tools.protoc -I. --python_out=codegen/ --grpc_python_out=codegen/ example.proto</span></pre><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="741a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译器生成两个文件:<code class="du ko kp kq kr b">codegen/example_pb2.py</code>和<code class="du ko kp kq kr b">codegen/example_pb2_grpc.py</code>。<code class="du ko kp kq kr b">example_pb2.py</code>指定了<code class="du ko kp kq kr b">example.proto</code>中的消息类型在Python中应该是什么样子。<code class="du ko kp kq kr b">example_pb2_grpc.py</code>包含两个类，<code class="du ko kp kq kr b">ExampleServiceServicer</code>和<code class="du ko kp kq kr b">ExampleServiceStub</code>，您将分别使用它们来构建自己的服务器端和客户端代码。</p><p id="5f8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">覆盖<code class="du ko kp kq kr b">ExampleServiceServicer</code>来创建您自己的gRPC API服务，如<code class="du ko kp kq kr b">server.py</code>所示:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="0273" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当客户端访问<code class="du ko kp kq kr b">GetUser</code>端点时，gRPC将自动调用<code class="du ko kp kq kr b">ExampleServiceServicer</code>类中被覆盖的<code class="du ko kp kq kr b">GetUser</code>方法。该框架自动将<code class="du ko kp kq kr b">GetUserRequest</code>协议缓冲区消息解析成一个<code class="du ko kp kq kr b">GetUserRequest</code> Python类，您可以习惯性地操作它；然后，它接受一个<code class="du ko kp kq kr b">User</code> Python类，将其序列化为一个<code class="du ko kp kq kr b">User</code>协议缓冲消息，并将其返回给客户端。注意<code class="du ko kp kq kr b">GetUserRequest</code>和<code class="du ko kp kq kr b">User</code> Python类都是在<code class="du ko kp kq kr b">example_pb2.py</code>中定义的。</p><p id="d8b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，使用<code class="du ko kp kq kr b">ExampleServiceStub</code>为gRPC API服务创建一个客户端，如<code class="du ko kp kq kr b">client.py</code>所示:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="1436" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端将在运行时自动连接到gRPC API服务。当客户用一个<code class="du ko kp kq kr b">name</code>参数调用<code class="du ko kp kq kr b">get_user</code>方法时，您将把它准备成一个<code class="du ko kp kq kr b">GetUserRequest</code> Python类，并通过存根把它传递给gRPC。然后gRPC将<code class="du ko kp kq kr b">GetUserRequest</code> Python类解析成<code class="du ko kp kq kr b">GetUserRequest</code>协议缓冲区消息，并发送给服务器；来自服务器的响应，一个<code class="du ko kp kq kr b">User</code>协议缓冲消息，然后被解析成一个<code class="du ko kp kq kr b">User</code> Python类，并打印出来。</p><p id="7c13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有帮助的话，可以把<code class="du ko kp kq kr b">.proto</code>文件想象成服务器和客户机之间的契约，gRPC是信使，协议缓冲区是仲裁员/翻译员。协议缓冲区执行契约，将客户机和服务器所说的内容翻译成通用语言，gRPC在HTTP/2中进行通信。gRPC +协议缓冲区在后台执行所有管理任务(传输、序列化等。)这样你的服务器和客户端就可以专注于真正重要的东西:你的应用程序的业务逻辑。</p><h1 id="5d7c" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">试一试</h1><p id="8ea5" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在后台运行<code class="du ko kp kq kr b">server.py</code>:</p><pre class="ks kt ku kv fd ln kr lo lp aw lq bi"><span id="358e" class="lr jm hi kr b fi ls lt l lu lv">python server.py</span></pre><p id="32f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器监听本地主机:8080。使用客户端连接到服务器；运行以下Python脚本:</p><pre class="ks kt ku kv fd ln kr lo lp aw lq bi"><span id="e2a4" class="lr jm hi kr b fi ls lt l lu lv">import client<br/>client = client.ExampleServiceClient()<br/>client.get_user(‘//myapiservice.com/users/1’)</span></pre><p id="fc70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该会看到以下输出:</p><pre class="ks kt ku kv fd ln kr lo lp aw lq bi"><span id="269f" class="lr jm hi kr b fi ls lt l lu lv">User fetched.<br/>name: “//myapiservice.com/users/1”<br/>display_name: “Example User”<br/>email: “user@example.com”</span></pre><h1 id="a79a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">下一步是什么</h1><p id="25da" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">关于gRPC API服务的推荐实践和模式，请参见<a class="ae jd" rel="noopener" href="/@ratrosy/building-apis-with-grpc-continued-f53b5a5ab850">用gRPC构建API:续</a>。</p></div></div>    
</body>
</html>