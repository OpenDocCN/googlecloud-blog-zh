<html>
<head>
<title>Golang Modules &amp; Immutability #2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang模块和不变性#2</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/golang-modules-immutability-2-96cb76a6630e?source=collection_archive---------1-----------------------#2019-07-11">https://medium.com/google-cloud/golang-modules-immutability-2-96cb76a6630e?source=collection_archive---------1-----------------------#2019-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d4f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">昨天，我使用Docker和Cloud Build探索了利用不可变Golang包库的一些方法。似乎有一种方法可以利用这种不变性，使用<em class="je">解构的</em>多阶段构建。</p><h2 id="ad5f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">多阶段构建</h2><p id="f375" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">这是我的Golang多阶段构建和Google发行版的样板文件</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="cacc" class="jf jg hi kk b fi ko kp l kq kr">FROM golang:1.12 as build<br/>WORKDIR /app<br/>COPY . .<br/>RUN GO111MODULE=on GOPROXY=https://proxy.golang.org go build app</span><span id="bfc8" class="jf jg hi kk b fi ks kp l kq kr">FROM gcr.io/distroless/base<br/>COPY --from=build /go/bin/app /<br/>ENTRYPOINT ["/app"]</span></pre><p id="5e84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次运行这个过程时，<code class="du kt ku kv kk b">golang</code>映像的<code class="du kt ku kv kk b">/go/pkg</code>将被与构建相关的包填充。</p><blockquote class="kw kx ky"><p id="2463" class="if ig je ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj">假设</strong>:临时容器是匿名的，但是必须保存到磁盘上。应该可以发现这些过渡集装箱。但是…</p><p id="ba28" class="if ig je ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj">假设</strong>:通过解构一个多阶段构建，应该有可能强制持久化临时容器，并且我们可以使用这样的临时容器来将来自多个构建的不同的包提取聚合到单个源中。</p></blockquote><h2 id="1cbf" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">解构的多阶段构建</h2><p id="bf62" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">我正在设想像这样的种子步骤做一次你的第一个<code class="du kt ku kv kk b">go.mod</code>:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="2cf2" class="jf jg hi kk b fi ko kp l kq kr">FROM <strong class="kk hj">golang:1.12</strong> as <strong class="kk hj">origin<br/></strong>WORKDIR /app<br/>COPY go.mod .<br/>RUN GO111MODULE=on GOPROXY=https://proxy.golang.org <strong class="kk hj">go</strong> <strong class="kk hj">mod</strong> <strong class="kk hj">download</strong></span></pre><p id="00ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并建立图像:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="76c1" class="jf jg hi kk b fi ko kp l kq kr">docker build --tag=golang:modules --file=Dockerfile.orig .</span></pre><p id="0f18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了基线<code class="du kt ku kv kk b">golang:modules</code>。</p><p id="02b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且——随后——<strong class="ih hj">为每个Go构建</strong>——将这个构建的包添加到<code class="du kt ku kv kk b">golang:modules</code>而不是<code class="du kt ku kv kk b">golang</code>:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="4c58" class="jf jg hi kk b fi ko kp l kq kr">FROM <strong class="kk hj">golang:modules</strong> as <strong class="kk hj">modules<br/></strong>WORKDIR /app<br/>COPY go.mod .<br/>RUN GO111MODULE=on GOPROXY=https://proxy.golang.org <strong class="kk hj">go</strong> <strong class="kk hj">mod download</strong></span></pre><blockquote class="kw kx ky"><p id="1e70" class="if ig je ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>我发现一个只包含<code class="du kt ku kv kk b">go.mod</code>的目录失败了，比如说<code class="du kt ku kv kk b">go get ./...</code>但是，有一个<code class="du kt ku kv kk b">go mod download</code>命令正是我们所需要的。</p></blockquote><p id="ed24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并(重新)构建<code class="du kt ku kv kk b">golang:modules</code>(包)映像:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="c713" class="jf jg hi kk b fi ko kp l kq kr">docker build --tag=<strong class="kk hj">golang:modules</strong> --file=Dockerfile.mods .</span></pre><blockquote class="kw kx ky"><p id="fdaf" class="if ig je ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>是的，<code class="du kt ku kv kk b">golang:modules</code>可能会因为增加了这么多层而变得有问题。Docker有一个实验性的<code class="du kt ku kv kk b">docker build … -squash ...</code>命令可能会有所帮助。</p></blockquote><p id="eb04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，为了建立这个项目:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="f832" class="jf jg hi kk b fi ko kp l kq kr">FROM <strong class="kk hj">golang:modules</strong> as <strong class="kk hj">modules</strong></span><span id="0232" class="jf jg hi kk b fi ks kp l kq kr">FROM golang:1.12 as <strong class="kk hj">build</strong><br/>COPY --from=<strong class="kk hj">modules</strong> /go/pkg /go/pkg<br/>WORKDIR /app<br/>COPY . .<br/>RUN GO111MODULE=on GOPROXY=https://proxy.golang.org <strong class="kk hj">go build app</strong></span><span id="30f3" class="jf jg hi kk b fi ks kp l kq kr">FROM gcr.io/distroless/base<br/>COPY --from=<strong class="kk hj">build</strong> /foo /<br/>ENTRYPOINT ["/foo"]</span></pre><p id="49f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并建立图像:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="4fa0" class="jf jg hi kk b fi ko kp l kq kr">docker build --tag=thisproject --file=Dockerfile.proj .</span></pre><h2 id="0628" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">结论</h2><p id="a41c" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">使用这种——公认的更复杂的方法——我们(应该)能够在<code class="du kt ku kv kk b">golang:modules</code>中累积不同的包，这样，一旦被提取，一个包就被保留，并且即使在不同的构建中也不会被提取第二次。</p><p id="1930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可通过将两个构建语句绑定在一起来重构解构的多阶段构建Dockerfile文件。</p><p id="47a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p></div></div>    
</body>
</html>