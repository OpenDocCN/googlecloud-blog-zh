<html>
<head>
<title>Rewriting moviegolf.com</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重写moviegolf.com</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/rewriting-moviegolf-com-e5c01fd396dc?source=collection_archive---------1-----------------------#2017-05-22">https://medium.com/google-cloud/rewriting-moviegolf-com-e5c01fd396dc?source=collection_archive---------1-----------------------#2017-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cea2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">反思8年的编程经验</h2></div><p id="15e9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今年4月，我重新启动了moviegolf.com网站，这个网站我从2009年就开始运营了。因为这是我写过的最精彩的程序之一，当然也是持续时间最长的程序之一，所以我想讲述一下它的历史。在这中间的几年里，我的编程风格确实发生了变化。</p><h1 id="930d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">什么是电影高尔夫？</h1><p id="22bd" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">来自网站的<a class="ae jt" href="https://www.moviegolf.com/about" rel="noopener ugc nofollow" target="_blank">关于页面</a>:</p><blockquote class="kr ks kt"><p id="151d" class="ix iy ku iz b ja jb ij jc jd je im jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated">电影高尔夫是一个电影琐事游戏——就像<a class="ae jt" href="http://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon" rel="noopener ugc nofollow" target="_blank">的凯文·贝肯六度游戏</a>——涉及到连接电影。这个游戏的目标是通过最少的中介把两部看似不同的电影联系起来。要投入到另一部电影中，你必须找到一个共同的演员。例如，你可以通过瑞茜·威瑟斯彭从《律政俏佳人》进入《欢乐谷》。</p></blockquote><p id="959e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我爸爸(杰夫·莱特)和他在OSU的朋友们多年前开发的一个游戏，但它归结为一个基本的CS图问题:在两个电影节点之间找到最佳路径，每个边都是一个演员。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/d3bf335f38bf13609f6bca2b942313bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5w2zL1e_fujR9yocoCD6w.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">连接电影A和电影z的无向图。最佳路径穿过电影B，演员1连接电影A和电影B，演员2连接电影B和电影z。为了在两部电影之间存在边，演员必须在两部电影中都出现过。底部显示了一条次优路径，从电影A到电影C到电影D再到电影z。通常有许多方法可以在两部电影之间遍历。</figcaption></figure><h1 id="436b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">版本1.0</h1><p id="dfce" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我最初在2009年初为这个游戏写了一个Python解算器。当时，我非常迷恋Freebase，并注意到我可以下载一个中等大小的文件(不会超过几十兆字节)并获得大约60，000部电影的信息。这包括演员名单、导演和摄影师。一切。想起我爸爸教我的这个游戏，我编写了一个hacky命令行解算器，它将整个转储读取到一个哈希映射中，然后找到两部给定电影之间的路径。我把这个给我的朋友们看，他们很兴奋，但可以理解的是，他们想要一个更容易上手的游戏方式。因为当时我正处于一个<a class="ae jt" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">应用引擎</a> + <a class="ae jt" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>的阶段，一个网站似乎是一个不错的选择。</p><p id="7edb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于那些没有使用过App Engine的人来说，它会根据你使用的流量来启动虚拟服务器实例，并在你不使用它们时关闭它们。当时，每个实例“启动时从磁盘读取整个数兆字节文件”的成本对我来说似乎不是一个好主意。如今，我连眼睛都不会眨一下，但在那时，我对事物的相对速度没有把握。所以我决定“嘿，我应该把这个放在数据库里”。这是一个好主意；这是我在新版本中所做的。令人不快的想法(事后看来)是我对数据库的选择:我使用了<a class="ae jt" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank">云数据库</a>。不要误解我的意思:数据存储是一个很好的存储系统，但它不是<a class="ae jt" href="https://en.wikipedia.org/wiki/Relational_model" rel="noopener ugc nofollow" target="_blank">关系型的</a>，这正是电影《高尔夫》这样的问题所需要的。为了找到相邻的电影，我对电影中的每个演员进行了查询。从这个角度来看，假设平均每部电影有:(都是手写的，但大致真实)3个演员，连接到90部其他电影，重叠系数为50%。用两个中介连接一对电影需要通过网络查询数据存储12423次！即使每个查询是1毫秒，这也将超过12秒的挂钟时间。相比之下，我的新系统只发出一小部分查询，都在内存中。</p><p id="7c33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我现在很容易挑剔自己，但做出这些决定是因为我不了解我所使用的底层系统。直到很多年以后，我才知道<a class="ae jt" href="https://en.wikipedia.org/wiki/Join_(SQL)" rel="noopener ugc nofollow" target="_blank"> SQL加入了</a>。当我放弃使用App Engine时，我编写了一个小型的磁盘B树索引，可以直接存储相邻的电影。我不知道，这正是SQL数据库在幕后做的事情。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lo"><img src="../Images/c297f413305fc53b26b51e115e92fd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qy-W8S3ztRS-NIJ2W8ys4g.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">大约在2013年，moviegolf.com登录页面的屏幕截图。非常简约。顶部的搜索表单是你输入两部电影的地方。我还试图提供一个登录体验，在那里你可以保存和投票，但我是唯一一个这样做的人。</figcaption></figure><p id="5d3b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该网站运行良好，支持各种与电影相关的查询。然而，它有一个关键的缺点:数据从来不是最新的。您可以搜索特定的电影，然后单击按钮来刷新该电影。这根本无法扩展，需要最终用户手动操作。当你试图在高尔夫搜索中建立联系时，你希望你没有要求更新的电影。随着时间的推移，电影变得更加紧密，因为新电影将以新的方式将演员聚集在一起。但至少有一些数据。</p><p id="8551" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个新手，我很满意。</p><h1 id="ff8c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">8年后…</h1><p id="9687" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">2010年，谷歌收购了Freebase。五年后，Freebase被关闭。moviegolf.com不再有任何数据。看看我的网站，叶不可一世，绝望了！</p><p id="67cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">凭借一个正式的计算机科学学位和4年的工作经验，我决定要取代这个废弃的网站。我的首要任务是研究Go on Google云平台的体验，并将任何持续的维护工作保持在最低限度。我的空闲时间很宝贵，所以一切都应该简单，只写一次，易于调试。</p><h2 id="79fb" class="lp jv hi bd jw lq lr ls ka lt lu lv ke jg lw lx kg jk ly lz ki jo ma mb kk mc bi translated">数据摄取</h2><p id="5c3c" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">到目前为止，获取数据是整个工作中最复杂的部分，也是让我远离这次重写的主要因素。我必须找到一个新的数据源，这一次，我希望它尽可能地活。不再需要手动更新和托管用户生成的内容。让别人做主持人。IMDB是显而易见的候选者，他们确实发布数据转储，但是我不清楚他们的许可条款是否适合我的用例。找律师联系电影看起来很荒谬。当Freebase关闭后，他们的数据被转移到维基数据。这看起来很完美:一个我已经理解了每周转储的数据模型，一个获取最近变化的API，和一个<a class="ae jt" href="https://www.wikidata.org/wiki/Wikidata:Database_download/en#License" rel="noopener ugc nofollow" target="_blank"> CC0许可的</a>语料库。</p><p id="5b1f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于大多数其他有趣的部分(实际上是打高尔夫球，通过HTML显示数据)需要数据，并且使用真实数据比假数据更能测试系统，所以我花了一周时间首先构建了这个。Wikidata转储以压缩的JSON记录的形式出现，每行一个。未压缩的语料库是17亿个实体，占用111千兆字节！虽然这听起来很大，但我只想要其中的一小部分:只是电影和演员。虽然电影的记录在流中有明显的指标，但维基数据没有为演员提供指标。为了确定哪些实体是演员，您必须保留一个运行列表，列出在每部电影的演员阵容中出现的记录id。因此，我的导入程序需要遍历数据一次，以找出应该保留哪些记录，然后再次遍历数据，将这些记录收集到数据库中。一旦测试并构建了代码，下载和解压转储文件大约需要一个小时，然后运行导入程序需要一个半小时。其中大部分是磁盘限制的，所以我可以从我的桌面上的高速磁盘中受益。这对于最初的开发来说已经足够好了:一个40兆字节的真实数据语料库。</p><h2 id="a572" class="lp jv hi bd jw lq lr ls ka lt lu lv ke jg lw lx kg jk ly lz ki jo ma mb kk mc bi translated">更新数据</h2><p id="5d2b" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">然而，由于时间和空间的限制，每周下载转储文件显然是不切实际的。我将不得不支付比我实际需要的多得多的云存储，并且数据将会非常陈旧。此外，单个概念操作进行的时间越长，某个东西就越有可能在中间扼杀这个工作。耶墨菲定律！相反，正如我上面提到的，我编写了另一个服务(updater ),它查询Wikidata最近更改API来查看自上次导入以来修改的实体，然后直接从网站而不是转储中读取更改。在我的笔记本电脑上的小规模测试中，我注意到处理500个实体更改大约需要1分钟(其中绝大多数甚至与电影无关)。我测量了24小时内发生的更改数量，发现大约为160，000次，也就是说每小时大约有7，000次更改。我希望每次导入运行不超过10分钟，所以我决定每30分钟运行一次更新程序作业。</p><p id="6eac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能会注意到这里的一个问题:如果更新程序开始滞后怎么办？假设更新程序在一次或多次运行时崩溃。然后，它可能开始承担比正常情况下更大的工作负载，从而导致它因为仍在运行而错过下一次计划的运行。此外，当我从最初的转储导入切换时，我如何弥补导入转储时错过的大约3个小时？为了解决这些问题，我指定了任何一个导入可以操作的最大时间跨度。我选择了一个稍微超过运行频率的值:45分钟。这样，系统将有一个更加可预测的负载，即使是在追赶的时候。只要它没有运行超过30天(维基数据最近更改的限制)，那么它就没问题。</p><p id="0e45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">做完这些，我开始考虑托管。</p><h2 id="07ee" class="lp jv hi bd jw lq lr ls ka lt lu lv ke jg lw lx kg jk ly lz ki jo ma mb kk mc bi translated">价格驱动的架构</h2><p id="d9a7" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">GCP清单中最令人惊讶的有用工具之一是<a class="ae jt" href="https://cloud.google.com/products/calculator/" rel="noopener ugc nofollow" target="_blank">定价计算器</a>。它可以让你插入你的预测使用量，并了解你的账单将如何增加。在某些方面，扩展比其他方面更昂贵。负载平衡是最昂贵的，其次是CPU和RAM。存储便宜。如果没有计算器，如果没有几个月的反复试验和重新设计，我就不会有做出这些决定的祈祷。</p><p id="f453" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">定价也迫使我简化最初的设计。最初，我认为我会使用Cloud PostgreSQL，但即使运行一个不符合SLA的共享实例也比我想要的更昂贵。为了避免云PostgreSQL实例，我决定将SQLite数据库存储在云存储中。实时服务流量只需要从数据库中读取，因此不存在写争用。这样，我可以在本地开发期间使用生产数据。这也简化了我的集成测试，因为我不需要建立一个完整的SQL server，只需要一个文件。</p><p id="6796" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在谷歌工作多年后，我已经习惯了<a class="ae jt" href="https://landing.google.com/sre/book/chapters/service-best-practices.html" rel="noopener ugc nofollow" target="_blank">“N+2”冗余</a>:总是部署比运行服务所需多2个的实例。这允许您处理计划内的实例中断(升级您的服务)和计划外的中断(某些东西死亡)。如果您需要高可用性并且能够负担得起这些资源，这很好。但是moviegolf.com不需要高可用性。moviegolf.com的预算是自付的(即“越低越好”)。虽然我希望以99%的可靠性运行moviegolf.com，但更合理的<a class="ae jt" href="https://landing.google.com/sre/book/chapters/service-level-objectives.html" rel="noopener ugc nofollow" target="_blank">服务水平目标</a>应该是90%。N = 1就是了。</p><p id="cd5c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个GCP爱好者，我得到的经验是:您希望运行尽可能少的实例，即使您在一个实例中装入的东西稍微多一些。这排除了Google容器引擎，因为它运行在多个节点上。我还为我的项目排除了App Engine (Flex或Standard ),因为我想把功能分成多个Docker映像。我的理由是:如果我想在未来扩大规模，我不想排除容器引擎。尽管定价在某些方面限制了我，但它迫使我检查我的解决方案的重要权衡。尽管我现在的潜在负载很小，但我有一个扩展计划。</p><p id="44f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到这些限制，除了上面概述的更新程序之外，我还开发了两个Go服务器。这些都在一个Google计算引擎实例上的独立Docker容器中运行。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es md"><img src="../Images/95a6008698f85a4ec631d6dcef58457c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62wfDMW4WdOR6Ah7TOj6_Q.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">三个Go服务(HTTP前端、后端和更新程序)。后端和更新程序都从Google云存储中获取SQLite数据库。</figcaption></figure><h2 id="3f2d" class="lp jv hi bd jw lq lr ls ka lt lu lv ke jg lw lx kg jk ly lz ki jo ma mb kk mc bi translated">前端和后端</h2><p id="3dd3" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">一旦我从dump importer获得了SQL可查询形式的数据，后端服务器就很容易编写了。这是一个RPC服务，它从云存储中下载SQLite文件，然后运行查询来查找电影之间的最佳高尔夫。它使用简单的广度优先搜索。将其拆分为单独的二进制文件的好处是便于集成测试，也便于扩展。你可以想象，当我扩大规模时，我可以开始为后端服务提供更多的CPU内核，同时继续为前端提供最少的资源。前端同样简单:获取HTTP请求，将其转换为后端请求，然后呈现HTML。一旦有了数据，剩下的就容易了。</p><p id="381e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了调试，我将这两个服务器与Stackdriver日志和Stackdriver跟踪集成在一起。Stackdriver日志度量足够好，可以作为白盒监控源，因此我可以监控500级HTTP错误响应的增加。这些开箱即用的工具让GCP摇滚起来。</p><h2 id="d949" class="lp jv hi bd jw lq lr ls ka lt lu lv ke jg lw lx kg jk ly lz ki jo ma mb kk mc bi translated">DevOps时间！</h2><p id="7327" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">为了部署它，我直接使用了谷歌计算引擎。我使用了新的容器优化操作系统，所以我可以运行我的无状态Docker作业——注意Google云存储是唯一一个具有可变状态的服务。前端、后端和更新程序只有数据库的本地缓存，所以它们完全是可处理的。我可以通过创建一个新实例并删除旧实例来更新站点，尽管实际上，我只是更新systemd单元并重启服务。同样，如果我可以使用负载平衡器，这将更容易。</p><p id="c97f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Google Compute Engine的一个不幸的副作用是，由您(DevOp)来决定是否将日志放入Stackdriver日志。虽然确实存在日志代理，但它旨在用于非Dockerized环境。为了解决这个问题，我最终创建了一个systemd单元，它将把journalctl输出通过管道传输到FIFO，另一个systemd单元将通过stdin把管道的数据发送到google-fluentd Docker容器，然后使用google-fluentd配置把stdin发送到Stackdriver。google-fluentd配置(最难的部分)如下所示:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="6be0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但正如一位朋友向我指出的那样，我可能应该把google-fluentd去掉，在Go中编写一个自定义的日志转发任务。改天的任务！如果我在一个更受支持的配置中运行，这将会更容易。照现在的情况，在GCP运行这个相对容易。</p><h1 id="da77" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">经验教训</h1><p id="cfb2" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">简而言之，我的经验告诉我，设计时要时刻注意权衡——无论是简单性、可靠性、价格、资源使用还是速度。随着时间的推移，我考虑的权衡范围已经扩大。新版的电影《高尔夫》有更多的部分，但每个部分在概念上都做一件可以测试的事情，并且可以独立失败。对数据存储系统如何工作的理解无疑有助于指导我进行更好的设计。但是有趣的是，我的最后一种方法与我的第一种方法非常接近:将一个文件加载到内存中并运行高尔夫查询。对我来说，这是我学到的最重要的一课:只增加必要的复杂性。</p></div></div>    
</body>
</html>