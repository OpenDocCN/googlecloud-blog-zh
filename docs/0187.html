<html>
<head>
<title>ASP.NET sessions on Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云平台上的ASP.NET会议</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/asp-net-sessions-on-google-cloud-platform-4dddd2aa5333?source=collection_archive---------1-----------------------#2017-01-13">https://medium.com/google-cloud/asp-net-sessions-on-google-cloud-platform-4dddd2aa5333?source=collection_archive---------1-----------------------#2017-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fff2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蒂姆·斯内思写了一篇关于<a class="ae jd" href="https://blogs.msdn.microsoft.com/tims/2003/11/21/asp-net-session-state-architectural-and-performance-considerations/" rel="noopener ugc nofollow" target="_blank">存储与ASP.NET</a>的会话状态的好文章。这个故事试图建立在这些知识的基础上，并对<a class="ae jd" href="http://cloud.google.com/dotnet" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>上的选项进行评估。我衡量了每个选项的性能和成本，并提供了示例代码，可用于评估本文中未考虑的其他选项。</p><p id="8c87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">in proc会话状态提供程序。</strong></p><p id="fe54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，新的ASP.NET应用程序将使用Inproc会话状态提供程序。Inproc会话状态提供程序将会话状态存储在运行应用程序的<a class="ae jd" href="https://www.iis.net/" rel="noopener ugc nofollow" target="_blank">Internet Information Server</a>(IIS)进程中。Inproc会话状态提供程序是最快且最便宜的，但是当从web服务器场中升级或删除计算机时，可能会导致用户感到失望。</p><p id="b787" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">当Inproc会话状态提供者导致用户沮丧时。</strong></p><p id="30c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您在Google计算引擎上运行您的ASP.NET应用程序。用户喜欢你的应用，流量增长很快。现在，你有这么多的流量，你需要多个网络服务器来服务。因此，您<a class="ae jd" href="https://cloud.google.com/dotnet/docs/getting-started/using-instance-groups" rel="noopener ugc nofollow" target="_blank">创建了一个HTTP负载平衡器，并进行水平扩展</a>。</p><p id="0bf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">负载平衡器添加一个会话cookie，以便来自同一个web浏览器的请求总是到达同一个IIS。这对许多应用程序来说都很好。但是请注意:<a class="ae jd" href="https://cloud.google.com/compute/docs/load-balancing/http/backend-service#session_affinity" rel="noopener ugc nofollow" target="_blank">无论选择哪种类型的关联，web浏览器都可能会失去与其IIS的关联</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/86d5e58a4214215b1ea7270d619c072d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSG-dg5kE_DKvGYQp9_u2w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">自动清空购物车让用户不高兴。</figcaption></figure><p id="309d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最坏的情况下，一个用户在你的网站上购物，花了20分钟装载他们的购物车。他们所有的HTTP请求都由同一个IIS提供服务。用户单击“签出”按钮，与此同时，他们与之对话的IIS离线，可能是因为Windows更新。哦不！他们所有的购物车数据都存储在那个IIS中。当用户的请求到达一个新的IIS时，他们的购物车现在是空的！用户可能会因为失望而放弃你的网站，这是有原因的。</p><p id="a698" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在IIS外部存储会话数据。</strong></p><p id="0210" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免让用户感到沮丧，会话数据必须存储在IIS之外，这样，当web服务器启动和关闭时，用户的会话数据可以保留下来。</p><p id="ce0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我写了一个简单的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/tree/vs2015/sessionstate/WebApp" rel="noopener ugc nofollow" target="_blank">ASP.NET应用程序</a>。它显示一个允许用户设置会话变量的表单。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jv"><img src="../Images/f65f24e3ab420aa374a891da35926b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/0*fxFyRNUydfxd00G5."/></div></figure><p id="ed16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还编写了一个简单的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/tree/vs2015/sessionstate/WebClient" rel="noopener ugc nofollow" target="_blank"> HTTP客户端</a>来评估解决方案，包括Tim没有讨论的两个解决方案。这两个新的解决方案是<a class="ae jd" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>和<a class="ae jd" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank">谷歌云数据存储</a>。然后，我运行了谷歌云平台的us-central-1f区的所有代码。结果如下:</p><p id="eb7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Inproc </strong></p><ul class=""><li id="aa3e" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">速度:最快，亚毫秒。</li><li id="bd9c" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">扩展:水平扩展，具有上面讨论的会话相似性和警告。</li><li id="1527" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">价格:免费。IIS GCE实例之外不收费。</li><li id="cd3d" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">重启时丢失数据:是。</li></ul><p id="27b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">状态服务器</strong></p><ul class=""><li id="b100" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">速度:快，一毫秒或两毫秒。</li><li id="0e92" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">Scales:不，所有的会话都需要放在一个状态服务器中。</li><li id="3d7e" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">价格:<a class="ae jd" href="https://cloud.google.com/products/calculator/" rel="noopener ugc nofollow" target="_blank">预计每月18.69美元</a>用于f1-micro实例。</li><li id="c9b1" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">重启时丢失数据:是。</li></ul><p id="6a99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> SqlServer </strong></p><ul class=""><li id="5c7e" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">速度:快，一般不到10毫秒。</li><li id="ed4d" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">缩放:作为SQLServer水平缩放。</li><li id="989b" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">价格:<a class="ae jd" href="https://cloud.google.com/products/calculator/" rel="noopener ugc nofollow" target="_blank">一个n1-standard-1实例估计每月86.87美元</a>。</li><li id="7518" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">重启时丢失数据:没有</li></ul><p id="e312" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Redis </strong></p><ul class=""><li id="94cc" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">速度:中等，90毫秒左右。</li><li id="7ab1" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">缩放:水平方向为Redis集群。</li><li id="de07" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">价格:<a class="ae jd" href="https://cloud.google.com/products/calculator/" rel="noopener ugc nofollow" target="_blank">估计每月4.09美元</a>一个f1-微实例。</li><li id="a49d" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">重启时丢失数据:没有</li></ul><p id="b899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据存储</strong></p><ul class=""><li id="6201" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">速度:慢，300到400毫秒。</li><li id="1578" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">规模:无限，无需监督。</li><li id="814e" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">价格:每天8000页以下免费，之后每10万页收费0.54美元。</li><li id="eb6a" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">重启时丢失数据:没有</li></ul><p id="a5a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我实现了一个<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/vs2015/sessionstate/WebApp/Services/DatastoreSessionStateStoreProvider.cs" rel="noopener ugc nofollow" target="_blank">会话状态提供器</a>，它将会话存储在<a class="ae jd" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Datastore </a>中。这出乎意料地具有挑战性，因为SessionStateStoreProviderBase类比我预期的简单ReadSession()和WriteSession()接口复杂得多。相反，该接口具有类似LockAndReadSession()和WriteAndUnlockSession()的方法。<a class="ae jd" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Datastore </a>没有固有的锁定功能，所以我不得不使用计数器实现锁定。这意味着函数是这样实现的:</p><pre class="jf jg jh ji fd kk kl km kn aw ko bi"><span id="4183" class="kp kq hi kl b fi kr ks l kt ku">LockAndReadSession()<br/>  Begin transaction.<br/>  Read two entities.<br/>  Write one entity.<br/>  Commit transaction.</span><span id="0b9f" class="kp kq hi kl b fi kv ks l kt ku">WriteAndUnlockSession()<br/>  Begin transaction.<br/>  Read one entity.<br/>  Write one entity.<br/>  Commit transaction.</span></pre><p id="604e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，许多独立的操作产生了相对较慢的运行时间。当每日可用配额到期时，使用数据存储区的成本将为:</p><p id="3f7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3次读取+ 2次写入= 3 * 0.06美元+2 * 0.18美元=每100，000次页面查看0.54美元，<a class="ae jd" href="https://cloud.google.com/datastore/docs/pricing" rel="noopener ugc nofollow" target="_blank">不包括存储成本</a>。会话数据通常很小。</p><p id="77d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="9933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有一个最佳解决方案。您的应用程序的最佳选择将取决于对您的应用程序最重要的是什么:速度、价格、最小化用户挫折感，还是最小化维护负担。初创企业会喜欢Inproc和Redis，因为它们价格实惠。拥有数百万用户的大型应用程序会喜欢SqlServer的速度和可靠性。如果您的网页已经需要2秒或更多的时间来加载，那么用户可能不会注意到存储在数据存储中的会话的延迟，并且您永远不需要担心伸缩或维护。</p><p id="e212" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">免责声明:</strong></p><p id="4079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2017年1月9日测量了这些性能基准并计算了价格。它们不是保证。在选择会话状态解决方案时，您应该评估特定应用程序的性能和价格。</p></div></div>    
</body>
</html>