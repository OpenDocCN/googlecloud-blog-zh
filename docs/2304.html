<html>
<head>
<title>Dataproc — Why is my cluster not scaling?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dataproc —为什么我的集群没有伸缩？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/autoscaling-in-dataproc-e02bf446a509?source=collection_archive---------0-----------------------#2022-08-16">https://medium.com/google-cloud/autoscaling-in-dataproc-e02bf446a509?source=collection_archive---------0-----------------------#2022-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a765f0d18b8a2e39afd3c2903c2fed78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E59VT3ExQDT2NEhmb8pclg.png"/></div></div></figure><p id="f465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“Autoscaling”是一个Dataproc API，可以自动监控纱线内存使用情况，并添加/删除容量以实现最佳使用。它消除了针对季节性高峰过度调配群集的需求，以及可能导致业务关键型延迟的群集调配不足的风险。</p><p id="d396" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Dataproc的自动缩放控制平面(真正的阿甘正传风格)是</p><blockquote class="jo jp jq"><p id="1605" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">易如反掌</em></p></blockquote><p id="1a13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Dataproc试图将配置的复杂性保持在最小，这意味着可用于调整自动缩放策略的旋钮和杠杆并不多。</p><p id="3967" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于配置如此之少，当客户遇到自动扩展问题时，他们通常会疑惑——“我们哪里出了问题？”</p><p id="1ae3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本帖中，我们将用一个常见的答案来回答客户在使用自动缩放时提出的3个问题</p><ol class=""><li id="a610" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">为什么我的集群没有纵向扩展，尽管我有新的工作负载激增？</li><li id="284d" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">为什么我的集群没有向下扩展？尽管只有非常小的工作负载在运行，为什么我还要为空闲节点付费？</li><li id="0d74" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">为什么群集长时间处于“正在更新”状态，并且不允许我对群集执行其他更新？</li></ol></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="14dd" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">很高兴知道</strong></h1><p id="7660" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">一个Dataproc集群有1或3个(对于HA)运行名称节点守护进程的主节点，以及一堆执行所有繁重工作(计算)的工作机。有两种类型的工人-</p><ul class=""><li id="3012" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn lt kb kc kd bi translated">主要员工—参与HDFS存储并为计算做出贡献的员工</li><li id="bfa6" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn lt kb kc kd bi translated">次要员工—不参与HDFS，仅执行计算的员工</li></ul><p id="99fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用此设置，您可以根据需要添加或删除辅助员工，而不会影响任何HDFS数据。可以手动添加/删除辅助工作器，也可以使用自动缩放API。</p><blockquote class="jo jp jq"><p id="3a2e" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">初级工人也可以按比例增减，但不建议这样做。您通常会希望根据BAU工作负载调整基本容量(主工作人员池)的大小，并使用辅助工作人员来适应高峰工作负载。</p></blockquote><p id="1fb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">截至2022年，Dataproc在决定是否缩放时仅考虑纱线内存。算法很简单—</p><ul class=""><li id="3f94" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn lt kb kc kd bi translated">如果群集中的“可用内存”多于“待定内存”，请尝试移除节点</li><li id="9e03" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn lt kb kc kd bi translated">如果群集中的“待定内存”多于“可用内存”，请尝试添加节点</li></ul><p id="dd2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算背后有一点七年级的数学，但我们将在这篇文章中跳过这些实现细节。<a class="ae lu" href="https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/autoscaling#how_autoscaling_works" rel="noopener ugc nofollow" target="_blank">点击这里</a>阅读更多。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="fbd8" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">解决办法</h1><p id="2513" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated"><strong class="is hj">故障排除</strong></p><p id="76e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Dataproc不允许并发更新。这意味着，如果集群正在进行任何类型的更新—标签被重命名、集群被调整大小、属性被修改等等，则在此期间不能执行任何其他更新操作。</p><p id="54e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">调整集群的大小，即向集群添加/删除额外的节点，是一种发生在Dataproc的控制平面中的更新操作。</p><p id="b074" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为自动缩放引擎所做建议的一部分，群集可能正在进行缩减操作，尽管新的工作负载需要额外的内存，但这会阻止进一步的更新。</p><p id="831f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缩减操作考虑了多种因素。简而言之，一旦autoscaler引擎确定集群中有可以删除的节点，它会将这些节点标记为删除，相应的容量会立即从Yarn中移除。然而，这些机器不会立即死亡。如果机器上已经运行了应用程序，或者包含等待提供给在其他节点上运行的应用程序的随机/临时数据，那么Dataproc将等待作业完成，或者等待随机数据被提供，或者等待正常退役超时窗口关闭，以较早者为准。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3f70" class="me kr hi ma b fi mf mg l mh mi">Time taken to complete downscaling = <br/>MIN <br/>(<br/>time taken by existing applications to finish, <br/>time taken for shuffle data on the node to get served, <br/>graceful decommissioning timeout<br/>)</span></pre><p id="8417" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着，在许多情况下，缩小规模不是一个瞬间的活动，可能导致集群处于长期的"更新"期。这在不使用增强灵活性模式和长时间正常停用超时(GDT)的情况下尤其普遍。</p><p id="6ff1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要验证这一点，请转到云日志记录，并使用此MQL过滤到自动缩放日志—</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="eeb3" class="me kr hi ma b fi mf mg l mh mi">resource.type="cloud_dataproc_cluster"<br/>resource.labels.cluster_name="&lt;cluster-name&gt;"<br/>log_name="projects/&lt;project&gt;/logs/dataproc.googleapis.com%2Fautoscaler"</span></pre><p id="49a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该MQL将获取该群集的所有自动缩放日志。确定您的分类是否具有较长的缩减窗口模式的一种快速方法是查看日志记录中生成的直方图。为了获得更明确的描述，将时间窗口增加到您的正常退役超时的一个因子(至少2倍)。</p><p id="27cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，我用了6个小时，因为GDT是3个小时</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/ecfad627b58a03c6ea5eff1629c83171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7iHxMrKCLEy9Jvv5u6c5w.png"/></div></div></figure><p id="2ea2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意自动缩放器如何显示日志记录活动的突发，静默3小时，然后在再次静默之前再次唤醒？这3个小时是自动缩放策略的GDT。这表明群集经常运行在这样一种情况下，即许多空闲节点在被删除之前都在等待提供随机数据。</p><p id="a07b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一些影响- <br/> -您为空闲节点付费，因为集群已经缩减了规模，但机器仍在运行。<br/> -在达到GDT之前，不会为新工作负载提供额外容量。</p><p id="620f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">那么我们能做些什么呢？</strong></p><ul class=""><li id="fc8c" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn lt kb kc kd bi translated">这个想法是让GDT窗口尽可能接近于零。如果您的应用程序具有足够的弹性，并且由于重启而导致的延迟是可以接受的，那么将GDT设置为一个较低的值(甚至为零)，这样无论节点是否空闲，都会立即删除它们。快速失败，更快恢复。</li><li id="4f3e" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn lt kb kc kd bi translated"><a class="ae lu" href="https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/flex" rel="noopener ugc nofollow" target="_blank">增强灵活性模式或EFM </a>是Dataproc提供的一项功能，它允许将数据仅存储在主工作节点中，从而允许辅助工作节点立即缩减规模。当然，在它们上面运行的任何应用程序都需要在不同的节点上重新启动。</li><li id="ed52" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn lt kb kc kd bi translated">如果修改GDT不符合您的业务需求，您可以调整自动扩展策略中的以下旋钮—<br/><strong class="is hj">—扩展/缩减因子(0–1)</strong><br/>这控制了如何积极地<strong class="is hj">扩展或缩减集群。<br/>下图说明了放大系数的工作原理。除了变量是可用内存之外，缩小因子的数学运算也是一样的。</strong></li></ul><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="01d6" class="me kr hi ma b fi mf mg l mh mi">Let’s say that the amount of memory to scale up by = f(x,y,z)<br/>where<br/>x = Number of pending containers, e.g. — 100<br/>y = Memory requested by each container, e.g.- 512 MB<br/>z = Scale up factor, e.g. — 0.5</span><span id="dbd0" class="me kr hi ma b fi mk mg l mh mi">Therefore, the total pending YARN memory = x*y = 50 GB<br/>Amount of memory to scale up by = Total pending YARN memory*Scale up factor = 25GB</span><span id="265f" class="me kr hi ma b fi mk mg l mh mi">So if each node has 8 GB of memory and assuming 80% allocation to YARN,</span><span id="baa7" class="me kr hi ma b fi mk mg l mh mi">For z=0.5, number of nodes = 100*512*0.5 / (8*1000)*0.8 = 4<br/>For z=1, number of nodes = 100*512*1 / (8*1000)*0.8 = 8</span></pre><p id="84d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> -放大/缩小最小工人比例<br/> </strong>这控制<strong class="is hj">如何频繁地</strong>放大或缩小集群。<br/>和前面的观点一样，下图适用于两种分数。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="1964" class="me kr hi ma b fi mf mg l mh mi">Let the amount of memory to scale up by = f(x,y,z)<br/>where<br/>x = Number of pending containers, e.g. — 100<br/>y = Memory requested by each container, e.g.- 512 MB<br/>z = Scale up factor, e.g. — 0.5<br/>N = Number of nodes in the cluster, e.g. — 20<br/>S = scaleUpMinWorkerFraction, e.g. — 0.3<br/>M = N*S = 6 nodes</span><span id="0933" class="me kr hi ma b fi mk mg l mh mi">Total pending YARN memory = x*y = 50 GB<br/>Amount of memory to scale up by = Total pending YARN memory*Scale up factor = 25GB</span><span id="61ac" class="me kr hi ma b fi mk mg l mh mi">So if each node has 8 GB of memory and assuming 80% allocation to YARN</span><span id="de2b" class="me kr hi ma b fi mk mg l mh mi">For z=0.5 —<br/>Nodes = 100*512*0.5 / (8*1000)*0.8 = 4.<br/>Since this is less than M = 6, no scale up will occur</span><span id="9766" class="me kr hi ma b fi mk mg l mh mi">For z=1 —<br/>Nodes = 100*512*1 / (8*1000)*0.8 = 8.<br/>Since this is greater than M = 6, cluster will scale up by 8</span></pre><ul class=""><li id="45ec" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn lt kb kc kd bi translated">如果<strong class="is hj">缩小最小工作人员比例</strong>设置为更高的值，那么只有当有更大的节点块要删除时，集群才会缩小。这将降低缩减的频率，从而降低提交额外工作负载时集群处于更新状态的概率。这也有助于减少集群容量的频繁波动。</li></ul><h1 id="be67" class="kq kr hi bd ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln bi translated">摘要</h1><p id="51ae" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">这篇文章详细介绍了更新操作停滞或不能正常工作的几个原因之一。大多数其他原因归结为基础设施问题或服务损坏。本文中详细介绍的故障排除解释了应用程序逻辑或集群配置产生的原因。Dataproc的自动伸缩策略试图使最终用户的实现尽可能简单，但是如果没有适当的调整，它会导致不稳定的性能和增加的成本。</p></div></div>    
</body>
</html>