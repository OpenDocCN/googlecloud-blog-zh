<html>
<head>
<title>Golang Modules &amp; Immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang模和不变性</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/golang-modules-immutability-9b2fddda1dd8?source=collection_archive---------0-----------------------#2019-07-10">https://medium.com/google-cloud/golang-modules-immutability-9b2fddda1dd8?source=collection_archive---------0-----------------------#2019-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">昨天写了一篇<a class="ae jd" rel="noopener" href="/google-cloud/golang-before-after-modules-273b5a5df838">总结</a>我最近切换到Go的模块。在结论中，我写道我将在我的项目中转向单一的<code class="du je jf jg jh b">${GOPATH}</code>。模块的优点之一是，包的版本应该是不可变的。这意味着，一旦你拉了一次包，你就不应该(必须)再拉一次包。</p><p id="1f6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，当然，如果你只使用一台机器，那也是可行的。但是，举例来说，当你使用Docker时会发生什么呢？有没有办法把这个扩展到Google Cloud Build？</p><h2 id="d74b" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">码头工人建造</h2><p id="3b57" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">让我们在示例中添加一个distroless Docker构建。在<code class="du je jf jg jh b">${WORKDIR}</code>中创建这个Dockerfile:</p><pre class="ki kj kk kl fd km jh kn ko aw kp bi"><span id="b7fa" class="ji jj hi jh b fi kq kr l ks kt">FROM golang:1.12 as build</span><span id="a887" class="ji jj hi jh b fi ku kr l ks kt">RUN printf "[timer] start\t%s\n" $(date +%s%N)</span><span id="31f3" class="ji jj hi jh b fi ku kr l ks kt">COPY ./foo /foo<br/>WORKDIR /foo<br/>RUN GO111MODULE=on GOPROXY=<a class="ae jd" href="https://proxy.golang.org" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org</a> go build foo</span><span id="a063" class="ji jj hi jh b fi ku kr l ks kt">RUN printf "[timer] end\t%s\n" $(date +%s%N)</span><span id="64ae" class="ji jj hi jh b fi ku kr l ks kt">FROM gcr.io/distroless/base</span><span id="feb3" class="ji jj hi jh b fi ku kr l ks kt">COPY --from=build /foo /<br/>CMD ["/foo"]</span></pre><p id="dc9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是运行10次的结果，确保Docker不会在使用<code class="du je jf jg jh b">--no-cache</code>的构建之间缓存层:</p><pre class="ki kj kk kl fd km jh kn ko aw kp bi"><span id="43a4" class="ji jj hi jh b fi kq kr l ks kt">for t in {1..10}<br/>do<br/>  docker build \<br/>  <strong class="jh hj">--no-cache</strong> \<br/>  --tag=foo:latest . \<br/>  | grep "^\[timer\]"<br/>done</span><span id="1272" class="ji jj hi jh b fi ku kr l ks kt">[timer] start 1562692830352570907<br/>[timer] end   1562692833701779047<br/>[timer] start 1562692837743692624<br/>[timer] end   1562692841088710635<br/>[timer] start 1562692845149766319<br/>[timer] end   1562692848465842721<br/>[timer] start 1562692852464160691<br/>[timer] end   1562692855829662065<br/>[timer] start 1562692859765082861<br/>[timer] end   1562692863149075221<br/>[timer] start 1562692867096511753<br/>[timer] end   1562692870563710328<br/>[timer] start 1562692874552237719<br/>[timer] end   1562692877931096022<br/>[timer] start 1562692881991442336<br/>[timer] end   1562692885298613761<br/>[timer] start 1562692889252781564<br/>[timer] end   1562692892541429803<br/>[timer] start 1562692896460210629<br/>[timer] end   1562692899837684581</span></pre><p id="584b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其根据Sheets具有3357913011的平均值和50407471纳秒的标准偏差。</p><h2 id="b145" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">Docker副本</h2><p id="975e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">这不是一个很好的解决方案，但是不可能在Docker构建期间挂载Docker卷(这样会更好)。修改(或创建另一个docker文件):</p><pre class="ki kj kk kl fd km jh kn ko aw kp bi"><span id="5881" class="ji jj hi jh b fi kq kr l ks kt">FROM golang:1.12 as build</span><span id="fb9a" class="ji jj hi jh b fi ku kr l ks kt">RUN printf "[timer] start\t%s\n" $(date +%s%N)</span><span id="41a5" class="ji jj hi jh b fi ku kr l ks kt"><strong class="jh hj">COPY ./go/pkg /go<br/></strong>COPY ./foo /foo<strong class="jh hj"><br/></strong>WORKDIR /foo<br/>RUN GO111MODULE=on GOPROXY=<a class="ae jd" href="https://proxy.golang.org" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org</a> go build foo</span><span id="3e32" class="ji jj hi jh b fi ku kr l ks kt">RUN printf "[timer] end\t%s\n" $(date +%s%N)</span><span id="43cc" class="ji jj hi jh b fi ku kr l ks kt">FROM gcr.io/distroless/base</span><span id="64e2" class="ji jj hi jh b fi ku kr l ks kt">COPY --from=build /foo /<br/>CMD ["/foo"]</span></pre><p id="2471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，我们将通过将<code class="du je jf jg jh b">golang-module-mirror</code>作为<code class="du je jf jg jh b">/go</code>安装到容器中来运行测试。在我们将丢弃的第一次运行中，将创建我们的镜像，后续运行将使用它:</p><pre class="ki kj kk kl fd km jh kn ko aw kp bi"><span id="315c" class="ji jj hi jh b fi kq kr l ks kt">[timer] start 1562694281225041674<br/>[timer] end   1562694285811156939<br/>[timer] start 1562694289319807596<br/>[timer] end   1562694293776883985<br/>[timer] start 1562694297206823489<br/>[timer] end   1562694301530111138<br/>[timer] start 1562694304936211074<br/>[timer] end   1562694309252913601<br/>[timer] start 1562694312650657096<br/>[timer] end   1562694316880599577<br/>[timer] start 1562694320360184122<br/>[timer] end   1562694324700460041<br/>[timer] start 1562694328110722373<br/>[timer] end   1562694332475305957<br/>[timer] start 1562694335900959477<br/>[timer] end   1562694340500560831<br/>[timer] start 1562694343962632837<br/>[timer] end   1562694348394060653<br/>[timer] start 1562694351868504357<br/>[timer] end   1562694356285662159</span></pre><p id="409c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大概是因为我的本地缓存如此之小(只有<code class="du je jf jg jh b">glog</code>)，所以到达<code class="du je jf jg jh b">COPY</code>的时间大大超过了这里的好处。平均值为4406618035，标准偏差为117921035.6。</p><h2 id="5674" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">谷歌云构建</h2><p id="fc22" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">我写过几次关于Google Cloud Build的文章。这是一个低调而引人注目的服务，它提供了一种机制来运行一系列容器图像，将结果从一个传递到下一个。最(！)的时候，该服务用于构建容器映像，但是它可以用于构建更多的资产。</p><p id="a964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我意识到，默认情况下，使用一个<code class="du je jf jg jh b">library/Golang</code>映像而不是<code class="du je jf jg jh b">gcr.io/cloud-builders/go</code>映像，需要在构建步骤之间持久化，例如<code class="du je jf jg jh b">/go</code>，以便两个不同的<code class="du je jf jg jh b">golang</code>步骤可以共享一个<code class="du je jf jg jh b">${GOPATH}</code>。</p><p id="dea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案是使用云构建卷(见下文)。在本例中，名为<code class="du je jf jg jh b">go-modules</code>的卷被创建并安装在<code class="du je jf jg jh b">/go</code>上，用于需要它的第一个步骤，并且该卷一直存在，直到没有其他步骤引用它。对于随后引用它的每个步骤，例如<code class="du je jf jg jh b">go get</code>包的缓存被保留。</p><blockquote class="kv kw kx"><p id="2cf7" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj">2019–07–10更新</strong>:我了解到云构建允许一个<code class="du je jf jg jh b">options</code>节(<a class="ae jd" href="https://cloud.google.com/cloud-build/docs/build-config#options" rel="noopener ugc nofollow" target="_blank">链接</a>)，允许<code class="du je jf jg jh b">env</code>和<code class="du je jf jg jh b">volumes</code>节被定义一次并应用于每一步，而不是像我下面这样在每一步重复。</p></blockquote><pre class="ki kj kk kl fd km jh kn ko aw kp bi"><span id="4bd7" class="ji jj hi jh b fi kq kr l ks kt">steps:</span><span id="ec0b" class="ji jj hi jh b fi ku kr l ks kt">- name: golang:1.12<br/>  env:<br/>  - GOPATH=/go<br/>  - GO111MODULE=on<br/>  - GOPROXY=<a class="ae jd" href="https://proxy.golang.org" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org</a><br/>  <strong class="jh hj">dir</strong>: foo<br/>  args:<br/>  - go<br/>  - build<br/>  - -o<br/>  - /go/bin/<strong class="jh hj">test1</strong><br/>  - foo<br/>  <strong class="jh hj">volumes</strong>:<br/>  - name: go-modules<br/>    path: /go</span><span id="275a" class="ji jj hi jh b fi ku kr l ks kt">- name: golang:1.12<br/>  env:<br/>  - GOPATH=/go<br/>  - GO111MODULE=on<br/>  - GOPROXY=<a class="ae jd" href="https://proxy.golang.org" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org</a><br/>  <strong class="jh hj">dir</strong>: foo<br/>  args:<br/>  - go<br/>  - build<br/>  - -o<br/>  - /go/bin/<strong class="jh hj">test2</strong><br/>  - foo<br/>  <strong class="jh hj">volumes</strong>:<br/>  - name: go-modules<br/>    path: /go</span><span id="43d3" class="ji jj hi jh b fi ku kr l ks kt">- name: golang:1.12<br/>  env:<br/>  - GOPATH=/go<br/>  - GO111MODULE=on<br/>  - GOPROXY=<a class="ae jd" href="https://proxy.golang.org" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org</a><br/>  <strong class="jh hj">dir</strong>: foo<br/>  args:<br/>  - go<br/>  - build<br/>  - -o<br/>  - /go/bin/<strong class="jh hj">test3</strong><br/>  - foo<br/>  <strong class="jh hj">volumes</strong>:<br/>  - name: go-modules<br/>    path: /go</span><span id="4e91" class="ji jj hi jh b fi ku kr l ks kt">- name: busybox<br/>  args:<br/>  - ls<br/>  - -l<br/>  - /go/bin<br/>  <strong class="jh hj">volumes</strong>:<br/>  - name: go-modules<br/>    path: /go</span></pre><blockquote class="kv kw kx"><p id="80e2" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">我认为<code class="du je jf jg jh b">GOPATH=/go</code>在这里是多余的，因为这是<code class="du je jf jg jh b">Golang</code>图像的默认工作目录。</p><p id="43c6" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">因为云构建使用<code class="du je jf jg jh b">/workspace</code>作为工作目录，我们的源代码将位于<code class="du je jf jg jh b">/workspace/foo</code>而不是我们的包等。被持久保存在<code class="du je jf jg jh b">/go</code>中。</p><p id="321f" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">因为我们的源代码在<code class="du je jf jg jh b">/workspace</code>的子目录中，所以我使用云构建的<code class="du je jf jg jh b">dir</code>修饰符使<code class="du je jf jg jh b">/workspace/foo</code>成为构建的工作目录。</p><p id="21d1" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>我正在使用<code class="du je jf jg jh b">GOPROXY</code>来利用Golang团队的围棋模块镜像。</p></blockquote><p id="16d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在这个不可否认的小例子中，每次构建(相同的东西)都会创建一个不同名称的二进制文件(<code class="du je jf jg jh b">testX</code>)并将它放在共享的<code class="du je jf jg jh b">/go/bin</code>目录中。</p><p id="279c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做的目的是展示在第一次构建时，包是如何缓存在<code class="du je jf jg jh b">/go/pkg</code>中的:</p><pre class="ki kj kk kl fd km jh kn ko aw kp bi"><span id="12c9" class="ji jj hi jh b fi kq kr l ks kt">gcloud builds submit \<br/>--config=./cloudbuild.yaml \<br/>--project=[[YOUR-PROJECT]]</span><span id="5cdc" class="ji jj hi jh b fi ku kr l ks kt">...<br/>starting build "22137c6c-df17-418b-8177-c231dd34b719"</span><span id="4112" class="ji jj hi jh b fi ku kr l ks kt">FETCHSOURCE<br/>...<br/>BUILD<br/>Starting Step #0<br/>Step #0: Pulling image: golang:1.12<br/>Step #0: 1.12: Pulling from library/golang<br/>Step #0: Digest: sha256:3fee5835...<br/>Step #0: Status: Downloaded newer image for golang:1.12<br/><strong class="jh hj">Step #0: go: finding github.com/golang/glog v0.0.0</strong><br/>Finished Step #0<br/>Starting Step #1<br/>Step #1: Already have image: golang:1.12<br/>Finished Step #1<br/>Starting Step #2<br/>Step #2: Already have image: golang:1.12<br/>Finished Step #2<br/>Starting Step #3<br/>Step #3: Pulling image: busybox<br/>Step #3: Using default tag: latest<br/>Step #3: latest: Pulling from library/busybox<br/>Step #3: Digest: sha256:bf510723...<br/>Step #3: Status: Downloaded newer image for busybox:latest<br/>Step #3: total 5892<br/>Step #3: <strong class="jh hj">test1</strong><br/>Step #3: <strong class="jh hj">test2</strong><br/>Step #3: <strong class="jh hj">test3</strong><br/>Finished Step #3<br/>PUSH<br/>DONE</span></pre><p id="188b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果我们删除|注释掉对<code class="du je jf jg jh b">volumes</code>的引用，并删除<code class="du je jf jg jh b">busybox</code>步骤，因为在<code class="du je jf jg jh b">go/bin</code>中没有创建任何文件，然后重新运行构建:</p><pre class="ki kj kk kl fd km jh kn ko aw kp bi"><span id="0416" class="ji jj hi jh b fi kq kr l ks kt">starting build "3837eb7d-dae6-476e-9e72-67ee2f57de86"</span><span id="2f8a" class="ji jj hi jh b fi ku kr l ks kt">FETCHSOURCE<br/>...<br/>BUILD<br/>Starting Step #0<br/>Step #0: Pulling image: golang:1.12<br/>Step #0: 1.12: Pulling from library/golang<br/>Step #0: Digest: sha256:3fee5835...<br/>Step #0: Status: Downloaded newer image for golang:1.12<br/><strong class="jh hj">Step #0: go: finding github.com/golang/glog v0.0.0</strong><br/>Finished Step #0<br/>Starting Step #1<br/>Step #1: Already have image: golang:1.12<br/><strong class="jh hj">Step #1: go: finding github.com/golang/glog v0.0.0</strong><br/>Finished Step #1<br/>Starting Step #2<br/>Step #2: Already have image: golang:1.12<br/><strong class="jh hj">Step #2: go: finding github.com/golang/glog v0.0.0</strong><br/>Finished Step #2<br/>PUSH<br/>DONE</span></pre><p id="d9c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，您将看到每次运行构建时都提取了<code class="du je jf jg jh b">glog</code>包。这是因为我们没有在构建步骤中共享<code class="du je jf jg jh b">go/pkg</code>。</p><p id="40db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果您有一个现有的多阶段docker文件，或者您有一个包含几个二进制文件的repo，并且您希望为每个二进制文件发出不同的容器映像，那么我怀疑这种机制会节省时间。</p></div></div>    
</body>
</html>