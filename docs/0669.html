<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/google-cloud/dead-letter-queues-simple-implementation-strategy-for-cloud-pub-sub-80adf4a4a800?source=collection_archive---------0-----------------------#2018-06-27">https://medium.com/google-cloud/dead-letter-queues-simple-implementation-strategy-for-cloud-pub-sub-80adf4a4a800?source=collection_archive---------0-----------------------#2018-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><blockquote class="hg"><p id="6fc6" class="hh hi hj bd hk hl hm hn ho hp hq hr dx translated"><strong class="ak"> <em class="hs">注意:这是在发布/订阅不支持死信队列时创作的。请使用产品原生死信主题:https://cloud.google.com/pubsub/docs/dead-letter-topics</em>T3】</strong></p></blockquote><p id="079c" class="pw-post-body-paragraph ht hu hj hv b hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hr hb bi translated">不要再往下读了，转到https://cloud.google.com/pubsub/docs/dead-letter-topics<a class="ae iq" href="https://cloud.google.com/pubsub/docs/dead-letter-topics" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="4a9f" class="ir is hj bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">云发布/订阅和死信队列的错误处理策略</h1><p id="36b5" class="pw-post-body-paragraph ht hu hj hv b hw jp hy hz ia jq ic id ie jr ig ih ii js ik il im jt io ip hr hb bi translated">有时客户会问我关于云发布/订阅的死信队列(他们提到其他一些云提供商也有这个功能)。</p><p id="0ad0" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">什么是死信队列？本质上，它们是您发送无法正常处理的消息的地方。假设您有一个消息队列。您可能希望定义一个策略，在处理某个消息失败N次后，队列将停止向订阅者重新传递该消息，而是将其发布到另一个队列。另一个队列保存错误消息(因此是死信)。那个队列有什么用？嗯，您可能想要跟踪错误的消息，记录并监控它们，或者可能修复一些代码，再次使用它们并处理它们。这是死信队列的经典用法。</p><h2 id="e1fd" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">实现死信邮差</h2><p id="52a2" class="pw-post-body-paragraph ht hu hj hv b hw jp hy hz ia jq ic id ie jr ig ih ii js ik il im jt io ip hr hb bi translated">在本帖中，我们将讨论一个可以在您的消费者中实现的死信队列策略。</p><h2 id="3c96" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">你需要什么</h2><ol class=""><li id="ea4c" class="kn ko hj hv b hw jp ia jq ie kp ii kq im kr hr ks kt ku kv bi translated">您的云发布/订阅主题和订阅。</li><li id="ff10" class="kn ko hj hv b hw kw ia kx ie ky ii kz im la hr ks kt ku kv bi translated">一个键值存储。它可以是redis(你检查过我们现在处于测试阶段的新云内存存储吗？)，它可以是memcache、bigtable或sql，这取决于您的潜在吞吐量和您喜欢的内容。</li><li id="d8a1" class="kn ko hj hv b hw kw ia kx ie ky ii kz im la hr ks kt ku kv bi translated">死信的云发布/订阅主题和订阅。为什么需要订阅？让我提醒您，发送到没有订阅的主题的消息实际上是被丢弃的，因此订阅是非常重要的。</li><li id="6a3f" class="kn ko hj hv b hw kw ia kx ie ky ii kz im la hr ks kt ku kv bi translated">有能力和意愿对你的申请做一些改变。</li></ol><p id="c8c3" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">下图描述了数据流:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es lb"><img src="../Images/94da9054f81cf58f6852248493085bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*1kI_F6m2izlZXLZYDiJd0Q.png"/></div></figure><h2 id="157a" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">那么发生了什么？</h2><p id="d704" class="pw-post-body-paragraph ht hu hj hv b hw jp hy hz ia jq ic id ie jr ig ih ii js ik il im jt io ip hr hb bi translated">云发布/订阅用户可以以多种形式出现。也许你有使用python的容器轮询。也许您在Java中有计算引擎实例轮询。也许你有一个用Java或Python实现的云数据流管道。也许你正在使用云发布/订阅的推送功能，并通过你的网络服务器接收消息。你明白我的意思。</p><p id="faa6" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">我的意图不是提供实现，而更多的是提供一种可以适应自己需求的模式。</p><p id="b66d" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">假设您已经准备好了云发布/订阅主题+订阅，我们必须为死信队列创建一个新主题和(至少)一个订阅。</p><p id="e150" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">在云壳(或任何其他支持gcloud的环境)中:</p><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="1d03" class="jz is hj lk b fi lo lp l lq lr">gcloud pubsub topics create dead-letters<br/>gcloud pubsub subscriptions create --topic dead-letters error-monitoring-sub</span></pre><p id="90d5" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">这将创建一个名为dead-letters的云发布/订阅主题，然后将一个名为error-monitoring-sub的订阅附加到该主题。</p><h2 id="bf6f" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">键值存储架构</h2><p id="e9b6" class="pw-post-body-paragraph ht hu hj hv b hw jp hy hz ia jq ic id ie jr ig ih ii js ik il im jt io ip hr hb bi translated">让我们从钥匙开始。我认为，在一般情况下，您需要表达主题+订阅+消息id的唯一性。消息id在一个主题中是唯一的，但也可能是一种类型的订阅者可以顺利处理消息，而另一种订阅者会失败。这就是为什么我们订阅了？所以这三者的简单结合是这里的关键。该值可以是您认为适合存储的任何值，如果您有特定于应用程序的数据，例如消息有效负载等。</p><p id="3d0f" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">就像我说的，键值存储有很多选择，我将在谷歌云平台上使用redis和新的Memorystore。请注意，在输入这些内容时，Memorystore仍处于测试阶段。</p><p id="74cc" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">下一行在美国中心1区的Memorystore上创建一个名为“error-tracker”的redis实例(连接到默认网络):</p><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="64d8" class="jz is hj lk b fi lo lp l lq lr">gcloud beta redis instances create error-tracker --region=us-central1</span><span id="5693" class="jz is hj lk b fi lt lp l lq lr">gcloud beta redis instances list  --region=us-central1 <br/>INSTANCE_NAME  REGION       TIER   SIZE_GB  HOST      PORT  NETWORK  RESERVED_IP  STATUS  CREATE_TIME <br/>error-tracker  us-central1  BASIC  1        10.0.0.3  6379  default  10.0.0.0/29  READY   2018-06-19T17:40:12</span></pre><p id="5598" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">现在我们有了一些redis的优点，我们可以记下ip地址(在本例中是10.0.0.3)并继续我们的代码。</p><p id="f65f" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">确保您的虚拟机/实例至少拥有“发布/订阅订阅者”和“发布/订阅发布者”的权限。</p><p id="4677" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">让我们用python写一些示例行为代码(官方的说法是python客户端仍处于测试阶段)，但是您或多或少可以适应任何语言。</p><h2 id="d832" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">设置:</h2><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="9717" class="jz is hj lk b fi lo lp l lq lr">from functools import wraps<br/>import redis<br/>import os<br/>import time</span><span id="3ed4" class="jz is hj lk b fi lt lp l lq lr">os.environ['GOOGLE_CLOUD_PROJECT'] = 'myproject'</span><span id="c1c5" class="jz is hj lk b fi lt lp l lq lr">FAIL_LIMIT = 5</span><span id="bd4a" class="jz is hj lk b fi lt lp l lq lr"># Our subscription to the work topic<br/>subscription_name = 'projects/{project_id}/subscriptions/{sub}'.format(<br/>     project_id=os.getenv('GOOGLE_CLOUD_PROJECT'),<br/>     sub='work-subscription',  # Set this to something appropriate.<br/> )<br/> <br/># Our publisher for the dead letter queue <br/>dead_letter_queue_topic = 'projects/{project_id}/topics/{topic}'.format(<br/>     project_id=os.getenv('GOOGLE_CLOUD_PROJECT'),<br/>     topic='dead-letters',  # Set this to something appropriate.<br/>)</span></pre><p id="5e68" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">在这里，我们只执行基本的导入，并获取我们要从中提取的订阅的完全限定名和我们要推送的死信主题的完全限定名。</p><p id="285d" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">注意FAIL_LIMIT = 5，这是我们对每条消息的容错能力(也就是说，如果一条消息失败的次数超过FAIL_LIMIT的次数</p><h2 id="1439" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">消息处理程序</h2><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="5ffb" class="jz is hj lk b fi lo lp l lq lr">def pubusb_message_handler(f):<br/>"""<br/>  A decorator for handling a pub/sub message. It handles the error    handling and acking.<br/>"""<br/>  <a class="ae iq" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(f)<br/>  def wrapper(message):<br/>    try:<br/>      result =  f(message)<br/>      message.ack()<br/>      return result<br/>    except Exception, ex:<br/>      handle_error(ex, message)<br/>  return wrapper</span></pre><p id="cf07" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">这是一个用于处理pubsub消息的装饰器。这里的流程相对简单。运行修饰函数，如果没有出现异常，则确认消息。如果出现异常，那么让handle_error函数来处理。</p><h2 id="7be0" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">处理错误</h2><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="597a" class="jz is hj lk b fi lo lp l lq lr">def handle_error(ex, message):<br/> """<br/>  Handling errors when there is a failure of handling a message<br/> """<br/> key = create_key(message.message_id)<br/> counter = get_fail_count(key)        <br/> if counter &gt;= FAIL_LIMIT:<br/>            print "message %s failed" % (message.message_id)<br/>            error_notifier = pubsub.PublisherClient()<br/>            error_notifier.publish(dead_letter_queue_topic, message.data, **message.attributes)<br/>            message.ack()  <br/> else:<br/>            wait_time = calc_wait_time(counter)<br/>            time.sleep(wait_time)<br/>            raise ex</span></pre><p id="debe" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">我们来谈谈错误处理程序。这里的流程变得(有点)复杂。</p><p id="d0b9" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">我们调用一个名为“create_key”的函数，该函数在本例中接受消息id并返回一个惟一的标识符，该标识符被传递给访问数据存储的get_fail_count。</p><p id="eee2" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">如果达到了阈值，我们将消息发布到死信队列，然后确认它，这样我们就不会再次处理它。如果我们还没有达到阈值，我们会尝试看看是否要在返回之前休眠一段时间(在某些情况下可能有用)，然后再引发异常。</p><h2 id="2ee7" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">助手</h2><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="9327" class="jz is hj lk b fi lo lp l lq lr">def calc_wait_time(fail_count):<br/> # In case you want to wait some arbitrary time before your message "fails"<br/> return fail_count</span><span id="ed32" class="jz is hj lk b fi lt lp l lq lr">def create_key(message_id):<br/> """<br/>  This helper function creates a unique key for a message<br/> """<br/> return "%s_%s" % (subscription_name, message_id)</span></pre><p id="ec0c" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">这里的create_key函数只是将订阅名称与消息id连接起来，这是因为消息id在主题中是惟一的，我们希望为订阅创建一个惟一的键。</p><p id="3fa4" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">calc_wait_time基本上可以根据您喜欢的任何逻辑进行编码(也许是一些后退？)，但这实际上取决于您为拉式主题配置的确认时间。这里我只返回失败的次数，这是我们等待的秒数。</p><h2 id="26c6" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">访问我们的键值存储</h2><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="f6e5" class="jz is hj lk b fi lo lp l lq lr">def get_fail_count(key):<br/> """<br/>  This function wraps the data store logic. In this case we access redis, but this can be implemented with bigtable, spanner, sql, cassandra, etc.<br/>  Here, I create the client in the function but it can also be created outside.<br/> """<br/> redis_client = redis.StrictRedis(host='10.0.0.3', port=6379, db=0)<br/> redis_client.incr(key)<br/> counter = int(redis_client.get(key))<br/> return counter</span></pre><p id="027c" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">get_fail_count方法原子地(尽可能多地)访问键值存储，增加失败计数并检索当前计数。在这种情况下，我使用redis，但你可以选择使用任何你喜欢的。</p><h2 id="4a20" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">启动订阅服务器</h2><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="d977" class="jz is hj lk b fi lo lp l lq lr"><a class="ae iq" href="http://twitter.com/pubusb_message_handl" rel="noopener ugc nofollow" target="_blank">@pubusb_message_handl</a>er<br/>def callback(message):<br/>    print("Received Message %s " % message.data)<br/>    # Uncomment to cause some havoc<br/>    #raise "Unknown Error"</span><span id="8f27" class="jz is hj lk b fi lt lp l lq lr">if __name__ == '__main__':<br/> subscriber = pubsub.SubscriberClient()<br/> future = subscriber.subscribe(subscription_name, callback)<br/> while True:<br/>  time.sleep(1)</span></pre><p id="fbb1" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">注意，这里的回调方法是由我上面描述的“pubsub_message_handler”修饰器修饰的。</p><p id="c5ba" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">当应用程序启动时，它创建一个订阅者并开始监听消息，这些消息由回调处理。无限循环是保持进程活动所必需的(订阅处理程序是异步的，不会阻塞主线程。</p><h2 id="53ae" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">把所有的放在一起</h2><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h2 id="7a1a" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">在活动</h2><p id="dd01" class="pw-post-body-paragraph ht hu hj hv b hw jp hy hz ia jq ic id ie jr ig ih ii js ik il im jt io ip hr hb bi translated">我将运行该流程</p><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="dd1a" class="jz is hj lk b fi lo lp l lq lr">python main.py</span></pre><p id="b0e0" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">然后，我将从gcp控制台向工作主题发布一条新消息:</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lw"><img src="../Images/ad24c79a55eba38091b6388a5df3a504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUNRKjVRzihxGIDSLm_EqQ.png"/></div></div></figure><p id="85bb" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">因为我没有设置代码来引发任何错误，所以我将只看到消息被处理:</p><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="fdbb" class="jz is hj lk b fi lo lp l lq lr">python main.py <br/>Received Message This is a test message</span></pre><p id="5bb6" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">现在让我们取消对“raise”行的注释，以在消息处理程序回调中引发一个错误，并发布相同的消息。</p><p id="2c15" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">在这种情况下，我们将在外壳上看到:</p><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="ee4f" class="jz is hj lk b fi lo lp l lq lr">python main.py <br/>Received Message This is a test message<br/>Received Message This is a test message<br/>Received Message This is a test message<br/>Received Message This is a test message <br/>Received Message This is a test message <br/>message 130021349625804 failed</span></pre><p id="5cd5" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">我们可以看到，在停止之前，我们尝试处理了5次消息。现在让我们检查死信队列:</p><pre class="lc ld le lf fd lj lk ll lm aw ln bi"><span id="10dd" class="jz is hj lk b fi lo lp l lq lr">gcloud pubsub subscriptions pull error-monitoring-sub --limit=100 --auto-ack<br/>┌────────────────────────┬─────────────────┬───────────────┐<br/>│          DATA          │    MESSAGE_ID   │   ATTRIBUTES ├────────────────────────┼─────────────────┼───────────────┤<br/>This is a test message   │ 126573022336505    │ publisher=ron │└────────────────────────┴─────────────────┴───────────────┘</span></pre><p id="56c6" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">瞧，消息现在在死信队列中，我们可以按我们想要的任何方式处理它。</p><h2 id="3232" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">需要注意的事项:</h2><ul class=""><li id="e9eb" class="kn ko hj hv b hw jp ia jq ie kp ii kq im kr hr mb kt ku kv bi translated">我还没有提到这一点，但是您可能希望从您的键值存储中TTL/删除消息键。</li><li id="0b7e" class="kn ko hj hv b hw kw ia kx ie ky ii kz im la hr mb kt ku kv bi translated">这里的代码仍然很简单。在某些情况下，您可能会批量处理消息，并希望对数据存储进行不同类型的访问。</li><li id="7990" class="kn ko hj hv b hw kw ia kx ie ky ii kz im la hr mb kt ku kv bi translated">这里的错误处理可以改进(例如数据存储错误)</li></ul><h2 id="365a" class="jz is hj bd it ka kb kc ix kd ke kf jb ie kg kh jf ii ki kj jj im kk kl jn km bi translated">结论</h2><p id="4437" class="pw-post-body-paragraph ht hu hj hv b hw jp hy hz ia jq ic id ie jr ig ih ii js ik il im jt io ip hr hb bi translated">Pub/Sub不支持死信队列(截至目前)，但是我们可以对代码和架构进行一些更改，并将该功能添加到我们的应用程序中。</p><p id="4474" class="pw-post-body-paragraph ht hu hj hv b hw ju hy hz ia jv ic id ie jw ig ih ii jx ik il im jy io ip hr hb bi translated">阅读更多信息:</p><div class="mc md ez fb me mf"><a href="https://cloud.google.com/memorystore/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd ls fi z dy mk ea eb ml ed ef mm bi translated">完全托管的内存数据存储服务|谷歌云</h2><div class="mn l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">Cloud Memorystore为Redis提供完全托管的内存数据存储服务，以构建应用程序缓存或…</h3></div><div class="mo l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">cloud.google.com</p></div></div></div></a></div><div class="mc md ez fb me mf"><a href="https://cloud.google.com/pubsub/docs/subscriber" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd ls fi z dy mk ea eb ml ed ef mm bi translated">订阅者概述|云发布/订阅|谷歌云</h2><div class="mn l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">订阅者所在项目中的App Engine应用程序无需配置。配置(和…</h3></div><div class="mo l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">cloud.google.com</p></div></div></div></a></div></div></div>    
</body>
</html>