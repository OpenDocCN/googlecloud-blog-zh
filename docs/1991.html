<html>
<head>
<title>Vertex AI custom training jobs in GitLab CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitLab CI中的Vertex AI自定义培训作业</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-run-vertexai-custom-jobs-in-gitlab-ci-b986e6ebed89?source=collection_archive---------0-----------------------#2021-10-27">https://medium.com/google-cloud/how-to-run-vertexai-custom-jobs-in-gitlab-ci-b986e6ebed89?source=collection_archive---------0-----------------------#2021-10-27</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="16a6" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">如何为MLOps管道设置容器</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/d2bca1aa46d96ed03b517ec6bdace88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4uopW-y0YhVjbM3rDT3MBg.jpeg"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">照片由<a class="ae jo" href="https://unsplash.com/@carrier_lost?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae jo" href="https://unsplash.com/s/photos/docker?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="93f2" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这篇博文是关于我的团队最近在一个<strong class="jr hk"> MLOps </strong>项目范围内处理<code class="dv kl km kn ko b">gcloud beta ai</code>和<code class="dv kl km kn ko b">docker</code>相关任务时所面临的一个挑战。这些任务包括为<a class="ae jo" href="https://cloud.google.com/vertex-ai/docs/training/create-python-pre-built-container" rel="noopener ugc nofollow" target="_blank">定制培训应用</a>开发轻量级集成测试。我们使用<a class="ae jo" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">Google Cloud Vertex AI unified ML platform</a>，因此我们可以利用<code class="dv kl km kn ko b"><a class="ae jo" href="https://cloud.google.com/sdk/gcloud/reference/beta/ai/custom-jobs/local-run" rel="noopener ugc nofollow" target="_blank">gcloud beta ai custom-jobs local-run</a></code>在开发机器和CI/CD管道的早期阶段进行“本地”测试。</p><p id="ad82" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">在定制培训应用程序上工作的机器学习工程师成功地在他们的开发环境中运行了测试，其中Cloud SDK和Docker守护程序是可用的。一旦本地开发完成，就该建立持续集成环境了，它运行在GitLab上。</p><h1 id="2871" class="kp kq hj bd kr ks kt ku kv kw kx ky kz ip la iq lb is lc it ld iv le iw lf lg bi translated">Docker图像设置</h1><p id="848a" class="pw-post-body-paragraph jp jq hj jr b js lh ik ju jv li in jx jy lj ka kb kc lk ke kf kg ll ki kj kk hc bi translated">如文档中所述，<code class="dv kl km kn ko b">gcloud beta ai custom-jobs local-run</code> <em class="lm">将你的训练代码打包成Docker镜像，并在本地执行</em>。在引擎盖下，它似乎调用了<code class="dv kl km kn ko b">docker build</code>和<code class="dv kl km kn ko b">docker run</code>，所以我们的第一个动作是学习在GitLab CI容器内运行Docker命令(我们的运行人员使用<a class="ae jo" href="https://docs.gitlab.com/runner/executors/docker.html" rel="noopener ugc nofollow" target="_blank"> Docker执行器</a>)。幸运的是，<a class="ae jo" href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html" rel="noopener ugc nofollow" target="_blank"> GitLab提供了大量关于它的文档</a>！</p><p id="4bf2" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">如果你阅读GitLab的文档，你会注意到大多数例子使用下面的<code class="dv kl km kn ko b">image</code>和<code class="dv kl km kn ko b">services</code>设置:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="ln lo l"/></div></figure><p id="6add" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">对于Docker(又名<em class="lm"> DinD </em>)用例中的各种Docker来说，这应该没问题，但对于我们的用例来说就不行了。我们不仅需要Docker守护进程，还需要CI容器中的Cloud SDK。</p><p id="36e9" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">所以我们决定构建一个自定义映像，从<code class="dv kl km kn ko b">docker:19.03.12</code>开始，并在其中安装云SDK，如下所示。</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="ln lo l"/></div></figure><p id="5127" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">需要记住的几件事:</p><ol class=""><li id="7aec" class="lp lq hj jr b js jt jv jw jy lr kc ls kg lt kk lu lv lw lx bi translated"><a class="ae jo" href="https://github.com/docker-library/docker/blob/86f7f4b563c7c6fe4620c5a8d82694a78f41989f/19.03/Dockerfile" rel="noopener ugc nofollow" target="_blank"/><code class="dv kl km kn ko b"><a class="ae jo" href="https://github.com/docker-library/docker/blob/86f7f4b563c7c6fe4620c5a8d82694a78f41989f/19.03/Dockerfile" rel="noopener ugc nofollow" target="_blank">docker:19.03.12</a></code><a class="ae jo" href="https://github.com/docker-library/docker/blob/86f7f4b563c7c6fe4620c5a8d82694a78f41989f/19.03/Dockerfile" rel="noopener ugc nofollow" target="_blank">镜像建立在</a> <code class="dv kl km kn ko b"><a class="ae jo" href="https://github.com/docker-library/docker/blob/86f7f4b563c7c6fe4620c5a8d82694a78f41989f/19.03/Dockerfile" rel="noopener ugc nofollow" target="_blank">alpine:3.12</a></code>之上，所以我们使用了基于Alpine的方法将Cloud SDK安装到容器中，并参考了<a class="ae jo" href="https://github.com/GoogleCloudPlatform/cloud-sdk-docker/blob/a1754f1ccfa47c4cc5bd218a592d7df1051aaad6/alpine/Dockerfile" rel="noopener ugc nofollow" target="_blank">官方Cloud SDK Alpine Dockerfile </a>。</li><li id="ffa2" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk lu lv lw lx bi translated">Cloud SDK的Alpine映像是建立在<code class="dv kl km kn ko b">alpine:3.13</code>之上的，所以我们预计在<code class="dv kl km kn ko b">docker:19.03.12 / alpine:3.12</code>之上使用相同的命令时不会出现兼容性问题。</li><li id="9e4e" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk lu lv lw lx bi translated">Cloud SDK的Alpine映像不包含额外的组件，我们需要<code class="dv kl km kn ko b">gcloud beta</code>。因此，我们安装了组件，正如您在上面的<code class="dv kl km kn ko b">Dockerfile</code>的第28行中看到的。</li></ol><h1 id="9809" class="kp kq hj bd kr ks kt ku kv kw kx ky kz ip la iq lb is lc it ld iv le iw lf lg bi translated">演示</h1><p id="7f7c" class="pw-post-body-paragraph jp jq hj jr b js lh ik ju jv li in jx jy lj ka kb kc lk ke kf kg ll ki kj kk hc bi translated">我已经建立了一个git存储库来演示自定义图像的运行:<a class="ae jo" href="https://gitlab.com/ricardomendes/docker-cloud-sdk-sample-repo" rel="noopener ugc nofollow" target="_blank">gitlab.com/ricardomendes/docker-cloud-sdk-sample-repo</a>。</p><p id="4c6e" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><code class="dv kl km kn ko b"><a class="ae jo" href="https://gitlab.com/ricardomendes/docker-cloud-sdk-sample-repo/-/blob/main/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank">.gitlab-ci.yml</a></code>文件带来了一个简短的CI管道，由两个步骤组成。首先，它构建自定义Docker映像并将其推送到repo的容器注册中心。然后，它提取图像并运行几个命令，以确保<code class="dv kl km kn ko b">gcloud beta</code>和<code class="dv kl km kn ko b">docker</code>启动并运行，如下面的代码片段所示:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="ln lo l"/></div></figure><p id="fc2f" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">结果是:</p><pre class="iz ja jb jc fe md ko me mf aw mg bi"><span id="e0c1" class="mh kq hj ko b fj mi mj l mk ml">$ gcloud --version</span><span id="ce4c" class="mh kq hj ko b fj mm mj l mk ml">Google Cloud SDK 361.0.0<br/>beta 2021.10.15<br/>bq 2.0.71<br/>core 2021.10.15<br/>gsutil 5.4</span><span id="c0b2" class="mh kq hj ko b fj mm mj l mk ml">$ docker --version</span><span id="5196" class="mh kq hj ko b fj mm mj l mk ml">Docker version 19.03.12, build 48a66213fe</span><span id="6391" class="mh kq hj ko b fj mm mj l mk ml">$ docker run hello-world</span><span id="504e" class="mh kq hj ko b fj mm mj l mk ml">Unable to find image ‘hello-world:latest’ locally<br/>latest: Pulling from library/hello-world<br/>...<br/>Status: Downloaded newer image for hello-world:latest<br/>Hello from Docker!</span><span id="df8f" class="mh kq hj ko b fj mm mj l mk ml">This message shows that your installation appears to be working correctly.<br/>To generate this message, Docker took the following steps:<br/>1. The Docker client contacted the Docker daemon.<br/>2. The Docker daemon pulled the “hello-world” image from the Docker Hub. (amd64)<br/>3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.<br/>4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.</span></pre><p id="b836" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">完整的构建日志可从<a class="ae jo" href="https://gitlab.com/ricardomendes/docker-cloud-sdk-sample-repo/-/jobs/1718577368" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="c50e" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这就是我们如何用运行<code class="dv kl km kn ko b">gcloud beta ai custom-jobs local-run</code>所需的服务建立一个映像，并在我们正在处理的MLOps管道中启用集成测试。</p><h1 id="f847" class="kp kq hj bd kr ks kt ku kv kw kx ky kz ip la iq lb is lc it ld iv le iw lf lg bi translated">最终考虑</h1><p id="b6a4" class="pw-post-body-paragraph jp jq hj jr b js lh ik ju jv li in jx jy lj ka kb kc lk ke kf kg ll ki kj kk hc bi translated">在同一个Docker容器中运行不同的工作负载并不总是那么简单。因此，我们考虑使用定制映像来运行其他类型的集成测试，例如一些基于Python的测试。</p><p id="7579" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">虽然定制映像拥有基本的Python 3资源，这是<code class="dv kl km kn ko b">gcloud</code>所需要的，但是我们意识到它不适合运行基于Python的测试。在基于Alpine的容器中安装Python依赖项很麻烦(请查看这些链接来理解我的意思:【pythonspeed.com/articles/alpine-docker-python和<a class="ae jo" href="https://www.python.org/dev/peps/pep-0656/" rel="noopener ugc nofollow" target="_blank">python.org/dev/peps/pep-0656</a>)，这就是为什么我们也考虑了基于Debian的方法而不是Alpine。为此，我们从基于<code class="dv kl km kn ko b">debian:buster-slim</code>的<code class="dv kl km kn ko b">google/cloud-sdk:361.0.0</code>开始，然后尝试在里面安装Docker，但是<a class="ae jo" href="https://gitlab.com/ricardomendes/docker-cloud-sdk-sample-repo/-/jobs/1718917675" rel="noopener ugc nofollow" target="_blank">至今没有成功</a>。</p><p id="ad58" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">也就是说，团队同意在多个容器中运行集成测试，这些容器可以并发运行，利用每个映像提供的特性，避免越来越多的定制。</p><p id="ec93" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">希望有帮助，随时欢迎反馈！</p><p id="981c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">最好的，</p></div></div>    
</body>
</html>