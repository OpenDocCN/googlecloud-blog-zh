<html>
<head>
<title>Protecting your Application on Cloud Run with API Gateway and Identity Aware Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用API网关和身份感知代理保护您的云应用</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/protecting-your-application-on-cloud-run-with-api-gateway-and-identity-aware-proxy-712c237916b0?source=collection_archive---------2-----------------------#2022-07-22">https://medium.com/google-cloud/protecting-your-application-on-cloud-run-with-api-gateway-and-identity-aware-proxy-712c237916b0?source=collection_archive---------2-----------------------#2022-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f45935182ee97d8800a1bf13efdc8fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yWn-jYpRD9HMp1dZM_s_A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@huefnerdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·哈弗纳</a>在<a class="ae iu" href="https://unsplash.com/s/photos/guard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a53e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我是无服务器的忠实粉丝。我对托管基础设施的关心越少，我就越开心。因为我可以把更多的时间放在为用户创造价值上。但是，由于我总是关注安全性，这也让我安心地知道，我的服务位于别人为我维护的安全层之后。就我个人而言，我喜欢使用平台特性来保护服务对服务的通信。在服务网格中，mTLS是解决这一问题的最佳选择。在云运行中，我们可以依靠Google Cloud IAM为我们提供这种级别的安全性。</p><p id="e8dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在使用身份识别代理 (IAP)的Google Cloud中，有一个很好的解决方案可以保护您的web应用程序免受不希望的访问。类似地，<a class="ae iu" href="https://cloud.google.com/api-gateway" rel="noopener ugc nofollow" target="_blank"> API Gateway </a>是一个很好的、轻量级的API公开选项。它负责为您验证JWT令牌，并且可以安全地集成到您的堆栈中，这要感谢Google IAM。不过，将IAP和API Gateway结合起来可能会很有挑战性。在这篇文章中，我们将一起经历必要的步骤，你将需要一些关于<a class="ae iu" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>和Spring Security的经验。您可以从带有一些OAuth依赖项的Spring应用程序开始。我在这里放了一个完整的部署示例和Terraform:</p><div class="jt ju ez fb jv jw"><a href="https://github.com/cgrotz/blog-examples/tree/main/lb_apigw_spring_boot_example" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">主cgrotz/blog-examples上的blog-examples/lb _ API GW _ spring _ boot _ example</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">在您的GCP项目中启用身份平台https://console . cloud . Google . com/customer-Identity/on boarding创建一个…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">github.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><h2 id="8aa3" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">向Spring Boot应用程序添加身份识别代理</h2><p id="0b0f" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">让我们从在应用程序中添加对IAP的支持开始。IAP通过<code class="du ll lm ln lo b">x-goog-iap-jwt-assertion</code>头提供登录令牌。该报头包含由IAP签名的JWT。因此，让我们从在应用程序中添加JWT验证开始。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="e1e7" class="kl km hi lo b fi lx ly l lz ma">spring:<br/>  security:<br/>    oauth2:<br/>      resourceserver:<br/>        jwt:<br/>          issuer-uri: <a class="ae iu" href="https://cloud.google.com/iap" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/iap</a><br/>          jwk-set-uri: https://www.gstatic.com/iap/verify/public_key-jwk</span></pre><p id="89be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并在<code class="du ll lm ln lo b">securityFilterChain</code>中配置不同的表头名称:</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="ebdc" class="kl km hi lo b fi lx ly l lz ma">http<br/>    .oauth2ResourceServer()<br/>        .bearerTokenResolver(<strong class="lo hj">new</strong> HeaderBearerTokenResolver("x-goog-iap-jwt-assertion"));</span></pre><p id="9749" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们的应用程序已经准备好接受和验证IAP令牌。</p><h2 id="3c6c" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">向Spring Boot应用程序添加API网关支持</h2><p id="0ad9" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">现在添加API网关支持应该很容易。我们需要将<code class="du ll lm ln lo b">issuer-uri</code>和<code class="du ll lm ln lo b">jwk-set-uri</code>配置添加到<code class="du ll lm ln lo b">application.yaml</code>中。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="6699" class="kl km hi lo b fi lx ly l lz ma">spring:<br/>  security:<br/>    oauth2:<br/>      resourceserver:<br/>        jwt:<br/>          issuer-uri: &lt;issuer-uri&gt;<br/>          jwk-set-uri: &lt;jwk-set-uri&gt;</span></pre><p id="f145" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，我们还需要一个API Gateway的令牌解析器，因为API Gateway通过<code class="du ll lm ln lo b">x-forwarded-authorization</code>头提供原始的登录令牌。自定义BearerTokenResolver可能如下所示:</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="a4ec" class="kl km hi lo b fi lx ly l lz ma">http<br/>    .oauth2ResourceServer()<br/>        .bearerTokenResolver(<strong class="lo hj">new</strong> HeaderBearerTokenResolver("<!-- -->x-forwarded-authorization<!-- -->"));</span></pre><h2 id="a453" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">组合API网关和身份感知代理</h2><p id="eaf9" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">遗憾的是，目前我们不能简单地将这两种选择结合起来。Spring Security OAuth一次只支持一个JWT身份提供者配置。但是我们可以在<code class="du ll lm ln lo b">SecurityFilterChain</code>中组合<code class="du ll lm ln lo b">BearerTokenResolver</code>和init自定义<code class="du ll lm ln lo b">AuthenticationManagerResolver</code>。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="b8c0" class="kl km hi lo b fi lx ly l lz ma"><a class="ae iu" href="http://twitter.com/Bean" rel="noopener ugc nofollow" target="_blank">@Bean</a><br/>  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {<br/>    JwtDecoder decoder1 = createJwtDecoder(issuerUri, jwksUrl);<br/>    JwtDecoder decoder2 = createJwtDecoder("<a class="ae iu" href="https://cloud.google.com/iap" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/iap</a>",<br/>        "<a class="ae iu" href="https://www.gstatic.com/iap/verify/public_key-jwk" rel="noopener ugc nofollow" target="_blank">https://www.gstatic.com/iap/verify/public_key-jwk</a>");<br/>    JwtAuthenticationProvider provider1 = new JwtAuthenticationProvider(decoder1);<br/>    JwtAuthenticationProvider provider2 = new JwtAuthenticationProvider(decoder2);<br/>    JwtIssuerAuthenticationManagerResolver authenticationManagerResolver =<br/>        new JwtIssuerAuthenticationManagerResolver(context -&gt; {<br/>          if (context.startsWith(issuerUri)) {<br/>            return provider1::authenticate;<br/>          } else if (context.startsWith("<a class="ae iu" href="https://cloud.google.com/iap" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/iap</a>")) {<br/>            return provider2::authenticate;<br/>          } else {<br/>            throw new RuntimeException("Unsupported Issuer " + context);<br/>          }<br/>        });</span><span id="b808" class="kl km hi lo b fi mb ly l lz ma">http<br/>        .authorizeHttpRequests(authorize -&gt; authorize<br/>            .anyRequest().authenticated()<br/>        )<br/>        .oauth2ResourceServer(oauth2 -&gt; oauth2<br/>            .authenticationManagerResolver(authenticationManagerResolver)<br/>        );<br/>    return http.build();<br/>  }</span><span id="d511" class="kl km hi lo b fi mb ly l lz ma">private JwtDecoder createJwtDecoder(String issuer, String jwkSetUri) {<br/>    OAuth2TokenValidator&lt;Jwt&gt; jwtValidator = JwtValidators.createDefaultWithIssuer(issuer);<br/>    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri)<br/>        .jwsAlgorithm(SignatureAlgorithm.ES256)<br/>        .jwsAlgorithm(SignatureAlgorithm.RS256)<br/>        .build();<br/>    jwtDecoder.setJwtValidator(jwtValidator);<br/>    return jwtDecoder;<br/>  }</span></pre><p id="4229" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，这两个选项的标记格式不同。IAP将从原始令牌中提取定制声明，并将它们放在<code class="du ll lm ln lo b">gcip</code>声明中。这导致不同格式的身份验证对象。我们当然可以用一个自定义的<code class="du ll lm ln lo b">Converter&lt;Jwt, AbstractAuthenticationToken&gt;</code>来协调这一点(你可以在链接的源代码中获得完整的例子)。</p><h2 id="e53a" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">调用其他服务</h2><p id="3447" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">在调用其他服务时，我们也希望使用IAM来保护服务到服务的流量。这意味着我们需要放置用户的上下文，例如原始的JWT，其中调用应该在有效载荷或报头中进行。在Spring中，我们可以简单地定制<code class="du ll lm ln lo b">RestTemplate </code>，使用<code class="du ll lm ln lo b">RestTemplateCustomizer</code>并添加一个拦截器来添加IAM令牌。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="ba41" class="kl km hi lo b fi lx ly l lz ma">interceptors.add((request, body, execution) -&gt; {<br/>      // This behaviour could also be limited to the .a.run.app domain to only forward the Identity Token to other Cloud Run services<br/>      GoogleCredentials adCredentials = GoogleCredentials.getApplicationDefault();<br/>      if (adCredentials instanceof IdTokenProvider) {<br/>        IdTokenProvider idTokenProvider = (IdTokenProvider) adCredentials;<br/>        IdToken idToken = idTokenProvider.idTokenWithAudience(<br/>            "https://" + request.getURI().getHost(), null);<br/>        request.getHeaders().add(HttpHeaders.AUTHORIZATION, "Bearer " + idToken.getTokenValue());<br/>      }<br/>      return execution.execute(request, body);<br/>    });</span></pre><h2 id="165a" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">部署解决方案</h2><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/e9591a72868b21a633b5999510055149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOGWGL9rg7mbH8CeAp_a9w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">该示例的架构</figcaption></figure><p id="85e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目前，有几个因素使得部署变得复杂:</p><ol class=""><li id="2a60" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">API网关流量不被视为来自云运行的内部流量，因此由API网关提供的云运行服务需要配置<code class="du ll lm ln lo b">ingress all</code>。当然，当设置<code class="du ll lm ln lo b">ingress all</code>时，您希望在您的云运行服务前获得IAM授权。</li><li id="6a75" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">IAP流量被认为是负载平衡器流量，因此您可以设置<code class="du ll lm ln lo b">ingress internal+loadbalancing</code>，但是它要求您将<code class="du ll lm ln lo b">roles/run.invoker</code>设置为<code class="du ll lm ln lo b">allUsers</code></li></ol><p id="62a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两种配置是出于相互排斥的安全考虑。您希望在您的服务前面至少有一层保护。最简单的解决方案是，用不同的配置部署两次微服务。</p><p id="34a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您不想这样做(或者由于某些组织政策/约束无法这样做)，您也可以考虑使用基于<a class="ae iu" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> envoy </a>的反向代理作为负载平衡器的后端，该负载平衡器托管在IAP负载平衡器的虚拟机或托管实例组上，而不是使用无服务器网络端点组。代理可以将身份令牌添加到您的请求中，允许您统一部署所有云运行服务，将入口设置为all，并将IAM限制为某些服务帐户。您可以在此找到特使配置的示例:</p><div class="jt ju ez fb jv jw"><a href="https://github.com/cgrotz/blog-examples/tree/main/envoy-cloudrun-proxy" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">blog-examples/envoy-cloud run-proxy at main cgrotz/blog-examples</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">这是一个简单的特使代理示例，它在云运行服务前充当反向代理。代理人…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">github.com</p></div></div><div class="kf l"><div class="mr l kh ki kj kf kk io jw"/></div></div></a></div><p id="2501" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这就完成了在前面有API Gateway和IAP的云上托管Spring Boot应用程序的小小尝试。</p></div></div>    
</body>
</html>