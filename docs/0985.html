<html>
<head>
<title>Python and Stackdriver Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和Stackdriver日志记录</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/python-and-stackdriver-logging-2ade460c90e3?source=collection_archive---------1-----------------------#2019-04-29">https://medium.com/google-cloud/python-and-stackdriver-logging-2ade460c90e3?source=collection_archive---------1-----------------------#2019-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="05a5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">现代测井:结构化还是文本？</h1><p id="21b3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现代日志记录是结构化的——JSON或其他——在事件发生时记录事件，而不是传统的由一系列文本行组成的日志记录。这可以更好地索引、搜索和跟踪事件。</p><p id="3123" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Stackdriver支持结构化事件，但也可以管理文本。</p><p id="7479" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用Python Stackdriver客户端——参见此处的<a class="ae kg" href="https://googleapis.github.io/google-cloud-python/latest/logging/usage.html" rel="noopener ugc nofollow" target="_blank"/>——您可以使用带有Stackdriver处理程序<strong class="jf hj">的Python记录器，也可以使用本地Stackdriver记录器</strong>。客户端的源代码可以在<a class="ae kg" href="https://github.com/googleapis/google-cloud-python/tree/master/logging" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h2 id="14ad" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">先决条件</h2><p id="491e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">安装google-cloud-logging pip包，确保设置了应用程序默认凭证，并且有一个默认项目。</p><h1 id="8213" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">本机堆栈驱动程序记录器</h1><p id="d073" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用本机Stackdriver日志记录器允许对发送日志进行显式控制。通过调用log_text()和log_struct()，您可以同步指定文本或结构化日志消息<strong class="jf hj"/>。这允许您将记录的事件与实际事件协调起来，但是每个日志消息的<strong class="jf hj">显著的性能损失</strong>大约为100毫秒。</p><p id="243e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有一个未记录的batch()选项可以在一个同步调用中发送多个日志条目，但这仍然很难管理。</p><h2 id="ca90" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">发送100条JSON消息的示例:</h2><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1586" class="kh ig hi la b fi le lf l lg lh">import google.cloud.logging                                                     </span><span id="296c" class="kh ig hi la b fi li lf l lg lh">client = google.cloud.logging.Client()                                          </span><span id="4e72" class="kh ig hi la b fi li lf l lg lh">logger = client.logger('python_special_logger')                                 <br/>                                                                               <br/>for i in range(100):                                                            <br/>    logger.log_struct({'key':'a', 'val':'b'})                                   </span></pre><p id="258a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从下面可以看到，每条日志消息大约需要100ms。总共100条消息大约是<strong class="jf hj"> 13秒。</strong></p><figure class="kv kw kx ky fd lk er es paragraph-image"><div class="er es lj"><img src="../Images/6613663502c64c3639acd8087409a3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*JzRpS6XIIEPvj5iYP8xicw.png"/></div></figure><h2 id="dc68" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">批量发送100条短信示例:</h2><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="bfdb" class="kh ig hi la b fi le lf l lg lh">import google.cloud.logging</span><span id="6698" class="kh ig hi la b fi li lf l lg lh">client = google.cloud.logging.Client()</span><span id="154a" class="kh ig hi la b fi li lf l lg lh">logger = client.logger('python_special_logger')</span><span id="a226" class="kh ig hi la b fi li lf l lg lh">with logger.batch() as blogger:<br/>    for i in range(100):                                                        <br/>        blogger.log_text('first message.')                                      </span></pre><p id="329f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这要快得多。所有消息的时间戳都是相同的，程序花费大约<strong class="jf hj"> 1.4秒</strong>(单个请求)。但是它仍然同步发生——减慢你的程序——并且你需要小心你批处理的数量和你如何控制它。</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/f9c467336d7b13fbbe8236fa4e92746d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qf7HBgPra7OIgXkQkJAGvg.png"/></div></div></figure><h1 id="ef58" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">带有Stackdriver处理程序的Python记录器</h1><h2 id="6df0" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">文本记录</h2><p id="c170" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">按照下面的说明，将日志(普通文本日志行)从Python写入Stackdriver非常简单:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9a95" class="kh ig hi la b fi le lf l lg lh">import logging<br/>import google.cloud.logging</span><span id="4346" class="kh ig hi la b fi li lf l lg lh">client = google.cloud.logging.Client()<br/>client.setup_logging()</span><span id="4bc3" class="kh ig hi la b fi li lf l lg lh">for i in range(100):<br/>    logging.info('hello!', {'key':'a', 'val':'b'})</span></pre><p id="772e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">大约需要<strong class="jf hj"> 3秒</strong>。如果您看到下图，您可以看到许多日志消息具有相同的时间戳，但有多个批次。所以需要的时间比1.4秒长。</p><p id="49b3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然而，这也是在后台线程中完成的，程序终止等待线程完成发送日志消息。所以是<strong class="jf hj">异步</strong>不阻塞主程序。</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/8c922b3375e8b25252dcb5fc28a1eddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSqqY8LD8gr3rlGtiw5OTw.png"/></div></div></figure><p id="780a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们在日志中添加了一些额外的值，但是它没有在Stackdriver中被捕获。所以看起来它只是文本。</p><h2 id="5c9a" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">自定义格式化程序— JSON消息</h2><p id="94a4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，我们将使用相同的机制来记录日志，但是使用了CustomFormatter。这将根据我们自己的逻辑格式化消息。</p><p id="1efa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用Python logger，您可以在每个日志消息的基础上指定额外的参数字典。这有助于消息的格式化。通常情况下，message是一个文本，但是这里我们将把它变成一个用于Stackdriver日志记录的Python字典。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4ff8" class="kh ig hi la b fi le lf l lg lh">import logging<br/>import google.cloud.logging</span><span id="b29c" class="kh ig hi la b fi li lf l lg lh">client = google.cloud.logging.Client()</span><span id="4648" class="kh ig hi la b fi li lf l lg lh"># Custom formatter returns a structure, than a string<br/>class CustomFormatter(logging.Formatter):<br/>    def format(self, record):<br/>        logmsg = super(CustomFormatter, self).format(record)<br/>        return {’msg’: losgmsg,<br/>                'args’:record.args}</span><span id="649e" class="kh ig hi la b fi li lf l lg lh"># Setup handler explicitly -- different labels<br/>handler = client.get_default_handler()<br/>handler.setFormatter(CustomFormatter())</span><span id="bc6e" class="kh ig hi la b fi li lf l lg lh"># Setup logger explicitly with this handler                                     <br/>logger = logging.getLogger()<br/>logger.setLevel(logging.INFO)<br/>logger.addHandler(handler)<br/><br/>for i in range(100):<br/>    logger.info('hello!', {'key':'a', 'val':'b'})</span></pre><p id="dbf8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们使用record . args——来自日志消息的参数——和“msg”字段作为正常格式的消息。</p><p id="208a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们还在自定义处理程序上设置标签。</p><p id="72e5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">总时间仍然是大约<strong class="jf hj"> 3秒。</strong>这也在后台进行，就像文本日志一样。</p><p id="94e9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">信息不是文本，而是结构化的。</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div class="er es lt"><img src="../Images/9cb0c0327014aca11b0f71a6574e982f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*JfsDOFT21kunVbhIMkKKPQ.png"/></div></figure><h1 id="b99b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">建议</h1><p id="887f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">除非您需要同步控制——知道日志条目已经保存——否则您应该使用Python日志记录机制。如果您需要结构化消息，请创建适合您的应用程序的自定义格式化程序。</p></div></div>    
</body>
</html>