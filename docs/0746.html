<html>
<head>
<title>Google Cloud Functions for Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Go的谷歌云功能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-functions-for-go-57e4af9b10da?source=collection_archive---------0-----------------------#2018-09-01">https://medium.com/google-cloud/google-cloud-functions-for-go-57e4af9b10da?source=collection_archive---------0-----------------------#2018-09-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ba9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【2019年1月，谷歌云功能终于宣布了对Go的beta支持。查看 <a class="ae je" href="https://cloud.google.com/blog/products/application-development/cloud-functions-go-1-11-is-now-a-supported-language" rel="noopener ugc nofollow" target="_blank"> <em class="jd">官方博文</em> </a> <em class="jd">了解更多详情。</em></p><h2 id="fe4b" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">你好世界</h2><p id="8ae6" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">让我从一个简单的“hello world”开始，向您介绍整个构建+部署体验。GCF需要一个http。HandlerFunc是入口点。创建一个名为“hello”的包，并添加一个简单的处理程序:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="b68c" class="jf jg hi kk b fi ko kp l kq kr">$ cat hello/fn.go<br/>package hello</span><span id="9a08" class="jf jg hi kk b fi ks kp l kq kr">import (<br/> "fmt"<br/> "net/http"<br/>)</span><span id="381f" class="jf jg hi kk b fi ks kp l kq kr">func HelloWorld(w http.ResponseWriter, r *http.Request) {<br/> fmt.Fprintf(w, "Hello, World!")<br/>}</span></pre><p id="ba70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进行部署，请使用以下命令。它将创建一个名为hello的新函数，并将使用HelloWorld作为入口点。将要使用的Go运行时将是Go.11。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="c5b5" class="jf jg hi kk b fi ko kp l kq kr">$ gcloud functions deploy hello --entry-point HelloWorld --runtime go111 --trigger-http<br/>Deploying function (may take a while - up to 2 minutes)...</span></pre><p id="aa1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，部署可能需要一段时间。部署完成后，您将能够在终端上看到HTTP端点。您还可以在<a class="ae je" href="https://console.cloud.google.com/functions/list" rel="noopener ugc nofollow" target="_blank">云控制台</a>查看您的功能。</p><figure class="kf kg kh ki fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kt"><img src="../Images/ccbd5ad33441a83dfb7c724700abc4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOH3RWYZoOEarZvHAOxjJg.png"/></div></div></figure><p id="80f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在控制台上，你可以看到“你好”功能被部署。您可以访问日志和基本指标，如调用次数、执行时间和内存使用情况。</p><h2 id="beb8" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">属国</h2><p id="e242" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">如果有外部依赖项，将使用go.mod文件来获取依赖项。您也可以在功能模块下出售它们。我引入了golang.org/x/sync/errgroup包作为例子。如需更多信息，请参见<a class="ae je" href="https://cloud.google.com/functions/docs/concepts/go-runtime#specifying_dependencies" rel="noopener ugc nofollow" target="_blank"> GCF依赖性指南</a>。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="1bb1" class="jf jg hi kk b fi ko kp l kq kr">$ cd hello<br/>$ go mod init<br/>$ tree<br/>hello<br/>├── fn.go<br/>├── go.mod<br/>...</span></pre><p id="2107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我再次重新部署函数时，将检索依赖关系。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="0b09" class="jf jg hi kk b fi ko kp l kq kr">$ gcloud functions deploy hello --entry-point HelloWorld --runtime go111 --trigger-http<br/>Deploying function (may take a while - up to 2 minutes)...<br/>availableMemoryMb: 256<br/>entryPoint: HelloWorld<br/>httpsTrigger:<br/>  url: https://us-central1-bamboo-shift-504.cloudfunctions.net/hello<br/>...</span></pre><p id="e47b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">功能重新部署在<a class="ae je" href="https://us-central1-bamboo-shift-504.cloudfunctions.net/hello" rel="noopener ugc nofollow" target="_blank">https://us-central 1-bamboo-shift-504 . cloud functions . net/hello</a>。你自己看吧。您也可以从命令行调用该函数:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="4f20" class="jf jg hi kk b fi ko kp l kq kr">$ gcloud functions call hello<br/>executionId: x71xpor7tasd<br/>result: Hello, World!</span></pre><p id="4762" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还从我的笔记本电脑上生成了一些负载到函数中，以便为您提供更真实的响应时间数据。我提出了1000个请求，一次10个。您可以看到有一些异常值，但大多数呼叫都在213毫秒的范围内。</p><figure class="kf kg kh ki fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lb"><img src="../Images/47b3af5f5438708e16511a16b57f22c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9b0hzD9A_n3RhB6tJKQCig.png"/></div></div></figure><h2 id="efda" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">代码组织</h2><p id="2999" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">在Go中，我们通过<a class="ae je" href="https://rakyll.org/style-packages/" rel="noopener ugc nofollow" target="_blank">职责</a>来组织包。这也非常适合无服务器设计模式——一个功能代表一种责任。我为每个函数创建一个新的模块，从同一个模块中提供特定于函数的其他API。</p><p id="f740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主入口点处理程序总是在<strong class="ih hj"> fn.go </strong>中，这帮助我快速找到主处理程序，就像main.go帮助我找到主函数一样。</p><p id="e4af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通用功能位于单独的模块中，在功能包中出售，因为GCF CLI一次只上传和部署一个模块。我们正在考虑如何改善这种情况，但是目前一个模块应该包含它所有的依赖项。</p><p id="bf30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个示例树。程序包配置包含与配置相关的常见功能。它是一个模块，由其他函数(hello和user)导入和出售。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="0060" class="jf jg hi kk b fi ko kp l kq kr">$ tree<br/>fns<br/>├── config (commonly used module)<br/>│   ├── config.go<br/>│   ├── go.mod<br/>├── hello<br/>│   ├── fn.go<br/>│   ├── go.mod<br/>└── user<br/>    ├── fn.go<br/>    ├── go.mod</span></pre><h2 id="ac1c" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">链接处理程序</h2><p id="75dd" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">与其他提供者不同，我们决定使用go惯用处理程序API(func(response writer，*Request))作为主要入口点。这允许你更容易地利用Go生态系统中现有的中间件。例如，在下面的例子中，我使用ochttp为传入的http请求自动创建跟踪。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="a23c" class="jf jg hi kk b fi ko kp l kq kr">package hello</span><span id="3408" class="jf jg hi kk b fi ks kp l kq kr">import (<br/>   "fmt"<br/>   "net/http"</span><span id="21a7" class="jf jg hi kk b fi ks kp l kq kr">   "go.opencensus.io/plugin/ochttp"<br/>)</span><span id="ff96" class="jf jg hi kk b fi ks kp l kq kr">func HelloWorld(w http.ResponseWriter, r *http.Request) {<br/>    fn := func(w http.ResponseWriter, r *http.Request) {<br/>        fmt.Fprintln(w, "Hello world")<br/>    }<br/>    traced := &amp;ochttp.Handler{<br/>        Handler: http.HandlerFunc(fn),<br/>    }<br/>    traced.ServeHTTP(w, r)<br/>}</span></pre><p id="60d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个传入请求，都会创建一个传入跟踪范围。如果你注册了一个导出器，你可以上传追踪到任何我们支持的后端，当然包括Stackdriver追踪。</p></div></div>    
</body>
</html>