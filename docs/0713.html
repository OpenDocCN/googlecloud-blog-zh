<html>
<head>
<title>Quick Hit: kubectl hacking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速命中:kubectl黑客</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/quick-hit-kubectl-hacking-b1896d06cbfd?source=collection_archive---------0-----------------------#2018-08-06">https://medium.com/google-cloud/quick-hit-kubectl-hacking-b1896d06cbfd?source=collection_archive---------0-----------------------#2018-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我越来越喜欢一个更“流畅”的kubectl CLI，它(更)便于将命令链接在一起。让我解释一下我的挑战。我很好奇解决这个问题的其他方法；请回复建议！</p><p id="1a87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有多个公开多个节点端口的服务:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="eafd" class="jm jn hi ji b fi jo jp l jq jr">kubectl get services \<br/>--selector=component=peer,org=org1,peer=0 \<br/>--namespace=fermium \<br/>--context=fabric \<br/>--output=json | <strong class="ji hj">jq .items[].spec.ports[]</strong><br/>{<br/>  "name": "request",<br/>  "nodePort": 30605,<br/>  "port": 7051,<br/>  "protocol": "TCP",<br/>  "targetPort": 7051<br/>}<br/>{<br/>  "name": "chaincode",<br/>  "nodePort": 32255,<br/>  "port": 7052,<br/>  "protocol": "TCP",<br/>  "targetPort": 7052<br/>}<br/>{<br/>  "name": "events",<br/>  "nodePort": 30535,<br/>  "port": 7053,<br/>  "protocol": "TCP",<br/>  "targetPort": 7053<br/>}</span></pre><p id="4905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>我正在使用<code class="du js jt ju ji b">--output=json</code>并将它传送到(优秀的)<code class="du js jt ju ji b">jq</code>中，以保存JSON输出。虽然<code class="du js jt ju ji b">kubectl</code>支持<code class="du js jt ju ji b">--output=json</code>和<code class="du js jt ju ji b">--output=jsonpath="..."</code>，但它返回的结果是字符串化的Golang类型，而不是JSON :-(</p><p id="4a78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">脱离群集(！)，我想端口转发本地主机端口到服务端口，端口对端口。</p><p id="b527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于最简单的情况，其中所有端口都属于一个Pod，我可以使用<code class="du js jt ju ji b">kubectl port-forward</code>，但是我希望组合来自多个服务的端口。一个有用的事实是，因为我将通过它们的<code class="du js jt ju ji b">NodePorts</code>端口转发到这些服务，所以没有复制的可能性；节点端口在集群中是唯一的，并且在集群的节点中是一致的(我们可以选择任何节点)。</p><h2 id="b2cf" class="jm jn hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated"><strong class="ak">设置</strong></h2><p id="f2d4" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我正努力强迫自己在使用<code class="du js jt ju ji b">kubectl</code>时总是指定名称空间和上下文(参见我的故事“<a class="ae kt" rel="noopener" href="/google-cloud/context-light-gcloud-and-kubectl-89185d38ce82"> Safer `gcloud `和` kubectl </a>`”)，所以，在下面，你会看到<code class="du js jt ju ji b">--namespace=${NAMESPACE}</code>和<code class="du js jt ju ji b">--context=${CONTEXT}</code>。这些你都可以用，随你的便。</p><h2 id="910a" class="jm jn hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">第一步:选择你的节点😃)</h2><p id="7cad" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">通常，我只获取返回的第一个节点:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f535" class="jm jn hi ji b fi jo jp l jq jr">NODE=$(\<br/>  kubectl get nodes \<br/>  --context=${CONTEXT} \<br/>  --namespace=${NAMESPACE} \<br/>  --output=jsonpath='{.items[0].metadata.name}'\<br/>)</span></pre><p id="a659" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你可以随机选择一个:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="d045" class="jm jn hi ji b fi jo jp l jq jr">NODE=$(shuf \<br/>  --head-count=1 \<br/>  --echo \<br/>  $(\<br/>    kubectl get nodes \<br/>    --context=${CONTEXT} \<br/>    --namespace=${NAMESPACE} \<br/>    --output=jsonpath='{.items[*].metadata.name}'\<br/>  )\<br/>)</span></pre><h2 id="8fb0" class="jm jn hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">步骤2:识别您的服务及其端口</h2><p id="befa" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">尽管每个Kubernetes资源都有一个名称，但是通过类型和标签而不是名称来引用资源是一个很好的实践。例如，在创建部署和服务时，这种模式是明确需要的。这些是由将它们绑定到豆荚的选择器定义的。但是，对于所有的Kubernetes资源来说，这通常是一个很好的实践。这里，为了识别服务，我使用了我的服务的<code class="du js jt ju ji b">component</code>、<code class="du js jt ju ji b">org</code>和<code class="du js jt ju ji b">peer</code>标签(和值):</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="29ae" class="jm jn hi ji b fi jo jp l jq jr">kubectl get service \<br/>--<strong class="ji hj">selector=component=peer,org=org1,peer=0</strong> \<br/>--namespace=${NAMESPACE} \<br/>--context=${CONTEXT} \<br/>--output=jsonpath='{range .items[0].spec.ports[*]}{.targetPort}{.nodePort}{end}'</span></pre><p id="b439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使用了一个jsonpath扩展<code class="du js jt ju ji b">range</code>来迭代<code class="du js jt ju ji b">ports</code>数组。它输出每个<code class="du js jt ju ji b">ports</code>的<code class="du js jt ju ji b">targetPort</code>和<code class="du js jt ju ji b">nodePort</code>的值。在我的例子中，每个服务的<code class="du js jt ju ji b">port</code>与<code class="du js jt ju ji b">targetPort</code>(Pod的<code class="du js jt ju ji b">port</code>)相同。</p><h2 id="5ba4" class="jm jn hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">步骤3:转换服务和端口映射</h2><p id="bb93" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">当我考虑这个问题时，我的想法是将<code class="du js jt ju ji b">targetPort:nodePort</code>对的数组作为bash关联数组输出。代表服务端口名称的键和代表节点端口的值。</p><p id="e4d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我意识到<code class="du js jt ju ji b">gcloud</code>命令接受<code class="du js jt ju ji b"> — ssh-flag</code>作为循环标志。我只需要为每个端口创建标志，然后将它附加到<code class="du js jt ju ji b">gcloud</code>命令，即</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7ff0" class="jm jn hi ji b fi jo jp l jq jr">gcloud compute instance ... --ssh-flag=... --ssh-flag=...</span></pre><p id="b3e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前面的<code class="du js jt ju ji b">kubectl</code>命令的输出是所有端口和节点端口作为一个字符串的混搭。<code class="du js jt ju ji b">{range}</code>和<code class="du js jt ju ji b">{end}</code>之间的模板，仅输出<code class="du js jt ju ji b">targetPort</code>和<code class="du js jt ju ji b">nodePort</code>的值。</p><p id="0869" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个模板很容易生成更有用的东西:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7fa2" class="jm jn hi ji b fi jo jp l jq jr">{range .items[0].spec.ports[*]}<br/>  {.targetPort}<br/>  {":localhost:"}<br/>  {.nodePort}<br/>  {" "}<br/>{end}</span></pre><blockquote class="ku kv kw"><p id="a9a9" class="if ig kx ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">上面用换行符显示是为了更好地显示命令的意图。实际上，最简单的方法是将这些模板字符串保持为单行文本</p></blockquote><p id="a12a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我来说，这项服务会产生:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6be4" class="jm jn hi ji b fi jo jp l jq jr">7051:localhost:31833 7052:localhost:31088 7053:localhost:32085</span></pre><blockquote class="ku kv kw"><p id="47c0" class="if ig kx ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">使用字符串构造Bash命令并处理Bash的分词是很棘手的。您将看到我可以使用<code class="du js jt ju ji b">Golang</code>模板<code class="du js jt ju ji b">range</code>命令:<code class="du js jt ju ji b">{{" — ssh-flag=\" -L"}…{" "}</code>为整个标志生成字符串。但是，由于Bash的单词拆分，这是行不通的。因此，我们需要再次迭代上面生成的端口映射列表。感谢我的同事——安德鲁——帮助我更好地理解这一点。</p></blockquote><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6d36" class="jm jn hi ji b fi jo jp l jq jr">for MAPPING in $(\<br/>  kubectl get service \<br/>  --selector=... \<br/>  --context=${CONTEXT} \<br/>  --namespace=${NAMESPACE} \<br/>  --output=jsonpath='{range .items[0].spec.ports[*]}{.targetPort}{":localhost:"}{.nodePort}{" "}{end}')<br/>do<br/>  FLAGS+=(--ssh-flag="-L ${MAPPING}")<br/>done</span></pre><p id="e09e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经解决了一个服务的问题，但是我们有多个服务。</p><h2 id="c3c0" class="jm jn hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">4.迭代多个服务</h2><p id="6155" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们已经接近我们需要的<code class="du js jt ju ji b">gcloud</code>命令了。有用的是，因为我们现在正在生成可能附加到<code class="du js jt ju ji b">gcloud</code>命令的字符串，我们也可以为第二个服务运行我们的命令，例如</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c8eb" class="jm jn hi ji b fi jo jp l jq jr">kubectl get service \<br/>  <strong class="ji hj">--selector=component=orderer</strong> \<br/>  --namespace=${NAMESPACE} \<br/>  --context=${CONTEXT} \<br/>  --output=jsonpath='{range .items[0].spec.ports[*]}{.targetPort}{":localhost:"}{.nodePort}{" "}{end}'</span></pre><blockquote class="ku kv kw"><p id="05bd" class="if ig kx ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">这个命令和前一个命令的唯一区别是选择器。</p></blockquote><p id="76f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">倒数第二步是将每个服务的标签集提取到另一个循环中:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="13bb" class="jm jn hi ji b fi jo jp l jq jr">for LABELS in \<br/>  "component=ca" \<br/>  "component=peer,org=org1,peer=0" \<br/>  "component=orderer"<br/>do<br/>  for MAPPING in $(\<br/>    kubectl get service \<br/>    --selector=${LABELS} \<br/>    --context=${CONTEXT} \<br/>    --namespace=${NAMESPACE} \<br/>    --output=jsonpath='{range .items[0].spec.ports[*]}{.targetPort}{":localhost:"}{.nodePort}{" "}{end}'\<br/>  )<br/>  do<br/>    FLAGS+=(--ssh-flag="-L ${MAPPING}")<br/>  done<br/>done</span></pre><blockquote class="ku kv kw"><p id="ccf2" class="if ig kx ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">希望你能看到如何推广这个过程。只是标签不同的Kubernetes服务提供了一个简单的迭代源。</p></blockquote><h2 id="5256" class="jm jn hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">5.生成gcloud命令</h2><p id="8cd2" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">因此，我们现在能够:</p><ul class=""><li id="7779" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">获取一个集群的<code class="du js jt ju ji b">Nodes</code>(从中我们可以访问它的<code class="du js jt ju ji b">NodePorts</code>)</li><li id="65fd" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">枚举感兴趣的多个服务的端口详细信息</li><li id="6d4f" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">为gcloud生成合适的— <code class="du js jt ju ji b">ssh-flag</code>语法</li></ul><p id="4996" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">剩下要做的就是生成gcloud命令。我们需要<code class="du js jt ju ji b">${NODE}</code>和<code class="du js jt ju ji b">— ssh-flags</code>的名单。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9da8" class="jm jn hi ji b fi jo jp l jq jr">gcloud compute ssh ${NODE} "${ARGS[A]}"</span></pre><p id="e7bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是完整的脚本:</p><figure class="jd je jf jg fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><blockquote class="ku kv kw"><p id="6307" class="if ig kx ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">我能够使用<code class="du js jt ju ji b">targetPort</code>，因为我知道它们是不重叠的。在您的解决方案中，您可能没有这种保证。在这种情况下，您可以为自己生成本地端口号，也可以直接使用节点端口或在本地映射这些端口。</p></blockquote><h2 id="0ac7" class="jm jn hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">结论</h2><p id="5aa1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我没有得到我想要的，但我能够生产出接近我需要的东西。理想情况下(！)，我希望能够将一个kubectl命令的输出通过管道传输到另一个命令的输入中，这种传输方式更像fluent:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="d879" class="jm jn hi ji b fi jo jp l jq jr">kubectl get nodes ... |<br/>xargs shuf --head-count 1 --echo |<br/>kubectl get services ... '{range}...{end}' |<br/>...</span></pre><p id="2e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p></div></div>    
</body>
</html>