<html>
<head>
<title>Monitoring website changes with Workflows, Cloud Functions and SendGrid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过工作流、云功能和SendGrid监控网站变化</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/monitoring-website-changes-with-workflows-cloud-functions-and-sendgrid-8f6dfa8d6485?source=collection_archive---------0-----------------------#2022-09-12">https://medium.com/google-cloud/monitoring-website-changes-with-workflows-cloud-functions-and-sendgrid-8f6dfa8d6485?source=collection_archive---------0-----------------------#2022-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bcd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每年在法国，大约在九月中旬，有一个特殊的周末，每个人都可以参观一些著名的地方，通常在一年的其余时间关闭。那是“<a class="ae jd" href="https://journeesdupatrimoine.culture.gouv.fr/" rel="noopener ugc nofollow" target="_blank">渡厄·帕特莫因</a>”。例如，如果你想看看法国总统或总理工作的地方，你可以去参观像<a class="ae jd" href="https://www.elysee.fr/" rel="noopener ugc nofollow" target="_blank">爱丽舍宫</a>或<a class="ae jd" href="https://www.gouvernement.fr/le-patrimoine-de-l-hotel-de-matignon" rel="noopener ugc nofollow" target="_blank">马蒂尼翁宫</a>这样的地方。然而，对于其中一些地方来说，在线注册预订一个位置是很棘手的，因为对它们的需求总是很高。此外，你必须在正确的时间到那里注册，通常，你甚至不知道那天或时间是什么时候！所以我想我可以通过跟踪爱丽舍宫网站上的变化来监控爱丽舍宫的网站，看看注册何时开放。</p><p id="eba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了监控网页或网站的变化，有大量的在线服务可用。自由请求的数量或者变更检查的频率通常有一些限制。作为Google Cloud的开发人员，我决定编写一个简单的解决方案，利用各种Google Cloud服务，即:</p><p id="251d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先来看一个计算网页哈希的函数。由于工作流标准库中没有哈希函数，我决定使用一个函数来完成这项工作。我使用Node.js运行时和crypto模块，它包含一个sha1实现:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="21d6" class="jn jo hi jj b fi jp jq l jr js">const crypto = require('crypto'); </span><span id="23f0" class="jn jo hi jj b fi jt jq l jr js">exports.checksum = (req, res) =&gt; { <br/>    const shasum = crypto.createHash('sha1'); <br/>    res.status(200).send({sha1: sha1});</span><span id="e7a5" class="jn jo hi jj b fi jt jq l jr js">    const webpageBody = req.body.webpage; <br/>    shasum.update(webpageBody);</span><span id="6557" class="jn jo hi jj b fi jt jq l jr js">    const sha1 = shasum.digest('hex'); <br/>};</span></pre><p id="ff46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数从工作流接收网页内容。然后，我用该内容创建sha1散列，并以十六进制形式在一个小的JSON有效负载中返回它。</p><p id="7507" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个Google云存储桶来存放我的网页哈希:</p><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es ju"><img src="../Images/2c2db8e6a47ef86ed93db58bd4a7759b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*Dotx51_qfI-OUbjH.png"/></div></figure><p id="29b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我使用SendGrid通过电子邮件通知我更改，所以我将API密钥安全地存储在Secret Manager中:</p><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es ju"><img src="../Images/f6ace864e8f7e9d09be1045e376280bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*tDG6gWE1wArp8DN8.png"/></div></figure><p id="6780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们一点一点地放大我们的工作流程。</p><p id="1522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我定义了一些变量，比如我的bucket的名称、我的hashes文本文件的名称，并且我检索了我的SendGrid API密钥(参见上一篇关于在工作流中使用Secret Manager的文章):</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="32bb" class="jn jo hi jj b fi jp jq l jr js">main:<br/>    params: [input]<br/>    steps:<br/>    - assignment:<br/>        assign:<br/>            - bucket: hash_results<br/>            - file_name: hash.txt<br/>    - get_email_api_key:<br/>        call: googleapis.secretmanager.v1.projects.secrets.versions.accessString<br/>        args:<br/>            secret_id: SENDGRID_API_KEY<br/>        result: EMAIL_API_KEY</span></pre><p id="c5bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我在GCS中读取前面hash的内容(你也可以查看这篇关于如何从一个工作流的bucket中读写JSON数据到一个文件的文章):</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="cc4a" class="jn jo hi jj b fi jp jq l jr js">- read_hash_from_gcs:<br/>        call: http.get<br/>        args:<br/>            url: ${"<a class="ae jd" href="https://storage.googleapis.com/download/storage/v1/b/" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/download/storage/v1/b/</a>" + bucket + "/o/" + file_name}<br/>            auth:<br/>                type: OAuth2<br/>            query:<br/>                alt: media<br/>        result: hash_from_gcs</span></pre><p id="57c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候对网站进行简单的HTTP GET调用了。目前，URL是硬编码的，但是我们可以将工作流参数化，以从工作流执行输入参数中获取该URL。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8676" class="jn jo hi jj b fi jp jq l jr js">- retrieve_web_page:<br/>        call: http.get<br/>        args:<br/>           url: <a class="ae jd" href="https://evenements.elysee.fr/" rel="noopener ugc nofollow" target="_blank">https://evenements.elysee.fr/</a><br/>        result: web_page</span></pre><p id="94ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我检索到URL的内容(请求的结果存储在web_page变量中)，我就可以通过调用我的云函数来计算我的散列值:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8444" class="jn jo hi jj b fi jp jq l jr js">- compute_hash:<br/>        call: http.post<br/>        args:<br/>            url: <a class="ae jd" href="https://europe-west1-patrimoine-check.cloudfunctions.net/checksum" rel="noopener ugc nofollow" target="_blank">https://europe-west1-patrimoine-check.cloudfunctions.net/checksum</a><br/>            body:<br/>                webpage: ${web_page.body}<br/>        result: hash_result</span></pre><p id="8c16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们在工作流程中引入一些分支的地方。如果网页没有改变，我们就提前结束，但是如果它改变了，我们就把新的散列存储在GCS中:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="f262" class="jn jo hi jj b fi jp jq l jr js">- assign_hashes:<br/>        assign:<br/>            - old_hash: ${hash_from_gcs.body.sha1}<br/>            - new_hash: ${hash_result.body.sha1}<br/>            - hash_msg: ${"Old hash = " + old_hash + " / New hash = " + new_hash}<br/>    - conditionalSwitch:<br/>        switch:<br/>        - condition: ${new_hash != old_hash}<br/>          next: write_hash_to_gcs<br/>        next: returnOutput<br/>    - write_hash_to_gcs:<br/>        call: http.post<br/>        args:<br/>            url: ${"<a class="ae jd" href="https://storage.googleapis.com/upload/storage/v1/b/" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/upload/storage/v1/b/</a>" + bucket + "/o"}<br/>            auth:<br/>                type: OAuth2<br/>            query:<br/>                name: ${file_name}<br/>            body:<br/>                sha1: ${hash_result.body.sha1}</span></pre><p id="7e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我记录了网站已经更改的事实，并且我正在调用SendGrid API(就像本文中关于使用SendGrid从工作流发送电子邮件的内容一样):</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="322f" class="jn jo hi jj b fi jp jq l jr js">- site_changed_log:<br/>        call: sys.log<br/>        args:<br/>            text: Website has changed<br/>    - notify_by_email:<br/>        call: http.post<br/>        args:<br/>            url: <a class="ae jd" href="https://api.sendgrid.com/v3/mail/send" rel="noopener ugc nofollow" target="_blank">https://api.sendgrid.com/v3/mail/send</a><br/>            headers:<br/>                Content-Type: "application/json"<br/>                Authorization: ${"Bearer " + EMAIL_API_KEY}<br/>            body:<br/>                personalizations:<br/>                    - to:<br/>                        - email: <a class="ae jd" href="mailto:me@gmail.com" rel="noopener ugc nofollow" target="_blank">me@gmail.com</a><br/>                from:<br/>                    email: <a class="ae jd" href="mailto:you@gmail.com" rel="noopener ugc nofollow" target="_blank">you@gmail.com</a><br/>                subject: "Elysée, page mise à jour"<br/>                content:<br/>                    - type: text/plain<br/>                      value: "La page de l'Élysée a été mise à jour"<br/>    - log_hashes:<br/>        call: sys.log<br/>        args:<br/>            text: ${hash_msg}<br/>    - returnOutput:<br/>            return: ${hash_msg} </span></pre><p id="ee99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要定期调用工作流。工作流可以配置为通过Cloud Scheduler按计划调用(同样，查看这篇关于计划工作流执行的文章)。我用* * * * * cron模式将我的工作流配置为每分钟触发一次。</p><figure class="je jf jg jh fd jv er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ju"><img src="../Images/5bfa4a97aa3af01091f149090d121fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*72LKd27O_neTrsG5.png"/></div></div></figure><p id="6f73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧啊。我让我的小工作流每分钟都被调用来检查网页是否有变化，如果有，就给我发一封电子邮件！</p><p id="aadd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">老实说，这个工作流程非常完美…但事实是我没有监控正确的URL，我应该监控首页。此外，我监控的页面包含一些动态JavaScript代码，但是获取的HTML并没有真正改变。我错过了登记窗口，在我甚至有时间登记我的家人来参观之前，所有的位置都被超级迅速地填满了！真为我感到羞耻，下次最好检查一下我的网址，或者用运行在Cloud Run或Cloud Functions中的无头Chrome创建网页截图！或者，当然，使用在线服务已经解决了这些问题与他们多年的经验！希望明年，我不会错过报名！但是把谷歌云上所有有用的服务粘在一起，解决一个具体的问题是很有趣的。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="d388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kj">最初发表于</em><a class="ae jd" href="https://glaforge.appspot.com/article/monitoring-website-changes-with-workflows-cloud-functions-and-sendgrid" rel="noopener ugc nofollow" target="_blank"><em class="kj">【https://glaforge.appspot.com】</em></a><em class="kj">。</em></p></div></div>    
</body>
</html>