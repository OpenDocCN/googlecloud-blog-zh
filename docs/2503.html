<html>
<head>
<title>Configure Streams from Partition table in PostgreSQL to non partition in BigQuery using Datastream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用数据流配置从PostgreSQL中的分区表到BigQuery中的非分区的流</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/configure-streams-from-partition-table-in-postgresql-to-non-partition-in-bigquery-using-datastream-3238fe3321d9?source=collection_archive---------1-----------------------#2022-11-14">https://medium.com/google-cloud/configure-streams-from-partition-table-in-postgresql-to-non-partition-in-bigquery-using-datastream-3238fe3321d9?source=collection_archive---------1-----------------------#2022-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="3be9" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这是PostgreSQL和BigQuery在数据流上解决真实世界场景系列的第2部分，如果有兴趣查看所有策划的场景<a class="ae jh" href="https://mahtodeepak.medium.com/solving-real-world-scenarios-on-datastream-for-postgresql-and-bigquery-b79334a065fc" rel="noopener">请点击我。</a></p></blockquote><p id="9abb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">PostgreSQL数据库提供了分区等企业级数据库特性。当谈到使用逻辑复制的分区和流更改时，我们有像<a class="ae jh" href="https://www.postgresql.org/docs/current/sql-createpublication.html#:~:text=existing%20table%20data.-,publish_via_partition_root,-(boolean)" rel="noopener ugc nofollow" target="_blank"><em class="ik">publish _ via _ partition _ root</em></a>这样的配置，它们影响更改需要如何传播到订阅服务器。PostgreSQL支持声明性分区，它允许为一个表声明一个分区，并且根表是一个不存储任何数据的虚拟表；所有数据都驻留在特定的分区中。</p><p id="9f27" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们可以让客户将PostgreSQL中跨分区的数据作为源合并到BigQuery的单个表中。</p><p id="e6a8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在今天的博客中，我们将提供一种方法，说明如何使用<em class="ik">publish _ via _ partition _ root</em>发布配置将PostgreSQL中作为源的分区表的所有更改合并到BigQuery中的单个表中，并了解如何从源中捕获新的分区数据。</p><p id="fef0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们用PostgreSQL构建一个示例分区表，并创建必要的发布和复制槽。</p><h2 id="ef88" class="jl jm hi bd jn jo jp jq jr js jt ju jv ji jw jx jy jj jz ka kb jk kc kd ke kf bi translated">PostgreSQL分区表和发布配置</h2><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="291a" class="kp jm hi kl b be kq kr l ks kt">CREATE TABLE order_partition_pk(<br/>order_id bigint NULL,<br/>ordered_at timestamp(0) without time zone NULL,<br/>shipped_at timestamp(0) without time zone NULL,<br/>order_amount double precision NULL,<br/>customer_id varchar(255) NULL<br/>) PARTITION BY RANGE( ordered_at);<br/><br/>alter table order_partition_pk add constraint pk_order_partition_pk primary key(order_id,ordered_at);<br/><br/>CREATE TABLE order_partition_pk_2020 PARTITION OF order_partition_pk FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');<br/>CREATE TABLE order_partition_pk_2021 PARTITION OF order_partition_pk FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');<br/>CREATE TABLE order_partition_pk_2022 PARTITION OF order_partition_pk FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');<br/><br/>insert into order_partition_pk  <br/>select col1, <br/>date_trunc('day',clock_timestamp()::timestamp(0) without time zone - interval '1 day' * mod(col1,700)),<br/>clock_timestamp()::timestamp(0) without time zone + interval '1 day' - interval '1 day' * mod(col1,700)  ,<br/>col1*0.33,<br/>col1::text<br/>from generate_series(1,100000) as col1 ;<br/><br/>create publication pub_partition for all tables;<br/><br/>SELECT PG_CREATE_LOGICAL_REPLICATION_SLOT('rep_slot_partition', 'pgoutput');</span></pre><p id="3418" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们将使用<em class="ik">publish _ via _ partition _ root</em>配置将发布更改为true。</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="e921" class="kp jm hi kl b be kq kr l ks kt">alter publication pub_partition set (publish_via_partition_root=true);<br/><br/>ds_sample=&gt; \dRp<br/>                                    List of publications<br/>     Name      |  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root <br/>---------------+----------+------------+---------+---------+---------+-----------+----------<br/> pub_partition | postgres | t          | t       | t       | t       | t         | t<br/>(1 row)</span></pre><p id="5ab8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们已经创建了必要的分区表，并填充了三个分区。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ku"><img src="../Images/06c108cfd59a7a8b265d4d9642a385cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bq6O8_F3YeaWTuA6z5aMlw.png"/></div></div></figure><h2 id="5a19" class="jl jm hi bd jn jo jp jq jr js jt ju jv ji jw jx jy jj jz ka kb jk kc kd ke kf bi translated">为作为目标的BigQuery的数据流中的已分区表创建流。</h2><p id="05a6" class="pw-post-body-paragraph ii ij hi il b im lc io ip iq ld is it ji le iw ix jj lf ja jb jk lg je jf jg hb bi translated">我们已经配置了必要连接相关设置，并将为PostgreSQL中的分区表创建流，作为数据流中BigQuery的源和目标。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lh"><img src="../Images/5f975d0002e458e7e195c85e75e6ece0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ahNnZHPMPcflKhwdgZxdqg.gif"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">数据流公共预览— PostgreSQL到BigQuery</figcaption></figure><p id="d386" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在选择分区表时，我们有意忽略选择它的分区，而只选择父表或根表。不应选择它，以避免由于<em class="ik">publish _ via _ partition _ root</em>设置<em class="ik">而导致初始回填和连续更改之间可能发生的BigQuery目标差异。</em></p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lm"><img src="../Images/bfc3e6025c1a90bed1243329e116a457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Cc8FNB5rA9R2_iHPJEjDQ.png"/></div></div></figure><p id="bd3f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">创建流并启动它之后，我们可以看到我们的初始回填已经完成。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ln"><img src="../Images/0b1a3ff8d73cc5092fc97c13fe46e82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5trO1T87hYEvCuraFwE8Q.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">数据流回填完成</figcaption></figure><h2 id="0a01" class="jl jm hi bd jn jo jp jq jr js jt ju jv ji jw jx jy jj jz ka kb jk kc kd ke kf bi translated">在PostgreSQL中对已分区表应用DML，并在BigQuery中进行验证。</h2><p id="82c5" class="pw-post-body-paragraph ii ij hi il b im lc io ip iq ld is it ji le iw ix jj lf ja jb jk lg je jf jg hb bi translated">我们将在分区表上应用dml，并用模拟数据添加新的分区。<br/>在PostgreSQL源代码上应用插入和更新。</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="0001" class="kp jm hi kl b be kq kr l ks kt">insert into order_partition_pk  <br/>select col1, <br/>date_trunc('day',clock_timestamp()::timestamp(0) without time zone - interval '1 day' * mod(col1,700)),<br/>clock_timestamp()::timestamp(0) without time zone + interval '1 day' - interval '1 day' * mod(col1,700)  ,<br/>col1*0.33,<br/>col1::text<br/>from generate_series(100001,101000) as col1 ;<br/><br/>update order_partition_pk<br/>set order_amount = order_amount+0.33<br/>where order_id in (select generate_series(100001,101000));</span></pre><p id="0169" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们可以从数据流控制台验证是否捕获了新的DML事件。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lo"><img src="../Images/9cc0279b16d81eabf283d23ff01191d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZz5BjtvUNrrDMowIq_Faw.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">数据流事件</figcaption></figure><p id="9e32" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">BigQuery控制台中的快速检查可以确认这一点。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lp"><img src="../Images/41d8e5d92387fca06d61257b784f0666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miKQ64O3JGcWlxmsEoQDag.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">BigQuery — SQL检查</figcaption></figure><p id="5018" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在接下来的更改中，我们将为subscribe partitions表创建新的分区，并应用DML。</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="5d73" class="kp jm hi kl b be kq kr l ks kt">ds_sample=&gt; CREATE TABLE order_partition_pk_2019 PARTITION OF order_partition_pk FOR VALUES FROM ('2019-01-01') TO ('2020-01-01');<br/>CREATE TABLE<br/>ds_sample=&gt; insert into order_partition_pk  <br/>select col1, <br/>dd,<br/>dd + interval '1 day'  ,<br/>col1*0.33,<br/>col1::text<br/>from generate_series(101000,101005)  as col1  , generate_series<br/>        ( '2019-01-01'::timestamp <br/>        , '2019-12-31'::timestamp<br/>        , '1 day'::interval) dd;<br/>INSERT 0 2190</span></pre><p id="741d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们可以从数据流控制台验证是否捕获了新的DML事件。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lq"><img src="../Images/36599444e3d0bcd969fd1a71a59f0036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etVy0xtYCU0B3PM04begMw.png"/></div></div></figure><p id="f28f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">BigQuery控制台中的快速检查可以确认这一点。</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="0aeb" class="kp jm hi kl b be kq kr l ks kt">SELECT * FROM `databaseproj-366912.ds_public_partitionpublic.order_partition_pk` where order_id &gt; 100999</span></pre><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lr"><img src="../Images/77e4b753f83f32bc00691d94150bbaaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAd067w4d56lsr28Zyi88g.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">BigQuery SQL检查。</figcaption></figure><h2 id="d526" class="jl jm hi bd jn jo jp jq jr js jt ju jv ji jw jx jy jj jz ka kb jk kc kd ke kf bi translated">结论</h2><p id="bf80" class="pw-post-body-paragraph ii ij hi il b im lc io ip iq ld is it ji le iw ix jj lf ja jb jk lg je jf jg hb bi translated">如果我们有一个从PostgreSQL作为源到BigQuery作为目标合并分区表的场景，我们可以使用发布配置<em class="ik">publish _ via _ partition _ root</em>来实现它。为了避免任何差异，建议在创建流时不要选择关注表的分区。<br/>所有场景都在支持PostgreSQL作为源和BigQuery作为目标的公开预览版的数据流上进行测试。</p><h2 id="26c5" class="jl jm hi bd jn jo jp jq jr js jt ju jv ji jw jx jy jj jz ka kb jk kc kd ke kf bi translated">进一步阅读</h2><blockquote class="if ig ih"><p id="5ac3" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">查看解决PostgreSQL和BigQuery的数据流上的真实场景的第3部分的<a class="ae jh" rel="noopener" href="/google-cloud/configure-streams-in-datastream-with-predefined-tables-in-bigquery-for-postgresql-as-source-528340f7989b">，其中包括“使用PostgreSQL的BigQuery中的预定义表配置数据流中的流作为源”</a></p></blockquote></div></div>    
</body>
</html>