<html>
<head>
<title>Google Trillian for Noobs (1b)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Trillian for Noobs(10亿美元)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-trillian-for-noobs-1b-16097474ee3d?source=collection_archive---------0-----------------------#2019-07-05">https://medium.com/google-cloud/google-trillian-for-noobs-1b-16097474ee3d?source=collection_archive---------0-----------------------#2019-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1d0c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">失踪的手册系列</h2></div><p id="0b4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上周，我记录了我希望是最简单的崔莉恩人格。昨天我<a class="ae jt" rel="noopener" href="/google-cloud/google-trillian-for-noobs-1a-c87a78e5e585">记录了</a>添加包含证明。今天我们将把<code class="du ju jv jw jx b">main.go</code>分成一个客户端和一个服务器，并使用gRPC重新连接它们。这是gRPC而不是Trillian的作品，但它有助于发展个性。</p><h2 id="d02a" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">设置</h2><p id="30aa" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">您将需要我在之前的帖子中描述的数据库和Trillian服务器。</p><h2 id="cdca" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">基于gRPC的个性服务器</h2><p id="d06e" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">这一次，要么克隆<code class="du ju jv jw jx b">gRPC</code>:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="90b0" class="jy jz hi jx b fi lg lh l li lj">git clone \<br/>--single-branch \<br/>--branch=gRPC \<br/><a class="ae jt" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:DazWilkin/simple-trillian-log-1.git</span></pre><p id="a211" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者您可以运行Docker合成文件:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="18a6" class="jy jz hi jx b fi lg lh l li lj">docker-compose --file=./deployment/docker-compose.yml up</span></pre><blockquote class="lk ll lm"><p id="fd49" class="ix iy ln iz b ja jb ij jc jd je im jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">无论哪种情况，你都需要创建数据库。</p></blockquote><p id="7ca3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Docker Compose将创建7个服务:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="6005" class="jy jz hi jx b fi lg lh l li lj">Name                       State  Ports<br/>--------------------------------------------------------------------<br/>adminer                    Up     0.0.0.0:7777-&gt;8080/tcp<br/>basic-personality-client   Up     0.0.0.0:9997-&gt;9999/tcp<br/>basic-personality-server   Up     50051/tcp<br/>                                  0.0.0.0:8080-&gt;8080/tcp<br/>                                  0.0.0.0:9998-&gt;9999/tcp<br/>db                         Up     3306/tcp<br/>prometheus                 Up     0.0.0.0:9090-&gt;9090/tcp<br/>trillian-log-server        Up     0.0.0.0:54051-&gt;50051/tcp, 8080/tcp<br/>trillian-log-signer        Up     50051/tcp, 8080/tcp</span></pre><p id="3e33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不会进一步描述<code class="du ju jv jw jx b">adminer</code>和<code class="du ju jv jw jx b">db</code>。可以说，<code class="du ju jv jw jx b">db</code>服务在(！idspnonenote)中公开了端口<code class="du ju jv jw jx b">3306</code>。)Docker创建的网络组成了Trillian日志服务器和日志签名者。</p><p id="5bbf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ju jv jw jx b">basic-personality-client</code>在<code class="du ju jv jw jx b">basic-personality-client:9999</code>上内部公开一个zPages端点，该端点将在<code class="du ju jv jw jx b">:9997</code>上在您的主机上公开。您可以使用<code class="du ju jv jw jx b">localhost:9997/debug/rpcz</code>或<code class="du ju jv jw jx b">localhost:9997/debug/tracez</code>浏览该端点。</p><p id="90ce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ju jv jw jx b">basic-personality-server</code>在内部公开<code class="du ju jv jw jx b">:50051</code>(仅),由<code class="du ju jv jw jx b">basic-personality-client</code>使用gRPC访问。该服务还在内部公开了<code class="du ju jv jw jx b">:8080</code> (http)和<code class="du ju jv jw jx b">basic-personality-server:9999</code>上的一个zPages端点，该端点将在<code class="du ju jv jw jx b">:9998</code>上在您的主机上公开。您可以使用<code class="du ju jv jw jx b">localhost:9998/debug/rpcz</code>或<code class="du ju jv jw jx b">localhost:9998/debug/tracez</code>浏览该端点。</p><p id="9c41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ju jv jw jx b">prometheus</code>服务在<code class="du ju jv jw jx b">:9090</code>上公开其端点(见下文)。</p><p id="42d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ju jv jw jx b">trillian-log-server</code>在<code class="du ju jv jw jx b">:54051</code>的主机上暴露其gRPC端点。这是为了提供一个主机可访问的端点来使用<code class="du ju jv jw jx b">createtree</code>二进制文件创建新的日志。</p><h2 id="d811" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">普罗米修斯</h2><p id="fd8f" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">目前只有Trillian服务被检测。您可以通过以下网址访问Prometheus服务器:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="6a32" class="jy jz hi jx b fi lg lh l li lj"><a class="ae jt" href="http://localhost:9090/targets" rel="noopener ugc nofollow" target="_blank">http://localhost:9090</a><br/><a class="ae jt" href="http://localhost:9090" rel="noopener ugc nofollow" target="_blank">http://localhost:9090</a>/graph<br/>http://localhost:9090/status<br/>http://localhost:9090/targets<br/>http://localhost:9090/-/healthy</span></pre><figure class="ky kz la lb fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lr"><img src="../Images/7cbfb07eb0ede47846b34e14b1db7766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKXujz8aWGn7GjuuMuKnsw.png"/></div></div></figure><blockquote class="lk ll lm"><p id="4a27" class="ix iy ln iz b ja jb ij jc jd je im jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>因为Prometheus是Docker Compose网络的一部分，所以该服务能够使用Trillian服务的网络名称(<code class="du ju jv jw jx b">trillian-log-server</code>和<code class="du ju jv jw jx b">trillian-log-signer</code>)来引用它们。如果您希望直接访问这些服务的<code class="du ju jv jw jx b">/metrics</code>端点，您将需要创建<code class="du ju jv jw jx b">port</code>绑定来在主机上公开这些服务的<code class="du ju jv jw jx b">:8080</code>端口。</p></blockquote><h2 id="b9fa" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">zPages</h2><p id="cd0d" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">OpenCensus的zPages包增加了一个小功能，提供了gRPC调用的细节，包括跟踪。谷歌的惯例是多元化(多元化？)这些带'-z '的。因此，您可以浏览:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="e146" class="jy jz hi jx b fi lg lh l li lj"><a class="ae jt" href="http://localhost:9998/rpcz" rel="noopener ugc nofollow" target="_blank">http://localhost:9998/debug/rpcz</a><br/>http://localhost:9998/debug/tracez</span></pre><p id="8d4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于<code class="du ju jv jw jx b">basic-personality-server</code>(在<code class="du ju jv jw jx b">:9998</code>曝光)，您应该看到:</p><figure class="ky kz la lb fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lz"><img src="../Images/15fc3a6f90b58b8289445341aa9a8038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YsAns1--8iY-0swX7R-Uw.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">/调试/rpcz</figcaption></figure><p id="87a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><figure class="ky kz la lb fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es me"><img src="../Images/068ba62157b77429cfde449f71d18152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MUtcPLxyLVf03t8AENvog.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">/debug/tracez</figcaption></figure><blockquote class="lk ll lm"><p id="5216" class="ix iy ln iz b ja jb ij jc jd je im jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>对于tracez来说，第一列是进行中的|正在运行的跟踪，所以你必须在适当的时候刷新。延迟直方图提供了更多深入分析的机会。</p></blockquote><h2 id="e6d4" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">频道z</h2><p id="0615" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">基本个性gRPC服务器在其gRPC端点(<code class="du ju jv jw jx b">:50051</code>)上公开了一个<a class="ae jt" href="https://grpc.io/blog/a_short_introduction_to_channelz/" rel="noopener ugc nofollow" target="_blank">通道</a>端点。如果您希望探索channelz的功能，请参见<a class="ae jt" href="https://github.com/grpc/grpc-experiments/tree/master/gdebug" rel="noopener ugc nofollow" target="_blank"> gdebug </a>。最简单的解决方案是修改Docker Compose文件，将这个端口暴露给主机，这样您就可以在主机上运行gdebug，并且gdebug可以访问基本的个性化服务。</p><h2 id="51c3" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">原蟾蜍</h2><p id="04c1" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">回购的这一分支中的变化的本质是为我们的原始客户端(<code class="du ju jv jw jx b">main.go</code>)发送到Trillian日志服务器和从Trillian日志服务器接收的消息添加了protobuf定义。我们重构了这段代码，使它看起来像是在与一个<code class="du ju jv jw jx b">server</code>交互，而实际上这纯粹是一个命名|包的想法。你会记得我们有三个函数有相似的签名。的形式:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="2ff4" class="jy jz hi jx b fi lg lh l li lj">server.<strong class="jx hj">put</strong>(&amp;Request{<br/>  thing: *thing,<br/>  extra: *extra,<br/> }</span></pre><p id="9190" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在创建了这些函数和消息的protobuf定义之后。那么现在使用gRPC <code class="du ju jv jw jx b">client</code>代理的新客户端代码看起来类似:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="6b42" class="jy jz hi jx b fi lg lh l li lj">client.PutThing(ctx, &amp;pb.ThingRequest{<br/>   Thing: &amp;pb.Thing{...},<br/>   Extra: &amp;pb.Extra{...},<br/>})</span></pre><p id="fdc3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">gRPC服务器代理只是:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="8a53" class="jy jz hi jx b fi lg lh l li lj">func (s *server) PutThing(ctx context.Context, r *pb.ThingRequest) (*pb.ThingResponse, error) { return s.<strong class="jx hj">put</strong>(r) }</span></pre><p id="f0e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不想用gRPC教程来烦你，但是为了完整起见，<code class="du ju jv jw jx b">pb.ThingRequest</code>和<code class="du ju jv jw jx b">pb.ThingResponse</code>类型在protobuf定义中描述了，还有我们重命名的——但在其他方面类似的——函数<code class="du ju jv jw jx b">PutThing</code>、<code class="du ju jv jw jx b">GetThing</code>和<code class="du ju jv jw jx b">WaitThing</code>。</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="c57c" class="jy jz hi jx b fi lg lh l li lj">syntax = "proto3";</span><span id="5954" class="jy jz hi jx b fi mf lh l li lj">package google.basicpersonality.v1;</span><span id="372b" class="jy jz hi jx b fi mf lh l li lj">option go_package = "github.com/DazWilkin/basic-personality/protos";<br/>option java_package = "com.google.dazwilkin.basicpersonality";</span><span id="f6c6" class="jy jz hi jx b fi mf lh l li lj">service BasicPersonality {<br/>  rpc PutThing(ThingRequest) returns (ThingResponse) {};<br/>  rpc GetThing(ThingRequest) returns (ThingResponse) {};<br/>  rpc WaitThing(ThingRequest) returns (ThingResponse) {};</span><span id="f159" class="jy jz hi jx b fi mf lh l li lj">message <strong class="jx hj">ThingRequest</strong> {<br/>  Thing thing = 1;<br/>  Extra extra = 2;<br/>}<br/>message <strong class="jx hj">ThingResponse</strong> {<br/>  string status = 1;<br/>}<br/>message Thing {<br/>  string name = 1;<br/>}<br/>message Extra {<br/>  string name = 1;<br/>}</span></pre><p id="4eb9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们所需要做的就是向protobuf编译器(<code class="du ju jv jw jx b">protoc</code>)提供上面的定义，配置它来为我们生成Golang绑定，我们就快完成了。</p><p id="3630" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们需要将原来的<code class="du ju jv jw jx b">main.go</code>解耦成一个客户端和一个服务器，每个客户端和服务器都使用机器生成的gRPC绑定来绑定<code class="du ju jv jw jx b">BasicPersonality</code>，并让gRPC运行时负责在它们之间传递消息。</p><h2 id="8b3e" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">Docker撰写</h2><p id="cc1f" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">如前所述，Docker Compose文件被扩展为与数据库、Trillian日志服务器和日志签名者以及Prometheus一起运行<code class="du ju jv jw jx b">basic-personality-client</code>和<code class="du ju jv jw jx b">basic-personality-server</code>。我们用gRPC端口(<code class="du ju jv jw jx b">:50051</code>)来配置它们，以便将它们绑定在一起。</p><p id="029b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端被配置为永远运行，尽管有15秒钟的暂停。当你编写Docker文件时，小心不要让它运行，因为你最终会破坏数据库。</p><h2 id="5413" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">结论</h2><p id="5b82" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">我们现在有一个非常基本的Trillian personality，称为“基本personality ”,它被实现为Golang gRPC服务器，该服务器本身使用gRPC与Trillian服务进行通信。为了简单起见，我们生成了一个Golang gRPC客户端，它与我们的基本个性服务器集成在一起。</p><p id="8328" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为Basic Personality有一个protobuf服务定义，并使用该定义公开了一个gRPC端点，所以您可以使用protobuf并以任何gRPC语言生成一个客户机来与服务进行对话。</p><p id="03c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在接下来的步骤中，我想我会(a)使用OpenCensus来规范这些服务；(b)生成一个非Golang gRPC客户端。我在谷歌上搜索了Rust gRPC，对于一个Rust初学者来说，这似乎不是一件小事。如果有人读了这篇文章，想展示这是如何做到的，我会很感兴趣。</p></div></div>    
</body>
</html>