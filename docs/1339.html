<html>
<head>
<title>Solving a Set Cover Problem in Cloud IAM on GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP云IAM中集合覆盖问题的求解</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/solving-a-set-cover-problem-in-cloud-iam-on-gcp-6c509b39271b?source=collection_archive---------0-----------------------#2020-03-25">https://medium.com/google-cloud/solving-a-set-cover-problem-in-cloud-iam-on-gcp-6c509b39271b?source=collection_archive---------0-----------------------#2020-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="06a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，一位战略云工程师同事从一位谷歌云客户那里提出了一个有趣的问题，引发了我们的集体兴趣。他们曾问过如何以最少的工作量获得谷歌云平台上所有可能的许可。GCP有数百个角色和数千个权限。为了回答这个问题，我们必须看每一个。这需要用代码来解决。</p><p id="3a18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这主要是一个思考练习。授予每一个可能的权限的明显问题是，它违反了职责分离等最佳实践，即按照完成用户或团队工作所需的最小特权原则授予访问权限。获取的范围是巨大的，应该非常小心以防止误用或滥用。我强烈推荐阅读这篇<a class="ae jd" href="https://cloud.google.com/blog/products/identity-security/dont-get-pwned-practicing-the-principle-of-least-privilege" rel="noopener ugc nofollow" target="_blank">博客文章</a>，了解更多关于安全使用IAM的信息。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="6537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们对一些基本的谷歌云平台(GCP) IAM概念进行水平设置。<a class="ae jd" href="https://cloud.google.com/iam" rel="noopener ugc nofollow" target="_blank"> Cloud IAM </a>提供了授权访问谷歌云资源的框架。用最简单的话来说，<a class="ae jd" href="https://cloud.google.com/iam/docs/overview#cloud-iam-policy" rel="noopener ugc nofollow" target="_blank"> IAM策略</a>授予成员在云资源上执行特定操作的权限。</p><p id="f0d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GCP使用资源，比如列出或创建Google计算引擎实例，需要特定的<a class="ae jd" href="https://cloud.google.com/iam/docs/overview#permissions" rel="noopener ugc nofollow" target="_blank">权限</a>:分别是compute.instances.list或compute instances.create。权限通常对应于GCP API方法。</p><p id="6818" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/iam/docs/overview#roles" rel="noopener ugc nofollow" target="_blank">角色</a>是授予IAM策略的<a class="ae jd" href="https://cloud.google.com/iam/docs/overview#concepts_related_identity" rel="noopener ugc nofollow" target="_blank">成员</a>的权限包。成员可以是用户、服务帐户、组或域。谷歌提供了许多各种类型的<a class="ae jd" href="https://cloud.google.com/iam/docs/understanding-roles#role_types" rel="noopener ugc nofollow" target="_blank">预定义角色</a>——有时与成员可能执行的工作职能相关——如数据库管理员、需要BigQuery读取权限的数据科学家或监督整个平台安全控制的安全工程师。没有一个角色包含所有可能的权限，这些权限数以千计，并将继续增长。</p><p id="e366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">IAM策略适用于各种资源:组织、文件夹、项目、实例等。一个策略将成员绑定到一个角色<strong class="ih hj">。</strong>在资源上设置策略时，最终会授予访问权限。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="27e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决用最少的可能角色授予每个权限的问题，你可以使用<a class="ae jd" href="https://docs.python.org/3/" rel="noopener ugc nofollow" target="_blank"> Python 3 </a>和<a class="ae jd" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter </a>中的prototype，因为这是迭代算法的好方法。</p><p id="cbd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要获得可用IAM角色的完整列表以及其中包含的权限。在下面的代码中，我使用Google API的<a class="ae jd" href="https://github.com/googleapis/google-api-python-client" rel="noopener ugc nofollow" target="_blank"> Python客户端</a>来列出和描述角色，直到结果用尽。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">通过查询API枚举GCP IAM角色。</figcaption></figure><p id="df23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着角色及其权限的变化，您可以选择将字典作为一个JSON文件转储，作为一个简单的、人类可读的结果缓存。在迭代算法时，您可能会节省数百个API调用，或者您可以选择将数据用于以后的分析。</p><p id="aec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一下结果的前几行。角色(即<a class="ae jd" href="https://console.cloud.google.com/iam-admin/roles/details/roles%3Caccessapproval.approver" rel="noopener ugc nofollow" target="_blank">roles/access approval . approver</a>)是键，值是原始的<em class="jw"> describe </em> API调用结果。“includedPermissions”的数组值正是我们要寻找的。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">GCP IAM角色结果为JSON，被截断。</figcaption></figure><p id="eaca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，结果可能不会很大，只有751K的重复数据。数据中存在多对多的关系，因此为了处理结果，您需要执行一些查找，比如识别特定角色中的权限，或者发现哪些角色包含给定的权限。您还需要确定哪些独特的权限是可用的，这样就有可能产生一组提供所有这些权限的角色。</p><p id="bccc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对数据进行一次迭代，并为每个查找创建几个字典。在迭代数据时，计算并存储每个角色包含多少权限——这在以后会很有用。通过创建和填充权限集来跟踪唯一权限。这不仅是一个有用的数据结构，而且您需要知道所有可能的权限值，以便知道何时找到满意的答案。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">通过将角色映射到其权限来处理角色数据，反之亦然。</figcaption></figure><p id="196c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按角色包含的权限数量对角色进行排序。这在下一步和后面的选择算法中很有用。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="563b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GCP中的角色通常是另一个角色的子集，这意味着它们包含的权限可以完全包含在另一个更全面的角色中。在运行选择算法之前消除子集角色将提高选择的质量。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">查找子集角色</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="4f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个被解决的问题叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/Set_cover_problem" rel="noopener ugc nofollow" target="_blank">集合覆盖问题</a>。有一个包含所有可能的唯一权限的集合(称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Universe_(mathematics)" rel="noopener ugc nofollow" target="_blank">领域</a>)和一个权限(角色)集合的集合，其<a class="ae jd" href="https://en.wikipedia.org/wiki/Union_(set_theory)" rel="noopener ugc nofollow" target="_blank">联合</a>等于领域。您只需要找出哪些角色加在一起等于所有可能的权限。</p><p id="54fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用来寻找集合的算法叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/Greedy_algorithm" rel="noopener ugc nofollow" target="_blank">贪婪算法</a>。目标是首先找到包含最多权限的角色。我们将从集合中删除该角色满足的权限，然后处理剩余的权限。在每一次迭代中，我们查看剩余集合中的一个权限。我们查看包含该权限的角色集，然后根据每个角色包含多少权限对该列表进行排序。我们总是选择包含最多权限的角色。这样，我们就有最大的机会在每次迭代中从剩余的集合中移除权限。我们跟踪我们选择的每个角色，当不再有权限时，我们知道我们已经为每个角色解决了问题。</p><p id="542d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先抢权限最多的角色。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="11e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该角色最终成为拥有2578个权限的<a class="ae jd" href="https://console.cloud.google.com/iam-admin/roles/details/roles%3Cowner" rel="noopener ugc nofollow" target="_blank"> <em class="jw">所有者</em> </a>。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jx"><img src="../Images/450f24ce8665aa7905a2f522b37a8f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/0*MwlXmwj41kS3e7ao"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">在<a class="ae jd" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter </a>中处理结果。</figcaption></figure><p id="3946" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个所选角色的<a class="ae jd" href="https://docs.python.org/3/tutorial/datastructures.html#sets" rel="noopener ugc nofollow" target="_blank">集合</a>，并用被识别为包含最多权限的<em class="jw">所有者</em>角色对其进行初始化。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="2c0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，计算<em class="jw">所有者</em>角色尚未满足的权限以及唯一权限的范围。下面，使用集合上的减号运算符计算<a class="ae jd" href="https://docs.python.org/3.8/library/stdtypes.html#frozenset.difference" rel="noopener ugc nofollow" target="_blank">差</a>；结果设置在<em class="jw">剩余的</em>变量中。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div></figure><p id="eec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然仍有权限需要我们选择的角色来满足，但算法会继续尝试并找到满意的角色。因为它很贪婪，所以它总是使用拥有最多权限的角色来满足所需的权限。每次迭代后，它会重新计算剩余的权限，并循环直到没有剩余权限。</p><figure class="jl jm jn jo fd jp"><div class="bz dy l di"><div class="jq jr l"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">选择满足必要的剩余权限的角色。</figcaption></figure><p id="6c3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法选择了以下16个角色，按字母顺序排序:</p><pre class="jl jm jn jo fd ka kb kc kd aw ke bi"><span id="16af" class="kf kg hi kb b fi kh ki l kj kk">roles/axt.admin<br/>roles/billing.admin<br/>roles/billing.creator<br/>roles/compute.xpnAdmin<br/>roles/container.hostServiceAgentUser<br/>roles/datacatalog.categoryFineGrainedReader<br/>roles/datafusion.serviceAgent<br/>roles/iam.serviceAccountTokenCreator<br/>roles/iap.httpsResourceAccessor<br/>roles/orgpolicy.policyAdmin<br/>roles/owner<br/>roles/remotebuildexecution.actionCacheWriter<br/>roles/resourcemanager.folderAdmin<br/>roles/resourcemanager.organizationAdmin<br/>roles/resourcemanager.projectCreator<br/>roles/serverless.serviceAgent</span></pre><p id="86ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以验证所选角色是否包含全域中的所有权限:</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kl"><img src="../Images/b0b25626be69dbc21589430bfb16ab82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MjDywRBGIvnSHIct"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">确认所选角色包含所有可能的权限。</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="2a33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您有了一组角色，这些角色授予了GCP的所有独特权限。但是这是最小可能的角色集合吗？</p><p id="043e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不。嗯，可能不会。</p><p id="cd87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法不会选择最小的可能集合。更糟糕的是，集合覆盖问题是<a class="ae jd" href="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener ugc nofollow" target="_blank"> NP-hard </a>，这意味着你必须计算所有可能的角色组合才能找到——或者至少多达15个角色，因为你现在知道有一个解决方案只有16个角色组合。</p><p id="4433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Combinatorics" rel="noopener ugc nofollow" target="_blank">组合学</a>来计算需要多少<a class="ae jd" href="https://en.wikipedia.org/wiki/Combination" rel="noopener ugc nofollow" target="_blank">组合</a>才能<em class="jw">潜在地</em>找到更好的答案——不排除任何角色——给我们1.187552 x 10个⁸组合。这是一个巨大的数字！通过排除485到39个角色的子集，组合的数量减少到大约540亿，以便找到多达15个角色的解决方案——这至少在可能的范围内。检查所有的组合需要一段时间，所以我编写了一个应用程序来完成这项工作。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="a3b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了一劳永逸地找到答案，我编写了一个命令行应用程序，使用强力方法尝试我们39个非子集角色中多达15个选择的每种可能组合。该应用程序在15停止，因为我们有一个贪婪算法的16个角色的解决方案。任何解决方案——如果有的话——都需要包含15个或更少。</p><p id="6d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">命令行应用程序分两步运行。首先，它产生每个可能的角色组合，并将这些组合写入磁盘。这一步被称为<em class="jw">生产者</em>阶段。接下来，在<em class="jw"> worker </em>阶段，为机器上的每个CPU核心启动一个进程，每个核心评估所有组合中的一部分，直到没有剩余。</p><p id="9ecd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了给每个进程提供最强大的CPU资源，我选择了计算优化的实例类型<a class="ae jd" href="https://cloud.google.com/compute/docs/machine-types#c2_machine_types" rel="noopener ugc nofollow" target="_blank"> c2-standard-60 </a>，提供了60个vcpu，因此有60个工作线程来分析组合，充分利用了实例的计算资源。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kq"><img src="../Images/3c42017107c6fdcdc4cccf04376ffac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mfVnSSOYmmSmdiGr"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">htop的屏幕截图，显示了计算实例在强行获取答案时CPU的全部利用率。</figcaption></figure><p id="7854" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行该生成器在不到9小时的总运行时间内产生了超过2tb的数据。60名工作人员对组合数据进行了超过28小时的处理，发现了8个解决方案，每个方案包含15个角色。这里有一个例子:</p><pre class="jl jm jn jo fd ka kb kc kd aw ke bi"><span id="3a4e" class="kf kg hi kb b fi kh ki l kj kk">roles/axt.admin<br/>roles/billing.admin<br/>roles/billing.creator<br/>roles/compute.xpnAdmin<br/>roles/container.hostServiceAgentUser<br/>roles/datacatalog.categoryFineGrainedReader<br/>roles/datafusion.serviceAgent<br/>roles/iam.securityAdmin<br/>roles/iam.serviceAccountTokenCreator<br/>roles/iap.httpsResourceAccessor<br/>roles/orgpolicy.policyAdmin<br/>roles/owner<br/>roles/remotebuildexecution.actionCacheWriter<br/>roles/resourcemanager.folderAdmin<br/>roles/resourcemanager.projectCreator</span></pre></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="9a28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管在技术上不正确，但贪婪算法很快(在数百毫秒内)产生了足够好的解决方案，我发现与一天半计算出来的绝对正确的答案相比，这是一个合理的权衡。</p><p id="be89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文中的代码和数据是<a class="ae jd" href="https://github.com/angstwad/set-cover-iam-roles" rel="noopener ugc nofollow" target="_blank">开源</a>。</p><p id="4d5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你选择使用这种算法来授予自己新的、无所不能的、无所不包的IAM权限，愿你非常小心地使用它们。在大多数情况下，这种访问级别不适合大多数组织。了解风险，认真执行IAM。</p></div></div>    
</body>
</html>