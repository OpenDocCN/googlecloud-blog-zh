<html>
<head>
<title>Cloud Run performances with multiple CPUs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有多个CPU的云运行性能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-run-performances-with-multiple-cpus-a4c2fccb5192?source=collection_archive---------0-----------------------#2020-10-09">https://medium.com/google-cloud/cloud-run-performances-with-multiple-cpus-a4c2fccb5192?source=collection_archive---------0-----------------------#2020-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/de5c6be328bcacca5c59f1999a02261a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-tUoWZm3l53TC674i1DuA.png"/></div></div></figure><p id="7c7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Cloud Run是一款<strong class="is hj">无服务器产品</strong>，允许<strong class="is hj">提供大规模</strong>的集装箱服务。<strong class="is hj">团队非常活跃</strong>，自Beta版发布(2019年4月)以来<strong class="is hj">新功能的数量令人印象深刻</strong>！其中，可配置的CPU数量。</p><p id="2a71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个或两个CPU的配置现已推出，<strong class="is hj"> 4也即将推出。</strong></p><blockquote class="jo"><p id="ebe8" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">但是，更多的CPU意味着更好的性能吗？</p></blockquote><h1 id="154c" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">如何测试多CPU处理性能？</h1><p id="bb52" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">要评估CPU效率，我们不能使用毫秒或微秒端点，这太难比较，指标不够清晰，标准偏差太重要。<br/>为了进行直观的比较，我们需要一个几秒钟就能完成的过程。</p><p id="8fe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lb">当然，快速请求的行为是相同的，结论也是相似的。</em></p><p id="a92c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，第一步是建立一个<strong class="is hj">计算密集型流程</strong>。对于这个测试，我选择在递归模式下使用<strong class="is hj">斐波那契算法</strong>。<em class="lb">在这里进去</em></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3d4e" class="ll jz hi lh b fi lm ln l lo lp">func fibo(n int64) int64 {<br/>   if n &lt;= 2 {<br/>      return n - 1<br/>   } else {<br/>      return fibo(n-1) + fibo(n-2)<br/>   }<br/>}</span></pre><p id="1041" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二步是拥有一个<strong class="is hj">多线程进程</strong>。</p><blockquote class="lq lr ls"><p id="0174" class="iq ir lb is b it iu iv iw ix iy iz ja lt jc jd je lu jg jh ji lv jk jl jm jn hb bi translated">为此，我会作弊！</p></blockquote><p id="261e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，云运行能够处理多达80个并发请求<a class="ae lw" href="https://cloud.google.com/run/docs/about-concurrency" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"/></a>。因此，如果您有一个单线程进程(如斐波那契算法),并且您同时向云运行发送2个请求</p><ul class=""><li id="248b" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">有了<strong class="is hj">和</strong>、<strong class="is hj">两个CPU，每个请求应该在一个单独的CPU </strong>上并行处理，并且花费大致相同的时间</li><li id="c10a" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">有了<strong class="is hj"> 1个CPU，这2个请求被同时处理并共享</strong>同一个CPU。处理时间应该比2个CPU配置的<strong class="is hj">长2倍。</strong></li></ul><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/5995240c59edc672d7aa3489b00e12b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3rd1qYPm0qyxoTji0HQ1A.png"/></div></div></figure><p id="5ce3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来验证这些假设！</p><h2 id="3af5" class="ll jz hi bd ka mm mn mo ke mp mq mr ki jb ms mt km jf mu mv kq jj mw mx ku my bi translated">基准原则</h2><p id="1cd6" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">为了得到斐波那契算法的处理持续时间，我简单地用<strong class="is hj">得到函数调用前后的时间，并计算差值。</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a838" class="ll jz hi lh b fi lm ln l lo lp">before := time.Now()<br/>result := fibo(n)<br/>after := time.Now()<br/><br/>diff := after.Sub(before)</span></pre><p id="f53e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了拥有相似的环境，当部署容器时，我总是在每个平台上使用2gb的内存(不受内存限制，只受CPU限制)</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="f0f7" class="jy jz hi bd ka kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv bi translated">TL；灾难恢复:完整的基准总结</h1><p id="8d6e" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">为了总结性能，这里有一张我用Fibonacci(43)测试过的所有不同配置的图表。<br/> <em class="lb">结果以秒为单位，越小越好。</em></p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/45306b83d477fb12fb58ff58c3fe36ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdnK5l43YED2Vs_xpDcVSQ.png"/></div></div><figcaption class="nm nn et er es no np bd b be z dx translated"><em class="nq">用Go容器处理时间以秒为单位。越小越好</em></figcaption></figure><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/ac41d8c67e3cec6e51fbc71e967d4139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_M3oQwDR1EIuwqrCrPR4ng.png"/></div></div><figcaption class="nm nn et er es no np bd b be z dx translated"><em class="nq">用Java容器处理时间以秒为单位。越小越好</em></figcaption></figure><p id="04ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lb">我已经包含了使用4个CPU对云运行进行早期访问的测试！</em></p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="57d1" class="jy jz hi bd ka kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv bi translated">云运行基准</h1><p id="6e2c" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我用两种语言写了这个基准:Go和Java  (springboot framework)。<em class="lb">关于脚本配置的详细信息，请参考</em> <code class="du nr ns nt lh b"><a class="ae lw" href="https://github.com/guillaumeblaquiere/multi-proc-bench/blob/master/readme.md" rel="noopener ugc nofollow" target="_blank"><em class="lb">readme.md</em></a></code> <em class="lb">文件。</em></p><ul class=""><li id="279a" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">从检查<a class="ae lw" href="https://github.com/guillaumeblaquiere/multi-proc-bench" rel="noopener ugc nofollow" target="_blank"> Github项目</a>开始</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7b34" class="ll jz hi lh b fi lm ln l lo lp">git clone <a class="ae lw" href="https://github.com/guillaumeblaquiere/multi-proc-bench.git" rel="noopener ugc nofollow" target="_blank">https://github.com/guillaumeblaquiere/multi-proc-bench.git</a></span></pre><ul class=""><li id="93a0" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">然后，进入您喜欢的目录语言(<code class="du nr ns nt lh b"><a class="ae lw" href="https://github.com/guillaumeblaquiere/multi-proc-bench/tree/master/springboot" rel="noopener ugc nofollow" target="_blank">springboot</a></code>用于Java，<code class="du nr ns nt lh b"><a class="ae lw" href="https://github.com/guillaumeblaquiere/multi-proc-bench/tree/master/go115" rel="noopener ugc nofollow" target="_blank">go115</a></code>用于go)并构建容器</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="42e1" class="ll jz hi lh b fi lm ln l lo lp">#Build locally (with docker)<br/>bash build-local.sh</span><span id="378d" class="ll jz hi lh b fi nu ln l lo lp">#Build on Cloud Build<br/>bash build-cloud.sh</span></pre><ul class=""><li id="082c" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">最后，运行工作台<em class="lb"> (4个请求同时发送给服务)</em></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2873" class="ll jz hi lh b fi lm ln l lo lp">#With 1 CPU<br/>bash bench-cloud-run.sh</span><span id="aca1" class="ll jz hi lh b fi nu ln l lo lp">#With 2 CPU<br/>NB_CPU=2 bash bench-cloud-run.sh</span></pre><p id="b4d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并比较结果:</p><ul class=""><li id="553a" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">1个CPU:平均处理时间约为<strong class="is hj">Go中9.7s(Java中6.7s)</strong></li><li id="71c1" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">2 CPU:平均处理时间约为<strong class="is hj">Go中4.6s(Java中2.9s)</strong></li></ul><h2 id="d2d7" class="ll jz hi bd ka mm mn mo ke mp mq mr ki jb ms mt km jf mu mv kq jj mw mx ku my bi translated">结果比较</h2><p id="3974" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">你可以观察到的第一件事是，在这个算法上，Java比Go快30%。</p><p id="59e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二件事是，使用2个CPU时，结果并不完全是使用1个CPU时的两倍(T20)，而是略高(Go中4.6s * 2 = 9.2s)。如果你了解CPU调度和线程管理，你就知道这是正常的。</p><p id="7428" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，由于4个请求同时出现在一个CPU上，<strong class="is hj">处理时间在线程之间共享，CPU必须在它们之间切换上下文</strong><em class="lb">(线程的备份状态，并恢复下一个线程的状态)</em>。这种操作在密集的CPU处理中是不自由的，并且您在每个交换机上损失了一些宝贵的CPU周期。<br/>2个CPU也是一样的事情，但是上下文切换发生的次数少了两次！</p><p id="b9bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lb">另外，可以看到</em><strong class="is hj"><em class="lb">CPU时间分配比较公平</em> </strong> <em class="lb">。请求处理持续时间相等，这意味着</em> <strong class="is hj"> <em class="lb"> CPU调度程序为每个线程分配相同的CPU插槽。</em> </strong></p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="8b98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，是的，<strong class="is hj">一个服务上更多的CPU允许你更快地处理请求</strong>，尤其是当你需要CPU计算能力的时候！</p><blockquote class="jo"><p id="0f0a" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">计算引擎上的性能有多相似？</p></blockquote><h1 id="0f45" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">计算引擎基准</h1><p id="3e94" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">有了现有的容器，现在<strong class="is hj">很容易在计算引擎</strong>上执行类似的基准测试。计算引擎基准测试有两个脚本:</p><ul class=""><li id="a9bb" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><code class="du nr ns nt lh b">bench-compute-engine.sh</code>使用<a class="ae lw" href="https://cloud.google.com/compute/docs/startupscript" rel="noopener ugc nofollow" target="_blank">启动脚本</a>和<a class="ae lw" href="https://cloud.google.com/container-optimized-os/docs" rel="noopener ugc nofollow" target="_blank"> COS </a>(容器优化操作系统)创建标准计算引擎</li><li id="2b4d" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated"><code class="du nr ns nt lh b">bench-compute-engine-with-container.sh</code>即使用了<code class="du nr ns nt lh b"><a class="ae lw" href="https://cloud.google.com/compute/docs/containers/deploying-containers" rel="noopener ugc nofollow" target="_blank">create-with-container</a></code>的<a class="ae lw" href="https://cloud.google.com/compute/docs/containers/deploying-containers" rel="noopener ugc nofollow" target="_blank">特性</a>，也在<a class="ae lw" href="https://cloud.google.com/container-optimized-os/docs" rel="noopener ugc nofollow" target="_blank"> COS </a>上。</li></ul><p id="43b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du nr ns nt lh b"><a class="ae lw" href="https://github.com/guillaumeblaquiere/multi-proc-bench/blob/master/readme.md" rel="noopener ugc nofollow" target="_blank">readme.md</a></code>文件中，您可以看到您可以<strong class="is hj">定制机器类型、要使用的CPU数量以及测试的位置</strong>。</p><ul class=""><li id="27d8" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated">对于<code class="du nr ns nt lh b">n1</code>和<code class="du nr ns nt lh b">e2</code>机型，<strong class="is hj">位置可以改变基准结果</strong>。比如<a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank"> </a> <code class="du nr ns nt lh b"><a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank">n1</a></code> <a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank">可以是Intel Haswell或者Intel Skylake CPU架构</a>，<strong class="is hj">这几代效率不同</strong>。</li><li id="e47f" class="lx ly hi is b it mg ix mh jb mi jf mj jj mk jn mc md me mf bi translated">有些机种<strong class="is hj">至少需要2个(</strong> <code class="du nr ns nt lh b"><strong class="is hj">n2</strong></code> <strong class="is hj">、</strong> <code class="du nr ns nt lh b"><strong class="is hj">e2</strong></code> <strong class="is hj">、</strong> <code class="du nr ns nt lh b"><strong class="is hj">n2d</strong></code> <strong class="is hj">)或4个(</strong><code class="du nr ns nt lh b"><strong class="is hj">c2</strong></code><strong class="is hj">)CPU</strong>。小心，如果你改变机器类型，使用正确的CPU数量。<em class="lb">您可以使用</em> <code class="du nr ns nt lh b"><em class="lb">LIMIT_CPU</em></code> <em class="lb">参数限制docker run命令使用的CPU数量。</em></li></ul><h2 id="9ba4" class="ll jz hi bd ka mm mn mo ke mp mq mr ki jb ms mt km jf mu mv kq jj mw mx ku my bi translated">结果比较</h2><p id="ed49" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我只展示了在 <code class="du nr ns nt lh b"><strong class="is hj">us-central1-a</strong></code> <strong class="is hj">区域中使用2个CPU和使用Go </strong>容器<em class="lb">进行的<strong class="is hj">测试(使用2个CPU在云上运行的处理时间为4.6秒)</strong></em></p><ul class=""><li id="a6e9" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><code class="du nr ns nt lh b">n1</code>机器类型(Haswell):平均响应时间<strong class="is hj"> 8s </strong></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9b0c" class="ll jz hi lh b fi lm ln l lo lp">MACHINE_TYPE=n1 NB_CPU=2 LIMIT_CPU=2 bash bench-compute-engine.sh</span></pre><ul class=""><li id="17ed" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><code class="du nr ns nt lh b">n2</code>机器类型:平均响应时间<strong class="is hj"> 6s </strong></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6d46" class="ll jz hi lh b fi lm ln l lo lp">MACHINE_TYPE=n2 NB_CPU=2 LIMIT_CPU=2 bash bench-compute-engine.sh</span></pre><ul class=""><li id="5201" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><code class="du nr ns nt lh b">e2</code>机器类型:平均响应时间<strong class="is hj"> 7.3s </strong></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0c9f" class="ll jz hi lh b fi lm ln l lo lp">MACHINE_TYPE=e2 NB_CPU=2 LIMIT_CPU=2 bash bench-compute-engine.sh</span></pre><ul class=""><li id="e38e" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><code class="du nr ns nt lh b">n2d</code>机器类型:平均响应时间7 <strong class="is hj">秒</strong></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0611" class="ll jz hi lh b fi lm ln l lo lp">MACHINE_TYPE=n2d NB_CPU=2 LIMIT_CPU=2 bash bench-compute-engine.sh</span></pre><ul class=""><li id="4345" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><code class="du nr ns nt lh b">c2</code>机器类型(4个CPU，最多2个):平均响应时间<strong class="is hj"> 5.2s </strong></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e752" class="ll jz hi lh b fi lm ln l lo lp">MACHINE_TYPE=c2 NB_CPU=4 LIMIT_CPU=2 bash bench-compute-engine.sh</span></pre></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="cfb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很明显，你可以看到云运行的<strong class="is hj">性能与计算引擎</strong>相当。它们类似于<code class="du nr ns nt lh b">c2</code>(计算密集型)机器类型。<br/> <em class="lb">这些</em> <strong class="is hj"> <em class="lb">的观察结果与Java版本</em> </strong> <em class="lb">中的相同。你们可以自测一下！</em></p><blockquote class="jo"><p id="bd91" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">我可以将云运行性能与本地环境进行比较吗？</p></blockquote><h1 id="d2c7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">当地环境基准</h1><p id="b7b2" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated"><em class="lb">对于这个测试，你需要</em> <strong class="is hj"> <em class="lb">在你的电脑上安装Docker</em></strong><em class="lb">。<br/> </em>用最新的剧本就地替补。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="95d9" class="ll jz hi lh b fi lm ln l lo lp">LIMIT_CPU=2 bash bench-local.sh</span></pre><p id="0c84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的电脑上，限2个CPU，处理时间是<strong class="is hj"> 4s。</strong></p><h2 id="bddd" class="ll jz hi bd ka mm mn mo ke mp mq mr ki jb ms mt km jf mu mv kq jj mw mx ku my bi translated">局部基准陷阱</h2><p id="6caa" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">在我的例子中，<strong class="is hj">我限制了CPU的数量，以在我的计算机上拥有类似于</strong>的云，并且<strong class="is hj">仍然更快！！</strong> <br/>所以，是的，我限制了CPU的数量，但是<strong class="is hj">没有</strong>的CPU的威力，而影响，在CPU密集型处理中，是非常重要的！</p><p id="43dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我电脑上有一个英特尔酷睿i5 6600 (4核/4线程，@3.3Ghz- <strong class="is hj"> 3.9Ghz </strong> (turbo)，Skylake架构)，处理时间是<strong class="is hj"> 4s。</strong><br/><a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank"/><code class="du nr ns nt lh b"><a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank">n1</a></code><a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank">has well机种有<strong class="is hj"> 2.3Ghz </strong> CPU </a>，处理时间为<strong class="is hj"> 8s </strong>，但架构较老。<br/>我在<code class="du nr ns nt lh b">europe-north1-a</code>用<code class="du nr ns nt lh b">n1</code>机种测试。这次的CPU架构是<a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank"> Skylake在<strong class="is hj">2 GHz</strong>T23】。而且台架成绩是<strong class="is hj"> 8s也是</strong>。</a></p><p id="3c74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我限制我的CPU的速度(2 / 3.3Ghz - &gt; 60%)，我得到了相同的结果。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es nv"><img src="../Images/573b92f4eaf0645ffb71dee2cf9a7d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*qIUtsZfXvWfZI4KTk8w_Xg.png"/></div><figcaption class="nm nn et er es no np bd b be z dx translated">Windows 10上的电源管理可限制CPU速度</figcaption></figure><p id="fc90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">整组结果与</strong>每秒的周期数和CPU架构生成一致。<br/>因此，<strong class="is hj">在本地环境中运行性能测试时要小心</strong>！</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="d963" class="jy jz hi bd ka kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr nk kt ku kv bi translated">CPU越多是否意味着能力越强？</h1><p id="cfa2" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">第一个结果<strong class="is hj">展示了并行性的前景</strong>。有了几个CPU，您可以并行处理几个请求并改善响应时间。<br/>对于所有服务、计算引擎和云运行来说都是<strong class="is hj">真。</strong></p><p id="4b10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">除了CPU的数量，CPU的功率和代数也很重要</strong>。对我来说，最令人惊讶的结果是，<strong class="is hj">云运行的性能比一个</strong> <code class="du nr ns nt lh b"><strong class="is hj">c2</strong></code> <strong class="is hj"> </strong>机器类型(计算密集型<a class="ae lw" href="https://cloud.google.com/compute/docs/cpu-platforms" rel="noopener ugc nofollow" target="_blank">级联湖架构，3.1Ghz </a>)比一个常规计算引擎(<code class="du nr ns nt lh b">n1</code>或<code class="du nr ns nt lh b">n2</code>机器类型)更接近</p><p id="0075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总之，如果您有由请求触发的<strong class="is hj">计算密集型处理</strong>(例如ML处理)，<strong class="is hj">云运行是很好的解决方案</strong>，具有高效的处理和多CPU能力。<br/>现在每个实例有1或2个CPU可用，不久<strong class="is hj">将有4个CPU可用于所有</strong>(目前仅用于Alpha测试人员)。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="b190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请告诉我您在这些平台上尝试的基准测试结果或其他处理类型！</p></div></div>    
</body>
</html>