<html>
<head>
<title>How We Implemented a Fully Serverless Recommender System Using GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何使用GCP实现一个完全无服务器的推荐系统</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-we-implemented-a-fully-serverless-recommender-system-using-gcp-9c9fbbdc46cc?source=collection_archive---------0-----------------------#2017-12-12">https://medium.com/google-cloud/how-we-implemented-a-fully-serverless-recommender-system-using-gcp-9c9fbbdc46cc?source=collection_archive---------0-----------------------#2017-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f59b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就在最近，我们公司面临着一个非常令人兴奋的挑战，我想借此机会写下这个挑战以及我们在这个过程中学到的东西。</p><p id="bcb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的主要目标是与我们在<a class="ae jd" href="http://global-fashion-group.com/" rel="noopener ugc nofollow" target="_blank"> GFG集团</a>的核心团队合作，为我们的不同企业开发一个能够与我们的客户有效互动的推荐系统，只有一个条件:它应该建立在<a class="ae jd" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache-Spark </a>之上；原因是该团队已经掌握了Spark系统及其在生产环境中的管理的专业知识。</p><p id="2e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，在这篇文章中，我想写一下我们实现了什么。我们有两个月的时间来实现一些东西，最终的解决方案是建立在谷歌云平台(GCP)之上的一个完全无服务器的系统。</p><p id="4727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终实现的算法被称为“DIMSUM ”,也是Twitter目前运行的算法。以下是我们将在本帖中讨论的已实现架构的概述:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ac6640dc4e19822b492ea09472ffbfc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axNxklrne21SY_N6pyXp-w.png"/></div></div></figure><p id="55b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之:AppEngine编排调用(由crons触发),将数据加载到我们的云存储中，构建Dataproc集群，处理我们的主算法，再次将结果保存到存储中，最后我们有一个数据流管道执行，将结果加载到数据存储中，以便Appengine可以直接访问并向我们的客户提供建议。</p><p id="4171" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，这是相当地狱的坚果壳。</p><p id="1447" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在不要担心所有这些操作，请注意，我们有不同的颜色连接不同的元素，这些将单独讨论，因为它们构成了我们系统的主要模块。本帖涵盖的主题将是:</p><ol class=""><li id="1426" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">理解算法</li><li id="cb1e" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">获取数据</li><li id="786d" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">AppEngine中的Cron作业</li><li id="c8ec" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">Dataproc执行</li><li id="efba" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">具有数据流的流水线过程</li><li id="fb63" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">提出建议</li><li id="2d25" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">成本估算</li><li id="d48a" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">未来的工作</li><li id="3edd" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">结论</li></ol><p id="17a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事不宜迟，我们走吧！</p><h1 id="f6d5" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">1.理解算法(DIMSUM)</h1><p id="7905" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我们的第一个方法是尝试实现<a class="ae jd" href="http://yifanhu.net/PUB/cf.pdf" rel="noopener ugc nofollow" target="_blank">邻域算法</a>，这是一个非常成功的实现，在推荐系统文献中非常流行，特别是在<a class="ae jd" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>领域。</p><p id="2d9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的工作原理基本上是找到不同项目之间的相似性分数(这里的项目可以是产品、客户、音乐，任何可以提取元素之间某种相关性的东西)，并使用这些分数来预测客户对每个项目的喜爱程度。</p><p id="5824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在电子商务中，在很大程度上，我们并不确切知道一个给定的客户是否喜欢某个商品；这意味着我们所能做的就是计算来自客户的一般交互，例如“他或她访问该产品多少次？他把这个放进篮子里了吗？她买了吗？如果是这样的话，我们会尝试添加一些值来表示对该特定项目的某种喜爱感，尽管这可能是隐含的，但我们仍然会尝试从这些行为中提取信号。</p><p id="fa90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更清楚地说，假设我们观察了4个客户以及他们与2个不同产品的交互(1表示客户浏览了产品页面):</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lh"><img src="../Images/b0cd6c03b891d64cc5c6c5aa454305c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*kDtbdE5olB81in5lrDICQQ.png"/></div></figure><p id="dca3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找出这两只鞋之间的相关性，我们使用由以下公式给出的余弦相似性:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es li"><img src="../Images/a470b52489d521129389e30198b9a59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*IPV2VURSJG13NAa4-N7Blw.png"/></div></figure><p id="dc31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个等式说的是，相似性度量是每个客户的产品之间的交集的总和，通过这些交互来标准化。</p><p id="5176" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，如果每个客户都与这两种产品交互，那么结果将正好是1，这意味着这两种产品100%相似。喜欢一种产品的顾客会同样喜欢另一种产品；如果他们只与其中一个SKU交互，而不与另一个SKU交互，那么最终结果将是0，这导致了一个概念，即如果客户喜欢一个SKU，就不能期望他或她会喜欢另一个SKU。</p><p id="07f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前面的示例中，我们有:</p><p id="1850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> A </strong> = [1，0，1，1]；<strong class="ih hj"> B </strong> = [0，0，1，1]</p><p id="d488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用相似性得分等式，我们得到:</p><p id="7357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj">相似度</em>=(1 * 0+0 * 0+1 * 1+1 * 1)/√( 1+0+1+1)* √( 0+0+1+1)≈0.82</p><p id="3274" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，这实际上是对产品之间的交集的提取，由该产品上的所有值进行标准化。</p><p id="5f09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些相似性分数，我们就可以预测顾客会有多喜欢那些看起来不那么遥远的商品。让我们以之前的例子为例:如果我们知道红色鞋子和米色鞋子的相似度是82%，假设我们知道一位顾客喜欢其中一款；我们可以推断，鉴于他们的相似性得分，他有82%的可能性会喜欢对方。我们可以用数学方法表达对新项目进行预测的概念:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lk"><img src="../Images/165cbf21afe3a9ba688fe9854420491b.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*jAXRKAqL8RGlF2fcxf61iQ.png"/></div></figure><p id="f90e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候介绍一些符号了:在上面的等式中，“u”标识我们网站上的一个给定客户；“I”和“j”是项目的标识符,“r”是一个度量，它告诉我们用户<em class="lj"> u </em>如何与项目交互，所以在我们之前的示例中，它是1和0。“s”是我们刚刚计算的相似性，因此“s_ij”是项目“I”与“j”之间的相似性(在我们的示例中，“I”可能是红色的鞋子，“j”可能是米色的鞋子)。</p><p id="7f0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以所有的公式都在说:为了预测用户“u”会有多喜欢项目“I”，由带有“^”符号的“r”表示，我们观察他或她与之交互的所有项目；我们观察这些和我们想要预测的那个之间的相似性，将所有的相互作用乘以相似性，然后将所有的事情加起来(除法是一种使方程标准化的方法，在实践中我们并不像文献中建议的那样应用它)。我知道这听起来令人困惑，但鉴于一张图片胜过千言万语，以下是对其工作原理的描述:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ll"><img src="../Images/8aa3acfa2b12f81c6abb1ee9050a68d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGNfIt4q9lK588AQE_eMhg.png"/></div></div></figure><p id="b1ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们的客户与第一个sku互动了“1.5”分，与第二个SKU互动了2分，与第三个SKU互动了2.5分。那些相同的产品和我们想要预测的产品之间的相似度分别是56%，21%和67%。因此，为了预测这位顾客对第四件产品的喜爱程度，我们将我们了解的顾客的每个sku的互动和相似性相乘，将所有东西相加，并通过相似性得分标准化，结果为2.42。这是我们预测顾客会喜欢这件商品的程度。</p><p id="2449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">差不多就是这样了！总之，neighborhood观察客户和商品的所有互动，并提取它们之间的相似性指标，这使我们能够预测客户将如何喜欢新商品。</p><p id="1f8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但有一个问题，这就是挑战的开始:在达菲提(GFG的一家合资企业)，我们每天都有数百万客户访问我们的网站，他们可能会与其他数十万种可用产品进行互动。</p><p id="ab37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你利用Dafiti的数据，试图找到客户和商品的所有互动，然后试图建立所有产品之间的所有相似性，你会发现你的计算机/集群在几秒钟后爆炸并燃烧成火焰。如果你在某个共享集群中这样做，确保尽快离开大楼(在这样做之前删除数码照片*)。</p><p id="56de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实证明，有更聪明的方法可以做到这一点，这就是我们开始在挑战中取得一些重大进展的地方。</p><h2 id="5e5a" class="lm kf hi bd kg ln lo lp kk lq lr ls ko iq lt lu ks iu lv lw kw iy lx ly la lz bi translated">1.1 dim sum方法</h2><p id="edfc" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">由于使用Spark是这个项目的强制要求，我们寻找如何以MapReduce方式实现余弦计算的方法；我们发现，该框架基本上是一个步骤管道，您可以将输入值映射到新值，并减少它(如果您需要的话)以将结果聚合到某个最终指标中。因此，主要思想是:应用映射来转换数据，如果你需要一些聚合(你通常这样做)，然后使用一些减少操作。</p><p id="e0c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你仔细思考，你会发现在MapReduce框架中实现某种邻域方法其实很简单:我们有训练数据，其中包含用户及其与产品的交互(我们将在后面详细讨论)，所以我们可以这样安排:</p><pre class="jf jg jh ji fd ma mb mc md aw me bi"><span id="7b52" class="lm kf hi mb b fi mf mg l mh mi">{“user”: “user_0”, “items”: [{“sku”: “sku_0”, “r”: 1},<br/>                             {“sku”: “sku_1”, “r”: 2}]}<br/>{“user”: “user_1”, “items”: [{“sku”: “sku_0”, “r”: 2},<br/>                             {“sku”: “sku_2”, “r”: 1}]}</span><span id="422d" class="lm kf hi mb b fi mj mg l mh mi">(...)</span><span id="ad94" class="lm kf hi mb b fi mj mg l mh mi">{“user”: “user_m”, “items”: [{“sku”: “sku_0”, “r”: 2},<br/>                             {“sku”: “sku_n”, “r”: 1}]}</span></pre><p id="891f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，我们可以将它安排给<em class="lj"> m </em>个用户和他们潜在的<em class="lj"> n </em>个条目的交互(请记住，我们不保存“零”值，因为这会不必要地消耗大量内存)。</p><p id="b09b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于余弦指标在客户层面上寻找产品之间的相关性(如果客户与两个项目都有交互，那么它们的交集就会增加)，我们可以使用这个简单的算法来提取相似性:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mk"><img src="../Images/df7e92476ad9f5d3543ef35eaac3a5e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*DlaWO0yR3UGrxbE2roOtzg.png"/></div></figure><p id="8346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，该算法没有提取余弦相似度，因为它没有按照每个sku交互向量的规范进行归一化；在实践中，我们仍然需要进行这种规范化(这非常简单，我们将向您展示我们是如何做到的)。视觉上，大概是这样的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ml"><img src="../Images/deb751b92180267ace4958b392dc5ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*2xxu6CgUdqC_pi8Sli83Hg.png"/></div></figure><p id="3239" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个客户，我们有两个“For ”,对应于每个“ai”和“aj ”,我们通过向量发射ai * aj进行扫描。</p><p id="c2ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从<a class="ae jd" href="https://stanford.edu/~rezab/papers/dimsum.pdf" rel="noopener ugc nofollow" target="_blank">雷扎·扎德讨论Twitter上DIMSUM实现的论文</a>中获得了这个算法(这是一篇非常令人惊讶的文章，如果你是一名数据科学家或者喜欢计算机科学的这个领域，我强烈推荐这本书，它当然值得一读)。</p><p id="2f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，这个算法被称为“NaiveMapper”(理由很充分)。对于代表一个客户的每一行，我们在所有项目之间做一个叉积。比方说，一个给定的客户与skus 0、1和2交互；我们最终可能会得到(只是一个例子，数字是随机写的):</p><p id="4faa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[((sku0，sku0)，1)，<br/> ((sku0，sku1)，2)，<br/> ((sku0，sku2)，0)，<br/> ((sku1，sku0)，2)，<br/> ((sku1，sku1)，2)，<br/> ((sku1，sku2)，1)，<br/> ((sku2，sku0)，0)，<br/> ((sku2，sku1)，1)，<br/> ((sku2，sku2)，1)]</p><p id="ee90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为每个客户提取所有这些相关性的步骤是我们的映射阶段(或"<em class="lj">洗牌阶段"</em>)，其BigO是<em class="lj">O</em>(mL)(“L”是客户在我们整个训练集中的最大交互次数)。好吧，如果你是一个开发者，你肯定已经知道当我们在waaaaateeeer上有<em class="lj">O</em>(n):smoooke时会发生什么…</p><p id="cfd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不太好。不一定不可行，但主要不是…酷。正如在达菲提<em class="lj"> L </em>可能有数千个SKU，而<em class="lj"> m </em>是数百万个，你看我们手中的问题。嗯，DIMSUM是通过实现这个新算法将这个问题分解成一个更容易处理的问题的方法:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mm"><img src="../Images/127bf1cd154d4e76f4462b6543ee2d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/0*KmpoikBn3rVp-3SZ."/></div></figure><p id="29b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个相同的想法，但有一个聪明的变化:现在我们有了这个标量“γ”,它作为洗牌阶段相关性发射的采样率。但这不仅仅是添加一个简单的标量和“瞧”，它已经完成了！我们需要一些严格的数学分析来理解进行这种采样的利弊！</p><p id="bc04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我将花时间进一步解释它是如何工作的，但下一个小型会议是完全“可以跳过”的。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="dabc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(我会完全遵循雷扎布的纸上批注)。正如我们已经讨论过的，假设<strong class="ih hj"> A </strong>是一个矩阵，它的行是客户，列是产品，每个单元格中的值对应于某种隐含的度量，即我们的客户对某个给定商品的喜爱程度(比如说，他每浏览一个产品，我们就加1分)。</p><p id="f528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，对于每一行，我们迭代所有产品交互，构建组合并将这些值发送到Reduce阶段。既然我们有了排放的取样率，那么它必须适用于每个交叉路口:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mu"><img src="../Images/1dd06fb78fba92cbabfe63c54918004b.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*qwP0TOf-DaoQep2AYP8T1A.png"/></div></figure><p id="1c96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mv"><img src="../Images/7bee14a4e767e5a64c2bafb50eeb606f.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*pAvtxnyipG_wQM2OVDtiYg.png"/></div></figure><p id="f9ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">「‖ci‖」是乘积向量「I」的范数。这意味着一个产品的交互越多，我们就越不可能释放它的价值；原因是我们已经有了很多关于它的信息，所以我们可以发出少一点的信息，并且仍然在有限的误差内收敛到真正的相似性值。</p><p id="32d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> X </strong>是一个<a class="ae jd" href="https://www.khanacademy.org/math/statistics-probability/random-variables-stats-library/random-variables-discrete/v/random-variables" rel="noopener ugc nofollow" target="_blank">随机变量</a>，因为它现在遵循一个概率分布，并且最终的相似性得分是这些X的归一化总和，这给出了我们:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mw"><img src="../Images/b5f76d8845f5770e5bff45e9e3b5132d.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*YV6tWstZ9RjlL7dw1YzAVw.png"/></div></figure><p id="dc35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，我承认，我只是不明白“γ”是从哪里来的；事实证明，这很简单:相似性是由每个乘积向量的范数归一化的“X”的总和(正如我们在本文开始时讨论的)。但是假设我们以一个给定的概率发出这些值，期望值也会乘以这个概率。</p><p id="57fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，如果我们不对这种影响进行校正，我们最终会得到类似“p *相似性”的结果。在这种情况下，我们需要除以“p ”,以便期望值收敛到真实值。但是考虑到我们的概率公式，如果我们将余弦除以“p ”,我们就抵消了SKU的范数,“γ”将保留在分母中。</p><p id="262a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以推导如下:如果γ=ω(n/ε)(即，采样率与训练数据中的乘积量除以真实值和估计值之间的预期相对误差的平方成比例)，则:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mx"><img src="../Images/b1df4758072ab17246f39e447a23b685.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*WHJ1R_QNSJcl9fdqKj4ogw.png"/></div></figure><p id="f412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至少有50%的可能性。<strong class="ih hj"> B </strong>是我们的相似矩阵，而<strong class="ih hj"> D </strong>是一个对角矩阵，其对角线上的每个值都是相应产品的范数。这种推导有些广泛，我们在这里就不赘述了，但本文对每一步都有详尽的推导。</p><p id="942b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个公式还使我们得出以下结论:如果对于给定的α ∈ ℝ，γ ≥ α/ε，则:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es my"><img src="../Images/576739ac175ee66f737617cb8fb1b560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*zp82Al2mGPAyTD3DrC6nxw.png"/></div></figure><p id="5815" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mz"><img src="../Images/0cc303b9fdf97cebe183c15fe0d7c685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*emxrbsUujsFy-9fjDhLqEg.png"/></div></figure><p id="d396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了我们一个上限和下限，在给定γ值的情况下，我们的计算可能会有多大的误差。对于给定的有界误差ε，α越大，计算值与真实值相差太远的可能性越低。</p><p id="9216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一切的美妙之处在于:我们的洗牌阶段最终得到了<em class="lj"> O </em> (nLγ/H)，其中“H”是在我们将其缩放到0和1之间之后<strong class="ih hj"> A </strong>中最小的非零条目。</p><p id="ed48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是该算法被称为“DIMSUM”的原因，它使用MapReduce 扩展为“<strong class="ih hj">维度独立矩阵平方”:请注意，以前，该值是<em class="lj"> O </em> (mL)，现在它与我们的训练数据中有多少客户完全无关！“m”消失了，现在我们基本上有了一个线性的<em class="lj"> O </em>，它允许我们处理大量的数据，构建我们的相似性矩阵，并在一定程度上保证获得的值在给定的边界内收敛到真实值。</strong></p><p id="e5c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Reduce阶段只是一个求和阶段，因此这里的最佳策略是避免向该阶段发出太多值。</p><p id="c298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这足够好地介绍了我们如何使用MapReduce框架计算这些算法。这背后肯定有一些繁重的数学计算，但它仍然允许我们尽可能有效地在矩阵上进行各种线性代数运算，给定我们要权衡的有界误差。</p><p id="b4c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，变化如下:还记得我们之前关于每个客户排放的例子吗？如果我们举同样的例子，现在用DIMSUM，我们可能会得到这样的结果:</p><p id="5f26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[((sku0，sku0)，1)，<br/>，<br/> ((sku0，sku2)，0)，<br/>，<br/>，<br/> ((sku1，sku2)，1)，<br/> ((sku2，sku0)，0)，<br/>，<br/> ((sku2，sku2)，1)]</p><p id="5ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺失的值不再被发出，因为现在我们有了发出每个相关的概率。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="8201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实现算法时，我们将对映射阶段做一个小的调整，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es na"><img src="../Images/1cbb6af5f1f84e38ea5774429d95b658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*ai6VwHZrmNuSu3M4GHtf_Q.png"/></div></figure><p id="0877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不仅减少了排放，而且减少了所需的计算，因为只有在采样方案中接受了第一“aij”时才计算第二“aik”。</p><p id="8aa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">差不多就是这样了！我们基本上需要为每个客户提取产品之间的相关性，但在大数据中这样做在很大程度上是不可行的。因此，我们使用采样技术将<em class="lj"> O </em>带到更低的值范围，这样我们就可以对数据执行各种线性代数运算。</p><p id="45a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，我们已经准备好开始实施DIMSUM了！</p><p id="a9fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有点…</p><p id="1dad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们仍然需要数据来支持算法！数据是新的黄金，所以…让我们挖掘它！</p><h1 id="24a1" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">2.给我看看数据</h1><p id="ec52" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">这就是我们现在要讨论的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nb"><img src="../Images/8486fe97b541bdbbbe6a5a26b2559c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kaQ0VibMjNMxBCf2SghsMw.png"/></div></div></figure><p id="e4eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用来实现无服务器应用的第一批工具是AppEngine、BigQuery和云存储。</p><p id="96e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/products/big-data/?hl=pt-br&amp;utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=latam-BR-all-pt-dr-bkws-all-all-trial-b-latam-1002243-LUAC0000358&amp;utm_content=text-ad-none-any-DEV_c-CRE_204833483167-ADGP_BKWS+%7C+Multi+~+Bigquery+Google-KWID_43700022301561115-kwd-302438885959-userloc_1001773&amp;utm_term=KW_%2Bbigquery%20%2Bgoogle-ST_%2Bbigquery+%2Bgoogle&amp;dclid=CL_tiJTPgNgCFQcchwodeagASQ" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>基本上是一个数据库新概念的天才实现，旨在尽可能轻松地处理大数据。没有索引，也没有任何基础设施需要你去照顾。你只需将数据加载到那里，它就会处理你需要的一切，按需、即时、超赞。</p><p id="b2a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用BQ将我们的数据从<a class="ae jd" href="https://support.google.com/analytics/answer/3437719?hl=en" rel="noopener ugc nofollow" target="_blank"> Google Analytics </a>转换成一种我们在Spark中的算法可以处理的格式；当我们与GFG的中心团队合作时，我们使用了与他们相同的生产环境输入模式。以下是我们为算法提供的数据示例:</p><pre class="jf jg jh ji fd ma mb mc md aw me bi"><span id="98b5" class="lm kf hi mb b fi mf mg l mh mi">user,productSku,type<br/>95106786645166913,AG672APF78UCF,1<br/>8897887309145128270,FI911APF10HUZ,2<br/>1153521620412862249,CO515APM42GTT,2<br/>1819629928011287314,FI911SHM06PUF,1<br/>1133082218947946503,JO546APM50KFT,3</span></pre><p id="aa28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要指出的几点:还记得我们之前的讨论吗，我们跟踪顾客的信号来间接推断给定顾客对给定商品的喜爱程度？所以，我们是这样做的:“1”表示客户浏览了给定的产品；“2”产品被添加到购物篮，最后“3”:产品被购买。</p><p id="1dfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们推断用户<code class="du nc nd ne mb b">95106786645166913</code>浏览了产品<code class="du nc nd ne mb b">AG672APF78UCF</code>，用户<code class="du nc nd ne mb b">8897...</code>将<code class="du nc nd ne mb b">FI911APF10HUZ</code>添加到购物篮，等等。</p><p id="5699" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，这对我们来说只是一个提示。顾客浏览一件商品并不意味着他或她喜欢它。但这也是我们不想摆脱的一个隐含信号；如果同一个顾客将同样的商品添加到购物篮中，我们就有了比“浏览”更有意义的东西，购买也是如此。请注意，顾客购买产品并不意味着他或她喜欢它。也许这是给别人的礼物，也许他后来归还了物品，也许他很着急，不得不先买他发现的东西...这是我们运行来提取这些值的查询:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="d5a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止一切顺利！但是如果我们想要一个无服务器的解决方案，我们需要自动触发这个查询的执行，而不需要运行cron服务的机器。</p><p id="755f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<a class="ae jd" href="https://console.cloud.google.com/appengine?src=ac" rel="noopener ugc nofollow" target="_blank"> AppEngine </a>发挥作用的地方。</p><h1 id="adf2" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">3.保佑克朗斯</h1><p id="bdd9" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">简单地说，Google AppEngine是一个<a class="ae jd" href="http://wsgi.readthedocs.io/en/latest/what.html" rel="noopener ugc nofollow" target="_blank">的无服务器WSGI </a>服务器，你可以在那里上传路线、相关功能和指令规则；只需构建与每条路由相关的代码，并部署到GAE，它就会工作:自动缩放、流量分配、日志记录、身份验证、memcache和许多其他功能。</p><p id="2e1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想现在就向你们展示一个例子，它是我们为管理crons而部署的代码之一，我们很快就会谈到。这就是我们的<strong class="ih hj"> main.py </strong>服务:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="3448" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意这是一个指定了一个路由规则的<a class="ae jd" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Flask </a>应用程序:对于具有模式为<code class="du nc nd ne mb b">/run_job/job_name/</code>的URL的请求，将触发<code class="du nc nd ne mb b">run_job()</code>函数(稍后我们将在GCP调度我们的任务)。这基本上是您部署到GAE的代码，它会处理其余的事情。</p><p id="4368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你阅读GAE文档，你会注意到有两种类型的环境可以上传你的代码:标准与灵活。</p><p id="62a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主要区别是:Standard运行在一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Sandbox_(software_development)" rel="noopener ugc nofollow" target="_blank">沙盒</a>环境中，该环境阻止了一些事情，例如运行用户C代码、多线程/处理、写入磁盘等等。你得到的回报是缩减到零台机器的可能性，以及一套只在这个选项中可用的工具，如<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/ndb/" rel="noopener ugc nofollow" target="_blank"> NDB </a>库(由BDFL·吉多·范·罗森设计)。</p><p id="ba54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，Flexible Environment接收一个Docker映像，您可以在其中公开一个端口，将流量路由到一个内部WSGI服务器(对于Python，<a class="ae jd" href="http://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> gunicorn </a>非常流行，将在本文后面使用),这保证您可以安装几乎任何东西。这种灵活性的缺点是为自动伸缩创建一个新的实例更加耗时，而且由于这一点，始终至少有一台机器在运行，也就是说，在这个选项中，您不能将实例缩减到零。</p><p id="f1cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们使用的一个好的经验法则是:如果我们正在设计的东西会有长时间的不活动(没有请求),那么我们使用标准；如果需要更高级的编码(比如多重处理和基于C的处理)并且总是不停地接收请求，那么就用Flexible。</p><p id="2653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，您可能会问:“这与我们能够为BigQuery中的查询运行cron作业有什么关系”？</p><p id="f7ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">别担心。我们来谈谈这个吧！</p><p id="7606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们现在要讨论的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nh"><img src="../Images/1a9a17a1113f29fe923fa9ad2cc9a00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozaycfRcwnGjn6rSeS3Z4w.png"/></div></div></figure><p id="ce1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GAE拥有对无服务器CRON触发器的本地支持。您所要做的就是指定一个将接收GET请求的URL，然后在该URL中编写您需要的任何代码。您必须部署一个指定路线和规则的<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/config/cronref" rel="noopener ugc nofollow" target="_blank"> cron.yaml </a>文件；这里有一个来自官方文件的例子:</p><pre class="jf jg jh ji fd ma mb mc md aw me bi"><span id="525b" class="lm kf hi mb b fi mf mg l mh mi">#cron.yaml<br/>cron:<br/>- description: "daily summary job"<br/>  url: /tasks/summary<br/>  schedule: every 24 hours</span></pre><p id="80ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着每24小时就会向URL <code class="du nc nd ne mb b">/tasks/summary.</code>发出一个GET请求</p><p id="d51c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GAE有一个重要的要求:请求必须在60秒的时间内完成，否则你将不得不安排操作加入一个<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/taskqueue/" rel="noopener ugc nofollow" target="_blank">队列</a>，并且任务将作为一个后台任务处理，在输入请求之外。</p><p id="1841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望我们的cron在BigQuery中运行查询，然后将结果导出到GCS这可能需要60秒以上的时间，因此我们为cron创建了一个<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/taskqueue/" rel="noopener ugc nofollow" target="_blank">调度器</a>，以便在指定的时间触发发生时启动。</p><p id="35e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，接下来发生的事情是:我们的cron向我们的主路由器发出一个GET，然后主路由器向我们的调度器添加一个任务，调度器由(在本例中，我们使用了<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/" rel="noopener ugc nofollow" target="_blank">推送队列</a>的概念):</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="56f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们有:一个cron向<code class="du nc nd ne mb b">/run_job/job_name</code>发出一个GET请求，它依次向我们的任务队列添加一个与URL <code class="du nc nd ne mb b">/export_customers</code>相关联的作业，该作业依次运行我们的查询和提取操作。天哪，真让人困惑！也许一张照片会有所帮助:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ni"><img src="../Images/8608a2f0c85759057a40ccdf611ac6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkowJRk8EaIsFu80sqVdiA.png"/></div></div></figure><p id="ca26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的主要服务由这个<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/config/appref" rel="noopener ugc nofollow" target="_blank"> yaml </a>文件定义:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="b7a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们关于标准与灵活的讨论发挥作用的地方:我们不需要那些机器一直运行。仅当他们正在处理计划任务时；如果我们没有在这个ymal文件中指定环境，那么默认情况下会部署standard。</p><p id="f5d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，现在我们可以设置一个cron来查找服务“dataproc-twitter ”,并在处理程序定义中找到将请求重定向到哪里，也就是说，在名为“main.py”的文件中找到名为“app”的应用程序。这是我们对将在后台运行我们的计划流程的工作人员的yaml定义:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="07c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要定义我们的<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/config/queueref" rel="noopener ugc nofollow" target="_blank">队列</a>将被处理的速率。这很简单，对于我们的项目，我们是这样做的:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="d64d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们的cron:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="b6e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署到GAE非常简单；需要安装gcloud ，之后我们只需运行:</p><p id="693d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nc nd ne mb b">gcloud app deploy main.yaml worker.yaml</code></p><p id="9017" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已。另一种部署是这样的:</p><pre class="jf jg jh ji fd ma mb mc md aw me bi"><span id="ba4f" class="lm kf hi mb b fi mf mg l mh mi">gcloud app deploy queue.yaml<br/>gcloud app deploy cron.yaml</span></pre><p id="f47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GCP仪表板上，所有正在发生的事情都有更新:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nj"><img src="../Images/6374cbbe8227116d65781e8e1a81ee53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wKrr10BTkooWcfhNJzQ_A.png"/></div></div></figure><p id="531f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及关于我们刚刚安装的crons的信息:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nk"><img src="../Images/383cecdf432c276f9260ce08ef7c9b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*isXpb_KmM2rfSDKW1jqrYQ.png"/></div></div></figure><p id="a84a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(cron“run _ dimsum”将在后面解释)。</p><p id="88c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经知道了如何在GCP运行无服务器cron作业。那我们去Spark实现吧！</p><h1 id="d863" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">4.天堂之火</h1><p id="2f3d" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">简而言之，Dataproc是一个Google完全管理的集群，它已经有了Spark内置功能。基本上，您可以指定需要多少工作人员，然后点击play，等待几分钟来创建集群。</p><p id="2a4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们的目标是在Spark中实现DIMSUM算法。我们创建的第一个东西是一个基于cron的触发器，它在启动时为我们构建一个完整的集群，处理Spark作业，并在结束时删除集群。这是为什么呢？所以成本直线下降。我们实际上为我们使用的东西付费，仅此而已。</p><p id="e30f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，让我们开始吧！我们现在要讨论的是:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nl"><img src="../Images/aa5b16dfdf27652b2478208c3a02cef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xt7QO2Bo3mzaEJC_14HImg.png"/></div></div></figure><p id="9527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经有了cron作业接收器和调度器工作器。这是我们用来运行所有这些操作的<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/gae/worker.py" rel="noopener ugc nofollow" target="_blank">代码</a>:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="5f91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里发生的事情是:首先，我们的cron作业将向URL <code class="du nc nd ne mb b">/run_job/run_dimsum/.</code>发送一个GET请求，这又将调度一个由运行函数<code class="du nc nd ne mb b">dataproc_dimsum().</code>的URL <code class="du nc nd ne mb b">/dataproc_dimsum</code>触发的任务</p><p id="101e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数的作用是:</p><ol class=""><li id="8221" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">创建火花簇</li><li id="96b7" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">将运行作业所需的PySpark文件上传到GCS</li><li id="a0ea" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">运行PySpark作业</li><li id="0c5f" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">删除集群</li><li id="b2f7" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">安排一个任务，启动从GCS到数据存储的数据流提取。</li></ol><p id="3baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到这一点，我们可以深入了解PySpark工作。</p><h2 id="2595" class="lm kf hi bd kg ln lo lp kk lq lr ls ko iq lt lu ks iu lv lw kw iy lx ly la lz bi translated">4.1 PySpark</h2><p id="0617" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">以下是我们使用Dataproc的方式。首先，我们通常用<code class="du nc nd ne mb b">n1-standard-1</code>机器和<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/dataproc/bin/create_cluster.sh" rel="noopener ugc nofollow" target="_blank">脚本</a>创建一个非常小的集群，并像这样运行它</p><p id="dc1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nc nd ne mb b">./create_cluster -n=cluster_name -b=bucket_name</code></p><p id="3b34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里重要的一点是:如果你仔细观察<code class="du nc nd ne mb b">gcloud</code>命令，你会看到有一个<code class="du nc nd ne mb b">jupyter.sh</code>初始化动作。这样做的目的是为我们的集群准备一个J <a class="ae jd" href="http://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> upyter-notebook </a>服务，准备使用它来创建一个ssh隧道(你可以在文件<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/dataproc/bin/utils.sh" rel="noopener ugc nofollow" target="_blank"> utils.sh </a>和<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/dataproc/bin/launch_jupyter.sh" rel="noopener ugc nofollow" target="_blank"> launch_jupyter.sh </a>中的<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/tree/master/dataproc/bin" rel="noopener ugc nofollow" target="_blank">文件夹</a>中看到我们是如何做的)。</p><p id="87a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/dataproc/notebooks/df_naive.ipynb" rel="noopener ugc nofollow" target="_blank">这是我们完成实施后笔记本电脑的外观示例</a>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nm"><img src="../Images/d25f0e4de7b6d91604353f096599f679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHMoqb5jS4QUQzTdmRe_xA.png"/></div></div></figure><p id="97df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在作为本文基础的主存储库上，你可以在文件夹“dataproc”中看到文件夹“notebooks”。最酷的是，您可以看到在使用PySpark时这个工具是多么有用。我真的打开pyspark笔记本，开始测试一切可能的东西:所有的测试、问题、观察，一个接一个地同时进行。</p><p id="710c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这最终成为开发时的一个巨大的时间救星，因为您可以非常容易和快速地进行动态测试。如果你检查我的笔记本，你会发现我甚至没有跟着台词，我从一行开始，然后跳到底部，然后回到开头。这真的不重要，重要的是快速测试，尽可能快地构建原型，然后相应地构建最终代码(仍然要注意，我们所有的工作都经过单元测试，所以我们有一些代码工作的保证)。</p><p id="81a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到这一点，下面是我们如何为DIMSUM算法进行作业开发的。首先，我们创建了一个带有通用助手函数的<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/dataproc/jobs/base.py" rel="noopener ugc nofollow" target="_blank">基础</a>文件；以下是其中的一部分:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="b559" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当使用Spark时，你通常从创建一个<code class="du nc nd ne mb b">SparkContext</code>开始，它设定了关于Spark应该如何运行工作的一般准则。注意方法<code class="du nc nd ne mb b">process_day_input</code>中发生的MapReduce操作；首先，我们从<code class="du nc nd ne mb b">textFile</code>源读取，然后是一组映射和归约操作。</p><p id="887d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得我们将客户行为映射为“1”表示浏览给定的sku，“2”表示当它被添加到购物篮时，“3”表示购买发生时吗？在这里，我们将这些数字转换成最终得分，这暗示了给定顾客对某件商品的喜爱程度。</p><p id="49c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们做了这样的映射:<code class="du nc nd ne mb b">{"browsed": 0.5, "basket": 2., "purchase: 6.}</code>(在达菲提的生产中，我们有不同的值，这些值是通过<a class="ae jd" href="https://en.wikipedia.org/wiki/Bayesian_optimization" rel="noopener ugc nofollow" target="_blank">贝叶斯黑盒优化</a>获得的；因为讨论这些不是这篇文章的主要焦点，我们可能会在另一个机会讨论。</p><p id="b85c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾客每浏览一件商品，我们就加0.5分；如果它被添加到篮子，然后2点和6点，如果购买。这是我们得到的输出示例:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nn"><img src="../Images/5d8c84ee4a5934709c62779418106e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JdwWlzDVUN2oWwwA2R32lg.png"/></div></div></figure><pre class="jf jg jh ji fd ma mb mc md aw me bi"><span id="d33c" class="lm kf hi mb b fi mf mg l mh mi">{“user”:”8291743389332496534",”interactions”:[{“item”:”RE499APM08ZTZ”,”score”:0.5},{“item”:”RE499APM85DGC”,”score”:0.5}]}</span><span id="bca5" class="lm kf hi mb b fi mj mg l mh mi">{“user”:”5843584611541988560",”interactions”:[{“item”:”SA232SHF47ZZO”,”score”:0.5},{“item”:”SA232SHF89GXI”,”score”:1.0}]}</span><span id="dc08" class="lm kf hi mb b fi mj mg l mh mi">{“user”:”6935962925703084781",”interactions”:[{“item”:”DE996ACF83KYE”,”score”:0.5},{“item”:”CR177ACF76BIH”,”score”:0.5},{“item”:”MA318ACF62LRP”,”score”:0.5},{“item”:”DE996ACF23CIQ”,”score”:0.5},{“item”:”QU097ACF76IKL”,”score”:0.5},{“item”:”QU097ACF44IPN”,”score”:0.5},{“item”:”QU097ACF77IOG”,”score”:0.5},{“item”:”DE996ACF50CHP”,”score”:1.5}]}</span></pre><p id="9dc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程完成后，我们就可以最终运行<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/dataproc/jobs/dimsum.py" rel="noopener ugc nofollow" target="_blank"> DIMSUM </a>实现了:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="766d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个脚本基本上扫描了我们在上一步中计算的所有中间数据，将所有客户交互聚合到一行中(这是我们在开始时讨论的矩阵<strong class="ih hj"> A </strong>)，然后执行<code class="du nc nd ne mb b">run_DIMSUM</code>方法。首先注意<code class="du nc nd ne mb b">pq.</code>的广播，这是对每个产品的概率和它们的归一化因子的计算，用于相关性的发射(ai * bi)。当我们在Spark中广播一些东西时，对象被序列化并通过workers网络传播，这样他们就可以在内存中直接访问该对象；我们广播一个包含每个sku信息的字典来提高性能。</p><p id="8cb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，DIMSUM脚本基本上遍历我们客户的所有交互，并在这样做的概率超过生成随机数的概率时发出关联(想法是掷骰子，看看是否发布该数字)。</p><p id="4192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上就是这些了。尽管所有的方程都很复杂，但最终的实现非常简单。之后，结果被上传到GCS快速示例:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es no"><img src="../Images/52eb663e8a5e2e77dc9dd5ab2f7e17ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtnsrttNWjWLaGiWbmLAsw.png"/></div></div></figure><pre class="jf jg jh ji fd ma mb mc md aw me bi"><span id="42f8" class="lm kf hi mb b fi mf mg l mh mi">{“item”:”LO611APF49EBY”,”similarity_items”:<br/>    [{“item”:”DI944APF23XPS”,”similarity”:0.017922988},<br/>     {“item”:”ME700ACF75HAQ”,”similarity”:0.035410713},<br/>     {“item”:”LO611APF47ECA”,”similarity”:0.1254363},<br/>     {“item”:”TR943APF03NGY”,”similarity”:0.024296477},<br/>     {“item”:”CA700APF63DSU”,”similarity”:0.044455424},<br/>     {“item”:”LO611APF43ECE”,”similarity”:0.33709994},<br/>     {“item”:”LO611APF41ECG”,”similarity”:0.07137738},<br/>     {“item”:”LO611APF80EAT”,”similarity”:0.02228836},<br/>     {“item”:”LO611APF84EAP”,”similarity”:0.03180418},<br/>     {“item”:”DE234APF58ION”,”similarity”:0.013907681}]}</span></pre><p id="3b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这里我们没有按照相似性度量对结果进行排序。这是在我们的数据流管道中完成的，说到这…</p><h1 id="a50a" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">5.把他们都传送出去！</h1><p id="0c3e" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在将结果保存到GCS之后，会安排一个新任务将这些数据检索到数据存储中。这就是我们现在要讨论的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es np"><img src="../Images/0d4663093ab72c54a3608a5a66bddc50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVCCSiuqx8CswmLG-ckf8Q.png"/></div></div></figure><p id="b020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank"> Datastore </a>是谷歌的一个NoSQL数据库，它与AppEngine直接集成，使事情变得简单快捷100倍。我们现在要做的是以键值的方式上传结果，这样当我们的系统收到一个请求，询问“我应该向喜欢这双红色鞋子的顾客推荐什么？”我们的系统可以查询数据存储，并检索所有需要的相似性，以得出答案。</p><p id="ea8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是有一个问题:如何将结果从GCS保存到Datastore？</p><p id="e17c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<a class="ae jd" href="https://cloud.google.com/dataflow/" rel="noopener ugc nofollow" target="_blank">数据流</a>发挥作用的地方！Dataflow是一个无服务器的框架，可以通过运行统一的数据处理模型来计算一般的ETL任务(这意味着它有一个“引擎”或“运行器”的概念，您可以选择运行哪个引擎:Dataflow、Apache Spark、Flink和任何其他遵循统一模型的工具)。</p><p id="1bdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇波束</a>是创建流水线作业所需的工具。这是一个开源项目，目前支持Java和Python SDKs(尽管不幸的是Python的实现落后于Java，但它仍然提供了很多特性)。</p><p id="649f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在要做的是实现一个管道过程，读取保存在GCS中的DIMSUM的结果，对其进行相应的处理，并将结果保存到数据存储中。这是我们的管道<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/dataflow/build_datastore_template.py" rel="noopener ugc nofollow" target="_blank">实现</a>:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="f28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们使用了<a class="ae jd" href="https://cloud.google.com/dataflow/docs/templates/overview" rel="noopener ugc nofollow" target="_blank">模板化数据流</a>的概念:基本上它所做的就是创建必要的代码和json元数据，并将其导出到GCS中的位置路径；这样做的好处是，任何其他客户端在任何时候都可以运行该模板，只需发出一个指向模板位置的HTTP请求。这意味着不需要重新编译代码或设置整个环境。这对我们来说很有价值，因为我们是在标准GAE中工作的(记住，到目前为止所有的东西都是由crons激活的)，沙箱环境不允许我们在那里运行beam管道。</p><p id="cea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了模板，什么样的环境和限制真的无关紧要，我们只需向作业执行发出GET请求，它就会自动发生；这是我们处理过的管道的一个例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nq"><img src="../Images/49d3b922c40cc128de74b75b65670c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpbzdI3GWL-gZjBG1AHOqw.png"/></div></div></figure><p id="7fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是:我们将管道执行设置为最多2个工人；数据流自动知道何时产生更多的工人，以便在可行的时间框架内优化总成本。</p><p id="029d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，您可能会注意到，将实体写入数据存储时会消耗相当长的时间。我不知道为什么会发生这种情况，幸运的是这对我们来说不是问题，因为这个过程在晚上运行，但我希望编写步骤比现在快得多(如果你知道如何提高性能，请告诉我们:)！).也许我们错过了一些优化步骤，但是随着我们交付产品的最后期限临近，这就是我们目前交付产品的方式。</p><p id="36a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着我们的数据准备就绪，是时候提供建议了。我们快到了。</p><h1 id="3ed6" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">夫人，先生，塞西是为你们。</h1><p id="7e46" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">(我不会说法语，所以我只希望翻译没弄错)下面是我们现在要讨论的内容:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nr"><img src="../Images/02f2b07f2075381be256da01def9991e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWF2_NI0X-g2rw2LmaDqFQ.png"/></div></div></figure><p id="8570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，让我们来推荐！</p><p id="0af2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，在我们的简介中，我们是这样计算最终建议的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lk"><img src="../Images/165cbf21afe3a9ba688fe9854420491b.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*jAXRKAqL8RGlF2fcxf61iQ.png"/></div></figure><p id="e3c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，我们不像文献中建议的那样进行归一化(分母中的相似性求和)。</p><p id="9e0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，我们可以获得客户与商品的所有互动，得出一个隐含的得分指标“r ”,并乘以商品与这些得分之间的相似性，以预测给定客户对我们可能推荐的给定产品的喜爱程度。查看代码可能会使这更容易可视化。这是我们的第一个<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/gae/main.py" rel="noopener ugc nofollow" target="_blank">实现</a>来完成:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="f96c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且<code class="du nc nd ne mb b">process_recommendations</code>由下式给出:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="a31b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是这样工作的:我们接收这样的输入请求:</p><pre class="jf jg jh ji fd ma mb mc md aw me bi"><span id="7b48" class="lm kf hi mb b fi mf mg l mh mi">/make_recommendation?browsed=CA278SHF46UJH</span></pre><p id="6e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">意思是:“我有一个顾客浏览了CA278SHF46UJH商品，你有什么推荐吗？”</p><p id="38f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们通过循环遍历CA278SHF46UJH作为DIMSUM输出的所有相似性来实现该等式，并从最好到最差排序，仅选择顶部的“n”。</p><p id="8336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一切表示，这就是我们所得到的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ns"><img src="../Images/059b67119aadbc43294ff21f1410ff87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZKRj66FAYCOW3s__-GWdw.png"/></div></div></figure><p id="719c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，没错。一场离奇的灾难...处理这些建议几乎花了整整1秒钟。从那1秒开始，<strong class="ih hj">仅用一种方法就完成了800毫秒！</strong> <code class="du nc nd ne mb b">process_recommendations</code>这里最终变成了一场灾难。</p><p id="9e36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要误会，这是一个很大的失败。如果你开发了一个推荐系统，它需要1秒的时间来回应，你就不会吸引那么多顾客，也不会让他们因为等待而高兴；这是丑陋和无效的。</p><p id="d8f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，那意味着我们所有的努力都失败了。但是我们还有最后一个锦囊妙计:我们一直使用标准环境，因为它简单，而且如果需要的话，可以缩减到零个实例。但这一次，沙盒功能可能弊大于利，现实是推荐系统很可能总是收到请求；对于达菲提和我们的许多企业来说都是如此，所以继续使用标准版没有多大意义。</p><p id="18da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的时间很短，所以我们很快迁移了环境，并开始使用灵活的环境，同时玩了另一个大把戏:我们决定<a class="ae jd" href="http://cython.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">将</a>操作<code class="du nc nd ne mb b">process_recommendation</code>化。</p><p id="63d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，这就是Python的妙处:<em class="lj">《过早优化是万恶之源》</em>。这是代码开发中的一个基本事实。到目前为止，Python为我们提供了很大的帮助，它让我们尽可能地多产。但是在这种特殊的方法中，它肯定没有做得很好，所以一个解决方法是使用Cython来获得一些性能提升；Cython基本上是一种能够混合Python和C/C++的语言。</p><p id="e2ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的优点是，在很大程度上，Python将每个对象都视为…嗯，一个对象。这意味着“int”的概念在Python中并不存在。实际上，int是由包含int的对象封装的。这很神奇也很糟糕，只是取决于你如何看待它(或者说你如何使用它)。这给了Python所有的灵活性和编码实现速度，但代价是性能。但是在Cython中我们能做的是去掉Python必须对每个对象提出的那些问题，比如“ok object，你是什么？”我们可以事先说:“这是一个整型数组，你不必再问它们是什么了”。</p><p id="62d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/gae/cythonized/c_funcs.pyx" rel="noopener ugc nofollow" target="_blank">这就是我们在Cython中实现的</a>:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="ac76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Cython对Python-API请求的分析:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nt"><img src="../Images/3a2151236580b1135d591792e13731aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K-DSPrpBE8nhS5KC.png"/></div></div></figure><p id="e86d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯…有点……好吧。</p><p id="9788" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码已经让我们在本地计算机上的处理速度提高了7倍。那是相当酷的！但是请注意分析中的黄线:它越强，对Python-API的请求就越多。因为我们的输入是一个字典列表，所以Cython不能将其直接转换成任何C结构。这意味着这些对象在Cython中仍然被如此对待，我们没有获得成功转换后可能获得的性能提升。</p><p id="2655" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，别担心。然后，我们为推荐创建了一个单独的<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/gae/recommender.py" rel="noopener ugc nofollow" target="_blank">服务</a>，这次是在灵活的环境中:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="820f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<code class="du nc nd ne mb b">cy_process_recommendations.</code>这是我们调用Cython脚本的地方。</p><p id="42d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的案例中，部署到灵活就像标准一样简单。我们已经定义了我们的<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter/blob/master/gae/requirements.txt" rel="noopener ugc nofollow" target="_blank"> requirements.txt </a>文件，所以我们只需运行:</p><p id="130a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du nc nd ne mb b">gcloud app deploy recommender.yaml</code></p><p id="7dea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这些是新的结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nu"><img src="../Images/d69f8d3836b6f860de1806af0f338e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MGOInJWav8fz4fo7aNj0Q.png"/></div></div></figure><p id="ae60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个处理时间从1秒到<strong class="ih hj">104毫秒。</strong>这是一个相当昂贵的请求，需要输入多个SKU。我们得到更简单的输入:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nv"><img src="../Images/27080f9bbb2144cb69b27f119a273224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Whs0n7OQU4G33TGz2lZgA.png"/></div></div></figure><p id="4f57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约在<strong class="ih hj">20毫秒</strong>左右(需要注意的是，响应时间的数据存储标准偏差相当大，但平均值和中间值仍在此值附近)。</p><p id="a883" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在的主要瓶颈是从数据存储中检索密钥，由于消耗的时间是完全可以接受的，我们可以认为我们的任务现在已经完成了(哦耶！！！)</p><p id="dd1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里发生的一件事是从数据存储中获取实体的时间变得更长了；发生这种情况是因为我们必须更改客户端来建立连接，它使用HTTP而不是<a class="ae jd" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>，这意味着我们可以使用更合适的客户端来缩短时间。</p><p id="6ef1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们从输入<code class="du nc nd ne mb b">/make_recommendation?browsed=DA923SHF25QXA</code>中得到的结果示例:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nw"><img src="../Images/eaa2557fa0378f366c0321fc3e0405ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NURT3hRy5RvY85UkcVXzPw.png"/></div></div></figure><h1 id="1b75" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">7.给我钱！(费用)</h1><p id="0615" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">成本很重要，但实际上真正重要的是成本收入比，而不仅仅是成本。</p><p id="b49b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我不能公开Dafiti的数据和成本，但让我们看看这样一个模拟电子商务系统的成本。</p><p id="b8f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们有标准的AppEngine cron服务。这笔费用基本上可以忽略不计，大概会是每月1美元。现在我们让BigQuery进行数据处理，假设每天处理100 GB的数据，那么每个月的查询量会增加15美元。让我们模拟一个Dataproc集群，每天运行大约2小时，3台n1-standard-4类型的机器，每月增加36美元。我们也有数据流机器，但由于瓶颈是写入操作，我们可以使用非常基本的n1-standard-1实例，假设两个工人工作3小时，每月加起来就是9美元。现在我们有了数据存储。由于每100k次写入是0.18美元，假设300k最终大约是每月16美元。现在，假设电子商务规模很大，每天有大约500万次请求。那就是每月90美元。存储也是有价格的。如果我们消费5英镑，那么到月底就只有1美元了。最后，我们有灵活的环境机器。在这里，我们选择了一个非常基本的机器，因为我们看到主要的瓶颈是数据存储。考虑到我们将使用1个vCPU和2GB内存，这给了我们大约46.8美元。</p><p id="e973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一个每天接收500万次请求的电子商务来说，这些加起来就是每月214美元。</p><p id="a8a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一点非常重要:该系统是完全无服务器的，这意味着我们没有基础架构团队或开发人员的费用。我们实际上只为我们使用的东西付费，仅此而已；这里没有额外的费用。</p><h1 id="c5f6" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">8.现在我们改进了</h1><p id="fb49" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">嗯，我们仍然可以做一些改变来改进这个系统。在达菲提，我们在生产中不使用Spark。我们相似性是通过BigQuery查询提取的，该查询已经为我们计算了所有的相关性。</p><p id="53c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，使用Python进行推荐最终并不十分有效。更好的选择是在这里使用<a class="ae jd" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> GoLang </a>。这可能导致不必将数据导出到数据存储，并且每个实例将文件从GCS加载到自己的本地内存。在这种架构下，我们的模拟商店的成本可能会比<strong class="ih hj">100美元</strong>低得多。</p><p id="2651" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们必须交付，我们不能进一步探索这种方法，但它肯定是我们将很快测试的东西。</p><h1 id="cdb2" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">9.就是这样！</h1><p id="f319" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">多好的旅程啊…</p><p id="2051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们开始实施这个系统时，我们无法想象它最终会有多么具有挑战性和苛刻。这让人筋疲力尽，痛苦不堪，我们每天都要在紧迫的期限内面对一个又一个bug；这非常非常具有挑战性。</p><p id="11e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我记得看到过这句话“最好的水手不是风平浪静的大海造就的”。我承认，这个版本的“不劳无获”让我重新考虑继续经历这个项目实施过程中出现的所有障碍。我很高兴我们成功地解决了这个问题，因为我们在整个过程中学到了很多。</p><p id="b9a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们设法让它工作，并及时交货。我们对取得的成绩感到非常高兴，也很期待接下来会发生什么。</p><p id="b71a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经掌握了一些知识，知道如何在生产环境中使用一个完整的无服务器架构来实现要求相当高的系统，这种架构既便宜又有效。希望这将为我们打开大门，让我们能够快速、简单、无服务器地构建更复杂的系统，并随时准备好与客户互动。</p><p id="1d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就在不久前，我们还认为不可能建立一个完全无服务器的推荐系统，因为每个请求中的计算可能相当苛刻，但正如我们可以证实的那样，这是完全可能的，也应该是我们作为开发者的主要目标。</p><p id="6ee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你通读了所有这些，天哪，这是你应得的！希望它值得一读，你可以从中学习到一些东西。如果您有任何建议或意见，请告诉我们！</p><p id="67d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">全部代码可在<a class="ae jd" href="https://github.com/WillianFuks/example_dataproc_twitter" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="07f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，我们期待着我们的下一个任务(你现在可以播放<a class="ae jd" href="https://www.youtube.com/watch?v=KWdRKZ6QgcU" rel="noopener ugc nofollow" target="_blank">超级银河战士结局</a>原声带，这将是史诗，保证)。</p><p id="8572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常感谢！<br/>(光束开火。阿帕奇-梁，也就是*)</p></div></div>    
</body>
</html>