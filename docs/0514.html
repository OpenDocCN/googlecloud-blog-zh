<html>
<head>
<title>Capturing and Integrating Service Data with Google Cloud Functions and Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google云功能和Neo4j捕获和集成服务数据</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/capturing-and-integrating-service-data-with-google-cloud-functions-and-neo4j-588855f1695e?source=collection_archive---------0-----------------------#2018-02-08">https://medium.com/google-cloud/capturing-and-integrating-service-data-with-google-cloud-functions-and-neo4j-588855f1695e?source=collection_archive---------0-----------------------#2018-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="28df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/moxious/neo4j-serverless-functions" rel="noopener ugc nofollow" target="_blank"> <em class="je">本文提到的所有代码都可以在Github </em> </a> <em class="je">上找到。</em></p><p id="378f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多服务提供了webhooks的机制，或者在某个动作发生时调用一些自定义URL的能力。有这么多不同的系统和触发需求，让一个人的专有平台上的事件服从其他地方的发布和订阅类型的行为是一种很好的简单方法。也很简单；一个HTTP POST，带有一个JSON主体。</p><p id="34d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">真实的例子包括:</p><ul class=""><li id="6005" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated"><strong class="ih hj"> Trello </strong>，它将<a class="ae jd" href="https://developers.trello.com/page/webhooks" rel="noopener ugc nofollow" target="_blank">向您选择的端点发布所有卡片变化和棋盘动作</a></li><li id="8934" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><strong class="ih hj"> Slack </strong>，它有一个<a class="ae jd" href="https://api.slack.com/custom-integrations/outgoing-webhooks" rel="noopener ugc nofollow" target="_blank"> Outgoing Webhooks </a>集成，可以为您指定的通道中的任何消息做同样的事情。</li><li id="ac65" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated"><strong class="ih hj">谷歌分析</strong>，它允许<a class="ae jd" href="https://metric.live/2017/08/setup-webhook-google-analytics-alerts/" rel="noopener ugc nofollow" target="_blank">向webhooks发布提醒</a></li></ul><h1 id="ac3f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">数据捕捉</h1><p id="26fa" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">不仅仅是触发一个定制行为，许多用例都需要先捕获。最近在开发一些可部署到云的映像时，我想要一种简单灵活的方法来从云服务中捕获数据，这使我能够在有人部署我的包时调用webhook。我知道我想把这个放到neo4j图表中，因为我最终需要把这个数据和我的另一个图表整合起来。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es kw"><img src="../Images/9bcdc5d3e328c06d64e8473d44de334e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSExneMR3pIqHkkGMb3ouw.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">Webhook在neo4j中捕获数据</figcaption></figure><h1 id="c834" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">谷歌云功能</h1><p id="f3ca" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">GCP的<a class="ae jd" href="https://cloud.google.com/functions/docs/" rel="noopener ugc nofollow" target="_blank">云功能</a>是一种创建运行在云基础设施之上的独立功能的方式。它们是“无服务器”的，因为Google管理所有的供应和运行时部分。开发人员只需编写一组功能，将它们部署到云中，然后在需要时运行它们。理想情况下，这些函数也是无状态的和幂等的，这有助于重用。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lm"><img src="../Images/080aa83b1dfc231f15a0df71253e7f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*TG4VTrSkg1egeFGgzihl9Q.png"/></div></figure><p id="b4e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你看到这条标语“响应云中的事件”时…嘿，听起来像网钩！</p><p id="9edf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我来说，这样做对webhooks的好处还在于，我期望的流量相当低(比如说，每天最多几百个)，而且我不想支付24/7托管虚拟机的费用，也不想费心去管理那个虚拟机。</p><h1 id="36a9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Neo4j云函数如何捕获数据</h1><p id="f3ff" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">与本文相关的代码可以在github 上的<a class="ae jd" href="https://github.com/moxious/neo4j-serverless-functions" rel="noopener ugc nofollow" target="_blank">neo4j-无服务器功能报告中找到。</a></p><p id="11a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">捕捉数据变得相当容易。谷歌的云功能公开了一个API，用javascript看起来像(或者可能是)T2快车。JS API 。最简单的可能函数如下所示:</p><pre class="kx ky kz la fd ln lo lp lq aw lr bi"><span id="ced6" class="ls ju hi lo b fi lt lu l lv lw">export.myCloudFunction = (req, res) =&gt; {<br/>    return res.status(200).json('All OK!');<br/>};</span></pre><p id="65a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要从一个webhook捕获数据，我们需要做的就是查看请求中的数据，比如它的头、它的POST主体等等，然后将这些数据转换成一个在neo4j中创建数据的Cypher语句。<a class="ae jd" href="https://github.com/moxious/neo4j-serverless-functions/blob/master/services/node.js" rel="noopener ugc nofollow" target="_blank">你可以在这里看到代码</a>。</p><h1 id="04b1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">从Webhook数据创建节点</h1><p id="4a9a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">假设我们有一个简单的帖子，如下所示:</p><pre class="kx ky kz la fd ln lo lp lq aw lr bi"><span id="4553" class="ls ju hi lo b fi lt lu l lv lw">curl -XPOST -H "myheader: foo" -d '{"name":"Bob"}' http://cloud-endpoint/node?label=Person</span></pre><p id="cc89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将变成密码的等价物:</p><pre class="kx ky kz la fd ln lo lp lq aw lr bi"><span id="13fc" class="ls ju hi lo b fi lt lu l lv lw">CREATE (r:Request { myheader: "foo" })<br/>CREATE (n:Person { name: "Bob" })<br/>CREATE (r)-[:POST]-&gt;(n);</span></pre><p id="c7ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是从外部服务、任何服务、任何JSON模式捕获可审计数据的简单方法。当然，neo4j中的属性定义将远非理想，但这可以在事后用Cypher进行处理。</p><h1 id="a0dc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">从Webhook数据创建边</h1><p id="e293" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">对于允许对URL进行一些定制的API，您可以使用相同的方法将图形编织在一起。代码包包括一个单独的“edge”函数，可以给它一个属性名和值，如果适合您的使用，它将用来绘制新的关系。假设在一个社交网络上，有人加别人为好友，你可以调用webhook:</p><pre class="kx ky kz la fd ln lo lp lq aw lr bi"><span id="f72d" class="ls ju hi lo b fi lt lu l lv lw">http://cloud-endpoint/edge?fromLabel=Person&amp;fromProp=userid&amp;fromVal=PERSON_A&amp;toLabel=Person&amp;toProp=userid&amp;toVal=PEROSN_B&amp;edgeType=KNOWS</span></pre><p id="c94a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这和cypher的作用是一样的:</p><pre class="kx ky kz la fd ln lo lp lq aw lr bi"><span id="f18a" class="ls ju hi lo b fi lt lu l lv lw">MATCH (a:Person { userid: "PERSON_A" }),<br/>      (b:Person { userid: "PERSON_B" })<br/>CREATE (a)-[:KNOWS]-&gt;(b);</span></pre><h1 id="8430" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">“无状态函数”并不是真正的无状态</h1><p id="41c6" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">有趣的是，销售无服务器功能的方式之一<a class="ae jd" href="https://cloud.google.com/functions/docs/concepts/exec#stateless_functions" rel="noopener ugc nofollow" target="_blank">涉及到无状态的概念</a>。理想情况下，你的云函数是一个纯函数，它产生一个值，没有副作用。像往常一样，现实侵入完美…</p><p id="ce84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，在幕后，google必须将这个功能部署到一个实际的容器或服务器上。这可能会造成混乱，因为现实是“无服务器不是无服务器”。所以在现实中，你的代码至少有时是热部署在某个地方，而不是每次都从冷部署，这将是非常低效的，如果你使用重量级运行时(例如java)，更是如此。</p><p id="5d4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在google关于云函数的提示和技巧中，他们指出在未来调用中使用变量重用对象是最佳实践。让我们看看这在neo4j案例中意味着什么。</p><p id="a7c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在设置neo4j驱动程序的代码模块中，<a class="ae jd" href="https://github.com/moxious/neo4j-serverless-functions/blob/master/neo4j/index.js" rel="noopener ugc nofollow" target="_blank">有一个persistentDriver变量</a>，它在函数调用之间保存一个驱动程序实例。</p><pre class="kx ky kz la fd ln lo lp lq aw lr bi"><span id="ad1b" class="ls ju hi lo b fi lt lu l lv lw">const driverSetup = () =&gt; {<br/>    const username = process.env.NEO4J_USER || _creds.username;<br/>    const password = process.env.NEO4J_PASS || _creds.password;<br/>    const uri = process.env.NEO4J_URI || _creds.uri;<br/><br/>    const auth = neo4j.auth.basic(username, password);<br/>    return neo4j.driver(uri, auth);<br/>};<br/><br/>let persistentDriver = null;<br/><br/>exports.getDriver = () =&gt; {<br/>    if (!persistentDriver) {<br/>        persistentDriver = driverSetup();<br/>    }<br/><br/>    return persistentDriver;<br/>};</span></pre><p id="6aeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据文档，Neo4j驱动程序对象是“重量级”的，不应该随意地大量创建，否则会影响性能。通过使用持久驱动程序，数据库连接可以在函数调用之间重用。通过公开一个访问器函数，这个驱动程序在需要的时候被“延迟创建”,而不只是躺着。</p><p id="4c7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们换一种方式呢？如果我们这里没有一个持久的驱动程序，这个函数仍然可以工作；但是我们可能会用连接来破坏数据库。对于几十个请求来说可能是可以的，但是这个函数永远不会扩展到大量的调用。</p><h1 id="5a46" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">云功能无处不在</h1><p id="d603" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">本文涵盖了一些如何进行基本集成的简单示例。但是除了两个简单的功能之外，你还可以(人们肯定会这样做)增加更多的功能。</p><p id="3906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你理解了这个模型，你将很快看到如何只用云函数来编写整个后端。什么，没有虚拟机？没有码头集装箱？这将是一个“无后端的后端”。<a class="ae jd" href="http://www.catb.org/esr/writings/unix-koans/" rel="noopener ugc nofollow" target="_blank">非常禅</a>。</p><p id="7c50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，事情并不那么简单。正如我在上面描述的那样，谷歌云功能确实有状态和服务器，这是必然的。结果，无服务器抽象有点漏洞，当你进入其中时，知道一些函数生命周期是很好的。我还发现这篇文章很好地概括了你将在这个美丽新世界中面临的一些关键架构问题。与工程中的所有事情一样，这不是什么是对或错，而是对您的用例来说什么是一个好的权衡。</p><h1 id="de3e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">后续步骤</h1><p id="a917" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在这个简单的例子中，我掩盖了在一个更加繁重的用例中你想要做的一些事情。我只是从一些网站上收集数据，没什么大的工作量。例如:</p><ul class=""><li id="5e98" class="jf jg hi ih b ii ij im in iq jh iu ji iy jj jc jk jl jm jn bi translated">对于许多云功能，您会希望有一个身份存储并验证调用者。这里描述的代码实际上是开放的，所以如果有人知道你的端点，如果他们愿意，他们可以用垃圾填充你的数据库。</li><li id="758f" class="jf jg hi ih b ii jo im jp iq jq iu jr iy js jc jk jl jm jn bi translated">我们讨论的代码以一种“简单”的格式存储数据，以达到最小的工作量和最大的灵活性。但是随着许多webhook调用，它将导致在你的图中有许多断开的节点的情况。如果你想改变迭代地构建一个更好的图，你可以使用提供的代码的变体。所有需要做的就是修改运行的密码以适应你的用例。您也可以编写一个body transformer来过滤它接受的JSON有效负载，或者转换它们(例如，获取一个Slack JSON响应，并将其分成多个对象/节点，比如通道、用户、消息等)。</li></ul></div></div>    
</body>
</html>