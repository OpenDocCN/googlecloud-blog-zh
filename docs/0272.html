<html>
<head>
<title>App Engine Resident instances and the startup time problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">App Engine常驻实例和启动时间问题</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/app-engine-resident-instances-and-the-startup-time-problem-8c6587040a80?source=collection_archive---------0-----------------------#2017-05-04">https://medium.com/google-cloud/app-engine-resident-instances-and-the-startup-time-problem-8c6587040a80?source=collection_archive---------0-----------------------#2017-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d9dc4b6b7d36750855f51f34b01f8003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8gFMHNLtQJj-DnrepTSjw.jpeg"/></div></div></figure><div class=""/><p id="6246" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上周，我在德克萨斯州奥斯汀参加了一个会议，一些开发人员找到我，他们开发了一个名为“<em class="jo"> ThinkThanks </em>的应用程序。他们的目标是彻底改变人们感谢他人的方式。然而，他们遇到了一个大问题:当大量用户突然想要“发送感谢”时，他们注意到他们的请求延迟达到了最高点。</p><p id="e5d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我已经调试了一些与启动性能相关的问题，所以这听起来非常相似。然而，当我与首席开发人员坐下来时，我很快意识到他们的使用模式与<a class="ae jp" rel="noopener" href="/@duhroach/app-engine-startup-time-and-the-global-variable-problem-7ab10de1f349"><em class="jo"/></a>或<a class="ae jp" rel="noopener" href="/google-cloud/app-engine-and-the-connection-confusion-problem-d270b7465794"> <em class="jo">部分模糊</em> </a>非常不同。</p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">忙到没时间看书？看TL；上面的DR视频！</figcaption></figure><p id="601a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实证明，他们已经完成了减少实例启动时间的所有繁重工作。他们的问题是应用程序的流量非常具有突发性。他们会从几个小时的0个用户，突然增加到几千个。在这些情况下，实例被合法地冷启动，导致创建实例时的整体延迟。</p><p id="ddde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">花一些时间在云控制台上证实了这种行为；观察实例旁边的延迟峰值，我们发现实例数和延迟峰值之间存在直接的相关性:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ka"><img src="../Images/bc031b987601ebbd4cb75bee04844e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*a3mJMTatgQ1UYrxljlXT5Q.png"/></div></figure><p id="fc75" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当一个新实例启动时，<em class="jo"> ThinkThanks </em>的延迟就会受到相当大的影响。因此，除了调整调度程序来引导更少的实例之外，看起来他们需要更强大的东西来处理流量和实例的突然高峰。</p><h1 id="4024" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">空闲实例是潜在的玩物</h1><p id="61d1" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">正如我之前谈到的，应用引擎服务算法不断地决定是将请求排队好还是启动新实例好。这考虑了大量的因素，(例如队列深度、当前QPS、平均。请求等待时间等)来决定这应该何时发生。</p><p id="9608" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您的冷启动时间很长，那么在流量达到峰值时，用户请求的延迟会很大，因为请求在得到服务之前会在工作队列中停留更长时间。这可能会使您的应用程序充满大量的启动成本，并显著延迟整个系统。</p><p id="4498" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这些情况下，<a class="ae jp" href="https://cloud.google.com/appengine/docs/python/config/appref#min_idle_instances" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">常驻实例</strong> </a>可以帮助减少整体启动时间，改善用户等待时间，同时降低成本。</p><p id="c92f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">常驻实例是不管你的应用程序正在处理什么类型的负载都存在的实例；<strong class="is hu">即使你已经缩小到零，这些实例仍将存在</strong>。</p><p id="01ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当出现峰值时，常驻实例用于处理那些在启动新实例所需的时间内无法处理的请求。因此，请求被并行地路由到它们，同时一个新的实例被启动。一旦新实例启动，流量就被路由到它，常驻实例又回到空闲状态。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es le"><img src="../Images/fb58574e55e93ea80bd16e9e24018a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*2Fv7vDoAiXaUzNNx75u1sg.png"/></div></figure><p id="f04c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的要点是，常驻实例是快速扩展的关键，并且不会让您的用户对延迟的感觉一飞冲天；它们向用户隐藏了对实例启动时间的任何感知(这是一件好事)！</p><p id="7c64" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我能够在<em class="jo"> ThinkThanks </em>中确认这一点，方法是将它们的<a class="ae jp" href="https://cloud.google.com/appengine/docs/python/config/appref#min_idle_instances" rel="noopener ugc nofollow" target="_blank"> min-idle-instances </a>标志设置为1，并绘制出我的应用程序的延迟如何适应结果:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lf"><img src="../Images/cab2d76ab3cc0f11be7e95d44bbc9527.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*JICmcnxhU96Wj7qFKtnPQg.png"/></div></figure><p id="50ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦新的请求负载进来，它就由现有的实例处理，所以当新的实例启动时，延迟不会突然增加。</p><p id="008d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，Idle实例设置有一个min和<a class="ae jp" href="https://cloud.google.com/appengine/docs/python/config/appref#max_idle_instances" rel="noopener ugc nofollow" target="_blank"> max </a>值，这使得它们在峰值期间也可以按比例增加。在<em class="jo"> ThinkThanks </em>的人们摆弄这些值，以找到一个最佳点，我怀疑这将因应用程序类型和地区而异(YMMV！)</p><h1 id="418d" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">总是Cron实例</h1><p id="2548" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">在对常驻实例进行了一番研究后，<em class="jo"> ThinkThanks </em>注意到，在流量低于正常水平的情况下，似乎存在+1实例税。基本上，如果有一段时间没有人使用这个应用程序，突然爆发会消耗2个实例:空闲实例，以及正在启动的新实例。</p><p id="c2dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是对于不频繁的流量，这并不是他们真正需要的；<em class="jo"> ThinkThanks </em>浪费了一个实例。一个更好的解决方案来自G+的帖子，波格丹一世·努雷斯库描述了他对同样问题的解决方案(转述如下):</p><blockquote class="lg lh li"><p id="3acb" class="iq ir jo is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><em class="ht">对于我的用例，min-idle-instances标志超出了我的需要，因为如果我一天收到许多请求，我会有2个实例在运行，尽管我只需要1个。</em></p><p id="345d" class="iq ir jo is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><em class="ht"> …… </em></p><p id="19a6" class="iq ir jo is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">我的解决方法:创建一个cron作业，它调用一个DoNothing Url，这样它就可以在我需要的时候保持我的实例活动，这样当用户访问API时，他们可以获得低延迟，并且没有启动请求。DoNothing URL只记录“保持实例活动”</p></blockquote><p id="a1c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看起来是个不错的解决方案。我们的初创公司朋友改变了他们的配置，发现他们对负载峰值的延迟结果几乎相同，但没有看到相同的实例负载:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lm"><img src="../Images/d413d03678551889d4487a3fb574e950.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*GEsLRQqPe9dRO-p36Ptzmw.png"/></div></figure><h1 id="9ee4" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">学习和收获</h1><p id="3259" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">对他们的延迟改进感到满意，<em class="jo"> ThinkThanks </em>的人们吃完了meetup提供的披萨，然后愉快地继续他们的旅程。</p><p id="7c6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">后来，我和几个应用引擎专家谈过，他们想弄清楚这里有两个截然不同的用例。</p><p id="61b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">如果你有一个高频率、大量实例流失的场景，以及一个缓慢的冷启动时间</strong>，那么常驻实例是最好的选择。是的，您最终会有更多的总实例，但是让GAE处理常驻实例的伸缩将会更好地响应流量负载随时间的变化。</p><p id="75b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">如果您处理低频率的流量，偶尔会有突发，并且冷启动时间很慢，</strong>那么保持一个always-cron实例是理想的，因为您可以优雅地处理初始流量负载，并且实例总数较少。</p><p id="5afb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两种情况的缺点是，这些持久化的实例是有代价的:您基本上是在为一个实例24x7保持活动而付费，这可能会大大增加您的运营预算。</p><p id="128a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，和往常一样，在一头扎进去之前，确保你仔细权衡了这些方法的利弊。</p><h2 id="af71" class="ln kc ht bd kd lo lp lq kh lr ls lt kl jb lu lv kp jf lw lx kt jj ly lz kx ma bi translated">嘿！</h2><p id="8855" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">想了解更多关于如何<a class="ae jp" rel="noopener" href="/@duhroach/understanding-and-profiling-app-engine-cold-boot-time-908431aa971d">剖析App引擎启动时间</a>？<br/>想了解更多关于<a class="ae jp" rel="noopener" href="/@duhroach/app-engine-scheduler-settings-and-instance-count-4d1e669f33d5"> GAE的调度器设置</a>？<br/>想知道首先避免<a class="ae jp" rel="noopener" href="/@duhroach/app-engine-startup-time-and-the-global-variable-problem-7ab10de1f349">启动新实例的方法</a>？<br/>想成为<a class="ae jp" href="http://shop.oreilly.com/product/0636920052036.do" rel="noopener ugc nofollow" target="_blank">数据压缩专家</a>？</p></div></div>    
</body>
</html>