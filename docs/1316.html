<html>
<head>
<title>How to query geographic raster data in BigQuery efficiently</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在BigQuery中高效查询地理栅格数据</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-query-geographic-raster-data-in-bigquery-efficiently-b178b1a5e723?source=collection_archive---------0-----------------------#2020-03-07">https://medium.com/google-cloud/how-to-query-geographic-raster-data-in-bigquery-efficiently-b178b1a5e723?source=collection_archive---------0-----------------------#2020-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="57b4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将光栅图像加载到BigQuery时，对其进行游程编码</h2></div><p id="e6fb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几个月前，我写了一篇关于如何在BigQuery中查询GIS栅格数据的文章。因此，为了处理栅格图像，我展示了可以将栅格的每个像素表示为它自己的多边形，并展示了即使对于分辨率为30弧秒(约0.9公里)的全球图像，结果查询也是有效的。</p><p id="60d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是它一直困扰着我，必须有一种更有效的方式来表示栅格数据。在本文中，我将向您展示一种更有效的方法。对于人口密度数据，存储减少了3-5倍，查询速度也相应提高。</p><h2 id="1536" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">将数据表示为矩形</h2><p id="845c" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">最简单的图像压缩方法之一是游程编码。在这里，不是逐个像素地存储图像数据，而是将图像存储为一个像素值，后跟一个游程长度。在地理图像领域，这意味着什么？</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/47da8ab549fb9a1c2fd0766e5218cdac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRF8HCte6yUrdDKjdggqrQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">GIS中的游程编码转换为将数据存储为矩形而不是像素</figcaption></figure><p id="5619" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没错！我们不是逐个像素地存储数据，而是简单地将其存储为矩形(假设我们没有从一行绕到下一行)。在GIS表单中，一个矩形占用的存储空间与一个像素(4个顶点)完全相同，因此使用矩形的存储成本将始终与存储单个像素的成本相似或更高。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="7642" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的代码是GitHub 上的<a class="ae jt" href="https://github.com/GoogleCloudPlatform/training-data-analyst/tree/master/blogs/popdensity" rel="noopener ugc nofollow" target="_blank">，所以请查看更大上下文的报告— </a><a class="ae jt" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/blogs/popdensity/convert_to_rect.py" rel="noopener ugc nofollow" target="_blank"> convert_to_rect.py </a>是使用矩形的新代码，而<a class="ae jt" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/blogs/popdensity/convert_to_geo.py" rel="noopener ugc nofollow" target="_blank"> convert_to_geo.py </a>是使用像素的旧代码。注意，创建矩形实质上是在具有相同值的像素行中向前寻找，并创建端点的geo。</p><p id="b9f4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">地理代表是:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="f17b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个有趣的区别。在最初的文章中，我使用众所周知的文本(WKT)格式表示了一个像素多边形，并以逆时针顺序遍历像素的顶点:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="eb55" class="ju jv hi ln b fi lr ls l lt lu">POLYGON((-11.3000 -72.3000, -11.3000 -72.4000, -11.2000 -72.4000, -11.2000 -72.3000, -11.3000 -72.3000))</span></pre><p id="175f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，这在表示更大的矩形时会失败，例如:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="32a8" class="ju jv hi ln b fi lr ls l lt lu">POLYGON((-11.3000 -72.3000, <strong class="ln hj">-11.3000</strong> -72.4000, <strong class="ln hj">169.9000</strong> -72.4000, 169.9000 -72.3000, -11.3000 -72.3000))</span></pre><p id="c468" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于从经度=-11.3到经度=-169.9的最短路径不是向东走而是向西走，而且两边其实都是大圆！因为WKT格式是在球形地球上定义的，所以没有简单的方法来表示我们想要的多边形——实际的定义变得相当奇怪:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lv"><img src="../Images/f2a10bcdaad4251c228b0de710440b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*KVtvFmI7EnSDsUM5ssyjzQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">如果我们用WKT的球形表示法来表示大的多边形，会产生奇怪的形状</figcaption></figure><p id="2d6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们应该使用GeoJSON写出矩形:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="6824" class="ju jv hi ln b fi lr ls l lt lu">SELECT ST_GeogFromGeoJson("{ \"type\":\"Polygon\", \"coordinates\": [ [ [-11.3000, -72.3000], [-11.3000, -72.4000], [169.9000, -72.4000], [169.9000, -72.3000], [-11.3000, -72.3000]]] }") AS geom</span></pre><p id="1143" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这提供了我们实际想要的形状(使用<a class="ae jt" href="https://bigquerygeoviz.appspot.com/" rel="noopener ugc nofollow" target="_blank"> BigQuery GeoViz </a>来像这样可视化各个形状):</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lw"><img src="../Images/a174c75657742bb2bc1272d04d231e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3dtVK84P_ntdAVhLRukcg.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">GeoJson表示法给出了我们想要的结果:南极洲的大片区域具有相同的人口密度，我们可以将其表示为单个矩形，而不是像素。</figcaption></figure><h2 id="605e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">用矩形加载表格</h2><p id="0be7" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">运行程序在NASA人口密度数据集上创建矩形后，我将换行符分隔的JSON加载到BigQuery:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="6c0a" class="ju jv hi ln b fi lr ls l lt lu">bq load --replace \<br/>   --source_format NEWLINE_DELIMITED_JSON \<br/>   --range_partitioning=year,1900,2100,5 \<br/>   --clustering_fields tile \<br/>   advdata.${TABLE} $GCSFILE schema.json</span></pre><p id="06e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中模式指定该列为地理类型:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="8dca" class="ju jv hi ln b fi lr ls l lt lu"> {<br/>    "description": "polygon representing boundary of rectangle",<br/>    "mode": "REQUIRED",<br/>    "name": "bounds",<br/>    "type": "GEOGRAPHY"<br/>  },</span></pre><p id="9c56" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我看到存储减少了5倍，结果表中的行数减少了7倍:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="ecd7" class="ju jv hi ln b fi lr ls l lt lu">    Pixels:      457 MB, 2139k rows<br/>    Rectangles:   96 MB,  319k rows</span></pre><p id="6e7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将人口数据集进行游程编码为矩形而不是像素真的很有帮助！</p><h2 id="c374" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">查询表</h2><p id="c606" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">让我们运行一个查询来查找华盛顿州人口最多的城市。我们可以通过将栅格转矩形数据与城市边界的公共数据集关联来实现这一点:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="fadc" class="ju jv hi ln b fi lr ls l lt lu">WITH urban_populations AS (<br/>    SELECT <br/>       lsad_name<br/>       , SUM(ST_AREA(ST_INTERSECTION(bounds, urban_area_geom))/1000000) AS area_sqkm<br/>       , COUNT(1) AS num_rectangles<br/>       , AVG(population_density) AS pop_density<br/>    FROM advdata.popdensity_nasa, `bigquery-public-data.geo_us_boundaries.urban_areas`<br/>    WHERE ST_INTERSECTS(bounds, urban_area_geom) <br/>          AND STRPOS(lsad_name, ', WA') &gt; 0<br/>    GROUP BY lsad_name<br/>)<br/>SELECT <br/>       *, (area_sqkm * pop_density / 1000000) AS population_millions<br/>FROM urban_populations<br/>ORDER BY area_sqkm DESC<br/>LIMIT 10</span></pre><p id="2c9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，与基于像素的数据集相比，我们处理了一半的数据(因此是两倍的成本效益),速度提高了20%。结果是:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lx"><img src="../Images/a6a5e0df4acf183de0aaafcbf7d4677c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tp9qDe0jG4qsftpECM3ldg.png"/></div></div></figure><p id="e474" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你与前一篇博客中的结果进行比较，你会注意到西雅图的人口(160万)比我们上次得到的(300万)少。那是因为这个查询实际上更准确。</p><p id="b02d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们有了逐像素的数据时，我简单地总结了所有与西雅图边界重叠的像素的面积:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="0ca0" class="ju jv hi ln b fi lr ls l lt lu">ST_AREA(bounds)</span></pre><p id="79cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在矩形可能要大得多，但是，我必须只计算实际相交的面积:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="5b83" class="ju jv hi ln b fi lr ls l lt lu">ST_AREA(ST_INTERSECTION(bounds, urban_area_geom))</span></pre><p id="1d23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，这要准确得多，即使在使用逐像素数据时，我也应该这样做。然而，有一个颇具讽刺意味的问题，因为人口密度是在更大的正方形上计算的。对低分辨率数据的更精确的计算将产生具有更大误差的结果！</p><h2 id="2236" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">从像素到矩形的ELT</h2><p id="e320" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">在上一节中，我重写了ETL程序，将人口密度栅格网格转换为GeoJson矩形，并将数据重新加载到BigQuery中。</p><p id="1f79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能避免重新创建ETL脚本吗？在上一篇文章中，我将来自SEDAC的高分辨率数据作为像素加载到BigQuery中——考虑到这是NASA数据的100倍，如果我可以避免重新加载数据，这将是一个优势。<em class="ly"> </em>那么……我可以简单地把像素数据转换成矩形吗？</p><p id="ae7c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是啊！将像素数据分组成行，并调用ST_Union。在BigQuery中，St_UNION分解边界，因此最终结果将是一组矩形。</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="50e5" class="ju jv hi ln b fi lr ls l lt lu">CREATE OR REPLACE TABLE advdata.sedac_rectangles AS<br/>PARTITION BY RANGE_BUCKET(year, GENERATE_ARRAY(2000, 2100, 5))<br/>CLUSTER BY tile<br/>OPTIONS(require_partition_filter=True)</span><span id="7f9b" class="ju jv hi ln b fi lz ls l lt lu">with dissolved AS (<br/>SELECT <br/>  year, tile, rowno, population_density,<br/>  ST_UNION( ARRAY_AGG(bounds) ) AS bounds,<br/>FROM advdata.sedac_pixels<br/>GROUP BY year, tile, rowno, population_density<br/>)</span><span id="67a7" class="ju jv hi ln b fi lz ls l lt lu">SELECT *, ST_CENTROID(bounds) AS location<br/>FROM dissolved</span></pre><p id="393f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将表的存储减少了3.5倍，表的数量减少了9倍，与NASA的数据一样:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="4110" class="ju jv hi ln b fi lr ls l lt lu">Pixels:         57.03 GB       223m rows<br/>Rectangles:     17.79 GB        28m rows</span></pre><p id="a107" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，许多行是多多边形，这就是为什么存储方面的改进不如行数方面的改进那么显著。这不如从零开始重新加载数据，因为我们得到的将是多多边形(考虑在一个图块中有多个具有相同人口密度的矩形的情况):</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ma"><img src="../Images/de257fccb142ef424bcd0b85432a4b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgtXqbrJyyK3hJ9kdYRdpA.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">当进行ST_Union时，您将得到多重多边形，这对于空间查询来说不如在ETL程序中进行游程编码时得到的多边形有效</figcaption></figure><p id="2d86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这表明BigQuery为决定是否处理某一行而进行的一些空间优化将不适用于这些数据。因此，如果我们有能力这样做，我们应该加载矩形，如果我们能像我对NASA数据(前一节)所做的那样，而不是使用ST_Union进行事后转换。当我写这篇文章时，我正在家里工作(感谢cornavirus ),我家的带宽不允许我下载和上传SEDAC数据...所以我没有选择… 无论如何，这只是表明BigQuery是强大和灵活的，如果你想你可以ELT大型栅格网格，如果你需要…</p><p id="0b08" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以像以前一样尝试相同的查询，确保指定图块:</p><pre class="kv kw kx ky fd lm ln lo lp aw lq bi"><span id="2389" class="ju jv hi ln b fi lr ls l lt lu">WITH urban_populations AS (<br/>        SELECT <br/>           lsad_name<br/>           , SUM(ST_AREA(ST_INTERSECTION(bounds, urban_area_geom))/1000000) AS area_sqkm<br/>           , COUNT(1) AS num_rectangles<br/>           , AVG(population_density) AS pop_density<br/>        FROM advdata.popdensity_sedac_rectangles, `bigquery-public-data.geo_us_boundaries.urban_areas`<br/>        <strong class="ln hj">WHERE </strong>year = 2020 <br/>              AND <strong class="ln hj">tile = 'gpw_v4_population_density_rev11_2020_30_sec_1.asc'</strong><br/>              AND ST_INTERSECTS(bounds, urban_area_geom) <br/>              AND STRPOS(lsad_name, ', WA') &gt; 0<br/>        GROUP BY lsad_name<br/>    )<br/>    SELECT <br/>           *, (area_sqkm * pop_density / 1000000) AS population_millions<br/>    FROM urban_populations<br/>    ORDER BY area_sqkm DESC<br/>    LIMIT 10</span></pre><p id="776c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果显示结果的更高分辨率(参见num_rectangles):</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/fda71e51b8f9559bb49cebae0c894502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlMxZhhJ-k3hzC4rwo36Qw.png"/></div></div></figure><p id="b3f9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该查询处理的数据是相应像素查询的一半(2.6 GB对5.4 GB)，但花费的时间是后者的四倍(26秒对6秒)，因为无法过滤掉这么多的多重多边形。</p><p id="1c94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">底线:虽然您可以将数据作为像素加载，然后使用ST_Union将它们转换成多边形，但这不如在您的ETL程序本身中将像素游程编码成多边形有效。</p><h2 id="9249" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">后续步骤:</h2><ol class=""><li id="039e" class="mc md hi iz b ja kp jd kq jg me jk mf jo mg js mh mi mj mk bi translated">阅读上一篇关于BigQuery 中的<a class="ae jt" rel="noopener" href="/@lakshmanok/querying-geographic-raster-data-in-bigquery-the-brute-force-way-1da46799d65f">栅格数据的文章，了解更多内容</a></li><li id="c3b6" class="mc md hi iz b ja ml jd mm jg mn jk mo jo mp js mh mi mj mk bi translated">在GitHub 上浏览<a class="ae jt" href="https://github.com/GoogleCloudPlatform/training-data-analyst/tree/master/blogs/popdensity" rel="noopener ugc nofollow" target="_blank">代码</a></li><li id="b375" class="mc md hi iz b ja ml jd mm jg mn jk mo jo mp js mh mi mj mk bi translated">按照README.md文件中的步骤尝试代码</li></ol><h2 id="199e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">关键点:</h2><ol class=""><li id="cf6d" class="mc md hi iz b ja kp jd kq jg me jk mf jo mg js mh mi mj mk bi translated">将栅格数据加载到BigQuery时，将图像表示为一组矩形。这类似于对数据进行游程编码，将降低存储成本并加快查询速度。</li><li id="9aa3" class="mc md hi iz b ja ml jd mm jg mn jk mo jo mp js mh mi mj mk bi translated">与WKT制图表达相比，我更喜欢GeoJson制图表达，因为GeoJson的平面制图表达更加直观</li><li id="060d" class="mc md hi iz b ja ml jd mm jg mn jk mo jo mp js mh mi mj mk bi translated">您可以使用BigQuery GeoViz快速排除形状故障</li><li id="0c57" class="mc md hi iz b ja ml jd mm jg mn jk mo jo mp js mh mi mj mk bi translated">您可以将栅格数据作为像素进行ELT，然后在BigQuery中使用ST_Union将它们转换为矩形。但是，这不如通过在ETL程序中进行游程编码将数据作为矩形加载到BigQuery中有效。</li></ol><p id="37a4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">鸣谢:感谢我的同事迈克尔·恩廷和埃里克·恩格尔的许多有益的讨论。</p></div></div>    
</body>
</html>