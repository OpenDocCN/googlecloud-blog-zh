<html>
<head>
<title>Scaling Google BigQuery analytic functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缩放Google BigQuery分析函数</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/scaling-google-bigquery-analytical-functions-5fe6f098479e?source=collection_archive---------1-----------------------#2020-11-16">https://medium.com/google-cloud/scaling-google-bigquery-analytical-functions-5fe6f098479e?source=collection_archive---------1-----------------------#2020-11-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3ae3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank"> Google BigQuery </a>，Google的数据仓库解决方案，有很多功能和能力。</p><p id="efab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/analytic-function-concepts" rel="noopener ugc nofollow" target="_blank">分析函数</a>计算一组行的值，并为每行的<em class="je">返回一个结果。这不同于聚合函数，聚合函数为一组</em>行<em class="je">返回单个结果。</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/d35f0db9f6f4a5e6891102c976ac7843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1-CVYo5SBoBCPX9q_SPmg.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">来源:<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/analytic-function-concepts#syntax" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/big query/docs/reference/standard-SQL/analytic-function-concepts #语法</a></figcaption></figure><p id="e6d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于BigQuery的每个节点内存限制，这些强大的数据集函数可能会达到“资源超出异常”的错误。</p><p id="52f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将看看两个最常用的函数是RANK()和DENSE_RANK()，以及如何为这些函数使用更大的分区。</p><h2 id="a733" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated"><strong class="ak">按日期分区</strong></h2><p id="6768" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">通过按日期划分窗口功能，可以避免在单个节点上操作:</p><p id="a2cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RANK() OVER(按日期分区，按公制DESC排序)</p><p id="989e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这对你来说还不够，你只能使用更快更简单的解析函数:ROW_NUMBER()和LAG()，手动计算RANK()和DENSE_RANK()。</p><h2 id="7c41" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">一个例子</h2><p id="309f" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们将使用Wikipedia<em class="je">` BigQuery-public-data . Wikipedia . pageviews _ 2020 `</em>上的big query公共数据集来计算每小时查看最多的页面和wiki的排名。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">带有BigQuery内置分析函数的示例查询</figcaption></figure><p id="5b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了限制BQ测试的成本，我们可以扫描更少的数据，参见上面的WHERE条件。我们可以稍后删除此过滤器。</p><p id="97d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在同一个窗口看到RANK()、DENSE_RANK()和ROW_NUMBER()是如何比较的。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kx"><img src="../Images/0f72d28c1bdcd99513eb3e28019ec95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlW_x4GIwKTGUu5rtH6kTA.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">使用BigQuery内置的分析函数查询结果</figcaption></figure><p id="59ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，对于由<em class="je"> datehour、wiki </em>标识的每个分区，我们可以仅使用ROW_NUMBER()来计算RANK():</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">RANK()备选项</figcaption></figure><p id="d006" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以只使用ROW_NUMBER()来计算DENSE_RANK():</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">DENSE_RANK()替代</figcaption></figure><p id="c9a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以将这些结果与BQ的内置函数进行比较:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">将BQ内置RANK()和DENSE_RANK()与手动计算的值进行比较的查询</figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ky"><img src="../Images/11877e811b9f0ec0842d9426af547f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxOEKpNDQC-Y1xM6_rx2_A.png"/></div></div></figure><h2 id="2a44" class="jv jw hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">它的伸缩性更好吗？</h2><p id="6f4a" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">让我们使用带有DENSE_RANK()函数的wiki " <em class="je"> en </em>"语料库，尝试通过<em class="je"> wiki </em>对2020年全年进行分区:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">这在wiki“en”的大型wiki语料库上失败，但在较小的“pt.b”上仍然有效</figcaption></figure><p id="d3b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将失败，并显示“查询执行期间超出资源”错误。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es kz"><img src="../Images/3f3715ec413826be23fac5eabf2ea622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*XdF2oIw08lJo87qOsQqRzA.png"/></div></figure><p id="9579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用替代的DENSE_RANK():</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="kv kw l"/></div></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es la"><img src="../Images/5773192555785348a7f75212f2ab4b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*hB8YDqvcrIGw_uPRYuKsWw.png"/></div></figure><p id="c9cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以为<em class="je"> my_rnk </em>和<em class="je"> my_drnk </em>子查询创建表，以加快处理速度。</p><h1 id="ceee" class="lb jw hi bd jx lc ld le kb lf lg lh kf li lj lk ki ll lm ln kl lo lp lq ko lr bi translated">结论</h1><p id="6d04" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">BigQuery的分析功能是强大的工具，可以将困难且计算昂贵的查询简化为更简单的解决方案。</p><p id="61e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当您的数据对于分析函数来说太大时，您可以用一种更加手动而不那么神奇的方式获得相同的结果，直到BigQuery将处理所有这些。</p></div></div>    
</body>
</html>