# 谷歌云发布/订阅订单交付

> 原文：<https://medium.com/google-cloud/google-cloud-pub-sub-ordered-delivery-1e4181f60bc8?source=collection_archive---------0----------------------->

![](img/60e6d85e0dc8467ef0cf1de5fd2254ac.png)

Google Cloud Pub/Sub 团队很高兴地宣布,[订购交付](https://cloud.google.com/pubsub/docs/ordering)现已全面推出。这项新功能允许订阅者按照消息发布的顺序接收消息，而不会牺牲规模。本文详细讨论了该特性的工作原理，并讨论了在分布式系统中按顺序处理消息时的一些常见问题。

# 订购基础

云发布/订阅中的订购由两个属性组成。第一个是在发布消息时设置的[排序键](https://cloud.google.com/pubsub/docs/publisher#using_ordering_keys)。这个字符串——最大为 1KB——表示应该为其排序消息的实体。例如，它可以是用户 ID 或数据库中某一行的主键。第二个属性是订阅的 [enable_message_ordering 属性。当此属性为 true 时，订阅方按照服务接收消息的顺序接收排序关键字的消息。](https://cloud.google.com/pubsub/docs/ordering#enabling_message_ordering)

这两个属性允许发布者和订阅者独立决定消息是否被排序。如果发布者没有指定消息的排序键，或者订阅者没有启用有序传递，则消息传递是无序的，其行为就像没有有序传递功能的云发布/订阅一样。并非某个主题的所有订阅都需要具有相同的 enable_message_ordering 设置。因此，接收相同消息的不同用例可以确定它们是否需要有序交付，而不会相互影响。

排序键的数量只受 1KB 字符串所能表示的内容的限制。每个排序关键字的发布吞吐量限制为 1MB/s。一个主题上所有排序关键字的吞吐量限制为[发布区域中可用的配额](https://cloud.google.com/pubsub/quotas)。这一限制可以提高到许多 GBs/s。

所有的[云发布/订阅客户端库](https://cloud.google.com/pubsub/docs/reference/libraries)都有对有序交付的丰富支持。它们是利用这一特性的最佳方式，因为它们负责确保消息按顺序处理所需的大量细节。有序交付适用于所有三种类型的用户:[流拉](https://cloud.google.com/pubsub/docs/pull#asynchronous-pull)、[拉](https://cloud.google.com/pubsub/docs/pull#synchronous_pull)和[推](https://cloud.google.com/pubsub/docs/push)。

# 排序属性

有序交付有三个主要属性:

1.  **Order** :当订阅启用了消息排序时，订阅者按照服务接收消息的顺序接收在同一地区发布的具有相同排序关键字的消息。
2.  **一致重发**:如果一条消息被重发，那么在该消息之后收到的相同排序关键字的所有消息也将被重发，无论它们是否已经被确认。
3.  **相似性**:如果有排序关键字未完成的消息发送给流拉用户，则其他已发送的消息将被发送给该用户。如果某个排序关键字当前没有未完成的消息，该服务会尽最大努力将消息传递给最后一个接收该关键字消息的订户。

让我们通过一个例子来检验这些属性的含义。假设我们有两个排序键，A 和 b。对于键 A，我们按顺序发布消息 1、2 和 3。对于密钥 B，我们依次发布消息 4、5 和 6。有了 ordering 属性，我们保证 1 在 2 之前送达，2 在 3 之前送达。我们也保证 4 在 5 之前送到，5 在 6 之前送到。请注意，不同排序键之间的消息顺序没有保证。例如，消息 1 可以在消息 4 之前或之后到达。

第二个属性解释了当消息被重新传递时会发生什么。一般来说，云发布/订阅至少提供一次交付。这意味着消息可能被多次发送给订阅者，即使这些消息已经被确认。有了一致的重新传递保证，当消息被重新传递时，在重新传递的消息之后接收的相同排序关键字的整个后续消息序列也将被重新传递。在上面的例子中，假设一个订户收到了消息 1、2 和 3。如果消息 2 被重新传递(因为 ack 截止时间到期或者因为尽力而为 ack 没有在云发布/订阅中持续)，那么消息 3 也保证被重新传递。

最后一个属性定义了相同排序键的消息被传递到哪里。它仅适用于流拉用户，因为他们是唯一拥有可用于亲缘关系的长期连接的用户。该属性有两个部分。首先，当消息对于流拉用户是未完成的时，意味着 ack 截止时间还没有过去，并且消息还没有被确认，那么如果对于排序键有更多的消息要传递，它们将转到同一个用户。

第二部分与没有未完成的消息时发生的情况有关。理想情况下，我们希望相同的订户处理一个排序关键字的所有消息。云发布/订阅试图做到这一点，但在某些情况下，它不能保证将继续向同一订户传递消息。换句话说，键的相似性可能会随着时间而改变。通常这样做是为了负载平衡。例如，如果只有一个订户，所有消息都必须传递给它。如果另一个用户启动，人们通常希望它开始接收一半的负载。因此，一些排序关键字的相似性必须从第一个订户移动到这个新订户。云发布/订阅会等待，直到排序键上不再有未完成的消息，然后再更改键的关联。

# 规模化有序交付

订单交付最困难的问题之一是规模化。通常需要事先了解题目的尺度特征。当一个话题超出这个范围时，维持秩序就变得极其困难。云发布/订阅的有序交付旨在随着使用情况而扩展，用户无需考虑这一点。

最常见的大规模订购方式是使用分区。一个主题可以由许多分区组成，每个分区存储发布到该主题的消息的子集。当消息发布时，为该消息选择一个分区，或者显式地，或者通过将消息的键或值散列到一个分区。这种情况下的“键”就是云 Pub/Sub 所说的排序键。

订阅服务器连接到一个或多个分区，并从这些分区接收消息。与发布端非常相似，订阅者可以显式地选择分区，或者依靠消息服务将订阅者分配到分区。基于分区的消息传递服务保证同一分区内的消息按顺序传递。

典型的分区设置如下所示:

![](img/a140306ead9b077c787f80f86e985f9f.png)

绿框代表存储消息的分区。它们属于消息服务器(通常称为“代理”)，但是为了简单起见，我们省略了这些服务器。圆圈代表消息，颜色表示消息关键字，数字表示该颜色消息的相对顺序。

一个系统的分区通常比键少得多。在上面的示例中，有四种消息颜色，但只有三个分区，因此第二个分区包含蓝色和红色消息。有两个订阅者，一个使用第一个分区，另一个使用第二和第三个分区。

在使用分区时，用户可能需要处理三个主要问题:订阅者伸缩限制、热碎片和行首阻塞。让我们详细看看每一个。

# 订户扩展限制

在一组对消息传递进行负载平衡的订户(通常称为“使用者组”)中，任何时候都只能将一个订户分配给一个分区。因此，可以发生的最大并行处理量是 min(分区数和订阅数)。在上面的示例中，我们可以在不超过三个订户之间进行负载平衡:

![](img/536eccc5bfe0950f612c8429a0ca58a2.png)

如果处理消息的成本突然变得更高，或者(更有可能的情况是)添加了一个新的使用者组来接收新管道中需要更长时间处理的消息，则可能无法获得足够的并行性来处理所有发布的消息。一种解决方案是让一个订阅者负责重新发布带有更多碎片的主题消息，而原始订阅者可以使用这些碎片:

![](img/f92518d6aab6652ccc714ff190901b35.png)

不利的一面是，现在这两个主题都必须保留，或者必须进行仔细的迁移，以更改原始发布者来发布新主题。如果两个主题都被维护，那么消息被存储两次。一旦第一个主题中的消息发布到第二个主题，就可以删除它们，但是这需要将接收消息的订阅者从原始主题迁移到新主题。

# 热碎片

下一个问题是热碎片——单个分区的过载。理想情况下，跨分区的流量模式相对相似。但是，与散列到其他分区的消息相比，散列到一个分区的消息可能要多得多或大得多。因此，单个分区可能会过载:

![](img/ed5b442cc24c24f9ca753ea3dcf14cfd.png)

如何处理这种高温碎片？通常，解决方案是添加分区。但是，在重新分区期间维持秩序可能非常困难。例如，如果我们在上面的例子中添加一个新的分区，它可能导致相关的消息到达完全不同的分区:

![](img/0355b13152e770ec846db864d031cfd3.png)

有了这组新的分区，紫色消息现在发布到第一个分区，蓝色消息发布到第三个分区，黄色和红色消息发布到第四个分区。这种重新划分导致了几个问题。首先，第四个分区现在包含了以前在两个订户之间拆分的密钥的消息。这意味着键对订阅者的亲和力必须改变。

更困难的是，如果订阅者希望所有消息都有序，他们必须仔细协调何时从哪个分区接收消息。在添加更多分区之前，订阅者必须知道每个分区中用于消息的最后偏移量。然后，他们需要使用这些偏移量以内的消息。在处理完所有分区中的消息偏移量之后，订阅者可以开始使用超出最后一个偏移量的消息。

# 行首阻塞

最后一个难题是行首阻塞，即由于必须首先消费的消息处理缓慢而无法处理消息。让我们回到最初的场景:

![](img/0ced032c9ff9d0b89f2a20b1ae03a87c.png)

想象一下，红色信息比蓝色信息需要更多的时间来处理。当从第二分区读取消息时，由于红色消息 1 的缓慢处理，蓝色消息 2 的处理可能被不必要地延迟。因为排序的单位是一个分区，所以没有办法在不处理红色消息的情况下处理蓝色消息。人们可以尝试通过重新分区来解决这个问题，希望红色和蓝色消息最终出现在不同的分区中。然而，对红色消息的处理将会阻塞其他消息在它们结束的分区中的处理。重新分区还会导致热碎片一节中讨论的相同问题。

或者，发布者可以显式地将红色消息分配给它们自己的分区，但是如果发布者必须根据订阅者处理消息的方式做出决策，那么这就打破了发布者和订阅者的分离。也可能是红色消息的额外处理时间是暂时的，并不保证对系统进行大规模的更改。用户必须决定是延迟处理某些消息好，还是改变分区的艰苦过程好。

# 订购时自动缩放

云发布/订阅的有序交付实现旨在使用户无需受到此类限制。它可以扩展到数十亿个密钥，而没有用户扩展限制、热碎片或线路头阻塞。正如人们对高吞吐量发布/订阅系统的预期，消息被拆分到云发布/订阅的底层分区中。但是，该服务有两个主要属性，允许它克服通常与有序交付相关的问题:

1.  分区不向用户公开。
2.  订阅服务器单独确认消息，而不是推进分区游标。

通过利用这些属性，云发布/订阅代理有三种有用的行为:

1.  它们将订阅者分配给比分区更细粒度的排序键组。
2.  它们跟踪每个关键字的发布速率，并根据需要扩展到适当的分区数量，从而在重新分区时保持正确的有序交付。
3.  它们基于每个排序键存储消息的顺序，因此传递不会被同一分区中尚未处理的其他键的消息阻塞。

这些行为允许云发布/订阅避免大规模有序交付的所有三个主要问题！

当然，订购的快递不是免费的。与无序传递相比，消息的有序传递可能会略微降低发布可用性并增加端到端消息传递延迟。与无序情况不同，在无序情况下，交付可以毫无延迟地故障转移到任何代理，而有序情况下的故障转移需要跨代理进行协调，以确保消息被写入正确的分区和从正确的分区读取。

# 有效使用有序交付

即使 Cloud Pub/Sub 能够大规模有序地传递消息，依赖有序传递时仍然存在一些微妙之处。本节详细介绍了构建有序管道时需要记住的事项。当使用具有有序传递的其他消息传递系统时，其中一些事情也适用。为了提供一个如何有效使用排序键的好例子，Cloud Pub/Sub 团队发布了其排序键探测器的[开源版本。这个探测器与团队为了验证这个新特性的正确行为而连续运行的探测器几乎相同。](https://github.com/GoogleCloudPlatform/pubsub/tree/master/ordering-keys-prober)

# 有序发布

从表面上看，按顺序发布似乎非常容易:只需为每条消息调用 publish。如果我们能保证发布永远不会失败，那么事情就这么简单了。然而，发布随时都可能发生暂时或永久的失败，发布者必须了解这些失败的含义。

让我们举一个简单的例子，尝试为相同的排序键 A 发布三条消息:1、2 和 3。发布这些消息的 Java 代码可能如下:

```
String[] messages = {"1", "2", "3"};
for (String msg : messages) {
  PubsubMessage message = PubsubMessage.newBuilder()
      .setData(ByteString.copyFromUtf8(msg))
      .setOrderingKey("A")
      .build();
  ApiFuture<String> publishFuture = publisher.publish(message);
  publishFuture.addListener(() -> {
    try {
      String messageId = publishFuture.get();   
      System.out.println("Successfully published " + messageId);
    } catch (Exception e) {
      System.err.println("Could not publish message "+ msg);
    }
  }, executor);
}
```

如果没有失败，那么每个发布调用都将成功，并且消息 ID 将在将来返回。我们希望订阅者按顺序接收消息 1、2 和 3。然而，有很多事情可能会发生。如果发布失败，可能需要再次尝试。云发布/订阅客户端库在内部重试可重试错误的请求。诸如超过截止时间之类的错误并不表示发布实际上是否成功。可能发布确实成功了，但是客户端没有在截止日期前及时收到发布响应，在这种情况下，客户端可能再次尝试了发布。在这种情况下，消息序列可以具有重复，例如 1、1、2、3。每条发布的消息都有自己的消息 ID，因此从订阅者的角度来看，看起来像是发布了四条消息，前两条具有相同的内容。

通过[批处理](https://cloud.google.com/pubsub/docs/publisher#batching)，重试发布请求变得更加复杂。当客户端库将消息发送到服务器时，可能会将消息成批发送到一起，以提高发布效率。这对于高吞吐量的主题尤其重要。在上面的例子中，消息 1 和 2 可能被一起批处理，并作为单个请求发送到服务器。如果服务器未能及时返回响应，客户端将重试这一批两个消息。因此，订户可能会看到消息 1、2、1、2、3 的序列。如果想要避免这些成批重新发布，最好设置成批设置，以便在每批中只允许一条消息。

发布还有一个可能导致问题的情况。假设在运行上述代码时，发生了以下事件序列:

1.  用消息 1 调用 Publish。
2.  用消息 2 调用 Publish。
3.  消息 1 的发布暂时失败。
4.  用消息 3 调用 Publish。

结果可能是消息 2 和/或 3 被成功发布并发送给订户，而消息 1 没有被发送，这将导致无序传递。一个简单的解决方案可能是使发布调用同步:

```
String[] messages = {"1", "2", "3"};
for (String msg : messages) {
  PubsubMessage message = PubsubMessage.newBuilder()
      .setData(ByteString.copyFromUtf8("1"))
      .setOrderingKey(msg)
      .build();
  boolean successfulPublish = false;
  while (!successfulPublish) {
    ApiFuture<String> publishFuture = publisher.publish(message);
    try {
      String messageId = publishFuture.get();
      System.out.println("Successfully published "+ messageId);
      successfulPublish = true;
    } catch (Exception e) {
      System.err.println("Could not publish message "+ msg);
    }
  }
}
```

虽然这种变化可以保证消息按顺序发布，但它会使大规模发布变得更加困难，因为每个发布操作都会阻塞一个线程。云发布/订阅客户端库通过两种方式克服了这个问题。首先，如果发布失败，并且在库的消息缓冲区中有其他消息排队等待相同的排序键，那么所有这些消息的发布也会失败。其次，该库会立即使对具有相同排序键的消息的任何后续发布调用失败。

当这种情况发生时，如何回到能够在排序键上发布的状态呢？客户端库公开一个方法 resume publish(String ordering key)。当发布者处理了失败的发布、确定了要做的事情，并准备好再次发布排序键的消息时，它应该调用 resumePublish。发布者可以决定按顺序重新发布所有失败的消息，发布消息的子集，或者发布一组全新的消息。无论发布者希望如何处理这种边缘情况，客户端库都提供 resumePublish 作为实现这一点的手段，而不会失去异步发布的伸缩优势。请看一下[订购键探测器的发布错误逻辑](https://github.com/GoogleCloudPlatform/pubsub/blob/69c0430bea73235fbd06f6222d92c5a6a91b55cf/ordering-keys-prober/src/main/java/com/google/cloud/pubsub/prober/OrderedProber.java#L166-L184)以获取如何使用 resumePublish 的示例。

上述所有问题都涉及到来自单个发布者的发布。但是，还有一个问题是如何从不同的发布者发布相同排序键的消息。云发布/订阅允许这样做，并保证对于同一地区的发布，订阅者看到的消息顺序与代理接收发布的顺序一致。例如，假设发布者 X 和 Y 都发布了订购密钥 a 的消息，如果 X 的消息在 Y 的消息之前被云发布/订阅接收，则所有订阅者都将看到该顺序的消息。但是，发布者无法知道服务接收消息的顺序。如果必须维护不同发布者之间的消息顺序，则发布者需要使用某种其他机制来协调他们的发布，例如，某种锁定服务来在发布时维护排序密钥的所有权。

重要的是要记住，排序保证只适用于在同一地区发布的消息。因此，强烈建议所有发布者使用[区域服务端点](https://cloud.google.com/pubsub/docs/reference/service_apis_overview#service_endpoints)来确保他们为相同的排序关键字向相同的区域发布消息。这对 GCP 以外的出版商尤为重要；如果请求从另一个地方被路由到 GCP，如果使用全局端点，路由总是可能改变，这可能会扰乱消息的顺序。

# 按顺序接收消息

订阅者按照消息发布的顺序接收消息。“按顺序接收消息”的含义因订户类型而异。云发布/订阅支持三种消息接收方式:[流拉](https://cloud.google.com/pubsub/docs/pull#asynchronous-pull)、[拉](https://cloud.google.com/pubsub/docs/pull#synchronous_pull)、[推](https://cloud.google.com/pubsub/docs/push)。客户端库使用流拉(PHP 除外)，我们从使用客户端库的角度讨论通过流拉接收消息。无论使用什么方法接收消息，记住云发布/订阅至少提供一次传递是很重要的。这意味着订阅者必须能够再次接收消息序列，如排序属性一节中所讨论的。让我们看看按顺序接收消息对每种类型的订户意味着什么。

# 流式拉取(通过客户端库)

当使用客户端库时，需要指定一个用户回调，每当接收到一条消息时就应该运行这个回调。客户端库保证对于任何给定的排序键，回调以正确的顺序在消息上运行到完成。如果消息在回调中得到确认，那么这意味着对消息的所有计算都按顺序进行。但是，如果用户回调计划对消息进行其他异步工作，订阅者必须确保异步工作按顺序完成。一种选择是将消息添加到按顺序处理的本地工作队列中。

值得注意的是，由于像这样的订阅者中的异步处理，云发布/订阅中的有序交付目前不适用于云数据流。数据流并行执行的本质意味着它不会在收到消息后保持消息的顺序。因此，用户的管道不能依赖于按顺序传递的消息。为了确保不在数据流中使用发布/订阅并期望有序交付，使用启用了排序键的订阅的数据流管道在启动时会失败。

# 拉

对于直接使用拉方法的订户，云发布/订阅提供两种保证:

1.  在 [PullResponse](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#google.pubsub.v1.PullResponse) 的 received_messages 列表中，排序键的所有消息在该列表中处于正确的顺序。
2.  每次每个排序键都有一个未完成的消息列表。

一次只能有一批消息处于未完成状态的要求是维护有序传递所必需的。云发布/订阅服务不能保证它为订户的拉请求发送的响应的成功或延迟。如果响应失败，并且后续的 pull 请求通过包含相同排序关键字的后续消息的响应来实现，则这些后续消息可能会在失败响应中的消息之前到达订户。它也不能保证后续的拉请求来自同一个订阅者。

# 推

对推的限制甚至比拉的更严格。对于推送订阅，云发布/订阅一次只允许每个订购密钥有一条未完成的消息。因为每个消息都是通过自己的请求发送给推送订阅者的，所以并行发送这样的请求与为同一个排序键同时发送多批消息给拉取订阅者具有相同的问题。因此，对于经常使用相同的排序键发布消息或延迟非常重要的主题，推送订阅者可能不是一个好的选择，因为这些限制可能会阻止订阅者跟上已发布的消息。

总之，大规模的有序交付通常需要对其消息传递系统的容量和设置非常小心。当超过该容量或消息处理特征改变时，在维持秩序的同时增加容量是一个耗时且困难的过程。随着 Cloud Pub/Sub 中有序交付的引入，用户可以在系统中以他们习惯的方式依赖订单，而系统仍然会根据他们的使用情况自动扩展。