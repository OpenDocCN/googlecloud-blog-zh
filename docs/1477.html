<html>
<head>
<title>Reading NULLABLE fields with BigQueryIO in Apache Beam</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Apache Beam中使用BigQueryIO读取可空字段</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/reading-nullable-fields-with-bigqueryio-in-apache-beam-f0e36e1f6c7?source=collection_archive---------0-----------------------#2020-06-21">https://medium.com/google-cloud/reading-nullable-fields-with-bigqueryio-in-apache-beam-f0e36e1f6c7?source=collection_archive---------0-----------------------#2020-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/74742fcbbb47505a742407d73953f467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3sUaUIzFQk8OI-BR"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@benhershey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本·赫尔希</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f8f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当在用Java编写的Apache Beam管道中使用<a class="ae iu" href="https://beam.apache.org/releases/javadoc/2.22.0/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIO.html" rel="noopener ugc nofollow" target="_blank"> BigQueryIO </a>从BigQuery读取数据时，您可以将记录读取为<code class="du jt ju jv jw b">TableRow</code>(方便但性能较低)或<code class="du jt ju jv jw b">GenericRecord</code>(额外的性能，但您的代码中可能也需要一些额外的工作)。</p><p id="de9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/google-cloud/reading-numeric-fields-with-bigqueryio-in-apache-beam-23273a9d0c99">在之前的一篇文章</a>中，我展示了当使用<em class="jx"> GenericRecord，</em>big query类型或多或少容易映射到Java类型NUMERIC除外，这需要一些额外的工作。</p><p id="7ef1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但这实际上只适用于<em class="jx">必需的</em>big query列。<strong class="ix hj">可空的<em class="jx">列</em>需要一些额外的解析，以便从记录中提取值。</strong></p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="9b6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在BigQuery中为表创建模式时，<a class="ae iu" href="https://cloud.google.com/bigquery/docs/schemas#modes" rel="noopener ugc nofollow" target="_blank">我们可以为列</a>提供三种不同的模式:<em class="jx">可空</em>、<em class="jx">必需</em>和<em class="jx">重复</em>。</p><p id="d409" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认模式是<em class="jx">可空</em>。可空字段可能包含该列类型的值，或者null。简单。</p><p id="34d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，当将BigQueryIO中的数据读取为<em class="jx"> GenericRecord </em>时，Avro模式没有可空类型。除了其他类型之外，它们还有一个空的类型。所以要指定一个字段可以包含空值，需要在Avro中为同一个字段指定几种类型。那其实叫<em class="jx">联</em>。例如，如果您的name <em class="jx"> myfield </em>字段包含字符串并且可为空，则Avro模式将如下所示:</p><pre class="kf kg kh ki fd kj jw kk kl aw km bi"><span id="37fc" class="kn ko hi jw b fi kp kq l kr ks">{"name": "myfield", "type": ["null", "string"]}</span></pre><p id="855c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="jx"> GenericRecord </em>中，<em class="jx"> myfield </em>的类型将是<em class="jx"> union </em>，我们需要遍历该字段的<em class="jx">类型</em>和<em class="jx">值</em>，以实际恢复<em class="jx"> myfield </em>的值(空值或字符串)。</p><p id="8d73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以让我们假设我们有以下两个变量(所有代码片段都是Java的):</p><pre class="kf kg kh ki fd kj jw kk kl aw km bi"><span id="42f5" class="kn ko hi jw b fi kp kq l kr ks">String fieldName;   // the name of the column<br/>GenericRecord rec;  // the values in the row to be parsed</span></pre><p id="a026" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以恢复该字段的模式和类型</p><pre class="kf kg kh ki fd kj jw kk kl aw km bi"><span id="d78d" class="kn ko hi jw b fi kp kq l kr ks">Schema fieldSchema = rec.getSchema().getField(fieldName).schema();<br/>Schema.Type type = fieldSchema.getType();</span></pre><p id="e3d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们应该检查类型是否是UNION</p><pre class="kf kg kh ki fd kj jw kk kl aw km bi"><span id="cf97" class="kn ko hi jw b fi kp kq l kr ks">if (type == Schema.Type.UNION) {      <br/>   // We have a NULLABLE field<br/>...</span></pre><p id="9bfe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们也可以检查<code class="du jt ju jv jw b">fieldSchema.getTypes()</code>的长度是1还是2。对于必填字段，该值为1；对于可空字段，该值为2。</p><p id="2e7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们检查了我们有一个可空字段之后，我们可以恢复类型，尝试识别空类型(在字段包含的两种类型中)，并使用另一种类型来解析值:</p><pre class="kf kg kh ki fd kj jw kk kl aw km bi"><span id="741c" class="kn ko hi jw b fi kp kq l kr ks">List&lt;Schema&gt; types = fieldSchema.getTypes();      <br/>// Let's see which one is the NULL and let's keep the other      <br/>if (types.get(0).getType() == Schema.Type.NULL) {        <br/>  type = types.get(1).getType();      <br/>} else {        <br/>  type = types.get(0).getType();      <br/>}</span></pre><p id="409c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，我们可以将该值解析为另一个<em class="jx">所需的</em>值(也就是说，只有一种类型)。请注意，如果表中的原始值为null，则该字段可能包含null。</p><p id="18fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看完整的代码片段:</p><figure class="kf kg kh ki fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="20ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从BigQuery读取时，不要放弃使用<em class="jx"> GenericRecord。</em>有时你将不得不做一些额外的解析，比如在这个例子中，当你使用数字字段时，使用NULLABLE或<a class="ae iu" rel="noopener" href="/google-cloud/reading-numeric-fields-with-bigqueryio-in-apache-beam-23273a9d0c99">，但是你将获得的额外性能值得多几行代码。</a></p><p id="5bb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于读取NULLABLE，请记住该类型将是两种类型的联合:字段的实际类型和null。读取值时要小心空值！</p></div></div>    
</body>
</html>