<html>
<head>
<title>Conditionally Initial or Delta Load BQ with Composer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Composer有条件地初始或增量加载BQ</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/conditionally-initial-or-delta-load-big-query-tables-w-one-dynamic-dag-b1cdb2915b65?source=collection_archive---------0-----------------------#2022-09-04">https://medium.com/google-cloud/conditionally-initial-or-delta-load-big-query-tables-w-one-dynamic-dag-b1cdb2915b65?source=collection_archive---------0-----------------------#2022-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="49ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">典型的数据复制作业包括两个阶段:初始加载和复制更改。为初始和增量加载的每个表构建单独的管道可能很耗时。</p><p id="f267" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好是建立一个元数据驱动的动态管道。</p><p id="8038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，你可以发现如何有条件地对任何表动态地使用相同的composer DAG进行初始或增量加载<strong class="ih hj">。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/73c6aa4a464b7f8e875f8009dc8bc445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4TZ7CQjMciupe281eyU8A.png"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="30d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的关键要素是<strong class="ih hj">branch pythonooperator</strong>，它使您能够根据条件对您的流进行分支；</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="b690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们将构建一个参数化DAG，它将LOAD_MODE作为一个参数。如果设置为<em class="jy">初始</em>，流程将继续执行<em class="jy">初始_加载_表</em>，或者如果设置为<em class="jy">增量</em>，流程将继续执行<em class="jy">辅助_表</em>任务。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="1ca2" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">如何处理增量变更</h2><p id="575d" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">一种方法是使用merge语句，通过一条语句和一次传递插入新记录并更新已更改的记录。</p><p id="0bc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在BigQuery中，典型的merge语句如下所示；</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="7eee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢<strong class="ih hj"> xcom variables </strong>，我们可以将表名、模式和键作为参数传递，并使我们的DAG完全动态，因此我们不需要每个表有一个单独的DAG。</p><p id="626a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是如何获取这些参数并推送给xcom变量，以便这些变量可以被其他任务使用；</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="f0e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经为准备合并语句做好了一切准备。为此，我们需要两项任务；第一，python操作符准备merge语句并将其推送到xcom变量，第二，BigQuery操作符运行merge语句。这是它的样子:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="328f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们已经为不同的类型定义了默认的“null”值。原因是；在BigQuery的连接中，空不等式不匹配。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="6af5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们如何从临时表中初始装载一个管理过的表？</p><p id="69f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这相对容易，我们只需要使用BigQuery操作符截断并写入表中；</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="b0ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意我们如何使用xcom变量来获得StagingTable和CuratedTable。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="3106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是全部，这里是<strong class="ih hj">完整的DAG代码</strong>；</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="1189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以像这样运行DAG w/config；</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="abdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博文中，我们有条件地从临时表中加载了管理表。如果您对如何从GCS动态加载BQ表以及如何运行参数化管道感兴趣，可以查看<a class="ae kz" rel="noopener" href="/google-cloud/dynamically-load-data-to-any-bigquery-table-from-gcs-835a6525afef">“从GCS动态加载数据到任何BigQuery表”帖子</a>。</p></div></div>    
</body>
</html>