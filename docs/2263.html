<html>
<head>
<title>Streaming JSON messages into BigQuery JSON-type column</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将JSON消息流式传输到BigQuery JSON类型的列</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/streaming-json-messages-into-bigquery-json-type-column-7b9702a49a36?source=collection_archive---------0-----------------------#2022-07-15">https://medium.com/google-cloud/streaming-json-messages-into-bigquery-json-type-column-7b9702a49a36?source=collection_archive---------0-----------------------#2022-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6b55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google最近宣布了BigQuery的新数据类型——JSON。因此，BigQuery用户能够插入半结构化的JSON消息，而不需要提供消息模式，也不需要将消息简化为结构化格式。然而，正如我们将在本文中展示的，在BigQuery表单元格中存储JSONs的可能性远不止这些:</p><ol class=""><li id="4784" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">BigQuery工程师用简单的SQL和对子结构和属性的简单点标记访问使得解析JSON结构变得非常容易。</li><li id="742f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">与大多数云数据仓库不同，BigQuery将JSON元素表示为存储级的单个虚拟列，因此BigQuery也能够对JSON列应用列压缩。</li><li id="73ab" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">作为#2的结果，当用户查询具有JSON列的表并只选择JSON消息中可用元素的子集时，BigQuery不需要读取整个JSON消息，而是能够只获取请求的元素，这大大减少了需要处理的字节数，从而提高了性能，并降低了按需BigQuery计划的成本，该计划具体取决于处理的字节数。</li><li id="8885" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">请看这个:用户可以<strong class="ih hj">将</strong> JSON消息直接流入带有JSON列的BigQuery表。</li></ol><p id="3d2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文旨在成为一个实践指南，展示上面列出的所有优点。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es jr"><img src="../Images/f4e59091e444e929e9759caede38ffb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*wS1-Kw0RFr2hR9ti.png"/></div></figure></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><h1 id="19d8" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">语境</h1><p id="7763" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">假设我们有一个验证电子商务交易的欺诈检测系统。每次有新的支付请求时，电子商务支付服务都会要求我们的系统对欺诈风险进行评分。评分由机器学习算法处理，该算法定期重新训练以从新数据中学习模式。训练用于欺诈检测的机器学习模型超出了本文的范围，但是我们将展示如何在我们的系统和数据分析后端之间建立一座桥梁，这些模型就是在这里制作的。因为机器学习模型从数据中学习，我们的桥的主要职责将是将传入的评分请求的有效载荷传递到数据湖，然后由我们的数据和机器学习工程师使用。</p><p id="a771" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就本文而言，在点击支付按钮和风险评分的机器学习模型之间发生的一切都是由数据流作业抽象的。该作业从流数据生成器模板实例化，以生成代表评分请求有效负载的JSON消息。</p><p id="0ddb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消息被发送到由GCP公共订阅服务处理的分布式队列，该服务将我们的欺诈检测系统与数据分析后端相分离。</p><blockquote class="lj lk ll"><p id="51d5" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">我们强烈推荐阅读Spotify如何将其事件交付系统从Kafka迁移到GCP PubSub:<a class="ae lq" href="https://cloud.google.com/blog/products/gcp/spotifys-journey-to-cloud-why-spotify-migrated-its-event-delivery-system-from-kafka-to-google-cloud-pubsub" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/blog/products/GCP/spotifys-journey-to-cloud-why-Spotify-migrated-its-event-delivery-system-from-Kafka-to-Google-cloud-PubSub</a>。</p></blockquote><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lr"><img src="../Images/8274af4b9ef1fb6ac7bf13a3196f26bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*k58KsCyco_56QF4AfDlxIA.png"/></div></figure><p id="8519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要的东西，将拉从GCP公共订阅主题的消息，因为他们来到，并把它们推到BigQuery。这项任务也将由数据流作业处理。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><h1 id="48e4" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">设置</h1><p id="17e8" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">以下是在Google Console中重现这种设置时需要做的一些事情的高级列表:</p><ol class=""><li id="5df5" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">为我们的消息创建发布订阅主题。我们的主题是随机事件:</li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/f805484ef53c159c9b06b5439853c655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbxEAIYUkYpGzgX5XN0vVg.png"/></div></div></figure><p id="47e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.创建服务帐户，该帐户将能够从/向您的PubSub主题读取和写入消息。</p><p id="e153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.我们的JSON消息将具有良好定义的模式，但值将非常随机，为了生成这样的消息，我们将使用流数据生成器模板使用的<a class="ae lq" href="https://github.com/vincentrussell/json-data-generator" rel="noopener ugc nofollow" target="_blank">数据生成器</a>库。流数据生成器模板将需要指向描述消息字段的所谓模式文件的路径。数据生成库允许我们为每个模式字段使用不同的faker函数:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lx"><img src="../Images/4139a35e5818bbfb107c7bb87acdfa48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R52bfarOFlOHdC3bd7vJwg.png"/></div></div></figure><p id="84a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的模式将由以下字段组成:</p><pre class="js jt ju jv fd ly lz ma mb aw mc bi"><span id="c1cc" class="md kh hi lz b fi me mf l mg mh">{<br/>  "id": "{{uuid()}}",<br/>  "email": "{{email()}}",<br/>  "ip": "{{ipv4()}}",<br/>  "phone": "{{phone()}}",<br/>  "age": "{{integer(1,50)}}",<br/>  "price": "{{double(1,1000)}}",<br/>  "tid": "{{timestamp()}}",<br/>  "country": "{{country()}}"<br/>}</span></pre><p id="db2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保存这个文件，上传到Google云存储桶。</p><p id="fc60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.从数据流生成器模板创建数据流作业。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mi"><img src="../Images/67b404aac46a4ee3d0a92b9927a3fdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5bF8DaolrBGiCOSctPJrg.png"/></div></div></figure><p id="5e6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模板有两个必需的参数:</p><ul class=""><li id="6a05" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc mj jj jk jl bi translated">模式位置的GCS路径，这是我们的消息的模式文件的位置。</li><li id="ff57" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc mj jj jk jl bi translated">输出QPP，这是预期的每秒输出消息数。我们用了100。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mk"><img src="../Images/b1e6d1325a83795ae5c542ba2024614d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o42c7RVjWsn7mo6MURcfYA.png"/></div></div></figure><p id="f6f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击<strong class="ih hj">运行作业</strong>按钮。您的数据流作业应该开始将消息流式传输到PubSub主题。</p><p id="29d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.用JSON列创建BigQuery表。JSON类型的语法相当简单:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ml"><img src="../Images/732e67a63e839e0cba4e53b478f120b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXYht-S5VOD2ECxlqjssTw.png"/></div></div></figure><p id="bad6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">bigquerydemos-337515代表GCP项目id (p <strong class="ih hj">请注意，您将需要自己的GCP项目。bigquerydemos-337515是我的</strong>)，dataflowsink表示BigQuery数据集名，jevents表示BigQuery表名。</p><h1 id="a601" class="kg kh hi bd ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld bi translated">结论</h1><p id="5d97" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">我们将从最后开始处理第1–4项，这意味着我们将首先在PubSub topic和BigQuery之间设置流作业，以将我们的JSON消息流式传输到带有JSON列的BigQuery表中。</p><blockquote class="lj lk ll"><p id="5f15" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">4.用户可以将<strong class="ih hj">JSON消息直接流入带有JSON列的BigQuery表。</strong></p></blockquote><p id="54bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这一次没有准备好重用的数据流模板。我们需要编码所谓的数据处理管道，可以理解为数据处理步骤的图形。</p><p id="3bf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如remainder: Dataflow是Apache Beam的托管服务——定义批处理和流数据并行处理管道的统一模型。Apache Beam就是这样——一些关于如何定义数据处理管道的建议，以便相同的代码可以在任何地方执行:本地，也可以在许多受支持的分布式执行引擎中的一个上执行，如Spark、Flink和……data flow。是的，Dataflow也是非常可扩展的分布式执行引擎。</p><p id="8f50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用java或python实现数据流处理图。这里我们使用了python。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="4330" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的管道由5个步骤组成:</p><ul class=""><li id="c49c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc mj jj jk jl bi translated">从PubSub主题中提取消息(由第16行的beam.io.ReadFromPubSub处理)</li><li id="1d32" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc mj jj jk jl bi translated">将PubSub消息(它只是一个字节流)转换成UTF-8编码的字符串(第19行)</li><li id="bb34" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc mj jj jk jl bi translated">BigQuery writer希望我们将BigQuery表行表示为带有<key value="">对的JSON，其中key表示列名，value表示该列的值(<a class="ae lq" href="https://beam.apache.org/releases/javadoc/2.2.0/org/apache/beam/sdk/io/gcp/bigquery/TableRowJsonCoder.html" rel="noopener ugc nofollow" target="_blank">https://beam . Apache . org/releases/javadoc/2 . 2 . 0/org/Apache/beam/SDK/io/GCP/big query/tablerowjsoncoder . html</a>)。我们的表只有一个名为event的JSON类型的列(第13行)。因此，我们需要告诉BigQuery，我们希望将我们的消息作为值注入到事件列中，并遵守<a class="ae lq" href="https://beam.apache.org/releases/javadoc/2.2.0/org/apache/beam/sdk/io/gcp/bigquery/TableRowJsonCoder.html" rel="noopener ugc nofollow" target="_blank"> TableRowJsonCoder </a>，对于我们的表，我们需要使用单个&lt;键、带有事件的值&gt;对作为键构建JSON，并将我们的JSON消息的字符串表示作为相应的值(第20行)。我们将json.dumps函数应用于我们的json消息，将其转换为转义字符串:例如:{"event": { "id": 10，" email ":"<a class="ae lq" href="mailto:foo@abc.com" rel="noopener ugc nofollow" target="_blank">foo@abc.com</a>" } }变成{ " event ":" { " id \ ":10，" email ":\ "<a class="ae lq" href="mailto:foo@abc.com" rel="noopener ugc nofollow" target="_blank">foo@abc.com</a>\ " } " }</key></li><li id="9648" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc mj jj jk jl bi translated">将代表TableRow JSON的字符串转换成JSON对象(第21行)。</li><li id="011c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc mj jj jk jl bi translated">使用beam.io.WriteToBigQuery模块将表示为TableRow对象的(流)消息写入BigQuery(第22行)。</li></ul><p id="37c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦执行，该代码将持续运行，作为从PubSub主题提取到BigQuery表的数据流作业流消息。</p><p id="f342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们想强调的一点是，我们不修改原始的JSON消息——我们只是传递它并指定它应该被分配给哪一列。没有必要对我们的JSON消息进行逆向工程。</p><p id="b0ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的最后一步是查询我们的目标BigQuery表:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mt"><img src="../Images/aec4ebb6256044b3713a4bd2a4988754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnkgThzF_9A9UXjRPEAarg.png"/></div></div></figure><blockquote class="lj lk ll"><p id="85d6" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">1.BigQuery工程师用简单的SQL和对子结构和属性的简单点标记访问使解析JSON结构变得非常容易。</p></blockquote><p id="1193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们转到Google Cloud控制台，使用BigQuery workbench查询我们的目标表，并使用点标记法从我们的JSON消息中选择属性的子集:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mu"><img src="../Images/4e376e4b16fbb4c09938be30a6031f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-aI79MGRO6FKgL0jkQdxA.png"/></div></div></figure><p id="1991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我们的JSON消息具有非常简单的模式，但是BigQuery中的点符号也可以用于遍历更复杂的结构。</p><blockquote class="lj lk ll"><p id="3f78" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">2.与大多数云数据仓库不同，在存储级别上，BigQuery将JSON元素表示为单独的虚拟列，因此BigQuery也能够对JSON列应用列压缩。</p><p id="35c4" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">3.作为#2的结果，当用户查询具有JSON列的表并只选择JSON消息中可用元素的子集时，BigQuery不需要读取整个JSON消息，而是能够只获取请求的元素，这大大减少了需要处理的字节数，从而提高了性能并降低了成本，因为在BigQuery按需计划中，成本具体取决于处理的字节数。</p></blockquote><p id="7e28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了验证这一点，让我们向目标BigQuery表发送两个查询。第一个将是经典的select star——因此BigQuery将读取所有JSON属性。第二个查询将只针对年龄属性:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mv"><img src="../Images/83d81b4a6085643f931d5144ef654b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duaG2AqoHCUKDoCMEqZ2Ew.png"/></div></div></figure><p id="75f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“职务信息”选项卡包含得出某些结论所需的所有信息。事实上，使用select star查询，BigQuery必须读取整个JSON消息，因此处理的字节数达到13.78 MB。然而，当我们只查询JSON消息的单个属性时，BigQuery只需要处理376 KB，并且返回结果的速度要快得多。这个简单的实验表明，BigQuery并不仅仅将我们的消息作为blob，而是作为单独的虚拟列在内部持久化。</p><blockquote class="lj lk ll"><p id="c7b4" class="if ig lm ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">本文由</em> </strong> <a class="ae lq" href="https://www.linkedin.com/in/lukasz-olejniczak-1a75a613/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="hi">卢卡兹</em> </strong> </a> <strong class="ih hj"> <em class="hi">和</em> </strong> <a class="ae lq" href="https://www.linkedin.com/in/jakubskuratowicz" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="hi">雅各布</em> </strong> </a> <strong class="ih hj"> <em class="hi">合著。所表达的观点是作者的观点，不一定反映谷歌的观点。</em> </strong></p></blockquote><p id="7b74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，请为它鼓掌。更多google云端数据科学、数据工程、AI/ML关注我<a class="ae lq" href="https://www.linkedin.com/in/lukasz-olejniczak-1a75a613/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="lm">LinkedIn</em></strong></a><strong class="ih hj"><em class="lm">。</em> </strong></p></div></div>    
</body>
</html>