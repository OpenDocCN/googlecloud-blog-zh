<html>
<head>
<title>Talking a good DevOps game: Google Container Engine deployments, Kubernetes Dashboards and Google Home</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谈论一个好的DevOps游戏:Google容器引擎部署、Kubernetes仪表盘和Google Home</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/talking-a-good-devops-game-google-container-engine-deployments-kubernetes-dashboards-and-google-63a576b3e29b?source=collection_archive---------1-----------------------#2017-11-02">https://medium.com/google-cloud/talking-a-good-devops-game-google-container-engine-deployments-kubernetes-dashboards-and-google-63a576b3e29b?source=collection_archive---------1-----------------------#2017-11-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><p id="82f9" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">这是我上一篇文章(<a class="ae jj" rel="noopener" href="/google-cloud/lets-talk-deployments-with-google-home-circleci-and-google-container-engine-f4121703ef26">让我们谈谈Google Home、CircleCI和Google Container Engine </a>的部署)的后续文章，并更详细地介绍了:</p><ul class=""><li id="4074" class="jk jl hi in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">组织您的GKE部署。</li><li id="95cf" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">使用Kubernetes APIs创建定制的Kubernetes仪表板。</li><li id="1f29" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">使用Google Assistant加载仪表板</li></ul><blockquote class="jy jz ka"><p id="54bf" class="il im kb in b io ip iq ir is it iu iv kc ix iy iz kd jb jc jd ke jf jg jh ji hb bi translated"><strong class="in hj">背景</strong>:在<a class="ae jj" rel="noopener" href="/me/stories/public">过去的文章</a>中，我们已经将应用程序(主要是Rails应用程序)部署到GKE，并使用不同的技术通过Kubernetes实现零停机部署。本文中的技术也可以用于用其他语言构建的应用程序。</p><p id="e7e9" class="il im kb in b io ip iq ir is it iu iv kc ix iy iz kd jb jc jd ke jf jg jh ji hb bi translated">我们还看到了一个<a class="ae jj" rel="noopener" href="/google-cloud/lets-talk-deployments-with-google-home-circleci-and-google-container-engine-f4121703ef26">概念验证</a>，我们可以使用Google Assistant，通过与CircleCI的RESTful APIs集成，开始构建和部署到GKE。在那篇文章中，我提到了将助手与Kubernetes API连接起来以显示定制的仪表板。</p></blockquote><p id="d2a3" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">本文简要论述了以下内容:</p><ol class=""><li id="ea3d" class="jk jl hi in b io ip is it iw jm ja jn je jo ji kf jq jr js bi translated">典型的GKE部署模型是什么样的？</li><li id="ea77" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">如何将您的应用程序部署到各种环境中(QA、试运行、生产等。)</li><li id="f2d0" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">快速浏览一下<a class="ae jj" href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Web UI(仪表板)</a></li><li id="795a" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">如何使用<a class="ae jj" href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" rel="noopener ugc nofollow" target="_blank">Kubernetes API</a>来实现定制仪表板</li><li id="2079" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated"><strong class="in hj">有趣的功能</strong>:如何通过谷歌助手的语音命令显示这个仪表盘或几乎任何其他网页</li></ol><p id="1ca0" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">好的，让我们逐一解决这些问题。</p><h1 id="7157" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">典型的GKE部署模式是什么样的？</strong></h1><p id="52a3" class="pw-post-body-paragraph il im hi in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji hb bi translated"><strong class="in hj">在下图</strong>中，您可以看到一个示例Rails应用程序，它执行以下操作:</p><ul class=""><li id="43df" class="jk jl hi in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">允许用户张贴狗的图片。该应用程序部署在GKE。</li><li id="0530" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">它还运行后台进程(工人),处理这些图像，识别狗的品种和其他特征，并将这些细节保存在数据库中</li><li id="e225" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">它使用CloudSQL存储数据，使用StackDriver进行日志记录/监控/警报，使用Pub/Sub进行异步事件处理，使用Storage buckets存储狗图片。</li><li id="5def" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">该应用程序的用户将通过HTTPS访问网站。</li></ul><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lj"><img src="../Images/dd70baac486783be16416c67f74af9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VOQhRT7sZCoQTUM1dxzRg.jpeg"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">谷歌容器引擎(GKE)中的Rails应用和工人的标准部署模型</figcaption></figure><blockquote class="jy jz ka"><p id="0378" class="il im kb in b io ip iq ir is it iu iv kc ix iy iz kd jb jc jd ke jf jg jh ji hb bi translated"><strong class="in hj">在</strong>的引擎盖下，你会看到一个<strong class="in hj">入口</strong>(路由规则)完成TLS终止，一个<strong class="in hj">服务</strong>(负载均衡器)将请求发送到web应用实例(<strong class="in hj">部署</strong>)。web应用程序和工作程序有单独的部署(异步流程)。入口和部署将使用<strong class="in hj">机密</strong>(用于环境变量)来访问与第三方服务等对话所需的凭证。<strong class="in hj">由于该应用也是一个好公民</strong>，它将使用CloudSQL代理打开到您数据库的安全连接。</p></blockquote><p id="6e52" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">伟大的</strong>！你在GKE有你的第一次部署。现在，您所要做的就是在您的多个环境中复制这一点(QA、试运行、生产…)就大功告成了！:-)</p><h1 id="7244" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如何将您的应用程序部署到各种环境中(QA、试运行、生产等。)</h1><p id="6d19" class="pw-post-body-paragraph il im hi in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji hb bi translated">该画第二张图了。这里有一种组织方式:</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ly"><img src="../Images/405861bd0f1248636c86c9ec25224b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKYArPNVCgUnWdIoVJkqIw.jpeg"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">自动构建和部署到多个GKE环境</figcaption></figure><p id="3c75" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">上图中有一组<em class="kb">信息。</em></p><p id="8aa0" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">主要特点:</strong></p><blockquote class="jy jz ka"><p id="bc84" class="il im kb in b io ip iq ir is it iu iv kc ix iy iz kd jb jc jd ke jf jg jh ji hb bi translated">我们现在有3个环境(QA、试运行或预生产和生产)。生产有两种类型的部署(蓝色和绿色)。稍后我会详细解释“青色”。所有的构建/测试/部署过程都是完全自动化的，并且由CircleCI根据Github库中的不同触发器进行编排。</p></blockquote><ol class=""><li id="797d" class="jk jl hi in b io ip is it iw jm ja jn je jo ji kf jq jr js bi translated">合并到开发分支的代码<strong class="in hj">通过CircleCI自动部署到“my-QA”GCP项目的集群中</strong></li><li id="1188" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">合并到主分支的代码<strong class="in hj">自动部署到“我的分期”GCP项目的集群中</strong></li><li id="6402" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">当您<strong class="in hj">‘git tag’</strong><strong class="in hj">master</strong>分支时，一个部署会自动发生在同一个“my-prod”GCP项目中的一个集群上，并被部署到同一个集群上的一个“青色”部署中。它还被部署到生产服务器中的“非活动颜色”中。示例:如果当前“颜色”为绿色，则标记为<strong class="in hj">蓝色</strong>部署<strong class="in hj">的吊舱已完成部署。</strong></li><li id="ecac" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">该团队现在可以在“smoketest.mywebsite.com”上对指向青色部署的功能进行内部测试。此时，我们在青色部署和非活动蓝色部署上有了新版本的应用程序。绿色仍然支持生产中的当前版本。</li><li id="461a" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">一旦“smoketest.mywebsite.com”上一切正常，您就可以切换开关，将您的生产应用程序(smoketest.mywebsite.com)指向上面“蓝色”部署中新部署的应用程序。</li><li id="aa95" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji kf jq jr js bi translated">为了保持数据库前端的数据模型和数据是最新的(对于Rails应用程序)，我们有一个Kubernetes Pod(上图中的“db-updater ”),它在部署期间启动以运行迁移和种子，如果遇到任何错误，部署将会停止。通过一些创造性的查询，您可以发现作业何时运行及其输出。该Pod将在过程结束时被删除，但您仍然可以在通过/失败的CircleCI作业中看到日志。</li></ol><p id="94fa" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">注意</strong>:如果蓝/绿和现在的青色(！)术语没有多大意义，请看我关于这个话题的<a class="ae jj" rel="noopener" href="/@nithinmallya4/blue-green-deployments-for-a-rails-app-in-google-container-engine-gke-49ddcc1b002">文章</a></p><h1 id="e85f" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如何利用默认的Kubernetes仪表板</h1><p id="b99c" class="pw-post-body-paragraph il im hi in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji hb bi translated">一旦我们有了上面的部署，接下来就是确保我们的部署看起来不错，没有重启等等。除了查看StackDriver仪表板、设置具有正确阈值的警报等，我们还需要一种能够可视化访问这些信息的方法。</p><blockquote class="jy jz ka"><p id="c8b7" class="il im kb in b io ip iq ir is it iu iv kc ix iy iz kd jb jc jd ke jf jg jh ji hb bi translated">T <strong class="in hj"> ip </strong>:查看生产中的pod以了解是否有任何新的重启总是一个好的做法，因为通过通常的监控和警报方法来捕捉这些重启更加困难。</p></blockquote><p id="b354" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">熟悉<a class="ae jj" href="https://kubernetes.io/docs/user-guide/kubectl-overview/" rel="noopener ugc nofollow" target="_blank"> <strong class="in hj"> kubectl </strong> </a>命令的用户知道，当您运行下面的命令时，Kubernetes提供了一个非常干净、用户友好的仪表板。您可以使用这个仪表板做很多事情(创建部署、服务、机密、增加/减少副本等。)，而这在<strong class="in hj">大部分</strong>情况下应该足够了。</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="1642" class="me kh hi ma b fi mf mg l mh mi">kubectl proxy</span></pre><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mj"><img src="../Images/e04b4d7ba14cd40d544b1c5a1ba7008e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlqat8sfu0BgLR3OIglnhQ.png"/></div></div></figure><blockquote class="jy jz ka"><p id="1a75" class="il im kb in b io ip iq ir is it iu iv kc ix iy iz kd jb jc jd ke jf jg jh ji hb bi translated"><strong class="in hj">为附加功能提供案例</strong>:有时，对于分布式团队和不同时区的团队，当需要生产推送时，请求生产部署的团队成员可能不一定熟悉部署模型或<strong class="in hj"> gcloud </strong>和<strong class="in hj"> kubectl </strong>工具。在这种情况下，拥有一个定制的仪表板可能会有所帮助，这个仪表板可以更具体地满足我们所拥有的应用程序的需求，并且可以被团队轻松地访问和理解。有多种方法可以实现这一点，下一节将对此进行讨论</p></blockquote><h1 id="117b" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如何使用Kubernetes APIs创建定制仪表板。</h1><p id="6867" class="pw-post-body-paragraph il im hi in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji hb bi translated">如果需要使用默认的Kubernetes仪表板，我们可以通过调用Kubernetes RESTful APIs来创建自己的仪表板。这可以通过以下方式实现:</p><ul class=""><li id="bcba" class="jk jl hi in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">使用Kubernetes提供的<a class="ae jj" href="https://kubernetes.io/docs/reference/client-libraries/" rel="noopener ugc nofollow" target="_blank">标准客户端库</a>(在Go和Python中)</li><li id="03a1" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">使用<a class="ae jj" href="https://kubernetes.io/docs/reference/client-libraries/#community-maintained-client-libraries" rel="noopener ugc nofollow" target="_blank">社区支持的</a> (Node.js，Ruby等)。)</li><li id="97d4" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">通过标准REST客户端直接调用RESTful APIs</li></ul><p id="58c9" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">下图显示了一个简单的仪表板，我们可以用它来跟踪<strong class="in hj">我们所有的环境</strong>，并将我们的部署切换到相应的颜色。</p><p id="5dcc" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">以下亮点:</p><ul class=""><li id="3445" class="jk jl hi in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">查看我们所有的Kubernetes工件及其状态(重启计数等。).您可以看到我们的应用程序被部署到webserver-blue、webserver-green和webserver-cyan部署中。我们还有异步工作进程(web-worker，phoenix-worker)</li><li id="d838" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">部署时间戳，以查看每次部署发生的时间和使用的映像。</li><li id="8fcd" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">一键切换到不同“颜色”部署的能力</li><li id="f142" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">将工作线程回滚到先前版本的能力(图中未显示)</li><li id="df37" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">当生产颜色切换完成时，自动发出宽限通知，详细说明谁在何时进行了更改</li><li id="0f3e" class="jk jl hi in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">混沌猴功能(发送无效数据，测试连接中断等。)等等..</li></ul><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mk"><img src="../Images/4ed49531075a7b7aa2d4c96b8a2e1427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5XZvmWkNSyNT0Hpzwbkp_g.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">示例DevOps仪表板显示了各种Kubernetes工件，并允许用户修改部署</figcaption></figure><p id="d7b4" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">如何:</strong></p><p id="98e2" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">选项I: </strong>如前所述，您可以使用官方的Kubernetes客户端库(Go/Python)并利用这些库或社区支持的库构建一个仪表板。更多详情请点击<a class="ae jj" href="https://kubernetes.io/docs/reference/client-libraries/#community-maintained-client-libraries" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="1a6e" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">选项II: </strong>创建一个简单的Node.js Express应用程序，它访问我们的主API服务器上的各个Kubernetes端点并获取数据。<em class="kb">为了实现这一点，您需要事先知道集群中API服务器的IP地址。通过这种方法，一个应用程序可以服务于DevOps仪表板，因为它能够从不同项目的多个集群中获取部署细节。上图显示了这种方法</em></p><p id="29b6" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">当运行kubectl命令并将详细程度设置为8时:</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="0225" class="me kh hi ma b fi mf mg l mh mi">kubectl &lt;your command&gt; --v=8</span></pre><p id="fc65" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">您将获得API服务器的IP地址和实际调用的GET/PATCH调用。</p><p id="808c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">例如，如果您运行:</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="977b" class="me kh hi ma b fi mf mg l mh mi">kubectl get deployment —-v=8</span></pre><p id="f4ac" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">您将看到类似如下的输出:</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="cc15" class="me kh hi ma b fi mf mg l mh mi">GET https://&lt;API-SERVER-IP-ADDRESS&gt;/apis/extensions/v1beta1/namespaces/default/deployments</span></pre><p id="b55f" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">选项三:</strong></p><p id="d98b" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">另一种选择是在集群中启动一个容器，该容器在本地运行一个“kubectl代理”,并且可以由在该容器中运行的应用程序通过http://localhost:8001/…访问..端点。</p><p id="d491" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">注:</strong>每个集群都需要这种方法。</p><h1 id="fa9b" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">趣味功能</strong>:如何通过谷歌助手的语音命令显示这个仪表盘(或任何其他网页)</h1><p id="3f00" class="pw-post-body-paragraph il im hi in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji hb bi translated">以下是通过语音命令("<strong class="in hj"> Show me the DevOps Dashboard </strong>")显示您的仪表盘的几种方法:</p><ol class=""><li id="c76e" class="jk jl hi in b io ip is it iw jm ja jn je jo ji kf jq jr js bi translated">您可以使用Google Pub/Sub和一个充当Pub/Sub消费者的本地轻量级客户端来加载仪表板页面(参见我的<a class="ae jj" rel="noopener" href="/google-cloud/lets-talk-deployments-with-google-home-circleci-and-google-container-engine-f4121703ef26">以前的文章</a>关于如何为Google Assistant创建实体、意图和实现端点)</li></ol><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ml"><img src="../Images/28e6fb2b481b40b98fefb60a9db1555d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*On_EIpo0JetBkfEtz6os0w.jpeg"/></div></div></figure><p id="48af" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">node.js中的云函数片段如下所示:</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="d3ac" class="me kh hi ma b fi mf mg l mh mi">const PubSub = require('<a class="ae jj" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/pubsub');</span><span id="3118" class="me kh hi ma b fi mm mg l mh mi">// Instantiates a client<br/>const pubsub = PubSub();</span><span id="70bf" class="me kh hi ma b fi mm mg l mh mi">function publish (req, res) {<br/>  console.log(`Publishing message to topic &lt;YOUR TOPIC&gt;`);<br/>  const topic = pubsub.topic('&lt;YOUR TOPIC&gt;');</span><span id="1fd3" class="me kh hi ma b fi mm mg l mh mi">const message = {<br/>    data: {<br/>      url: '&lt;MY DASHBOARD URL'<br/>    }<br/>  };</span><span id="66d3" class="me kh hi ma b fi mm mg l mh mi">// Publishes a message<br/>  return topic.publish(message)<br/>    .then(() =&gt; res.status(200).send('Message published.'))<br/>    .catch((err) =&gt; {<br/>      console.error(err);<br/>      res.status(500).send(err);<br/>      return Promise.reject(err);<br/>    });<br/>};</span></pre><p id="ca4c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">Ruby中的本地桌面客户端(Pub/Sub consumer)看起来像下面的例子(它连续运行，并简单地打开一个浏览器窗口，其中包含从Pub/Sub消息中获得的URL)。</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="690a" class="me kh hi ma b fi mf mg l mh mi"># Local Pub/Sub client (ruby)</span><span id="da00" class="me kh hi ma b fi mm mg l mh mi">require 'google/cloud/pubsub'</span><span id="b74a" class="me kh hi ma b fi mm mg l mh mi">pubsub = Google::Cloud::Pubsub.new(<br/>  project: '&lt;MY GCP PROJECT&gt;',<br/>  keyfile: '&lt;MY SERVICE ACCOUNT CREDENTIALS JSON FILE'<br/>)</span><span id="4e72" class="me kh hi ma b fi mm mg l mh mi">loop do<br/>  sub = pubsub.subscription '&lt;MY SUBSCRIPTION NAME&gt;'<br/>  msgs = sub.pull<br/>  sub.acknowledge msgs<br/>  received_message = msgs[0] unless msgs.nil?<br/>  next if received_message.nil?<br/>  json_obj = JSON.parse(received_message.data) <br/>  url = json_obj['data']['url']<br/>  `open #{url}`<br/>end</span></pre><blockquote class="jy jz ka"><p id="920e" class="il im kb in b io ip iq ir is it iu iv kc ix iy iz kd jb jc jd ke jf jg jh ji hb bi translated"><strong class="in hj"> <em class="hi">注意</em> </strong> <em class="hi">:由于这种方法的异步特性，请做好准备，它需要大约10秒来加载仪表板。</em></p></blockquote><p id="77ef" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">2.通过socket.io在Node.js应用程序中使用自定义端点将用户请求的URL实时发送到客户端浏览器。您需要使用socket.io服务器和客户端库来实现这一点。这显然会比上述方法更快。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ml"><img src="../Images/f56186cabedfe6d55d8cb33c196b2789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGwYnEw88WX4ObKDQgsBvw.jpeg"/></div></div></figure><p id="590a" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">结论:</strong>我们已经讨论了很多内容，详细描述了过去对我们有所帮助的一些部署策略。希望这篇文章实现了它的初衷:分享将我们的应用程序部署到GKE的不同方法，同时通过使用Google Assistant查看仪表板的更现代的方式，将它提升一个档次。</p></div></div>    
</body>
</html>