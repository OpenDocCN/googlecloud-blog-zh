<html>
<head>
<title>Build a blog application on Google App Engine: Architecture (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google App Engine上构建一个博客应用程序:架构(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-architecture-part-2-1b7fb081bf3c?source=collection_archive---------2-----------------------#2018-11-27">https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-architecture-part-2-1b7fb081bf3c?source=collection_archive---------2-----------------------#2018-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cbae219b3e21a7ee3e6a078ca818d86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WE8RS9U839vi7oVNg0Z5pA.jpeg"/></div></div></figure><p id="1df7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是关于如何在Node.js中使用<strong class="is hj"> Google Datastore </strong>构建一个小型博客应用程序并将其部署到<strong class="is hj"> Google App Engine </strong>的多部分教程的第二部分。如果你还没有看过，请跳到第一部分，我会解释如何建立这个项目。</p><p id="c5c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一节中，我将解释应用程序的<strong class="is hj">架构以及组成它的不同的<strong class="is hj">模块</strong>。</strong></p><h1 id="4cc7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">六角形建筑</h1><p id="aa85" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了构建应用程序，我们将放置所谓的<em class="ks">六角形架构</em>或<em class="ks">端口和适配器</em>架构。你可以在那里找到很多关于六边形架构的信息，但是我喜欢Apiumhub 下面的<a class="ae jo" href="https://apiumhub.com/tech-blog-barcelona/hexagonal-architecture/" rel="noopener ugc nofollow" target="_blank">定义:</a></p><blockquote class="kt ku kv"><p id="7453" class="iq ir ks is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated">六边形架构通过将逻辑封装在应用程序的不同层中来促进关注点的分离。这实现了更高级别的隔离、<strong class="is hj">可测试性</strong>以及对业务特定代码的控制。应用程序的每一层都有一套<strong class="is hj">严格的职责和要求</strong>。这为某些逻辑或功能应该位于何处，以及这些层应该如何相互交互创建了清晰的边界。</p></blockquote><p id="e6cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在我们的Node.js应用程序中意味着<strong class="is hj">每一层</strong>都将遵循这种模式:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="d1dc" class="li jq hi le b fi lj lk l ll lm">interface BlogPostDomain {<br/>    someMethod(): boolean;<br/>}</span><span id="3488" class="li jq hi le b fi ln lk l ll lm">/**<br/> * Export a function that<br/> * - accepts arguments (Input)<br/> * - returns an interface (Output)<br/> */<br/>export default (ctx: Context, modules: Modules): BlogPostDomain =&gt; {<br/>    return {<br/>        someMethod() {<br/>            return true;<br/>        }<br/>    }<br/>}</span></pre><p id="0200" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，我们的BlogPost域层将2个参数作为<strong class="is hj">输入</strong> ( <em class="ks">上下文</em>和<em class="ks">模块</em>)并返回(<strong class="is hj">输出</strong>)包含1个方法(<code class="du lo lp lq le b">someMethod()</code>)的<em class="ks"> BlogPostDomain </em>接口。有了这种方法，我们将很容易<strong class="is hj">隔离测试这一层</strong>，为我们的<em class="ks">上下文</em>和<em class="ks">模块</em>提供模拟值，只要它们有相同的契约。只要我们不破坏已定义的签名(输入和输出)，修改或替换这一层也将非常容易。</p><p id="1d2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，如果我们将<strong class="is hj"> Typescript </strong>与该模式一起使用，那么重构我们的应用程序将是极其安全的，因为Typescript会自动告诉我们代码的哪一部分由于不遵守的契约而被破坏。</p><h1 id="22bd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">应用模块</h1><p id="582b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将把我们的应用分成4个模块:</p><ul class=""><li id="83cb" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated"><strong class="is hj">博客</strong>模块:阅读、创建、编辑、删除<em class="ks">博客帖子</em>和<em class="ks">评论</em>。</li><li id="337c" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">管理模块:小CMS列出我们的职位，并编辑或删除它们。它主要是一个管理我们的<em class="ks">博客</em>模块的实体的接口。</li><li id="71a0" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated"><strong class="is hj">图片</strong>模块:上传或删除特色图片到Google Storage。</li><li id="9fb7" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated"><strong class="is hj"> Utils </strong>模块:实用函数。根据定义，这个模块<em class="ks">不</em>依赖任何模块，因为其他模块应该能够依赖它。为了简化教程，这个模块已经包含在starting分支中，如果你有不明白的地方，可以在评论中找到。</li></ul><p id="aec6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们进入“<em class="ks">模块</em>”文件夹(记住，我们所有的打字稿代码都在“<em class="ks"> src/server </em>文件夹中)，并创建3个文件夹(<em class="ks"> admin </em>、<em class="ks"> blog </em>、<em class="ks"> images </em>)。在每个文件夹中添加一个“<em class="ks"> index.ts </em>”文件，并添加以下内容:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2906" class="li jq hi le b fi lj lk l ll lm">export default () =&gt; {<br/>    return {};<br/>};</span></pre><p id="ee0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们已经定义了每个模块的入口点<strong class="is hj">，现在让我们将它们从主文件“<em class="ks"> modules.ts </em>”中导出。打开根目录下的“<em class="ks"> modules.ts </em>”文件，进行如下修改:</strong></p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="15f5" class="li jq hi le b fi lj lk l ll lm">// modules.ts</span><span id="060a" class="li jq hi le b fi ln lk l ll lm">import initBlogModule from './modules/blog'; // Add<br/>import initAdminModule from './modules/admin'; // Add<br/>import initImagesModule from './modules/images'; // Add<br/>import initUtilsModule from './modules/utils';</span><span id="a3d2" class="li jq hi le b fi ln lk l ll lm">export default () =&gt; {<br/>  const utils = initUtilsModule();<br/>  const images = initImagesModule(); // Add<br/>  const blog = initBlogModule(); // Add<br/>  const admin = initAdminModule(); // Add</span><span id="efbf" class="li jq hi le b fi ln lk l ll lm">return {<br/>    blog,  // Add<br/>    admin,  // Add<br/>    images,  // Add<br/>    utils,<br/>  };<br/>};</span></pre><p id="bfcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！…但是这里还没有太多的打字。让我们为每个模块定义一个接口并导出它。然后，我们将能够声明包含所有4个模块的全局<em class="ks"> AppModule </em>类型。</p><p id="bb42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打开“<em class="ks">modules/admin/index . ts</em>”<em class="ks"/>文件，进行如下修改:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c924" class="li jq hi le b fi lj lk l ll lm">// modules/admin/index.ts</span><span id="9c53" class="li jq hi le b fi ln lk l ll lm">export interface AdminModule {} // Add this line</span><span id="7223" class="li jq hi le b fi ln lk l ll lm">export default () =&gt; {<br/>  return {};<br/>};</span></pre><p id="3dea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对其他2个模块进行同样的操作。<br/>在<em class="ks">模块/博客/索引. ts </em>中，添加<code class="du lo lp lq le b">export interface BlogModule {}</code>。<br/>在<em class="ks">模块/图像/索引. t </em> s中，增加<code class="du lo lp lq le b">export interface ImagesModule {}</code>。</p><p id="4ebb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经为每个模块定义了一个接口，我们可以创建一个包含每个模块的<em class="ks"> AppModules </em>类型。为此，在根目录下创建一个“<em class="ks"> models.ts </em>”文件，并添加以下内容</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5675" class="li jq hi le b fi lj lk l ll lm">// models.ts</span><span id="2330" class="li jq hi le b fi ln lk l ll lm">import { BlogModule } from './modules/blog';<br/>import { AdminModule } from './modules/admin';<br/>import { ImagesModule } from './modules/images';<br/>import { UtilsModule } from './modules/utils';</span><span id="4499" class="li jq hi le b fi ln lk l ll lm">export type AppModules = {<br/>  blog: BlogModule;<br/>  admin: AdminModule;<br/>  images: ImagesModule;<br/>  utils: UtilsModule;<br/>};</span></pre><p id="e830" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以在我们的"<em class="ks"> modules.ts" </em>文件中导入我们的<em class="ks"> AppModules </em>类型，并将其定义为返回类型(输出)。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="be50" class="li jq hi le b fi lj lk l ll lm">// modules.ts<br/>...<br/>import initUtilsModule from './modules/utils';<br/>import { AppModules } from './models'; // Add this line</span><span id="2c03" class="li jq hi le b fi ln lk l ll lm">export default (): AppModules =&gt; { // Add the return Type<br/>...</span></pre><p id="8d74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，现在我们已经声明了4个模块，并导出了它们的接口。我们将在单独的博客文章中详细介绍每个模块。现在，让我们继续构建应用程序的框架。</p><h1 id="9854" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">应用程序配置</h1><p id="1eca" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们的应用程序将需要一些配置传递给层和模块。我们将遵循与模块相同的方法:我们将有不同配置的多个文件，然后用一个文件从一个地方导出它们。首先，让我们在服务器文件夹的根目录下创建一个<em class="ks"> config </em>文件夹，并在其中添加一个“<em class="ks"> index.ts </em>”文件。将以下内容添加到文件中:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ae15" class="li jq hi le b fi lj lk l ll lm">// config/index.ts</span><span id="0f2b" class="li jq hi le b fi ln lk l ll lm">export type Config = {};</span><span id="63dd" class="li jq hi le b fi ln lk l ll lm">const config: Config = {};</span><span id="f054" class="li jq hi le b fi ln lk l ll lm">export default config;</span></pre><p id="d5e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里没有什么特别的，我们声明我们的应用程序<em class="ks">配置</em>类型，然后将其导出为默认的<em class="ks">配置</em>对象。现在让我们创建不同的配置文件。在“<em class="ks"> config </em>”文件夹中，创建一个“<em class="ks"> common.ts </em>”文件，并添加以下内容</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="d4ed" class="li jq hi le b fi lj lk l ll lm">// config/common.ts</span><span id="eee1" class="li jq hi le b fi ln lk l ll lm">import joi from "joi";</span><span id="95ad" class="li jq hi le b fi ln lk l ll lm">const envVarsSchema = joi<br/>  .object({<br/>    NODE_ENV: joi<br/>      .string()<br/>      .valid(["development", "production", "test"])<br/>      .required()<br/>  })<br/>  .unknown();</span><span id="6b32" class="li jq hi le b fi ln lk l ll lm">const { error, value: envVars } = joi.validate(<br/>  process.env,<br/>  envVarsSchema<br/>);</span><span id="28e5" class="li jq hi le b fi ln lk l ll lm">if (error) {<br/>  throw new Error(`Config validation error: ${error.message}`);<br/>}</span><span id="ec85" class="li jq hi le b fi ln lk l ll lm">export type CommonConfig = {<br/>  env: string,<br/>  isTest: boolean,<br/>  isDevelopment: boolean,<br/>  apiBase: string<br/>};</span><span id="32b3" class="li jq hi le b fi ln lk l ll lm">export const config: CommonConfig = {<br/>  env: envVars.NODE_ENV,<br/>  isTest: envVars.NODE_ENV === "test",<br/>  isDevelopment: envVars.NODE_ENV === "development",<br/>  apiBase: "/api/v1"<br/>};</span></pre><p id="0270" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们来详细看看这里发生了什么。首先，我们导入<a class="ae jo" href="https://github.com/hapijs/joi" rel="noopener ugc nofollow" target="_blank"> Joi </a>，一个用于Javascript对象的<strong class="is hj">验证器</strong>。Joi借助<strong class="is hj">模式</strong>来验证对象。这里我们定义了一个包含1个属性的<code class="du lo lp lq le b">envVarsSchema</code>:<code class="du lo lp lq le b">NODE_ENV</code>。我们指定<code class="du lo lp lq le b">NODE_ENV</code>必须是一个<strong class="is hj">字符串</strong>，其有效值为("<em class="ks">开发</em>"、"<em class="ks">生产</em>"或"<em class="ks">测试</em>")。我们还将其标记为<strong class="is hj">必填</strong>。</p><p id="40e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们要求Joi<strong class="is hj">根据这个模式验证</strong>全局变量<code class="du lo lp lq le b">process.env</code>。如果<code class="du lo lp lq le b">process.env</code>不包含<code class="du lo lp lq le b">NODE_ENV</code> <em class="ks"> </em>属性或者如果它的值无效，在引导时间将抛出一个错误<strong class="is hj">，程序将退出(这就是所谓的“快速失效原则”)。</strong></p><p id="19ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们为<em class="ks">公共</em>配置声明一个类型并返回它。</p><p id="3c33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们为<em class="ks"> gcloud </em>、<em class="ks"> logger </em>和<em class="ks"> server </em>创建其他配置对象。它们都将遵循相同的模式，所以我不会详细介绍。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8bd3" class="li jq hi le b fi lj lk l ll lm">// config/glcoud.ts</span><span id="6d6f" class="li jq hi le b fi ln lk l ll lm">import joi from "joi";</span><span id="f37e" class="li jq hi le b fi ln lk l ll lm">const envVarsSchema = joi<br/>  .object({<br/>    GOOGLE_CLOUD_PROJECT: joi.string().required(),<br/>    GCLOUD_BUCKET: joi.string().required(),<br/>    DATASTORE_NAMESPACE: joi.string()<br/>  })<br/>  .unknown();</span><span id="bd8f" class="li jq hi le b fi ln lk l ll lm">const { error, value: envVars } = joi.validate(<br/>  process.env,<br/>  envVarsSchema<br/>);</span><span id="5e02" class="li jq hi le b fi ln lk l ll lm">if (error) {<br/>  throw new Error(`Config validation error: ${error.message}`);<br/>}</span><span id="89fe" class="li jq hi le b fi ln lk l ll lm">export type GcloudConfig = {<br/>  projectId: string,<br/>  datastore: {<br/>    namespace: string<br/>  },<br/>  storage: {<br/>    bucket: string<br/>  }<br/>};</span><span id="ff53" class="li jq hi le b fi ln lk l ll lm">export const config: GcloudConfig = {<br/>  projectId: envVars.GOOGLE_CLOUD_PROJECT,<br/>  datastore: {<br/>    namespace: envVars.DATASTORE_NAMESPACE<br/>  },<br/>  storage: {<br/>    bucket: envVars.GCLOUD_BUCKET<br/>  }<br/>};</span></pre><p id="48fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以及服务器的配置:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="3d07" class="li jq hi le b fi lj lk l ll lm">// config/server.ts</span><span id="3249" class="li jq hi le b fi ln lk l ll lm">import joi from "joi";</span><span id="1fb3" class="li jq hi le b fi ln lk l ll lm">const envVarsSchema = joi<br/>  .object({<br/>    PORT: joi.number().default(8080)<br/>  })<br/>  .unknown();</span><span id="3eb4" class="li jq hi le b fi ln lk l ll lm">const { error, value: envVars } = joi.validate(process.env, envVarsSchema);</span><span id="f7a6" class="li jq hi le b fi ln lk l ll lm">if (error) {<br/>  throw new Error(`Config validation error: ${error.message}`);<br/>}</span><span id="80c0" class="li jq hi le b fi ln lk l ll lm">export type ServerConfig = {<br/>  port: number<br/>};</span><span id="b963" class="li jq hi le b fi ln lk l ll lm">export const config: ServerConfig = {<br/>  port: Number(envVars.PORT)<br/>};</span></pre><p id="9811" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…对于记录器:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f70c" class="li jq hi le b fi lj lk l ll lm">// config/logger.ts</span><span id="1bea" class="li jq hi le b fi ln lk l ll lm">import joi from "joi";</span><span id="28a1" class="li jq hi le b fi ln lk l ll lm">const envVarsSchema = joi<br/>  .object({<br/>    LOGGER_LEVEL: joi<br/>      .string()<br/>      .allow(["error", "warn", "info", "verbose", "debug", "silly"])<br/>      .default("info"),<br/>    LOGGER_ENABLED: joi<br/>      .boolean()<br/>      .truthy("TRUE")<br/>      .truthy("true")<br/>      .falsy("FALSE")<br/>      .falsy("false")<br/>      .default(true)<br/>  })<br/>  .unknown();</span><span id="eabe" class="li jq hi le b fi ln lk l ll lm">const { error, value: envVars } = joi.validate(<br/>  process.env,<br/>  envVarsSchema<br/>);</span><span id="c04d" class="li jq hi le b fi ln lk l ll lm">if (error) {<br/>  throw new Error(`Config validation error: ${error.message}`);<br/>}</span><span id="9979" class="li jq hi le b fi ln lk l ll lm">export type LoggerConfig = {<br/>  level: string,<br/>  enabled: boolean<br/>};</span><span id="9efe" class="li jq hi le b fi ln lk l ll lm">export const config: LoggerConfig = {<br/>  level: envVars.LOGGER_LEVEL,<br/>  enabled: !!envVars.LOGGER_ENABLED<br/>};</span></pre><p id="452e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经定义了4个配置文件，让我们将它们导入到我们的"<em class="ks"> config/index.ts" </em>中，并将它们作为单个配置对象导出。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="4f06" class="li jq hi le b fi lj lk l ll lm">// config/index.ts</span><span id="442b" class="li jq hi le b fi ln lk l ll lm">import { config as common, CommonConfig } from "./common";<br/>import { config as gcloud, GcloudConfig } from "./gcloud";<br/>import { config as server, ServerConfig } from "./server";<br/>import { config as logger, LoggerConfig } from "./logger";</span><span id="f2ae" class="li jq hi le b fi ln lk l ll lm">export type Config = {<br/>  common: CommonConfig,<br/>  gcloud: GcloudConfig,<br/>  server: ServerConfig,<br/>  logger: LoggerConfig<br/>};</span><span id="53cc" class="li jq hi le b fi ln lk l ll lm">const config: Config = {<br/>  common,<br/>  gcloud,<br/>  server,<br/>  logger<br/>};</span><span id="cbe9" class="li jq hi le b fi ln lk l ll lm">export default config;</span></pre><h2 id="b706" class="li jq hi bd jr mf mg mh jv mi mj mk jz jb ml mm kd jf mn mo kh jj mp mq kl mr bi translated">环境变量</h2><p id="a0c6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">正如我们所见，我们的应用程序配置的所有验证都是针对<strong class="is hj"> <em class="ks"> process.env </em> </strong>全局变量完成的，这是节点存储<strong class="is hj">环境变量</strong>的地方。以这种方式定义应用程序配置是<a class="ae jo" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">十二因素App </strong> </a>的原则之一。它允许我们根据应用运行的<strong class="is hj">进行不同的配置。<br/>当我们将我们的应用程序部署到Google App Engine时，我们将在<em class="ks"> app.yaml </em>描述符文件中定义环境变量，但是在担心这些之前，我们还有很长的路要走...:)</strong></p><p id="66ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开发过程中，我们将使用非常有用的<a class="ae jo" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="ks">dotenv</em></strong>NPM包</a>来设置所需的环境变量。这个包会寻找一个“<em class="ks">”。env" </em>文件，并在运行时将其内容添加到<em class="ks"> process.env </em>全局对象中。</p><p id="b95b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您会在存储库的根目录下找到一个<em class="ks"/>"<em class="ks">. example . env</em>"文件，<strong class="is hj">将其重命名为<em class="ks">。env" </em>并更新它的变量值(主要是<code class="du lo lp lq le b">GOOGLE_CLOUD_PROJECCT</code>和<code class="du lo lp lq le b">GCLOUD_BUCKET</code>)。</strong></p><p id="ef7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在“<em class="ks">config”</em>文件夹中创建一个“<em class="ks">env . ts”</em>文件，并添加以下内容:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9d25" class="li jq hi le b fi lj lk l ll lm">// config/env.ts</span><span id="5f41" class="li jq hi le b fi ln lk l ll lm">import dotenv from "dotenv";</span><span id="6f1e" class="li jq hi le b fi ln lk l ll lm">if (process.env.NODE_ENV === "development") {<br/>  /**<br/>   * In development, read the environment variables from .env file<br/>   */<br/>  dotenv.config();<br/>}</span></pre><p id="0b11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…并将其导入到“<em class="ks"> index.ts </em>”中</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7ca7" class="li jq hi le b fi lj lk l ll lm">// config/index.ts</span><span id="6140" class="li jq hi le b fi ln lk l ll lm">// Make sure to import this first!<br/>import "./env";</span><span id="dd36" class="li jq hi le b fi ln lk l ll lm">import { config as common, CommonConfig } from "./common";<br/>...</span></pre><p id="d42b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们现在已经定义了应用程序配置。在正常的开发过程中，我们不会预先知道配置对象中需要的所有属性，我们会在需要时<strong class="is hj">逐渐添加它们</strong>。但即使这样，我在创建应用程序的框架时也总是遵循相同的方法:<strong class="is hj">从<em class="ks"> config/index.ts </em>文件中导出一个配置对象</strong>，然后<strong class="is hj">将其注入应用程序的不同层</strong>。<br/>在本教程中，为了简单起见，我们只是在一个模块中添加了所有配置。</p><h2 id="70e8" class="li jq hi bd jr mf mg mh jv mi mj mk jz jb ml mm kd jf mn mo kh jj mp mq kl mr bi translated">数据存储模拟器</h2><p id="d3b2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">你可能在<em class="ks">里见过。env </em>文件定义了以下变量:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1b89" class="li jq hi le b fi lj lk l ll lm">DATASTORE_EMULATOR_HOST=localhost:8081</span></pre><p id="410a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当这个变量被设置时，数据存储实例(来自<code class="du lo lp lq le b">google-cloud/datastore</code>库)将不会连接到实时数据存储，而是连接到<strong class="is hj">在我们的机器</strong>上本地运行的仿真器，允许我们离线开发。该项目有一个npm脚本来启动<strong class="is hj">数据存储本地仿真器</strong>，该仿真器将实体数据保存在我们的项目文件夹中。<strong class="is hj">在单独的终端窗口</strong>中运行以下程序:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c69e" class="li jq hi le b fi lj lk l ll lm">npm run local-datastore<br/># or<br/>yarn local-datastore</span></pre><p id="260d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您从未运行过数据存储模拟器，它会首先要求您安装它。之后，您将拥有一个本地数据存储模拟器来进行开发。</p><p id="1b6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们完成了应用程序架构和配置。我希望你能跟上，请在下面的评论中让我知道任何问题。</p><p id="a9e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一篇文章中，我们将创建<strong class="is hj">应用程序上下文</strong>。一个包含应用程序范围依赖性的对象，如<strong class="is hj">数据库连接</strong> ( <code class="du lo lp lq le b">gstore</code>)或<strong class="is hj"> Google存储</strong>实例。让我们直接开始吧！</p></div></div>    
</body>
</html>