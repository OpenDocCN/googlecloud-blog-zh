<html>
<head>
<title>Decision Gate for MLOps pipelines with Vertex AI Experiments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有顶点人工智能实验的MLOps流水线的判决门</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/decision-gate-for-mlops-pipelines-with-vertex-ai-experiments-73d5b258928e?source=collection_archive---------0-----------------------#2022-08-24">https://medium.com/google-cloud/decision-gate-for-mlops-pipelines-with-vertex-ai-experiments-73d5b258928e?source=collection_archive---------0-----------------------#2022-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="004a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据科学开始获得牵引力时，人们主要谈论算法，最终目标是拥有ML模型，不管它是如何在哪里被训练的。由此产生的模型就像一个烫手山芋——很少有人知道如何使用它，更少有人知道如何以及在哪里部署它、监控它等等。幸运的是，这样的日子已经一去不复返了，今天配备了MLOps实践的ML工程更像是建造生产流水线，所有阶段都是自动化的，随时可以按需交付新的模型版本。</p><p id="ed15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MLOps流水线的重要阶段之一是所谓的决策门，它决定新训练的模型是否比当前使用的模型执行得更好。本文的主要目标是展示如何使用顶点人工智能实验构建这样一个决策门。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/c6f5956db54f3fe78d09377f2df98684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*Vo0nv028WutXN1fK"/></div></figure><h1 id="fd41" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">语境</h1><p id="4628" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">就本文而言，假设您是电信公司数据科学团队的新成员。您的目标是将数据科学实践提升到一个新的水平，并构建MLOps基础。你花了第一周时间与其他团队成员交谈，了解到该团队为其第一个用于预测客户流失的ML模型感到非常自豪。你见过做编码的人了解到模型是用Sklearn在Jupyter笔记本上训练的。每月一次，他在笔记本电脑上启动笔记本，训练新模型，并使用新模型建立预期流失的客户名单。他将该列表放入文本文件中，并发送给客户服务团队。在过去的10个月中，这个过程一直是这样工作的，但是没有记录模型属性及其性能特征。此外，事实证明，一旦模型被训练，它就留在笔记本电脑上。</p><p id="bee1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还介绍你认识了CRM系统的产品经理。他希望加强与数据科学团队的合作，并有可能通过REST API调用ML模型。他的第一个用例是，每当与客户服务顾问有新的交流时，能够在客户资料页面上显示最新的客户流失概率。</p><p id="ccfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是最差的起点，但仍有改进的空间。你已经知道还没有类似ML平台的东西，所以让我们给你一个顶点AI的简单介绍。</p><h1 id="37f7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">顶点人工智能</h1><p id="6a9c" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">当谈到机器学习时，谷歌被视为黄金标准，拥有世界一流的研究团队，如谷歌大脑、谷歌研究和Deep Mind，通过谷歌搜索、谷歌翻译和TensorFlow、Kubeflow、Kaggle、Colabs、TPUs、Kubeflow、BERT、T5、ImageNet、Parti、LaMDA、PaLM等多个贡献成功部署了ML。这只是举几个例子。</p><p id="a3fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">鉴于上述所有情况，谷歌的机器学习平台名为<strong class="ih hj"> Vertex AI </strong>，可作为服务在<strong class="ih hj">谷歌云</strong>上获得，似乎至少值得一试。</p><p id="c15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">真正让Vertex AI与其他类似平台不同的一点是，它是<strong class="ih hj">完全无服务器的</strong>——你可以通过各种加速器访问谷歌的ML基础设施，如GPU和TPU，而<strong class="ih hj">不需要</strong>管理服务器、虚拟机、kubernetes集群，<strong class="ih hj">不需要</strong>安装和升级任何软件。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ko"><img src="../Images/c769770568ff70735ee8f17e697b89c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*7NEQbjMMhHH_yPl5.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">来源:<a class="ae kt" href="https://cloud.google.com/blog/topics/developers-practitioners/new-ml-learning-path-vertex-ai" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/blog/topics/developers-practices/new-ml-learning-path-vertex-ai</a></figcaption></figure><p id="5c37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个值得一提的是，Vertex AI是一个<strong class="ih hj">端到端的MLOps平台。这是什么意思？这意味着它是一个单一的地方，您可以在这里管理功能、标记训练样本、使用您最喜欢的ML框架运行训练、执行自动化超参数调整、实施和执行MLOps管道、在模型注册表中注册您的模型、运行无服务器批量预测作业、将您的模型部署为REST端点并支持模型监控和预测的可解释性。</strong></p><p id="8716" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">你为什么要关心这一切？</strong>如果你真的打算通过标准化你的团队构建基于机器学习的解决方案的方式来扩展你的数据科学实践，这将对你有很大帮助。</p><p id="5556" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一点是，Vertex AI将允许你建立完全定制的模型，但也将让你访问许多由谷歌设计的最先进的架构，并作为AutoML培训提供。AutoML意味着你需要做的就是准备和标记训练数据，然后运行Vertex AI AutoML训练，它将处理功能工程，检查许多架构，并为你进行超参数调整。相当强大的机制，至少可以建立参考模型。</p><h1 id="ceb8" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">顶点人工智能实验</h1><p id="34a3" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">每个ML模型训练都发生在某个上下文中，其中上下文实际上是可以给出关于训练和结果模型的更多细节的任何东西:算法名称、关于输入数据的细节、应用于该特定训练的超参数、模型性能度量等。事实上，应用机器学习的<strong class="ih hj">关键部分是实验</strong>,对于你试图用机器学习解决的每个业务问题，你需要实验许多不同的功能、ML架构和超参数，然后才能得出结论，你有一个可以解决问题的模型。每一个这样的实验都有它自己的背景，如果你能够捕捉背景并保持它，那么这将有助于你比较不同的实验，跟踪模型的发展等。<strong class="ih hj"> Vertex AI Experiments </strong>模块就是为这个用例设计的，它就像一个无服务器的数据库，用于实验环境的快照，具有方便的UI和SDK来收集和管理环境细节。</p><h1 id="2db7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">第0步:把你的模型从你的笔记本电脑放到可共享的顶点人工智能模型注册处</strong></h1><p id="c21e" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">现在回到你的新角色。你决定要做的第一件事是确定当前状态的基线。你让你的同事从他的笔记本电脑中取出最新版本的客户流失ML模型，并在<strong class="ih hj"> Vertex AI模型注册表中注册。</strong></p><p id="94ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">听起来像是一个小变化，但它已经开启了许多可能性，如:</p><ul class=""><li id="8aa3" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">您有一个单一的地方，您可以在任何时候访问所有的ML模型，而不管您的团队假期日历。</li><li id="b15c" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">你可以在<strong class="ih hj"> Vertex AI无服务器计算基础设施</strong>上运行<strong class="ih hj">批量预测作业</strong>(可能使用GPU或TPU等加速器)来建立一个根据该模型即将离开的客户列表。这意味着您不再依赖笔记本电脑的计算能力。</li><li id="6999" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">您可以将您的模型作为REST API端点部署到无服务器的<strong class="ih hj"> Vertex AI端点，并能够处理来自其他组件的特别HTTPS预测请求</strong>。</li></ul><h1 id="92c4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">第一步:顶点人工智能管道——设计</h1><p id="f6f3" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">然后，您希望自动执行准备必要数据、进行功能工程、运行模型训练和部署新模型所需的所有步骤。换句话说，你最终得到的不是模型，而是一个脚本化的配方，一个能够按需培训和部署新模型的管道。</p><p id="c65e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">然后你听到这个问题:</strong>但是我们应该为我们的用例使用哪种算法呢？流失预测是一个二元分类问题，这意味着给定输入数据，模型只有两个选项:是(1)或否(0)。这里可以使用许多现有的算法，从随机Forrests和逻辑回归到更复杂的深度神经网络。有人说，竞争总是一件好事。<strong class="ih hj">它迫使我们尽力而为。</strong>这也适用于ML。与其专注于单个算法，为什么不选择其中的几个，让这些模型来竞争呢？我们将称这些模型为<strong class="ih hj">挑战者。</strong>最佳挑战者将与<strong class="ih hj">当前的冠军</strong>竞争——该型号目前已投入使用并满足生产需求。关于哪个挑战者是最好的，以及最佳挑战者是否比当前冠军更好的决定将由称为决策门的任务来处理。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/f244af9a244e0161d82d175534bdb624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SyNZrYGmGvx0eJne"/></div></div></figure><h1 id="984d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤2:决策阶段——设计</h1><p id="fde7" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们的决策门需要做出两个决策:</p><ul class=""><li id="88c9" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">选择最佳挑战者</li><li id="1376" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">决定最佳挑战者是否比当前的冠军更好</li></ul><p id="eb97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个决策都需要某种确定性的度量标准<strong class="ih hj">，即什么意味着更好</strong>。假设更好的模型只是具有更好性能指标的模型是非常直观的，当涉及到二元分类器时，我们通常使用AUC ROC，它代表“接收器特征算子”(ROC)的“曲线下面积”(AUC)。</p><p id="db26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标是收集每个挑战者的度量值，并将其提供给决策门。这就是我们将使用<strong class="ih hj">顶点人工智能实验的地方。</strong>在所谓的<strong class="ih hj">实验运行</strong>的上下文中，每个模型训练使用顶点AI实验SDK注册模型参数和度量。每个实验运行都有唯一的名称(id)和创建时间戳。因此，我们可以预期，我们想要训练多少挑战者，就会进行多少次实验。所有这些实验运行都属于同一个父实验，由它的名称来标识，例如:这里我们有三个实验运行属于同一个名为telco-churn-mlops的实验。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ln"><img src="../Images/b5fafedcce843ded41c15efc1ecaf778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vp_zsEmLjnXLuIaFVzX1PQ.png"/></div></div></figure><p id="afc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">实验</strong>类似于一个数据库表，其中每个记录代表一个不同的实验运行(除了通常每个实验运行可以有不同的参数和度量列表)。因此，这个“表”将帮助我们跟踪由我们的管道的所有执行训练的所有模型的演变。<strong class="ih hj">它有什么帮助？</strong>如果您的数据科学团队中有一名新成员想要了解更多关于模型历史表现的信息，您只需要求该人检查Vertex AI中的相应实验。</p><p id="d228" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，您可能会问以下问题:实验包含迄今为止发生的所有实验运行，而在我们的决策门中，我们只想比较为在同一管道执行中训练的挑战者收集的指标。我们如何识别对应于相同流水线执行的实验运行？这是一个有效的问题。我们必须对对应于相同流水线执行的实验运行进行分组的选项之一是记录表示给定流水线执行的附加参数。在我们的例子中，这个参数将被命名为:<strong class="ih hj"> training_set(我们训练属于同一个训练集的多个挑战者)。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lo"><img src="../Images/ff1d8063dac810beb1bbf04eb155399c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IhQ0t9Jp0k8bsXq0fMptg.png"/></div></div></figure><p id="da20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最后一个问题是，我们如何识别与当前冠军相对应的实验运行？</strong>当前冠军(如果存在)代表在先前流水线执行之一期间训练的最佳挑战者，因此其实验运行应该具有不同的training_set参数值。</p><p id="5bc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着要识别当前冠军的实验运行，我们需要使用另一个技巧。这个技巧要求我们用相应的实验运行名称来标记我们在Vertex AI模型注册表中注册的冠军模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lp"><img src="../Images/f0c08e1e9594f369dfdc188859e007f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*errljlcCw4Lr54NhTolwYw.png"/></div></div></figure><p id="8956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个技巧将帮助我们收集与我们的挑战者和当前冠军相对应的实验运行，这是我们选择最佳挑战者所需的全部，然后决定最佳挑战者是否比当前冠军更好。如果后者是真的，我们的决策门应该启用我们管道中的下游任务，这些任务应该首先在Vertex AI模型注册表中注册最佳挑战者作为新版本，然后将其部署到Vertex AI端点。</p><h1 id="7e04" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">第三步:顶点人工智能管道——实现</h1><p id="2200" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">Vertex AI附带Pipelines模块，这是一个使用<strong class="ih hj"> Kubeflow Pipelines SDK v1构建的MLOps管道的无服务器执行环境。</strong> <strong class="ih hj"> 8.9以上</strong>，或TensorFlow扩展v0。30.0或更高。这对你来说意味着什么？你不需要管理任何ML基础设施——你只需要将执行委托给Vertex AI。如果你有自己的Kubeflow集群，那么你应该能够只需要你的Kubeflow管道，并在Vertex AI上运行它们。</p><p id="2bb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将使用Kubeflow SDK对MLOps管道进行编码。</p><p id="c6d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的管道由以下步骤组成:</p><ul class=""><li id="e590" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">从BigQuery表中读取数据，并将其暂存在Google云存储中。</li><li id="fe51" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">从Google云存储读取阶段性数据，做特征工程。将结果物化回谷歌云存储。</li><li id="6a7f" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">平行训练挑战者</li><li id="5c03" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">决策门</strong></li><li id="e6ac" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如果最佳挑战者比当前冠军更好，则部署最佳挑战者</li></ul><p id="3807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在下面讨论一些编码细节，但最终当管道在Vertex AI上编码和执行时，您应该能够深入管道执行细节并可视化相应的运行时图，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lq"><img src="../Images/eed3270c4366fe16d2e835a791e4d2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pv3wRdEy3WhfyDjGc_bwUw.png"/></div></div></figure><p id="4054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个任务都作为容器执行，当你双击它时，你将能够浏览相应的执行日志。我们的管道训练三个挑战者(任务:<strong class="ih hj"> train，train-2，train-3 </strong>)。一旦所有都被训练好，流水线将运行代表我们的<strong class="ih hj">决策门</strong>的<strong class="ih hj">门</strong>任务。</p><p id="31d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说到代码，Kubeflow pipeline是一个用@pipeline注释的普通python函数。创建任务之间的相关性，将前面任务的输出变量作为输入变量注入下游任务:</p><blockquote class="lr ls lt"><p id="3581" class="if ig lu ih b ii ij ik il im in io ip lv ir is it lw iv iw ix lx iz ja jb jc hb bi translated"><strong class="ih hj">staging _ task</strong>= stage(in _ big query _ projectid，…..</p><p id="d633" class="if ig lu ih b ii ij ik il im in io ip lv ir is it lw iv iw ix lx iz ja jb jc hb bi translated">feature _ eng _ task = preprocess(<strong class="ih hj">staging _ task . output</strong>，……</p></blockquote><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5c3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">管道函数有相当多的输入参数。因此，这条管道将作为一个模板。</p><p id="e352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个管道<strong class="ih hj">任务</strong>都编码为用@component注释的python函数。由于这个注释，<strong class="ih hj"> train </strong>函数将作为来自基础映像(python 3.7)的容器执行，并按照<strong class="ih hj"> packages_to_install </strong>列表中的指定安装附加包。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="3ee1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第35–38行是我们使用Vertex AI SDK实例化到Vertex AI服务的连接的地方。请注意，我们需要指定GCP项目、GCP地区和实验名称。如果实验尚不存在，它将被创建。</p><p id="57b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第42行是我们开始新实验的地方。</p><p id="9eef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第77–82行和第84–90行是我们分别为参数和指标构建两个键、值对映射的地方，我们希望在实验运行中注册这两个映射。我们有training_set的参数、模型类型(svm、random forrest、决策树)、输入文件在Google云存储上的位置以及我们保存训练好的模型在Google云存储上的位置(第59–60行)。另一方面，度量标准描述了我们的模型性能，我们决定记录准确度、精确度、召回率、logloss和auc roc。最后一个将由我们的决策门使用。</p><p id="b61c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Vertex AI SDK提供了两个相当简单的方法来保存参数和指标:分别是log_params和log_metrics </strong>(第92–93行)。</p><h1 id="bd90" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤4:决策阶段—实施</h1><p id="f6a4" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们的决策门任务被编码为门函数。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="661a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第25–28行是我们使用Vertex AI SDK启动与Vertex AI通信的地方。</p><p id="ed00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第31–46行是我们检查顶点人工智能模型注册表，看看冠军模型是否存在。你可以想象这个管道的第一次执行应该找不到冠军模型。Vertex AI模型注册中心是所有ML模型的注册中心，而不仅仅是客户流失的注册中心。因此，当我们扫描注册表时，我们会寻找与实验名称相同的模型。在第35行，我们构建过滤器字符串来解释这个标签，然后在第38–40行向顶点AI模型注册中心询问满足这个过滤器的模型。</p><p id="615b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果champion模型确实存在，那么在第46行，我们读取其代表实验运行id的标签。这是唯一的关键，将帮助我们读取这个冠军模型的顶点人工智能实验中注册的参数和指标。</p><p id="96a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第50行是读取顶点AI '实例'中所有实验的所有实验运行所需的全部内容。换句话说，如果实验就像一个表，而实验运行就像表行，那么第50行将获取在给定顶点AI实例中创建的所有这些表的并集。这太多了，这就是为什么在第51行我们将第一个过滤器应用于结果数据帧，这将帮助我们只处理与我们的模型相对应的实验(表)的实验运行。此过滤器基于实验_测向数据框的实验_名称列。当然，这仍然比我们需要的多，因此在第54行中，我们应用了另一个过滤器，它将过滤掉所有不代表在该流水线执行中训练的挑战者的实验运行。如决策门设计部分所述，我们为此使用<strong class="ih hj"> training_set </strong>参数(因此我们在滤波器表达式中有<em class="lu"> param.training_set </em>)。在同一流水线执行中训练的所有挑战者应该具有相同的<strong class="ih hj">训练_设置</strong>参数值。</p><p id="c96b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在这个阶段，我们收集了一切有助于我们确定最佳挑战者的资料。</p><p id="cec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第59–60行使用与当前champion模型(如果存在)相对应的参数和指标进行实验运行。</p><p id="76e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第62行是我们实例化辅助变量的地方，它代表我们在决定哪个模型更好时想要使用的度量的名称。在我们的演示中，我们使用<em class="lu"> metric.model_auc_roc。</em></p><p id="562a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们准备好进入半决赛了——让我们的挑战者们一决高下吧！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ma"><img src="../Images/18c0852facc1098f23b045da9614e1d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEEGoE8jY71IBLF8vSEVzA.png"/></div></div></figure><p id="3798" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第64-67行用于查找对应于最佳挑战者(具有最大AUC ROC)的实验运行。</p><p id="a29b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当冠军模型在模型注册中不存在时，最佳挑战者成为冠军(第84-86行)——不需要<em class="lu">盛大的结局</em>。</p><p id="6977" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果champion确实存在，那么在第77行，我们将它放在特权位置，假设新的champion一定比当前的champion更好——否则我们将保持我们的生产系统不变。</p><p id="3394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第80行代表我们伟大的决赛，其中我们比较了当前冠军和最佳挑战者的AUC ROC指标。<strong class="ih hj">这个决策门表达式可以和我们文章中的一样简单，但是您可以在这里编码多个条件，如果您需要，可以使它变得更复杂(例如，使用从上次管道执行日期收集的数据作为验证集，以测量当前champion在新数据上的性能)。</strong></p><p id="cfc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的gate函数返回下游任务将使用的NamedTuple对象。如果该元组中的<em class="lu"> is_current_champion </em>字段被设置为真，则条件任务将停止流水线执行，而不执行下游任务。否则，它将启用最后一步，即在Vertex AI模型注册表中注册新的champion，并使用Vertex AI端点后面的无服务器托管基础架构将其部署为REST端点。</p><h1 id="2011" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">摘要</h1><p id="72c2" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">有了Vertex AI，你的团队非常接近于建立智能微服务的<strong class="ih hj">工厂</strong>，在那里新的模型被训练并通过可靠的管道交付给下游消费。你所有的模型都被版本化并注册在一个中央<strong class="ih hj">顶点人工智能模型注册中心</strong>。每个模型都有自己的历史，完全可以通过<strong class="ih hj">顶点人工智能实验进行审计。</strong>正如我们在本文中所展示的，<strong class="ih hj">顶点AI实验</strong>也可以用作自动化MLOps流水线的<strong class="ih hj">决策门的度量来源。我认为您的团队已经准备好再次与CRM产品负责人会面，并计划在您的ML工厂中建立新的创新。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mb"><img src="../Images/a06953203c0907a4a4eb6c79dd47b802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*17c7172W8dmfSVqe"/></div></div></figure><blockquote class="lr ls lt"><p id="94f3" class="if ig lu ih b ii ij ik il im in io ip lv ir is it lw iv iw ix lx iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">本文由</em></strong><a class="ae kt" href="https://www.linkedin.com/in/lukasz-olejniczak-1a75a613/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="hi">Lukasz Olejniczak</em></strong></a><strong class="ih hj"><em class="hi">和</em></strong><a class="ae kt" href="https://www.linkedin.com/in/jakubskuratowicz" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="hi">Jakub Skuratowicz</em></strong></a><strong class="ih hj"><em class="hi">合著。所表达的观点是作者的观点，不一定反映谷歌的观点。</em> </strong></p></blockquote><p id="7ec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，请为它鼓掌。有关基于google云的数据科学、数据工程和AI/ML主题的更多详细信息，请关注我的<a class="ae kt" href="https://www.linkedin.com/in/lukasz-olejniczak-1a75a613/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="lu">LinkedIn</em></strong></a><strong class="ih hj"><em class="lu">。</em>T49】</strong></p></div></div>    
</body>
</html>