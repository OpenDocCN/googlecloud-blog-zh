<html>
<head>
<title>Search on Google Cloud Platform — Cloud SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云平台搜索—云SQL</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/search-on-google-cloud-platform-cloud-sql-65a0f75b3af8?source=collection_archive---------4-----------------------#2018-08-09">https://medium.com/google-cloud/search-on-google-cloud-platform-cloud-sql-65a0f75b3af8?source=collection_archive---------4-----------------------#2018-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8a0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为主题“Google云平台上的搜索”系列的继续，在本文中，我将探索作为存储的<a class="ae jd" href="https://cloud.google.com/sql/" rel="noopener ugc nofollow" target="_blank">云SQL </a>，即用于文本搜索的PostgreSQL内置功能。本系列之前的文章/解决方案包括:</p><ul class=""><li id="5de9" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/google-cloud/search-on-google-cloud-platform-app-engine-and-search-api-31cda6917bbf">在谷歌云平台上搜索——应用引擎和搜索API </a></li><li id="02c1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/google-cloud/search-on-google-cloud-platform-cloud-datastore-615c14cb1bb">搜索谷歌云平台——云数据存储</a></li></ul><p id="043b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将重复以前文章中的任务描述:“在Google云平台上为eshop创建自动完成功能，这样当用户搜索一些文本时，它会返回包含该文本的产品名称”。在现实生活中，我使用的是百思买的产品数据。呈现搜索页面和结果的web服务器是在Flask framework (Python)中完成的，并部署在Google App Engine Flexible上。我使用灵活而非标准的原因是因为目前无法从GAE标准连接到云SQL PostgreSQL。</p><p id="837b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该项目的代码在<a class="ae jd" href="https://github.com/zdenulo/gcp-search/tree/master/cloud_sql" rel="noopener ugc nofollow" target="_blank"> Github </a>库中。</p><h1 id="fdad" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">谷歌云SQL</h1><p id="bae9" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">云SQL于2011年推出，最初支持MySQL，2017年推出对PostgreSQL的支持，从现在起，我将在PostgreSQL的上下文中使用云SQL的用法和属性。云SQL是完全托管的数据库，这意味着服务器和磁盘存储是自动调配的。它还有其他特点，如:</p><ul class=""><li id="4c20" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">自动备份，可以定义每天的备份窗口。</li><li id="7b0b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">自动存储增加，所以不应该发生你用完磁盘空间</li><li id="c419" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">通过不同区域中的副本实现高可用性</li><li id="0154" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">目前支持PostgreSQL 9.6，目前官方版本是10，11是测试版</li><li id="686a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">自定义CPU和内存配置，从1个共享CPU和0.6GB RAM开始，最多64个vcpu和416 GB RAM内存</li><li id="aa23" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">存储容量从10GB到10TB不等</li><li id="2de6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">最低配置从每月10美元起，其他服务如自动备份、副本当然需要额外费用</li><li id="8c4a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">从onpremise或其他云提供商迁移数据库</li><li id="32d9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">网络访问规则，可以定义访问数据库实例的IP地址(范围),也可以使用云sql代理<a class="ae jd" href="https://cloud.google.com/sql/docs/postgres/sql-proxy" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/sql/docs/postgres/sql-proxy</a></li></ul><h1 id="c9ec" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">数据库设置</h1><p id="2652" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我将使用<a class="ae jd" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a>来执行命令行操作，因此首先我将创建名为“myinstance”的数据库实例:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8a7b" class="le jt hi la b fi lf lg l lh li">gcloud sql instances create myinstance --database-version=POSTGRES_9_6 --cpu=1 --memory=3840MiB</span><span id="2157" class="le jt hi la b fi lj lg l lh li">Created [https://www.googleapis.com/sql/v1beta4/projects/adventures-on-gcp/instances/myinstance].<br/>NAME DATABASE_VERSION LOCATION TIER ADDRESS STATUS<br/>myinstance POSTGRES_9_6 us-central1-a db-custom-1-3840 35.232.43.115 RUNNABLE</span></pre><p id="d9f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:如果您的配置中没有设置zone和region，您可以在那里设置它，或者可以使用— zone和— region标志来指定数据库实例所在的区域和zone。</p><p id="2d04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注2:最好将web服务器和数据库实例放在同一个区域中，以获得最佳性能/最小延迟。</p><p id="df43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是在数据库实例中创建数据库:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="774f" class="le jt hi la b fi lf lg l lh li">gcloud sql databases create eshop --instance=myinstance<br/><br/>Creating Cloud SQL database...done. <br/>Created database [eshop].<br/>instance: myinstance<br/>name: eshop<br/>project: adventures-on-gcp</span></pre><p id="d93e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认用户<strong class="ih hj"> postgres </strong>是自动创建的，我将在这个例子中使用它，但是我需要为它设置密码。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="f30f" class="le jt hi la b fi lf lg l lh li">gcloud sql users set-password postgres --instance myinstance --host=% --prompt-for-password</span></pre><h1 id="4519" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">数据库模型</h1><p id="a831" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">所有与数据库相关的东西都在sql_search.py文件中。值得一提的是，我使用了<a class="ae jd" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> SQLAlchemy </strong> </a>作为ORM，并将<a class="ae jd" href="https://sqlalchemy-searchable.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">SQLAlchemy-Searchable</strong></a>集成到SQLAlchemy模型中。sql_search.py文件的内容:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9723" class="le jt hi la b fi lf lg l lh li">import os<br/>import sqlalchemy<br/>from sqlalchemy import create_engine, Column, String, Float, BigInteger<br/>from sqlalchemy.orm import sessionmaker<br/>from sqlalchemy.ext.declarative import declarative_base<br/>from sqlalchemy_searchable import make_searchable<br/>from sqlalchemy_utils.types import TSVectorType<br/>from sqlalchemy_searchable import search<br/>from sqlalchemy_searchable import sync_trigger<br/><br/>from db_settings import USERNAME, PASSWORD, DB_NAME<br/><br/><br/>SQLALCHEMY_DATABASE_URI = os.environ['SQLALCHEMY_DATABASE_URI']<br/><br/>if not SQLALCHEMY_DATABASE_URI:<br/>    SQLALCHEMY_DATABASE_URI='postgresql+psycopg2://{USER_NAME}:{PASSWORD}@127.0.0.1:5431/{DATABASE_NAME}'.format(<br/>        USER_NAME=USERNAME, PASSWORD=PASSWORD, DATABASE_NAME=DB_NAME<br/>    )<br/><br/># these are some necessary lines<br/>Base = declarative_base()<br/>make_searchable(Base.metadata)<br/>engine = create_engine(SQLALCHEMY_DATABASE_URI, echo=True)<br/>sqlalchemy.orm.configure_mappers()<br/><br/>Session = sessionmaker(bind=engine)<br/>session = Session()<br/><br/><br/>class Product(Base):<br/>    """Table for products"""<br/>    __tablename__ = 'products'<br/><br/>    sku = Column(BigInteger, primary_key=True)<br/>    product_name = Column(String)<br/>    price = Column(Float)<br/>    sale_price = Column(Float)<br/>    type = Column(String)<br/>    url = Column(String)<br/>    image = Column(String)<br/>    available = Column(String)<br/>    search_vector = Column(TSVectorType('product_name', ))  # this field is for full text search<br/><br/>    def __repr__(self):<br/>        return self.product_name<br/><br/><br/>class PostgreSQLSearch():<br/>    def init_schema(self):<br/>        """creates table"""<br/>        # configure_mappers()<br/>        session.commit()  # with out this line, Flask hangs for some reason<br/>        Base.metadata.create_all(engine)<br/>        sync_trigger(engine, 'products', 'search_vector', ['product_name'])<br/><br/>    def delete_all(self):<br/>        """deletes table"""<br/>        session.commit()  # with out this line, Flask hangs for some reason<br/>        Product.__table__.drop(engine)<br/><br/>    def insert_bulk(self, product_data):<br/>        """creates multiple row (objects) and commits into database"""<br/>        objects = []<br/>        for product in product_data:<br/>            if product.get('name', ''):<br/>                product_db = Product(sku=product['sku'], product_name=product['name'], price=product['price'],<br/>                                     url=product['url'], type=product['type'], available=product['available'],<br/>                                     sale_price=product['sale_price'], image=product['image']<br/>                                     )<br/>                objects.append(product_db)<br/>        session.bulk_save_objects(objects)<br/>        session.commit()<br/><br/>    def search(self, search_query):<br/>        """making query to database"""<br/>        query = session.query(Product)<br/>        query = search(query, search_query, sort=True)<br/>        results = query.limit(20).all()<br/>        output = []<br/>        for item in results:<br/>            out = {<br/>                'value': item.product_name,<br/>                'label': item.product_name,<br/>                'sku': item.sku<br/>            }<br/>            output.append(out)<br/>        return output<br/><br/><br/>if __name__ == '__main__':<br/>    db_client = PostgreSQLSearch()<br/>    db_client.init_schema()</span></pre><p id="794c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我定义了具有一些字段和特殊字段的类产品是<strong class="ih hj"> search_vector </strong>，其中是为文本搜索定义的向量和应该被索引的字段。因此，当保存实例(插入行)时，它会自动处理来自product_name的文本并填充search_vector字段。除此之外，没有什么特别的，我创建了批量上传，查询，创建和删除表的方法。</p><h2 id="c600" class="le jt hi bd ju lk ll lm jy ln lo lp kc iq lq lr kg iu ls lt kk iy lu lv ko lw bi translated">上传数据</h2><p id="56f6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们有120万行产品数据，由于SQLAlchemy searchable只有在对象通过SQLAlchemy保存时才有效，因此很遗憾，直接导入大量csv文件是不可能的。这就是为什么我编写脚本来创建对象并保存到数据库中(这不是最有效的方式，但我想我没有选择)。另一件事是，因为我希望它尽可能快，我会在同一个区域创建服务器。(尝试从您的本地计算机上传，您会注意到很大的不同，尤其是如果数据库实例在地球的另一半)。</p><p id="1bcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建Google计算引擎实例，命令是:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1c77" class="le jt hi la b fi lf lg l lh li">gcloud compute instances create instance-1 --scopes=sql-admin --preemtible<br/>Created [https://www.googleapis.com/compute/v1/projects/adventures-on-gcp/zones/us-central1-a/instances/instance-1].<br/>NAME        ZONE           MACHINE_TYPE   PREEMPTIBLE  INTERNAL_IP  EXTERNAL_IP   STATUS<br/>instance-1  us-central1-a  n1-standard-1               10.128.0.4   35.206.91.84  RUNNING</span></pre><p id="01b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在添加计算引擎的特定范围，以便它可以被授权使用云SQL，我正在使用preemtible，因为这将花费不到几个小时的时间……每一分都很重要。</p><p id="8c1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将复制整个存储库的代码，因为其中有我的csv文件和产品数据。这可能需要几分钟，因为有许多文件，更简单的是压缩它，只复制一个文件，然后解压缩。</p><p id="5d74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将文件夹从本地计算机复制到服务器:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ea53" class="le jt hi la b fi lf lg l lh li">gcloud compute scp --recurse gcp-search instance-1:~/</span></pre><p id="3b8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ssh进入服务器</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8071" class="le jt hi la b fi lf lg l lh li">gcloud compute ssh instance-1</span></pre><p id="e830" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正在安装pip，这样我就可以安装Python的其余依赖项了:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9009" class="le jt hi la b fi lf lg l lh li">sudo apt-get install python-pip</span></pre><p id="53ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到服务器上的cloud_sql/webapp文件夹并安装python依赖项:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="a6f0" class="le jt hi la b fi lf lg l lh li">pip install -r requirements.txt</span></pre><p id="d313" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，检查存储库根目录下settings.py中的变量PRODUCTS_LOCAL_PATH是否反映了服务器上的路径，如果没有，则更新它。</p><p id="96ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个重要部分是处理到数据库实例的连接。就像我在开始写的，一种可能性是允许特定的IP地址(我们的服务器)访问，或者使用云SQL的代理。我将使用第二种选择。第一步是使用命令下载代理的二进制文件:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9e2a" class="le jt hi la b fi lf lg l lh li">wget <a class="ae jd" href="https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64" rel="noopener ugc nofollow" target="_blank">https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64</a> -O cloud_sql_proxy</span></pre><p id="f888" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将其更改为可执行:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="c0cf" class="le jt hi la b fi lf lg l lh li">chmod +x cloud_sql_proxy</span></pre><p id="3add" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要获取云sql数据库实例的“实例连接名称”:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9f15" class="le jt hi la b fi lf lg l lh li">gcloud sql instances describe myinstance<br/>backendType: SECOND_GEN<br/>connectionName: adventures-on-gcp:us-central1:myinstance<br/>databaseVersion: POSTGRES_9_6<br/>...</span></pre><p id="9190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二行(connectionName)包含我们需要的信息。连接名通常采用<project-id> : <region> : <instance-name>的格式。</instance-name></region></project-id></p><p id="5489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好打开另一个终端，通过ssh连接到服务器实例，并使用以下命令运行代理:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3d7a" class="le jt hi la b fi lf lg l lh li">./cloud_sql_proxy -instances=adventures-on-gcp:us-central1:myinstance=tcp:5431<br/><br/>2018/08/08 12:56:58 Listening on 127.0.0.1:5431 for adventures-on-gcp:us-central1:myinstance<br/>2018/08/08 12:56:58 Ready for new connections<br/>2018/08/08 12:58:31 New connection for "adventures-on-gcp:us-central1:myinstance"<br/>2018/08/08 12:58:37 Client closed local connection on 127.0.0.1:5431</span></pre><p id="478b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在另一个终端窗口中，您可以执行第一个scipt(从文件夹webapp)在数据库中创建表格，我们将在其中上传数据:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="361e" class="le jt hi la b fi lf lg l lh li">python sql_search.py</span></pre><p id="76eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和其他命令开始上传过程(从文件夹cloud_sql)</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b21a" class="le jt hi la b fi lf lg l lh li">python upload_data.py</span></pre><p id="5326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望不会有错误，脚本打印每10000次插入的时间戳。整个过程花了我大约15分钟。</p><p id="ec5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于数据库的所有工作都完成了，可以删除GCE服务器了</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="f11d" class="le jt hi la b fi lf lg l lh li">gcloud compute instances delete instance-1<br/>The following instances will be deleted. Any attached disks configured<br/> to be auto-deleted will be deleted unless they are attached to any <br/>other instances or the `--keep-disks` flag is given and specifies them<br/> for keeping. Deleting a disk is irreversible and any data on the disk<br/> will be lost.<br/> - [instance-1] in [us-central1-a]<br/><br/>Do you want to continue (Y/n)?  <br/><br/><br/>Deleted [https://www.googleapis.com/compute/v1/projects/adventures-on-gcp/zones/us-central1-a/instances/instance-1].</span></pre><h1 id="1837" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Web服务器部署</h1><p id="7fa2" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">Web服务器基本上与以前的文章相同，简单的Flask应用程序，带有一些端点，我将在Google App Engine上部署这些端点。关于云SQL连接，需要在GAE的app.yaml文件中设置具体的配置。这就是app.yaml的生活。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b1ba" class="le jt hi la b fi lf lg l lh li">runtime: python<br/>env: flex<br/>entrypoint: gunicorn -b :$PORT main:app<br/><br/>runtime_config:<br/>  python_version: 3<br/><br/><br/>env_variables:<br/>    # Replace user, password, database, and instance connection name with the values obtained<br/>    # when configuring your Cloud SQL instance.<br/>    # postgresql+psycopg2://&lt;username&gt;:&lt;password&gt;@/&lt;database name&gt;?host=/cloudsql/&lt;instance connection name&gt;<br/>    SQLALCHEMY_DATABASE_URI: postgresql+psycopg2://postgres:mypass@/eshop?host=/cloudsql/adventures-on-gcp:us-central1:myinstance<br/><br/>beta_settings:<br/>    # cloud_sql_instances: &lt;instance connection name&gt;<br/>    cloud_sql_instances: adventures-on-gcp:us-central1:myinstance</span></pre><p id="cd3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我在本地(通过代理)和在GAE(在sql_search.py中使用)使用数据库时，我使用环境变量SQLALCHEMY_DATABASE_URI来区分连接配置。</p><p id="c3e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">beta_settings是也需要的特定设置，它包含实例连接名称</p><p id="6a46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果设置了这些变量，则使用以下命令部署应用程序:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="5340" class="le jt hi la b fi lf lg l lh li">gcloud app deploy app.yaml --promote</span></pre><p id="6d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这需要一些时间(有时甚至10分钟),因为Docker映像是创建和部署的。</p><p id="11dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在网址<a class="ae jd" href="http://&lt;project-id&gt;.appspot.com" rel="noopener ugc nofollow" target="_blank">http://&lt;project-id&gt;. appspot . com</a>查看申请</p><figure class="kv kw kx ky fd ly er es paragraph-image"><div class="er es lx"><img src="../Images/dc0c0075c4ad889cd8b44615d1eb3b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*BRxBXV96JylzSNHb.png"/></div></figure><h1 id="764d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">负载测试</h1><p id="eb31" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">因为一切都正常，就像在以前的案例中一样，我使用Kubernetes集群上部署的Locust框架进行负载测试。更多详情在这里<a class="ae jd" href="https://www.the-swamp.info/blog/search-google-cloud-platform-app-engine-and-search-api/" rel="noopener ugc nofollow" target="_blank">https://www . the-swamp . info/blog/search-Google-cloud-platform-app-engine-and-search-API/</a>(负载测试下)以及如何设置集群在这里<a class="ae jd" href="https://github.com/zdenulo/gcp-search/tree/master/load-testing" rel="noopener ugc nofollow" target="_blank">https://github . com/zde nulo/GCP-search/tree/master/Load-Testing</a>。出于测试目的，我部署了已经运行了10个实例的GAE应用程序(具有自动缩放功能),因为GAE Flex在旋转新实例方面比GAE标准慢得多，我不希望自动缩放影响结果。</p><figure class="kv kw kx ky fd ly er es paragraph-image"><div class="er es mb"><img src="../Images/98813258ae16702f5e62de1d6846e3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*8p8qTNw3Fdc5tUlv.png"/></div></figure><figure class="kv kw kx ky fd ly er es paragraph-image"><div class="er es mb"><img src="../Images/77d2157ce9f545069ef3870fdccb5bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*BW16bSKDTOAzGgxC.png"/></div></figure><figure class="kv kw kx ky fd ly er es paragraph-image"><div class="er es mb"><img src="../Images/daeefcacf836a07c421685de72ca7308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*p0GYmKuO6e5EAnCo.png"/></div></figure><p id="cbc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我以每秒5个用户的孵化率运行了2000个用户。从图中可以看出，测试持续了大约10分钟，没有服务器错误或类似错误，最后我认为它总共运行了13个实例。总共有218816个请求，平均响应时间为16毫秒，平均响应时间为20毫秒，这是迄今为止最快的解决方案。值得注意的是，数据库服务器的CPU负载峰值在30%左右。</p><figure class="kv kw kx ky fd ly er es paragraph-image"><div class="er es mb"><img src="../Images/be3a1960ed3f4275a4b073e861814f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*xsP_kIsJowXSA9Qh.png"/></div></figure><h1 id="3ec3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="5df0" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">由于PostreSQL经过了实战测试，是最受欢迎的开源SQL数据库之一，并且提供了许多额外的特性，因此它可以成为用于eshops数据库存储或类似用途的绝佳选择。在此基础上的云SQL提供了可管理的功能，如轻松扩展服务器实例的可能性、自动备份和高可用性。</p></div></div>    
</body>
</html>