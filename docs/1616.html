<html>
<head>
<title>Service Account Credentials API: A solution to different issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务帐户凭证API:不同问题的解决方案</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/service-account-credentials-api-a-solution-to-different-issues-dc7434037115?source=collection_archive---------0-----------------------#2020-10-12">https://medium.com/google-cloud/service-account-credentials-api-a-solution-to-different-issues-dc7434037115?source=collection_archive---------0-----------------------#2020-10-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8f36e85bed21d67f4994329a4e1f7f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AF-KgFbEDB5Ipy9IqNSu0A.png"/></div></div></figure><p id="633d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> IAM </strong>(身份和访问管理)是<strong class="is hj">谷歌云</strong>的支柱。它验证并授权帐户(用户帐户或服务帐户)访问资源。我<a class="ae jo" rel="noopener" href="/google-cloud/the-2-limits-of-iam-service-on-google-cloud-7db213277d9c">已经提到了这个服务</a>的一些局限性，特别是当<strong class="is hj">你想避免服务账户密钥文件的使用</strong>，从而为<strong class="is hj">避免重大安全风险</strong>。</p><p id="506f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了帮助解决这个问题，Google Cloud引入了一个新的API: <a class="ae jo" href="https://cloud.google.com/iam/docs/reference/credentials/rest" rel="noopener ugc nofollow" target="_blank">服务帐户凭证API </a>。实际上，<strong class="is hj">并不是真正的新</strong>(2018年6月公测发布)，而是<strong class="is hj">鲜为人知或了解的</strong>。然而，它可以在两个典型的用例中有所帮助。</p><ul class=""><li id="cdea" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">不使用元数据服务器生成</strong> <code class="du jy jz ka kb b"><strong class="is hj">id_token</strong></code>(例如本地)</li><li id="bc5c" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn ju jv jw jx bi translated"><strong class="is hj">生成云存储签名url </strong>无服务账户私钥</li></ul></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="8612" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">元数据服务器不可用</h1><p id="ae36" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated"><a class="ae jo" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">元数据服务器</strong> </a> <strong class="is hj">提供运行平台上的上下文信息</strong>。它<strong class="is hj">只在所有谷歌云服务</strong>上可用，并且对于查找服务上下文信息(项目ID、位置)或<strong class="is hj">从服务的服务帐户</strong>获取凭证信息很有用。</p><p id="6eac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">例如，要从云运行中执行“服务对服务”调用，您必须按照文档中描述的</em> <a class="ae jo" href="https://cloud.google.com/run/docs/authenticating/service-to-service" rel="noopener ugc nofollow" target="_blank"> <em class="lr">来使用它。</em> </a></p><p id="6349" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，元数据服务器<strong class="is hj">只能从Google Cloud </strong>服务访问，基本URL是明确的<code class="du jy jz ka kb b">http://metadata.google.internal</code></p><blockquote class="ls"><p id="d98a" class="lt lu hi bd lv lw lx ly lz ma mb jn dx translated">如何用元数据服务器<strong class="ak">在本地</strong>测试代码？</p></blockquote><p id="51db" class="pw-post-body-paragraph iq ir hi is b it mc iv iw ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated"><em class="lr">为了确保本地和云上的相同行为，约束是</em> <strong class="is hj"> <em class="lr">在所有环境</em> </strong> <em class="lr">上拥有完全相同的代码。</em></p><p id="70a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这一点，你<strong class="is hj">需要避免使用</strong>元数据服务器，至少要生成<strong class="is hj">所需的</strong> <code class="du jy jz ka kb b"><strong class="is hj">id_token</strong></code> <strong class="is hj">来访问私有的无服务器服务</strong>比如:</p><ul class=""><li id="6c1e" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">私有云运行</li><li id="8c5b" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn ju jv jw jx bi translated">私有云功能</li><li id="48a1" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn ju jv jw jx bi translated">IAP背后的应用引擎</li></ul><h2 id="68cd" class="mh kp hi bd kq mi mj mk ku ml mm mn ky jb mo mp lc jf mq mr lg jj ms mt lk mu bi translated">访问要求</h2><p id="1017" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">要访问这些私有的无服务器服务，您需要<strong class="is hj">拥有有效的</strong> <code class="du jy jz ka kb b"><strong class="is hj">id_token</strong></code> <strong class="is hj">和正确的受众</strong>。您只能在服务帐户上<strong class="is hj">生成:</strong></p><ul class=""><li id="6102" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">使用服务帐户密钥文件，这是一个糟糕的安全想法</li><li id="4df2" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn ju jv jw jx bi translated">对于元数据服务器，当<strong class="is hj">可用时</strong> <em class="lr">(即不在本地)</em></li><li id="13b1" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn ju jv jw jx bi translated">使用<strong class="is hj">服务账户凭证API </strong></li></ul><p id="bff4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">不可能用一个用户凭证</em>  <em class="lr">生成一个有效的</em>  <code class="du jy jz ka kb b"><strong class="is hj"><em class="lr">id_token</em></strong></code> <strong class="is hj"> <em class="lr">，正如我在上一篇文章</em> 中解释的 <a class="ae jo" rel="noopener" href="/google-cloud/the-2-limits-of-iam-service-on-google-cloud-7db213277d9c"> <em class="lr"/></a></strong></p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="29c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，要<strong class="is hj">访问Google API </strong>，比如服务账户凭证API、存储API，甚至GMail API (…)，你<strong class="is hj">需要一个</strong> <code class="du jy jz ka kb b"><strong class="is hj">access_token</strong></code>，而不是一个<code class="du jy jz ka kb b">id_token</code>。这个区别很重要，因为<strong class="is hj">可以用</strong>生成一个 <code class="du jy jz ka kb b"><strong class="is hj">access_token</strong></code> <strong class="is hj"/></p><ul class=""><li id="6bff" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">通过元数据服务器使用密钥文件或<strong class="is hj">的<strong class="is hj">服务帐户</strong></strong></li><li id="2a21" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn ju jv jw jx bi translated">一个<strong class="is hj">用户帐户</strong>，因此在本地具有ADC(应用程序默认凭证)</li></ul><blockquote class="mv mw mx"><p id="5f2c" class="iq ir lr is b it iu iv iw ix iy iz ja my jc jd je mz jg jh ji na jk jl jm jn hb bi translated"><em class="hi">综上所述，你</em> <strong class="is hj"> <em class="hi">可以在任意条件下</em> </strong> <em class="hi">生成一个</em>  <code class="du jy jz ka kb b"><strong class="is hj"><em class="hi">access_token</em></strong></code> <strong class="is hj"> <em class="hi">。</em></strong></p></blockquote><h2 id="e95b" class="mh kp hi bd kq mi mj mk ku ml mm mn ky jb mo mp lc jf mq mr lg jj ms mt lk mu bi translated">避免元数据服务器请求</h2><p id="dcec" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">所以现在，您必须用服务帐户凭证API替换元数据服务器调用，以构建一个合适的替代方案</p><ol class=""><li id="c1f1" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn nb jv jw jx bi translated"><strong class="is hj">获取访问令牌</strong>以执行对服务帐户凭证API的安全请求</li><li id="2a4d" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn nb jv jw jx bi translated"><strong class="is hj">获取您想要生成<code class="du jy jz ka kb b">id_token</code>的服务账户电子邮件</strong></li><li id="8421" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn nb jv jw jx bi translated"><strong class="is hj">使用正确的受众调用服务帐户凭证API </strong>来生成<code class="du jy jz ka kb b">id_token</code></li></ol><p id="4588" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要做到这一点，下面的代码示例中Python生成的<code class="du jy jz ka kb b">id_token</code> <br/> <code class="du jy jz ka kb b"><em class="lr">google-auth</em></code> <em class="lr">和</em> <code class="du jy jz ka kb b"><em class="lr">requests</em></code> <em class="lr">依赖项需要安装</em></p><pre class="nc nd ne nf fd ng kb nh ni aw nj bi"><span id="39eb" class="mh kp hi kb b fi nk nl l nm nn">import google.auth<br/>from google.auth.transport.requests import AuthorizedSession<br/>import json</span><span id="892b" class="mh kp hi kb b fi no nl l nm nn"># IAP audience is the ClientID of IAP-App-Engine-app in <br/># the API-&gt;credentials page<br/># Cloud Function and Cloud Run need the base URL of the service<br/>audience = 'YOUR AUDIENCE'</span><span id="fa38" class="mh kp hi kb b fi no nl l nm nn"># <strong class="kb hj">#1 Get the default credential to generate the access token</strong><br/>credentials, project_id = google.auth.default(<br/>            scopes='https://www.googleapis.com/auth/cloud-platform')<br/><br/># <strong class="kb hj">#2 To use the current service account email</strong><br/>service_account_email = credentials.service_account_email<br/># Don't work with user account, so define manually the email<br/># service_account_email = 'MY SERVICE ACCOUNT EMAIL'</span><span id="3b2f" class="mh kp hi kb b fi no nl l nm nn"># <strong class="kb hj">#3 prepare the call the the service account credentials API</strong><br/>sa_credentials_url =  f'https://iamcredentials.googleapis.com/' \<br/>                      f'v1/projects/-/serviceAccounts/'  \<br/>                      f'{service_account_email}:generateIdToken'</span><span id="b073" class="mh kp hi kb b fi no nl l nm nn">headers = {'Content-Type': 'application/json'}<br/><br/># <strong class="kb hj">Create an AuthorizedSession</strong> that includes <br/># automatically the access_token based on your credentials<br/>authed_session = AuthorizedSession(credentials)</span><span id="c20a" class="mh kp hi kb b fi no nl l nm nn"># <strong class="kb hj">Define the audience in the request body</strong><br/># add the parameter "'includeEmail':true" for IAP access<br/>body = json.dumps({'audience': audience})</span><span id="4288" class="mh kp hi kb b fi no nl l nm nn"># <strong class="kb hj">Make the call</strong> <br/>token_response = authed_session.request('POST',sa_credentials_url,<br/>                                        data=body, headers=headers)<br/><br/>jwt = token_response.json()</span><span id="0a35" class="mh kp hi kb b fi no nl l nm nn">id_token = jwt['token']</span></pre><p id="a31b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在<strong class="is hj">已经有了</strong> <code class="du jy jz ka kb b"><strong class="is hj">id_token</strong></code>，您可以调用您想要的私有无服务器服务API，例如</p><pre class="nc nd ne nf fd ng kb nh ni aw nj bi"><span id="30f0" class="mh kp hi kb b fi nk nl l nm nn">import requests</span><span id="97fb" class="mh kp hi kb b fi no nl l nm nn">headers = {'Authorization': f'bearer {id_token}'}<br/>service_response = requests.get(service_url, headers=headers)</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="fe83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">现在，你有了！</strong>这段代码<strong class="is hj">在本地工作，在云中<em class="lr">几乎</em>无缝</strong>。<em class="lr">的确，在本地，有了用户凭证，你需要定义要使用的服务帐户。</em></p><h2 id="6ac2" class="mh kp hi bd kq mi mj mk ku ml mm mn ky jb mo mp lc jf mq mr lg jj ms mt lk mu bi translated">角色和权限</h2><p id="de1b" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">当您执行此操作时，您需要设置正确的权限，因为</p><blockquote class="mv mw mx"><p id="ffb0" class="iq ir lr is b it iu iv iw ix iy iz ja my jc jd je mz jg jh ji na jk jl jm jn hb bi translated">您要求帐户(由<em class="hi"> </em> <code class="du jy jz ka kb b"><em class="hi">access_token</em></code>标识)代表服务帐户电子邮件生成一个ID令牌</p></blockquote><p id="51e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，请求者(由<code class="du jy jz ka kb b">access_token</code> ) <strong class="is hj">需要在服务帐户</strong>上拥有 <code class="du jy jz ka kb b"><strong class="is hj">Service Account Token Creator</strong></code> <strong class="is hj">角色。</strong></p><h2 id="d986" class="mh kp hi bd kq mi mj mk ku ml mm mn ky jb mo mp lc jf mq mr lg jj ms mt lk mu bi translated">特殊情况:元数据服务器部分可用</h2><p id="317d" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">关于栈溢出，<a class="np nq ge" href="https://medium.com/u/6d75218cbac2?source=post_page-----dc7434037115--------------------------------" rel="noopener" target="_blank"> Fabian </a>发表了一个关于云构建的<a class="ae jo" href="https://stackoverflow.com/questions/64252736/google-cloud-build-fetch-identity-token/64268716" rel="noopener ugc nofollow" target="_blank">问题。云构建的<strong class="is hj">行为不是标准的</strong>:它允许你基于元数据服务器生成<code class="du jy jz ka kb b">access_token</code>，而不是<code class="du jy jz ka kb b">id_token</code>。<em class="lr">类似技术限制的东西</em>。<br/>和Fabian <strong class="is hj">需要在构建</strong>期间调用私有云函数，因此，他需要在请求头中添加一个<code class="du jy jz ka kb b">id_token</code>！</a></p><p id="a953" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，通过重用此解决方案和<strong class="is hj">避免为</strong> <code class="du jy jz ka kb b"><strong class="is hj">id_token</strong></code> <strong class="is hj">代</strong>使用元数据服务器 <strong class="is hj">，他已经能够实现他的私有云功能调用！</strong></p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="f5ad" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建不带私钥的签名url</h1><p id="c715" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">第二个用例也是一个安全问题。的确，当你想<strong class="is hj">生成一个</strong> <a class="ae jo" href="https://cloud.google.com/storage/docs/access-control/signed-urls" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">云存储签名的url </strong> </a> <strong class="is hj">时，需要一个服务账号私钥。</strong></p><blockquote class="ls"><p id="fd2d" class="lt lu hi bd lv lw lx ly lz ma mb jn dx translated">但是，这个私钥的用途是什么呢？</p></blockquote><p id="139d" class="pw-post-body-paragraph iq ir hi is b it mc iv iw ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn hb bi translated">私钥可用于</p><ul class=""><li id="65e9" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">在非对称加密的情况下，解密加密数据</strong>(用公钥加密)；<em class="lr">这不是用例</em></li><li id="7fb0" class="jp jq hi is b it kc ix kd jb ke jf kf jj kg jn ju jv jw jx bi translated"><strong class="is hj">签署数据以证明签署者身份</strong>(根据公钥验证签名)</li></ul><p id="0a44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，服务帐户凭证API <a class="ae jo" href="https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob" rel="noopener ugc nofollow" target="_blank">允许您代表</a>在 <a class="ae jo" href="https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob" rel="noopener ugc nofollow" target="_blank">服务帐户</a> <a class="ae jo" href="https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob" rel="noopener ugc nofollow" target="_blank">上签署数据。<strong class="is hj">用起来吧</strong>！</a></p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="c352" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这次，<strong class="is hj">我就不重写SignedUrl方法</strong>了，但是如果你在Python库中深潜，就能看到这个<a class="ae jo" href="https://github.com/googleapis/python-storage/blob/fcd1c4f7c947eb95d6937783fd69670a570f145e/google/cloud/storage/_signing.py#L623" rel="noopener ugc nofollow" target="_blank"> <em class="lr">(摘录自</em></a><code class="du jy jz ka kb b"><a class="ae jo" href="https://github.com/googleapis/python-storage/blob/fcd1c4f7c947eb95d6937783fd69670a570f145e/google/cloud/storage/_signing.py#L623" rel="noopener ugc nofollow" target="_blank"><em class="lr">_signing.py</em></a></code><a class="ae jo" href="https://github.com/googleapis/python-storage/blob/fcd1c4f7c947eb95d6937783fd69670a570f145e/google/cloud/storage/_signing.py#L623" rel="noopener ugc nofollow" target="_blank"><em class="lr">)</em></a></p><pre class="nc nd ne nf fd ng kb nh ni aw nj bi"><span id="e741" class="mh kp hi kb b fi nk nl l nm nn">...<br/>if access_token and service_account_email:<br/>   signature = _sign_message(string_to_sign, access_token,<br/>                                             service_account_email)<br/>...</span></pre><blockquote class="mv mw mx"><p id="045d" class="iq ir lr is b it iu iv iw ix iy iz ja my jc jd je mz jg jh ji na jk jl jm jn hb bi translated">如果<strong class="is hj">提供了<code class="du jy jz ka kb b">generate_signed_url</code>参数中的</strong> <code class="du jy jz ka kb b"><strong class="is hj">access_token</strong></code> <strong class="is hj">和</strong> <code class="du jy jz ka kb b"><strong class="is hj">service_account_email</strong></code>，则<code class="du jy jz ka kb b"><strong class="is hj">_sign_message</strong></code> <strong class="is hj">称为</strong></p></blockquote><p id="ae5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而且，如果你沿着<code class="du jy jz ka kb b"><a class="ae jo" href="https://github.com/googleapis/python-storage/blob/fcd1c4f7c947eb95d6937783fd69670a570f145e/google/cloud/storage/_signing.py#L671" rel="noopener ugc nofollow" target="_blank">_sign_message</a></code> <a class="ae jo" href="https://github.com/googleapis/python-storage/blob/fcd1c4f7c947eb95d6937783fd69670a570f145e/google/cloud/storage/_signing.py#L671" rel="noopener ugc nofollow" target="_blank">走，你会看到这个</a></p><pre class="nc nd ne nf fd ng kb nh ni aw nj bi"><span id="e6f2" class="mh kp hi kb b fi nk nl l nm nn">url = "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{}:signBlob?alt=json".format(service_account_email)</span></pre><p id="9f01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">正是我们需要的！</strong>所以现在，我们只需要正确调用初始的<code class="du jy jz ka kb b">generate_signed_url</code>方法</p><pre class="nc nd ne nf fd ng kb nh ni aw nj bi"><span id="545c" class="mh kp hi kb b fi nk nl l nm nn">from google.cloud import storage<br/>from datetime import datetime, timedelta<br/>import google.auth<br/>from google.auth.transport import requests    </span><span id="67ea" class="mh kp hi kb b fi no nl l nm nn"><strong class="kb hj"># Get the default credential on the current environment</strong><br/>credentials, project_id = google.auth.default()<br/><br/><strong class="kb hj"># Perform a refresh request to get the access token </strong><br/># of the current credentials (Else, its value is 'None')<br/>r = requests.Request()<br/>credentials.refresh(r)<br/><br/><strong class="kb hj"># Create your storage object to sign</strong><br/>client = storage.Client()<br/>bucket = client.get_bucket('MY_BUCKET')<br/>blob = bucket.get_blob('my_path/my_file.txt')<br/>expires = datetime.now() + timedelta(seconds=86400)<br/><br/><strong class="kb hj"># In case of user credential usage</strong>, you have to define manually <br/># the service account to use <strong class="kb hj">(for development purpose only)</strong><br/>service_account_email = "YOUR DEV SERVICE ACCOUNT"<br/><strong class="kb hj"># If you use a service account credential, you can use it directly</strong><br/>if hasattr(credentials, "service_account_email"):<br/>    service_account_email = credentials.service_account_email<br/><br/>url = blob.generate_signed_url(expiration=expires,<br/>                   service_account_email=service_account_email, <br/>                   access_token=credentials.token)<br/>print(url)</span></pre><p id="495f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">嘣，你生成了一个没有任何私钥的签名URL</strong>本地存储！您使用<strong class="is hj">相同的云存储功能，并且增加了您的安全性</strong>(没有秘密需要管理)。</p><p id="1ada" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">该云存储客户端库容量</em> <strong class="is hj"> <em class="lr">可通过Python获得。在Go </em> </strong> <em class="lr">中还没有。检查您最喜欢的语言的客户端库中的signedUrl代码，以验证这种能力。</em></p><h1 id="5241" class="ko kp hi bd kq kr nr kt ku kv ns kx ky kz nt lb lc ld nu lf lg lh nv lj lk ll bi translated">尽可能使用它！</h1><p id="0389" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">该<strong class="is hj">服务帐户凭据应用编程接口可以在许多情况下</strong>帮助您，在这些情况下，您需要的操作只有使用服务帐户密钥文件才有可能。您<strong class="is hj">通过执行一个简单的API调用</strong>来增加您的应用程序安全性！太棒了，不是吗？</p><p id="49cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了这两个有用的特性和用例之外，您还可以，例如，用这个API<strong class="is hj">模拟一个服务帐户或者签署一个JWT令牌</strong>。</p><p id="77b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">我希望这个API现在不再那么神秘了</strong>因为它真的很有帮助！</p></div></div>    
</body>
</html>