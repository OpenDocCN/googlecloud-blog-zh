# 使用 terraform 管理云基础架构的五件事

> 原文：<https://medium.com/google-cloud/five-things-learned-using-terraform-to-manage-cloud-infrastructure-5ad0d4aa0648?source=collection_archive---------1----------------------->

HashiCorp 的 [terraform](https://www.terraform.io/) 是一个强大且可扩展的工具，用于以可重复的方式定义和创建云基础设施。在 [Olark](https://www.olark.com/) 我们用它来管理谷歌云平台上的许多不同环境。在从命令式基础设施到声明式基础设施的过程中，我们学到了一些东西。这里有五个我觉得特别重要的。以下完全是我自己的看法。

![](img/187d30f9892c6fdc5af7be367c01b171.png)

# **使用远程状态**

Terraform 的工作方式是处理清单文件中的一组声明，并生成一个 json 表示，表示您的环境的期望状态。它将这些数据存储在一个文件中。tfstate 扩展，然后生成一个计划，将云资源的实际状态驱动到期望的状态。清单文件和产生的状态在工具运行之间都是持久的，因此在任何给定的时间，如果不打算进行任何更改，那么针对清单运行工具应该不会在生成的状态文件中产生任何差异，也不会计划更改资源。默认情况下，terraform 存储。tfstate 文件，位于本地名为。从你的项目的根开始。这种行为对于实验来说是很好的，并且可能适用于一个单独从事一个项目的工程师。一旦你有多个团队成员在一个环境中工作，地方政府就不能再削减它了。

大多数可能发生的问题都属于竞态条件这一大类。工程师 A 添加了一个东西并运行 terraform，这个东西被创建，本地状态被更新，然后工程师 B 来做其他事情并删除这个东西，因为她的本地状态说它不应该在那里。解决这个问题的一个方法是在源代码控制中管理状态文件。如果在运行 terraform 之前获取状态的最新更改，然后提交结果，您可以在某种程度上实现这一点。问题在于“如果”。我们组的一个内部笑话是 terraform 可以“土化”。我个人在. tf 清单上犯了一个错误，不得不麻木地看着 terraform 删除了我们为新环境准备的 100 多个虚拟机。这并不令人愉快。

> 一旦你有多个团队成员在一个环境中工作，地方政府就不能再削减它了

更好的方法是配置 terraform，将状态文件存储在中央[远程位置](https://www.terraform.io/docs/state/remote.html)。支持几种不同的存储后端，我们选择使用一个[谷歌云存储](https://cloud.google.com/storage/)桶。一旦您通过将适当的声明添加到您的主清单中进行了配置，那么处理该文件的每个人都将读取和写入相同的状态，并且许多潜在的竞争条件问题将被有效地防止。然而，远程状态没有解决的一个问题是争用:工程师仍然可以尝试在同一时间对同一资源做冲突的事情。一个解决方案是锁定，它在后端如 [etcd](https://coreos.com/etcd) 和[consult](https://www.consul.io/)上受支持，但在 GCS 上不受支持。我们可以采用锁定后端，但是现在我们选择采用一个简单的规则:没有人从他们的本地机器写状态。这让我想到了…

# 自动化构建

terraform 工具链最重要的特征是它是可预测的:在将它应用到您的环境之前，您必须知道给定操作的结果。Terraform 的默认操作模式鼓励了这一点。当您运行该工具时，它会生成一个人类可读的计划，而无需进行任何实际的更改。如果计划可以接受，您可以再次运行该工具，包括`apply`命令来更新资源。如果更改成功，那么远程状态文件将被更新，工具的下一次运行将看到新的状态作为基线。这一切都很好，但是实际上，如果您在本地运行工具并写入远程状态，您仍然有资源争用的机会，我甚至不能假装我们已经针对重叠更改等所有可能的边缘情况进行了测试。

为了避免这一切，我们从不在本地运行该工具。相反，我们将清单文件视为我们管理的所有其他源代码:它存储在 git repo 中，当提交更改时，我们会自动运行我们的构建。我们的 git repos 是在 gitlab 中自托管的，并且 [gitlab pipelines](https://docs.gitlab.com/ee/ci/pipelines.html) 是一个很好的抽象，它让我们以一种与上面概述的协议一致的方式运行我们的 terraform 构建。我们使用两级管道来处理对清单的提交。第一个阶段在提交时自动发生，并针对当前清单运行工具，生成一个计划。如果该阶段成功，那么可以检查计划输出，并且可以通过单击 gitlab UI 中的 deploy 按钮来手动启动第二阶段。如果提交到除主服务器之外的任何分支，则只能运行临时部署。

> …如果您在本地运行该工具并写入远程状态，您仍有可能发生资源争用

部署步骤应用计划中的更改并更新远程状态文件。通过这种方式，我们使用 terraform 对变更的执行进行了大量控制，并且我们已经能够避免上述所有问题。显然，这对单个工程师来说会带来更多的开销，但从我的角度来看，作为一个意外删除了 100 多个虚拟机的人，知道按下按钮后会发生什么的安全感比围绕部署的额外工具和流程更值得。这个工具对我们来说一直工作得很好，但是有一个小漏洞没有关闭:当计划和应用阶段之间发生变化时会发生什么？如何避免这个问题是下一篇技巧文章的主题。

# 在应用之前序列化计划

好吧，你设置了这一切，这很酷。你对你的清单做了一些修改并提交，检查计划，一切看起来都很好。就在这时，你得到了一个松弛的 ping，并陷入了一个 15 分钟的事情。你回来，再次浏览计划，点击部署按钮和红色文字墙。到底发生了什么？可能发生的情况是，当您在处理副业时，其他人执行了一个 terraform 操作，该操作更改了资源的状态，现在您所做的更改无法再按您编写的方式应用。像这样的错误有很多可能的原因，就像在您的云环境中违反了约束一样。

在这种情况下，您无法避免您的更改失败:如果资源已被更改，它们也已被更改。但是您可以发现问题，而不用在环境中发送垃圾操作来查看它们是否工作。方法是在第一个构建步骤中运行 terraform 时包含`— out`参数。这将导致工具将当前状态以及计划的更改序列化到输出文件中。然后，您的第二个阶段将执行这个输出文件，而不是重新处理您的清单来生成一个新的计划。如果环境状态发生了变化，导致计划无效，那么 terraform 将会以一种有意义的方式失败，而不会尝试对环境进行更改。

# 使用模块

terraform 项目的默认组织是拥有一个包含清单文件的目录，该清单文件等同于要管理的一些资源集。从单个目录到单个云环境不一定存在强映射。例如，您可以让多个 terraform 项目管理同一个 Google Cloud 项目中的不同资源，但是为了保持简单明了，我们为每个 GCP 环境维护一个项目:生产、试运行等。我们可以在主清单文件中用一长串资源填充这些环境，但是有几个原因不这样做。

第一个是你可能最终得到的大量重复的样板文件。如果您需要对您供应的每个虚拟机做一些常见的事情，可能是将启动脚本安装到元数据中，或者更改默认的访问权限，那么您需要在创建这种资源的每个清单声明中重复这些事情。当您需要一个在生产环境中复制架构的临时或测试环境时，会出现另一个问题:现在您会发现自己从一个清单向另一个清单复制并粘贴了大量内容，然后编辑属性以获得您想要的内容。出错的空间很大。

> …为了简单明了，我们为每个 GCP 环境维护一个项目

幸运的是，terraform 允许你将一个环境分解成[个模块化的资源集合](https://www.terraform.io/docs/modules/usage.html)，这些资源可以作为一个组来创建和管理。模块可以使用默认的输入变量，它们可以产生输出变量，这些变量可以被其他模块或者在主清单中使用，有很多选项。模块还可以依赖于其他模块，这使我们能够创建一个低级模块，定义一个基本虚拟机类型，并捕获所有启动脚本和配置步骤，然后将该基本模块用作定义服务(如一组 web 服务器)的高级模块的构建块。通过定义变量来控制参数，如一种类型的服务器数量、它们的 cpu、磁盘和 ram，您可以在具有不同资源需求的不同环境中轻松重用这些模块。

关于模块输入变量的最后一个想法是:如果你要为它们设置默认值，考虑适当地设置它们。当您部署了几十台服务器，并意识到默认的访问权限不起作用，或者默认的磁盘大小太小(或者更糟，太大且成本太高)时，这就不好玩了。对于设置资源(如磁盘和内核数量)的变量，最好将默认值设置得较低，并允许需求超出可用范围的工作负载在声明时进行显式覆盖。

# 把相关的东西放在一起

模块对于创建可以部署到不同环境中的可重用组件非常有用，但是与任何结构化语法一样，您必须对如何组成解决方案做出正确的决策。我的建议是将服务于共同目标的东西放在同一个模块中。举一个具体的例子，考虑在 Google Cloud 上部署可公开访问的 web 服务需要创建的资源列表:一些实例、一个实例组、一个健康检查、一个后端服务、一个全局 IP、一个 url 映射、http 和 https 代理、两个全局转发规则和至少一个防火墙规则。

你可以有一个“防火墙规则”模块，和一个“负载平衡器”模块，这些似乎是合理的划分标准。如果您对防火墙规则有疑问，请查看防火墙规则模块！但是在实践中，当收到实际的问题报告时，或者当有一个变更请求时，它可能会在特定服务的上下文中呈现。也许与新合作伙伴的集成需要 web 服务接受非标准端口上的挂钩，或者需要支持新的虚拟主机或路径。根据我的经验，当提供给定服务所需的所有东西都放在同一个 terraform 模块中时，定位和修改受此类请求影响的资源要容易得多。