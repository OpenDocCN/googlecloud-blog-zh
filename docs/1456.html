<html>
<head>
<title>Loading and transforming data into BigQuery using dbt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用dbt将数据加载并转换到BigQuery中</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/loading-and-transforming-data-into-bigquery-using-dbt-65307ad401cd?source=collection_archive---------0-----------------------#2020-06-04">https://medium.com/google-cloud/loading-and-transforming-data-into-bigquery-using-dbt-65307ad401cd?source=collection_archive---------0-----------------------#2020-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="33cc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个数据工程工具，用于在BigQuery中构建数据湖、数据仓库、数据集市和商业智能语义层</h2></div><p id="9b6e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近我似乎听到了很多关于<a class="ae jt" href="https://docs.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>的事情(最近一次是在由<a class="ju jv ge" href="https://medium.com/u/865aa0396c2?source=post_page-----65307ad401cd--------------------------------" rel="noopener" target="_blank">格拉汉姆·波利</a>和<a class="ju jv ge" href="https://medium.com/u/1967b9bb3a61?source=post_page-----65307ad401cd--------------------------------" rel="noopener" target="_blank">哈姆扎·汗</a>主持的研讨会上)，所以我决定看看到底是怎么回事。</p><p id="8ff5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">dbt是data build tool的缩写，是一个数据工程工具，当您有多个步骤来转换SQL时，它允许您捕获依赖关系。这在您进行ELT时很常见——当您将原始数据加载到SQL数据仓库中，然后在SQL中执行转换来清理数据、创建数据集市等等。</p><p id="b055" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在BigQuery的第四章中，我们从一个CSV文件中加载了一些关于美国大学的数据，并进行了一些转换。让我们看看如何使用dbt自动生成那一章中的所有表和视图。</p><h2 id="3df0" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jg kh ki kj jk kk kl km jo kn ko kp kq bi translated">0.设置</h2><p id="61d9" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，你必须做四件事:</p><ul class=""><li id="72c1" class="kw kx hi iz b ja jb jd je jg ky jk kz jo la js lb lc ld le bi translated">pip安装dbt</li><li id="224b" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">创建一个供dbt使用的服务帐户，并允许该服务帐户创建BigQuery表和运行查询</li><li id="334f" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">将配置文件和服务帐户密钥文件复制到~/中。dbt</li><li id="aa12" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">创建新的DBT项目</li></ul><p id="2c19" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经在bash脚本中为您捕获了所有这些步骤。因此，只需通过存储库git clone并运行<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/dbt_load/setup.sh" rel="noopener ugc nofollow" target="_blank"> setup.sh </a></p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="a4b0" class="jw jx hi lp b fi lt lu l lv lw">git clone <a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/</a><br/>cd bigquery-oreilly-book/blogs/dbt_load<br/>./setup.sh</span></pre><p id="ca11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其次，更改<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/dbt_load/profiles.yml" rel="noopener ugc nofollow" target="_blank"> profiles.yml </a>中的项目名称和keyfile的位置，以反映您的主目录(我的是/home/jupyter)。这是要更改的两行:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="7ff4" class="jw jx hi lp b fi lt lu l lv lw">project: <strong class="lp hj">ai-analytics-solutions</strong>  <br/>...<br/>keyfile: /home/<strong class="lp hj">jupyter</strong>/.dbt/keyfile.json</span></pre><h2 id="2813" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jg kh ki kj jk kk kl km jo kn ko kp kq bi translated">1.将数据加载到BigQuery(“数据湖”)</h2><p id="8cf1" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">ELT管道的第一步是EL。在使用dbt进行所有转换之前，必须将数据加载到BigQuery中。</p><p id="cec5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为源数据位于Google云存储上，并且是受支持的格式(在我撰写本文时是CSV/JSON/Avro/Parquet/ORC)，所以将数据放入BigQuery的最简单方法是设置一个外部表。这样，我们不必复制原始数据，只需通过运行<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/04_load/load_external_gcs.sh" rel="noopener ugc nofollow" target="_blank"> load_external_gcs.sh </a>在GCS文件上定义一个表:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="554f" class="jw jx hi lp b fi lt lu l lv lw">./load_external_gcs.sh</span></pre><p id="bd9a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述脚本的作用是:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5d05" class="jw jx hi lp b fi lt lu l lv lw">bq $LOC \<br/>   mkdef \<br/>   --source_format=CSV \<br/>   --noautodetect \<br/>   $INPUT \<br/>   $SCHEMA \<br/>  | sed 's/"skipLeadingRows": 0/"skipLeadingRows": 1/g' \<br/>  | sed 's/"allowJaggedRows": false/"allowJaggedRows": true/g' \<br/>  &gt; $DEF</span><span id="65bc" class="jw jx hi lp b fi lx lu l lv lw">bq mk --external_table_definition=$DEF ch04.college_scorecard_gcs</span></pre><p id="0a76" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在BigQuery中将有一个名为college_scorecard_gcs的外部表。实际数据采用GCS。我们可以把这看作是我们的数据湖。</p><h2 id="2fb8" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jg kh ki kj jk kk kl km jo kn ko kp kq bi translated">2.第一次转换(“数据仓库”)</h2><p id="9461" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在让我们定义第一个转换。这是在<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/dbt_load/college-scorecard/models/college_scorecard.sql" rel="noopener ugc nofollow" target="_blank">模型/学院_记分卡. sql: </a></p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="2fb7" class="jw jx hi lp b fi lt lu l lv lw">WITH etl_data AS (<br/>   SELECT<br/>     * EXCEPT(ADM_RATE_ALL, FIRST_GEN, MD_FAMINC, SAT_AVG, MD_EARN_WNE_P10)<br/>     , {{target.schema}}.cleanup_numeric(ADM_RATE_ALL) AS ADM_RATE_ALL<br/>     , {{target.schema}}.cleanup_numeric(FIRST_GEN) AS FIRST_GEN<br/>     , {{target.schema}}.cleanup_numeric(MD_FAMINC) AS MD_FAMINC<br/>     , {{target.schema}}.cleanup_numeric(SAT_AVG) AS SAT_AVG<br/>     , {{target.schema}}.cleanup_numeric(MD_EARN_WNE_P10) AS MD_EARN_WNE_P10<br/>   FROM<br/>     ch04.college_scorecard_gcs<br/>)</span><span id="298c" class="jw jx hi lp b fi lx lu l lv lw">SELECT * FROM etl_data</span></pre><p id="134b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于这一点需要注意几件事:</p><ul class=""><li id="d1ec" class="kw kx hi iz b ja jb jd je jg ky jk kz jo la js lb lc ld le bi translated">没有创建或替换表。dbt将包装这个的创建，并将结果写入数据集ch04中名为college_scorecard的表中。为什么？因为在dbt_project.yml中，我已经指定了:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="ab0f" class="jw jx hi lp b fi lt lu l lv lw">models:<br/>  <strong class="lp hj">college_scorecard:<br/>      materialized: table</strong><br/>      description: ELT of College Scorecard Data</span></pre><ul class=""><li id="bfee" class="kw kx hi iz b ja jb jd je jg ky jk kz jo la js lb lc ld le bi translated">dbt中的“模型”就是我们所说的查询。数据集的名称在profiles.yml中指定，表的名称与SQL文件的名称匹配。</li><li id="835b" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">注意，我正在调用一个用户定义的函数ch04 . clean up _ numeric(target . schema是输出数据集，所以这里是ch04)。这在<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/dbt_load/college-scorecard/macros/cleanup_numeric.sql" rel="noopener ugc nofollow" target="_blank">宏/cleanup_numeric.sql </a>中定义:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5f58" class="jw jx hi lp b fi lt lu l lv lw">{% macro <strong class="lp hj">cleanup_numeric_macro</strong>() %}</span><span id="3f52" class="jw jx hi lp b fi lx lu l lv lw">CREATE OR REPLACE FUNCTION {{target.schema}}.cleanup_numeric(x STRING) AS<br/>(<br/>  IF ( x != 'NULL' AND x != 'PrivacySuppressed',<br/>       CAST(x as FLOAT64),<br/>       NULL )<br/>);</span><span id="1338" class="jw jx hi lp b fi lx lu l lv lw">{% endmacro %}</span></pre><ul class=""><li id="518c" class="kw kx hi iz b ja jb jd je jg ky jk kz jo la js lb lc ld le bi translated">在开始创建表之前，必须执行所有的宏。我们通过向dbt_project.yml添加以下行来确保上面提到的宏运行:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="97dc" class="jw jx hi lp b fi lt lu l lv lw">on-run-start:<br/>    - "{{<strong class="lp hj">cleanup_numeric_macro</strong>()}}"</span></pre><p id="7c24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终结果是创建了一个名为college_scorecard的表。该表包含CSV文件中的所有列，但其中五列被转换为数字。这是干净的数据。我们甚至可以丰富或过滤它。我们可以把它想象成我们的数据仓库。</p><p id="22aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用宏来做UDF的方式有点像黑客。dbt中宏的真正目的是捕获您想要重用的SQL片段。例如，如果我们一直选择相同的5列，我们可以这样定义一个宏:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d902" class="jw jx hi lp b fi lt lu l lv lw">{% macro selective_college_features() %}<br/>INSTNM, ADM_RATE_ALL, FIRST_GEN, MD_FAMINC, SAT_AVG<br/>{% endmacro %}</span></pre><p id="b38c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并引用所有模型SQL文件中的宏:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="62a4" class="jw jx hi lp b fi lt lu l lv lw">SELECT<br/>   {{ selective_college_features() }}<br/>   , MD_EARN_WNE_P10<br/>   ...</span></pre><h2 id="e014" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jg kh ki kj jk kk kl km jo kn ko kp kq bi translated">3.第二次转型(“数据集市”)</h2><p id="ad5b" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设一些商业用户想要一个对第一代学生友好的选择性大学列表。我们知道我们想要运行的SQL。我们可以把这个放到<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/dbt_load/college-scorecard/models/selective_firstgen.sql" rel="noopener ugc nofollow" target="_blank">models/selective _ first gen . SQL</a>中:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="c242" class="jw jx hi lp b fi lt lu l lv lw">SELECT<br/>  INSTNM, ADM_RATE_ALL, FIRST_GEN, MD_FAMINC, SAT_AVG, MD_EARN_WNE_P10<br/>FROM<br/>  {{ ref('college_scorecard') }}<br/>WHERE<br/>  SAT_AVG  &gt; 1300<br/>  AND ADM_RATE_ALL &lt; 0.2<br/>  AND FIRST_GEN &gt; 0.1</span></pre><p id="8dfa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意一些事情:</p><ul class=""><li id="9971" class="kw kx hi iz b ja jb jd je jg ky jk kz jo la js lb lc ld le bi translated">我们提供了更小的数据子集(只有几列)</li><li id="eb77" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">FROM引用dbt创建的college_scorecard</li></ul><p id="2692" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出被具体化为一个名为selective_firstgen的表。</p><h2 id="827e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jg kh ki kj jk kk kl km jo kn ko kp kq bi translated">4.第三次转型(“报告”)</h2><p id="b7db" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设我们有一个报告用例，我们需要根据收入中位数对这些选择性的、第一代友好的大学进行排名。我们可以在<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/dbt_load/college-scorecard/models/selective_firstgen_top10.sql" rel="noopener ugc nofollow" target="_blank">models/selective _ first gen _ top 10 . SQL</a>中再编写一个SQL查询:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="e82d" class="jw jx hi lp b fi lt lu l lv lw">{{ config(materialized='view') }}   /* overrides the project definition */</span><span id="77bf" class="jw jx hi lp b fi lx lu l lv lw">SELECT<br/>  INSTNM, ADM_RATE_ALL, FIRST_GEN, MD_FAMINC, SAT_AVG<br/>FROM<br/>  {{ ref('selective_firstgen') }}<br/>ORDER BY<br/>  MD_FAMINC ASC<br/>LIMIT 10</span></pre><p id="b3ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，这里的FROM子句指的是另一个dbt查询。dbt为我们管理依赖关系。由于SQL文件顶部的config语句，它将创建一个名为selective_firstgen_top10的视图。</p><h2 id="3837" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jg kh ki kj jk kk kl km jo kn ko kp kq bi translated">5.运行它</h2><p id="489c" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">要运行它，只需执行以下操作:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="f9cd" class="jw jx hi lp b fi lt lu l lv lw">cd college-scorecard<br/>dbt run</span></pre><p id="8269" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建函数(由于宏定义)、两个表(college_scorecard和selective_firstgen)和一个视图(selective_firstgen_top10):</p><figure class="lk ll lm ln fd lz er es paragraph-image"><div class="er es ly"><img src="../Images/ed1df9a7c1347699d29fcc2fea051d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*73LTu7cJaAtA4_jc_JO0dQ.png"/></div></figure><p id="7285" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(回想一下，我们必须在dbt之外创建college_scorecard_gcs，因为它只做ELT的T部分)。</p><p id="febc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将它打包到Docker容器中，您可以通过云构建或CI/CD实现整个过程的自动化，以便在每次修改SQL语句时创建表。</p><p id="466e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">dbt似乎内置了某种测试功能，但我没有探究它。在生产系统中，您可能也会这样做。</p><h2 id="4f93" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jg kh ki kj jk kk kl km jo kn ko kp kq bi translated">6.后续步骤</h2><p id="64f0" class="pw-post-body-paragraph ix iy hi iz b ja kr ij jc jd ks im jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这个简单的例子中，我们看到了一些常见的数据工程模式。BigQuery的功能是:</p><ul class=""><li id="f3dc" class="kw kx hi iz b ja jb jd je jg ky jk kz jo la js lb lc ld le bi translated">数据湖:对存储在Google云存储中的文件进行联邦查询</li><li id="1eed" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">数据仓库:用于清理和丰富数据的高度可伸缩的SQL</li><li id="809a" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">数据集市:支持业务用户的数据提取</li><li id="585c" class="kw kx hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">商业智能语义层:一致捕获KPI的视图</li></ul><p id="ff9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">dbt能够一次性为我们设置好这一切，并捕获依赖关系。我们可以将项目签入版本控制，进行测试，安排构建，以及CI/CD。</p><p id="d1d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/tree/master/blogs/dbt_load" rel="noopener ugc nofollow" target="_blank">完整的代码示例</a>在GitHub上。</p><p id="b5b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另外，请阅读哈姆扎对dbt 的精彩介绍<a class="ae jt" rel="noopener" href="/weareservian/bigquery-dbt-modern-problems-require-modern-solutions-b40faedc8aaf">。</a></p><p id="3696" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽情享受吧！</p></div></div>    
</body>
</html>