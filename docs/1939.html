<html>
<head>
<title>ES Modules in Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云函数中的专家系统模块</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/es-modules-in-cloud-functions-f5be1676c8b5?source=collection_archive---------1-----------------------#2021-08-13">https://medium.com/google-cloud/es-modules-in-cloud-functions-f5be1676c8b5?source=collection_archive---------1-----------------------#2021-08-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c6b1ccd4d609582bfafa485ca67807a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7V9PQqEN8DBXCf6votqog.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">节点、ES模块、云功能</figcaption></figure><p id="d0fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> ES模块</strong>(又名ECMAScript模块或ESM)是TC39标准，Node≥14中未标记的特性，用于加载JavaScript模块。</p><p id="4377" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与CommonJS相反，ESM为加载模块提供了一个异步API，并通过<code class="du js jt ju jv b"><strong class="iw hj">import</strong></code>和<code class="du js jt ju jv b"><strong class="iw hj">export</strong></code>语句提供了一个非常普遍采用的<strong class="iw hj">语法改进</strong>。</p><p id="8ed6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">随着最近的更新，Google Cloud Functions for Node现在支持开箱即用的es模块！</p><p id="1645" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是如何使用它们…</p><h2 id="6808" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">将类型设置为模块</h2><p id="bbd2" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">要在包中启用ESM，我们必须显式地将字段<code class="du js jt ju jv b">"type": “module"</code>添加到我们的<code class="du js jt ju jv b">package. json</code>文件中(或者使用文件扩展名<code class="du js jt ju jv b">.mjs</code>):</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个简单的<code class="du js jt ju jv b">package.json</code>文件</figcaption></figure><blockquote class="lc ld le"><p id="e9e3" class="iu iv lf iw b ix iy iz ja jb jc jd je lg jg jh ji lh jk jl jm li jo jp jq jr hb bi translated"><strong class="iw hj">注意:</strong>在云函数中，如果我们没有在<code class="du js jt ju jv b">package.json</code>中指定，我们将自动使用最新的函数框架。在这里，它是当地发展所需要的。</p></blockquote><h2 id="6af6" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">使用导出</h2><p id="319c" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">在JavaScript模块中，不使用<code class="du js jt ju jv b">modules.export</code>，我们可以使用<code class="du js jt ju jv b">exports</code>关键字来导出函数、对象或原始值的动态绑定。这里有一个例子:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">单线出口</figcaption></figure><h2 id="5e6e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">使用导入</h2><p id="f04f" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">您可以使用<code class="du js jt ju jv b">import</code>来加载原语、对象和函数，而不是使用<code class="du js jt ju jv b">require</code>关键字。好的方面是您的IDE将为您提供导入属性的自动补全(或错误)。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">单行导入</figcaption></figure><h2 id="4481" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">导出函数</h2><p id="a0a5" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">最重要的是，您现在可以导出一个函数，当您的<code class="du js jt ju jv b">localhost</code> URL被点击时，该函数将被调用，同时传递<a class="ae lj" href="https://expressjs.com/en/api.html" rel="noopener ugc nofollow" target="_blank"> Express </a>和<code class="du js jt ju jv b">req</code>对象:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用ES模块的简单云函数</figcaption></figure><p id="b539" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最大的好处是不需要额外的配置。只需运行<code class="du js jt ju jv b">npm start</code>即可启动您的功能/网络服务器:</p><pre class="kw kx ky kz fd lk jv ll lm aw ln bi"><span id="d927" class="jw jx hi jv b fi lo lp l lq lr">&gt; npm start<br/>&gt; nodejs-ff-esm@ start /functions-framework-nodejs/docs/esm<br/>&gt; functions-framework --target=esm</span><span id="93de" class="jw jx hi jv b fi ls lp l lq lr">Serving function...<br/>Function: esm<br/>Signature type: http<br/>URL: <a class="ae lj" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a></span></pre><p id="d742" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后向<code class="du js jt ju jv b">localhost:8080</code>提出请求。响应应该是<code class="du js jt ju jv b">Hello, ESM!</code></p><p id="da63" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种体验和行为在云中是同义词，但是我们可以将我们的功能部署到Google的22个可用位置中的任何一个。您可以随意将我们的功能部署到云功能中，无需使用gcloud进行任何修改:</p><pre class="kw kx ky kz fd lk jv ll lm aw ln bi"><span id="71db" class="jw jx hi jv b fi lo lp l lq lr">gcloud functions deploy esm --runtime nodejs14 --trigger-http</span></pre><p id="ff74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在命令的输出中，我们将看到一个到<em class="lf">cloudfunctions.net</em>的唯一URL，如果调用它，将产生与我们刚才在本地看到的相同的响应。</p><p id="6c60" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">太好了！我们刚刚在谷歌云上部署了一个简单的ESM功能！🎉</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="eecb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢阅读！您可以在此处查看ESM说明和文档:</p><ul class=""><li id="d4e5" class="ma mb hi iw b ix iy jb jc jf mc jj md jn me jr mf mg mh mi bi translated"><a class="ae lj" href="https://cloud.google.com/functions/docs/concepts/nodejs-runtime#using_es_modules_experimental" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/functions/docs/concepts/nodejs-runtime # using _ es _ modules _ experimental</a></li><li id="fb68" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><a class="ae lj" href="https://github.com/GoogleCloudPlatform/functions-framework-nodejs/tree/master/docs" rel="noopener ugc nofollow" target="_blank">https://github . com/Google cloud platform/functions-framework-nodejs</a></li></ul></div></div>    
</body>
</html>