<html>
<head>
<title>Finding Patterns in π</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在π中寻找模式</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/finding-patterns-in-%CF%80-151dc4a9ee4d?source=collection_archive---------3-----------------------#2020-03-30">https://medium.com/google-cloud/finding-patterns-in-%CF%80-151dc4a9ee4d?source=collection_archive---------3-----------------------#2020-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="21ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">π是一个有趣的数字。不仅仅是<a class="ae jd" href="https://en.wikipedia.org/wiki/Irrationality" rel="noopener ugc nofollow" target="_blank">非理性</a>，还有<a class="ae jd" href="https://en.wikipedia.org/wiki/Transcendental_number" rel="noopener ugc nofollow" target="_blank">先验</a>。它的十进制表示“看起来是随机的”(它不是随机的，它有精确的定义，但是<a class="ae jd" href="https://en.wikipedia.org/wiki/Pi#Irrationality_and_normality" rel="noopener ugc nofollow" target="_blank">似乎通过了随机性测试</a>)。您想要的任何数字串似乎都可以在该表示中找到。找到它们可能需要一段时间，但是给定足够多的π数字，你可以期望找到任何给定的数字。例如，<a class="ae jd" href="https://www.youtube.com/watch?v=6WTdTwcmxyo" rel="noopener ugc nofollow" target="_blank"> Jenny的号码8675309 </a>位于第9202591个位置(将数字中的首字母3计为位置0)。</p><p id="faf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用我创建的云应用程序来搜索π中的任何十进制数字串，发现了这一点。我采用的构建方法展示了一些有用的云应用程序开发和架构方法。这就是这篇文章的内容:不是一个云架构框架，只是一个如何思考云架构的例子。这不是该应用程序的详细描述，但是在<a class="ae jd" href="https://github.com/engelke/where-in-pi-is/" rel="noopener ugc nofollow" target="_blank">https://github.com/engelke/where-in-pi-is/</a>有可用的示例代码。只要做一点工作，你就可以用它来部署你自己的π数字搜索器。</p><h1 id="598d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据</h1><p id="1e51" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果我要在π的数字中找到字符串，我必须以某种方式让这些数字可用。理论上，程序在搜索字符串时可以计算越来越多的数字，当找到字符串时就停止。但那将是荒谬的；计算这些数字是一个密集而缓慢的过程。</p><p id="a710" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，有人已经计算了π的很多位数。2019年3月14日，谷歌宣布<a class="ae jd" href="https://cloud.google.com/blog/products/compute/calculating-31-4-trillion-digits-of-archimedes-constant-on-google-cloud" rel="noopener ugc nofollow" target="_blank">艾玛·相户爱Iwao使用谷歌云平台工具计算了超过31.4万亿位数的π </a>。这是一项新的世界纪录。Google设置了一个web API，用于在<a class="ae jd" href="https://pi.delivery/" rel="noopener ugc nofollow" target="_blank"> pi.delivery </a>返回选定的小数位。要获得从第9，202，591位小数开始的7位数字，请向<a class="ae jd" href="https://api.pi.delivery/v1/pi?start=9202591&amp;numberOfDigits=7" rel="noopener ugc nofollow" target="_blank">https://api.pi.delivery/v1/pi?start=9202591&amp;number of digits = 7</a>发出web请求。您应该看到:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0cf2" class="kq jf hi km b fi kr ks l kt ku">{"content":"8675309"}</span></pre><p id="e83b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在π中搜索七位数的一种方法是只请求从位置0开始的七位数，然后从位置1开始，依此类推，直到返回所查找的数字。</p><p id="3b7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要尝试那个。真的，<strong class="ih hj">不要</strong>。</p><p id="5bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项服务非常快，当我尝试的时候，每个这样大小的请求需要75毫秒。以这样的速度，你会在大约四年内找到这个数字，除非谷歌首先因为你滥用API而屏蔽你。我想要更快的答案。</p><p id="24a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们通过构建一个云应用程序来寻找π中的数字字符串，从而找出一种更快的方法。当我们为云进行设计时，我们不认为计算机是应用程序平台。不，所有可用的网络服务都是我们的平台。我们通常会使用这些服务中的几个，以各种方式相互通信，来构建应用程序。对于π搜索器，我们首先查看需要完成的每个不同的动作，然后将每个动作作为独立的部分来执行。然后我们将使用云技术让这些部分协同工作。</p><h1 id="79d3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">第一部分:搜索</h1><p id="a8b3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">必须存储π的数字并在其中搜索。在<a class="ae jd" href="https://pi.delivery/" rel="noopener ugc nofollow" target="_blank"> pi.delivery网站</a>上有链接，可以将数字下载到你自己的存储器中进行处理。最简单快速的数据流方式是将数据放在一个连接到虚拟机的文件中，所以我这样做了:启动一个虚拟机Google <a class="ae jd" href="https://cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank">计算引擎</a>并将数字放入一个名为pi.txt的文本文件中。我编写了一个Python程序，将该文件内存映射到一个Python字节字符串，并使用内置的find方法进行搜索。</p><p id="ee7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搜索七位数的字符串8675309只用了20毫秒。这比四年反复调用API站点要好得多。其实大概已经足够好了。对于长度上的每一个额外的数字，我们可以预期要花大约十倍的时间来搜索。因此，寻找一个8位数的数字(如日期)大约需要五分之一秒，十位数(如带区号的电话号码)大约需要20秒，等等。虽然这相当快，但许多搜索需要很长时间让请求者等待响应，就像处理网页一样。他们将不得不请求搜索，然后以某种方式得到结果。</p><p id="a29e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是应用程序的第一部分:一个可以相当快地找到所请求的数字串的盒子。请参见<a class="ae jd" href="https://github.com/engelke/where-in-pi-is/blob/master/computeengine/find-in-pi.py" rel="noopener ugc nofollow" target="_blank">https://github . com/engelke/where-in-pi-is/blob/master/compute engine/find-in-pi . py</a>中的<code class="du kv kw kx km b">where_is</code>函数，以获得真正的最小解决方案。现在让我们看看还需要什么。</p><h1 id="cfdf" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">第二部分:请求搜查</h1><p id="821a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">下一个要解决的问题是，人们如何请求搜索。我完全控制搜索框虚拟机，所以我可以SSH到它并运行Python代码。这对任何人都没用。需要有一些方法让人们可以要求运行搜索。我能想到几个办法:</p><ol class=""><li id="bfa7" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">在网页上填写表单</li><li id="9226" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">向特殊地址发送电子邮件</li><li id="55d7" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">发布一条推文，提及一个特定的Twitter账户</li><li id="643e" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">通过短信发送文本</li><li id="d6dc" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">拨打语音电话并说出一个号码(或使用键盘)</li></ol><p id="b556" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将不得不构建一个或多个这样的方法，但是在开始之前，让我们弄清楚用户与之交互的前端将如何获得对搜索框的请求。我们希望所用的方法是异步的(这样请求程序就不必等待，也不会过载)并且经过认证(这样恶意攻击者就不能用虚假请求淹没搜索者)。云平台提供的服务正是为这种需求量身定制的:<a class="ae jd" href="https://en.wikipedia.org/wiki/Message_passing" rel="noopener ugc nofollow" target="_blank">消息传递</a>。</p><p id="c9f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有不同风格的消息传递可用；谷歌提供<a class="ae jd" href="https://cloud.google.com/pubsub" rel="noopener ugc nofollow" target="_blank"> PubSub </a>。一个应用程序可以创建一个或多个<strong class="ih hj">主题</strong>(例如，一个名为<code class="du kv kw kx km b">search_requests</code>)，组件可以<strong class="ih hj">向主题发布</strong>消息，其他组件可以<strong class="ih hj">向主题订阅</strong>，因此得名。Google PubSub保证消息至少会被发送一次，并且很少会将一条消息发送给一个订阅者多次。这对我们的使用来说没问题，因为最坏的情况是我们(很少)不止一次地搜索相同的请求字符串。</p><p id="0f5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">收到用户搜索请求的前端将<strong class="ih hj">向<code class="du kv kw kx km b">search_requests</code>主题发布</strong>一条消息，搜索框将<strong class="ih hj">订阅同一主题的</strong>。可以将发布订阅配置为<strong class="ih hj">推送</strong>消息传递或<strong class="ih hj">拉取</strong>消息传递。推送消息功能会在每条消息可用时立即强制订阅方接收这些消息，并一直推送这些消息，直到订阅方确认这些消息，或者超过重试或超时限制。拉消息传递在传递消息之前等待订户请求可用的消息。</p><p id="b70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拉消息传递非常适合这种用途，因为搜索框可以有一个循环来请求消息，一次执行一个请求的搜索，然后请求更多的消息。搜索框不能以这种方式超载，因为它一次只运行一个搜索。如果机器有能力一次执行多个搜索，我们可以有多个进程，每个进程自己获取和处理消息。如果我们需要扩大规模，我们可以部署多个搜索框。</p><h1 id="0a39" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">第三部分:用户请求前端</h1><p id="1baf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我之前列出了用户请求搜索的五种可能方式。我们至少需要实现其中的一个，否则搜索框就没有意义了。在这个例子中，我们只做其中的一个，最简单的似乎是第一个:给用户一个web页面，让用户填写一个表单，请求搜索。如果需要的话，我们可以在以后实现更多的前端，只要让它们发布到<code class="du kv kw kx km b">search_requests</code> PubSub主题。</p><p id="4e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多方法可以为web页面提供一个表单，然后接受填写好的表单作为回报。如果您习惯于管理自己的计算资源，您可能会考虑为此设置一个带有web服务器软件的虚拟机。这将工作得很好，但需要做我们自己的系统管理和维护。<a class="ae jd" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">无服务器计算</a>产品让你编写自己的应用程序代码，把其他一切事情，包括扩展、监控和日志记录，都留给平台。</p><p id="f5a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要一个响应web请求的组件，一个包含GET请求的表单的页面，并通过提交POST请求的搜索请求。我所知道的最简单的方法就是使用<a class="ae jd" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云功能</a>。提供这个web用户界面只需要编写一个Python函数，平台会将web请求路由到这个函数。代码需要查看请求是否是GET，在这种情况下，它返回一个带有表单的网页，或者是POST，在这种情况下，它读取与表单一起提交的值，并通过向<code class="du kv kw kx km b">search_requests</code> PubSub主题发布消息来请求搜索。你可以在<a class="ae jd" href="https://github.com/engelke/where-in-pi-is/blob/master/function/main.py" rel="noopener ugc nofollow" target="_blank">https://github . com/engelke/where-in-pi-is/blob/master/Function/main . py</a>看到把这个实现为云函数有多简单。</p><p id="883a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个应用程序现在看起来像这样:</p><figure class="kh ki kj kk fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lm"><img src="../Images/a4de351dda0c917e1e310fb7547b74ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QtYU3HpnaVqwyfhg"/></div></div></figure><h1 id="d21d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">第四块:推一个结果</h1><p id="2a3f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">前端没有做的一件事是将搜索结果返回给用户。由于搜索可能需要一段时间，或者需要等待其他更早的搜索完成才能开始，因此该函数只负责触发搜索。用户将不得不从其他地方得到答案。可能的“其他地方”选择将包括网页(要求用户登录或为每个请求向用户给出唯一的请求)或电子邮件消息(发送到向用户提供的地址)。</p><p id="6af8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，我们将推迟解决如何向用户交付结果的问题。相反，我们将设置另一个PubSub主题:<code class="du kv kw kx km b">send_result</code>。当搜索框得到一个答案时，它会向该主题发布一条消息，并相信该主题会有一个订阅者来完成传递工作。该消息将包含如何交付结果的信息，这将根据请求的方式而变化。对于许多请求，发送结果的自然方式是通过电子邮件。对于这些情况，前端将不得不收集一个电子邮件地址，包括在给<code class="du kv kw kx km b">search_requests</code>主题的消息中，然后搜索框将不得不包括在给<code class="du kv kw kx km b">send_result</code>主题的消息中。其他形式的请求可能需要通过其他方法得到响应，需要Twitter用户名或电话号码来发送文本。消息可以简单地包括响应的类型和适当的地址。在我们进入下一步之前，没有什么需要太在意那些是什么。</p><h1 id="dc47" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">最后一部分:发送电子邮件结果</h1><p id="91d0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">应用程序的最后一部分是订阅<code class="du kv kw kx km b">send_result</code>主题并进行交付的组件。如果我们有多种交付方法，我们可以用一个单独的交付组件来处理所有这些方法，或者用单独的组件订阅主题并跳过它们不能处理的任何消息。我们将保持简单，通过发送电子邮件来处理每条消息。</p><p id="4c66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你如何使用谷歌云平台发送电子邮件？没有简单的方法。没有像一些云提供商那样的电子邮件发送API。如果你用电子邮件软件设置了一个虚拟机，它可能会被阻止，以防止可能的垃圾邮件。有办法解决这个问题，你可以使用第三方服务，但我记得谷歌应用引擎<em class="lu">曾经</em>有一个电子邮件发送API。最新版本的App Engine不再提供该API，但之前的App Engine版本仍然可用，因此我们将使用该版本。</p><p id="8197" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没错:我们将建立一个App Engine实例，只根据发送给它的PubSub消息发送邮件。</p><p id="8c78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python 2.7应用程序的App Engine代码位于<a class="ae jd" href="https://github.com/engelke/where-in-pi-is/tree/master/appengine" rel="noopener ugc nofollow" target="_blank">https://github . com/engelke/where-in-pi-is/tree/master/App Engine</a>。每当有消息发布到<code class="du kv kw kx km b">send_result</code>主题时，它使用PubSub push订阅向它发送HTTP请求。这些传入消息包括向其发送结果的电子邮件地址和结果本身，还包括在推送订阅中配置的共享密钥令牌，以便App Engine可以确保这些传入请求不是伪造的。</p><h1 id="a5b1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">把一切都包起来</h1><p id="7386" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们完整的应用程序如下所示:</p><figure class="kh ki kj kk fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lv"><img src="../Images/907fb138992ad928941624ddbb49be52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M71pU_ONqU5KrzeJ"/></div></div></figure><p id="3744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户与一个由云函数提供的web表单进行交互，该表单向<code class="du kv kw kx km b">search_requests</code>主题发布一条消息。搜索由一个计算引擎虚拟机完成，它提取搜索请求，找到答案，并将答案发布到<code class="du kv kw kx km b">send_result</code>主题。最后，一个应用引擎实例通过该主题的推送订阅获得发送结果的请求，并向用户最初提供的地址发送电子邮件。</p><p id="c475" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同作品的代码可在<a class="ae jd" href="https://github.com/engelke/where-in-pi-is" rel="noopener ugc nofollow" target="_blank">https://github.com/engelke/where-in-pi-is</a>获得。目前，在https://us-central 1-engelke-pi-blog . cloud functions . net/where-in-py上有这个应用程序的一个活动版本。它将只搜索π的前几十亿位，因为存储Emma计算的全部31.4万亿位对于这样的演示来说是相当昂贵的。不过，这将找到大多数7或8位数的数字你问。</p><p id="ac44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">试试看，或者构建自己的无服务器云应用程序！</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="c399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lu">原载于2020年3月30日</em><a class="ae jd" href="https://engelke.dev/2020/03/30/finding-patterns-in-%cf%80/" rel="noopener ugc nofollow" target="_blank"><em class="lu">http://engelke . dev</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>