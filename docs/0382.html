<html>
<head>
<title>Improving Rails application page load times on Google Container Engine using CloudCDN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CloudCDN改善Google Container引擎上Rails应用页面的加载时间</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/improving-rails-application-page-load-times-on-google-container-engine-using-cloudcdn-290d2364468e?source=collection_archive---------1-----------------------#2017-09-18">https://medium.com/google-cloud/improving-rails-application-page-load-times-on-google-container-engine-using-cloudcdn-290d2364468e?source=collection_archive---------1-----------------------#2017-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4c15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Tl；dr </strong>对于部署在GCP的web应用程序，我们如何从大约4.5秒的页面加载时间缩短到大约1.8秒。</p><p id="ab46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的<a class="ae jd" rel="noopener" href="/@nithinmallya4/deploying-a-rails-application-to-google-container-engine-with-kubernetes-b08b2de353fc">文章</a>中，我们为谷歌容器引擎(GKE)部署了一个Rails应用。这篇文章讲述了我们如何通过使用久经考验的方法来减少页面加载时间，例如使用<a class="ae jd" href="http://guides.rubyonrails.org/asset_pipeline.html" rel="noopener ugc nofollow" target="_blank">资产管道</a>和<a class="ae jd" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=13&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjthrW2lK_WAhXFYCYKHaNTB-8QFgh8MAw&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FContent_delivery_network&amp;usg=AFQjCNGV5YDfGmqtA7qo2GOdUSpAZs-wBQ" rel="noopener ugc nofollow" target="_blank">内容交付网络</a> (CDNs)。</p><blockquote class="je jf jg"><p id="d224" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">在高层次上，<strong class="ih hj">资产管道</strong>允许我们压缩我们的资产(css和javascript文件)并向我们的客户端应用程序(桌面和移动浏览器)交付更小的有效负载。当涉及到手机的数据费用时，这一点尤其重要，因为如果页面加载时间较长，大多数用户都会离开。</p><p id="9b2f" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">一个<strong class="ih hj">内容交付网络</strong>是一个由代理服务器和数据中心组成的地理分布式网络，它托管图像、视频(想想网飞的内容)、我们的代码(javascript、css等)等数据。)还有很多很多。使用CDN的优势在于，可以从离客户端最近的服务器获取数据，从而节省了获取数据所需的大量时间。</p><p id="0df9" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">我们使用Google提供的CDN(<a class="ae jd" href="https://cloud.google.com/cdn/docs/" rel="noopener ugc nofollow" target="_blank">Google Cloud CDN</a>)获得了非常积极的体验，并决定记录这些步骤，这样也可以帮助其他用户。</p><p id="9da2" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>互联网上有很多资源，包括处理资产管道的官方<a class="ae jd" href="http://guides.rubyonrails.org/asset_pipeline.html" rel="noopener ugc nofollow" target="_blank"> Rails资产管道文档</a>，所以我将坚持我们对代码库所做的更改，并解释CloudCDN如何帮助我们完成最后一英里。本文给出了一个相当复杂的过程的简化视图。</p></blockquote><p id="fd2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">假设</strong>:</p><ol class=""><li id="015b" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">你有一个谷歌云平台账户</li><li id="d2b0" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">您有一个将被部署到GKE的Rails应用程序</li><li id="475e" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">您已经熟悉了使用gcloud和kubectl命令部署应用程序。</li></ol><blockquote class="je jf jg"><p id="7b08" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">这篇文章有两个部分:代码变更和将编译好的资产部署到CDN。</p></blockquote><h1 id="baf1" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">代码变更</strong>:</h1><ol class=""><li id="15cf" class="jl jm hi ih b ii kx im ky iq kz iu la iy lb jc jq jr js jt bi translated">宝石档案:你需要下面提到的宝石。sass-rails用于压缩css文件，uglifier对javascript文件也是如此。</li></ol><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="eeff" class="ll ka hi lh b fi lm ln l lo lp">gem 'sass-rails'          , '~&gt; 5.0'<br/>gem 'uglifier'            , '&gt;= 1.3.0'</span></pre><p id="427e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">application . Rb:</strong>“public _ file _ server . headers”配置将指示浏览器缓存所有静态资产一年。由于哈希在预编译过程中会自动添加到每个资产名称中，因此浏览器会将它们视为唯一的资产。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fe20" class="ll ka hi lh b fi lm ln l lo lp">config.public_file_server.headers = { 'Cache-Control' =&gt; 'public, max-age=31536000' }</span></pre><p id="e070" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj"> assets.rb </strong>:在Rails 5中，可以在config/initializer/assets . Rb文件中设置资产版本。更改此版本将强制浏览器重新加载资产的最新版本。如果步骤2中基于散列的方法有效，通常不需要这样做。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d8fa" class="ll ka hi lh b fi lm ln l lo lp">Rails.application.config.assets.version = '1.0'</span></pre><p id="66b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj"> production.rb </strong>:下面的配置更改将需要为我们的css和javascript文件配置正确的处理程序(压缩器)。我们将使用<strong class="ih hj"> sass </strong>(来自步骤1的sass-rails)来压缩css文件，使用<strong class="ih hj"> uglify </strong>来压缩javascript文件。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6304" class="ll ka hi lh b fi lm ln l lo lp">config.serve_static_assets = true</span><span id="7ee7" class="ll ka hi lh b fi lq ln l lo lp"># Compress JavaScripts and CSS<br/>config.assets.compress = true</span><span id="71d2" class="ll ka hi lh b fi lq ln l lo lp"># Don't fallback to assets pipeline if a precompiled asset is missed<br/>config.assets.compile = false</span><span id="82d5" class="ll ka hi lh b fi lq ln l lo lp"># Generate digests for assets URLs<br/>config.assets.digest = true<br/>  <br/>config.assets.css_compressor = :sass<br/>config.assets.js_compressor = :uglifier</span></pre><p id="8afc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.<strong class="ih hj"> config.ru </strong>:您可以在您的config.ru中添加以下行，以确保资产在发送之前被压缩。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="545a" class="ll ka hi lh b fi lm ln l lo lp">use Rack::Deflater</span></pre><p id="5a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">构建代码:</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a745" class="ll ka hi lh b fi lm ln l lo lp">1. install the gems:  <strong class="lh hj">bundle install</strong><br/>2. precompile the assets: <strong class="lh hj">RAILS_ENV=production bundle exec rake assets:precompile</strong></span></pre><p id="3e09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> assets:precompile </strong>任务在<strong class="ih hj"> /public/assets </strong>文件夹中创建资产的编译和压缩版本。此过程会减小资产文件的大小，并加快下载速度。</p><blockquote class="je jf jg"><p id="605e" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:对于css和javascript文件压缩，你也可以使用<a class="ae jd" href="http://yui.github.io/yuicompressor/" rel="noopener ugc nofollow" target="_blank"> yui-compressor </a>。</p></blockquote><p id="7a32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述步骤应该有助于我们进入下一部分，在这一部分，我们将利用CDN获得惊人的速度优势。</p><h1 id="6c95" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">将预编译资产部署到CDN </strong></h1><p id="4038" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq lr is it iu ls iw ix iy lt ja jb jc hb bi translated">这是有趣的部分。有了Google CloudCDN，让我们的资产得到CDN的服务几乎没有什么可做的。</p><p id="877f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1: </strong>转到云控制台，选择网络服务下的云CDN</p><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lu"><img src="../Images/3127c49fb0bfcf8e46913cb54e58853d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNzmyf7BVmW3gsPiXXUM_w.png"/></div></div></figure><p id="e787" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:你应该会看到一个页面，要求你添加原点</p><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mc"><img src="../Images/428b7296c5dd36058e3d0fe4f77b1360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byLylSN0XAw_3e36dQgGyg.png"/></div></div></figure><p id="d3c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤3: </strong>原点是您的应用程序正在使用的<strong class="ih hj">负载平衡器</strong>。在我们的例子中，我们使用Kubernetes入口正在使用的负载平衡器</p><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es md"><img src="../Images/de69703f7e5f7d66db4b4a74fd9ac295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYgXw3X_Tirlhn_nkjuYhQ.png"/></div></div></figure><p id="3f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第四步:</strong>大功告成！</p><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es me"><img src="../Images/b363e74d581c5f66688590a86fdc4488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPqS0Bstg8QTIqm03fKWNQ.png"/></div></div></figure><p id="d0af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，您的应用程序应该与CloudCDN集成在一起，通过该负载平衡器发出的任何请求都将开始在CDN上缓存。您可以使用默认的缓存键(如果您没有选择任何内容)，或者为需要缓存的URL创建一个自定义键。默认设置缓存所有请求。</p><blockquote class="je jf jg"><p id="32db" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">那么，你怎么知道CDN是为你的资产服务的呢？</strong></p></blockquote><p id="eb34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几种方法可以找到答案:</p><ol class=""><li id="b4b1" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">可以查看gcloud日志<em class="jh">通过负载均衡器过滤和转发规则</em>。在下图中，你可以看到我们的应用程序使用的svg文件有很长的名字。这些名称是我们预编译资产时进行的资产预编译的结果，散列被附加到文件名上。</li></ol><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mf"><img src="../Images/d50956380c9b01f45d4823cefb5af457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2l__3XprI03KwcpA6XAICQ.png"/></div></div></figure><p id="2a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.如果您深入到任何特定的日志条目，您应该会看到jsonPayload的statusDetails为“<strong class="ih hj"> response_from_cache </strong>”。相反，如果您看到“<strong class="ih hj"> response_sent_by_backend </strong>”，那么资产是从源服务器(您的服务器)而不是从CloudCDN缓存提供的。</p><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mg"><img src="../Images/32a1214fc1c8f466429dab7b61967953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BH6ymEvG8TpyxL-doSsmw.png"/></div></div></figure><p id="e303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.在Chrome Dev tools中，你可以检查某个资产，你应该在Response Headers部分看到一个“age”标题。在本例中，ic-Caret-down.svg文件是在36秒前创建的</p><figure class="lc ld le lf fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mh"><img src="../Images/f16351da253ca276112b56eceaa67005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_-PRrC_1UJynRFKGrRt-Q.png"/></div></div></figure><p id="b4f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.前/后时间:最后，您应该能够使用标准的页面性能测量工具检查页面加载时间，例如w <a class="ae jd" href="https://www.webpagetest.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> ebpagetest </strong> </a>或g <a class="ae jd" href="https://gtmetrix.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> tmetrix。</strong>T15】</a></p><blockquote class="je jf jg"><p id="c082" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">总之</strong>:以上改动将有助于压缩您的javascript和css文件，将它们存储在/public/assets/中..文件夹，并让CloudCDN将这些文件与图像一起缓存。这是一个不断发展的过程，我们可能会对本文进行其他优化，以使其保持最新。</p><p id="dc66" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">这种方法让我们的页面加载时间缩短了65%。</strong></p></blockquote></div></div>    
</body>
</html>