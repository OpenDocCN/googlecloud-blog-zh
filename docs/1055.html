<html>
<head>
<title>Knative Serving 0.7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每份0.7克</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/knative-serving-0-7-96e6d7be463e?source=collection_archive---------0-----------------------#2019-07-01">https://medium.com/google-cloud/knative-serving-0-7-96e6d7be463e?source=collection_archive---------0-----------------------#2019-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e103" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能已经听说了，Knative 0.7 已经在上周发布了。这个版本的一个显著变化是Knative Serving API从<code class="du je jf jg jh b"><a class="ae jd" href="http://serving.knative.dev/v1alpha" rel="noopener ugc nofollow" target="_blank">v1alpha</a>1</code>发展到了<code class="du je jf jg jh b"><a class="ae jd" href="http://serving.knative.dev/v1beta" rel="noopener ugc nofollow" target="_blank">v1beta</a>1</code>。虽然您仍然可以使用旧的<code class="du je jf jg jh b">v1alpha1</code> API，但是如果您想要更新到<code class="du je jf jg jh b">v1beta</code>，您需要重写您的Knative服务定义文件。新的API还允许命名修订、静默最新部署和更好的流量分流配置。在这篇文章中，我想概述一些变化。</p><h1 id="c7d3" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">更简洁的服务定义</h1><p id="3472" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">在以前版本的Knative中，如果您想部署一个简单的Knative服务并将100%的流量路由到它，您必须使用如下的<code class="du je jf jg jh b">runLatest</code>块:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="544c" class="kt jj hi jh b fi ku kv l kw kx">apiVersion: serving.knative.dev/v1alpha1<br/>kind: Service<br/>metadata:<br/>  name: helloworld<br/>  namespace: default<br/>spec:<br/>  runLatest:<br/>    configuration:<br/>      revisionTemplate:<br/>        spec:<br/>          container:<br/>            image: docker.io/meteatamel/helloworld:v1<br/>            env:<br/>              - name: TARGET<br/>                value: "v1"</span></pre><p id="e96c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在新版本中，相同的服务定义如下所示:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="309a" class="kt jj hi jh b fi ku kv l kw kx">apiVersion: serving.knative.dev/v1beta1<br/>kind: Service<br/>metadata:<br/>  name: helloworld<br/>  namespace: default<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - image: docker.io/meteatamel/helloworld:v1<br/>          env:<br/>            - name: TARGET<br/>              value: "v1"</span></pre><p id="f13e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这里没有<code class="du je jf jg jh b">runLatest</code>或<code class="du je jf jg jh b">configuration</code>，现在<code class="du je jf jg jh b">revisionTemplate</code>被简单地称为<code class="du je jf jg jh b">template</code>。这允许更紧凑的服务定义文件。</p><h1 id="97ae" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">命名修订</h1><p id="bf65" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">在以前的版本中，当您部署对Knative服务的更改时，您会得到如下的随机修订号:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="3ccc" class="kt jj hi jh b fi ku kv l kw kx">$ kubectl get revision</span><span id="9cb3" class="kt jj hi jh b fi ky kv l kw kx">NAME                                                   <br/>revision.serving.knative.dev/helloworld-c4pmt   <br/>revision.serving.knative.dev/helloworld-vkvjt</span></pre><p id="8d00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这通常是可以的，但是会使流量分割配置变得有点麻烦(稍后会详细介绍)。</p><p id="af8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在新版本中，默认情况下你仍然会得到随机的修订号，但是你也可以给你的修订起一个可预测的名字。例如，看看这个带有修订名称的服务定义文件:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="147e" class="kt jj hi jh b fi ku kv l kw kx">apiVersion: serving.knative.dev/v1beta1<br/>kind: Service<br/>metadata:<br/>  name: helloworld<br/>  namespace: default<br/>spec:<br/>  template:<br/>    metadata:<br/>      name: helloworld-v1<br/>    spec:<br/>      containers:<br/>        - image: docker.io/meteatamel/helloworld:v1<br/>          env:<br/>            - name: TARGET<br/>              value: "v1"<br/>  traffic:<br/>  - tag: current<br/>    <strong class="jh hj">revisionName: helloworld-v1</strong><br/>    percent: 100<br/>  - tag: latest<br/>    latestRevision: true<br/>    percent: 0</span></pre><p id="a56c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署时，您将获得指定的修订名称:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="ff9f" class="kt jj hi jh b fi ku kv l kw kx">$ kubectl get revision<br/><br/>NAME               SERVICE NAME       GENERATION<br/>helloworld-f4xvr   helloworld-f4xvr   2         <br/>helloworld-ln8rv   helloworld-ln8rv   3         <br/><strong class="jh hj">helloworld-v1      helloworld-v1      4 </strong>        <br/>helloworld-z9clz   helloworld-z9clz   1</span></pre><h1 id="6ef4" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">能够静默部署最新版本</h1><p id="ca15" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">在前面的例子中，您可能注意到了<code class="du je jf jg jh b">latest</code>配置:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="45da" class="kt jj hi jh b fi ku kv l kw kx">traffic:<br/>  - tag: current<br/>    revisionName: helloworld-v1<br/>    percent: 100<br/><strong class="jh hj">  - tag: latest<br/>    latestRevision: true<br/>    percent: 0</strong></span></pre><p id="f0d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您部署服务时，它将部署最新的修订版(在随机命名的修订版id下),但是<code class="du je jf jg jh b">helloworld-v1</code>将获得所有流量。换句话说，你默默地部署了最新的版本。主url <code class="du je jf jg jh b"><a class="ae jd" href="http://helloworld.default.example.com" rel="noopener ugc nofollow" target="_blank">http://helloworld.default.example.com</a></code>将指向<code class="du je jf jg jh b">helloworld-v1</code>修订版，但是您也可以在<code class="du je jf jg jh b"><a class="ae jd" href="http://latest-helloworld.default.example.com)" rel="noopener ugc nofollow" target="_blank">http://latest-helloworld.default.example.com</a></code>下访问最新的修订版</p><p id="70a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想在向用户展示之前部署一些代码并对其进行测试，这是非常有用的。</p><h1 id="c31f" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">更强大的流量分流配置</h1><p id="b42b" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">在Knative的前一版本中，当您想要在当前版本和候选版本之间划分流量时，您必须创建一个版本并定义一个部署百分比，如下所示:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="11e6" class="kt jj hi jh b fi ku kv l kw kx">apiVersion: serving.knative.dev/v1alpha1<br/>kind: Service<br/>metadata:<br/>  name: helloworld<br/>  namespace: default<br/>spec:<br/>  release:<br/>    # First revision is traffic target "current"<br/>    # Second revision is traffic target "candidate"<br/>    revisions: ["helloworld-xyzss", "helloworld-zyxss"]<br/>    rolloutPercent: 20 # 20% traffic to route to "candidate"<br/>    configuration:<br/>      revisionTemplate:<br/>        spec:<br/>          container:<br/>            image: docker.io/meteatamel/helloworld:v1<br/>            env:<br/>              - name: TARGET<br/>                value: "v4"</span></pre><p id="5883" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是有问题的，因为在初始部署之前不知道候选修订id。您必须应用此配置来部署候选版本，获取已部署候选版本的随机版本id，并使用该版本id再次进行部署，以应用流量分离。不理想。</p><p id="6b7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Knative的最新版本中，您可以在流量分割中使用命名修订:</p><pre class="kl km kn ko fd kp jh kq kr aw ks bi"><span id="71f0" class="kt jj hi jh b fi ku kv l kw kx">apiVersion: serving.knative.dev/v1beta1<br/>kind: Service<br/>metadata:<br/>  name: helloworld<br/>  namespace: default<br/>spec:<br/>  template:<br/>    metadata:<br/>      name: helloworld-v4<br/>    spec:<br/>      containers:<br/>        - image: docker.io/meteatamel/helloworld:v1<br/>          env:<br/>            - name: TARGET<br/>              value: "v4"<br/>  traffic:<br/>  - tag: current<br/>    <strong class="jh hj">revisionName: helloworld-v1</strong><br/>    percent: 50<br/>  - tag: candidate<br/>    <strong class="jh hj">revisionName: helloworld-v4</strong><br/>    percent: 50<br/>  - tag: latest<br/>    latestRevision: true<br/>    percent: 0</span></pre><p id="edc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这无疑是定义流量分流的更简单、更清晰的方式。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="5d26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我想用Knative Serving 0.7覆盖的所有内容。如果你想试用Knative 0.7，我用0.7的说明测试并更新了我的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial" rel="noopener ugc nofollow" target="_blank"> Knative教程</a>，所以去看看吧。</p><figure class="kl km kn ko fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lg"><img src="../Images/9fa252a12c7f217f4321b09693c64481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaV_jqf7uTGSk0FoYy7jLg.png"/></div></div></figure></div></div>    
</body>
</html>