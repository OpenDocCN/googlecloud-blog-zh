<html>
<head>
<title>Quickly restore BigQuery dataset with time travel and Cloud Workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用时间旅行和云工作流快速恢复BigQuery数据集</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/quickly-restore-bigquery-dataset-with-time-travel-and-cloud-workflows-a66b868f4684?source=collection_archive---------0-----------------------#2022-09-24">https://medium.com/google-cloud/quickly-restore-bigquery-dataset-with-time-travel-and-cloud-workflows-a66b868f4684?source=collection_archive---------0-----------------------#2022-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/16a85e40ad90c1506566b73647d7aac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VChV1LgOPDiFVysp2_bUUg.png"/></div></div></figure><p id="9290" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据对公司来说是<strong class="is hj">黄金</strong>。数据湖和数据仓库年复一年地变得流行起来，以保持和利用这种价值。</p><blockquote class="jo jp jq"><p id="eb73" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">更好的<strong class="is hj">数据质量和丰富度</strong>，更高的<strong class="is hj">其价值和更强大或更准确的</strong>是你可以用它实现的用例。</p></blockquote><p id="3905" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，数据管道<strong class="is hj">是IT资产</strong>，正如其中任何一个一样，潜在的<strong class="is hj">错误、问题或错误配置</strong>会<strong class="is hj">搞乱您的数据、降低质量或破坏一致性</strong>。</p><p id="fc54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在谷歌云上，<a class="ae jv" href="https://cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>提供了一个强大的<strong class="is hj">功能，可以回到大灾难之前的</strong>！</p><h1 id="b3cc" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">BigQuery时间旅行</h1><p id="5e92" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">BigQuery是<strong class="is hj">谷歌云数据仓库旗舰</strong>。它是无服务器的，你按使用付费，有大量的功能。<br/>其中一个，不太为人所知的是<a class="ae jv" href="https://cloud.google.com/bigquery/docs/time-travel" rel="noopener ugc nofollow" target="_blank">时间旅行</a>:你可以在过去7天的任何时间点访问你的<strong class="is hj">数据状态。</strong></p><p id="e2fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用它，添加您想要在查询中查看的<code class="du kz la lb lc b">system time</code>。</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="30f0" class="ll jx hi lc b fi lm ln l lo lp">SELECT *<br/>FROM `mydataset.mytable`<br/>  FOR SYSTEM_TIME AS OF &lt;DATE|TIMESTAMP&gt;</span></pre><h2 id="6e1e" class="ll jx hi bd jy lq lr ls kc lt lu lv kg jb lw lx kk jf ly lz ko jj ma mb ks mc bi translated">在变更日期扩展你的知识</h2><p id="7c72" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">除了时间旅行特性，一个全新的<strong class="is hj">提供了了解BigQuery表的</strong> <a class="ae jv" href="https://cloud.google.com/bigquery/docs/change-history" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">变化历史</strong> </a>的功能。<br/></p><p id="0884" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以执行这种类型的请求</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="e014" class="ll jx hi lc b fi lm ln l lo lp">SELECT<br/>* except (_CHANGE_TYPE,_CHANGE_TIMESTAMP),<br/>_CHANGE_TYPE AS change_type,<br/>_CHANGE_TIMESTAMP AS change_time<br/>FROM<br/>APPENDS(TABLE <!-- -->mydataset.mytable<!-- -->, TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY), NULL);</span></pre><p id="fd92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">这样，你就可以看到一行什么时候被更新了，</em> <strong class="is hj"> <em class="jr">更好地了解你的问题的爆炸半径。</em> </strong></p><h1 id="cd31" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">还原BigQuery表</h1><p id="531b" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">知道数据的过去值是很有趣的。但是现在想象一下</p><ul class=""><li id="a50f" class="md me hi is b it iu ix iy jb mf jf mg jj mh jn mi mj mk ml bi translated">用户执行查询，使<strong class="is hj">改变</strong>，甚至<strong class="is hj">删除</strong>数据</li><li id="d8a3" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated">一个夜间<strong class="is hj">进程被更新</strong>并扰乱你所有的数据</li><li id="35a9" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated">周一，你<strong class="is hj">发现周五晚上流程的一个错误配置</strong></li></ul><blockquote class="mr"><p id="5d30" class="ms mt hi bd mu mv mw mx my mz na jn dx translated">您希望<strong class="ak">恢复某个时间点的数据</strong></p></blockquote><p id="ca61" class="pw-post-body-paragraph iq ir hi is b it nb iv iw ix nc iz ja jb nd jd je jf ne jh ji jj nf jl jm jn hb bi translated">然后，使用固定的管道重放您的工作负载，以尽可能保持高质量的数据。</p></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="86c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，您可以在您表中执行查询来<strong class="is hj">获取引用状态并存储在另一个表中</strong></p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="2924" class="ll jx hi lc b fi lm ln l lo lp">CREATE TABLE <!-- -->mydataset.mynewtable AS <br/>SELECT *<br/>FROM `mydataset.mytable`<br/>  FOR SYSTEM_TIME AS OF &lt;DATE|TIMESTAMP&gt;</span></pre><p id="56a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那你可以</p><ul class=""><li id="5341" class="md me hi is b it iu ix iy jb mf jf mg jj mh jn mi mj mk ml bi translated"><strong class="is hj">删除当前表格的数据</strong></li><li id="dbd3" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated"><strong class="is hj">将保存的数据</strong>插入当前表格</li><li id="beca" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated"><strong class="is hj">删除</strong>临时新表</li></ul><p id="92ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于数据集的所有表，也是如此。<strong class="is hj"> <em class="jr">好无聊！！</em>T11】</strong></p><p id="5411" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们实现自动化吧！</p><h1 id="b10e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">自动化数据集恢复</h1><p id="5a1e" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">对于自动化来说，<strong class="is hj"> </strong> <a class="ae jv" href="https://cloud.google.com/workflows" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">云工作流</strong> </a>是一个有用的服务，可以循环所有数据集的表并调用BigQuery APIs。</p><p id="a75f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为，我们直接使用API，我们可以<strong class="is hj">用<a class="ae jv" href="https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs" rel="noopener ugc nofollow" target="_blank">big query作业API </a>简化过程</strong>。在查询<a class="ae jv" href="https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert" rel="noopener ugc nofollow" target="_blank">工作中插入</a>:</p><ul class=""><li id="0090" class="md me hi is b it iu ix iy jb mf jf mg jj mh jn mi mj mk ml bi translated"><strong class="is hj">定义源表中的查询</strong>与时间行程</li><li id="1320" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated"><strong class="is hj">设置目标</strong>表等于源表，</li><li id="bb79" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated"><strong class="is hj">将处置设置为</strong> <code class="du kz la lb lc b"><strong class="is hj">WRITE_TRUNCATE</strong></code>以在恢复前清除现有数据</li></ul><p id="ca0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像这样，用<strong class="is hj">一个单独的API调用</strong>，我们就可以<strong class="is hj">直接恢复源表</strong>中的数据！</p><p id="9cc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们深入工作流代码。</p><h2 id="c1f2" class="ll jx hi bd jy lq lr ls kc lt lu lv kg jb lw lx kk jf ly lz ko jj ma mb ks mc bi translated">分配变量</h2><p id="ff56" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">首先分配全局变量和参数变量</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="6110" class="ll jx hi lc b fi lm ln l lo lp">assign:<br/>          - sourceDataset: ${param.source_dataset}<br/>          - date: ${default(map.get(param,"date"),"TIMESTAMP_ADD(CURRENT_TIMESTAMP(), INTERVAL -1 DAY)")}<br/>          - projectId: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}<br/>          - location: "US"<br/>          - maxResult: 100<br/>          - pageToken: ""</span></pre><p id="7b7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">在那个例子中</em> <code class="du kz la lb lc b"><em class="jr">date</em></code> <em class="jr">是可选的。如果省略，将采用昨天的数据。</em> <strong class="is hj"> <em class="jr">日期是SQL注入的(不要让脚本对任何人开放！！).</em> </strong> <em class="jr">但这也意味着你可以设置一个SQL公式。</em></p><h2 id="2fdd" class="ll jx hi bd jy lq lr ls kc lt lu lv kg jb lw lx kk jf ly lz ko jj ma mb ks mc bi translated">列出数据集中的表</h2><p id="a643" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">第一步是了解要恢复的表。大多数情况下，<strong class="is hj">数据集</strong>中的整个表必须在某个时间点恢复，以<strong class="is hj">保持数据一致</strong>。</p><p id="202f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用了<a class="ae jv" href="https://cloud.google.com/workflows/docs/reference/googleapis/bigquery/v2/tables/list" rel="noopener ugc nofollow" target="_blank">大查询表列表连接器</a></p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="12ee" class="ll jx hi lc b fi lm ln l lo lp">- list-tables:<br/>        call: googleapis.bigquery.v2.tables.list<br/>        args:<br/>          datasetId: ${sourceDataset}<br/>          projectId: ${projectId}<br/>          maxResults: ${maxResult}<br/>          pageToken: ${pageToken}<br/>        result: listResult</span></pre><h2 id="0bc4" class="ll jx hi bd jy lq lr ls kc lt lu lv kg jb lw lx kk jf ly lz ko jj ma mb ks mc bi translated">并行运行查询作业</h2><p id="4bfc" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">有了这个表列表，我们就可以遍历它并调用<a class="ae jv" href="https://cloud.google.com/workflows/docs/reference/googleapis/bigquery/v2/jobs/insert" rel="noopener ugc nofollow" target="_blank"> BigQuery作业插入连接器</a>。<br/>为了优化流程，我们使用云工作流的<a class="ae jv" href="https://cloud.google.com/workflows/docs/reference/syntax/parallel-steps" rel="noopener ugc nofollow" target="_blank">并行特性</a></p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="b406" class="ll jx hi lc b fi lm ln l lo lp">- perform-restore:<br/>        parallel:<br/>          for:<br/>            value: table<br/>            in: ${listResult.tables}<br/>            steps:<br/>              - snapshot:<br/>                  call: googleapis.bigquery.v2.jobs.insert<br/>                  args:<br/>                    projectId: ${projectId}<br/>                    body:<br/>                      configuration:<br/>                        query:<br/>                          useLegacySql: false<br/>                          destinationTable:<br/>                            datasetId: ${sourceDataset}<br/>                            projectId: ${projectId}<br/>                            tableId: ${table.tableReference.tableId}<br/>                          query: ${"select * from " + projectId + "." + sourceDataset + "." + table.tableReference.tableId + " FOR SYSTEM TIME AS OF " + date }<br/>                          writeDisposition: "WRITE_TRUNCATE"</span></pre><p id="d1e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">注</em> <code class="du kz la lb lc b"><em class="jr">date</em></code> <em class="jr">参数注入在时间旅行部分。您还可以注意到查询中的表和目的地中的表是相同的</em></p><h2 id="1a43" class="ll jx hi bd jy lq lr ls kc lt lu lv kg jb lw lx kk jf ly lz ko jj ma mb ks mc bi translated">遍历表的页面</h2><p id="604c" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">如果数据集有许多表，则列表查询可以有几页。迭代它们</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="a250" class="ll jx hi lc b fi lm ln l lo lp">- check-iterate-pages:<br/>        switch:<br/>          - condition: ${default(map.get(listResult, "nextPageToken"),"") != ""}<br/>            steps:<br/>              - loop-over-pages:<br/>                  assign:<br/>                    - pageToken: ${listResult.nextPageToken}<br/>                  next: list-tables- check-iterate-pages:<br/>        switch:<br/>          - condition: ${default(map.get(listResult, "nextPageToken"),"") != ""}<br/>            steps:<br/>              - loop-over-pages:<br/>                  assign:<br/>                    - pageToken: ${listResult.nextPageToken}<br/>                  next: list-tables</span></pre></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="0d80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是全部代码</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="65d6" class="ll jx hi lc b fi lm ln l lo lp">main:<br/>  params: [param]<br/>  steps:<br/>    - assignStep:<br/>        assign:<br/>          - sourceDataset: ${param.source_dataset}<br/>          - date: ${default(map.get(param,"date"),"TIMESTAMP_ADD(CURRENT_TIMESTAMP(), INTERVAL -1 DAY)")}<br/>          - projectId: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}<br/>          - location: "US"<br/>          - maxResult: 100<br/>          - pageToken: ""<br/>    - list-tables:<br/>        call: googleapis.bigquery.v2.tables.list<br/>        args:<br/>          datasetId: ${sourceDataset}<br/>          projectId: ${projectId}<br/>          maxResults: ${maxResult}<br/>          pageToken: ${pageToken}<br/>        result: listResult<br/>    - perform-restore:<br/>        parallel:<br/>          for:<br/>            value: table<br/>            in: ${listResult.tables}<br/>            steps:<br/>              - snapshot:<br/>                  call: googleapis.bigquery.v2.jobs.insert<br/>                  args:<br/>                    projectId: ${projectId}<br/>                    body:<br/>                      configuration:<br/>                        query:<br/>                          useLegacySql: false<br/>                          destinationTable:<br/>                            datasetId: ${sourceDataset}<br/>                            projectId: ${projectId}<br/>                            tableId: ${table.tableReference.tableId}<br/>                          query: ${"select * from " + projectId + "." + sourceDataset + "." + table.tableReference.tableId + " FOR SYSTEM TIME AS OF " + date }<br/>                          writeDisposition: "WRITE_TRUNCATE"<br/>    - check-iterate-pages:<br/>        switch:<br/>          - condition: ${default(map.get(listResult, "nextPageToken"),"") != ""}<br/>            steps:<br/>              - loop-over-pages:<br/>                  assign:<br/>                    - pageToken: ${listResult.nextPageToken}<br/>                  next: list-tables</span></pre><p id="1e0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用以下命令部署您的工作流</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="31b7" class="ll jx hi lc b fi lm ln l lo lp">gcloud workflows deploy &lt;workflowName&gt; \<br/> --source=&lt;workflowFileName&gt; \<br/> --service-account=&lt;runtimeServiceAccountEmail&gt;</span></pre><p id="aedc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">运行时服务帐户</em> <strong class="is hj"> <em class="jr">必须拥有数据集上的BigQuery admin角色</em> </strong> <em class="jr">。</em></p><p id="510a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并运行它</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="fcdd" class="ll jx hi lc b fi lm ln l lo lp">gcloud workflows run &lt;workflowName&gt; \<br/>  --data='{"source_dataset":"&lt;YourDataset&gt;"}'</span></pre><p id="ff12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以提到<code class="du kz la lb lc b">date</code>作为输入</p><pre class="ld le lf lg fd lh lc li lj aw lk bi"><span id="79b6" class="ll jx hi lc b fi lm ln l lo lp">gcloud workflows run &lt;workflowName&gt; \<br/>  --data='{"source_dataset":"&lt;YourDataset&gt;", "date":"2022-09-15"}'</span></pre><h1 id="a39c" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">保持您的数据价值</h1><p id="858d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">您的<strong class="is hj">数据在您的数据仓库</strong>中至关重要，而<strong class="is hj"> BigQuery和云工作流</strong>的结合可以帮助您完成这项任务。</p><p id="9689" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经介绍过<a class="ae jv" rel="noopener" href="/google-cloud/bigquery-snapshot-dataset-with-cloud-workflow-5175eb8df00b">如何给你的数据集</a>拍快照，以便能够超越7天的时间旅行。<br/>这一次，在数据损坏的情况下，这是一个可能的<strong class="is hj">快速回滚</strong>。</p><p id="d075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">问题发生</strong>，错误存在<strong class="is hj"/>，想办法<strong class="is hj">保护核心价值</strong>！</p></div></div>    
</body>
</html>