<html>
<head>
<title>Calling an internal GKE service from Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从云功能调用内部GKE服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/calling-an-internal-gke-service-from-cloud-functions-2958f9218355?source=collection_archive---------0-----------------------#2019-12-02">https://medium.com/google-cloud/calling-an-internal-gke-service-from-cloud-functions-2958f9218355?source=collection_archive---------0-----------------------#2019-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/daa53056d2ee050e99190fe711582321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4B5Eg_X_nsPFqlahldq6tg.png"/></div></div></figure><p id="4df2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑一个暴露在互联网上的云功能。部署时，我们可以调用该函数，实现逻辑将被执行。现在，假设该函数希望调用一个REST公开的服务，该服务被实现为Kubernetes中托管的容器。示意性地，我们希望以以下内容结束:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/f73475747fcf663279bc2463b898ed6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqWgG0e1TA4l2kUIORnZRg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">期望的架构/示意图</figcaption></figure><p id="4265" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这表明客户端通过互联网调用云函数。然后，云功能调用托管在一组复制pod中的目标服务(<code class="du jx jy jz ka b">MyService</code>)。这些豆荚是作为Kubernetes服务公开的。Kubernetes服务只出现在GCP VPC公司的内部网络中。显而易见，服务<strong class="is hj">没有</strong>暴露于互联网，因此服务的受攻击面减小。</p><p id="c62e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个故事听起来很有道理，但我们还有几个谜题需要解答。第一个是<code class="du jx jy jz ka b">MyService</code>服务定义的概念。当我们定义一个Kubernetes服务时，我们可以选择如何公开该服务。具体来说，我们有<code class="du jx jy jz ka b">spec.type</code>属性，可以是以下之一:</p><ul class=""><li id="d9a8" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><code class="du jx jy jz ka b">ClusterIP</code> —默认。该服务在集群网络内可用。</li><li id="4bbd" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><code class="du jx jy jz ka b">NodePort</code> —服务存在于每个节点的本地主机的给定端口上。</li><li id="9726" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><code class="du jx jy jz ka b">LoadBalancer</code> —通过云提供商的负载均衡器公开。</li><li id="29f9" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><code class="du jx jy jz ka b">ExternalName</code> —映射到外部名称。</li></ul><p id="5ead" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中，<code class="du jx jy jz ka b">LoadBalancer</code>似乎是显而易见的选择。但是，如果我们使用此选项，默认设置是将服务公开给一个Internet稳定的IP，如下所示:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/ad13fe97368e0ef9ed5db8e25d93efc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFq29Fh311FzIcrKCDY3qw.png"/></div></div></figure><p id="2986" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这在功能上可行，但我们已经将<code class="du jx jy jz ka b">MyService</code>暴露在互联网上，并增加了攻击面。解决方案是使用GKE提供的GCP特定功能，创建一个只对GCP内部VPC网络开放的负载平衡器。这通过公开具有VPC稳定IP地址的服务来实现TCP/UDP层负载平衡。通过在名为<code class="du jx jy jz ka b">cloud.google.com/load-balancer-type</code>的服务描述中添加一个值为<code class="du jx jy jz ka b">Internal</code>的<code class="du jx jy jz ka b">metadata.annotations</code>条目来启用该特性。</p><p id="da30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个示例服务可以是:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="0adb" class="kt ku hi ka b fi kv kw l kx ky">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: myservice<br/>  annotations:<br/>    cloud.google.com/load-balancer-type: "Internal"<br/>  labels:<br/>    app: myservice<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: myservice<br/>  ports:<br/>  - port: 80<br/>    targetPort: 8080<br/>    protocol: TCP</span></pre><p id="2a38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦定义完毕，我们现在将拥有一个负载平衡器，当调用它时，它会将流量路由到我们的pod。负载平衡器的稳定IP地址将出现在内部VPC网络上。我们的服务不会在互联网上曝光。</p><p id="ce31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在图表中，我们有:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/85193a27446909654e99ebac31d2e01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Og8_G-IA-BC-M--0WTu6Hw.png"/></div></div></figure><p id="30c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一个问题。云功能是一个无服务器组件。这对我们来说意味着，当客户端调用云函数时，云函数在谷歌管理的环境中运行，该环境独立于我们在GCP项目中定义的任何其他资源。这包括使用VPC网络。默认情况下，云功能根本无法访问该网络。如果它试图到达负载平衡服务的稳定IP，我们会发现没有到它的路径。谢天谢地，有一个解决方案。VPC网络中有一个组件叫做VPC接入。该组件允许无服务器GCP产品(如云功能)与VPC网络相关联，以便访问该网络上的IP地址的请求能够成功。</p><p id="9fea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以从我们的云函数向目标服务发出一个REST调用，它将按预期工作。我们要做的最后一个调整是为我们的稳定IP注册一个DNS条目，这样我们就可以将请求编码到一个逻辑命名的DNS实体，而不是一个不透明的IP地址。为此，我们将在云DNS中使用一个私有区域。最终的结果是我们最初所期望的，并在本系列的原始图表中显示出来。</p><p id="4e15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是创建一个示例Kubernetes服务并从前面描述的云函数调用它的一步一步的步骤。</p><ol class=""><li id="eb2e" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kz kh ki kj bi translated">创建一个集群</li></ol><p id="af3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用云控制台创建一个名为my-cluster的集群。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es la"><img src="../Images/c1407bbcbf34e602c151bd7a6919a4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*cXJ-vfnX94RGS1XwyqcCKw.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/8455a4624f81ca7ee8d6d137d5eb26f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*Sd5t6yhVApETjoarDwFyqA.png"/></div></figure><p id="ecf9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们单击创建。这将创建我们的集群，需要几分钟时间。</p><p id="c934" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创建应用程序</p><p id="767c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想要一个简单的应用程序在我们的豆荚中运行。</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="8de9" class="kt ku hi ka b fi kv kw l kx ky">const http = require('http');<br/>const os = require('os');<br/>const handler = function(request, response) {<br/>    response.writeHead(200);<br/>    response.end("You've hit " + os.hostname() + "\n");<br/>};<br/>var www = http.createServer(handler);<br/><a class="ae lc" href="http://www.listen(8080);" rel="noopener ugc nofollow" target="_blank">www.listen(8080);</a></span></pre><p id="f2e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是用于构建docker映像的Dockerfile的相应内容:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="2735" class="kt ku hi ka b fi kv kw l kx ky">FROM node:7<br/>ADD app.js /app.js<br/>ENTRYPOINT ["node", "app.js"]</span></pre><p id="3f24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.创建一个docker映像并将其放入注册表。</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="cc30" class="kt ku hi ka b fi kv kw l kx ky">gcloud container clusters get-credentials my-cluster --zone us-central1-a<br/>docker build -t gcr.io/[PROJECT]/my-image<br/>docker push gcr.io/[PROJECT]/my-image</span></pre><p id="e77c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.创建一个Kubernetes复制集。</p><p id="8df6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用以下内容创建一个名为<code class="du jx jy jz ka b">replica-set.yaml</code>的文件:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="be74" class="kt ku hi ka b fi kv kw l kx ky">apiVersion: apps/v1<br/>kind: ReplicaSet<br/>metadata:<br/>  name: my-replica-set<br/>  labels:<br/>    app: my-app<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: my-app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: my-app<br/>    spec:<br/>      containers:<br/>      - name: my-app<br/>        image: gcr.io/[PROJECT]/my-image</span></pre><p id="f3f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将此应用于我们的Kubernetes集群:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="d98f" class="kt ku hi ka b fi kv kw l kx ky">kubectl apply -f replica-set.yaml</span></pre><p id="afbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在控制台中，访问Kubernetes Engine -&gt; Workloads，等待名为<code class="du jx jy jz ka b">my-replica-set</code>的工作负载的状态到达<code class="du jx jy jz ka b">OK</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/d6324d8923f987c3528671e5c9fa6dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbTwYECfs4zQs6GPRyrGEw.png"/></div></div></figure><p id="3bc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，吊舱正在运行。</p><p id="fb8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.创建服务</p><p id="d28f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建LoadBalancer类型的服务，并使用注释声明我们正在使用内部TCP/UDP负载平衡器。创建一个名为<code class="du jx jy jz ka b">service.yaml</code>的文件，其中包含:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="b092" class="kt ku hi ka b fi kv kw l kx ky">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-service<br/>  annotations:<br/>    cloud.google.com/load-balancer-type: "Internal"<br/>  labels:<br/>    app: my-service<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: my-app<br/>  ports:<br/>  - port: 80<br/>    targetPort: 8080<br/>    protocol: TCP</span></pre><p id="9a95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将此应用于我们的Kubernetes集群:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="4edd" class="kt ku hi ka b fi kv kw l kx ky">kubectl apply -f service.yaml</span></pre><p id="f9bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在控制台中，访问Kubernetes引擎-&gt;服务和入口。等待名为<code class="du jx jy jz ka b">my-service</code>的服务到达<code class="du jx jy jz ka b">OK</code>状态。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/55de70d8a55999d79e6934ce2cdd7db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkbQ6eRyi4lLN4AuCEUb2g.png"/></div></div></figure><p id="1883" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记下IP地址。这是可以到达负载平衡器的VPC网络上的IP。</p><p id="364c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.创建DNS条目</p><p id="e1cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在控制台中，访问网络服务-&gt;云DNS。点击<code class="du jx jy jz ka b">Create zone</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/b56a98e6d3a22393dbf0d0dad46ca4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*uHcNOqX-Y7m-v7XBZNTpYg.png"/></div></figure><p id="4464" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将区域类型设置为私有。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/cf609014048e34b78bcb21a7475bd567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*GGwsOzYvY5puG_5swY1z6A.png"/></div></figure><p id="2de9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击<code class="du jx jy jz ka b">Add record set</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/7f26927d22ab2c34c86a63e4e314f16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*t-TeMtLkFs8ATYCT54xMzA.png"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es li"><img src="../Images/227324f17d3eb29520a51d2d3d5c42d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*kOhi8JQKtBJ-SmafnBxIRA.png"/></div></figure><p id="cdcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我们已经有了从<code class="du jx jy jz ka b">myservice.mycompany.internal</code>到负载平衡器的映射。</p><p id="135d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.定义无服务器VPC访问。</p><p id="d9b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">访问VPC网络-&gt;无服务器VPC访问。单击创建连接器。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/f7ea122178b476b107856d8585592ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_5pBRJrhlryzXl8ZDZHKA.png"/></div></div></figure><p id="ad6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.创建一个调用REST服务的云函数。</p><p id="ace6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是调用云函数时将执行的JavaScript代码。我们示例的重点是调用我们的Kubernetes服务的REST请求:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="6d47" class="kt ku hi ka b fi kv kw l kx ky">exports.helloWorld = (req, res) =&gt; {<br/>  const request = require('request');<br/>  <strong class="ka hj">request('http://myservice.mycompany.internal',<br/>   </strong>(err, resS, body) =&gt; {<strong class="ka hj"><br/>    </strong>let message = "Hello from Cloud Function: " + body;<br/>    res.status(200).send(message);<br/>  });<br/>};</span></pre><p id="4213" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jx jy jz ka b">package.json</code>应包含:</p><pre class="jp jq jr js fd kp ka kq kr aw ks bi"><span id="00dc" class="kt ku hi ka b fi kv kw l kx ky">{<br/>  "name": "sample-http",<br/>  "version": "0.0.1",<br/>  "dependencies": {<br/>    "request": "latest"<br/>  }<br/>}</span></pre><p id="39f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在函数定义中，在“网络”下的“高级选项”中，引用VPC连接器:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/c064ce904dec720915ae79a5501e03bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*WK02SXWeRPNW8vkf-Tvn4w.png"/></div></figure><p id="4cb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">9.测试功能</p><p id="0049" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以调用云函数，并看到内部Kubernetes托管的服务正在被调用。</p><p id="5181" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另请参见:</p><ul class=""><li id="858e" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><a class="ae lc" href="https://cloud.google.com/kubernetes-engine/docs/how-to/internal-load-balancing" rel="noopener ugc nofollow" target="_blank">内部TCP/UDP负载均衡</a></li><li id="785f" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae lc" rel="noopener" href="/google-cloud/internal-load-balancing-for-kubernetes-services-on-google-cloud-f8aef11fb1c4">中:Google Cloud上kubernetes服务的内部负载平衡</a></li><li id="bb24" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae lc" href="https://cloud.google.com/vpc/docs/configure-serverless-vpc-access" rel="noopener ugc nofollow" target="_blank">配置无服务器VPC访问</a></li><li id="3a71" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae lc" href="https://cloud.google.com/functions/docs/connecting-vpc" rel="noopener ugc nofollow" target="_blank">云功能:连接到VPC网络</a></li><li id="5230" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae lc" href="https://www.the-swamp.info/blog/connecting-cloud-functions-compute-engine-serverless-vpc-access/" rel="noopener ugc nofollow" target="_blank">使用无服务器VPC访问将云功能与计算引擎相连接</a></li></ul></div></div>    
</body>
</html>