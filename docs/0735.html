<html>
<head>
<title>CoreDNS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CoreDNS</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/coredns-afaa732aa35e?source=collection_archive---------0-----------------------#2018-08-22">https://medium.com/google-cloud/coredns-afaa732aa35e?source=collection_archive---------0-----------------------#2018-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d1be" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">库伯内特斯历险记</h2></div><blockquote class="ix iy iz"><p id="3fe2" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">“因为缺少一颗钉子”</p></blockquote><p id="1ad4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我有一个——让我们不去那里——需要别名一个Kubernetes服务到一个完全合格的域名。完成这项工作的技巧让我有了一个学习CoreDNS的机会。CoreDNS是kube-dns的替代方案(<a class="ae ka" href="https://kubernetes.io/blog/2018/07/10/coredns-ga-for-kubernetes-cluster-dns/" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><h2 id="e556" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">问题</h2><p id="d23f" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">我需要临时将<code class="du lb lc ld le b">[release-name]-[chart-name]-orderer</code>别名为<code class="du lb lc ld le b">orderer.example.com</code>才能前进(解析！？)Kubernetes上Hyperledger Fabric的舵图。</p><h2 id="a535" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">一个解决方案？</h2><p id="f6ad" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">成功的定义是，当Pods调用<code class="du lb lc ld le b">orderer.example.com</code>时，名称被解析为上述服务。可以使用所谓的“<a class="ae ka" href="https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#configure-stub-domain-and-upstream-dns-servers" rel="noopener ugc nofollow" target="_blank">存根域</a>”(使用ConfigMap配置)来配置集群的kube-dns，以便(在本例中)<code class="du lb lc ld le b">*.example.com</code>的dns请求由我控制的DNS服务解析。一个基于CoreDNS。</p><h2 id="3e56" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">CoreDNS</h2><p id="9a2f" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">让我们在本地测试一下。</p><p id="0adb" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我将保留CoreDNS的示例<code class="du lb lc ld le b">example.org</code> (dot-org)作为已知的工作配置，并将添加我自己的<code class="du lb lc ld le b">example.com</code> (dot-com):</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><blockquote class="ix iy iz"><p id="2d78" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong>神奇的事情发生在第13行，这里<code class="du lb lc ld le b">orderer</code>是<code class="du lb lc ld le b">[[RELEASE-NAME]]-[[CHART-NAME]]-orderer.</code>的别名，不要忘记终止。。我用实际值代替<code class="du lb lc ld le b">RELEASE-NAME</code>和<code class="du lb lc ld le b">CHART-NAME</code>。</p></blockquote><p id="aa49" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我们也需要CoreDNS的配置文件。默认情况下，这被称为<code class="du lb lc ld le b">Corefile</code>:</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><blockquote class="ix iy iz"><p id="4b64" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj">注意</strong>这定义了2个DNS域(<code class="du lb lc ld le b">example.com</code>和<code class="du lb lc ld le b">example.org</code>)。两者都包含一系列以<code class="du lb lc ld le b">file</code>开头的插件。<code class="du lb lc ld le b">file</code>后的值是一个参数，引用上述<code class="du lb lc ld le b">example.com</code>等文件。</p></blockquote><p id="1a93" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">让我们运行Docker图像:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="4d89" class="kb kc hi le b fi lq lr l ls lt">docker run \<br/>--interactive \<br/>--tty \<br/>--publish=1053:1053/tcp \<br/>--publish=1053:1053/udp \<br/>--volume=$PWD:/tmp \<br/>coredns/coredns \<br/>  -conf /tmp/Corefile \<br/>  -dns.port 1053</span></pre><blockquote class="ix iy iz"><p id="3b74" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj">注意</strong>端口<code class="du lb lc ld le b">1053</code>上的双重发布是因为DNS同时使用TCP和UDP。我假设上述文件在当前(<code class="du lb lc ld le b">${PWD}</code>)目录中。这个目录被映射到容器中的<code class="du lb lc ld le b">/tmp</code>。容器将在这个目录中找到<code class="du lb lc ld le b">Corefile</code>，并且它引用了应该在同一个(<code class="du lb lc ld le b">/tmp</code>)目录中的<code class="du lb lc ld le b">example.org</code>和<code class="du lb lc ld le b">example.com</code>。</p></blockquote><p id="56e2" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这应该会输出类似如下的内容:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="1429" class="kb kc hi le b fi lq lr l ls lt">example.com.:1053<br/>example.org.:1053<br/>2018/08/22 16:48:32 [INFO] CoreDNS-1.2.0<br/>2018/08/22 16:48:32 [INFO] linux/amd64, go1.10.3, 2e322f6<br/>CoreDNS-1.2.0<br/>linux/amd64, go1.10.3, 2e322f6</span></pre><p id="899a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">从另一个终端尝试:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="22b5" class="kb kc hi le b fi lq lr l ls lt">nslookup orderer.example.com -port 1053 localhost</span></pre><p id="6684" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这应该会产生:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="5e0b" class="kb kc hi le b fi lq lr l ls lt">Server:  localhost<br/>Address: ::1#1053</span><span id="bcdb" class="kb kc hi le b fi lu lr l ls lt">orderer.example.com canonical name = x-hyperledger-fabric-orderer.<br/>** server can't find x-hyperledger-fabric-orderer: REFUSED</span></pre><blockquote class="ix iy iz"><p id="8c1b" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong>这是正确的错误；-) CoreDNS已将<code class="du lb lc ld le b">orderer.example.com</code>别名化为<code class="du lb lc ld le b">x-hyperledger-fabric-orderer</code>。没错。该端点上目前没有任何东西，因此我们收到一个“找不到”错误(正确地说)。</p></blockquote><p id="0108" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">CoreDNS的文档使用dig代替nslookup…您的偏好:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="5bc7" class="kb kc hi le b fi lq lr l ls lt">dig <a class="ae ka" href="http://twitter.com/localhost" rel="noopener ugc nofollow" target="_blank">@localhost</a> -p 1053 a orderer.example.com</span></pre><h2 id="4ac4" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">容器优化操作系统(COS)</h2><p id="1ed6" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">如果你有一个容器，你想在谷歌云平台上运行它，Kubernetes是一个很好的默认选择。在本例中，我将在与我的Kubernetes集群相同的项目中的COS实例上运行CoreDNS。</p><p id="e149" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">为了简单起见，在配置COS实例之后，我将手动运行CoreDNS命令。COS在<code class="du lb lc ld le b">/tmp</code>上提供了一个可读写的文件系统，这也是我之前选择这个目录的原因。</p><p id="f24f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在运行容器之前，让我们将CoreDNS配置文件复制到实例中:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="0c35" class="kb kc hi le b fi lq lr l ls lt">PROJECT=[[YOUR-PROJECT]]<br/>INSTANCE=[[YOUR-INSTANCE]]</span><span id="cb51" class="kb kc hi le b fi lu lr l ls lt">for FILE in Corefile example.org example.com<br/>do<br/>  gcloud compute scp \<br/>  ${FILE} \<br/>  ${INSTANCE}:/tmp \<br/>  --project=${PROJECT}<br/>done</span></pre><blockquote class="ix iy iz"><p id="0036" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong> COS使用systemd-resolved，COS默认为<code class="du lb lc ld le b">DNSStubListener=udp</code>。要运行CoreDNS，您需要禁用它，您可以使用<code class="du lb lc ld le b">sudo systemctl stop systemd-resolved</code>来(暂时)禁用它。</p></blockquote><p id="283c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">然后<code class="du lb lc ld le b">gcloud compute ssh</code>像以前一样运行Docker命令，但是(1)将本地目录更改为<code class="du lb lc ld le b">/tmp</code>，以及(2)将DNS端口更改为其默认值(<code class="du lb lc ld le b">53</code>):</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="fdd8" class="kb kc hi le b fi lq lr l ls lt">docker run \<br/>--interactive \<br/>--tty \<br/>--publish=53:53/tcp \<br/>--publish=53:53/udp \<br/>--volume=<strong class="le hj">/tmp</strong>:/tmp \<br/>coredns/coredns \<br/>  -conf /tmp/Corefile \<br/>  -dns.port <strong class="le hj">53</strong></span></pre><blockquote class="ix iy iz"><p id="8225" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj">问题#1 </strong>:我宁愿不打开不必要的防火墙端口。但是，我无法使用内部IP从Kubernetes集群连接到CoreDNS实例。正在调查。CoreDNS实例的内部IP可用:</p></blockquote><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="abc7" class="kb kc hi le b fi lq lr l ls lt">DNS=$(\<br/>  gcloud compute instances describe ${INSTANCE} \<br/>  --project=${PROJECT} \<br/>  --format="value(networkInterfaces[0]<strong class="le hj">.networkIP</strong>)"\<br/>) &amp;&amp; echo ${DNS}</span></pre><p id="03dc" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">公共IP(有效)可用:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="1f2f" class="kb kc hi le b fi lq lr l ls lt">DNS=$(\<br/>  gcloud compute instances describe ${INSTANCE} \<br/>  --project=${PROJECT} \<br/>  --format="value(networkInterfaces[0]<strong class="le hj">.accessConfigs[0].natIP</strong>)"\<br/>) &amp;&amp; echo ${DNS}</span></pre><p id="82c1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">对于公共IP，你需要在防火墙上打一个洞。我将让你来决定；这将打开<em class="jc">实例的互联网端口</em>:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="e3d2" class="kb kc hi le b fi lq lr l ls lt">gcloud compute instances add-tags ${INSTANCE} \<br/>--tags=coredns \<br/>--project=${PROJECT}</span><span id="925e" class="kb kc hi le b fi lu lr l ls lt">gcloud compute firewall-rules create temp-test-coredns \<br/>--action=ALLOW \<br/>--rules=tcp:53,udp:53 \<br/>--target-tags=coredns \<br/>--project=${PROJECT}</span></pre><p id="d997" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">然后，从集群中的另一个实例:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="4467" class="kb kc hi le b fi lq lr l ls lt">nslookup orderer.example.com ${DNS}</span><span id="bb7c" class="kb kc hi le b fi lu lr l ls lt">Server:  10.138.0.5<br/>Address: 10.138.0.5#53</span><span id="4ed4" class="kb kc hi le b fi lu lr l ls lt">orderer.example.com canonical name = x-hyperledger-fabric-orderer.</span></pre><p id="822e" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">或者，在我的例子中，因为我从另一个COS实例运行:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="041e" class="kb kc hi le b fi lq lr l ls lt">docker run \<br/>--net=host \<br/>busybox \<br/>  nslookup orderer.example.com ${DNS}</span><span id="3aba" class="kb kc hi le b fi lu lr l ls lt">Server:  10.138.0.5<br/>Address: 10.138.0.5:53</span><span id="af99" class="kb kc hi le b fi lu lr l ls lt">orderer.example.com canonical name = <strong class="le hj">x-hyperledger-fabric-orderer</strong></span><span id="6af3" class="kb kc hi le b fi lu lr l ls lt">*** Can't find orderer.example.com: No answer</span></pre><blockquote class="ix iy iz"><p id="4ea2" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong> busybox的nslookup行为略有不同。它报告了正确的别名，但确认找不到<code class="du lb lc ld le b">orderer.example.com</code>(而不是<code class="du lb lc ld le b">x-hyperledger-fabric-orderer</code>)。</p></blockquote><h2 id="26e7" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">库伯内特斯</h2><p id="0dfe" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">到目前为止一切正常，让我们通过应用定义dns服务器的配置图来修改Kubernetes的kube-dns配置:</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><blockquote class="ix iy iz"><p id="c216" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong>你必须用它的值替换<code class="du lb lc ld le b">${DNS}</code>。结果必须用引号括起来。清单显式引用了<code class="du lb lc ld le b">kube-system</code>名称空间。</p></blockquote><p id="7351" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">然后:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="b74c" class="kb kc hi le b fi lq lr l ls lt">kubectl apply --filename=kube-dns.yaml<br/>Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply<br/><strong class="le hj">configmap/kube-dns configured</strong></span></pre><blockquote class="ix iy iz"><p id="3744" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong>忽略“警告”。</p></blockquote><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/4bb7798917203cea27d8e2f32fa764d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBDOX0N3rFtiEmCgfvOWIA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">显示系统对象的Kubernetes控制台</figcaption></figure><p id="a841" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">还有，我们来测试一下！</p><h2 id="e25d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">测试</h2><blockquote class="ix iy iz"><p id="9bf5" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj">问题#2 </strong>:我尝试将<code class="du lb lc ld le b">orderer.example.com</code>解析为Kubernetes服务名，但是没有成功。我不知道为什么。正在调查。</p></blockquote><p id="783f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这个(<code class="du lb lc ld le b">CNAME</code>)不起作用:</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="f21c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">相反，我确定了服务的IP地址，并将CoreDNS <code class="du lb lc ld le b">example.com</code>文件重新配置为<code class="du lb lc ld le b">A</code> (lias)文件:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="9e9a" class="kb kc hi le b fi lq lr l ls lt">ORDERER=$(\<br/>  kubectl get services \<br/>  --selector=component=orderer \<br/>  --namespace=${NAMESPACE} \<br/>  --output=jsonpath="{.items[0].spec.clusterIP}"\<br/>) &amp;&amp; echo ${ORDERER}</span></pre><p id="93c0" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">然后:</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><blockquote class="ix iy iz"><p id="e099" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong>你必须用它的值替换<code class="du lb lc ld le b">${ORDERER}</code>。</p></blockquote><p id="0701" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">现在，从集群中的一个Pod，<code class="du lb lc ld le b">nslookup</code>将解析<code class="du lb lc ld le b">orderer.example.com</code>:</p><pre class="lf lg lh li fd lm le ln lo aw lp bi"><span id="8e29" class="kb kc hi le b fi lq lr l ls lt">kubectl run test \<br/>--namespace=${NAMESPACE} \<br/>--image=busybox \<br/>--stdin \<br/>--tty<br/>If you don't see a command prompt, try pressing enter.<br/>/ # <strong class="le hj">nslookup orderer.example.com</strong><br/>Name:      orderer.example.com<br/>Address 1: 10.27.253.203 <strong class="le hj">x-hyperledger-fabric-orderer.ytterbium.svc.cluster.local</strong><br/>/ #</span></pre><p id="bcb5" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">嘭！</p><h2 id="a902" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">未决问题</h2><ul class=""><li id="b3c8" class="mg mh hi jd b je kw jh kx jx mi jy mj jz mk jw ml mm mn mo bi translated">为什么我无法使用内部IPs？</li><li id="2163" class="mg mh hi jd b je mp jh mq jx mr jy ms jz mt jw ml mm mn mo bi translated">怎么(！)我能把example.com解析到<code class="du lb lc ld le b">CNAME</code>(或者<code class="du lb lc ld le b">SRV</code>)吗？)?</li></ul><h2 id="4498" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">结论</h2><p id="88f3" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">使用CoreDNS运行你自己的DNS服务(比我想象的要容易得多)。</p><p id="f88a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">如果您希望用您控制的dns服务来补充Kubernetes集群的kube-dns，这也很容易。</p><p id="1313" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">虽然我实现了我的目标，并且现在能够在Helm部署上测试我的Fabric，Pods能够将<code class="du lb lc ld le b">orderer.example.com</code>解析为Kubernetes服务名称(并证明是一个调试点)，但是旅程比我希望的要长:-)</p><p id="e361" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">仅此而已！</p></div></div>    
</body>
</html>