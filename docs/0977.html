<html>
<head>
<title>Entity Groups, Ancestors, and Indexes in Datastore- A Working Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据存储中的实体组、祖先和索引——一个工作示例</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/entity-groups-ancestors-and-indexes-in-datastore-a-working-example-3ee40cc185ee?source=collection_archive---------0-----------------------#2019-04-23">https://medium.com/google-cloud/entity-groups-ancestors-and-indexes-in-datastore-a-working-example-3ee40cc185ee?source=collection_archive---------0-----------------------#2019-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="97b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">作者:</strong> <a class="ae jd" rel="noopener" href="/@theodoresiu7"> <strong class="ih hj">萧</strong></a><strong class="ih hj"/><a class="ae jd" rel="noopener" href="/@kaitlinardiff"><strong class="ih hj">凯特林</strong> </a></p><h1 id="da1a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">快速回顾:数据存储如何存储您的数据</h1><p id="f9a2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在我们直接进入数据存储中的实体组之前，首先回顾一下基础知识并建立一个通用词汇表是很重要的。数据存储保存着<strong class="ih hj">实体</strong>，它们是可以包含各种键/值对的对象，称为<strong class="ih hj">属性</strong>。每个实体必须包含一个唯一的标识符，称为<strong class="ih hj">键</strong>。创建实体时，用户可以选择指定自定义密钥或让数据存储创建密钥。如果用户决定指定一个自定义键，它将包含两个字段:一个<strong class="ih hj">种类</strong>，它表示诸如“动物”或“职业状态”之类的类别，以及一个<strong class="ih hj">名称</strong>，它是识别值。如果用户决定在创建键时只指定一种类型，而不指定唯一标识符，Datastore会在后台自动生成一个ID。下面是一个Python3脚本的例子，演示了这个标识符的概念。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="07da" class="kq jf hi km b fi kr ks l kt ku">from google.cloud import datastore<br/>client = datastore.Client()</span><span id="53a9" class="kq jf hi km b fi kv ks l kt ku">#Custom key- specify my kind=item and unique_id = teddy_bear <br/>custom_key_ent = datastore.Entity(client.key("toy","teddy_bear"))<br/>client.put(custom_key_ent)</span><span id="841c" class="kq jf hi km b fi kv ks l kt ku">#Only specify kind=item, let datastore generate unique_id<br/>datastore_gen_key_ent = datastore.Entity(client.key("toy"))<br/>client.put(datastore_gen_key_ent)</span></pre><p id="1954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的GCP控制台的数据存储下，你会看到你的两个“玩具”类型的实体。一个包含您的自定义密钥，另一个包含自动生成的密钥。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/d265541e4d88db5888fe2b16218cd7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpVcZIUrJaGOvufuP5lRGg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">指定您的自定义密钥或数据存储将为您生成一个唯一的id</figcaption></figure><h1 id="a059" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">祖先和实体组</strong></h1><p id="01a0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对于高度相关或分层的数据，数据存储允许以父/子关系存储实体。这被称为实体组或祖先/后代关系。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/59938a96350d934b684e83b49f4090b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WnnT1X5_ZmaSH4IHm3-FUQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">这是一个实体组的例子，有各种类型的人、宠物和玩具。这种关系中的“祖父母”就是“人”。为了进行配置，必须首先创建Person实体。然后，用户可以创建一个宠物，并指定其父项为person key。为了创建“孙儿”,用户然后创建一个玩具并将它的父玩具设置为宠物钥匙。为了进一步添加可定制的属性，用户可以指定额外的键值对，如年龄、性别和类型。这些键值对被存储为<strong class="bd jg">属性</strong>。在下面的工作示例中，我们在数据存储中对此图进行建模。</figcaption></figure><p id="ecbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在为子代创建实体键时，可以通过设置“parent”参数来创建实体组。该命令将父键添加为子实体键的一部分。孩子的键被表示为一个元组(“parent_key”、“child_key”)，使得父母的键是键的前缀，其后是它自己的唯一标识符。例如，遵循上图:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b0b4" class="kq jf hi km b fi kr ks l kt ku">person_key = client.key("Person","Lucy")<br/>pet_key = client.key("Pet","Cherie", parent=person_key)</span></pre><p id="3fbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打印变量<code class="du lj lk ll km b">pet_key</code>将显示:<code class="du lj lk ll km b">("Person", "Lucy","Pet", "Cherie")</code>。</p><p id="065d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Datastore还支持父级的链接，这可以为具有长祖先血统的后代产生非常大的键。此外，父母可以有多个孩子(代表一对多关系)。但是，没有对实体拥有多个父级(表示多对多关系)的本机支持。一旦配置了这个祖先层次结构，就很容易检索给定父代的所有后代。您可以通过使用“ancestor”参数查询父键来做到这一点。例如，给定上面创建的实体<code class="du lj lk ll km b">pet_key</code>，我可以查询Cherie的所有玩具:<code class="du lj lk ll km b">my_query = client.query(kind="Toy", ancestor = pet_key)</code>。</p><h1 id="269b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">一个完整的工作示例</strong></h1><p id="ba14" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这是一个完整的Python3人/宠物/玩具层次模型的例子，它使用实体组来模拟上图。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8187" class="kq jf hi km b fi kr ks l kt ku">from google.cloud import datastore<br/>client = datastore.Client()</span><span id="f1c8" class="kq jf hi km b fi kv ks l kt ku"><br/>#Entities with kinds- person, pet, toy<br/>my_entities = [<br/>{"kind": "Person", "Person_id": "Lucy", "sex": "f","age": 18},<br/>{"kind": "Pet", "Pet_id": "Cherie", "Person_id": "Lucy",<br/>"sex": "f", "type": "dog", "age": 7},<br/>{"kind": "Pet", "Pet_id": "Bubsy", "Person_id": "Lucy", <br/>"sex": "m", "type": "fish", "age": 3},<br/>{"kind": "Toy", "Toy_id": "tennis_ball", "Pet_id": "Cherie", "Person_id": "Lucy", "price": .99},<br/>{"kind": "Toy", "Toy_id": "castle", "Pet_id": "Bubsy", <br/>"Person_id": "Lucy", "price": 49.99},<br/>{"kind": "Toy", "Toy_id": "rope", "Pet_id": "Cherie", "Person_id": "Lucy", "price": 10.99},<br/>]</span><span id="b556" class="kq jf hi km b fi kv ks l kt ku">#Iterate through entities and set immediate parents<br/>for entity in my_entities:<br/> kind = entity['kind']<br/> parent_key = None<br/> if kind == "Pet":<br/>  parent_key = client.key("Person", entity["Person_id"])<br/> elif kind == "Toy":<br/>  parent_key = client.key("Person", entity["Person_id"],<br/>                          "Pet", entity["Pet_id"])</span><span id="a365" class="kq jf hi km b fi kv ks l kt ku"> key = client.key(kind, <br/>     entity[kind+"_id"],<br/>     parent=parent_key) #Notice I set the parent key!!<br/> datastore_ent = datastore.Entity(key)<br/> datastore_ent.update(entity) #Include properties+id<br/> client.put(datastore_ent)</span></pre><p id="3d00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个人想查询一个特定的宠物，比如说我们想抓一只叫Cherie的狗。我们可以运行一个查询:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e1e0" class="kq jf hi km b fi kr ks l kt ku">query1 = client.query(kind="Pet")<br/>query1.add_filter("Pet_id", "=", "Cherie")</span></pre><p id="5521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Cherie实体，我们可以很容易地获取父母的id。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a87e" class="kq jf hi km b fi kr ks l kt ku">pet = list(query1.fetch())[0] # We know there is only one Cherie<br/>print(“Cherie’s parent: “ + str(pet.key.parent.id_or_name))</span></pre><p id="8315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们还可以在查询中使用ancestor子句获取Cherie的直系子女玩具。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="86f7" class="kq jf hi km b fi kr ks l kt ku">query2 = client.query(kind="Toy", ancestor=pet.key)<br/>for toy in list(query2.fetch()):<br/>     print(toy.key)<br/>     print(toy["Toy_id"])</span></pre><p id="d20e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于更复杂的查询，数据存储需要适当设置特定的索引。例如，使用额外的过滤器运行相同的查询将需要一个索引，如果没有索引，就会导致失败。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="da48" class="kq jf hi km b fi kr ks l kt ku"># Adding a filter on the price will cause this to fail!<br/>query2 = client.query(kind="Toy", ancestor=pet.key)<br/>query2.add_filter("price", "&gt;", .5)<br/>for toy in list(query2.fetch()):<br/>        print(toy.key)<br/>        print(toy["Toy_id"])</span></pre><p id="010f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要解决此问题，请使用包含以下内容的index.yaml文件在数据存储中创建索引:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8ada" class="kq jf hi km b fi kr ks l kt ku">indexes:</span><span id="6a09" class="kq jf hi km b fi kv ks l kt ku">- kind: Toy<br/>  ancestor: yes<br/>  properties:<br/>  - name: price</span></pre><p id="032c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用gcloud命令上传yaml文件:<code class="du lj lk ll km b">gcloud datastore indexes create path/to/index.yaml</code>您的索引应该显示在您的数据存储控制台中！等待索引过程完成，并重新运行查询，看看它现在工作！现在你有了:实体组、祖先、索引和宠物(！！)在数据存储中。编码快乐！</p></div></div>    
</body>
</html>