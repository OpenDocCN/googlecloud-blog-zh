<html>
<head>
<title>How Kubernetes Initializers work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes初始化器如何工作</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-kubernetes-initializers-work-22f6586e1589?source=collection_archive---------1-----------------------#2017-09-08">https://medium.com/google-cloud/how-kubernetes-initializers-work-22f6586e1589?source=collection_archive---------1-----------------------#2017-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c43d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我要指出Kubernetes起飞的一个原因，我可能会说是因为它的令人敬畏的社区。第二个原因是<a class="ae jd" href="https://kubernetes.io/docs/reference/" rel="noopener ugc nofollow" target="_blank"> Kubernetes API </a>的灵活性，以及在其上编写定制扩展或插件是多么容易。在本文中，我将深入探讨一个新概念:<strong class="ih hj">初始化器</strong>，这是一种在实际创建Kubernetes资源之前对其进行修改的动态可插拔方式。</p><p id="2d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始化器已经是Kubernetes 1.7中的alpha特性了。例如，我们在<a class="ae jd" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank"> Google容器引擎</a>使用初始化器来扩展Kubernetes特性库，你也可以通过实现新的初始化器来满足你的需求。</p><p id="b24b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，Kubernetes只有<a class="ae jd" href="https://kubernetes.io/docs/admin/admission-controllers/" rel="noopener ugc nofollow" target="_blank">许可控制器插件</a>在创建资源之前拦截它们。例如，您可以让一个许可插件强制所有容器映像来自一个特定的注册表，并防止其他映像被部署到pod中。有相当多的<a class="ae jd" href="https://kubernetes.io/docs/admin/admission-controllers/" rel="noopener ugc nofollow" target="_blank">准入控制器提供诸如强制限制、应用预创建检查以及为缺失字段设置默认值等功能。</a></p><p id="81fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准入控制器问题是:</p><ol class=""><li id="ff2e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">它们被编译成Kubernetes:如果你要找的东西不见了，你需要分叉Kubernetes，编写准入插件并自己保持一个分叉。</li><li id="f634" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">您需要启用每个准入插件，方法是将其名称传递给<a class="ae jd" href="https://kubernetes.io/docs/admin/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> kube-apiserver </a>的<code class="du js jt ju jv b">--admission-control</code>标志。在许多情况下，这意味着重新部署集群。</li><li id="7ccd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">一些托管群集提供程序可能不允许您自定义API服务器标志，因此您可能无法启用源代码中可用的所有准入控制器。</li></ol><p id="06e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/admission_control_extension.md" rel="noopener ugc nofollow" target="_blank">提出了动态/外部准入控制器</a>来解决这些问题。目前有两种类型的插件:初始化器和网络挂钩。初始化器类似于准入控制器插件，因为您可以在创建资源之前拦截它。它们不同于准入控制器插件，因为它们不是Kubernetes源代码树的一部分，也没有编译到源代码树中；你需要自己写一个控制器。</p><h1 id="65c1" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">你能用初始化器做什么？</h1><p id="b7d4" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当您在创建Kubernetes对象之前拦截它们时，可能性是无限的:您可以以任何您喜欢的方式改变对象，或者阻止对象被创建。</p><p id="ed9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是初始化器的一些想法，每个初始化器在集群中执行一个特定的策略:</p><ul class=""><li id="83b7" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kz jk jl jm bi translated">如果pod有端口80，或者有特定的注释，则将代理边车容器插入到pod中。</li><li id="fe80" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kz jk jl jm bi translated">自动将带有测试证书的卷插入到测试命名空间中的所有pod。</li><li id="19aa" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kz jk jl jm bi translated">如果密码少于20个字符(可能是密码)，请防止创建它。</li></ul><p id="f87c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不打算修改对象，只是为了读取对象而拦截，那么webhooks 可能是获得对象通知的一个更快、更精简的替代方法。一定要看看这个基于webhook的准入控制器的例子。</p><p id="9c19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我上面列出的一些功能，如注入边车容器或体积可以使用<a class="ae jd" href="https://kubernetes.io/docs/tasks/inject-data-application/podpreset/" rel="noopener ugc nofollow" target="_blank"> Pod预设</a>来实现，灵活性较差。如果Pod预设确实适用于您，您可能不需要费心开发初始化器。</p><h1 id="d5e4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">初始化剖析</h1><ol class=""><li id="f1ea" class="je jf hi ih b ii ku im kv iq la iu lb iy lc jc jj jk jl jm bi translated"><strong class="ih hj">配置哪些资源类型需要初始化:</strong><a class="ae jd" href="https://kubernetes.io/docs/admin/extensible-admission-controllers/#configure-initializers-on-the-fly" rel="noopener ugc nofollow" target="_blank">initializer configuration</a>对象让你配置哪些初始化器应该分配给哪些类型的资源。<br/>例如，你可以创建一个将“myproxy”初始化器添加到类型为<code class="du js jt ju jv b">apps/v1beta1.Deployment</code>和<code class="du js jt ju jv b">v1.DeamonSet</code>的对象中。您可以创建任意多的<code class="du js jt ju jv b">InitializerConfigurations</code>,它们适用于所有的名称空间。</li><li id="4cb4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj"> API服务器将为新资源分配初始化器:</strong>当您向API server提交部署对象时，它将更新部署的<code class="du js jt ju jv b">metadata.initalizers.pending</code>并在那里添加“myproxy”值。这个字段显示当前分配给资源的初始化器。<br/>(准确的说，不是apiserver添加了初始化器。有一个名为“初始化器”的准入控制器插件，它使得整个初始化过程成为可能。它是通过向kube-apiserver添加<code class="du js jt ju jv b">--admission-controller=Initializer</code>标志来实现的。)</li><li id="3a89" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">您将编写一个控制器来监视资源:</strong>您开发并部署到集群的这个定制控制器使用Watch API来监听新资源、捕获它们并进行所需的修改。</li><li id="e6d8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">等待轮到你修改资源:</strong>一旦你的控制器通过Watch API拦截了一个对象，它应该只修改在初始化列表的第一个元素上看到它的名字的对象(<code class="du js jt ju jv b">metadata.initializers.pending[0]</code>)。否则，这意味着轮到其他初始化器修改资源了，它现在应该跳过修改。</li><li id="2124" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">完成修改，让位于下一个初始化器。一旦您完成了对资源的修改，您的控制器应该从对象的<code class="du js jt ju jv b">metadata.initializers.pending</code>列表中删除它的名称，并将对象保存回API服务器。</li><li id="932f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">没有更多的初始化器，资源准备实现:</strong>当Kubernetes API服务器看到对象没有更多的待定初始化器时，它认为对象“已初始化”。现在Kubernetes调度程序和其他控制器可以看到完全初始化的对象并使用它们。</li></ol><p id="7a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在集群上同时运行多个初始化器。这些定制控制器中的每一个都将得到关于他们订阅观看的资源(例如，pod)的修改的通知，但是他们将等待轮到他们来修改对象，直到他们在列表中看到他们的名字。</p><h1 id="06c9" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">初始值设定项:在幕后</h1><p id="17b8" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">您可以开发和部署初始化器，而无需了解它们在Kubernetes API server中是如何实现的。让我更详细地讨论一下它是如何在Kubernetes API中实现的:</p><p id="03a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes社区在早期就已经开始考虑以钩子<a class="ae jd" href="https://github.com/kubernetes/kubernetes/issues/3585" rel="noopener ugc nofollow" target="_blank">的形式提供这样的扩展点。第一个</a><a class="ae jd" href="https://github.com/kubernetes/kubernetes/pull/17305" rel="noopener ugc nofollow" target="_blank">在这里提出</a>，这个特性看起来有点类似于它实际上是如何实现的。<a class="ae jd" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/admission_control_extension.md#initializers" rel="noopener ugc nofollow" target="_blank">后面的提案</a>阐明并解释了该功能的机制预期如何工作。如果你想了解它在幕后是如何运作的，一定要阅读链接的提议和<a class="ae jd" href="https://github.com/kubernetes/kubernetes/pull/36721" rel="noopener ugc nofollow" target="_blank">拉动请求</a>。</p><p id="4a55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，当一个Pod资源被提交给API并被分配了一个未决初始化器列表时，它实际上将不会被调度，直到初始化完成。Kubernetes调度器，调度器是另一个控制器，它监视API服务器中出现的pod，并将它们分配给一个节点(<a class="ae jd" href="https://jvns.ca/blog/2017/07/27/how-does-the-kubernetes-scheduler-work/" rel="noopener ugc nofollow" target="_blank">了解更多关于调度的信息</a>)。</p><p id="2635" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，为什么调度程序和其他控制器在这个对象初始化之前看不到它，即使这个对象保存在API服务器上(和etcd数据库中)并且对其他一些控制器(比如你的初始化器)是可见的？</p><p id="9f92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是一个名为<code class="du js jt ju jv b">includeUninitialized</code>的请求参数。该参数默认为false，因此API在类似WATCH或LIST的请求中对默认客户端(例如<code class="du js jt ju jv b">kubectl</code>)和控制器(例如调度程序)隐藏未初始化的对象。您开发的初始化器必须设置<code class="du js jt ju jv b">?includeUninitialized=true</code>查询参数来观察这些对象。</p><p id="d756" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始化器阻塞创建请求。当创建对象的请求提交给API服务器时，它不会立即返回，请求会阻塞，直到初始化完成。如果您正在使用kubectl，并且对象陷入未初始化状态，您会注意到<code class="du js jt ju jv b">kubectl</code>在30秒后超时。</p><h1 id="1336" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">优点和缺点</h1><p id="62f4" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><a class="ae jd" href="https://kubernetes.io/docs/admin/admission-controllers/" rel="noopener ugc nofollow" target="_blank">准入控制插件</a>编译成Kubernetes API服务器。要添加一个新的插件，您需要分叉Kubernetes源代码树，在其上开发您的插件并保持分叉。另一方面，<a class="ae jd" href="https://kubernetes.io/docs/admin/extensible-admission-controllers/#initializers" rel="noopener ugc nofollow" target="_blank">初始化器</a>是在Kubernetes源代码树之外开发的。您可以使用Kubernetes API客户端轻松开发一个。它们像任何其他工作负载一样在集群上运行，您需要担心的事情更少。</p><p id="53f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">初始化器非常灵活:</strong>一旦你在一个对象被实际创建之前就得到它，那就没有限制了。请注意，这种灵活性也可以让你很容易搬起石头砸自己的脚。你应该限制每个初始化器做一个任务，不要踩到对方的脚趾。</p><p id="ec17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">编写一个初始化器很容易:</strong>看看<a class="ae jd" href="https://github.com/kelseyhightower/kubernetes-initializer-tutorial" rel="noopener ugc nofollow" target="_blank">这个例子</a>由Kelsey Hightower编写，它基于一个注释向Pod添加了一个sidecar容器。它大约有200行Go代码，但是它很好地自动化了一项重要的任务。你现在就可以自己开发一个。但是如何开发一个产品级初始化器，并在产品中运行它呢？这可能会更有挑战性。</p><p id="9f79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始化器的正常运行时间很重要:当初始化器离线时，它仍然会被分配来初始化新的资源。这些资源将无限期地陷入“未初始化”状态，除非初始化器返回。这可能具有真实的现场含义:如果您有pods的初始化器，并且如果您的初始化器在扩展事件期间离线，则不会创建新的pods，这可能会导致自动扩展操作失败并导致中断。</p><p id="4d62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在还早:</strong>在撰写本文时，初始化器目前在Kubernetes v1.7中处于<em class="ld"> alpha </em>，而在v1.8中它的目标是beta(更正:现在是v1.9)。您需要在您的群集中启用alpha标志，以便从今天开始使用此功能。还要注意，我在本文中解释的许多东西可能不适用于该特性的稳定版本。</p><h1 id="8dd4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">开发你自己的初始化器</h1><p id="b4e9" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">最简单的入门方法是派生出Kelsey Hightower的初始化器示例,它是用Go编写的，根据注释的存在向部署对象添加一个sidecar容器。</p><p id="a343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://github.com/kelseyhightower/kubernetes-initializer-tutorial/blob/2645c93e05f281c251ae7d835c7bb93dfdded0b8/envoy-initializer/main.go" rel="noopener ugc nofollow" target="_blank">源代码</a>中，您应该注意一些事情:指定<code class="du js jt ju jv b">IncludeUninitialized=true</code>并以所有名称空间为目标的列表/观察函数、通知器及其重新同步周期、API对象如何被克隆/变异，以及如何使用补丁执行更新</p><p id="3ac0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发初始化器时要注意的事情:</p><ul class=""><li id="a3ec" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kz jk jl jm bi translated">确保你的初始化式不会出错。我之前提到过，你能做的最好的事情就是确保你有一个活性探测器，并对其进行监控/报警。如果你有所有pod的初始化器，这是特别需要的。</li><li id="e954" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kz jk jl jm bi translated">先有鸡还是先有蛋的问题:如果你有pods/deployment的初始化器，部署初始化器可能会阻塞，因为它不能初始化自己。您需要手动指定待定初始值设定项列表，以清空pod清单中的数组值(<code class="du js jt ju jv b">[ ]</code>)。</li><li id="911d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kz jk jl jm bi translated">初始化器是正常的工作负载，但是您应该将它部署到与正常工作负载不同的命名空间。内置的<code class="du js jt ju jv b">kube-system</code>名称空间可能是存放初始化器的好地方。</li><li id="520e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kz jk jl jm bi translated">初始化器可能会收到不完整的对象:例如，一个尚未被调度的Pod可能会丢失一些字段，比如“节点名”或“状态”。你应该用这个假设来测试初始化器。</li><li id="384f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kz jk jl jm bi translated">初始值设定项可能以不同的顺序应用:待定初始值设定项的列表可能每次都有不同的顺序，您的实现应该可以很好地处理这个问题。</li><li id="7934" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kz jk jl jm bi translated">确保你的初始化器快速处理对象。初始化会阻止创建资源的请求。</li></ul><h1 id="e1af" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">立即获取启用初始值设定项的集群</h1><p id="1da3" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在Initializers特性变得稳定之前(这使得它们在默认情况下被启用)，您可以通过运行以下命令从Google容器引擎获得alpha集群:</p><pre class="le lf lg lh fd li jv lj lk aw ll bi"><span id="96e5" class="lm jx hi jv b fi ln lo l lp lq">gcloud container clusters create my-cluster \<br/> --enable-kubernetes-alpha \<br/> --cluster-version 1.7.4</span></pre><p id="fe04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用这个集群来部署您的第一个初始化器。请注意，阿尔法集群将在30天后删除自己。</p><h1 id="1dd4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">进一步阅读</h1><p id="8abe" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">如果初始化器对您来说是一个有趣的话题，请查看下面链接的参考资料。初始化器可能是扩展Kubernetes API最实用和最简单的方法。他们非常灵活，我很想听听你会提出什么样的想法。</p><p id="eefb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">感谢</strong> <a class="ae jd" href="https://twitter.com/apbhatnagar" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">阿帕娜辛哈</strong> </a> <strong class="ih hj">和</strong> <a class="ae jd" href="https://github.com/caesarxuchao" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">许超</strong> </a> <strong class="ih hj">审阅本文草稿。</strong></p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="7d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">最初发表于</em><a class="ae jd" href="https://ahmet.im/blog/initializers/" rel="noopener ugc nofollow" target="_blank"><em class="ld">Ahmet . im</em></a><em class="ld">。如果你喜欢这篇文章，你可以在Twitter上关注我，通过电子邮件订阅我的博客(不超过一篇文章/月)。</em></p></div></div>    
</body>
</html>