<html>
<head>
<title>Managing Helm releases on GKE the GitOps way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以GitOps的方式管理GKE的Helm版本</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/managing-helm-releases-the-gitops-way-207a6ac6ff0e?source=collection_archive---------1-----------------------#2018-09-03">https://medium.com/google-cloud/managing-helm-releases-the-gitops-way-207a6ac6ff0e?source=collection_archive---------1-----------------------#2018-09-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="310e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GitOps是一种持续交付的方式，它通过使用Git作为声明性基础设施和工作负载的真实来源来工作。对于Kubernetes来说，这意味着使用<code class="du jd je jf jg b">git push</code>而不是<code class="du jd je jf jg b">kubectl create/apply</code>或<code class="du jd je jf jg b">helm install/upgrade</code>。</p><p id="0261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在传统的CICD管道中，CD是由持续集成工具驱动的实现扩展，用于将构建工件提升到生产中。在GitOps管道模型中，对生产的任何更改都必须在应用到集群之前在源代码控制中提交(最好通过pull请求)。这样，回滚和审计日志由Git提供。如果整个生产状态都在版本控制之下，并在单个Git存储库中描述，那么当灾难发生时，整个基础设施可以从该存储库中快速恢复。</p><p id="521d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解这种CD方法的好处以及GitOps和基础设施即代码工具之间的区别，请访问Weaveworks网站并阅读<a class="ae jh" href="https://www.weave.works/blog/what-is-gitops-really" rel="noopener ugc nofollow" target="_blank">什么是GitOps？</a>。</p><p id="6752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将GitOps pipeline模型应用到Kubernetes，您需要三样东西:</p><ol class=""><li id="ee10" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jn jo jp jq bi translated">一个Git存储库，其中包含YAML格式的工作负载定义、Helm图表和任何其他Kubernetes自定义资源，这些资源定义了您的集群所需的状态(我将此称为<em class="jr"> config </em>存储库)</li><li id="fe1e" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jn jo jp jq bi translated">一个容器注册表，CI系统在其中推送不可变的图像(没有<em class="jr">最新的</em>标签，使用<em class="jr">语义版本</em>或git <em class="jr">提交sha </em>)</li><li id="4cba" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jn jo jp jq bi translated">在集群中运行并执行双向同步的操作员:</li></ol><ul class=""><li id="5926" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jx jo jp jq bi translated">监视注册表中新的映像版本，并根据部署策略使用新的映像标记更新工作负载定义，并将更改提交到配置存储库</li><li id="d35c" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">观察配置存储库中的更改，并将它们应用到集群中</li></ul><p id="f893" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用谷歌云Kubernetes托管服务运行工作负载，GitHub托管配置报告，Docker Hub作为容器注册表，Weave Flux OSS作为GitOps Kubernetes运营商。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/e94ca0b60ac45f4b5091d3b48566e666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yMYqvePeycjJCDkz.png"/></div></div></figure><h1 id="33fc" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">先决条件</h1><p id="f5d9" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">您需要一个Kubernetes集群1.11或更新版本，一个GitHub帐户，本地安装git和kubectl。</p><p id="83e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用自制软件为macOS安装Helm v3和fluxctl:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="609f" class="lr kl hi jg b fi ls lt l lu lv">brew install helm fluxctl</span></pre><p id="f2c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Windows上，您可以使用Chocolatey:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="de62" class="lr kl hi jg b fi ls lt l lu lv">choco install kubernetes-helm fluxctl</span></pre><p id="1d9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Linux上，你可以从GitHub下载<a class="ae jh" href="https://github.com/helm/helm/releases" rel="noopener ugc nofollow" target="_blank"> helm </a>和<a class="ae jh" href="https://github.com/fluxcd/flux/releases" rel="noopener ugc nofollow" target="_blank"> fluxctl </a>二进制文件。</p><h1 id="93bb" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">安装Flux CD</h1><p id="0047" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">用<a class="ae jh" href="https://github.com/fluxcd/flux" rel="noopener ugc nofollow" target="_blank"> Flux </a>自动化Helm发布的第一步是用你的图表源代码创建一个Git库。</p><p id="f49b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GitHub上，派生这个库并在本地克隆它(用您的GitHub用户名替换<code class="du jd je jf jg b">fluxcd</code>):</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="caa2" class="lr kl hi jg b fi ls lt l lu lv">git clone <a class="ae jh" href="https://github.com/fluxcd/helm-operator-get-started" rel="noopener ugc nofollow" target="_blank">https://github.com/fluxcd/helm-operator-get-started</a><br/>cd helm-operator-get-started</span></pre><p id="6988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*如果您使用fork，在继续之前，请使用您的Docker Hub存储库和GitHub用户名(位于主分支的\ releases(dev/stg/prod)\ podinfo . YAML中)更新发布定义。</p><p id="ed58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将FluxCD存储库添加到Helm repos:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="afe0" class="lr kl hi jg b fi ls lt l lu lv">helm repo add fluxcd <a class="ae jh" href="https://charts.fluxcd.io" rel="noopener ugc nofollow" target="_blank">https://charts.fluxcd.io</a></span></pre><p id="2369" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建<code class="du jd je jf jg b">fluxcd</code>名称空间:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="cd11" class="lr kl hi jg b fi ls lt l lu lv">kubectl create ns fluxcd</span></pre><p id="c849" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过指定您的fork URL来安装Flux(用您的GitHub用户名替换<code class="du jd je jf jg b">fluxcd</code>):</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="0b65" class="lr kl hi jg b fi ls lt l lu lv">helm upgrade -i flux fluxcd/flux --wait \<br/>--namespace fluxcd \<br/>--set git.url=git@github.com:fluxcd/helm-operator-get-started</span></pre><p id="2c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装<code class="du jd je jf jg b">HelmRelease</code> Kubernetes自定义资源定义:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="80b9" class="lr kl hi jg b fi ls lt l lu lv">kubectl apply -f <a class="ae jh" href="https://raw.githubusercontent.com/fluxcd/helm-operator/master/deploy/flux-helm-release-crd.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/fluxcd/helm-operator/master/deploy/flux-helm-release-crd.yaml</a></span></pre><p id="438b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用<em class="jr">舵v3 </em>支架安装通量舵操作器；</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="57b5" class="lr kl hi jg b fi ls lt l lu lv">helm upgrade -i helm-operator fluxcd/helm-operator --wait \<br/>--namespace fluxcd \<br/>--set git.ssh.secretName=flux-git-deploy \<br/>--set helm.versions=v3</span></pre><p id="3a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flux Helm operator为Flux提供了一个扩展，可以自动发布舵图。一个图表发布通过一个名为HelmRelease的Kubernetes定制资源来描述。Flux守护进程将这些资源从git同步到集群，Flux Helm操作员确保Helm图表按照资源中指定的方式发布。</p><p id="4e5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，通量舵操作员与Kubernetes 1.11或更新版本一起工作。</p><p id="0fae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在启动时，Flux生成一个SSH密钥并记录公钥。使用以下命令查找公钥:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="0309" class="lr kl hi jg b fi ls lt l lu lv">fluxctl identity --k8s-fwd-ns fluxcd</span></pre><p id="afe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将集群状态与Git同步，您需要复制公钥，并在GitHub存储库上创建一个具有写访问权限的部署密钥。</p><p id="4374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开GitHub，导航到您的分支，转到<em class="jr">设置&gt;部署密钥</em>点击<em class="jr">添加部署密钥</em>，勾选<em class="jr">允许写访问</em>，粘贴Flux公钥并点击<em class="jr">添加密钥</em>。</p><h1 id="721c" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">GitOps管道示例</h1><p id="b955" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">配置回购具有以下结构:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="c62c" class="lr kl hi jg b fi ls lt l lu lv">├── charts<br/>│   └── podinfo<br/>│       ├── Chart.yaml<br/>│       ├── README.md<br/>│       ├── templates<br/>│       └── values.yaml<br/>├── hack<br/>│   ├── Dockerfile.ci<br/>│   └── ci-mock.sh<br/>├── namespaces<br/>│   ├── dev.yaml<br/>│   └── stg.yaml<br/>└── releases<br/>    ├── dev<br/>    │   └── podinfo.yaml<br/>    └── stg<br/>        └── podinfo.yaml</span></pre><p id="082d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用<a class="ae jh" href="https://github.com/stefanprodan/k8s-podinfo" rel="noopener ugc nofollow" target="_blank"> podinfo </a>来展示一个完整的CI/CD管道，包括促进环境之间的发布。</p><p id="c38b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我假设以下Git分支模型:</p><ul class=""><li id="94de" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jx jo jp jq bi translated">开发分支(功能就绪状态)</li><li id="e82b" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">stg分支(发布候选状态)</li><li id="fd2a" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">主分支机构(生产就绪状态)</li></ul><p id="79cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当PR在dev或stg分支中被合并时，将产生一个不可变的容器映像，如在<code class="du jd je jf jg b">repo/app:branch-commitsha</code>中。</p><p id="09ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jd je jf jg b">hack</code>目录中，您可以找到一个模拟dev和stg的CI流程的脚本。<code class="du jd je jf jg b">ci-mock.sh</code>脚本执行以下操作:</p><ul class=""><li id="1c69" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jx jo jp jq bi translated">从GitHub获取podinfo源代码</li><li id="b94c" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">生成随机字符串并修改代码</li><li id="6de8" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">生成随机Git提交短SHA</li><li id="b670" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">构建Docker映像，格式为:<code class="du jd je jf jg b">yourname/podinfo:branch-sha</code></li><li id="e022" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">将图像推送到Docker Hub</li></ul><p id="a16b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个对应于<code class="du jd je jf jg b">dev</code>分支的图像(用您的Docker Hub用户名替换<code class="du jd je jf jg b">stefanprodan</code>):</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="3951" class="lr kl hi jg b fi ls lt l lu lv">$ <strong class="jg hj">cd</strong> <strong class="jg hj">hack &amp;&amp; ./ci-mock.sh -r stefanprodan/podinfo -b dev</strong><br/><br/>Sending build context to Docker daemon  4.096kB<br/>Step 1/15 : FROM golang:1.10 as builder<br/>....<br/>Step 9/15 : FROM alpine:3.7<br/>....<br/>Step 12/15 : COPY --from=builder /go/src/github.com/stefanprodan/k8s-podinfo/podinfo .<br/>....<br/>Step 15/15 : CMD ["./podinfo"]<br/>....<br/>Successfully built 71bee4549fb2<br/>Successfully tagged stefanprodan/podinfo:dev-kb9lm91e<br/>The push refers to repository [docker.io/stefanprodan/podinfo]<br/>36ced78d2ca2: Pushed</span></pre><p id="fbb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="jr">图表</em>目录中有一个podinfo舵图。使用这个图表，我想用我刚刚发布到Docker Hub的图片在<code class="du jd je jf jg b">dev</code>命名空间中创建一个发布。我将创建一个<code class="du jd je jf jg b">HelmRelease</code>定义，而不是编辑图表源中的<code class="du jd je jf jg b">values.yaml</code>:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="d6f0" class="lr kl hi jg b fi ls lt l lu lv">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  name: podinfo-dev<br/>  namespace: dev<br/>  annotations:<br/>    fluxcd.io/automated: "true"<br/>    filter.fluxcd.io/chart-image: glob:dev-*<br/>spec:<br/>  releaseName: podinfo-dev<br/>  chart:<br/>    git: git@github.com:fluxcd/helm-operator-get-started<br/>    path: charts/podinfo<br/>    ref: master<br/>  values:<br/>    image: stefanprodan/podinfo:dev-kb9lm91e<br/>    replicaCount: 1</span></pre><p id="037b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通量舵释放场:</p><ul class=""><li id="982e" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jx jo jp jq bi translated"><code class="du jd je jf jg b">metadata.name</code>是强制性的，需要遵循Kubernetes命名惯例</li><li id="b605" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated"><code class="du jd je jf jg b">metadata.namespace</code>是可选的，决定了在哪里创建发布</li><li id="f7c3" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated"><code class="du jd je jf jg b">spec.releaseName</code>是可选的，如果没有提供，发布名称将是$namespace-$name</li><li id="ff92" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated"><code class="du jd je jf jg b">spec.chart.path</code>是包含图表的目录，相对于存储库根目录给出</li><li id="2827" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated"><code class="du jd je jf jg b">spec.values</code>是图表本身的默认参数值的用户定制</li></ul><p id="99d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HelmRelease <code class="du jd je jf jg b">spec.values</code>中指定的选项将覆盖图表源中<code class="du jd je jf jg b">values.yaml</code>中的选项。</p><p id="1b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过<code class="du jd je jf jg b">fluxcd.io/automated</code>注释，我指示Flux自动完成这个发布。当一个带有前缀<code class="du jd je jf jg b">dev</code>的新标签被推送到Docker Hub时，Flux将更新yaml文件中的image字段，并将更改提交和推送到Git，最后将更改应用到集群上。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lw"><img src="../Images/e3249c8086bed07e00811edf66368dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xvHW-gCQjEkoD5K3"/></div></div></figure><p id="bb5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du jd je jf jg b">podinfo-dev</code> HelmRelease对象在集群内部发生变化时，Kubernetes API将通知Flux Helm操作员，操作员将执行HelmRelease升级。</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="417b" class="lr kl hi jg b fi ls lt l lu lv">$ <strong class="jg hj">helm -n dev history podinfo-dev</strong><br/><br/>REVISION	STATUS    	CHART        	     <br/>1       	SUPERSEDED	podinfo-0.2.0	Install complete<br/>2       	DEPLOYED  	podinfo-0.2.0	Upgrade complete</span></pre><p id="db01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flux Helm操作符对HelmRelease集合中的更改做出反应，但也会检测图表源文件中的更改。如果我对podinfo图表做了更改，操作员会选择并运行升级。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lw"><img src="../Images/63987c719955a5f4811068ec0d03e89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0sR3HszMZkyF_ztR"/></div></div></figure><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="b6df" class="lr kl hi jg b fi ls lt l lu lv">$ <strong class="jg hj">helm -n dev history podinfo-dev</strong><br/><br/>REVISION        STATUS    	CHART        	DESCRIPTION     <br/>1	        SUPERSEDED	podinfo-0.2.0	Install complete<br/>2	        SUPERSEDED	podinfo-0.2.0	Upgrade complete<br/>3	        DEPLOYED  	podinfo-0.2.1	Upgrade complete</span></pre><p id="2b5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们假设我想将来自<code class="du jd je jf jg b">dev</code>分支的代码提升到一个更稳定的环境中，让其他人来测试它。我将通过将来自<code class="du jd je jf jg b">dev</code>的podinfo代码合并到<code class="du jd je jf jg b">stg</code>分支中来创建一个发布候选。CI会介入并发布新的形象:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="2cf2" class="lr kl hi jg b fi ls lt l lu lv">$ <strong class="jg hj">cd hack &amp;&amp; ./ci-mock.sh -r stefanprodan/podinfo -b stg<br/></strong><br/>Successfully tagged stefanprodan/podinfo:stg-9ij63o4c<br/>The push refers to repository [docker.io/stefanprodan/podinfo]<br/>8f21c3669055: Pushed</span></pre><p id="791d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设试运行环境有某种自动化负载测试，我想有一个不同于dev的配置:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="880b" class="lr kl hi jg b fi ls lt l lu lv">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  name: podinfo-rc<br/>  namespace: stg<br/>  annotations:<br/>    fluxcd.io/automated: "true"<br/>    filter.fluxcd.io/chart-image: glob:stg-*<br/>spec:<br/>  releaseName: podinfo-rc<br/>  chart:<br/>    git: git@github.com:fluxcd/helm-operator-get-started<br/>    path: charts/podinfo<br/>    ref: master<br/>  values:<br/>    image: stefanprodan/podinfo:stg-9ij63o4c<br/>    replicaCount: 2<br/>    hpa:<br/>      enabled: true<br/>      maxReplicas: 10<br/>      cpu: 50<br/>      memory: 128Mi</span></pre><p id="3eb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助Flux Helm版本，可以轻松管理每个环境的不同配置。在图表源中添加新选项时，请确保默认情况下它是关闭的，这样它就不会影响所有环境。</p><p id="79a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我想创建一个新环境，比方说进行修补程序测试，我会执行以下操作:</p><ul class=""><li id="c181" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jx jo jp jq bi translated">在<code class="du jd je jf jg b">namespaces/hotfix.yaml</code>中创建新的名称空间定义</li><li id="7489" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">创建一个目录<code class="du jd je jf jg b">releases/hotfix</code></li><li id="5d9e" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">创建一个名为<code class="du jd je jf jg b">podinfo-hotfix</code>的FluxHelmRelease</li><li id="2e34" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">将自动过滤器设置为<code class="du jd je jf jg b">glob:hotfix-*</code></li><li id="c233" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">让CI工具将映像从我的热修复分支发布到<code class="du jd je jf jg b">stefanprodan/podinfo:hotfix-sha</code></li></ul><h1 id="f06c" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使用sem版本的生产促销</h1><p id="c336" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">对于生产，我将使用<a class="ae jh" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>，而不是用Git commit来标记图像。</p><p id="42c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我想将代码从<code class="du jd je jf jg b">stg</code>分支提升到<code class="du jd je jf jg b">master</code>并发布产品。通过pull请求将<code class="du jd je jf jg b">stg</code>合并到<code class="du jd je jf jg b">master</code>之后，我会通过用版本<code class="du jd je jf jg b">0.4.10</code>标记<code class="du jd je jf jg b">master</code>来剪切一个发布。</p><p id="1591" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我推送git标记时，CI将以<code class="du jd je jf jg b">repo/app:git_tag</code>格式发布一个新图像:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="308f" class="lr kl hi jg b fi ls lt l lu lv">$ <strong class="jg hj">cd hack &amp;&amp; ./ci-mock.sh -r stefanprodan/podinfo -v 0.4.10</strong><br/><br/>Successfully built f176482168f8<br/>Successfully tagged stefanprodan/podinfo:0.4.10</span></pre><p id="7ad8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我想基于版本标签自动化生产部署，我会使用<code class="du jd je jf jg b">semver</code>过滤器而不是<code class="du jd je jf jg b">glob</code>:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="8545" class="lr kl hi jg b fi ls lt l lu lv">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  name: podinfo-prod<br/>  namespace: prod<br/>  annotations:<br/>    fluxcd.io/automated: "true"<br/>    filter.fluxcd.io/chart-image: semver:~0.4<br/>spec:<br/>  releaseName: podinfo-prod<br/>  chart:<br/>    git: git@github.com:fluxcd/helm-operator-get-started<br/>    path: charts/podinfo<br/>    ref: master<br/>  values:<br/>    image: stefanprodan/podinfo:0.4.10<br/>    replicaCount: 3</span></pre><p id="029d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在如果我发布一个新的补丁，比如说<code class="du jd je jf jg b">0.4.11</code>，Flux会自动部署它。</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="892f" class="lr kl hi jg b fi ls lt l lu lv">$ <strong class="jg hj">cd hack &amp;&amp; ./ci-mock.sh -r stefanprodan/podinfo -v 0.4.11</strong><br/><br/>Successfully tagged stefanprodan/podinfo:0.4.11</span></pre><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lw"><img src="../Images/0273a153494b983494bb67ca84f1bf09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*db9xkBQBHvltETNd"/></div></div></figure><h1 id="d829" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">管理Kubernetes的秘密</h1><p id="05c4" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">为了在公共Git回购中安全地存储秘密，你可以使用Bitnami <a class="ae jh" href="https://github.com/bitnami-labs/sealed-secrets" rel="noopener ugc nofollow" target="_blank">密封秘密控制器</a>并将你的Kubernetes秘密加密到密封秘密中。SealedSecret只能由群集中运行的控制器解密。</p><p id="8c5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jh" href="https://hub.helm.sh/charts/stable/sealed-secrets" rel="noopener ugc nofollow" target="_blank">头盔中心</a>可以得到密封秘密头盔图，所以我可以用头盔库代替git repo。这是机密控制器的发布:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="c074" class="lr kl hi jg b fi ls lt l lu lv">apiVersion: helm.fluxcd.io/v1<br/>kind: HelmRelease<br/>metadata:<br/>  name: sealed-secrets<br/>  namespace: adm<br/>spec:<br/>  releaseName: sealed-secrets<br/>  chart:<br/>    repository: https://kubernetes-charts.storage.googleapis.com/<br/>    name: sealed-secrets<br/>    version: 1.6.1</span></pre><p id="fc89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这个版本不是自动化的，因为这是一个关键的组件，我更喜欢手动更新它。</p><p id="ed14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装kubeseal CLI:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="3eaa" class="lr kl hi jg b fi ls lt l lu lv">brew install kubeseal</span></pre><p id="1493" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在启动时，密封秘密控制器生成RSA密钥并记录公钥。使用kubeseal，您可以将您的公钥保存为<code class="du jd je jf jg b">pub-cert.pem</code>，公钥可以安全地存储在Git中，并且可以用于加密机密，而无需直接访问Kubernetes集群:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="5c91" class="lr kl hi jg b fi ls lt l lu lv">kubeseal --fetch-cert \<br/>--controller-namespace=adm \<br/>--controller-name=sealed-secrets \<br/>&gt; pub-cert.pem</span></pre><p id="4f72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用kubectl在本地生成一个Kubernetes秘密，并使用kubeseal对其进行加密:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="47ea" class="lr kl hi jg b fi ls lt l lu lv">kubectl -n dev create secret generic basic-auth \<br/>--from-literal=user=admin \<br/>--from-literal=password=admin \<br/>--dry-run \<br/>-o json &gt; basic-auth.json<br/><br/>kubeseal --format=yaml --cert=pub-cert.pem &lt; basic-auth.json &gt; basic-auth.yaml</span></pre><p id="d498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将生成一个类型为<code class="du jd je jf jg b">SealedSecret</code>的定制资源，其中包含加密的凭证:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="1524" class="lr kl hi jg b fi ls lt l lu lv">apiVersion: bitnami.com/v1alpha1<br/>kind: SealedSecret<br/>metadata:<br/>  name: basic-auth<br/>  namespace: adm<br/>spec:<br/>  encryptedData:<br/>    password: AgAR5nzhX2TkJ.......<br/>    user: AgAQDO58WniIV3gTk.......</span></pre><p id="a6fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除<code class="du jd je jf jg b">basic-auth.json</code>文件，将<code class="du jd je jf jg b">pub-cert.pem</code>和<code class="du jd je jf jg b">basic-auth.yaml</code>推送到Git</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="5458" class="lr kl hi jg b fi ls lt l lu lv">rm basic-auth.json<br/>mv basic-auth.yaml /releases/dev/<br/><br/>git commit -a -m "Add basic auth credentials to dev namespace" &amp;&amp; git push</span></pre><p id="1619" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flux将在您的集群上应用密封秘密，然后密封秘密控制器将它解密为Kubernetes秘密。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lx"><img src="../Images/4b6e9c28b0e4d9fb17825e96584c96aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jvnr7pXQmjy-k2Rx"/></div></div></figure><p id="f4df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了准备灾难恢复，您应该使用以下内容备份sealed-secrets控制器私钥:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="f855" class="lr kl hi jg b fi ls lt l lu lv">kubectl get secret -n adm sealed-secrets-key -o yaml --export &gt; sealed-secrets-key.yaml</span></pre><p id="5863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在灾难后从备份中恢复，请替换新创建的密码并重新启动控制器:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="0038" class="lr kl hi jg b fi ls lt l lu lv">kubectl replace secret -n adm sealed-secrets-key -f sealed-secrets-key.yaml<br/>kubectl delete pod -n adm -l app=sealed-secrets</span></pre><h1 id="29fc" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">通量舵集成常见问题</h1><p id="45e2" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated"><strong class="ih hj">我已经从Git中删除了一个</strong> <code class="du jd je jf jg b"><strong class="ih hj">HelmRelease</strong></code> <strong class="ih hj">文件。为什么Helm release仍然在我的集群上运行？</strong></p><p id="88e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，Flux不删除资源，您可以使用以下命令启用Flux GC:</p><pre class="jz ka kb kc fd ln jg lo lp aw lq bi"><span id="f259" class="lr kl hi jg b fi ls lt l lu lv">--set syncGarbageCollection.enabled=true</span></pre><p id="3df6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我在每个环境中都有一个专用的Kubernetes集群，我希望对所有环境使用相同的Git repo。我该怎么做呢？</strong></p><p id="46dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个集群，在配置报告中创建一个Git分支。安装Flux时，使用<code class="du jd je jf jg b">--set git.branch=cluster-name</code>设置Git分支。</p><p id="2300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何监控CD管道和Flux管理的工作负载？</strong></p><p id="635b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jh" href="https://www.weave.works/product/cloud/" rel="noopener ugc nofollow" target="_blank"> Weave Cloud </a>是Weaveworks的SaaS产品，它通过以下方式扩展通量:</p><ul class=""><li id="e3c9" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jx jo jp jq bi translated">用于所有流量操作、审计跟踪和部署警报的用户界面</li><li id="adc7" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">集群的实时图，用于调试和分析其状态</li><li id="3a19" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">对集群的全面观察和洞察(托管Prometheus，拥有13个月的指标历史)</li><li id="e556" class="ji jj hi ih b ii js im jt iq ju iu jv iy jw jc jx jo jp jq bi translated">通过GitHub webhooks路由进行即时流量操作</li></ul></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="5e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jr">最初发表于</em><a class="ae jh" href="https://www.weave.works/blog/managing-helm-releases-the-gitops-way" rel="noopener ugc nofollow" target="_blank"><em class="jr">www . weave . works</em></a><em class="jr">。</em></p></div></div>    
</body>
</html>