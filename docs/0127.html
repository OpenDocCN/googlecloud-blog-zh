<html>
<head>
<title>How to invoke a trained TensorFlow model from Java programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Java程序中调用经过训练的张量流模型</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-invoke-a-trained-tensorflow-model-from-java-programs-27ed5f4f502d?source=collection_archive---------0-----------------------#2016-07-19">https://medium.com/google-cloud/how-to-invoke-a-trained-tensorflow-model-from-java-programs-27ed5f4f502d?source=collection_archive---------0-----------------------#2016-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="373e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建和训练TensorFlow机器学习模型的主要语言是Python。然而，许多企业服务器程序是用Java编写的。因此，您经常会遇到需要从Java程序调用用Python训练的Tensorflow模型的情况。</p><p id="05a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你在谷歌云平台上使用<a class="ae jd" href="https://cloud.google.com/ml/" rel="noopener ugc nofollow" target="_blank"> Cloud ML </a>引擎，这没有问题——在Cloud ML引擎中，预测是通过REST API调用进行的，因此你可以从任何编程语言进行预测。但是，如果您已经下载了TensorFlow模型，并希望离线进行预测，该怎么办？</p><p id="e09c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是如何使用Python中训练的Tensorflow模型在Java中进行预测。</p><blockquote class="je jf jg"><p id="4c21" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">注意:Tensorflow团队现在已经开始添加Java绑定。详见</strong><a class="ae jd" href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/java" rel="noopener ugc nofollow" target="_blank">https://github . com/tensor flow/tensor flow/tree/master/tensor flow/Java</a><strong class="ih hj">。先试试那个，如果对你不起作用，来这里...</strong></p></blockquote><h2 id="ea7a" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">用Python写出模型文件</h2><p id="0edc" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">首先要做的是以两种格式保存Python中的TensorFlow模型:(a)权重、偏差等。作为一个“saver_def”文件(b)图形本身作为一个protobuf文件。为了保持理智，您可能希望将图形保存为文本和二进制protobuf格式。您会发现通读文本格式有助于找到TensorFlow分配给未明确分配名称的节点的名称。从Python编写这三个文件的代码:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="6e6d" class="jl jm hi kq b fi ku kv l kw kx"># create a Saver object as normal in Python to save your variables<br/>saver = tf.train.Saver(...)</span><span id="e321" class="jl jm hi kq b fi ky kv l kw kx"># Use a saver_def to get the "magic" strings to restore<br/>saver_def = saver.as_saver_def()<br/>print saver_def.filename_tensor_name<br/>print saver_def.restore_op_name</span><span id="6253" class="jl jm hi kq b fi ky kv l kw kx"># write out 3 files<br/>saver.save(sess, 'trained_model.sd')<br/>tf.train.write_graph(sess.graph_def, '.', 'trained_model.proto', as_text=False)<br/>tf.train.write_graph(sess.graph_def, '.', 'trained_model.txt', as_text=True)</span></pre><p id="c70d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，save_def输出的两个神奇字符串是<em class="jh"> save/Const:0 </em>和<em class="jh">save/restore _ all</em>——所以这就是我的Java代码中看到的内容。如果您的代码不同，那么在编写Java代码时更改它们。</p><p id="ca64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">的。sd文件包含权重、偏差等。(图表中变量的实际值)。的。原型文件是一个二进制文件，包含您的计算图和。txt对应的文本版本。</p><h2 id="bec8" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">从Java调用Tensorflow C++</h2><p id="95e5" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">即使您可能已经在Python中使用Tensorflow向模型提供数据并对其进行训练，Tensorflow Python包实际上调用C++实现来执行实际工作。因此，我们可以使用Java本地接口(JNI)直接调用C++，并使用C++创建图形，从Java中恢复模型的权重和偏差。</p><p id="9054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不用手工编写所有的JNI调用，可以使用一个名为<a class="ae jd" href="https://github.com/bytedeco/javacpp-presets/" rel="noopener ugc nofollow" target="_blank"> JavaCpp </a>的开源库来完成这项工作。要使用JavaCpp，请将这个依赖项添加到Java Maven pom.xml中:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="f861" class="jl jm hi kq b fi ku kv l kw kx">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt;<br/>  &lt;artifactId&gt;tensorflow&lt;/artifactId&gt;<br/>  &lt;version&gt;0.9.0–1.2&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="f939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您正在使用一些其他的构建管理系统，将tensorflow <em class="jh">的Javacpp预置及其所有依赖项</em>添加到您的应用程序的类路径中。</p><h2 id="731e" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">用Java创建模型</h2><p id="267d" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">在您的Java代码中，读取proto文件来创建一个图形定义，如下所示(为了清楚起见，省略了导入):</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="3020" class="jl jm hi kq b fi ku kv l kw kx">final Session session = new Session(new SessionOptions());<br/>GraphDef def = new GraphDef();<br/>tensorflow.ReadBinaryProto(Env.Default(), <br/>                           "somedir/trained_model.proto", def);<br/>Status s = session.Create(def);<br/>if (!s.ok()) {<br/>    throw new RuntimeException(s.error_message().getString());<br/>}</span></pre><p id="99d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，使用Session::Run()从保存的模型文件中恢复权重和偏差。注意saver_def中的神奇字符串是如何使用的。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="7927" class="jl jm hi kq b fi ku kv l kw kx">// restore<br/>Tensor fn = new Tensor(tensorflow.DT_STRING, new TensorShape(1));<br/>StringArray a = fn.createStringArray();<br/>a.position(0).put(“somedir/trained_model.sd”); <br/>s = session.Run(new StringTensorPairVector(new String[]{“save/Const:0”}, new Tensor[]{fn}), new StringVector(), new StringVector(“save/restore_all”), new TensorVector());<br/>if (!s.ok()) {<br/>   throw new RuntimeException(s.error_message().getString());<br/>}</span></pre><h2 id="9949" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">用Java做预测</h2><p id="6dba" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">此时，您的模型已经准备好了。你现在可以用它来做预测。这类似于在Python中的做法——必须为所有占位符传入值，并计算输出节点。不同之处在于，您必须知道占位符和输出节点的实际<em class="jh">名称</em>。如果在Python中没有为这些节点指定唯一的名称，Tensorflow会为它们指定名称。您可以通过查看写出的trained_model.txt文件来找出它们是什么。或者，您可以返回到Python代码，为您记住的关键节点分配名称。在我的例子中，输入占位符被称为占位符；丢弃节点占位符称为Placeholder_2，输出节点称为Sigmoid。您将在下面的Session::Run()调用中看到这些引用。</p><p id="bfe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，神经网络使用5个预测变量。假设我有一组输入，这些输入是我的神经网络模型的预测器，并希望对2组这样的输入进行预测，我的输入是一个2×5矩阵。我的NN只有一个输出，所以对于2组输入，输出张量是一个2x1矩阵。丢弃节点的硬编码输入为1.0(在预测中，我们保留所有节点—丢弃概率仅用于训练)。所以，我有:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="3a89" class="jl jm hi kq b fi ku kv l kw kx">// try to predict for two (2) sets of inputs.<br/>Tensor inputs = new Tensor(<br/>         tensorflow.DT_FLOAT, new TensorShape(2,5));<br/>FloatBuffer x = inputs.createBuffer();<br/>x.put(new float[]{-6.0f,22.0f,383.0f,27.781754111198122f,-6.5f});<br/>x.put(new float[]{66.0f,22.0f,2422.0f,45.72160947712418f,0.4f});</span><span id="c360" class="jl jm hi kq b fi ky kv l kw kx">Tensor keepall = new Tensor(<br/>        tensorflow.DT_FLOAT, new TensorShape(2,1));<br/>((FloatBuffer)keepall.createBuffer()).put(new float[]{1f, 1f});</span><span id="8d4a" class="jl jm hi kq b fi ky kv l kw kx">TensorVector outputs = new TensorVector();</span><span id="2822" class="jl jm hi kq b fi ky kv l kw kx">// to predict each time, pass in values for placeholders<br/>outputs.resize(0);<br/>s = session.Run(new StringTensorPairVector(new String[] {“Placeholder”, “Placeholder_2”}, new Tensor[] {inputs, keepall}),<br/> new StringVector(“Sigmoid”), new StringVector(), outputs);<br/>if (!s.ok()) {<br/>   throw new RuntimeException(s.error_message().getString());<br/>}</span><span id="b1f9" class="jl jm hi kq b fi ky kv l kw kx">// this is how you get back the predicted value from outputs<br/>FloatBuffer output = outputs.get(0).createBuffer();<br/>for (int k=0; k &lt; output.limit(); ++k){<br/>   System.out.println(“prediction=” + output.get(k));<br/>}</span></pre><p id="e970" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样——你现在使用Java来实现你的预测。有几个步骤，但是当一个人混合3种编程语言(Python、C++和Java)时，这是预料之中的。但重要的是，这是可以做到的，而且相对简单。</p><p id="1f23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，这样做并没有利用硬件加速和分布的优势。如果你想实时以非常高的速度进行预测，你应该考虑使用云ML引擎。</p></div></div>    
</body>
</html>