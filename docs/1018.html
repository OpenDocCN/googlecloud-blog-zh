<html>
<head>
<title>Google Cloud KMS &amp; Tink</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云KMS &amp;叮当</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-kms-tink-1e106156bb4e?source=collection_archive---------0-----------------------#2019-05-31">https://medium.com/google-cloud/google-cloud-kms-tink-1e106156bb4e?source=collection_archive---------0-----------------------#2019-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c263" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">谷歌OOS聚宝盆历险记</h2></div><p id="8a90" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">披露:我是一名谷歌员工。</p><p id="fbe8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说，偶然发现谷歌OSS珠宝并不罕见。通常，我会使用一个Google OSS项目，而它会使用另一个我不熟悉的Google OSS项目。我想知道人们是如何发现这些有用的项目的。</p><p id="c8b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给使用其他[Google] OSS项目的[Google] OSS开发者的建议是:宣传里面的东西，以帮助宣传你的依赖性。</p><p id="4ae9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，Tink…是SDK。我们的目标是通过一个简单的、经过安全审查的SDK，让开发人员的生活更轻松，从而更好地开发使用加密的代码。它还集成了谷歌云KMS(用于加密|解密检查签名是否也在诉讼表上)。</p><h2 id="7e45" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">准备</h2><p id="fbcf" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">设置您的环境:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0fd7" class="ju jv hi kz b fi ld le l lf lg">WORKDIR=[[YOUR-WORKDIR]]</span><span id="f040" class="ju jv hi kz b fi lh le l lf lg">GOPATH=${WORKDIR}/go<br/>mkdir -p ${GOPATH} &amp;&amp; cd ${WORKDIR}</span><span id="d865" class="ju jv hi kz b fi lh le l lf lg">PATH=${GOPATH}/bin:${PATH}</span></pre><p id="8958" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">定义变量:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="595e" class="ju jv hi kz b fi ld le l lf lg">PROJECT=[[YOUR-PROJECT]]<br/>LOCATION=[[YOUR-LOCATION]] # Perhaps "us-west1"<br/>KEYRING=[[YOUR-KEYRING]]   # Perhaps "keyring-01"</span></pre><p id="9458" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">启用云KMS</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9487" class="ju jv hi kz b fi ld le l lf lg">gcloud services enable cloudkms.googleapis.com \<br/>--project=${PROJECT}</span><span id="d5e9" class="ju jv hi kz b fi lh le l lf lg">gcloud kms keyrings create ${KEYRING} \<br/>--location=${LOCATION} \<br/>--project=${PROJECT}</span></pre><h2 id="f4d1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">叮当云KMS</h2><p id="cba3" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">下面是一个使用Google的Golang " <a class="ae jt" href="https://github.com/google/tink/blob/master/docs/GOLANG-HOWTO.md#envelope-encryption" rel="noopener ugc nofollow" target="_blank">信封加密</a>"示例的简单演示。该脚本创建一个对称加密密钥(<code class="du li lj lk kz b">${KEY}</code>)，并将其添加到您之前创建的密匙环(<code class="du li lj lk kz b">${KEYRING}</code>)。然后，它创建一个服务帐户(<code class="du li lj lk kz b">${ROBOT}</code>)和一个服务帐户密钥(存储在<code class="du li lj lk kz b">${FILE}</code>)。一个<code class="du li lj lk kz b">cloudkms.cryptoKeyEncrypterDecrypter</code>的角色被添加到云KMS键(不是添加到项目，只是云KMS键！):</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="26b6" class="ju jv hi kz b fi ld le l lf lg">KEY=[[YOUR-KEY]]              # Perhaps "tink-cloudkms"<br/>ROBOT=[[YOUR-SERVICE-ACCOUNT] # Perhaps "tink-cloudkms"<br/>FILE=${WORKDIR}/${ROBOT}.json</span><span id="9817" class="ju jv hi kz b fi lh le l lf lg">gcloud kms keys create ${KEY} \<br/>--purpose=encryption \<br/>--keyring=${KEYRING} \<br/>--location=${LOCATION} \<br/>--project=${PROJECT}</span><span id="fbb9" class="ju jv hi kz b fi lh le l lf lg">gcloud iam service-accounts create $ROBOT \<br/>--display-name=$ROBOT \<br/>--project=$PROJECT</span><span id="a6b4" class="ju jv hi kz b fi lh le l lf lg">gcloud iam service-accounts keys create ${FILE} \<br/>--iam-account=${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--project=$PROJECT</span><span id="be36" class="ju jv hi kz b fi lh le l lf lg"><strong class="kz hj">gcloud kms keys add-iam-policy-binding</strong> ${KEY} \<br/>--location=${LOCATION} \<br/>--keyring=${KEYRING} \<br/>--member=serviceAccount:${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--role=roles/<strong class="kz hj">cloudkms.cryptoKeyEncrypterDecrypter</strong> \<br/>--project=$PROJECT</span></pre><p id="a09b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个IAM角色足以让我们的代码获得密钥，加密消息，然后使用相同的密钥(对称)解码消息。强有力的是，即使是这个有限的角色也只允许在这个键上使用(<code class="du li lj lk kz b">${KEY}</code>)。以下是来自谷歌Tink文档的Golang大部分内容:</p><figure class="ku kv kw kx fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="2230" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以运行代码:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="4c10" class="ju jv hi kz b fi ld le l lf lg">GOOGLE_APPLICATION_CREDENTIALS=${FILE} \<br/>go run main.go \<br/>--project=${PROJECT} \<br/>--location=${LOCATION} \<br/>--keyring=${KEYRING} \<br/>--key=${KEY}</span></pre><blockquote class="lo lp lq"><p id="dc06" class="ix iy lr iz b ja jb ij jc jd je im jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">N <strong class="iz hj"> B </strong>我们利用应用程序默认凭证通过环境将服务帐户密钥传递给代码(<code class="du li lj lk kz b">GOOGLE_APPLICATION_CREDENTIALS</code>)。</p></blockquote><p id="ae4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该得到类似于以下内容的内容:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="89a7" class="ju jv hi kz b fi ld le l lf lg">Cipher text: <br/>ASb80OCm...uGGT09qA==<br/>Plain text: manifest</span></pre><h2 id="7b15" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">纯云KMS</h2><p id="f65c" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我的意图是使用Tink进行签名，但是——IIUC——SDK目前不支持使用云KMS进行签名。因此，相反，我使用谷歌的云KMS样本来创建并验证签名。</p><p id="2768" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，我们需要在密钥创建过程中提供更多的细节，为了简化工作，我们将使用单个服务帐户对消息进行签名和验证。实际上，签名者和验证者可能是不同的实体。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6c2f" class="ju jv hi kz b fi ld le l lf lg">KEY=[[YOUR-KEY]]              # Perhaps "pure-cloudkms"<br/>ROBOT=[[YOUR-SERVICE-ACCOUNT] # Perhaps "pure-cloudkms"<br/>FILE=${WORKDIR}/${ROBOT}.json</span><span id="7544" class="ju jv hi kz b fi lh le l lf lg"><strong class="kz hj">PURPOSE=asymmetric-signing<br/>ALGORITHM=EC_SIGN_P256_SHA256<br/>PROTECTION=software</strong></span><span id="c9cb" class="ju jv hi kz b fi lh le l lf lg">gcloud alpha kms keys create ${KEY} \<br/><strong class="kz hj">--purpose=${PURPOSE}</strong> \<br/><strong class="kz hj">--default-algorithm=${ALGORITHM}</strong> \<br/><strong class="kz hj">--protection-level=${PROTECTION}</strong> \<br/>--keyring=${KEYRING} \<br/>--location=${LOCATION} \<br/>--project=${PROJECT}</span><span id="79ca" class="ju jv hi kz b fi lh le l lf lg">gcloud iam service-accounts create $ROBOT \<br/>--display-name=$ROBOT \<br/>--project=$PROJECT</span><span id="e86d" class="ju jv hi kz b fi lh le l lf lg">gcloud iam service-accounts keys create ${FILE} \<br/>--iam-account=${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--project=$PROJECT</span><span id="4df2" class="ju jv hi kz b fi lh le l lf lg">gcloud kms keys add-iam-policy-binding ${KEY} \<br/>--location=${LOCATION} \<br/>--keyring=${KEYRING} \<br/>--member=serviceAccount:${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--role=<strong class="kz hj">roles/cloudkms.signer</strong> \<br/>--project=${PROJECT}</span><span id="8372" class="ju jv hi kz b fi lh le l lf lg">gcloud kms keys add-iam-policy-binding ${KEY} \<br/>--location=${LOCATION} \<br/>--keyring=${KEYRING} \<br/>--member=serviceAccount:${ROBOT}@${PROJECT}.iam.gserviceaccount.com \<br/>--role=<strong class="kz hj">roles/cloudkms.signerVerifier</strong> \<br/>--project=${PROJECT}</span></pre><p id="8b06" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是Golang，大部分原样来自谷歌的云KMS文档:</p><figure class="ku kv kw kx fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="9806" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该代码通过首先对消息进行哈希运算，然后使用签名者的私有(！idspnonenote)来创建签名。)密钥进行加密(！)它。验证者访问签名者的公共(！)密钥并使用它来解密(！idspninfopath _ NV)。)的签名。它将结果与哈希(共享)消息进行比较，以确认只有能够访问私钥的人才能创建该消息。</p><h2 id="2cee" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论</h2><p id="c4a8" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">如果Tink团队为我提供了如何使用云KMS签名的指导，我会更新这篇帖子。在我写纯云KMS客户端的时候，我意识到我真的应该把签名者和验证者分成两个服务帐户，这样更现实。</p><p id="0c35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这篇短文能鼓励你在将来的工作中考虑Tink，包括加密库。Tink也支持AWS的密钥管理解决方案，一个开发者已经提出为Azure的服务编写集成。</p><p id="6e81" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>