<html>
<head>
<title>Efficient aggregation and roll-ups with BigQuery HyperLogLog++ functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BigQuery HyperLogLog++函数进行高效聚合和汇总</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/efficient-aggregation-roll-ups-with-bigquery-hyperloglog-functions-80d408a046f4?source=collection_archive---------0-----------------------#2019-07-29">https://medium.com/google-cloud/efficient-aggregation-roll-ups-with-bigquery-hyperloglog-functions-80d408a046f4?source=collection_archive---------0-----------------------#2019-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">增量处理的概念会对数据分析管道的设计产生重大影响。增量处理大量数据带来了资源效率、更快的处理时间和固有的降低的处理成本。然而，并不是所有的分析函数都具有增量性质。一个常见的例子是<strong class="ih hj"> count distinct </strong>函数。在这篇文章中，我想谈谈使用BigQuery的HyperLogLog++函数的增量计数非重复处理，以及它们如何提供快速、可伸缩的增量处理属性。</p><p id="6c23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我一直着迷于代数概念如何极大地影响我们处理大规模数据的方式。例如，交换和结合性质一直是有趣的研究。简而言之，这些特性允许我们并行和增量地执行计算。例如，SUM()是一个交换和关联函数，我可以在不同的位置(线程、虚拟机等)分别计算1 + 2 + 3，结果总是6。例如，我可以在一个虚拟机中计算(2+3)并将结果添加到另一个虚拟机中的(1)，结果与在一个虚拟机中计算(1+2)并将结果添加到另一个虚拟机中的3是相同的。</p><p id="d224" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了并行处理之外，交换和关联函数允许我们逐步应用更高级的函数，如SUM()和COUNT()。让我在下面的例子中演示一下增量处理的强大功能。我还将提供一个例子，说明增量处理不是一个选项，以及BigQuery的HyperLogLog++如何提供帮助。为了让读者能够理解这个例子，我使用了一个<a class="ae jd" href="https://cloud.google.com/bigquery/public-data/" rel="noopener ugc nofollow" target="_blank"> BigQuery公共数据集</a>:big query-samples . Wikipedia _ benchmark。Wiki100B:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/3c30f9b24b635312644890a5e0e2052b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*17KR4VKEeCNEen2m"/></div></div></figure><p id="5c86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们被要求使用下面的查询来计算Wikimedia数据集的总日浏览量。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="ec0c" class="jv jw hi jr b fi jx jy l jz ka">SELECT year,month,day, SUM(views) day_total_views FROM `bigquery-samples.wikipedia_benchmark.Wiki100B` GROUP BY 1,2,3 ORDER BY 1,2,3</span></pre><p id="dd01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kb"><img src="../Images/068d83853e8cd46e0328b3155abc93aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/0*Ib3RZVGg0v9Xx23v"/></div></figure><p id="a6df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">执行时间:~37秒</em></p><p id="975a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，运行该查询需要大约37秒才能完成，我们希望它能更快。我们希望我们的报告是交互式的，响应时间为个位数秒。为了加快查询速度，我们将创建一个类似于以下示例的预聚合表，并在预聚合表上编写查询:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="a5de" class="jv jw hi jr b fi jx jy l jz ka">CREATE OR REPLACE TABLE `your_project.demo.wiki_daily_agg` AS SELECT year,month,day, SUM(views) daily_total_views FROM `bigquery-samples.wikipedia_benchmark.Wiki100B` GROUP BY 1,2,3</span><span id="f90b" class="jv jw hi jr b fi kd jy l jz ka">SELECT year, month, day, daily_total_views FROM `your_project.demo.wiki_daily_agg` ORDER BY 1,2,3</span></pre><p id="cbb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ke"><img src="../Images/a7bdd74733c03196b3148053d0b9c450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*EqZB-muHIkp3pM_f"/></div></figure><p id="cca3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">执行时间:~1秒</em></p><p id="9645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法将我们的查询时间减少到大约1秒钟(创建预聚合表需要大约30秒钟，可以使用BigQuery <a class="ae jd" href="https://cloud.google.com/bigquery/docs/scheduling-queries" rel="noopener ugc nofollow" target="_blank">计划查询</a>或<a class="ae jd" href="https://cloud.google.com/composer/" rel="noopener ugc nofollow" target="_blank"> Cloud Composer </a>自动完成)</p><p id="d96f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们想查看每月的总浏览量，而不是每天的总浏览量，会怎么样呢？有趣的是，同一个预聚合表可以回答不同的聚合问题。例如，要生成每月总视图，我们只需在预聚合表上运行以下查询:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="2d17" class="jv jw hi jr b fi jx jy l jz ka">SELECT year, month, SUM(daily_total_views) month_total_count FROM `your_project.demo.wiki_daily_agg`GROUP BY 1,2 ORDER BY 1,2</span></pre><p id="ce3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kf"><img src="../Images/cac8e7d145aad75b259977824c160d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*iiI3oRLySE3ThGrN"/></div></div></figure><p id="9f2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">执行时间:~1秒</em></p><p id="9d70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们能够从预聚集的表中计算每月的视图数的是SUM()的增量处理能力，这要归功于它的关联和交换属性。可以想象，这是一个强大的概念，可以应用于许多分析查询。但是，并非所有函数都提供增量处理特性。例如，如果我们想找到每日不同标题的数量，该怎么办？为了实现这一点，我们可以调整预聚合表，如下所示:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="fbb4" class="jv jw hi jr b fi jx jy l jz ka">CREATE OR REPLACE TABLE `your_project.demo.wiki_daily_agg_distinct` AS SELECT year,month,day, SUM(views) daily_total_views,<strong class="jr hj"> COUNT(DISTINCT title)</strong> unique_titles FROM `bigquery-samples.wikipedia_benchmark.Wiki100B` GROUP BY 1,2,3</span><span id="0736" class="jv jw hi jr b fi kd jy l jz ka">SELECT year, month, day, daily_total_views, unique_titles FROM `your_project.demo.wiki_daily_agg_distinct`ORDER BY 1,2,3</span></pre><p id="8fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kg"><img src="../Images/3e3ae1a12caa20e3687c99fc432e5795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/0*hhVmZGCEyu1NRrxV"/></div></figure><p id="5157" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">执行时间:~10分钟</em></p><p id="adae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然该查询生成了每日不同的标题，但它引入了两个挑战:</p><ol class=""><li id="c0b8" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">通过添加DISTINCT子句，生成预聚合表需要相当长的时间(大约10分钟)，因为DISTINCT函数需要更多的内存资源。</li><li id="6505" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">我们不再能够使用相同的预汇总表格来计算每月的唯一书目。换句话说，以下查询将不起作用(该查询将运行，但将显示不正确的结果):</li></ol><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="b771" class="jv jw hi jr b fi jx jy l jz ka">SELECT year,month, SUM(unique_titles) FROM `your_project.demo.wiki_daily_agg_distinct` GROUP BY 1,2</span></pre><p id="e6b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与SUM()和COUNT()不同，DISTINCT()函数没有增量属性，因此我们不能对每天的DISTINCT结果进行增量求和来获得每月的数字。为了计算每月不同的标题，我们必须在整个数据集上运行我们的查询。这在性能和成本方面都是低效的。具体来说，在整个数据集上运行DISTINCT需要与数据集的基数成比例的内存。当处理大型数据集时，这可能会导致更高的内存使用率。对于BigQuery，这可能意味着需要更多的槽来计算结果。除了更大数量的槽之外，我们还需要扫描整个表，这导致了更高的查询成本。</p><p id="2ff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions" rel="noopener ugc nofollow" target="_blank"> BigQuery的HyperLogLog++函数</a>发挥作用的地方。在这篇文章中，我们不需要深入了解HLL函数是如何工作的，我们只需要知道HLL是一种概率计数算法，它使用较少的内存，但只能提供一个近似的答案。由于内存占用更小，不同值的计算速度更快。HLL算法的另一个巨大优势是它的增量属性，允许我们递增地添加/合并两个单独的值，就像上面的SUM()例子一样。</p><p id="feb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将HLL应用到上面的场景中:</p><p id="78e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将创建一个类似的预聚合表，但这次我们将使用BigQuery的HLL计数。INIT()函数。这个函数创建了一个输出，通常被称为HLL草图，一个二进制输出，记录我们不同的值。</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="3886" class="jv jw hi jr b fi jx jy l jz ka">CREATE OR REPLACE TABLE `your_project.demo.wiki_daily_agg_hll` AS SELECT year,month,day, SUM(views) daily_total_views, HLL_COUNT.INIT(title) unique_titles_sketch FROM `bigquery-samples.wikipedia_benchmark.Wiki100B` GROUP BY 1,2,3</span></pre><p id="d025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">执行时间:~ 2分钟</em></p><p id="0e85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了获得给定一天中不同标题的近似值，我们将使用HLL计数。EXTRACT()函数获取标量值:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="8c9c" class="jv jw hi jr b fi jx jy l jz ka">SELECT year,month,day,daily_total_views, HLL_COUNT.EXTRACT(unique_titles_sketch) unique_titles_apporx FROM `your_project.demo.wiki_daily_agg_hll` ORDER BY 1,2,3</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kv"><img src="../Images/697ed2c2902548d11823364b7fac9d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*01Xex0dqJYVMrGHL"/></div></div></figure><p id="190b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">执行时间:~ 2秒</em></p><p id="b24c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想得到每月不同标题的数量呢？我们可以简单地使用HLL计数添加每日HLL素描。MERGE()函数:</p><pre class="jf jg jh ji fd jq jr js jt aw ju bi"><span id="e218" class="jv jw hi jr b fi jx jy l jz ka">SELECT year,month, HLL_COUNT.MERGE(unique_titles_sketch) unique_titles_approx FROM `your_project.demo.wiki_daily_agg_hll` GROUP BY 1,2 ORDER BY 1,2</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kw"><img src="../Images/d5d6ba79236d33087ffed00eaada809d.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*6dy7nepFgqbAkJzF"/></div></figure><p id="425d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">执行时间:~ 2秒</em></p><p id="12cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用BigQuery的HLL函数，我们能够实现两件事:</p><ol class=""><li id="1c60" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">在预聚集表的查询执行方面有更好的查询性能(大约10分钟<strong class="ih hj">分钟</strong>到大约2分钟<strong class="ih hj">分钟</strong>)</li><li id="e89e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">HLL函数的增量处理特性避免了数据的重复处理，降低了查询的成本</li></ol><p id="2f42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要记住的一点是，HLL是一个概率函数。换句话说，我们使用上述HLL函数的不同视图的结果并不是100%准确的。默认情况下，在99%的置信区间内，BigQuery HLL函数的精度为0.86%(参见此处的表格<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions" rel="noopener ugc nofollow" target="_blank">)。如果您想要更高的精确度，可以通过向HLL计数传递一个更高精度的数字来降低错误率。INIT()函数。例如:HLL伯爵。INIT(title，20)在99%的置信区间将有0.20%的误差。</a></p><p id="681b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，超对数函数是计算给定数据集中不同值的更具性能和成本效益的方法。性能和成本优势源于内存占用的减少以及HLL函数的增量特性。因此，如果您的用例涉及到寻找不同的值，并且可以容忍小程度的不准确性，那么请给出</p></div></div>    
</body>
</html>