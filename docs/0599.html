<html>
<head>
<title>Event Sourcing with Lagom on GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP Lagom的活动采购</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/event-sourcing-with-lagom-on-gcp-95f94a282fbe?source=collection_archive---------1-----------------------#2018-05-09">https://medium.com/google-cloud/event-sourcing-with-lagom-on-gcp-95f94a282fbe?source=collection_archive---------1-----------------------#2018-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d1cc3bbafcd9bde61f53f6dcc11b0cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cz0kqszPNklpDPCoHthutg.jpeg"/></div></div></figure><div class=""/><p id="7aea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.lightbend.com/lagom-framework" rel="noopener ugc nofollow" target="_blank"> Lagom </a>是light bend(Scala，Akka，Play more的创造者)做的(非常)自以为是的微服务框架。Lagom建立在Akka和Play的基础上，通过一个令人惊叹的引擎为其增压，以提供出色的性能。对于那些还不知道Akka或Play的人，我强烈建议去搜索它，并进一步了解它。我认为非常有用和可靠的两个框架。</p><p id="c955" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Lagom帮助您构建反应式系统，而不仅仅是微服务，提供开箱即用的弹性和复原力。构建反应式系统可能很难，但Lagom将复杂性抽象化了。Akka和Play完成了繁重的工作，因此您可以专注于更简单的事件驱动编程模型，同时受益于底层的消息驱动系统。</p><h2 id="21d9" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">活动采购</h2><p id="6ea7" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们过去对应用程序状态建模的范式转变。通常当一些东西改变状态时，我们更新它并把它保存回数据库。在事件源中，不是存储状态，而是必须存储操纵应用程序状态的事件(显然……)。使用这个事件日志，我们可以在以后需要时重建我们的状态。在服务之间共享事件、保持一切不变以及随时改变数据模型也变得更加容易。</p><p id="72f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://martinfowler.com/eaaDev/EventSourcing.html" rel="noopener ugc nofollow" target="_blank">如果你想进一步阅读</a>，马丁·福勒有一个很好的解释。</p><h2 id="b358" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">CQRS(命令查询责任分离)</h2><p id="6fdb" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">核心概念是解耦写模型和读模型。通常我们有一个用于所有事情的模型，但是在CQRS我们使用两个不同的模型，一个用于插入或更新数据，另一个用于查询。对于某些情况，它可能非常有价值，而对于其他情况，它可能是总开销。以我的经验来看，当你的系统进化时，你最终会做某种CQRS。</p><p id="dabd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒又一次给出了惊人的解释</a>。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="e54e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Lagom推广了这两个概念，并使建立一个活动采购和CQRS系统变得非常简单。每个服务的核心都有对命令做出反应的实体。每个命令持续一个或多个事件，并且每个事件导致实体的状态改变。我们通常使用HTTP调用或某种消息队列来与这些实体进行交互并向其发送命令。要查看Lagom实体的运行情况:</p><div class="hh hi ez fb hj kw"><a href="https://github.com/lagom/online-auction-scala/blob/master/item-impl/src/main/scala/com/example/auction/item/impl/ItemEntity.scala" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab dw"><div class="ky ab kz cl cj la"><h2 class="bd hu fi z dy lb ea eb lc ed ef hs bi translated">lagom/在线拍卖-scala</h2><div class="ld l"><h3 class="bd b fi z dy lb ea eb lc ed ef dx translated">在GitHub上创建一个帐户，为在线拍卖-scala开发做出贡献。</h3></div><div class="le l"><p class="bd b fp z dy lb ea eb lc ed ef dx translated">github.com</p></div></div></div></a></div><p id="3080" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi lf translated">但是这和GCP有什么关系呢？直到不久前，它与GCP没有任何关系，但最近实现了两个重要的里程碑。</p><p id="0aa5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个是发布了<a class="ae jo" href="https://developer.lightbend.com/docs/lightbend-orchestration-kubernetes/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Lightbend Orchestration </a>，它简化并自动化了基于Lightbend的系统的部署，Lagom幸运地是其中之一。作为GCP的客户，你可能喜欢Kubernetes，幸运的是，Kubernetes是Lightbend Orchestration的一等公民。它包括基于Kubernetes的DNS机制的开箱即用的服务发现，Akka集群的自动引导，它甚至生成将您的服务部署到Kubernetes所需的所有YAMLs。到目前为止，我们必须手动做所有的事情，让我们说这不是在公园散步。</p><p id="3edd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个里程碑是支持Google Pub/Sub作为Lagom服务的消息代理，而不是Kafka(发现由我而不是Lagom团队编写的模块提供的支持)。Lagom有一个惊人的消息代理API的抽象，所以你基本上可以通过改变你的服务继承的类从Kafka迁移到Pub/Sub，或者反过来。使用消息代理的通信分离了服务，使它们相互透明，并提高了系统的弹性。</p><p id="eb46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用Lagom已经半年多了，一直在处理非常复杂的问题，我对这个选择非常满意。这使得一切都更容易开发和测试。这个社区仍然很小，但是非常活跃和有帮助。</p><p id="9894" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我鼓励你给Lagom一个机会，让我知道事情的进展，我会在这里帮助你:)</p></div></div>    
</body>
</html>