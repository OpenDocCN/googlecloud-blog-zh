<html>
<head>
<title>Getting started with Google Cloud Monitoring APIs — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google云监控API入门—第3部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/missing-data-points-in-your-monitoring-api-response-use-page-iterators-81d27e954c70?source=collection_archive---------0-----------------------#2021-08-09">https://medium.com/google-cloud/missing-data-points-in-your-monitoring-api-response-use-page-iterators-81d27e954c70?source=collection_archive---------0-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b6d2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">迭代器简化了通过API响应分页的过程。学习使用页面迭代器从“list_time_series”调用中获取所有数据点。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0caa3141cefc25befc38b8991ddb998c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPZap7X4nhqiLrkQZe-6wQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">缺少一些数据？[图片由<a class="ae jn" href="https://unsplash.com/@franki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Franki Chamaki </a>在<a class="ae jn" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄]</figcaption></figure><p id="4e62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在GCP上运行的企业通常在不同的地区/区域拥有多个资源实例，以实现HA(高可用性),即在较长时间内提供一致的正常运行时间。</p><blockquote class="kk kl km"><p id="c72a" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">我合作过的一个GCP客户在其云环境中安装了9台路由器。这些路由器每分钟生成一个值为0或1的数据点，其中“1”表示路由器停机。你能想象你脑子里有多少数据点吗？</p></blockquote><blockquote class="kr"><p id="4484" class="ks kt hi bd ku kv kw kx ky kz la kj dx translated">9 * 30 * 24 * 60 =什么！唷。</p></blockquote><p id="f1b3" class="pw-post-body-paragraph jo jp hi jq b jr lb ij jt ju lc im jw jx ld jz ka kb le kd ke kf lf kh ki kj hb bi translated">我的上一篇博客文章讨论了如何获取这些度量数据点。当API响应返回超过100，000个数据点时，就像上面的388800个数据点一样，响应只包含前100，000个数据点和一个可用于获取下一组数据点的<code class="du lg lh li lj b">nextPageToken</code>。这可能有点令人困惑。怎么用<code class="du lg lh li lj b">nextPageToken</code>？这篇博客建议了两种方法，你可以用它们来获得你所有的数据点。</p><h1 id="5918" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">我的数据点都在哪里？</h1><p id="c31e" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">作为一个使用监控API的初学者，很难理解为什么响应没有包含所有的数据点，特别是当您没有在请求中传递一个<code class="du lg lh li lj b">pageSize</code>以及像<code class="du lg lh li lj b">filter</code>或<code class="du lg lh li lj b">interval</code>这样的参数时。<br/>答案是，如果请求中传递的<code class="du lg lh li lj b">pageSize</code>为空(未传递)或者超过10万个结果，则有效的<code class="du lg lh li lj b">pageSize</code>为10万个结果。如果<code class="du lg lh li lj b">view</code>设置为<code class="du lg lh li lj b">FULL</code>，这是返回的<code class="du lg lh li lj b">Points</code>的最大数量。</p><h1 id="2da2" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">如何获得剩余的数据点？</h1><p id="a3f4" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">在这里详细参考API响应<a class="ae jn" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v3/ListTimeSeriesResponse" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="iy iz ja jb fd mh lj mi mj aw mk bi"><span id="b67e" class="ml ll hi lj b fi mm mn l mo mp">{<br/>  "timeSeries": [<br/>    {<br/>      object (<a class="ae jn" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v3/TimeSeries" rel="noopener ugc nofollow" target="_blank"><strong class="lj hj">TimeSeries</strong></a>)<br/>    }<br/>  ],<br/>  "nextPageToken": string,<br/>  "executionErrors": [<br/>    {<br/>      object (<a class="ae jn" href="https://cloud.google.com/monitoring/api/ref_v3/rest/Shared.Types/Status" rel="noopener ugc nofollow" target="_blank"><strong class="lj hj">Status</strong></a>)<br/>    }<br/>  ],<br/>  "unit": string<br/>}</span></pre><h2 id="d28c" class="ml ll hi bd lm mq mr ms lq mt mu mv lu jx mw mx lw kb my mz ly kf na nb ma nc bi translated">直接使用nextPageToken</h2><p id="5f46" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">如文档所述，如果返回的结果多于返回的结果，那么<code class="du lg lh li lj b">nextPageToken</code>被设置为非空值。</p><p id="e7c8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要查看额外的结果，请在对该方法的下一次调用请求中将<code class="du lg lh li lj b">nextPageToken</code>作为<code class="du lg lh li lj b">pageToken</code>传递。响应是一个结果/数据点的<strong class="jq hj">列表，带有一个用于下一页的令牌</strong>，直到您到达一个调用，其中<code class="du lg lh li lj b">nextPageToken</code>为空，这意味着所有的值都被返回。</p><p id="7c45" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你想知道这不是一个很长的过程吗？是的，自己打电话，自己在每个值中添加代币值。这就是我们使用<code class="du lg lh li lj b">pages</code>的原因。</p><h2 id="c6fe" class="ml ll hi bd lm mq mr ms lq mt mu mv lu jx mw mx lw kb my mz ly kf na nb ma nc bi translated">使用页面迭代器</h2><p id="0249" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">迭代器简化了通过API响应分页的过程。具有遵循列表分页模式的方法的API客户端可以返回一个<code class="du lg lh li lj b"><a class="ae jn" href="https://googleapis.dev/python/google-api-core/latest/page_iterator.html#google.api_core.page_iterator.Iterator" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">Iterator</strong></a></code>。您可以使用这个迭代器获得所有页面的所有结果。</p><pre class="iy iz ja jb fd mh lj mi mj aw mk bi"><span id="81e5" class="ml ll hi lj b fi mm mn l mo mp">results = client.list_time_series(request={ ... })</span></pre><p id="d74f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设<code class="du lg lh li lj b">results</code>包含来自上一个API调用的响应，请求中有适当的参数。现在，我们知道如果响应包含超过100，000个点，那么响应将被分页。只需使用下面的代码片段遍历页面，并将您的所有观点存储在一个单独的<code class="du lg lh li lj b">list</code>中。这个<code class="du lg lh li lj b">list</code>留在内存里。稍后，我们可以使用列表中的<code class="du lg lh li lj b">points</code>,而不是为每个页面调用API。</p><pre class="iy iz ja jb fd mh lj mi mj aw mk bi"><span id="4afd" class="ml ll hi lj b fi mm mn l mo mp">all_points = []<br/>for page in results.pages:<br/>    for series in page.time_series:<br/>        for point in series.points:<br/>             all_points.append(point)</span></pre><p id="20a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为我们没有改变任何<code class="du lg lh li lj b">points</code>或者将它们改为列表对象，所以我们仍然可以使用本地方法<code class="du lg lh li lj b">points</code>来获得时间和相应的时间值(度量值)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h2 id="9133" class="ml ll hi bd lm mq mr ms lq mt mu mv lu jx mw mx lw kb my mz ly kf na nb ma nc bi translated">一些直接来自监控API开发者的建议—</h2><p id="4a6d" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">我们可以想象，分页是每页进行一次服务器调用，因此非常慢。当您有大量点数时，更好的方法是更好地组织您的<code class="du lg lh li lj b">filters</code>,使响应中的点数少于100，000。用博客开头的路由器例子来解释—</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c5618d1b4e79f24ed191ac7fa2bc109c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwh4ElgPDfTIF0AfGxrdxQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">现在取回所有数据:)[图片由<a class="ae jn" href="https://unsplash.com/@franki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae jn" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄]</figcaption></figure><p id="0532" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果所有路由器都有大约相同数量的点，您可以尝试发送9个查询，每个查询都有一个带有“router = x”的过滤器，以便单独获得每个路由器的数据。然后，每个响应可以有适合一个页面的值。您可以在view设置为<code class="du lg lh li lj b">HEADERS</code>的情况下使用<code class="du lg lh li lj b">list_time_series</code>来获得x的值(headers只给出哪些时间序列存在，而没有任何实际数据)。</p><h1 id="d95b" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">详细了解“列表分页”</h1><p id="f9cf" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">由于这些方法遵循所有具有分页响应的API的通用方案，您可以查看Google API风格指南中的<a class="ae jn" href="https://cloud.google.com/apis/design/design_patterns#list_pagination" rel="noopener ugc nofollow" target="_blank">列表分页</a>以了解更多细节。<br/>我实际上是通过参考google APIs for calendar上的大量答案找到了监控API问题的解决方案，因为，是的，它们遵循相同的风格指南。这也说明了在编写代码时遵循最佳实践是多么重要。模式让人们更容易吸收信息，并进一步使用它。</p><p id="34aa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望你觉得这有用！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/cab7b6a2aadc4a467470be33a7df0529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZNHwm0jMNuVl7Zvn9mNlg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">【作者图片——在这里用我尝试过的一点数字艺术结束监控系列！👋🏼]</figcaption></figure></div></div>    
</body>
</html>