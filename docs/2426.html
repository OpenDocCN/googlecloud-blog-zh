<html>
<head>
<title>Delta tables with Dataproc, Jupyter (and BigQuery)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Dataproc、Jupyter(和BigQuery)的增量表</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/delta-tables-with-dataproc-jupyter-and-bigquery-ea2509ca9e0f?source=collection_archive---------1-----------------------#2022-10-16">https://medium.com/google-cloud/delta-tables-with-dataproc-jupyter-and-bigquery-ea2509ca9e0f?source=collection_archive---------1-----------------------#2022-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7a8dcbb0fabffdda21bdeafac35b571f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9LFLyAA9Hi6unzJc7R4Kw.png"/></div></div></figure><p id="2826" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近我想处理增量表格式的数据。我的最终目的是看看如何从BigQuery查询它，但这是以后的事了。增量表通常与数据块一起使用，但我没有访问该平台的权限，所以我需要找到一个我可以使用的环境。我可以访问Dataproc，这是Google的Spark cluster故事。在搜索文档和互联网之后，我找到了允许我在Dataproc上安装Delta的方法，但是这些方法假设我将提交Spark作业进行处理。在我的故事中，我想用Jupyter笔记本来做实验。我找不到允许我通过Jupyter环境在Dataproc上使用增量表的方法。</p><p id="7a5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过一个漫长的夜晚，我找到了解决办法。这篇文章是对那个食谱的详细描述。如果我们遵循它，我们将最终得到一个运行中的支持增量表的Dataproc集群和一个可以用于实验的Jupyter笔记本。</p><ol class=""><li id="e157" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">转到控制台中的Dataproc页面。这是我们将做大部分工作的地方。我假设您已经启用了Dataproc，并且有足够的I am权限来执行这些任务。</li><li id="1a6b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">创建一个新的Dataproc集群</li></ol><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/3dee1d67501d842cd04c306fd1c09a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nkaI3Jm_6ggnYQGA"/></div></div></figure><p id="a661" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在组件下，选择启用组件网关和Jupyter笔记本:</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/267099e19d42a061894658cf3d0a4b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bHSRdpRXI4NALxNd"/></div></div></figure><p id="d12f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">切换到“定制集群”页面:</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/945fe0f34da284493cca5a99a8f718b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/0*3QolmgnSzYghdsy-"/></div></figure><p id="9765" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加群集属性:</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/84ebe8c1ae9aa78e84687e77afeba407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*rStIEbhh9VsWxGSW"/></div></figure><ul class=""><li id="d66b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn kk ju jv jw bi translated">前缀:<code class="du kl km kn ko b">spark</code></li><li id="704e" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn kk ju jv jw bi translated">按键:<code class="du kl km kn ko b">spark.jars.packages</code></li><li id="a6e8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn kk ju jv jw bi translated">价值:<code class="du kl km kn ko b">io.delta:delta-core_2.12:1.0.1</code></li></ul><p id="b3d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上是食谱的核心。这将maven坐标为<code class="du kl km kn ko b"><a class="ae kp" href="https://mvnrepository.com/artifact/io.delta/delta-core" rel="noopener ugc nofollow" target="_blank">io.delta:delta-core_2.12:1.0.1</a></code>的Maven包添加到集群环境中。请注意，我们使用的增量表版本是1.0.1。我最初错误地认为我可以使用最新的可用版本。这被证明是一个错误。1.0.x是与Apache Spark 3.1.x一起使用的版本。任何更高版本的Delta包都需要更高版本的Spark。在撰写本文时(2022-10)，<a class="ae kp" href="https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-release-2.0" rel="noopener ugc nofollow" target="_blank"> Dataproc </a>使用Apache Spark 3.1.3。当我尝试使用Delta的更高版本时，我遇到了Java未知的类错误。</p><p id="f3f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单击创建以创建集群</p><p id="07ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.打开Jupyter</p><p id="1577" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">深入新集群。找到Web界面页面:</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/7baa33ad7ae51d3acbd2fde3c44d3dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n9O1jV-VLoSDUH3Y"/></div></div></figure><p id="9731" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击JupyterLab。</p><p id="2216" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">朱庇特将发射。</p><p id="b05c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.点击笔记本下的PySpark打开Jupyter PySpark笔记本</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/ae15e05d5cd12095c39cd1b007142931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bv1bAm_UvObD3M_D"/></div></div></figure><p id="784f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.创建写入delta lake的PySpark代码片段</p><pre class="kd ke kf kg fd ks ko kt ku aw kv bi"><span id="b242" class="kw kx hi ko b fi ky kz l la lb">from delta import *<br/>from pyspark.sql import SparkSession</span><span id="fd7d" class="kw kx hi ko b fi lc kz l la lb">spark = SparkSession \<br/>  .builder \<br/>  .appName("DeltaTest") \<br/>  .config("spark.sql.extensions", "io.delta.sql.DeltaSparkSessionExtension") \<br/>  .config("spark.sql.catalog.spark_catalog", "org.apache.spark.sql.delta.catalog.DeltaCatalog") \<br/>  .config("spark.jars.packages", "io.delta:delta-core:1.0.1") \<br/>  .getOrCreate()</span><span id="8494" class="kw kx hi ko b fi lc kz l la lb">data = [{"Category": 'A', "ID": 1, "Value": 121.44, "Truth": True},<br/>        {"Category": 'B', "ID": 2, "Value": 300.01, "Truth": False},<br/>        {"Category": 'C', "ID": 3, "Value": 10.99, "Truth": None},<br/>        {"Category": 'D', "ID": 4, "Value": 123.45, "Truth": False}<br/>        ]<br/>df = spark.createDataFrame(data)<br/>df.write.format("delta").mode("overwrite").save('gs://kolban-tmp/temple/')<br/>df.show()</span></pre><p id="fa27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意SparkSession中与增量表相关的额外配置。运行这段代码后，我们会发现GCS bucket现在包含了一个增量表。</p><h1 id="f84a" class="ld kx hi bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">增量到大查询</h1><p id="1920" class="pw-post-body-paragraph iq ir hi is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hb bi translated">现在让我们假设Google云存储中有增量表。我们将通过表的GCS文件夹路径来识别该表。例如:</p><p id="ae77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kl km kn ko b">gs://kolban-tmp/temple/</code></p><p id="5a64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将是一个驻留在名为<code class="du kl km kn ko b">kolban-tmp</code>的GCS存储桶上的增量表，它包含在名为temple的文件夹中(该表也因此被称为temple)。如果我们检查该文件夹中包含的文件，我们会发现一系列拼花文件和一个名为<code class="du kl km kn ko b">_delta_logs</code>的附加文件夹。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/6bbe64ad4a46105eb023c852901f6c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6dN9OiPezYJ-rKkx"/></div></div></figure><p id="7fca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过Spark使用增量库直接处理增量表，但是有一个常见的问题…我可以通过BigQuery处理这些增量表吗？</p><p id="0db5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">BigQuery是谷歌的分析数据仓库。通常，我们将希望查询的数据交给BigQuery，然后big query将其存储在自己的私有存储中。将增量表复制到BigQuery中很容易。从Delta读取并写入BigQuery的spark作业将能够快速完成复制。但是，如果我们不想复制数据呢？如果我们希望增量表中的更改能够尽快在BigQuery中处理呢？最好是接近实时。</p><p id="f638" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">BigQuery支持一个叫做<a class="ae kp" href="https://cloud.google.com/bigquery/docs/external-tables" rel="noopener ugc nofollow" target="_blank">外部表</a>的概念。外部表是存储在BigQuery外部的逻辑表的数据。例如CSV、JSON、Avro和Parquet。当我们引用一个定义为外部的BigQuery表时，BigQuery从非BigQuery本地数据源中读取数据并执行处理。不幸的是，增量表格式数据还不是(2022年10月)BigQuery支持的格式。</p><p id="a89c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，一些谷歌工程师已经提出了一些解决办法。在这里，我们将描述和演示其中的一种解决方法。</p><p id="ff2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了理解这个解决方案，我们将简要描述增量表是如何物理存储的。这不是实施解决方案所必需的，因此如果需要，您可以跳过这一部分。当对增量表进行改变时，一个或多个新的拼花格式文件被写入存储器。这些文件的集合构成了整个增量表。拼花文件一旦写入就不会被修改。因此，如果在增量表中插入新行，将会创建表示这些插入的新拼花文件。但是更新和删除呢？同样，创建了新的拼花文件(以前的文件从不修改),表示表中的变化，但现在我们似乎有了新的挑战…我们现在有过时的拼花文件。现在在存储器中有实际拼花文件的子集，它们构成了表…我们如何知道使用哪一个呢？这就是德尔塔的第二部分发挥作用的地方。Delta维护一个包含JSON文件的日志文件夹，其中每个JSON文件代表一个对Delta表的更改。JSON文件描述了用于访问表的一组parquet文件。</p><p id="219e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个松散的总结，我们现在可以着眼于我们的解决方案。该解决方案基于外部数据创建了两个BigQuery表，这两个表都基于GCS托管的数据。第一个表利用增量表存储中的所有parquet文件，第二个表利用增量表存储中的所有JSON文件。跨越所有拼花文件的表可以看到所有可能的数据。跨越JSON文件的表可以看到所有的指令，从而知道哪些parquet文件应该组合在一起。最后，我们使用JSON files表的内容作为过滤器，在parquet files表上创建一个BigQuery视图。该视图可以用作最终用户查询的目标。查询视图将生成与查询增量表相同的结果，我们的工作就完成了。</p><p id="6145" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看实际情况。</p><p id="384d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个增量表，位于:</p><p id="da56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kl km kn ko b">gs://kolban-tmp/temple/</code></p><p id="7dbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的目标是以一个我们称之为<code class="du kl km kn ko b">delta_lake.temple</code>的BigQuery视图结束。</p><p id="aa27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在BigQuery中运行下面的SQL，我们将实现这个目标:</p><pre class="kd ke kf kg fd ks ko kt ku aw kv bi"><span id="4afe" class="kw kx hi ko b fi ky kz l la lb">DECLARE BUCKET STRING DEFAULT "kolban-tmp";<br/>DECLARE FOLDER STRING DEFAULT "temple";<br/>DECLARE DATASET STRING DEFAULT "delta_lake";<br/>DECLARE DELTA_TABLE STRING DEFAULT "temple";</span><span id="3a8d" class="kw kx hi ko b fi lc kz l la lb">#<br/># Implementation<br/>#<br/>DECLARE XXX_PARQUET STRING;<br/>DECLARE XXX_DELTA_LOG STRING;<br/>DECLARE GS_PARQUET STRING;<br/>DECLARE GS_JSON STRING;<br/>DECLARE DELTA_TABLE_VIEW STRING;<br/>DECLARE PATH STRING;<br/>SET PATH = FORMAT("gs://%s/%s/", BUCKET, FOLDER);<br/>SET XXX_PARQUET = FORMAT("%s.%s_parquet", DATASET, DELTA_TABLE);<br/>SET XXX_DELTA_LOG = FORMAT("%s.%s_delta_log", DATASET, DELTA_TABLE);<br/>SET GS_PARQUET = FORMAT("gs://%s/%s/part*.parquet", BUCKET, FOLDER);<br/>SET GS_JSON = FORMAT("gs://%s/%s/_delta_log/*.json", BUCKET, FOLDER);<br/>SET DELTA_TABLE_VIEW = FORMAT("%s.%s_view", DATASET, DELTA_TABLE);<br/>EXECUTE IMMEDIATE FORMAT("CREATE OR REPLACE EXTERNAL TABLE %s OPTIONS (format = 'PARQUET', uris = ['%s'])", XXX_PARQUET, GS_PARQUET);<br/>EXECUTE IMMEDIATE FORMAT("CREATE OR REPLACE EXTERNAL TABLE %s OPTIONS (format = 'CSV', field_delimiter='|', uris = ['%s'])", XXX_DELTA_LOG, GS_JSON);<br/>EXECUTE IMMEDIATE FORMAT("CREATE OR REPLACE VIEW `%s` AS SELECT * FROM  `%s` WHERE _FILE_NAME IN (SELECT CONCAT('%s' , JSON_EXTRACT_SCALAR(string_field_0, '$.add.path')) AS filepath FROM `%s` EXCEPT DISTINCT SELECT CONCAT('%s' , JSON_EXTRACT_SCALAR(string_field_0, '$.remove.path')) AS filepath FROM `%s`)", DELTA_TABLE_VIEW, XXX_PARQUET, PATH, XXX_DELTA_LOG, PATH, XXX_DELTA_LOG) ;</span></pre><p id="447e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SQL从四个声明开始，您可以针对自己的环境修改这些声明:</p><ul class=""><li id="5068" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn kk ju jv jw bi translated"><code class="du kl km kn ko b">BUCKET</code> —保存增量表的GCS存储桶的名称</li><li id="87f8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn kk ju jv jw bi translated"><code class="du kl km kn ko b">FOLDER</code>—GCS存储桶中保存增量表的文件夹的名称</li><li id="b249" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn kk ju jv jw bi translated"><code class="du kl km kn ko b">DATASET</code> —将保存BigQuery表和视图的BigQuery数据集的名称</li><li id="bb77" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn kk ju jv jw bi translated"><code class="du kl km kn ko b">DELTA_TABLE</code> —将呈现底层增量表的BigQuery视图的名称</li></ul><p id="dc3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行之后，我们将发现BigQuery中创建的三个新构件:</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/a71f55b3f2685d3d0c17cce6e73c656e.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/0*1IwfcJn8Tnnhp0RP"/></div></figure><p id="4684" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kl km kn ko b">temple_delta_log</code>表是增量表的JSON文件上的外部表。那里没有你需要直接查询的东西。</p><p id="6d2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kl km kn ko b">temple_parquet</code>表是增量表的拼花文件的外部表。同样，这里没有您需要直接查询的内容。</p><p id="7b14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kl km kn ko b">temple_view</code>是您将查询以查看增量表数据的视图。</p><p id="5d9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后……一段视频展示了上述步骤:</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="968f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">学分:</p><ul class=""><li id="e588" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn kk ju jv jw bi translated">Adam paterno stro——提出SQL方法来处理增量文件的专家。</li></ul></div></div>    
</body>
</html>