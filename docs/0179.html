<html>
<head>
<title>Deploying WebSockets cluster to GCP with Let’s Encrypt certificates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用加密证书将WebSockets集群部署到GCP</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploying-websockets-cluster-to-gcp-with-lets-encrypt-certificates-5ebb7fc1e245?source=collection_archive---------6-----------------------#2016-12-20">https://medium.com/google-cloud/deploying-websockets-cluster-to-gcp-with-lets-encrypt-certificates-5ebb7fc1e245?source=collection_archive---------6-----------------------#2016-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7eb40cdd49c0e14c392ba69abba67917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ynqs_YuKQ5vCrV-yeoBxaQ.png"/></div></div></figure><div class=""/><p id="f160" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署WebSockets集群本身并不是一项简单的任务，您需要一个特殊的负载平衡器，它具有保持连接活动的会话关联性，更不用说向该方添加加密SSL证书了。</p><p id="221e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我希望通过分享大量的bash代码和我在GCP部署WebSockets集群的经验，让我们加密SSL证书。在这里，我将讨论高级概念，而在GitHub资源库中，我将深入探讨低级命令。</p><p id="46bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从绘制架构开始，以使总体规划尽可能清晰:</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/99eaf59818ddc847546ea288ad12bbef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wHk4Jlr3IrhOhMilZpTxQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">架构概述</figcaption></figure><p id="e179" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，该架构由两个主要组件组成，应用服务器和加密服务器。它们都是受管理的实例组，位于负载平衡器之后。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="e936" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们深入了解架构的每个部分，我们将从网络负载平衡器开始。这个负载平衡器应该接收来自端口80和443 (HTTP/S)的所有域流量，并将其路由到应用程序实例组。必须为此负载平衡器启用会话关联，以保持WebSockets连接路由到同一服务器，否则连接将保持重新连接。我们必须使用网络负载平衡器，因为其他人不支持WebSockets。此外，一个静态IP地址必须连接到这个负载平衡器，这样我们就能够用这个地址更新我们的DNS区域文件。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="40ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用服务器运行Nginx来处理请求的路由和SSL终止。Docker用于应用程序本身(你的代码！).在初始化时，应用服务器从Google云存储中下载相关域的SSL证书以及dhparam.pem文件(稍后，我将解释它们是如何到达那里的)。Nginx将所有ACME challenge HTTP请求(由Let's Encrypt用来验证域)路由到Let's Encrypt负载平衡器(该负载平衡器的IP存储为项目元数据)。所有其他HTTP请求都被重定向到HTTPS。HTTPS请求被路由(使用反向代理)到带有应用程序代码的Docker映像(代理显然支持WebSockets)。一个每日cron作业被配置为从GCS同步证书，并在发生变化时重启Nginx。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="2374" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">HTTP负载平衡器是一个简单的负载平衡器，它将所有端口80请求路由到Let's Encrypt实例组。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="b95a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们加密更新服务器使用<code class="du ke kf kg kh b">letsencrypt</code> Docker映像来触发更新请求，并使用Apache2 web服务器来处理ACME挑战。Apache2不需要任何配置，因为它在安装后已经被设置为服务于一个目录。使用Docker映像，我们将更新我们的域证书，然后将它们上传到GCS，GCS中的相关路径也存储为项目元数据(不要担心，有一个脚本可以处理一切)。目前，我没有设置cron作业来自动更新证书，但这是完全可行的。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="afa8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经理解了每一部分，让我们运行一些代码。前往<a class="ae ki" href="http://bit.ly/2gWsG9B" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>并克隆项目。项目本身和脚本都有完整的文档记录，所以我只简单解释一下需要做什么。</p><p id="000c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，打开<code class="du ke kf kg kh b">pre-deploy.sh</code>，编辑<code class="du ke kf kg kh b">BUCKET</code>和<code class="du ke kf kg kh b">BUCKET_LOCATION</code>，然后运行脚本。这可能需要一段时间，因为它会生成一个dhparam.pem文件，这是一项CPU密集型任务。完成后，GCS中应该有一个全新的bucket，它包含dhparam文件以及一个存储bucket路径的新项目元数据。</p><p id="62ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将部署让我们加密的实例组，因此打开<code class="du ke kf kg kh b">letsencrypt</code>目录。如果您愿意，您可以更改一些<code class="du ke kf kg kh b">deploy.sh</code>参数，以适应您的使用情况。您必须更改<code class="du ke kf kg kh b">startup.sh</code>中的<code class="du ke kf kg kh b">EMAIL</code>参数。这封电子邮件将用于注册您的SSL证书与让我们加密。现在我们可以运行部署脚本了，应该不会花很长时间，我们就会在GCP控制台中看到一个新实例。第一次颁发证书时，我们必须将DNS区域文件设置为这个全新实例的外部IP(我们还不能部署应用程序服务器，因为它们需要证书，这就是为什么我们必须第一次使用这个工具)。然后，SSH进入实例，请注意，实例完全安装所有东西需要大约3m的时间。你可以<code class="du ke kf kg kh b">tail</code>安装日志<code class="du ke kf kg kh b">/var/log/daemon.log</code>来跟踪进度。安装完成后，我们可以运行更新脚本<code class="du ke kf kg kh b">sudo /root/renew.sh yourdomain.com</code>。第一次它可能会问你一些问题，但过一会儿它会颁发证书并将它们上传到GCS。</p><p id="446f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在已经为部署应用程序实例组做好了一切准备。同样，您可以编辑部署参数以满足您的需求。在<code class="du ke kf kg kh b">startup.sh</code>中，您必须编辑<code class="du ke kf kg kh b">DOMAIN</code>，这当然是应用服务器的域。您还需要编辑<code class="du ke kf kg kh b">DOCKER_IMAGE</code>，它应该指向您的应用程序Docker图像(如果您想使用，我为演示创建了一个简单的websockets服务器)。<code class="du ke kf kg kh b">DOCKER_PORT</code>应设置为您的Docker映像所显示的端口。保存所有东西并运行<code class="du ke kf kg kh b">deploy.sh</code>，同样需要大约3m的时间让实例自己安装，但同时我们可以返回到我们的DNS区域文件并更新它以指向我们全新的网络负载平衡器。一个静态的IP附在上面，应该是改不了的。</p><p id="fb90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！你现在在Google云平台上有了一个正在运行的websockets集群，由Let's Encrypt提供的免费SSL证书保护。如果您觉得缺少了什么或者需要修改，我们非常欢迎您对这个库做出贡献。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="74fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kj">感谢阅读！如果你喜欢这个，请推荐它，这样其他人也可以通过点击心形按钮来欣赏。</em></p><p id="6e0b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请随时通过<a class="ae ki" href="https://twitter.com/idoshamun" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ki" href="https://il.linkedin.com/in/ido-shamun-aa8628a3" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和这里的<a class="ae ki" rel="noopener" href="/@idoshamun"> Medium </a>联系我。</p></div></div>    
</body>
</html>