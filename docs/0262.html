<html>
<head>
<title>App Engine and the connection confusion problem.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用引擎和连接混乱问题。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/app-engine-and-the-connection-confusion-problem-d270b7465794?source=collection_archive---------1-----------------------#2017-04-20">https://medium.com/google-cloud/app-engine-and-the-connection-confusion-problem-d270b7465794?source=collection_archive---------1-----------------------#2017-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d9dc4b6b7d36750855f51f34b01f8003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8gFMHNLtQJj-DnrepTSjw.jpeg"/></div></div></figure><div class=""/><p id="bfaa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我帮助启动了<a class="ae jo" rel="noopener" href="/@duhroach/app-engine-startup-time-and-the-global-variable-problem-7ab10de1f349">“诱饵和缝合”应用程序</a>之后，一些新人向我提出了帮助他们解决性能问题的请求。所以，我们现在有大量的问题需要解决！</p><p id="da31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中一个更有趣的案例，是我的一个老朋友，<em class="jp">艾丽西娅，</em>，她开发了一个名为“<em class="jp">部分多云</em>”的应用程序，为需要在专业演示中使用云的开发者提供高分辨率图像。(有点像<a class="ae jo" href="https://earthview.withgoogle.com/" rel="noopener ugc nofollow" target="_blank">谷歌地球视图</a>..但是对于<a class="ae jo" href="https://www.google.com/search?q=clouds&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjW34frxY3SAhVLzGMKHaqJC2oQ_AUICCgB&amp;biw=1765&amp;bih=1037" rel="noopener ugc nofollow" target="_blank">云</a>..)这款应用在几周前推出了封闭测试版，在最初几天内就拥有了大约200多名用户。然而，在使用了大约一周后，艾丽西娅在一天早上醒来时看到这个小宝贝在谷歌云开发者控制台上等着她:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jq"><img src="../Images/85204197ffa1ddacd9427e2076687e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gk_lNIt9l-Yj-CZshZKEnA.png"/></div></div></figure><p id="3006" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图中的蓝线显示了她的应用程序正在使用的活动GAE实例的数量。平均大约有16个实例，峰值有18个。这是有问题的，考虑到这个特定的应用程序除了向用户提供一些图像之外，实际上没有做太多事情。</p><figure class="jr js jt ju fd hk"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">忙到没时间看书？查看LT；视频博士！</figcaption></figure><p id="92df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">艾丽西娅的商业计划书中没有为18倍并发连接收费，所以是时候深入研究并弄清楚为什么世界上有如此多的实例被加速了。</p><h1 id="f1dc" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">事情安排得怎么样了？</h1><p id="7557" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">和艾丽西娅见了几次面后，我明白了CCV是如何建立起来的。</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es le"><img src="../Images/dfe248a9f5e12f86dad06f6bd8ee99b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*HNRJ7BMfoHH4BTJhh1TdVA.png"/></div></figure><p id="5b6f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整个事情大概是这样的:</p><ul class=""><li id="9762" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated">GAE将处理来自客户端的请求，并对数据存储进行数据库查询(在我们的例子中是NDB查询)。这提供了数据库中所有20，000幅图像的完整目录。</li><li id="9457" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">从那里，应用程序引擎将随机选择一个，抓取其中的网址细节</li><li id="b47b" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">从GCS桶中获取完整图像</li><li id="c235" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">将完整的图像返回给客户端。</li></ul><p id="a675" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更深入地了解这里发生了什么，让我们来看看跟踪结果。</p><h1 id="1f4b" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">太远的痕迹。</h1><p id="0431" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated"><em class="jp">partially clouded</em>的开发人员有一种预感:她在跟踪结果中看到了非常高的延迟数字，并认为这是造成大量实例的原因。(在某些情况下，高响应时间会导致新实例加速运行)。</p><p id="582a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在看了跟踪列表后，我不得不同意，这看起来是个明显的问题。</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/620b78665613756eb57a322f058d1772.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*VMXVksQDDxfCVehOh4l7Xg.png"/></div></figure><p id="0da6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，当我深入研究追踪信息时，事情开始变得非常奇怪:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/ce64d93a519cbbc7e12bd93558399672.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*J9RNf6LUKv_YiG9jwpP0SQ.png"/></div></figure><p id="3d34" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">报告的延迟为6秒，但跟踪信息显示所有RPC调用的总和仅用了大约180毫秒。</p><p id="5669" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如<a class="ae jo" rel="noopener" href="/@duhroach/understanding-and-profiling-app-engine-cold-boot-time-908431aa971d">在</a>之前提到的，<a class="ae jo" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Stackdriver的</a> Trace工具在自动列出所有RPC命令方面做得很好，由于这两个数字有点混乱，我决定(再次)放入一些定制的分析，看看是否有什么没有被报告</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lv"><img src="../Images/0675fab19519047cce9c36fc07052a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*FJqnhifRQsLksEKSQHs-gA.png"/></div></figure><p id="2e15" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有。不仅时间不匹配，而且定制跟踪信息的提交给我们的请求增加了额外的143毫秒(<em class="jp">注意:稍后修正… </em>)。</p><h1 id="19e2" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">房屋回购</h1><p id="fb6a" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">至此，我严重迷茫了。我要求删除源代码，这样我就可以尝试在我的本地工作站上重现这个问题。这让事情变得更加奇怪，因为我无法从我的桌面上获得同样高的跟踪数:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lw"><img src="../Images/f7edc11fac1b64d8146d8ef66c379957.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*BDF08bTOINwqMJBmTjGvlw.png"/></div></figure><p id="5a8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我查看较慢请求的日志信息时，出现了突破:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lx"><img src="../Images/b38a8c0797b043cb583b3a501c7dd2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*vATm0MXvPrgn_ax8ip0TAA.png"/></div></figure><p id="b01a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它来自一个移动设备。</p><p id="ae4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这给了我一个想法:<em class="jp">如果连接速度导致跟踪号被夸大了怎么办？</em></p><p id="aff5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试这个理论，我用几个特定的<a class="ae jo" href="http://unix.stackexchange.com/questions/39218/throttle-the-download-speed-of-wget-or-curl-while-downloading" rel="noopener ugc nofollow" target="_blank"> CURL命令</a>(你也可以在<a class="ae jo" href="https://developer.chrome.com/devtools" rel="noopener ugc nofollow" target="_blank"> Chrome devtools </a>中这样做)将我的连接调节到【150k/s，450k/s，750k/s，None】，得到了以下计时:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es ly"><img src="../Images/221960c9dab0d288a0a9d5f10102600f.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*xzP7G-QFKsT9ATvAQh6qyA.png"/></div></figure><p id="31a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">似乎我们在这里得到了一些牵引。</p><h1 id="2914" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">午餐和学习。</h1><p id="c0ed" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">这里值得指出一点，这让我在调试这个问题时大费周章。跟踪可以被记录，并且几乎立即可见，如下所示:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/622086dfc427f2089ffb3480dbd0b0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*XlpRuubDa2T8FTiOkLQpLg.png"/></div></figure><p id="ef3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在30分钟的时间跨度内，前端信息将被添加到其中，您最终会看到整体跟踪时间的膨胀。这是同样的轨迹，17分钟后。</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lz"><img src="../Images/27649806d98f02314e2a85e7756485d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*zLzhnhTSBquypMW_TxeQDQ.png"/></div></figure><p id="cabf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">30分钟后，追踪数据显示:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/ce64d93a519cbbc7e12bd93558399672.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*J9RNf6LUKv_YiG9jwpP0SQ.png"/></div></figure><p id="be50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的要点是，云负载均衡器需要计算一些额外的数据，并且这些数据会随着时间的推移而增加。因此，为了对痕迹进行正确的分析，请确保在深入挖掘之前给它30-50分钟的时间。(注意* * stack driver团队意识到了这种<em class="jp">细微差别</em>，并希望在未来解决这一问题)</p><h1 id="ae84" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">这和实例计数有什么关系？</h1><p id="1d25" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">这里需要注意的是:<em class="jp">连接速度对实例数量没有影响</em>。</p><p id="7ff3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更具体地说，一个连接将通过一个App Engine前端路由，它将负责客户端和GAE实例之间的联系。一旦GAE实例处理完请求，它就被传递回前端，然后闲置。从那时起，AEF将保持打开，并在发送信息期间连接到客户端，而GAE实例可以为其他请求提供服务。</p><p id="9de7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是App Engine作为托管架构的好处之一；这些前端实例可以保持开放并传输流量，您实际上不必处理逻辑或压力。此外，它不会影响您的可计费实例数。</p><p id="b6c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么是什么导致<em class="jp">部分多云</em>的情况如此之高呢？</p><h1 id="dadf" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">隐性成功</h1><p id="6874" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">事实证明，高实例数的原因是巨大的成功。当我们翻到流量图时，我们看到在过去的6个小时里，人们一直在相当积极地使用部分多云服务:</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es ma"><img src="../Images/986c9be2145c8678228e695e35458999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*grhwmNbcHHlMmgZPNtrexw.png"/></div></figure><p id="71f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部分多云是它自身成功的受害者！但是，这样的例子还是太多了。谢天谢地，我们已经消除了所有奇怪的、隐藏的问题，解决方案变得非常简单。</p><h1 id="05ae" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">回到客户端</h1><p id="6a1f" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">partial Cloudy具有如此高的出站流量的最大原因之一是实例总是负责将图像数据传递回客户端。哪个..似乎是多余的，为什么客户端通过应用引擎获取图像<em class="jp">？他们不能直接从云存储中获取吗？</em></p><p id="4a1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，解决方案很简单:让我们找到一种方法，花更少的时间让客户与GAE对话，而花更多的时间让他们直接联系GCS。艾丽西娅对这个问题立刻有了答案:</p><ul class=""><li id="53fd" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated">当客户端从GAE获取一个图像时，附加接下来的10个图像id作为额外的头字段。(" x-cloudish-nexts"="123，456，789，…")</li><li id="97aa" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">客户端将直接从GCS获取接下来的10幅图像，而不需要通过GAE获取。</li><li id="cc55" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">当我们没有预取的图像时，回到服务器，获取下一批图像。</li></ul><p id="241a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将通过Alicia的GAE实例的流量减少了10倍，并且从代码的角度来看，解决方案占用的空间非常小。</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/632085032e7b76a6951c5dad77aa7b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*qy9tKRSrYOi2LzTtcwzuuA.png"/></div></figure><p id="2a53" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，从实例的角度来看，结果比预期的要好。运行8个小时后，从平均16次下降到1.5次。</p><figure class="jr js jt ju fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/dbf6b3d1a56f213817ad48eba3e92192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aa8ejhNU92PbKUevGuAgg.png"/></div></div></figure><p id="d411" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对我的底线来说相当不错。</p><h1 id="0568" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">每一毫秒都很重要</h1><p id="0e8a" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">App engine拥有大量令人惊叹的功能；其中一个更强大的优势是，跟踪和分析功能内置于平台中。您可以查看旧的跟踪，并深入了解RPC函数在您的请求中花费了多长时间。在这个特定的用例中，问题与任何RPC函数都没有关系，而是与客户端连接有关。因此，我们并没有过多地使用痕迹来<em class="jp">发现</em>问题，而是排除<em class="jp">不是</em>问题的东西，让我们能够更专注于手头的问题，而不是追逐幽灵。</p><p id="9a26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我的口头禅仍然是正确的:保持冷静，剖析你的代码！</p></div></div>    
</body>
</html>