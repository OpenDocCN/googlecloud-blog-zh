<html>
<head>
<title>Firebase: Developing serverless functions in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase:在Go中开发无服务器功能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/firebase-developing-serverless-functions-in-go-963cb011265d?source=collection_archive---------0-----------------------#2019-01-28">https://medium.com/google-cloud/firebase-developing-serverless-functions-in-go-963cb011265d?source=collection_archive---------0-----------------------#2019-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d1182a76686463868668b7a7ce7c48c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orNvc9gEXDEYAXOYbV5IyA.jpeg"/></div></div></figure><div class=""/><p id="9996" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谷歌云功能的Go运行时间<a class="ae jo" href="https://cloud.google.com/blog/products/application-development/cloud-functions-go-1-11-is-now-a-supported-language" rel="noopener ugc nofollow" target="_blank">于本月在</a>发布测试版。我非常喜欢静态类型语言，尤其是Golang。因此，我对在Go中开发无服务器功能的可能性感到兴奋，并将它们部署在<a class="ae jo" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>。在这篇文章中，我们看看如何在Go中实现云功能，并设置它从<a class="ae jo" href="https://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank">云Firestore </a>触发器中调用。然后我们将把<a class="ae jo" href="https://firebase.google.com/docs/database/" rel="noopener ugc nofollow" target="_blank"> Firebase实时数据库</a>也加入进来，让事情变得更有趣。</p><p id="1525" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的用例非常简单。假设我们有一个电影评论应用程序。用户发布评论，这些评论存储在名为<code class="du jp jq jr js b">movie_reviews</code>的Firestore集合中。每当发布新的评论时，我们都希望对其进行分析，对内容进行评分，并奖励评论的作者一些分数。在Firebase实时数据库中，用户的总分数保持最新。我们当然可以用Firestore来实现这个用例。但是我也使用实时数据库来演示通过云功能在<a class="ae jo" href="https://firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase </a>生态系统中集成多种服务。我还想在新的云函数运行时中尝试一下<a class="ae jo" href="https://firebase.google.com/docs/admin/setup" rel="noopener ugc nofollow" target="_blank"> Firebase Admin SDK </a>。</p><h2 id="6d8a" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">安装</h2><p id="e8a3" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们需要一个支持Firestore和云功能的Firebase项目。如果您还没有，就继续创建一个新的Firebase项目。注意，这实际上是在引擎盖下创建了一个GCP项目。查看<a class="ae jo" href="https://firebase.google.com/docs/firestore/quickstart" rel="noopener ugc nofollow" target="_blank"> Firestore </a>和<a class="ae jo" href="https://cloud.google.com/functions/docs/quickstart" rel="noopener ugc nofollow" target="_blank">云功能</a>的入门指南，了解如何在新项目中启用这些服务。</p><p id="f40e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在您的本地开发环境中安装<a class="ae jo" href="https://cloud.google.com/sdk/docs" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a>，这样您就可以使用<code class="du jp jq jr js b">gcloud</code>命令行工具了。还要确保你已经安装了Golang 1.11，并且你能够在本地构建和运行Go程序。最后，通过运行以下命令安装Firebase Admin SDK:</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="7e9b" class="jt ju ht js b fi lb lc l ld le">$ go get -u firebase.google.com/go</span></pre><p id="ff79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将把Admin SDK及其所需的依赖项安装到您的<code class="du jp jq jr js b">GOPATH</code>中。</p><h2 id="4f7b" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">云函数编码</h2><p id="3eaf" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">首先在本地的某个地方创建一个名为<code class="du jp jq jr js b">scorer</code>的新目录。然后在那个目录下创建一个名为<code class="du jp jq jr js b">scorer.go</code>的文件。这个文件将包含我们为这个例子实现的所有代码。你可以在<a class="ae jo" href="https://github.com/hiranya911/firecloud/tree/master/review-scorer/scorer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到完整的<code class="du jp jq jr js b">scorer.go</code>文件。</p><p id="6ce6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的云功能实现中有两个值得注意的组件:</p><ol class=""><li id="9c51" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated">一个包含包级初始化逻辑的<code class="du jp jq jr js b">init()</code>函数。</li><li id="c167" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">一个包含无服务器函数主体的<code class="du jp jq jr js b">ScoreReview()</code>函数。</li></ol><p id="ec16" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Go中的一个<code class="du jp jq jr js b"><a class="ae jo" href="https://golang.org/doc/effective_go.html#init" rel="noopener ugc nofollow" target="_blank">init()</a></code> <a class="ae jo" href="https://golang.org/doc/effective_go.html#init" rel="noopener ugc nofollow" target="_blank">函数</a>是为一个包实现一些一次性初始化逻辑的标准方式。清单1显示了我们的<code class="du jp jq jr js b">scorer</code>包的<code class="du jp jq jr js b">init()</code>函数应该是什么样子。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单1:包初始化代码</figcaption></figure><p id="2eaf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们初始化Firebase Admin SDK，并创建一个新的<code class="du jp jq jr js b"><a class="ae jo" href="https://godoc.org/firebase.google.com/go/db#Client" rel="noopener ugc nofollow" target="_blank">db.Client</a></code>供以后使用。确保更改<code class="du jp jq jr js b">DatabaseURL</code>设置(清单1中的第17行)以指向您自己的Firebase实时数据库实例。作为一个最佳实践，您应该总是重用<code class="du jp jq jr js b">firebase.App</code>和<code class="du jp jq jr js b">database.Client</code>的实例。因此，通过将上述代码放在一个<code class="du jp jq jr js b">init()</code>函数中，我们确保它只运行一次。相同云函数<em class="lz">实例</em>的多次执行将使用相同的<code class="du jp jq jr js b">db.Client</code>。但是，请注意，这并没有实现全局单例。可以同时有多个云函数实例处于活动状态，实例的启动和停止基于负载。</p><p id="acd2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导出的<code class="du jp jq jr js b">ScoreReview()</code>函数包含了我们的无服务器函数的主要业务逻辑。清单2展示了它是如何实现的。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单2:无服务器函数的主体</figcaption></figure><p id="4300" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个函数接收一个<code class="du jp jq jr js b">Context</code>和一个<code class="du jp jq jr js b">FirestoreEvent</code>作为参数。<code class="du jp jq jr js b">FirestoreEvent</code>由云Firestore触发器传入的所有数据组成。具体来说，它包含触发云功能的Firestore文档的内容。我们在电影评论文本上运行模拟评分函数，并使用之前初始化的<code class="du jp jq jr js b">db.Client</code>实例来更新相应作者的总分。我们使用<code class="du jp jq jr js b">Transaction()</code>代替<code class="du jp jq jr js b">Set()</code>是为了防止<a class="ae jo" href="https://codingsight.com/the-lost-update-problem-in-concurrent-transactions/" rel="noopener ugc nofollow" target="_blank">写入实时数据库时丢失更新问题</a>。</p><h2 id="5b8b" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">声明依赖关系</h2><p id="78d8" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在将我们的功能部署到GCP之前，我们需要创建一个Go模块文件(<code class="du jp jq jr js b">go.mod</code>)，其中包含代码所需的依赖项。在<code class="du jp jq jr js b">scorer</code>目录中执行以下命令，自动生成所需的清单。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="e9d9" class="jt ju ht js b fi lb lc l ld le">$ go mod init<br/>$ go mod tidy</span></pre><p id="1d28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">go mod</code>命令检查<code class="du jp jq jr js b">*.go</code>文件中的导入，以确定构建代码需要哪些依赖项。它根据发现生成两个新文件。此时，我们的项目目录如下所示。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="4baa" class="jt ju ht js b fi lb lc l ld le">scorer/<br/>├── go.mod<br/>├── go.sum<br/>└── scorer.go</span></pre><p id="403e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请随意打开并探索自动生成文件的内容。<code class="du jp jq jr js b">go.mod</code>文件列出了Firebase Admin SDK，以及Admin SDK所需的依赖项。<code class="du jp jq jr js b">go.sum</code>文件包含所有依赖关系的版本和校验和，因此依赖关系树可以在以后可靠地重现。</p><p id="c842" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/golang/go/wiki/Modules" rel="noopener ugc nofollow" target="_blank"> Go模块</a>是Golang 1.11中一个实验性的新特性，用于促进模块版本化和依赖性管理。基于<code class="du jp jq jr js b">go.mod</code>文件，谷歌云功能将获取所需的依赖项，并在云中构建我们的代码。</p><h2 id="4aef" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">部署到云</h2><p id="bf9d" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">从<code class="du jp jq jr js b">scorer</code>目录执行下面的命令，将我们的功能部署到云中。确保用您自己的GCP项目ID替换<code class="du jp jq jr js b">&lt;PROJECT_ID&gt;</code>占位符。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="2bde" class="jt ju ht js b fi lb lc l ld le">$ gcloud functions deploy ScoreReview --runtime go111 \<br/>--trigger-event providers/cloud.firestore/eventTypes/document.create \<br/>--trigger-resource "projects/&lt;PROJECT_ID&gt;/databases/(default)/documents/movie_reviews/{pushId}"</span></pre><p id="deda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">trigger-event</code>标志表示在Cloud Firestore中创建新文档时应该调用我们的函数。<code class="du jp jq jr js b">trigger-resource</code>标志指定文件创建事件将被监视的Firestore路径。按照我们设置的方式，每当一个新文档被添加到<code class="du jp jq jr js b">movie_reviews</code>顶级集合时，我们的函数就会被触发。这由触发器资源路径末尾的通配符<code class="du jp jq jr js b">{pushId}</code>表示。</p><p id="ec1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署可能需要几分钟时间。您的代码被上传到云中，在那里它被构建和部署为一个无服务器的功能。如果一切顺利，您应该会看到类似下面的输出。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="1c48" class="jt ju ht js b fi lb lc l ld le">Deploying function (may take a while - up to 2 minutes)...done.                                                                                          <br/>availableMemoryMb: 256<br/>entryPoint: ScoreReview<br/>eventTrigger:<br/>  eventType: providers/cloud.firestore/eventTypes/document.create<br/>  failurePolicy: {}<br/>  resource: projects/.../databases/(default)/documents/movie_reviews/{pushId}<br/>  service: firestore.googleapis.com<br/>labels:<br/>  deployment-tool: cli-gcloud<br/>name: projects/.../locations/us-central1/functions/ScoreReview<br/>runtime: go111<br/>serviceAccountEmail: ...<br/>status: ACTIVE<br/>timeout: 60s<br/>updateTime: '2019-01-26T23:02:15Z'<br/>versionId: '1'</span></pre><h2 id="ed02" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">尝试一下</h2><p id="dd8a" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">使用<a class="ae jo" href="https://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>创建一个名为<code class="du jp jq jr js b">movie_reviews</code>的新Firestore集合，并向其中添加一些子文档。每个文档至少应该包含两个字段— <code class="du jp jq jr js b">author</code>和<code class="du jp jq jr js b">text</code>。图1显示了这应该是什么样子。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/8635794caeab90b54b23aa8dd23d27d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qWxaPGCOq15EfduKD5pkA.png"/></div></div></figure><p id="5912" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每添加一个文档都会在几秒钟后触发我们的无服务器功能的执行。从Firebase控制台，您可以观察到用户分数被写入实时数据库，如图2所示。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/585fbbf43552d1406f8600306548b5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*_hVdoBJxHxj5olzrpmNnFQ.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">图Firebase实时数据库中的更新值</figcaption></figure><p id="16ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以在GCP控制台中查看云功能日志，以进一步确认。图3显示了预期的结果。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/028fc4a661bd2a7251eb3620b6a5d185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgZ5szCdJ8JckUpXQVFaKQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">图3:GCP控制台中的云函数日志</figcaption></figure><h2 id="7760" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">结论</h2><p id="38ad" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在本文中，我们研究了从Go中实现的无服务器功能中消费云Firestore事件。我们还使用Firebase Admin SDK与Firebase实时数据库进行交互。这篇文章中描述的技术和API可以用来集成GCP和Firebase中的各种服务。谷歌云功能有助于从云存储、Cloud PubSub、Firebase实时数据库等接收事件。Firebase Admin SDK支持访问Firebase Auth、Firebase Cloud Messaging等服务。针对云函数的Go运行时的可用性意味着开发人员现在可以实现使用上述产品的任意组合的无服务器函数，同时享受Go的简单性、性能和类型安全性。</p></div></div>    
</body>
</html>