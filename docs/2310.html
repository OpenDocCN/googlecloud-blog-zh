<html>
<head>
<title>Apache Beam: Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇光束:测试</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/apache-beam-testing-5684874afb51?source=collection_archive---------1-----------------------#2022-08-19">https://medium.com/google-cloud/apache-beam-testing-5684874afb51?source=collection_archive---------1-----------------------#2022-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为我们的管道编写测试是高效和有效的数据处理软件开发的重要一步。beam中的单元测试通常使用DirectRunner完成，它包含在Java和Python SDK中。</p><p id="08e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对DoFns和PTransforms进行单元测试</strong></p><p id="e6c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够执行这个测试，首先我们可以执行以下方法:</p><ul class=""><li id="4d22" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">创建一个测试管道(请分别参考<a class="ae jm" href="https://beam.apache.org/releases/pydoc/2.29.0/apache_beam.testing.test_pipeline.html#apache_beam.testing.test_pipeline.TestPipeline" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae jm" href="https://beam.apache.org/releases/javadoc/2.29.0/org/apache/beam/sdk/testing/TestPipeline.html" rel="noopener ugc nofollow" target="_blank"> Java </a>)。</li><li id="0151" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">创建一个测试输入数据并使用它作为Create(请分别参考<a class="ae jm" href="https://beam.apache.org/releases/pydoc/2.29.0/apache_beam.transforms.core.html#apache_beam.transforms.core.Create" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae jm" href="https://beam.apache.org/releases/javadoc/2.29.0/org/apache/beam/sdk/transforms/Create.html" rel="noopener ugc nofollow" target="_blank"> Java </a>转换的输入来创建一个PCollection</li><li id="e83a" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">对输入Pcollection应用转换，并将其保存到另一个PCollection</li><li id="2148" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">使用断言实用程序(请分别参考Python中testing.util包中的<a class="ae jm" href="https://beam.apache.org/releases/pydoc/2.29.0/apache_beam.testing.util.html#apache_beam.testing.util.assert_that" rel="noopener ugc nofollow" target="_blank"> assert_that </a>和Java中的<a class="ae jm" href="https://beam.apache.org/releases/javadoc/2.29.0/org/apache/beam/sdk/testing/PAssert.html" rel="noopener ugc nofollow" target="_blank"> PAssert </a>)。</li></ul><p id="c855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TestPipeline是一个特殊的实用类，包含在Beam SDK中，用于测试转换和管道逻辑。当我们测试代码时，我们应该使用TestPipeline而不是Pipeline来创建Pipeline对象。Create transfrom接受内存中的对象集合。目标是从我们的PTransforms中获得一小组测试输入数据，我们知道期望的输出PCollection。Create transfrom获取内存中的对象集合(一个Java iterable ),并从该集合创建一个PCollection。目标是从我们的转换中获得一小组测试输入数据，我们知道期望的输出PCollection。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="bbdd" class="kb kc hi jx b fi kd ke l kf kg"># Creating a TestPipeline in Python<br/>with TestPipeline() as p:<br/>    INPUTS = [fake_input_1, fake_input_2]<br/>    test_output = p | beam.Create(INPUTS) | # Transforms to be tested</span><span id="30ca" class="kb kc hi jx b fi kh ke l kf kg">// Creating a TestPipeline in Java<br/>TestPipeline p = TestPipeline.create();<br/>List&lt;String&gt; input = Arrays.asList(testInput);<br/>outputPColl = p.apply(Create.of(input).apply(...);</span></pre><p id="2d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后我们可以用断言来比较结果和预期结果:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="956b" class="kb kc hi jx b fi kd ke l kf kg"># Using assertion in Python<br/>assert_that(test_output, equal_to(EXPECTED_OUTPUTS))</span><span id="ac25" class="kb kc hi jx b fi kh ke l kf kg">// Using PAssert in Java<br/>PAssert.that(outputPColl).containsInAnyOrder(expectedOutput);</span></pre><p id="adf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用TestStream执行流处理逻辑测试</strong></p><p id="f487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当执行从测试流中读取的管道时，读取会等待每个事件的所有结果完成，然后再继续处理下一个事件，包括当处理时间提前且适当的触发器触发时。TestStream允许触发的效果，并允许在管道上观察和测试延迟。这包括关于延迟触发器和由于延迟而丢弃的数据的逻辑。TestStream类允许我们模拟实时消息流，同时控制处理时间和水印的进度。我们使用InvervalWindow类来定义我们希望检查的窗口，然后使用assertion来检查每个窗口的值(Python使用assert_that和equal_per_window，Java使用inWindow和PAssert)。</p></div></div>    
</body>
</html>