<html>
<head>
<title>Bash hacks gcloud, kubectl, jq etc.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bash hacks gcloud，kubectl，jq等。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bash-hacks-gcloud-kubectl-jq-etc-c2ff351d9c3b?source=collection_archive---------0-----------------------#2017-11-29">https://medium.com/google-cloud/bash-hacks-gcloud-kubectl-jq-etc-c2ff351d9c3b?source=collection_archive---------0-----------------------#2017-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="242e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">优化这些CLI的bash技巧商场</h2></div><p id="6367" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现并收到了一些最优秀的bash和其他CLI技巧，用于优化我使用<a class="ae jt" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank"> gcloud </a>和<a class="ae jt" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>的体验。我将它们列在这里，希望其他人会觉得有用。</p><p id="4d59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个页面是为我(和像我一样的人)准备的，他们知道一定有一个CLI“方法”,但是没有见过，或者因为不经常使用而忘记了正确的解决方案。</p><p id="8506" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将是一个正在进行的职位…我会更新每当我使用一个命令，并认为它可能会感兴趣。</p><h2 id="c38d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">尝试</h2><p id="6499" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我最近用这种方法随机选择一个端点，对它们发出<code class="du ku kv kw kx b">curl</code>命令:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="ed04" class="ju jv hi kx b fi lg lh l li lj"><a class="ae jt" href="https://stackoverflow.com/a/2388555" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/2388555</a></span></pre><p id="b160" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，当路径不容易生成时，这是最有用的，但是，为了举例:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="e13a" class="ju jv hi kx b fi lg lh l li lj">PATHS=("s1" "s2" "s3" "s4")<br/>for TEST in {1..10}<br/>do<br/>  SELECTED_PATH=${PATHS[$RANDOM % ${#PATHS[@]}]}<br/>  VALUE=$((RANDOM%10))<br/>  curl --silent http://echo.jsontest.com/${SELECTED_PATH}/${VALUE}<br/>done</span></pre><h2 id="b2f2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">gcloud</h2><p id="8708" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">列出“我的”(我是其中的成员…)项目，但仅列出项目Id，仅列出项目Id包含“dazwilkin”的项目以及项目ID以“dazwilkin”开头的项目:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="b9fd" class="ju jv hi kx b fi lg lh l li lj">gcloud projects list \<br/>--format='value(projectId)'</span><span id="59d0" class="ju jv hi kx b fi lk lh l li lj">gcloud projects list \<br/>--format='value(projectId)' \<br/>--filter='projectId ~ dazwilkin'</span><span id="696e" class="ju jv hi kx b fi lk lh l li lj">gcloud projects list \<br/>--format='value(projectId)' \<br/>--filter='projectId ~ ^dazwilkin'</span></pre><p id="dc54" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">格式化和过滤的一个挑战是每个CLI都有自己的方式。另一种方法是将输出格式化为JSON或YAML，然后使用通用工具对grep或<a class="ae jt" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>的结果进行后处理(参见<a class="ae jt" href="https://jqplay.org/" rel="noopener ugc nofollow" target="_blank"> jqplay </a>):</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="0f95" class="ju jv hi kx b fi lg lh l li lj">gcloud projects list --format='value(projectId)' \<br/>| grep '^dazwilkin'</span><span id="898c" class="ju jv hi kx b fi lk lh l li lj">gcloud projects list --format='json' \<br/>| jq '.[] | select (.projectId | test("^dazwilkin")) | .projectId'</span></pre><p id="f7af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想要迭代gcloud资源id或名称是很常见的。能够过滤项目并获取项目ID:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="765a" class="ju jv hi kx b fi lg lh l li lj">for PROJECT in $(gcloud projects list --format='value(projectId)')<br/>do<br/>  gcloud iam service-accounts list \<br/>  --filter='value(email)' \<br/>  --project=${PROJECT}<br/>done</span></pre><p id="1ff4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我按天按主题创建项目，一旦完成就立即处理掉。偶尔，我会让虚拟机闲置几天，但要确保它们都已关闭</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="cc47" class="ju jv hi kx b fi lg lh l li lj">PROJECT=[[YOUR-PROJECT-ID]]<br/>INSTANCES=$(gcloud compute instances list \<br/>  --project=$PROJECT \<br/>  --format="value(name)")<br/>gcloud compute instances stop ${INSTANCES} --project=${PROJECT}</span></pre><p id="3248" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个命令获取整个项目(所有区域和分区)的实例列表，并将其指定给实例。第二个命令将它们全部关闭。如果您愿意，可以合并这两个命令。</p><p id="cc61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的同事寻求一种方法来从IAM策略中过滤出“<a class="ae jt" href="https://cloud.google.com/iam/docs/overview#concepts_related_to_identity" rel="noopener ugc nofollow" target="_blank">成员</a>”。另一位同事(感谢格伦！)提供了一种使用gcloud实现这一点的方法:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="2496" class="ju jv hi kx b fi lg lh l li lj">gcloud projects get-iam-policy ${PROJECT} \<br/>--flatten=bindings \<br/>--filter=bindings.role:roles/editor \<br/>--format="value(bindings.members)"</span></pre><blockquote class="ll lm ln"><p id="66bd" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">注:有关“展平”、“过滤”和“格式”的解释，请参见Cloud SDK文档<a class="ae jt" href="https://cloud.google.com/sdk/gcloud/reference/" rel="noopener ugc nofollow" target="_blank">此处</a>和另一位同事的博客帖子<a class="ae jt" href="https://cloudplatform.googleblog.com/2016/06/filtering-and-formatting-fun-with.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></blockquote><p id="1d7c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对正在发生的事情的快速解释。“flatten”标志将策略拆分为多个记录，绑定数组中的每个元素对应一个记录。这对应于每个角色类型一个。“过滤器”然后隔离“角色/编辑”的记录。“format”然后返回binding.members(针对该角色)。</p><p id="b0fb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一种使用jq的方法。</p><p id="4344" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将枚举<code class="du ku kv kw kx b">$PROJECT</code>中<code class="du ku kv kw kx b">$ROLE</code>的成员:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="3752" class="ju jv hi kx b fi lg lh l li lj">ROLE="roles/owner" # for example</span><span id="bfda" class="ju jv hi kx b fi lk lh l li lj">FILTER=".bindings[] | select (.role==\"${ROLE}\") | .members[]"</span><span id="37d7" class="ju jv hi kx b fi lk lh l li lj">gcloud projects get-iam-policy ${PROJECT} --format=json \<br/>| jq --raw-output "${FILTER}"</span></pre><blockquote class="ll lm ln"><p id="93d8" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">注意:这里使用的“raw-output”标志去掉了引号字符串。</p></blockquote><p id="4967" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更复杂但更有用的是，它通过过滤“user”成员并返回不带“user:”前缀的成员详细信息来扩展上面的过滤器:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="6f27" class="ju jv hi kx b fi lg lh l li lj">FILTER=".bindings[] | select (.role==\"${ROLE}\") | .members[] | select (. | startswith(\"user:\")) | ltrimstr(\"user:\")"</span></pre><blockquote class="ll lm ln"><p id="1684" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">注意:当然，您可以用其他类型的成员(“组”、“域”、“服务帐户”)替换“用户”。</p></blockquote><p id="7cac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有讽刺意味的是，我刚知道gcloud的“展平”旗，就有机会再次使用它。一位客户工程师问他如何为所有项目枚举所有集群的节点映像。他想确认他们不再使用现在已经废弃的<a class="ae jt" href="https://cloud.google.com/kubernetes-engine/docs/concepts/node-images#container-vm_deprecated" rel="noopener ugc nofollow" target="_blank">容器-虚拟机</a>映像。</p><p id="d2aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一种方法可以做到这一点:</p><figure class="ky kz la lb fd ls"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="24a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与我们的一位客户聊天，讨论如何克服云日志(控制台)过滤的一个已知限制，这让我想到了下一个问题。目前无法比较云控制台日志中的数值，因为许多数值被记录为字符串。</p><figure class="ky kz la lb fd ls er es paragraph-image"><div class="er es lv"><img src="../Images/6afb4d2b0dbdddc3f280af52c80337ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*V6YG3hqaDYm9JD1uujloOQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">4.7 ≥ 11.0 !！谢谢加布里埃尔</figcaption></figure><p id="45ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个解决方案是使用gcloud以JSON的形式获取日志输出，然后将其注入jq以获得一些魔力:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="8bde" class="ju jv hi kx b fi lg lh l li lj">PROJECT="[YOUR-PROJECT-ID]"<br/>ROOT="projects/${PROJECT}/logs"<br/>LOG="${ROOT}/appengine.googleapis.com%2Fnginx.request"</span><span id="3fdc" class="ju jv hi kx b fi lk lh l li lj">TODAY=$(date +%Y-%m-%d)<br/>AFTER="${TODAY}T00:00:00.000Z"<br/>BEFORE="${TODAY}T23:59:00.000Z"</span><span id="90ac" class="ju jv hi kx b fi lk lh l li lj">FILTER="resource.type=\"gae_app\" "\<br/>"logName=\"${LOG}\" "\<br/>"timestamp&gt;=\"${AFTER}\" "\<br/>"timestamp&lt;=\"${BEFORE}\""</span><span id="5377" class="ju jv hi kx b fi lk lh l li lj">gcloud logging read  "$FILTER" --project=$PROJECT --format=json \<br/>| jq '.[] | {url: .httpRequest.requestUrl, latency: .jsonPayload.latencySeconds} | select (.latency != null) | select (.latency|tonumber &gt; .5)'</span></pre><p id="79e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有很多混乱和混乱，这让它比我们想要的更粗糙，但是…在设置了环境变量之后，为App Engine (Flex)应用程序构建过滤器字符串，只获取Nginx请求日志中今天(UTC)的条目。</p><p id="e1dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，jq从结果中抓取两个键，httpRequest.requestUrl的值(变成' Url ')和jsonPayload.latencySeconds的值(称为' latency '的字符串)。该结果投影({url，latency})被过滤以移除任何为空的延迟值，并且这些结果被过滤以将非空字符串转换成数字，然后仅取出那些大于0.5秒的值。</p><p id="6408" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="3b40" class="ju jv hi kx b fi lg lh l li lj">{<br/>  "url": "/favicon.ico",<br/>  "latency": "0.613"<br/>}<br/>{<br/>  "url": "/",<br/>  "latency": "0.583"<br/>}</span></pre><p id="0fc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我了解到使用带有“持续时间”和“时间戳”值的云日志过滤器是可能的。即使以字符串的形式出现，也可以用数字来比较。上述过滤器的一个细微差别是，请求日志条目包括HTTP请求元数据以及我们上面使用的JSON有效负载数据。HTTP请求元数据包括一个延迟字符串，它实际上是一个持续时间。困惑了吗？在这里阅读更多<a class="ae jt" href="https://cloud.google.com/logging/docs/view/advanced_filters#comparison_operators" rel="noopener ugc nofollow" target="_blank"/>。因为它是一个持续时间值，我们可以这样过滤:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="0262" class="ju jv hi kx b fi lg lh l li lj">gcloud logging read  "$FILTER httpRequest.latency &gt; \"0.5s\"" \<br/>--project=$PROJECT \<br/>--format=json</span></pre><p id="219f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用不同的日志值(httpRequest.latency，而不是jsonPayload.latencySeconds)，但是，因为httpRequest.latency被视为“持续时间”，所以我们可以放弃jq后置过滤，并增加gcloud过滤器以包括改进:http request . latency &gt;“0.5s”。</p><p id="48ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个，这个时间计数App引擎健康检查(两个<a class="ae jt" href="https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml#health_checks" rel="noopener ugc nofollow" target="_blank">口味</a>:遗留和更新)给定模块，版本为时间段之后到之前:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="d5ca" class="ju jv hi kx b fi lg lh l li lj">LOG="{$ROOT}/appengine.googleapis.com%2Fnginx.health_check"</span><span id="0bd9" class="ju jv hi kx b fi lk lh l li lj">MODULE="[YOUR-MODULE]"<br/>VERSION="[YOUR-VERSION]"</span><span id="4e06" class="ju jv hi kx b fi lk lh l li lj">FILTER="resource.type=\"gae_app\" "\<br/>"logName=\"${LOG}\" "\<br/>"resource.labels.module_id=\"${MODULE}\" "\<br/>"resource.labels.version_id=\"${VERSION}\" "\<br/>"timestamp&gt;=\"${AFTER}\" "\<br/>"timestamp&lt;=\"${BEFORE}\""</span><span id="255c" class="ju jv hi kx b fi lk lh l li lj">gcloud logging read "${FILTER}" \<br/>--format="csv[no-heading](httpRequest.status,httpRequest.requestUrl)" \<br/>--project=${PROJECT} \<br/>| sort | uniq -c</span></pre><p id="cae4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="ce35" class="ju jv hi kx b fi lg lh l li lj">XXXX 200,/liveness_check<br/>YYYY 200,/readiness_check</span></pre><p id="1c4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="4498" class="ju jv hi kx b fi lg lh l li lj">ZZZZ 200,/_ah/health</span></pre><h2 id="f829" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">库贝特尔</h2><p id="3ad0" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">如上所述，在CLI(例如gcloud和kubectl)之间切换意味着在过滤和格式方式之间切换。<code class="du ku kv kw kx b">kubectl</code>使用“输出”实现过滤和格式化。我发现kubectl输出比gcloud更容易过滤和格式化，但它仍然主要是试错的。我首先将命令输出为JSON:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="7280" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods --format=json</span></pre><p id="35a4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">API非常一致，多值结果总是在一个“items”数组中，并且许多(所有？)有一个“元数据”部分和一个“名称”。不幸的是，jq使用的查询语言不是JSONPath，因此需要进行转换。kubectl也支持Golang的模板包，但是最近使用得不那么频繁了，而JSONPath更为常见。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="3433" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods \<br/>--format=json \<br/>| jq .items[].metadata.name</span><span id="da27" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods \<br/>--output=jsonpath='{.items[*].metadata.name}'</span><span id="8dad" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods \<br/>--output=go-template='{{range .items}} {{.metadata.name}} {{end}}'</span></pre><p id="b0d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您在Kubernetes中看到的一个常见(因为它非常有用)的模式是用内部命令过滤|格式化外部命令的输出来嵌套kubectl命令，即:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="7712" class="ju jv hi kx b fi lg lh l li lj">kubectl port-forward $(\<br/>  kubectl get pod \<br/>  --selector=app=prometheus \<br/>  --namespace=istio-system \<br/>  --output=jsonpath='{.items[0].metadata.name}'\<br/>  ) \<br/>--namespace=istio-system \<br/>9090:9090 &amp;</span></pre><p id="a5df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubectl有一个有用的端口转发命令，它需要一个端口映射(这里是<code class="du ku kv kw kx b">9090:9090</code>)和pod的名称。在这种情况下，为了确定pod的名称，我们需要识别带有标签的pod(app:Prometheus)。应该只有1个pod符合标准，因此items[0]主要是将结果数组(包含一个项目)转换为单一结果。</p><p id="5c98" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">kubectl命令的另一个常见模式是想要获取一个已知服务的负载平衡器的IP地址:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="f812" class="ju jv hi kx b fi lg lh l li lj">SERVICE=[YOUR-SERVICE]</span><span id="58d8" class="ju jv hi kx b fi lk lh l li lj">NETWORKLB=$(kubectl get services/${SERVICE} \<br/>--output=jsonpath='{.status.loadBalancer.ingress[0].ip }')</span><span id="f802" class="ju jv hi kx b fi lk lh l li lj">curl --silent http://${NETWORKLB}/</span></pre><p id="8ba9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我今天了解到也有一个整洁的“<a class="ae jt" href="https://kubernetes.io/docs/reference/kubectl/overview/#custom-columns" rel="noopener ugc nofollow" target="_blank">自定义列</a>”格式。所以，我在玩Brendan Burns的聪明的<a class="ae jt" href="https://metaparticle.io" rel="noopener ugc nofollow" target="_blank">超粒子</a>项目，并使用它，我部署了一个由15个pod组成的服务，运行在一个区域集群上。一个问题是，默认的output=wide格式太宽，产生了我正在寻找的“节点”名称，但包括了一些我不需要的列。我想要pod名称及其节点的名称，很简单:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="6ba6" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods \<br/>--output=custom-columns=Name:.<strong class="kx hj">metadata.name</strong>,Node:.<strong class="kx hj">spec.nodeName</strong></span></pre><p id="2179" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与大多数这些命令一样，除非您非常熟悉输出结构，否则创建您需要的东西是一个试验过程。在这种情况下，我首先使用通用的YAML输出调用命令，确定我想要的列，然后在custom-columns规范中引用这些列:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="9fbb" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods --output=yaml</span><span id="650e" class="ju jv hi kx b fi lk lh l li lj">apiVersion: v1<br/>items:<br/>- apiVersion: v1<br/>  kind: Pod<br/>  <strong class="kx hj">metadata</strong>:<br/>    labels:<br/>      app: metaparticle-example<br/>      pod-template-hash: "1676060832"<br/>    <strong class="kx hj">name</strong>: metaparticle-example-5bcb4b4d76-42d7m<br/>    namespace: default<br/>  <strong class="kx hj">spec</strong>:<br/>    containers:<br/>      name: metaparticle-example-0<br/>      resources:<br/>        requests:<br/>          cpu: 100m<br/>      terminationMessagePath: /dev/termination-log<br/>      terminationMessagePolicy: File<br/>      volumeMounts:<br/>      - mountPath: /var/run/secrets/kubernetes.io/serviceaccount<br/>        name: default-token-5v5k6<br/>        readOnly: true<br/>    dnsPolicy: ClusterFirst<br/>    <strong class="kx hj">nodeName</strong>: gke-cluster-01-default-pool-5af672df-t4hg</span></pre><p id="f20b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您创建一个服务，并将其作为节点端口公开(在集群之外)。可能是因为您将通过L7负载平衡器引用节点端口。您可能还需要配置防火墙规则来公开群集的节点，这些节点现在都公开此端口。如何快速测试它是否按预期工作？首先，确定节点端口:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="67ca" class="ju jv hi kx b fi lg lh l li lj">SERVICE=[YOUR-SERVICE-NAME]</span><span id="62de" class="ju jv hi kx b fi lk lh l li lj">NODEPORT=$(kubectl get service/${SERVICE} \<br/>--output=jsonpath='{ .spec.ports[0].nodePort }')</span></pre><p id="a7ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后确定集群的一个节点。集群的所有节点都公开了节点端口，因此它们中的任何一个都是可接受的。我们随便抓一个吧。kubectl命令列出了集群节点的名称(以“node/”为前缀)。从结果中剪下前缀“node/”，对结果随机排序并获取第一个:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="013a" class="ju jv hi kx b fi lg lh l li lj">INSTANCE=$(kubectl get nodes --output=name \<br/>| cut --delimiter="/" --fields=2 \<br/>| sort --random-sort \<br/>| head --lines=1)</span></pre><p id="0ab9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们将所有内容结合起来，使用gcloud通过ssh连接到随机选择的集群节点，并将节点端口转发到本地主机。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="f427" class="ju jv hi kx b fi lg lh l li lj">PROJECT=[YOUR-PROJECT-ID]</span><span id="037e" class="ju jv hi kx b fi lk lh l li lj">gcloud compute ssh ${INSTANCE} \<br/>--project=${PROJECT} \<br/>--ssh-flag="-L ${NODEPORT}:localhost:${NODEPORT}"</span></pre><p id="5a31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，根据支持节点端口的内容，您可以从本地主机访问它。如果它是一个简单的HTTP服务，那么您现在可以:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="af1e" class="ju jv hi kx b fi lg lh l li lj">curl localhost:${NODEPORT}</span></pre><p id="8c1b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">反馈总是受欢迎的。</p><p id="5199" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更多即将推出…</p></div></div>    
</body>
</html>