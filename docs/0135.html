<html>
<head>
<title>Highly Available Websockets on Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Cloud上的高可用性Websockets</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/highly-available-websockets-on-google-cloud-c74b35ee20bc?source=collection_archive---------0-----------------------#2016-08-16">https://medium.com/google-cloud/highly-available-websockets-on-google-cloud-c74b35ee20bc?source=collection_archive---------0-----------------------#2016-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3789" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几周前，仍在@Storify工作的@devongovett联系我，分享了一个关于Storify对websockets进行负载平衡的方法的更新。两年前我们写了一篇<a class="ae jd" rel="noopener" href="/@Philmod/load-balancing-websockets-on-ec2-1da94584a5e9#.xepi18k8a">文章</a>来解释我们如何使用IP affinity来使用HAProxy对socket.io进行负载平衡。</p><p id="d149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但使用源IP亲缘关系进行平衡可能会导致问题:<a class="ae jd" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank"> socket.io </a>的轮询传输在一些企业网络上中断，在这些网络上，它们跨多个外部IP地址对流量进行负载平衡。在这种情况下，与特定会话id相关联的请求可能会连接到不同的进程，这将破坏socket.io为该特定会话缓冲消息的方式。</p><p id="efa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是切换到具有会话cookie的应用层持久性解决方案。</p><p id="f226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我给你举个例子。</p><h1 id="1a76" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">聊天示例</h1><p id="360e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我将使用稍微修改过的<a class="ae jd" href="http://socket.io/get-started/chat/" rel="noopener ugc nofollow" target="_blank"> socket.io聊天示例</a>的版本，将它分成两个服务器。</p><p id="541f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<a class="ae jd" href="https://github.com/Philmod/node-example-frontend" rel="noopener ugc nofollow" target="_blank">服务器</a>将负责服务单个HTML页面。另一个<a class="ae jd" href="https://github.com/Philmod/node-example-websocket" rel="noopener ugc nofollow" target="_blank">服务器</a>将负责向所有聊天用户广播消息。</p><p id="fb6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在生产环境中，HTML页面应该由<a class="ae jd" href="https://cloud.google.com/cdn/" rel="noopener ugc nofollow" target="_blank"> CDN </a>交付。但是在演示中，我想展示我们如何对HTTP和Websocket请求进行负载平衡。</p><p id="c402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在websocket服务器之间传递消息，我们将使用Redis <a class="ae jd" href="http://socket.io/docs/using-multiple-nodes/#passing-events-between-nodes" rel="noopener ugc nofollow" target="_blank">适配器</a>。当连接到<em class="kh">实例-websocket-1 </em>服务器的用户A发送消息时，该消息可以广播给连接到<em class="kh">实例-websocket-2 </em>的用户。</p><h1 id="7994" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">负载平衡流量</h1><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/6a41959e726a6880828a172ba3be1f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*PFreHnOSLhDili0uglerpw.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">全网络图</figcaption></figure><p id="7a6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌云平台提供了一个TCP负载平衡器，它将被用作我们网络的公共入口点。它将在许多HAProxy实例之间对流量进行负载平衡。</p><p id="2af3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> HAProxy </strong>将负责将流量重定向到所需的后端服务器(frontend或websocket)，并确保来自同一用户的socket.io请求总是进入同一进程。如果客户端不支持WebSocket协议，因此会退回到轮询传输，这一点非常重要。</p><h1 id="46e3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">HAProxy <a class="ae jd" href="https://gist.github.com/Philmod/21b7c8fbd5a2bc20987141bc99966951" rel="noopener ugc nofollow" target="_blank">配置</a></h1><p id="87d2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，<a class="ae jd" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>将侦听端口80上的所有传入流量，并根据子域(“ws”)将其重定向到websocket后端)，否则发送到HTTP后端。</p><pre class="kj kk kl km fd ku kv kw kx aw ky bi"><span id="9cab" class="kz jf hi kv b fi la lb l lc ld">frontend public<br/>  bind *:80<br/>  maxconn 10000<br/>  acl is_websocket hdr_end(host) -i ws.node-example.com<br/>  use_backend ws if is_websocket<br/>  default_backend www</span></pre><p id="d683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP后端配置非常简单。它使用“循环”策略来平衡流量负载。让我们不要忘记定义HTTP check url，这样HAProxy就知道其中一个服务器何时出现故障。我发现添加一个用于调试目的的查询字符串很有用。</p><pre class="kj kk kl km fd ku kv kw kx aw ky bi"><span id="9197" class="kz jf hi kv b fi la lb l lc ld">backend www<br/>  timeout check 5000<br/>  option httpchk GET /status?haproxy=1<br/>  balance roundrobin<br/>  server www1 10.142.0.3:3001 maxconn 1000 weight 10 check inter 10000 rise 1 fall 3<br/>  server www2 10.142.0.6:3001 maxconn 1000 weight 10 check inter 10000 rise 1 fall 3</span></pre><p id="8288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">神奇之处在于websocket后端配置。如果支持WebSocket协议，就不会有问题，因为只使用了一个tcp连接。但是在回退到轮询传输的情况下，许多连接都是到后端的。在第一次请求时，HAProxy设置一个cookie，指定使用哪个服务器，然后它使用这个cookie为后续请求选择同一个服务器。</p><pre class="kj kk kl km fd ku kv kw kx aw ky bi"><span id="873c" class="kz jf hi kv b fi la lb l lc ld">backend ws<br/>  timeout check 5000<br/>  option httpchk GET /status?haproxy=1<br/>  balance roundrobin<br/>  cookie HAPROXY_WS_COOKIE insert indirect nocache<br/>  server ws1 10.142.0.4:3002 maxconn 1000 weight 10 check inter 10000 rise 1 fall 3 check cookie ws1<br/>  server ws2 10.142.0.7:3002 maxconn 1000 weight 10 check inter 10000 rise 1 fall 3 check cookie ws2</span></pre><h1 id="56e7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Google云负载平衡器配置</h1><p id="42d5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">TCP <a class="ae jd" href="https://cloud.google.com/load-balancing/" rel="noopener ugc nofollow" target="_blank">负载平衡器</a>负责平衡端口80上的传入公共流量到HAProxy实例。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/6fb6c5fe3c30ce60f2337063c419576b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6AXMkn442thyK_PsEUFlg.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">Google云负载平衡器配置</figcaption></figure><h1 id="13ac" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">演示</h1><p id="35d2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我在聊天页面中添加了一些信息，以便于检查整个系统:</p><ul class=""><li id="4b52" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">“Html服务器”显示哪个HTTP后端服务于该页面。</li><li id="969c" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">“Websocket服务器”显示哪个websocket后端在监听用户的消息。</li><li id="8219" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">当页面连接/断开websocket后端时，会出现一条彩色消息。</li></ul><h2 id="c9f5" class="kz jf hi bd jg lx ly lz jk ma mb mc jo iq md me js iu mf mg jw iy mh mi ka mj bi translated">粘性会话</h2><p id="7da8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">通过刷新页面，我们可以看到html由两个后端服务器提供服务，但是websocket总是连接到同一个(原始)服务器。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mk"><img src="../Images/022e4bb5dfd448a18a518b9003ca1f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*viG_BlSrBISz3ww8dMagpw.gif"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">前端负载平衡<strong class="bd jg"><em class="ml">vs</em></strong>web socket cookie会话</figcaption></figure><h2 id="467a" class="kz jf hi bd jg lx ly lz jk ma mb mc jo iq md me js iu mf mg jw iy mh mi ka mj bi translated">死websocket后端</h2><p id="7ea9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果websocket后端失败，用户将重新连接到另一个实例。在这个例子中，我们的用户连接到<em class="kh">实例-websocket-2 </em>，这个实例死亡，用户重新连接到<em class="kh">实例-websocket-1 </em>。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mm"><img src="../Images/1621623f3b0ecbbb80f0e5a975f36a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*0lRPn5OrFR1RglqPTQ4Dqg.gif"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">重新连接到健康的websocket后端</figcaption></figure><h2 id="8dbc" class="kz jf hi bd jg lx ly lz jk ma mb mc jo iq md me js iu mf mg jw iy mh mi ka mj bi translated">死亡的HAProxy实例</h2><p id="b52f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当一个HAProxy实例死亡时，Google Cloud负载平衡器会将所有流量重定向到其他HAProxy实例。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mm"><img src="../Images/a85c63d31d02dc079efed44a70b427b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*V0sEx31ehnCAIVQo0_TWSw.gif"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">死亡的HAProxy实例</figcaption></figure><h1 id="aee7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="6e3d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这整个堆栈为我们提供了一个健壮的方法来扩展我们的服务，它使用socket.io进行通信。</p><p id="a84e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HAProxy提供了微调流量重定向到所需微服务的能力，并提供了为socket.io附加会话cookie的必要选项。</p></div></div>    
</body>
</html>