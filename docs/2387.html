<html>
<head>
<title>A Cloud Run service in Go calling a Workflows callback endpoint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的云运行服务调用工作流回调端点</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-cloud-run-service-in-go-calling-a-workflows-callback-endpoint-7827ce5b77bc?source=collection_archive---------0-----------------------#2022-09-27">https://medium.com/google-cloud/a-cloud-run-service-in-go-calling-a-workflows-callback-endpoint-7827ce5b77bc?source=collection_archive---------0-----------------------#2022-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">都是理查德·塞罗特的错，我最终和<a class="ae jd" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank">戈朗</a>有了瓜葛！我们讨论了使用谷歌云<a class="ae jd" href="https://cloud.google.com/workflows" rel="noopener ugc nofollow" target="_blank">工作流</a>和在Go中实现的<a class="ae jd" href="https://cloud.run/" rel="noopener ugc nofollow" target="_blank">云运行</a>服务的用例。所以这是一个玩围棋的机会。嗯，我还是不喜欢错误处理…但是让我们倒回一下故事吧！</p><p id="247d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Workflows是Google Cloud上的一个完全托管的服务/API orchestrator。您可以使用YAML语法创建一些高级业务工作流。我用它构建了许多小项目，并且<a class="ae jd" href="https://cloud.google.com/blog/topics/developers-practitioners/introducing-workflows-callbacks" rel="noopener ugc nofollow" target="_blank">在博客</a>上写了关于它的内容。我特别喜欢它暂停工作流执行的能力，创建一个<a class="ae jd" href="https://cloud.google.com/workflows/docs/creating-callback-endpoints" rel="noopener ugc nofollow" target="_blank">回调端点</a>，您可以从外部系统调用它来恢复工作流的执行。通过回调，您能够实现人工验证步骤，例如在一个费用报告应用程序中，经理验证或拒绝团队中某个人的费用(这是我在这篇文章<a class="ae jd" href="https://cloud.google.com/blog/topics/developers-practitioners/smarter-applications-document-ai-workflows-and-cloud-functions" rel="noopener ugc nofollow" target="_blank">中实现的)。</a></p><p id="0840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我和Richard的用例，我们有一个创建这样一个回调端点的工作流。这个端点是从Go中实现的云运行服务调用的。让我们看看如何实现工作流:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="6946" class="jn jo hi jj b fi jp jq l jr js">main:<br/>    params: [input]<br/>    steps:</span><span id="0c4f" class="jn jo hi jj b fi jt jq l jr js">    - create_callback:<br/>        call: events.create_callback_endpoint<br/>        args:<br/>            http_callback_method: "POST"<br/>        result: callback_details</span><span id="4876" class="jn jo hi jj b fi jt jq l jr js">    - log_callback_creation:<br/>        call: sys.log<br/>        args:<br/>            text: ${"Callback created, awaiting calls on " + callback_details.url}</span><span id="6650" class="jn jo hi jj b fi jt jq l jr js">    - await_callback:<br/>        call: events.await_callback<br/>        args:<br/>            callback: ${callback_details}<br/>            timeout: 86400<br/>        result: callback_request</span><span id="b079" class="jn jo hi jj b fi jt jq l jr js">    - log_callback_received:<br/>        call: sys.log<br/>        args:<br/>            json: ${callback_request.http_request}</span><span id="6a91" class="jn jo hi jj b fi jt jq l jr js">    - return_callback_request:<br/>        return: ${callback_request.http_request}</span></pre><p id="68d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的工作流定义创建了一个回调端点。第一步返回回调端点的URL。那么工作流正在等待从外部调用回调端点。然后继续执行，记录一些关于传入调用的信息并返回。</p><p id="b303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用一个服务帐户部署了该工作流，该服务帐户具有工作流编辑者角色、日志写入者角色(记录信息)和服务帐户令牌创建者角色(创建OAuth2令牌)，正如文档中的<a class="ae jd" href="https://cloud.google.com/workflows/docs/creating-callback-endpoints#oauth-token" rel="noopener ugc nofollow" target="_blank">所解释的那样。</a></p><p id="3b93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看看Go服务。我做了一个go mod init来创建一个新项目。我创建了一个main.go源文件，内容如下:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="cfb3" class="jn jo hi jj b fi jp jq l jr js">package main</span><span id="6b40" class="jn jo hi jj b fi jt jq l jr js">import (<br/>    metadata "cloud.google.com/go/compute/metadata"<br/>    "encoding/json"<br/>    "fmt"<br/>    "log"<br/>    "net/http"<br/>    "os"<br/>    "strings"<br/>)</span></pre><p id="1dd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元数据模块用于从<a class="ae jd" href="https://cloud.google.com/run/docs/container-contract#metadata-server" rel="noopener ugc nofollow" target="_blank">云运行元数据服务器</a>获取OAuth2令牌。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="fad2" class="jn jo hi jj b fi jp jq l jr js">// OAuth2 JSON struct<br/>type OAuth2TokenInfo struct {<br/>     // defining struct variables<br/>     Token      string `json:"access_token"`<br/>     TokenType  string `json:"token_type"`<br/>     Expiration uint32 `json:"expires_in"`<br/>}</span></pre><p id="47f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">instance/service-accounts/default/token中的元数据信息返回一个JSON文档，我们用上面的struct映射它。我们对access_token字段感兴趣，我们使用它对工作流回调端点进行身份验证调用。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="9acb" class="jn jo hi jj b fi jp jq l jr js">func main() {<br/>    log.Print("Starting server...")<br/>    http.HandleFunc("/", handler)</span><span id="1ff5" class="jn jo hi jj b fi jt jq l jr js">    // Determine port for HTTP service.<br/>    port := os.Getenv("PORT")<br/>    if port == "" {<br/>        port = "8080"<br/>        log.Printf("Defaulting to port %s", port)<br/>    }</span><span id="3bbd" class="jn jo hi jj b fi jt jq l jr js">    // Start HTTP server.<br/>    log.Printf("Listening on port %s", port)<br/>    if err := http.ListenAndServe(":"+port, nil); err != nil {<br/>        log.Fatal(err)<br/>   }<br/>}</span></pre><p id="b0ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">main()函数启动我们的Go服务。现在让我们更详细地看看handler()函数:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ef65" class="jn jo hi jj b fi jp jq l jr js">func handler(w http.ResponseWriter, r *http.Request) {<br/>    callbackUrl := r.URL.Query().Get("callback_url")<br/>    log.Printf("Callback URL: %s", callbackUrl)</span></pre><p id="72c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们找回了。将包含回调端点url的callback_url查询参数。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b606" class="jn jo hi jj b fi jp jq l jr js">    // Fetch an OAuth2 access token from the metadata server<br/>    oauthToken, errAuth := metadata.Get("instance/service-accounts/default/token")<br/>    if errAuth != nil {<br/>        log.Fatal(errAuth)<br/>    }</span></pre><p id="1109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面，我们通过metadata Go模块调用了元数据服务器。然后，我们在之前定义的结构中解组返回的JSON文档，代码如下:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="d320" class="jn jo hi jj b fi jp jq l jr js">    data := OAuth2TokenInfo{}<br/>    errJson := json.Unmarshal([]byte(oauthToken), &amp;data)<br/>    if errJson != nil {<br/>        fmt.Println(errJson.Error())<br/>    }<br/>    log.Printf("OAuth2 token: %s", data.Token)</span></pre><p id="8b74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是准备调用我们的工作流回调端点的时候了，有一个POST请求:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="17fc" class="jn jo hi jj b fi jp jq l jr js">    workflowReq, errWorkflowReq := http.NewRequest("POST", callbackUrl, strings.NewReader("{}"))<br/>    if errWorkflowReq != nil {<br/>        fmt.Println(errWorkflowReq.Error())<br/>    }</span></pre><p id="b82e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过报头添加OAuth2令牌作为载体授权:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="255e" class="jn jo hi jj b fi jp jq l jr js">    workflowReq.Header.Add("authorization", "Bearer "+data.Token)<br/>    workflowReq.Header.Add("accept", "application/json")<br/>    workflowReq.Header.Add("content-type", "application/json")</span><span id="c5a7" class="jn jo hi jj b fi jt jq l jr js">    client := &amp;http.Client{}<br/>    workflowResp, workflowErr := client.Do(workflowReq)<br/>    if workflowErr != nil {<br/>        fmt.Printf("Error making callback request: %s\n", workflowErr)<br/>    }<br/>    log.Printf("Status code: %d", workflowResp.StatusCode)</span><span id="22a5" class="jn jo hi jj b fi jt jq l jr js">    fmt.Fprintf(w, "Workflow callback called. Status code: %d", workflowResp.StatusCode)<br/>}</span></pre><p id="c7bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只是在Go服务结束时返回状态代码。</p><p id="cd52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了部署Go服务，我简单地使用了源部署方法，运行gcloud run deploy，并回答一些问题(服务名、区域部署等。)几分钟后，服务启动并运行。</p><p id="dd68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从Google Cloud控制台创建了一个新的工作流执行。一旦启动，它就记录回调端点URL。我复制它的值，然后用？callback_url=指向该url的查询字符串。瞧，服务恢复工作流的执行，工作流结束。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="f7ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kb">最初发表于</em><a class="ae jd" href="https://glaforge.appspot.com/article/a-cloud-run-service-in-go-calling-a-workflows-callback-endpoint" rel="noopener ugc nofollow" target="_blank">T5【https://glaforge.appspot.com】</a><em class="kb">。</em></p></div></div>    
</body>
</html>