<html>
<head>
<title>Kubernetes and Worker Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes和工人队列</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-and-worker-queues-c02fa56a0e31?source=collection_archive---------2-----------------------#2022-11-14">https://medium.com/google-cloud/kubernetes-and-worker-queues-c02fa56a0e31?source=collection_archive---------2-----------------------#2022-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3dfd8a68a900f1e3f1792a372716a9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gAEStLNQ6l0pEHevqBhuGQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">利瓦伊·琼斯在<a class="ae iu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2240" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几个月前，我在<a class="ae iu" href="https://oss-review-toolkit.org/" rel="noopener ugc nofollow" target="_blank">Eclipse OSS Review Toolkit</a>(ORT)的朋友找到我，寻求一些关于Kubernetes的指导。ORT允许您设置一个工具链来管理源代码中的OSS依赖关系，并且如果您将它作为CI/CD工具链的一部分进行集成，可以在早期避免OSS许可冲突。</p><p id="f356" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">他们希望实现按需扫描服务。基本上从触发器运行OSS扫描。在Java生态系统中，ORT主要是用Kotlin编写的，其范例通常是解决JVM进程内的挑战。因此，您可以使用类似于<a class="ae iu" href="http://www.quartz-scheduler.org/" rel="noopener ugc nofollow" target="_blank"> Quartz </a>的作业调度器，或者类似于<a class="ae iu" href="https://www.jobrunr.io/en/" rel="noopener ugc nofollow" target="_blank"> JobRunr </a>的更新工具来调度异步作业执行。这可能导致Java生态系统中的应用程序变得功能和框架过载。此外，在Java中配置分布式作业队列技术在状态和可靠性方面也具有挑战性。但是我们可以很容易地区分关于web队列工作器设置的多个不同的关注点:</p><ul class=""><li id="2fb8" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">有一个启动作业的客户端</li><li id="be01" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">有一个控制器来调度和跟踪作业的执行</li><li id="794c" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">有一个执行作业的执行器</li></ul><p id="cce4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于他们正在运行一个OSS项目，他们希望保持云供应商中立，尽管一个共同的标准是Kubernetes，因为它现在广泛可用。在这篇博文中，我将使用谷歌云平台服务(GCP)，但是解决方案应该适用于所有的Kubernetes (K8S)发行版。</p><p id="cdcc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想跳过这一步，可以前往ORT repo检查源代码。</p><div class="kh ki ez fb kj kk"><a href="https://github.com/oss-review-toolkit/ort/tree/main/integrations/tekton" rel="noopener  ugc nofollow" target="_blank"><div class="kl ab dw"><div class="km ab kn cl cj ko"><h2 class="bd hj fi z dy kp ea eb kq ed ef hh bi translated">主oss上的ort/integrations/tek ton-审查-工具包/ort</h2><div class="kr l"><h3 class="bd b fi z dy kp ea eb kq ed ef dx translated">这个示例管道允许您在Tekton上运行ORT。一些关于Tekton和Kubernetes的知识将有助于…</h3></div><div class="ks l"><p class="bd b fp z dy kp ea eb kq ed ef dx translated">github.com</p></div></div><div class="kt l"><div class="ku l kv kw kx kt ky io kk"/></div></div></a></div><p id="1231" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我决定做一个简单的概念验证来展示如何在K8S上实现这一点。因为我想利用云原生生态系统，所以我不必在这里重新发明轮子，而是可以为问题选择一个好的实现。我的决定落在了<a class="ae iu" href="https://tekton.dev/" rel="noopener ugc nofollow" target="_blank"> Tekton </a>上，这是一个云原生的CI/CD框架。Tekton是围绕几个带有控制器实现的K8S自定义资源定义(CRD)构建的。这意味着Tekton工作不需要额外的数据库，因为所有状态都保存在K8S集群中。</p><p id="811c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按照<a class="ae iu" href="https://tekton.dev/docs/pipelines/install/" rel="noopener ugc nofollow" target="_blank">安装说明</a>可以轻松设置Tekton。你只需要调用<code class="du kz la lb lc b">kubectl apply --filename <a class="ae iu" href="https://storage.googleapis.com/tekton-release/pipeline/latest/release.yaml" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/tekton-release/pipeline/latest/release.yaml</a></code>。这将为Tekton安装CRDs和控制器。Tekton是一个可扩展的框架，您可以创建和安装自己的任务类型，对于ORT示例，您需要安装<a class="ae iu" href="https://hub.tekton.dev/tekton/task/git-clone" rel="noopener ugc nofollow" target="_blank"> git-clone </a>和<a class="ae iu" href="https://hub.tekton.dev/tekton/task/gcs-upload" rel="noopener ugc nofollow" target="_blank"> gcs-upload </a>任务。</p><p id="0405" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这之后，我们可以定义我们的管道(参见<a class="ae iu" href="https://github.com/oss-review-toolkit/ort/blob/main/integrations/tekton/ort-pipeline.yaml" rel="noopener ugc nofollow" target="_blank"> ort-pipeline.yaml </a>作为例子)。管道定义了应该运行的步骤，以及哪些输出和输入工作区(想想文件夹)，管道需要存储和读取数据。一旦定义了管道，您就可以通过创建一个<code class="du kz la lb lc b">PipelineRun</code>资源来运行它。(例如<a class="ae iu" href="https://github.com/oss-review-toolkit/ort/blob/main/integrations/tekton/simple-maven.yaml" rel="noopener ugc nofollow" target="_blank"> simple-maven.yaml </a>)。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/d78ca9601052d61a31c0e6e14a2a5948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9_pt-73CBcrh9WY5Ms5jw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">成功扫描了<a class="ae iu" href="https://github.com/jshttp/mime-types" rel="noopener ugc nofollow" target="_blank"> mime-types repo </a></figcaption></figure><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/296809dbdc91343a81111dbfcddb4f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iT2JXtLUzQkoLorZVrgUkw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">对简单maven回购的不成功扫描<a class="ae iu" href="https://github.com/MarcelBochtler/maven-simple" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="71cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于每次我们想要执行管道时调用<code class="du kz la lb lc b">kubectl apply</code>有点麻烦，并且不是真正的生产就绪，Tekton还提供了<a class="ae iu" href="https://tekton.dev/docs/triggers/" rel="noopener ugc nofollow" target="_blank">触发器和事件监听器</a>，利用它们你可以设置常见的模式，比如基于<a class="ae iu" href="https://github.com/tektoncd/triggers/tree/main/examples/v1beta1/cron" rel="noopener ugc nofollow" target="_blank"> Cron的</a>触发器，基于<a class="ae iu" href="https://github.com/tektoncd/triggers/tree/main/examples/v1beta1/github" rel="noopener ugc nofollow" target="_blank"> Webhook的触发器</a>用于拉请求和Git提交，甚至是基于<a class="ae iu" href="https://github.com/tektoncd/triggers/blob/main/examples/v1beta1/cloudevent/eventlistener.yaml" rel="noopener ugc nofollow" target="_blank">云事件</a>的监听器。</p><p id="596b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我看来，如果你正在寻找一个厂商中立的基于K8S的CI/CD解决方案，你应该试试Tekton。但是在CI/CD场景之外，它还有更多有用的用例，因为它基本上允许您基于触发器编排任务，这是许多应用程序都有的用例。与K8S作业相比，它在多步骤工作流程方面提供了更多功能。当然，如果你想做工作流程编排，并且乐于使用完全托管的解决方案，你可以尝试一下<a class="ae iu" href="https://cloud.google.com/workflows" rel="noopener ugc nofollow" target="_blank">谷歌云工作流程</a>。</p></div></div>    
</body>
</html>