<html>
<head>
<title>Approach 1 - Integrating Gitlab repository with Cloud Build Triggers via webhook | CI/CD pipelines with GKE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">方法1——通过GKE的webhook | CI/CD管道将Gitlab存储库与云构建触发器集成</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/approach-1-integrating-gitlab-repository-with-cloud-build-triggers-via-webhook-and-creating-ci-cd-2f9d3327936b?source=collection_archive---------0-----------------------#2022-10-14">https://medium.com/google-cloud/approach-1-integrating-gitlab-repository-with-cloud-build-triggers-via-webhook-and-creating-ci-cd-2f9d3327936b?source=collection_archive---------0-----------------------#2022-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好👋在这篇博客中，我们将从Gitlab资源库中构建代码，并通过将它与云构建集成，将我们的代码部署到Google Kubernetes引擎。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0a435cea4e5a7380834fc446c4e7ba25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7C8Nzlvv0ayYmn9kuahxg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">尼古拉斯·冈萨雷斯在<a class="ae jt" href="https://unsplash.com/s/photos/screen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="15ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，云构建触发器没有提供从Gitlab库构建代码的直接选项。只有Github、Bitbucket和Google Source Repository可用。因此，要选择Gitlab作为源代码库，我们有两种方法。</p><p id="4a98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法1 </strong> —为了用Gitlab构建我们的代码，我们需要引入Gitlab <a class="ae jt" href="https://docs.gitlab.com/ee/user/project/integrations/webhooks.html" rel="noopener ugc nofollow" target="_blank"> webhooks </a>来构建我们的代码，并自动构建以响应webhook事件。</p><p id="21fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" rel="noopener" href="/@sanketbisne/approach2-mirroring-csr-and-gitlab-repository-to-create-cloud-build-triggers-and-automate-the-cicd-524c743ee669"> <strong class="ih hj">方法2</strong></a><strong class="ih hj">——</strong>(<strong class="ih hj"><em class="ju">最佳练习</em> </strong>)。通过在Gitlab和Google Cloud Source Repository之间创建库镜像，使用CSR(Cloud Source Repository)提供的高级功能。在这个方法中，我们将首先镜像Gitlab存储库，然后我们将选择云源存储库作为我们的云构建触发器中的源。</p><p id="ea31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们将讨论第一种方法<strong class="ih hj"/></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/ab3a9fe60b4c2297a5666b31ea88e96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YSoAR6hItviAiXmfGWAKw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">GCP支持的源代码库。</figcaption></figure><p id="5998" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总流量(方法1) </strong></p><ul class=""><li id="3413" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">因此，每当我们将代码推送到Gitlab存储库时，请求将首先发送到Gitlab webhook。</li><li id="aa4e" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">Gitlab webhook将请求转发给GCP秘密经理。</li><li id="a8fb" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">云构建将从GCP秘密管理器获取秘密值(私钥)。</li><li id="58a8" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">现在，Cloud Build inline yaml中提到的步骤将在容器中执行。</li></ul><p id="efcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">— CICD管道步骤如下:</p><ul class=""><li id="1b9c" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">复制SSH密钥。</li><li id="463a" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">克隆Gitlab存储库。</li><li id="4845" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">构建代码并标记图像。</li><li id="b55b" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">将其推送到Google容器注册中心，并部署到GKE集群中。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/cb7e8369f0fd6c755bad526028b75ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErpUbu-Jnu2LVKLxgTPqow.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">CICD的建筑流程</figcaption></figure><p id="fbdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Webhook触发器可以验证和接受传入的webhook事件。这些事件被发送到一个自定义的URL，允许我们直接连接到外部系统和外部源代码管理系统，如Bitbucket、Bitbucket Server或Gitlab，以通过webhook事件进行云构建。</p><p id="d079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用webhook触发器，我们可以定义一个内联构建配置文件，而不是在创建触发器时指定一个源。内联构建配置使我们能够控制git操作，并定义其余的构建。<br/>为了开始我们的Gitlab和云构建之旅，下面是我们今后将遵循的步骤。</p><p id="d43e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先决条件:我们需要为云构建、秘密管理器、GKE和本教程中使用的服务启用API。我们需要一个子网VPC、具有最低特权权限的服务帐户和一个已创建的GKE集群。</p><p id="961b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过Terraform配置我们的基础设施。<br/>下面的存储库向我们展示了shell脚本，使API和terraform代码能够构建以下资源。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kl"><img src="../Images/fd63438b446afe93de2c6cf476b3a724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBV1OUgnFryOONO0BQI2xw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">地形资源</figcaption></figure><p id="f00a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">克隆下面的库并签出到“webhook”分支</p><pre class="je jf jg jh fd km kn ko kp aw kq bi"><span id="51e7" class="kr ks hi kn b fi kt ku l kv kw">git clone <a class="ae jt" href="https://github.com/sanketbisne/gcp-terraform-resources.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sanketbisne/gcp-terraform-resources.git</a> </span><span id="345f" class="kr ks hi kn b fi kx ku l kv kw">cd gcp-terraform-resources</span><span id="f2e3" class="kr ks hi kn b fi kx ku l kv kw">git checkout webhook</span></pre><div class="ky kz ez fb la lb"><a href="https://github.com/sanketbisne/gcp-terraform-resources" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">GitHub-sanketbisne/GCP-terra form-resources</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">此库包括以下资源的地形模块:将有两个目录子模块-&gt;…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">github.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jn lb"/></div></div></a></div><p id="a9f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤</strong> : <br/> 1。准备我们的代码。<br/> 2。生成用于身份验证的SSH密钥。<br/> 3。将生成的SSH密钥存储在Secret Manager中。我们将在Gitlab中存储我们的公钥，在GCP秘密管理器中存储私钥。<br/> 4。正在创建内联生成配置文件。<br/> 5。将我们的代码推送到Gitlab，并触发Cloud Build来构建和部署我们的代码更改。</p><p id="3394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。准备我们的代码</strong> <br/>让我们从创建一个Gitlab存储库开始，并将我们的代码放入其中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/add55dd72b021d1ec64a7947f3339989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmDP6XVbbX_mhMflI5KNNg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">创建一个示例Gitlab存储库</figcaption></figure><p id="bfd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。为认证目的生成我们的SSH密钥:</strong> <br/>现在让我们创建我们的SSH密钥，以便认证我们到Gitlab的连接。创建SSH密钥后，我们需要在创建webhook时，在GCP秘密管理器中添加我们的私钥，在Gitlab中添加我们的公钥。</p><p id="fabd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要在云构建触发器中指定的内联构建配置中检索我们的SSH密钥，并在它下面指定一个版本。</p><p id="0df2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过以下命令创建我们的SSH密钥。</p><pre class="je jf jg jh fd km kn ko kp aw kq bi"><span id="0646" class="kr ks hi kn b fi kt ku l kv kw">ssh-keygen -t rsa -b 4096 -N '' -C gitlab.com -f &lt;our gitlab id&gt;</span></pre><p id="1a47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到生成了2个密钥。即公钥和私钥</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/2827233285f41564171f7f0eaa436da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGympqag7YupapKddHzzyA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">公钥和私钥</figcaption></figure><p id="b64b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要添加我们的。Gitlab的ssh密钥部分中的pub密钥。<br/>进入Gitlab &gt; &gt;个人资料&gt; &gt;首选项&gt; &gt; SSH按键</p><p id="a703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击打开。pub文件，复制密钥并将其添加到Gitlab部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/42f9f3b9fc6e63661dd924eadb89e86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sk1DAiQs4sjy4jh6wVPYQQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Gitlab SSH密钥</figcaption></figure><p id="bb51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。存储生成的SSH密钥。Gitlab中的公钥和secret manager中的私钥:</strong></p><p id="7d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">秘密:我们需要一个秘密来验证我们进入的webhook事件。</p><ul class=""><li id="e779" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">在Gitlab中存储了我们的公钥之后，现在我们需要在GCP秘密管理器中存储我们的私钥。这个私钥用于调用我们的构建，它验证并授权我们传入的webhook事件到云构建。</li><li id="40b9" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">单击我们之前生成的上传文件(我们的私钥)，它将自动填充秘密值。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/6337752627480d6e28d0d41a29158158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcQby9hQSFnMATTZw049Vw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">秘密经理</figcaption></figure><p id="a91b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击create <strong class="ih hj"> secret </strong>，secret创建后将会有一个默认版本v1，我们在创建云构建触发器时必须选择该版本。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/f27c2f764e8d20562b98856448e005f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUYRk1sfuzPd1L3hR3DvBA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Webhook Url从秘密管理器获取秘密</figcaption></figure><p id="16d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦选中我们现有的秘密，我们就可以看到一个<strong class="ih hj"> webhook URL预览</strong>。我们的URL将包含由云构建生成的API密钥和我们的秘密。我们的webhook URL如下所示:</p><pre class="je jf jg jh fd km kn ko kp aw kq bi"><span id="811c" class="kr ks hi kn b fi kt ku l kv kw"><em class="ju">https://cloudbuild.googleapis.com/v1/projects/&lt;$PROJECT_ID&gt;/triggers/s8-gitlab-cloudbuild-trigger:webhook?key=&lt;SECRET VALUE&gt;secret=-----BEGIN%20OPENSSH%20PRIVATE%20KEY-----&lt;SECRET_VALUE&gt;0A-----END%20OPENSSH%20PRIVATE%20KEY</em><br/></span></pre><p id="9825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个完整的url需要添加到Gitlab webhook中，我们将在接下来的步骤中看到。</p><p id="8288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击inline yaml并在替换下添加以下细节作为<code class="du lt lu lv kn b">_TO_SHA$ = (body.after) and _BRANCH$ =(body.ref)</code>变量和<br/>过滤器，如主/开发分支。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/77f2b5a7c9a3b191bc2bfeaae79d1040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lybG2Tt8Mt-CkmG0pSPOZA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">编辑触发器以添加替代变量和过滤器</figcaption></figure><p id="218d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击过滤器，添加每当有分支推入时需要触发的分支。因为默认情况下，如果我们没有在filter中指定任何分支，它将从任何分支构建代码。</p><p id="c500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到过滤器并添加以下值</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/2fca0fd705b02259e9c56b122a05cfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjmzLJ2xj3RRIbKtpeasEw.png"/></div></div></figure><p id="20c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Variable=_BRANCH <br/>运算符=matches <br/> Regex值=refs/heads/main</p><p id="12e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。创建我们的内联构建内联配置文件。<br/> </strong>这些步骤添加ssh密钥、克隆存储库、签入主分支、构建docker映像、标记映像并将映像推入Google容器注册表，最后将映像部署到GKE集群。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">inline.yaml</figcaption></figure><p id="4aa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复制我们在前面步骤中生成的webhook URL预览，并添加到Gitlab webhook中，这样每当有事件发生变化时，Cloud Build就会触发并执行上述步骤。</p><ul class=""><li id="5154" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">去仓库</li><li id="feb0" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">在左侧将有设置&gt; &gt; webhook</li><li id="4cb2" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">复制webhook url并粘贴到url部分。根据您的要求点击复选框。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ma"><img src="../Images/1344fe94d4f4dba45216e949555ee300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VejdR9yQwZ-rAd6Ljv_a0Q.png"/></div></div></figure><p id="1b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单击test connection，我们将收到以下HTTP 200 OK代码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/40f6fab5253370a443e51a376315a07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ud48MqYkgmLb8N_YJVQWfQ.png"/></div></div></figure><p id="d298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们准备将我们的代码推入Gitlab。一旦我们将代码放入Gitlab，Gitlab webhook将调用云构建触发器，该触发器将ssh密钥存储在GCP秘密管理器中，秘密将被提取，我们的云构建触发器将执行行内编辑器配置中指定的步骤。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/bdded3687e8b0bab1b676b49f6a364aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hc6P3P8rAvedd0nK09rHvA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">云构建步骤</figcaption></figure><p id="68f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">限制:</strong></p><p id="b146" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们选择webhook方法，这些功能将不可用</p><ul class=""><li id="210a" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">我们没有对$SHORT_SHA的控制权，也没有选择Github、Bitbucket和Google Source Repository等源代码时所拥有的其他功能。</li><li id="9c66" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">我们没有在GCP基于webhook事件手动运行触发器的选项，这只能从Gitlab完成。</li><li id="2101" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">对于每个应用程序，我们需要保持秘密，这是不可行的和可扩展的解决方案。</li><li id="e0d0" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">这种方法使用内联yaml文件，所有步骤都写在该文件中。不建议这样做，因为我们无法控制从任何中央存储库构建映像。</li><li id="7b29" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">如果我们想使用替代变量，只有很少的功能可用。我们还需要输入类似<code class="du lt lu lv kn b">_TO_SHA$ = (body.after) and _BRANCH$ =(body.ref)</code>的值，如果我们想修改任何东西，那么我们需要在执行步骤时在云构建的入口点添加git命令，这是另一个复杂的解决方法。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/0d36e6b5df565937c26788d43e7a6c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgRcXhqS9mC6s9IlRJT6Ug.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">body.after和body.ref</figcaption></figure><ul class=""><li id="ed4b" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">基于标记和基于分支的触发器。如果我们想要基于git标签触发我们的管道，比如<strong class="ih hj"> PATCH_1 </strong>或者想要使用星号，比如<strong class="ih hj"> PRODUCTION_RELEASE* </strong>。这里不支持，因为我们使用内联构建yaml。</li></ul><p id="fda5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程是关于通过webhook方法构建Gitlab repo代码的。<br/>在<a class="ae jt" rel="noopener" href="/@sanketbisne/approach2-mirroring-csr-and-gitlab-repository-to-create-cloud-build-triggers-and-automate-the-cicd-524c743ee669"> <strong class="ih hj">第二部分</strong> </a> <strong class="ih hj">，</strong>中，我们将讨论我们的<strong class="ih hj">第二种方法</strong>如何镜像Gitlab和google cloud repository以使用webhook缺乏的高级功能，以及如何自动触发我们的管道将我们的工作负载部署到kubernetes集群以用于开发和生产环境。</p><p id="c7e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="9b34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们学习了如何使用webhook方法以Gitlab作为源库来创建云构建触发器。现在，在下一篇博客中，我们将看到如何镜像Gitlab和CSR，并使用CSR作为源代码库。</p><p id="1fbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献:<br/> 1。</strong><a class="ae jt" href="https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ju">https://docs . git lab . com/ee/user/project/integrations/web hook _ events . htm</em></strong></a><strong class="ih hj"><em class="ju">l</em></strong></p><p id="2886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://docs.gitlab.com/ee/user/project/integrations/webhooks.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="ju"> 2。https://docs . gitlab . com/ee/user/project/integrations/web hooks . html</em></strong></a></p><p id="3817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ju"> 3。</em></strong><a class="ae jt" href="https://cloud.google.com/build/docs/automating-builds/build-repos-from-gitlab" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ju">https://cloud . Google . com/build/docs/automating-builds/build-repos-from-git lab</em></strong></a></p><p id="c090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有什么问题吗？</strong>:如果有什么问题，我很乐意在评论里看。在<a class="ae jt" rel="noopener" href="/@sanketbisne">媒体</a>或<a class="ae jt" href="https://www.linkedin.com/in/sanketbisne/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p><p id="a713" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢，祝你有美好的一天😊</p></div></div>    
</body>
</html>