<html>
<head>
<title>Adventures w/ Container manifests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有集装箱清单的冒险</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/adventures-w-docker-manifests-78f255d662ff?source=collection_archive---------0-----------------------#2019-03-22">https://medium.com/google-cloud/adventures-w-docker-manifests-78f255d662ff?source=collection_archive---------0-----------------------#2019-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3cd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；DR </strong>我被提示去了解集装箱图像清单，这些是如何计算|验证的，以及清单如何与层相对应。以下是我学到的。</p><blockquote class="jd je jf"><p id="d5e4" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>您的sha256会有所不同</p></blockquote><p id="74ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了最简单的Golang httpd，并将其封装为:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="dbc0" class="jt ju hi jp b fi jv jw l jx jy">FROM golang:1.12 as build</span><span id="7ef3" class="jt ju hi jp b fi jz jw l jx jy">WORKDIR /go/src/app<br/>COPY . .</span><span id="197e" class="jt ju hi jp b fi jz jw l jx jy">RUN go get -d -v ./...<br/>RUN go install -v ./...</span><span id="ab46" class="jt ju hi jp b fi jz jw l jx jy">FROM gcr.io/distroless/base<br/>COPY --from=build /go/bin/app /</span><span id="11ab" class="jt ju hi jp b fi jz jw l jx jy">ENTRYPOINT ["/app"]</span></pre><p id="4152" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="1ec6" class="jt ju hi jp b fi jv jw l jx jy">IMAGE=hellofreddie<br/>TAG=v1</span><span id="39cf" class="jt ju hi jp b fi jz jw l jx jy">docker build \<br/>--rm \<br/>--file=Dockerfile \<br/>--tag=${IMAGE}:${TAG} \<br/>hellofreddie</span></pre><blockquote class="jd je jf"><p id="1b6e" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong> <code class="du ka kb kc jp b">--rm</code>删除中间容器，这是默认设置。</p></blockquote><p id="aff7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="faa2" class="jt ju hi jp b fi jv jw l jx jy">docker history ${IMAGE}:${TAG} \<br/>--format="{{.ID}}\t{{.CreatedBy}}"</span><span id="f1f4" class="jt ju hi jp b fi jz jw l jx jy">IMAGE               CREATED BY                                      <br/>c8c7079fcada        /bin/sh -c #(nop)  ENTRYPOINT ["/app"]<br/>de61bd0d36a4        /bin/sh -c #(nop) COPY file:549fe06ce41c1ab2…<br/><strong class="jp hj">a5a1c6b2c22f</strong>        bazel build ...<br/>&lt;missing&gt;           bazel build ...</span></pre><p id="49e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些图像层从上到下与Dockerfile文件中的命令反向对应:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5305" class="jt ju hi jp b fi jv jw l jx jy">docker image ls gcr.io/distroless/base<br/>REPOSITORY               TAG                 IMAGE ID<br/>gcr.io/distroless/base   latest              <strong class="jp hj">a5a1c6b2c22f</strong></span><span id="087d" class="jt ju hi jp b fi jz jw l jx jy">docker image history gcr.io/distroless/base \<br/>--format="{{.ID}}\t{{.CreatedBy}}"<br/><strong class="jp hj">a5a1c6b2c22f</strong>        bazel build ...<br/>&lt;missing&gt;           bazel build ...</span></pre><p id="10bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后由<code class="du ka kb kc jp b">build</code>层生成文件的副本。</p><p id="e61c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，设置<code class="du ka kb kc jp b">ENTRYPOINT</code>。</p><p id="21b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="f260" class="jt ju hi jp b fi jv jw l jx jy">docker image inspect ${IMAGE}:${TAG} \<br/>| jq --raw-output '.[0].<strong class="jp hj">Id</strong>'<br/>sha256:c8c7079f...</span><span id="e3fa" class="jt ju hi jp b fi jz jw l jx jy">docker image inspect ${IMAGE}:${TAG} \<br/>| jq --raw-output '.[0].<strong class="jp hj">RepoDigests</strong>[]'<br/>dazwilkin/hellofreddie@sha256:<strong class="jp hj">2f93667f</strong>...<br/>gcr.io/dazwilkin-190319-docker/hello@sha256:<strong class="jp hj">2f93667f</strong>...<br/>gcr.io/dazwilkin-190319-docker/hellofreddie@sha256:<strong class="jp hj">2f93667f</strong>...</span><span id="4e0b" class="jt ju hi jp b fi jz jw l jx jy">docker image inspect ${IMAGE}:$}{TAG} \<br/>| jq --raw-output '.[0].RootFS.<strong class="jp hj">Layers</strong>[]'<br/>sha256:44873b56...<br/>sha256:87c747af...<br/>sha256:5ef84fd2...</span></pre><blockquote class="jd je jf"><p id="7555" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">假设#1 </strong>:(回购)摘要散列(<code class="du ka kb kc jp b">2f93667f</code>)应该专门从图像清单的内容中确定。希望在这篇文章结束之前，我们能证明这一点。</p></blockquote><h2 id="0995" class="jt ju hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">码头枢纽(<code class="du ka kb kc jp b">hub.docker.com</code></h2><p id="7179" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">如果您有Docker凭证(<code class="du ka kb kc jp b">${USERNAME}</code>)，您可以将您的图像推送到Docker的注册表(<code class="du ka kb kc jp b">hub.docker.com</code>):</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4a4e" class="jt ju hi jp b fi jv jw l jx jy">docker tag ${IMAGE}:${TAG} ${USERNAME}/${IMAGE}:${TAG}<br/>docker push ${USERNAME}/${IMAGE}:${TAG}</span></pre><p id="da39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来是这样的:</p><figure class="jk jl jm jn fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lb"><img src="../Images/5b8e90d0b100e0757fa64bccd84400a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sFpPT538RZrmWOwUwRUhw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">dockerhub</figcaption></figure><p id="798f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">UI看起来不错，但似乎缺乏深入清单和层的功能。幸运的是，有一个注册API，这个文档有助于使用它:</p><p id="4c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc jp b"><a class="ae ln" href="https://success.docker.com/article/how-do-i-authenticate-with-the-v2-api" rel="noopener ugc nofollow" target="_blank">https://success.docker.com/article/how-do-i-authenticate-with-the-v2-api</a></code></p><p id="f022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了保持连续性，我将在这里重复其中的一些例子:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="874a" class="jt ju hi jp b fi jv jw l jx jy">REG="<a class="ae ln" href="https://hub.docker.com/v2" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/v2</a>"<br/>USR=[[YOUR-DOCKER-USERNAME]]<br/>PWD=[[YOUR-DOCKER-PASSWORD]]</span><span id="84a4" class="jt ju hi jp b fi jz jw l jx jy">TOKEN=$(\<br/>  curl \<br/>  --silent \<br/>  --header "Content-Type: application/json" \<br/>  --request POST \<br/>  --data '{"username": "'${USR}'", "password": "'${PWD}'"}' \<br/>  ${REG}<strong class="jp hj">/users/login/</strong> \<br/>  | jq -r .token\<br/>) &amp;&amp; echo ${TOKEN}</span><span id="6583" class="jt ju hi jp b fi jz jw l jx jy">curl \<br/>--silent \<br/>--header "Authorization: JWT ${TOKEN}" \<br/>${REG}<strong class="jp hj">/repositories/${USR}/</strong>?page_size=100 \<br/>| jq -r '.results|.[]|.name'<br/></span><span id="b7c4" class="jt ju hi jp b fi jz jw l jx jy">curl \<br/>--silent \<br/>--header "Authorization: JWT ${TOKEN}" \<br/>${REG}<strong class="jp hj">/repositories/${USR}/${IMAGE}/tags/</strong></span></pre><blockquote class="jd je jf"><p id="48ba" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">我极力推荐jq，但是如果您不想使用它，您需要从curl命令返回的JSON中手动获取<code class="du ka kb kc jp b">token</code>值。</p></blockquote><p id="5e6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步应该是为image <code class="du ka kb kc jp b">${IMAGE}:${TAG}</code>拉一个清单，但是我努力让它与dockerhub一起工作:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="998c" class="jt ju hi jp b fi jv jw l jx jy">curl \<br/>--silent \<br/>--header "Authorization: JWT ${TOKEN}" \<br/>${REG}<strong class="jp hj">/${USR}/${IMAGE}/manifests/v1</strong></span></pre><p id="0c15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看Stackoverflow上的好心人是怎么说的:</p><p id="2f92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc jp b"><a class="ae ln" href="https://stackoverflow.com/questions/55269256/how-to-get-manifests-using-http-api-v2" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/55269256/how-to-get-manifests-using-http-api-v2</a></code></p><p id="28d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我无法提取货单，所以我无法在dockerhub上进一步证实货单。</p><p id="8ccf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新2019–09–12:</strong><a class="ae ln" href="https://stackoverflow.com/a/57878742/609290" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">已解决</strong> </a> <strong class="ih hj">由</strong><a class="ae ln" href="https://stackoverflow.com/users/1845976/schnatterer" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">schna tter</strong></a><strong class="ih hj">—感谢！</strong></p><p id="1b3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您使用以下方式获得一个<code class="du ka kb kc jp b">TOKEN</code>:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="931f" class="jt ju hi jp b fi jv jw l jx jy">AUTH="<a class="ae ln" href="https://auth.docker.io/token?service=registry.docker.io&amp;scope=repository:dazwilkin/hellofreddie:pull" rel="noopener ugc nofollow" target="_blank">https://auth.docker.io</a>"<br/>SERV="registry.docker.io<br/>REPO=${USR}/${IMAGE}</span><span id="1ca9" class="jt ju hi jp b fi jz jw l jx jy">TOKEN=$(\<br/>  curl \<br/>  --silent \<br/>  --location \<br/>  "${AUTH}<a class="ae ln" href="https://auth.docker.io/token?service=registry.docker.io&amp;scope=repository:dazwilkin/hellofreddie:pull" rel="noopener ugc nofollow" target="_blank">/token?service=${SERV}&amp;scope=repository:${REPO}:pull</a>" \<br/>  | jq --raw-output .token\<br/>) &amp;&amp; echo ${TOKEN}</span></pre><p id="0498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="86b4" class="jt ju hi jp b fi jv jw l jx jy">REG="<strong class="jp hj">https://index.docker.io/v2</strong>"<br/>SCHEMA="application/vnd.docker.distribution.manifest.v2+json"</span><span id="1884" class="jt ju hi jp b fi jz jw l jx jy">curl \<br/>  --silent \<br/>  --location \<br/>  --header "Authorization: Bearer ${TOKEN}" \<br/>  --header "Accept: ${SCHEMA}" \<br/>  "${REG}/${USR}/${IMAGE}/manifests/${TAG}" \<br/>| jq --raw-output</span></pre><p id="d5cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="bf03" class="jt ju hi jp b fi jv jw l jx jy">curl \<br/>  --silent \<br/>  --location \<br/>  --header "Authorization: Bearer ${TOKEN}" \<br/>  --header "Accept: ${SCHEMA}" \<br/>  "${REG}/${USR}/${IMAGE}/manifests/${TAG}" \<br/>| sha256sum \<br/>| head --bytes 64<br/><strong class="jp hj">2f93667f...</strong></span></pre><h2 id="74ef" class="jt ju hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">谷歌容器注册</h2><p id="3840" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">如果您可以访问谷歌云平台项目，您也可以使用谷歌容器注册:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e7ac" class="jt ju hi jp b fi jv jw l jx jy">docker tag ${IMAGE}:${TAG} <strong class="jp hj">gcr.io/${PROJECT}/</strong>${IMAGE}:${TAG}<br/>docker push <strong class="jp hj">gcr.io/${PROJECT}/</strong>${IMAGE}:${TAG}</span><span id="a489" class="jt ju hi jp b fi jz jw l jx jy">v1: digest: sha256:<strong class="jp hj">2f93667f</strong>... size: 949</span></pre><p id="002d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>推送完成后提供给我们的摘要(<code class="du ka kb kc jp b">sha256:2f9e667f…</code>)。</p><p id="c177" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我使用云控制台时看到的样子:</p><p id="1564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ka kb kc jp b"><a class="ae ln" href="https://console.cloud.google.com/gcr/images/${PROJECT}" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/gcr/images/${PROJECT}</a></code></p><figure class="jk jl jm jn fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lo"><img src="../Images/033ffbf7227d9a781eace7273fe11769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6nioooF_DCiuQyeH5r8-w.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">谷歌容器注册</figcaption></figure><p id="4bcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一个有用的深入查看图像的功能，首先显示可用的标签，然后显示清单细节:</p><figure class="jk jl jm jn fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lp"><img src="../Images/dd13bc90851d0eb30d69fadf77400c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inQK2uituN1VW2irwJy_5g.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">Google容器注册表:清单</figcaption></figure><p id="2cee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>容器注册表提供了摘要(<code class="du ka kb kc jp b">2f93667f</code>)。这与我们完成推送时提供给我们的摘要相匹配。当我们引用图像时，我们可以通过<code class="du ka kb kc jp b">${IMAGE}:${TAG}</code>来引用它，但是同一个<code class="du ka kb kc jp b">${IMAGE}:${TAG}</code>可能会产生不同的图像。相反，我们可以将图像唯一且不变地称为<code class="du ka kb kc jp b">${IMAGE}@sha256:2f9e667f...</code>。</p><p id="6bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google容器注册实现了Docker注册API v2。不幸的是，因为容器注册中心*不是*一个常规的Google API，所以不可能使用美妙的Google APIs Explorer来探测这个API。</p><p id="d86a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，根据以上Docker实现的经验，这里的主要问题是如何根据Google Registry进行认证。</p><p id="4bf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案如下:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4738" class="jt ju hi jp b fi jv jw l jx jy">TOKEN=$(gcloud auth print-access-token)</span></pre><p id="1f50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为这很容易获取，我建议在随后的命令中直接使用该命令，而不是使用<code class="du ka kb kc jp b">${TOKEN}</code>，因为这会过期。</p><p id="d82d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">抛开</strong>不谈:我试图通过对<code class="du ka kb kc jp b">gcloud container image</code>命令使用gcloud <code class="du ka kb kc jp b">-log-http</code>来找出使用了哪些API调用:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="620a" class="jt ju hi jp b fi jv jw l jx jy">gcloud container images list \<br/>--repository=<strong class="jp hj">gcr.io/${PROJECT}</strong> \<br/>--log-http</span><span id="0b44" class="jt ju hi jp b fi jz jw l jx jy">==== request start ====<br/>uri: <a class="ae ln" href="https://gcr.io/v2/token?scope=repository%3Adazwilkin-190319-docker%3Apull&amp;service=gcr.io" rel="noopener ugc nofollow" target="_blank">https://<strong class="jp hj">gcr.io/v2/token</strong>?scope=repository%3A<strong class="jp hj">${PROJECT}</strong>%3A<strong class="jp hj">pull&amp;service=gcr.io</strong></a><br/>method: GET<br/>== headers start ==<br/>Authorization: --- Token Redacted ---<br/>content-type: application/json<br/>== headers end ==<br/>== body start ==</span><span id="d758" class="jt ju hi jp b fi jz jw l jx jy">== body end ==<br/>---- response start ----<br/>-- body start --<br/>{<br/>  "expires_in":43200,<br/>  "issued_at":"2019-03-21-T23:59:59.00000000-7:00",<br/>  <strong class="jp hj">"token":"[[TOKEN]]"<br/></strong>}<br/>-- body end --</span><span id="6bd9" class="jt ju hi jp b fi jz jw l jx jy">==== request start ====<br/>uri: <a class="ae ln" href="https://gcr.io/v2/dazwilkin-190319-docker/tags/list" rel="noopener ugc nofollow" target="_blank">https://gcr.io/v2/<strong class="jp hj">${PROJECT}/${IMAGE}/tags/list</strong></a><br/>method: GET<br/>== headers start ==<br/>Authorization: --- Token Redacted ---<br/>== headers end ==<br/>== body start ==</span><span id="c25b" class="jt ju hi jp b fi jz jw l jx jy">== body end ==<br/>==== request end ====<br/>---- response start ----<br/>-- headers start --<br/>content-location: <a class="ae ln" href="https://gcr.io/v2/dazwilkin-190319-docker/tags/list" rel="noopener ugc nofollow" target="_blank">https://gcr.io/v2<strong class="jp hj">/${PROJECT}/${IMAGE}/tags/list</strong></a><br/>docker-distribution-api-version: registry/2.0<br/>server: Docker Registry<br/>status: 200<br/>-- headers end --<br/>-- body start --<br/>{<br/>  "child":["<strong class="jp hj">${IMAGE}</strong>"],<br/>  "manifest":{"sha256:2f93667f...":{...}},<br/>  "name":"<strong class="jp hj">${PROJECT}</strong>",<br/>  "tags":["<strong class="jp hj">${TAG}</strong>"]<br/>}<br/>-- body end --<br/>---- response end ----<br/>----------------------</span><span id="4ec4" class="jt ju hi jp b fi jz jw l jx jy">DIGEST        TAGS  TIMESTAMP<br/>2f93667f005b  v1    2019-03-19T00:00:00</span></pre><p id="4e42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我无法在针对容器注册API的后续调用中应用值<code class="du ka kb kc jp b">[[TOKEN]]</code>。相反，使用我的凭证来获得一个访问令牌(<code class="du ka kb kc jp b">gcloud auth print-access-token</code>)是可行的，所以我放弃了这条路。</p><p id="8161" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面可以看出，有趣的是，您看到Google容器注册中心正在接受Docker Registry v2 API调用:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="f7a7" class="jt ju hi jp b fi jv jw l jx jy">/token<br/>/${PROJECT}/tags/list<br/>/${PROJECT}/${IMAGE}/tags/list</span></pre><p id="d609" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，现在让我们使用与dockerhub相同的API调用，为容器注册库进行配置:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="f11d" class="jt ju hi jp b fi jv jw l jx jy">REPO=https://<strong class="jp hj">gcr.io/v2</strong>/${PROJECT}/${IMAGE}<br/>TOKEN=$(gcloud auth print-access-token)</span><span id="5178" class="jt ju hi jp b fi jz jw l jx jy">curl \<br/>--silent \<br/>--request GET \<br/>--user _token:${TOKEN} \<br/>${REPO}<strong class="jp hj">/tags/list</strong><br/>{<br/> "child": ["<strong class="jp hj">${IMAGE}</strong>"],<br/> "manifest": {},<br/> "name": "<strong class="jp hj">${PROJECT}</strong>",<br/> "tags": []<br/>}</span></pre><p id="023f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4c28" class="jt ju hi jp b fi jv jw l jx jy">curl \<br/>--silent \<br/>--request GET \<br/>--user _token:${TOKEN} \<br/>${REPO}<strong class="jp hj">/tags/list</strong><br/>{<br/> "child": [],<br/> "manifest": {"<strong class="jp hj">sha256:2f93667f...</strong>": {...}},<br/> "name": "<strong class="jp hj">${PROJECT}</strong>/<strong class="jp hj">${IMAGE}</strong>",<br/> "tags": ["<strong class="jp hj">${TAG}</strong>"]<br/>}</span></pre><p id="91c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我无法使用dockerhub的manifests命令可以正确使用容器注册表:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="db79" class="jt ju hi jp b fi jv jw l jx jy">curl \<br/>--silent \<br/>--request GET \<br/>--user _token:${TOKEN} \<br/>${REPO}<strong class="jp hj">/manifests/${TAG}</strong> \<br/>| jq .<br/>{<br/>  "schemaVersion": 2,<br/>  "config": {<br/>    ...<br/>    "digest": "sha256:c8c7079f..."<br/>  },<br/>  "layers": [<br/>    {<br/>      "size": 653664,<br/>      "digest": "sha256:41d63303..."<br/>    },<br/>    {<br/>      "size": 7326227,<br/>      "digest": "sha256:5f5edd68..."<br/>    },<br/>    {<br/>      "size": 3774900,<br/>      "digest": "sha256:cf2e7bc2..."<br/>    }<br/>  ]<br/>}</span></pre><p id="d2d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在这里暂停一下，试着理解(我不确定我现在是否理解)我们所拥有的:</p><ul class=""><li id="57cd" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated"><code class="du ka kb kc jp b">config.digest</code> ( <code class="du ka kb kc jp b">c8c7079f...</code>)对应的是<code class="du ka kb kc jp b">Id</code>的方式，当我们检查图像建成后。</li><li id="0f43" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">然而，容器注册表报告了另一个<code class="du ka kb kc jp b">2f93667f...</code>摘要。并且该值对应于来自同一图像检查命令的<code class="du ka kb kc jp b">RepoDigest</code>值。这也是我们可以用来提取图像的摘要值:<code class="du ka kb kc jp b">docker pull ${REPO}/${IMAGE}@sha2f93667f...</code>。</li><li id="e970" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated"><code class="du ka kb kc jp b">layers[].digest</code>值与本地副本上的层散列不匹配。</li></ul><p id="7be7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次让我们使用摘要:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="94b4" class="jt ju hi jp b fi jv jw l jx jy">DIGEST="sha256:2f93667f..."<br/>curl \<br/>--silent \<br/>--request GET \<br/>--user _token:${TOKEN} ${REPO}/${IMAGE}/manifests/${DIGEST} \<br/>| jq .<br/>{<br/>  "schemaVersion": 2,<br/>  "config": {<br/>    ...<br/>    "digest": "sha256:c8c7079f..."<br/>  },<br/>  "layers": [<br/>    {<br/>      "size": 653664,<br/>      "digest": "sha256:41d63303..."<br/>    },<br/>    {<br/>      "size": 7326227,<br/>      "digest": "sha256:5f5edd68..."<br/>    },<br/>    {<br/>      "size": 3774900,<br/>      "digest": "sha256:cf2e7bc2..."<br/>    }<br/>  ]<br/>}</span></pre><p id="a289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是一样的。该摘要唯一地引用了该图像。如果我们改变图像(不管有多小)并把它作为<code class="du ka kb kc jp b">${IMAGE}:${TAG}</code>重新推送，它的摘要(很可能)会不同。</p><p id="e71e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们计算清单的SHA-256散列:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="9403" class="jt ju hi jp b fi jv jw l jx jy">curl \<br/>--silent \<br/>--request GET \<br/>--user _token:${TOKEN} ${REPO}/${IMAGE}/manifests/${TAG} \<br/>| sha256sum \<br/>| head --bytes 64</span><span id="3376" class="jt ju hi jp b fi jz jw l jx jy"><strong class="jp hj">2f93667f...</strong></span></pre><p id="78ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">旁白</strong> : <a class="ae ln" href="https://github.com/containers/skopeo" rel="noopener ugc nofollow" target="_blank">斯科佩奥</a></p><p id="6c86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在搜索中找到了skopeo。我以前没有用过它，但它很有用:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="689a" class="jt ju hi jp b fi jv jw l jx jy">./skopeo inspect docker://<strong class="jp hj">docker.io</strong>/${USER}/${IMAGE}:${TAG}<br/>{<br/>    "Name": "docker.io/${USER}/${IMAGE}",<br/>    "Digest": "<strong class="jp hj">sha256:2f93667f...</strong>",<br/>    "RepoTags": [<br/>        "${TAG}"<br/>    ],<br/>    "Created": "2019-03-19T00:00:00.000000000Z",<br/>    "DockerVersion": "18.06.2-ce",<br/>    "Labels": null,<br/>    "Architecture": "amd64",<br/>    "Os": "linux",<br/>    "Layers": [<br/>        "sha256:41d63303...",<br/>        "sha256:5f5edd68...",<br/>        "sha256:cf2e7bc2..."<br/>    ]<br/>}</span></pre><p id="fbc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e017" class="jt ju hi jp b fi jv jw l jx jy">./skopeo inspect docker://<strong class="jp hj">gcr.io</strong>/${PROJECT}/${IMAGE}:${TAG}<br/>{<br/>    "Name": "gcr.io/${PROJECT}/${IMAGE}",<br/>    "Digest": "<strong class="jp hj">sha256:2f93667f...</strong>",<br/>    "RepoTags": [<br/>        "v1",<br/>        "v2"<br/>    ],<br/>    "Created": "2019-03-19T00:00:00.000000000Z",<br/>    "DockerVersion": "18.06.2-ce",<br/>    "Labels": null,<br/>    "Architecture": "amd64",<br/>    "Os": "linux",<br/>    "Layers": [<br/>        "sha256:41d63303...",<br/>        "sha256:5f5edd68...",<br/>        "sha256:cf2e7bc2..."<br/>    ]<br/>}</span></pre><blockquote class="jd je jf"><p id="5b26" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">在这种情况下，GCR的URL中没有<code class="du ka kb kc jp b">/v2/</code>。</p><p id="9563" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong><code class="du ka kb kc jp b">Digest</code>和<code class="du ka kb kc jp b">Layers[]</code>值匹配。</p><p id="9a12" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">因为清单完全相同，所以摘要匹配。</p></blockquote><h2 id="9720" class="jt ju hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">层</h2><p id="6cfc" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">根据Docker的API，应该可以通过它们的哈希来拉特定的层。我与多克和GCR的电话都没有成功。然而，有了GCR，我知道这些层被埋在哪里。GCR使用谷歌云存储(GCS)进行图层持久化。</p><p id="96a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用GCS存储浏览器，GCR创建了一个存储桶<code class="du ka kb kc jp b">artifacts.${PROJECT}.appspot.com</code>，其中包含<code class="du ka kb kc jp b">containers/images/</code>:</p><figure class="jk jl jm jn fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es me"><img src="../Images/019025e53032d0a99700aff5497a5d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pF_0u9lze50EZWHHutkoxg.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">云存储浏览器</figcaption></figure><p id="c344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你还记得，我有名为<code class="du ka kb kc jp b">sha256:441d63303...</code>、<code class="du ka kb kc jp b">sha256:5f5edd68...</code>和<code class="du ka kb kc jp b">sha256:cf2e7bc2</code>的层。让我们来计算这些档案的哈希值:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="7d1a" class="jt ju hi jp b fi jv jw l jx jy">DIGESTS=$(\<br/>  curl \<br/>  --silent \<br/>  --request GET \<br/>  --user _token:${TOKEN} \<br/>  ${REPO}/${IMAGE}/manifests/${TAG} \<br/>  | jq -r .layers[]<strong class="jp hj">.digest</strong> \<br/>)</span><span id="2d50" class="jt ju hi jp b fi jz jw l jx jy">BUCKET=artifacts.${PROJECT}.appspot.com</span><span id="e890" class="jt ju hi jp b fi jz jw l jx jy">for DIGEST in ${DIGESTS}<br/>do<br/>  echo "Provided: ${DIGEST}"<br/>  CALCD="sha256:"$(gsutil cp gs://${BUCKET}/containers/images/${DIGEST} - \<br/>  | sha256sum \<br/>  | head --bytes 64)<br/>  echo "Calculated: ${CALCD}"<br/>  if [ "${DIGEST}" != "${CALCD}" ]; then<br/>    echo "Match!"<br/>  else<br/>    echo "Error!"<br/>  fi<br/> done</span></pre><p id="108f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，该脚本获取了<code class="du ka kb kc jp b">${IMAGE}:${TAG}</code>的清单，并使用它来确定存储在GCS中的图层的相应存档。然后，它将每个归档文件传输到<code class="du ka kb kc jp b">sha256sum</code>中，以(重新)计算归档文件的哈希，并将其与该层的清单摘要进行比较。在我的例子中，结果是:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0d4e" class="jt ju hi jp b fi jv jw l jx jy">sha256:41d63303...<br/>sha256:41d63303...<br/>Match!<br/>sha256:5f5edd68...<br/>sha256:5f5edd68...<br/>Match!<br/>sha256:cf2e7bc2...<br/>sha256:cf2e7bc2...<br/>Match!</span></pre><p id="57aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还可以使用类似的过程来确认归档大小是否匹配。在这种情况下，最好将档案保存在本地，计算其<code class="du ka kb kc jp b">sha256sum</code>并确定其大小。</p><h2 id="c805" class="jt ju hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">结论</h2><p id="086c" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我一直避免更好地理解支撑容器图像的元数据。除了提供导航DockerHub和Google Container Registry注册表的基本概述之外，希望这篇文章对其他人理解图像清单和层背后的基础知识是有用的。</p><p id="d525" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能还记得假设1。我们确实能够证明(回购)摘要(即清单摘要)可以简单地从清单中计算出来。</p><p id="2fdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p><p id="a52b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">补遗</strong></p><p id="e173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于集装箱注册基础桶的sha256计算的另一个重复部分是:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="6f74" class="jt ju hi jp b fi jv jw l jx jy">BUCKET=[[YOUR-BUCKET]]</span><span id="b5cb" class="jt ju hi jp b fi jz jw l jx jy">for OBJECT in $(gsutil ls gs://${BUCKET}/containers/images)<br/>do <br/>  OBJECT_SHA=$(gsutil cp ${OBJECT} - | sha256sum | head --bytes 64)<br/>  printf "%s\tsha==%s\n" ${OBJECT} ${OBJECT_SHA}<br/>done</span></pre></div></div>    
</body>
</html>