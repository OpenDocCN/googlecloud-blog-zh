<html>
<head>
<title>Automating container security in GKE with Binary Authorization and Circle CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用二进制授权和Circle CI实现GKE集装箱安全自动化</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/automating-container-security-on-gke-with-binary-authorization-and-circleci-7efa7a6be2a7?source=collection_archive---------0-----------------------#2018-12-20">https://medium.com/google-cloud/automating-container-security-on-gke-with-binary-authorization-and-circleci-7efa7a6be2a7?source=collection_archive---------0-----------------------#2018-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><p id="ff9a" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">我们如何确保部署到Google Kubernetes引擎(GKE)的容器来自可信的来源，我们如何使用CI/CD工具<strong class="in hj"><em class="jj"/></strong>自动化这一关键的安全检查？</p><blockquote class="jk jl jm"><p id="7d23" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated"><strong class="in hj">注</strong>:本文假设读者熟悉Google云平台、Kubernetes和相关工具(gcloud、kubectl等)。).熟悉PGP密钥生成过程也很有帮助。</p></blockquote><h2 id="8c83" class="jq jr hi bd js jt ju jv jw jx jy jz ka iw kb kc kd ja ke kf kg je kh ki kj kk bi translated">为集装箱安全辩护</h2><p id="12ad" class="pw-post-body-paragraph il im hi in b io kl iq ir is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji hb bi translated">让我们以部署在GKE的医疗保健应用程序为例。该应用程序用于管理非常敏感的患者医疗保健数据。</p><p id="5dd1" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">在下图中，您可以看到标准CI/CD流程正在进行:</p><ul class=""><li id="a728" class="kq kr hi in b io ip is it iw ks ja kt je ku ji kv kw kx ky bi translated">代码被签入GitHub</li><li id="cba8" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">一个CI/CD工具(CircleCI)从GitHub获取它，运行所有需要的测试，创建一个Docker映像，并将其推送到Google容器注册中心(GCR)。</li><li id="9000" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">然后，它将此映像部署到GKE。</li></ul><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es le"><img src="../Images/a0833b67fe8f71ee1cab2224061706b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UyRDNMUDANFhPbJUyUQM7w.jpeg"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">在GKE部署医疗保健应用</figcaption></figure><p id="bdde" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">现在，假设组织内的一个特权用户决定创建应用程序的另一个版本，并将其直接部署到GKE集群<em class="jj">，而不通过CI/CD管道</em>。这可能是无害的，比如在不影响生产应用程序的情况下测试一个新特性<em class="jj">，也可能是更危险的</em>，代码试图出于恶意目的访问敏感数据。</p><p id="450c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">在任何情况下，由于该用户已经可以访问Kubernetes集群，所以使用新代码在本地构建应用程序并将其部署到GKE并绕过整个CI/CD过程是非常容易的。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es le"><img src="../Images/569849242d35a8167283a6e5c9030be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jEQFjAiXgAf7OMkbYNDlQ.jpeg"/></div></div></figure><p id="a2da" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">问题</strong>:我们如何确保集群中的容器来自可信的来源，并且已经通过了所有必要的检查，包括安全漏洞检查等等。？</p><p id="5c0a" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><strong class="in hj">解决方案</strong>:Google二进制授权。这是一种仅允许将“经证实的”映像部署到群集的服务。经证明的图像是已经由“证明者”验证或保证的图像。任何与二进制授权策略不匹配的未授权映像都会被拒绝，如下图所示。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lt"><img src="../Images/109c5d08c53754ee272296d186bc2fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCddWgrLGcmW8oRUaBHCTw.jpeg"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">二元授权在起作用</figcaption></figure><h2 id="6de3" class="jq jr hi bd js jt ju jv jw jx jy jz ka iw kb kc kd ja ke kf kg je kh ki kj kk bi translated">术语</h2><ul class=""><li id="74a7" class="kq kr hi in b io kl is km iw lu ja lv je lw ji kv kw kx ky bi translated"><strong class="in hj">二进制授权</strong>是Google提供的一个部署时安全服务，它确保在我们的GKE集群中只部署受信任的容器。它使用策略驱动模型，允许我们配置安全策略。在后台，该服务与容器分析服务进行对话。</li><li id="69f2" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated"><strong class="in hj">容器分析</strong>是一个API，用于存储关于我们软件工件的可信元数据，并在二进制授权过程中使用</li><li id="b782" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated"><strong class="in hj">证明人</strong>是证明图像真实性的人或过程</li><li id="9209" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated"><strong class="in hj">注意</strong>是容器分析存储中与证明者相关联的一段元数据</li><li id="0ddc" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated"><strong class="in hj">证明</strong>是来自证明者的声明，表明映像已准备好进行部署。在我们的例子中，我们将使用一个证明来引用我们图像的签名</li></ul><h2 id="f9f0" class="jq jr hi bd js jt ju jv jw jx jy jz ka iw kb kc kd ja ke kf kg je kh ki kj kk bi translated">将二进制授权整合到我们的管道中</h2><p id="2dfa" class="pw-post-body-paragraph il im hi in b io kl iq ir is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji hb bi translated">为了实现这一点，我们需要遵循<strong class="in hj">的2组步骤</strong>。第一个是一次性的<strong class="in hj">手动</strong>设置过程，第二个可以是<strong class="in hj">自动</strong>(通过您最喜欢的CI/CD工具)。在本文的后面，我将使用CircleCI展示这一点。</p><blockquote class="jk jl jm"><p id="0327" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated">这看起来工作量很大(确实如此)，但好消息是大部分工作都可以编写脚本并自动化。</p></blockquote><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lx"><img src="../Images/85ddf7c62b92ea5967f4489e10733b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UEguh4qeotR09zw5xxetg.jpeg"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">二进制授权所需的设置</figcaption></figure><blockquote class="jk jl jm"><p id="5b6d" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated"><strong class="in hj">一次性手动设置</strong>:我们将创建一个GCP项目，启用所需的API，创建一个启用了二进制授权的Kubernetes集群，设置一个注释，生成PGP密钥并创建一个证明者。出于演示的目的，我将使用一个准系统node.js Hello World应用程序部署到GKE。</p></blockquote><p id="3d3c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">让我们从手动设置开始:</p><ul class=""><li id="f248" class="kq kr hi in b io ip is it iw ks ja kt je ku ji kv kw kx ky bi translated">创建一个Kubernetes集群并启用二进制授权</li></ul><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ly"><img src="../Images/9fdc787f46f720b39fe45e74c14d7525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yn6bYQhJ0NBTBRuZkBuINw.png"/></div></div></figure><ul class=""><li id="bb02" class="kq kr hi in b io ip is it iw ks ja kt je ku ji kv kw kx ky bi translated">为您的项目启用容器注册表、容器分析和二进制授权API</li><li id="599f" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">默认的二进制授权策略<strong class="in hj">允许所有图像</strong>。您可以通过GCP控制台中的安全- &gt;二进制授权来访问它</li></ul><blockquote class="jk jl jm"><p id="44ab" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated"><strong class="in hj">注意</strong>:以下其余步骤在脚本<a class="ae lz" href="https://github.com/nmallya/containerdemo/blob/master/kube/onetime_setup.sh" rel="noopener ugc nofollow" target="_blank"><strong class="in hj">ontime _ setup . sh</strong></a>中可用</p></blockquote><ul class=""><li id="da44" class="kq kr hi in b io ip is it iw ks ja kt je ku ji kv kw kx ky bi translated">创建笔记有效负载。当我们创建证明者时，将需要此注释。注释id不应包含空格。</li><li id="6a07" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">将有效负载发送到二进制授权服务</li><li id="3b6d" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">使用gpg生成PGP密钥对(公钥和私钥)。公钥将与证明者相关联，私钥将用于对图像进行签名。注意 : gpg需要熵(随机性)来生成密钥。当我在我的Mac上这样做的时候，我不需要像rngd那样运行一个单独的程序来生成熵。此外，gpg在密钥生成期间需要一个密码短语。我选择了一个空白密码，并接受了警告。</li><li id="46c7" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">公钥被导出到一个文件中并保存以备后用</li><li id="a1f5" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">创建一个指定当前项目和上述注释的证明者。将公钥与证明者相关联。在我的例子中，证明者被称为“binauth-证明者”。证明者名称中不应有空格</li><li id="308d" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">创建二进制授权策略(参见<a class="ae lz" href="https://github.com/nmallya/containerdemo/blob/master/kube/sec-policy.yml" rel="noopener ugc nofollow" target="_blank"> sec-policy.yml </a>)。在此策略中，我们将默认限制所有项目级别的映像，并且只为我们名为<strong class="in hj"> cd-cluster的集群启用由我们的证明者<strong class="in hj">(projects/nmallyatestproject/证明者/binauth-证明者)</strong>证明的映像。</strong>好看又限制！</li></ul><blockquote class="jk jl jm"><p id="70a8" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated">运行onetime_setup.sh后，如果一切顺利，您应该能够看到已经创建了binauth-证明者，并且有一个相关联的公钥，如下所示。</p></blockquote><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ma"><img src="../Images/a4238b12eb3c683e604016558443d15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtzQoVlulvSTqsLE-6MDqg.png"/></div></div></figure><p id="6717" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">二进制授权策略也已更改，以反映我们的新限制，如下所示:</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mb"><img src="../Images/9b4d1bf239bbe83da1b8dd1147dcfdf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgR7u7OoRptjob-0WnclUA.png"/></div></div></figure><p id="39bf" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">让我们继续自动化工作的第二部分:在部署到GKE之前签署图像。</p><blockquote class="jk jl jm"><p id="ab7c" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated">自动化的C I /CD流程:在这个流程中，我们将执行构建我们的应用程序、测试它、将它归档并部署到GCR的标准任务。然后，我们将从映像创建一个映像摘要，用来自上述PGP密钥对的私钥对它进行签名，创建一个证明，并将其部署到二进制授权。</p><p id="20c0" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated"><strong class="in hj">重要提示</strong>:为了让CircleC I能够签署我们的图像摘要，它需要能够访问之前生成的密钥。实现这一点的一种方法是对私钥进行base64编码，并将其保存在我们项目的CircleCI环境变量中。出于本演示的目的，我们将采用这种方法。名为BINAUTH_PRIVATE_KEY的CircleCI环境变量将包含该值。请注意，可能有其他更好的解决方案。</p><p id="afc5" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated">您可以在<a class="ae lz" href="https://github.com/nmallya/containerdemo/blob/master/kube/extract_private_key.sh" rel="noopener ugc nofollow" target="_blank">https://github.com/nmallya/containerdemo/blob/master/kube/<strong class="in hj">extract _ private _ key . sh</strong></a>中找到密钥提取逻辑</p></blockquote><p id="5c4c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">以下其余步骤在脚本<a class="ae lz" href="https://github.com/nmallya/containerdemo/blob/master/kube/generate_signature.sh" rel="noopener ugc nofollow" target="_blank"><strong class="in hj">generate _ signature . sh</strong></a>中可用，并将由CircleCI为每个新构建自动执行</p><ul class=""><li id="cea2" class="kq kr hi in b io ip is it iw ks ja kt je ku ji kv kw kx ky bi translated">构建/测试/归档映像/推送到GCR</li><li id="cf08" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">从GCR获取图像路径和摘要，并创建签名有效负载</li><li id="4750" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">从Circle C I环境变量中提取私钥并存储在本地</li><li id="e64e" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">从公钥中提取PGP指纹</li><li id="a22c" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">使用gpg使用上述输入为我们的证明人生成的签名签署有效负载</li><li id="2ccc" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">使用上述所有信息创建一个证明，并提交给二进制授权</li><li id="96c7" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">稍等片刻(30秒到1分钟),让更改在二进制授权中生效</li><li id="19e7" class="kq kr hi in b io kz is la iw lb ja lc je ld ji kv kw kx ky bi translated">使用kubectl create -f命令将应用程序部署到GKE，并为我们的<strong class="in hj"> containerdemo </strong> pod传入yml</li></ul><pre class="lf lg lh li fd mc md me mf aw mg bi"><span id="c61c" class="jq jr hi md b fi mh mi l mj mk"><em class="jj">cat &lt;&lt; </em><strong class="md hj">EOF </strong>| <em class="jj">kubectl </em>create -f -<br/><em class="jj">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: containerdemo<br/>spec:<br/>  containers:<br/>  - name: containerdemo<br/>    image: "</em><strong class="md hj">$</strong>{IMAGE_PATH}<em class="jj">@</em><strong class="md hj">$</strong>{IMAGE_DIGEST}<em class="jj">"<br/>    ports:<br/>    - containerPort: 3000<br/></em><strong class="md hj">EOF</strong></span></pre><ul class=""><li id="df0a" class="kq kr hi in b io ip is it iw ks ja kt je ku ji kv kw kx ky bi translated">检查pod展开状态。如果一切顺利，您应该会看到下面的输出。恭喜你！</li></ul><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ml"><img src="../Images/2b1d50c254edd4b2e879c9dce8b6507c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWagqH33H89P5QsUsvnXvg.png"/></div></div></figure><blockquote class="jk jl jm"><p id="076b" class="il im jj in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji hb bi translated"><strong class="in hj">制造麻烦:</strong>让我们创建一个没有签名部分的<strong class="in hj">应用程序的新图像，看看当我们尝试部署它时会发生什么。</strong></p></blockquote><p id="273b" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">建立、标记和推动GCR的新形象</p><pre class="lf lg lh li fd mc md me mf aw mg bi"><span id="6ecd" class="jq jr hi md b fi mh mi l mj mk">$ docker build -t containerdemo -f ./Dockerfile .<br/>$ docker tag containerdemo gcr.io/nmallyatestproject/containerdemo:badimagev1</span><span id="f0ce" class="jq jr hi md b fi mm mi l mj mk">$ gcloud docker -- push gcr.io/nmallyatestproject/containerdemo:badimagev1</span></pre><p id="855c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">部署到GKE —您将看到下面的错误，指示此部署“被证明者拒绝”。找不到由证明者信任的密钥签名的有效证明。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mn"><img src="../Images/6b57cf087e661c4eca9dc42421cc3bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vu_wx7t7HHUu3ljmt_DdXQ.png"/></div></div></figure><h2 id="84cd" class="jq jr hi bd js jt ju jv jw jx jy jz ka iw kb kc kd ja ke kf kg je kh ki kj kk bi translated">使用其他技术定制部署规则:</h2><p id="c070" class="pw-post-body-paragraph il im hi in b io kl iq ir is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji hb bi translated">到目前为止，我们所看到的是在部署容器时确保信任的一种非常先进的方法(通过在项目级别禁止所有映像，只允许特定集群中经过验证的映像)。我们还可以尝试其他非常容易实现的技术，例如:</p><ol class=""><li id="1e95" class="kq kr hi in b io ip is it iw ks ja kt je ku ji mo kw kx ky bi translated">将GCR的图像路径列入白名单。此路径中存在的任何映像都不会通过部署规则进行授权检查</li><li id="8228" class="kq kr hi in b io kz is la iw lb ja lc je ld ji mo kw kx ky bi translated">允许/禁止给定集群的所有图像等</li></ol><h2 id="13b1" class="jq jr hi bd js jt ju jv jw jx jy jz ka iw kb kc kd ja ke kf kg je kh ki kj kk bi translated">资源</h2><ol class=""><li id="9a4b" class="kq kr hi in b io kl is km iw lu ja lv je lw ji mo kw kx ky bi translated"><a class="ae lz" href="https://github.com/nmallya/containerdemo" rel="noopener ugc nofollow" target="_blank">本文的GitHub库</a>。我很快会打扫干净的。</li><li id="7fec" class="kq kr hi in b io kz is la iw lb ja lc je ld ji mo kw kx ky bi translated"><a class="ae lz" href="https://cloud.google.com/binary-authorization/" rel="noopener ugc nofollow" target="_blank">来自谷歌的二进制授权官方文档</a></li><li id="5343" class="kq kr hi in b io kz is la iw lb ja lc je ld ji mo kw kx ky bi translated">感谢<a class="ae lz" href="https://twitter.com/bradgeesaman" rel="noopener ugc nofollow" target="_blank"> Brad Geesaman </a>关于二进制授权的<a class="ae lz" href="https://github.com/GoogleCloudPlatform/gke-binary-auth-demo" rel="noopener ugc nofollow" target="_blank">教程</a>，它非常有帮助，提供了我在文章中用到的很多细节</li></ol></div></div>    
</body>
</html>