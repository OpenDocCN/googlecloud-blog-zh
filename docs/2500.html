<html>
<head>
<title>Handle Kubernetes Secrets the GitOps Way — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以GitOps的方式处理Kubernetes的秘密—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/handle-kubernetes-secrets-the-gitops-way-part-1-7079bd8221f3?source=collection_archive---------0-----------------------#2022-11-13">https://medium.com/google-cloud/handle-kubernetes-secrets-the-gitops-way-part-1-7079bd8221f3?source=collection_archive---------0-----------------------#2022-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b597b720955e25859df0246783574da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r2J_01SKliesTKom"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">伊万·肯尼迪在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f721" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GitOps是实现云原生应用持续部署的一种方式。它通过使用开发人员已经熟悉的工具，包括Git和持续部署工具，关注操作基础设施时以开发人员为中心的体验。</p><p id="e656" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GitOps的核心思想是拥有一个Git存储库，该存储库总是包含生产环境中当前所需的基础设施的声明性描述，以及一个使生产环境与存储库中描述的状态相匹配的自动化过程。如果您想要部署一个新的应用程序或更新一个现有的应用程序，您只需要更新存储库—自动化过程会处理所有其他事情。这就像用巡航控制来管理生产中的应用程序一样。</p><p id="791f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意的是，GitOps是<strong class="ix hj">而不是</strong>devo PS甚至DevOps 2.0之后的下一个东西。</p><p id="9713" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GitOps是一套部署实践，而DevOps是一种范式，或者更好的说法是一种思维模式。他们共享的原则使得团队能够更容易地将GitOps工作流用于现有的DevOps技术。</p><p id="7e85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们知道了什么是GitOps，让我们理解在Kubernetes集群中实现它时的一些实际挑战。</p><p id="63ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">挑战:</strong></p><p id="e04d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您的应用程序和基础设施都需要访问一些敏感信息，如数据库凭证、API密钥等。在Kubernetes环境中，通常使用Kubernetes的秘密来存储这些值，然后使用环境变量或挂载的卷将这些值公开给应用程序。然而，</p><ol class=""><li id="c3ef" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">Kubernetes的秘密并不完全安全，因为它们只是base64编码，很容易被解码。</li><li id="0f89" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">GitOps的一个关键需求是使用git作为应用程序和基础设施的真实来源。这要求将这些不安全的Kubernetes秘密提交给你的SCM，暴露整个组织的敏感信息。</li></ol><p id="fc09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">方法:</strong></p><p id="1b78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种方法可用于管理GitOps中的机密:</p><ol class=""><li id="04f4" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">加密的秘密，在SCM中检查之前加密Kubernetes秘密，由Kubernetes控制器解密为常规的Kubernetes秘密</li><li id="b0c2" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">外部机密，将机密存储在外部机密管理器系统中，如GCP机密管理器、哈希公司保险库等，并提交对这些外部机密的引用，这些外部机密由Kubernetes控制器提取，并作为常规Kubernetes机密应用到集群。</li></ol><p id="c263" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我们将看到如何使用Bitnami Sealed Secrets 项目来使用方法1。</p><p id="016f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">解决方案:</strong></p><p id="9536" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">《密封的秘密》由两部分组成:</p><ol class=""><li id="9a7a" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">集群侧控制器/操作员</li></ol><p id="3e7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.一个客户端实用程序:<strong class="ix hj"> kubeseal </strong></p><p id="3566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加密是使用kubeseal完成的，它生成一个<strong class="ix hj"> SealedSecret </strong>定制资源，集群端控制器对该资源进行解密并将其转换为Kubernetes秘密对象</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/84a78c440c4fbc9ac0fdbfce388ec65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*sNQIX-_ffAEi1tQfPMD1Mg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">密封的秘密工作</figcaption></figure><p id="2b58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，需要做三件事:</p><ol class=""><li id="2ac8" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">在目标集群中安装Sealed Secrets控制器，并在本地客户端中安装kubeseal CLI</li><li id="968d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">下载将用于在客户端加密机密的公共证书，并加密机密。</li><li id="c6b3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">将SealedSecret对象检查到作为ArgoCD应用程序源的SCM repo。</li></ol><p id="c7d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">安装控制器和kubeseal: </strong></p><p id="f429" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要在本地安装kubeseal，只需从Github发布页面安装即可，如下所示:</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="2c62" class="kr ks hi kn b be kt ku l kv kw">wget https://github.com/bitnami-labs/sealed-secrets/releases/download/&lt;release-tag&gt;/kubeseal-&lt;version&gt;-linux-amd64.tar.gz<br/>tar -xvzf kubeseal-&lt;version&gt;-linux-amd64.tar.gz kubeseal<br/>sudo install -m 755 kubeseal /usr/local/bin/kubeseal</span></pre><p id="5964" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">安装控制器取决于您的Kubernetes部署方法。如果你已经使用了头盔或者Kustomize，那么这是你最好的选择，正如这里描述的<a class="ae iu" href="https://github.com/bitnami-labs/sealed-secrets#installation" rel="noopener ugc nofollow" target="_blank"/>。如果您编写常规的Kubernetes Yaml文件，那么您可以从这里的发布页面<a class="ae iu" href="https://github.com/bitnami-labs/sealed-secrets/releases/" rel="noopener ugc nofollow" target="_blank">下载controller.yaml文件。</a></p><p id="766e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">下载公共证书:</strong></p><p id="1f47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">理论上，您不需要下载公共证书，因为如果您的用户可以访问集群并且在kubeconfig文件中设置了正确的上下文，kubeseal可以直接与集群通信</p><p id="5869" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，在企业设置中，理想情况下您的集群应该是私有的。因此，我们将使用离线密封方法。</p><p id="c459" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">安装控制器后，在bastion VM上运行以下命令来获取公共证书</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="e6c1" class="kr ks hi kn b be kt ku l kv kw">kubectl log --tail -1 -f -l name=sealed-secrets-controller -n &lt;namespace&gt;</span></pre><p id="6d85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复制输出的证书并将其粘贴到本地的pem文件中。</p><p id="26f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们加密这个秘密。运行以下命令创建自定义资源。</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="dd51" class="kr ks hi kn b be kt ku l kv kw">kubeseal &lt;prod-secret.yaml --cert cert.pem -o yaml&gt; prod-sealed-secret.yaml</span></pre><p id="11a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将产生一个yaml文件，其中包含由加密数据组成的SealedSecret定制资源。</p><p id="1862" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您可以在您的SCM repo中安全地提交这个密封的秘密资源了。<strong class="ix hj">确保您没有提交原始机密和pem文件。</strong></p><p id="87e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦ArgoCD同步了集群和存储库之间的状态，您就可以通过运行以下命令来确认解密已经完成</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="3fb8" class="kr ks hi kn b be kt ku l kv kw">kubectl get secret &lt;secret-name&gt; -n &lt;namespace&gt;</span></pre><p id="554c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你应该看到一个普通的Kubernetes秘密物品，你的豆荚可以正常使用。</p><p id="8f42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">缺点:</strong></p><p id="a359" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然密封的秘密很棒，但这种方法肯定有一些缺点。显著的缺点如下:</p><ol class=""><li id="c39e" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">密钥轮换，然后将它传播到您的存储库，这对您的基础架构团队来说是一项巨大的工作。</li><li id="b213" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">最终，秘密对象仍然在您的存储库中，不管加密与否。恶意用户可以获取提交者的信息并发送社会工程漏洞，或者收集有助于攻击目标基础设施的线索。</li></ol><p id="fb6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">结论:</strong></p><p id="5c33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你正在开始你的GitOps之旅,《密封的秘密》是一个很好的解决方案，因为它很便宜，很容易开始和理解。然而，随着您的部署过程变得复杂和SecOps过程的发展，您将需要一个适当的秘密管理系统。</p><p id="0fdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本博客的下一部分，我们将深入探讨方法2——使用外部秘密管理系统，在该系统中，您只需将秘密的引用存储在您的存储库中。</p><p id="3dcb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">参考文献:</strong></p><p id="e9fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【https://codefresh.io/learn/gitops/ T4】</p><p id="0a1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank">https://www.gitops.tech/</a></p><p id="5957" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://betterprogramming.pub/why-you-should-avoid-sealed-secrets-in-your-gitops-deployment-e50131d360dd" rel="noopener ugc nofollow" target="_blank">https://better programming . pub/why-you-should-avoid-sealed-secrets-in-your-gitops-deployment-e 50131d 360 DD</a></p></div></div>    
</body>
</html>