<html>
<head>
<title>Managing Permissions on mounted SSH keys in Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云运行中管理装载的SSH密钥的权限</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/managing-permissions-on-mounted-ssh-keys-in-cloud-run-707f7fbf6a21?source=collection_archive---------2-----------------------#2022-12-19">https://medium.com/google-cloud/managing-permissions-on-mounted-ssh-keys-in-cloud-run-707f7fbf6a21?source=collection_archive---------2-----------------------#2022-12-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6bd77eaa094605ff2173fe5e5f53b759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QEPX-RocyxctdEAD_8MfA.png"/></div></div></figure><h1 id="2999" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">概述:</h1><p id="6dbf" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">CloudRun是谷歌的托管计算平台，让你可以直接在谷歌的可扩展基础设施上运行和扩展容器。这份特殊的文档可能会对那些试图使用SSH密钥(通过<a class="ae km" href="https://cloud.google.com/secret-manager/docs" rel="noopener ugc nofollow" target="_blank">Google Secrets Manager(GSM)</a>上传)将运行在CloudRun上的应用程序连接到其他服务的人有用。例如，连接到虚拟机的脚本、连接到数据库的应用程序等。我试图在一个GCE上执行一个用例来执行ansible脚本，并且遇到了更改已挂载SSH密钥的权限的特殊问题。本文档包含将ansible连接到GCE所执行的详细步骤，并为与ansible一起使用的已安装ssh密钥所出现的主要阻塞提供解决方法。</p><p id="f4cb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">默认情况下，Ansible希望在执行脚本之前有一个从主节点到远程节点的SSH连接。ssh连接可以通过多种方式执行，比如手动将私钥添加到主节点，使用ssh-agent，或者将私钥保存在机器上，并使用<em class="ks">ansi ble _ ssh _ private _ key _ file</em>标记从脚本中引用它。在GCP，遵循最佳安全实践，总是建议使用Secrets Manager将密钥存储和挂载到在Cloud Run中运行的容器。</p><h1 id="af91" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">步骤:</h1><p id="6bea" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">本节包含为解决和克服此问题而执行的所有步骤的详细信息。这个用例可以在高层次上划分为以下步骤，</p><ul class=""><li id="198d" class="kt ku hi jq b jr kn jv ko jz kv kd kw kh kx kl ky kz la lb bi translated">用脚本创建图像。</li><li id="4f3e" class="kt ku hi jq b jr lc jv ld jz le kd lf kh lg kl ky kz la lb bi translated">从CloudRun和VM创建网络连接。</li><li id="4c7a" class="kt ku hi jq b jr lc jv ld jz le kd lf kh lg kl ky kz la lb bi translated">管理CloudRun中的密钥。</li><li id="dc9e" class="kt ku hi jq b jr lc jv ld jz le kd lf kh lg kl ky kz la lb bi translated">管理挂载的密钥以匹配ansible的权限。</li></ul><h1 id="e6de" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用脚本创建映像:</h1><p id="263c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">从docker-hub使用了安装了ansible的ubuntu映像。对于这个POC，使用了一个简单的ansible脚本来创建一个示例文本文件。以下是用于此用例的所有文件的片段，</p><p id="7244" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">库存. ini文件:</p><pre class="lh li lj lk fd ll lm ln bn lo lp bi"><span id="8c8e" class="lq ir hi lm b be lr ls l lt lu">{ <br/>[targets]<br/>{internal-ip of VM}     ansible_connection=ssh        ansible_user={user-name}   ansible_ssh_common_args='-o StrictHostKeyChecking=no' ansible_ssh_private_key_file={secret-key-path}<br/>}</span></pre><p id="d5d2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">ansible-playbook.yaml:(在目标虚拟机中创建一个空的文本文件)</p><pre class="lh li lj lk fd ll lm ln bn lo lp bi"><span id="4ee3" class="lq ir hi lm b be lr ls l lt lu">- name: To change the permissions of key file in container<br/>  hosts: localhost<br/>  tasks:<br/>    - name: execute the local script to change permissions<br/>      script: /home/before_script.sh<br/>      register: log<br/><br/>    - debug: var=log  <br/><br/>- name: This is a hello-world example<br/>  hosts: {internal-ip of VM}<br/>  tasks:<br/>    - name: Create a file called '/tmp/testfile.txt' with the content 'hello world'.<br/>      copy:<br/>        content: hello world<br/>        dest: /tmp/testfile.txt</span></pre><p id="c370" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">before_script.sh</p><pre class="lh li lj lk fd ll lm ln bn lo lp bi"><span id="9a46" class="lq ir hi lm b be lr ls l lt lu">mkdir -p /root/secrets<br/>chown -R {username}:{username} /root/secrets<br/>chmod 755 -R /root/secrets<br/>cp /mount/{secret-key mounted} /root/secrets/cr-ansible-key<br/>cat /root/secrets/cr-ansible-key<br/>chmod 600 /root/secrets/*</span></pre><p id="3b2a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">docker映像一旦创建，就会被推送到google容器注册表中，CloudRun可以使用该映像来执行作业。要将容器映像推送到gcr中，创建并下载service-account.json文件，该文件具有连接到gcr的权限，并设置docker使用此服务帐户来推/拉映像。根据GCR标准标记新图像，并将图像推送到gcr存储库。(<a class="ae km" href="https://cloud.google.com/container-registry/docs/pushing-and-pulling" rel="noopener ugc nofollow" target="_blank">从gcr推/拉图像</a>)。以下命令用于连接gcr和推/拉映像。</p><pre class="lh li lj lk fd ll lm ln bn lo lp bi"><span id="21ad" class="lq ir hi lm b be lr ls l lt lu">** to save changes made to the running container ** <br/>Docker commit $containername (this will create a new image)<br/><br/>** connect to gcr using docker **<br/>docker login -u _json_key --password-stdin https://gcr.io &lt; account.json<br/><br/>** push/pull images into gcr ** <br/>docker tag ${imagename according to gcr std}<br/>docker push ${imagename}</span></pre><h1 id="6a80" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建连接和云运行作业执行:</h1><p id="0c98" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要将CloudRun与VM连接起来，需要在与VM相同的VPC和区域上创建一个<a class="ae km" href="https://cloud.google.com/vpc/docs/configure-serverless-vpc-access" rel="noopener ugc nofollow" target="_blank">无服务器VPC访问连接器</a>。CloudRun作业使用这个连接器来建立从作业到VM的网络连接。</p><p id="b3ba" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">通过运行ssh-keygen命令创建私钥和公钥。将私钥保存为<a class="ae km" href="https://cloud.google.com/secret-manager/docs" rel="noopener ugc nofollow" target="_blank"> Google Secrets Manager </a>下的密钥，并将公钥添加到SSH元数据部分下的VM中。该元数据自动将公钥添加到虚拟机内部的authorized_keys文件下，用于ssh连接。在云运行服务下，打开云运行作业并创建新作业。(注意:Ansible containers只能作为作业部署，因为云运行服务要求应用程序监听某个端口——主要用于web应用程序。)</p><p id="4f6f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">选择容器映像、区域(必须与VPC连接器相同)，在General选项卡下，传递参数以在内部运行ansible-playbook(下面提供了屏幕截图)，引用在Variables &amp; Secrets选项卡下作为秘密添加的ssh-key，并将创建的连接器添加到Connections选项卡下的connect to the VM。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/e27e4fdb8795a84cea579197029ef8c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SLv4xeqFnEsSn2XV"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">CloudRun作业中入口点的参数</figcaption></figure><h1 id="ecc7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">管理装载的密钥以匹配ansible的权限:</h1><p id="3afb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在执行作业时，它抛出以下错误，</p><pre class="lh li lj lk fd ll lm ln bn lo lp bi"><span id="2db2" class="lq ir hi lm b be lr ls l lt lu">“fatal: [#.#.#.#]: UNREACHABLE! =&gt; {"changed": false, "msg": "Failed to connect to the host via ssh: Warning: Permanently added '#.#.#.#' (ED25519) to the list of known hosts.\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n@ WARNING: UNPROTECTED PRIVATE KEY FILE! @\r\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\nPermissions 0444 for '/mount/cr-ansible-key' are too open.\r\nIt is required that your private key files are NOT accessible by others.\r\nThis private key will be ignored.\r\nLoad key \"/mount/cr-ansible-key\": bad permissions\r\n{username}@#.#.#.#: Permission denied (publickey).", "unreachable": true}<br/>”</span></pre><p id="7583" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">当我们尝试从脚本中引用挂载的密钥时，它不能按预期从ansible工作，因为Cloud Run将密钥挂载为具有0444权限的只读文件，ansible预计密钥具有0600，并抛出一个错误，指出私钥具有太多的打开权限。</p><p id="1d42" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了克服这个错误，为用户创建了一个具有必要权限的文件夹— 0600，并将挂载的ssh-key复制到这个文件夹中。复制到该文件夹中的键现在在ansible-script中被引用，ansible-script执行时没有出现上述错误。这由在ansible-playbook.yaml中的主要ansible任务之前运行的before_script.sh来执行。</p><p id="14de" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这个用例是为通过secret manager安装密钥而编写的。然而，可以通过将密钥作为环境变量(可能导致安全问题)直接传递到脚本中或者通过点击Google Security Manager api直接访问密钥来传递密钥。</p></div></div>    
</body>
</html>