<html>
<head>
<title>Deploying Go Servers with Kubernetes on Container Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在容器引擎上部署带有Kubernetes的Go服务器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploying-go-servers-with-kubernetes-on-container-engine-3fee717a7e2a?source=collection_archive---------6-----------------------#2015-07-16">https://medium.com/google-cloud/deploying-go-servers-with-kubernetes-on-container-engine-3fee717a7e2a?source=collection_archive---------6-----------------------#2015-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="2ca8" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">注:Cross发布在<a class="ae jh" href="http://www.ianlewis.org/en/deploying-go-servers-kubernetes" rel="noopener ugc nofollow" target="_blank">我的博客</a>上。</p></blockquote><p id="ef58" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我试着在容器引擎上运行一个Go应用程序，但是<br/>找不到我要找的东西。有一些关于如何使用Go和Docker，以及如何使用Kubernetes的指南，但没有多少关于Go应用程序和容器引擎的。我还发现部署应用程序很容易，但大多数指南缺乏关于如何通过定期升级来维护应用程序的最佳实践的信息，所以我决定研究一下，并自己写一篇关于它的帖子。</p><p id="da1a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">请务必查看<a class="ae jh" href="https://cloud.google.com/container-engine/docs/" rel="noopener ugc nofollow" target="_blank">容器引擎文档</a>，以获取关于所用概念和命令的详细信息。</p><p id="e728" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这篇文章是Go博客上<a class="ae jh" href="https://blog.golang.org/docker" rel="noopener ugc nofollow" target="_blank">用<br/> Docker </a>部署Go服务器文章的延续。请确保您完成了Docker映像的构建。</p><h1 id="7f30" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">将Docker图像推送到Google容器注册表</h1><p id="0638" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">你将需要gcloud工具，所以确保你已经安装了<a class="ae jh" href="https://cloud.google.com/sdk/#Quick_Start" rel="noopener ugc nofollow" target="_blank"> Google Cloud <br/> SDK </a>。接下来，你需要<a class="ae jh" href="https://developers.google.com/console/help/#creatingdeletingprojects" rel="noopener ugc nofollow" target="_blank">在谷歌开发者<br/>控制台</a>上创建一个项目。记下项目id。</p><p id="1f0f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">使用正确的配置设置您的gcloud工具。用您的项目id替换<br/>下面的<em class="ik"> &lt;项目id &gt; </em>。用您选择的区域替换<em class="ik"> &lt;区域&gt; </em>:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2dba" class="kx jm hi kt b fi ky kz l la lb">$ gcloud config set project &lt;project-id&gt;<br/>$ gcloud config set compute/zone &lt;zone&gt;</span></pre><p id="8a77" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">一旦你完成了，你将需要使用docker标记<br/>图片。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="15b7" class="kx jm hi kt b fi ky kz l la lb">$ docker tag outyet gcr.io/&lt;project-id&gt;/outyet:v1</span></pre><p id="3e4c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这将设置存储库，并用版本“v1”对其进行标记。接下来将<br/>图像推送到注册表中。您可能会收到关于安装“预览版”<br/>组件的警告。当被询问时，只需说“是”来安装它们。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="92a1" class="kx jm hi kt b fi ky kz l la lb">$ gcloud preview docker push gcr.io/&lt;project-id&gt;/outyet:v1</span></pre><h1 id="1851" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">库伯内特构型</h1><p id="c125" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">我们将为我们的应用程序创建一个<a class="ae jh" href="https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/replication-controller.md" rel="noopener ugc nofollow" target="_blank">复制控制器</a>和<a class="ae jh" href="https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md" rel="noopener ugc nofollow" target="_blank">服务</a>。</p><p id="2296" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">复制控制器配置我们的应用程序将如何在Kubernetes中运行和维护，该服务允许我们的容器作为一个逻辑服务/应用程序被访问。用下面的内容创建一个<em class="ik"> outyet-rc.yml </em>文件。我们将使用新版本的API:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1597" class="kx jm hi kt b fi ky kz l la lb">kind: ReplicationController<br/>apiVersion: v1<br/>metadata:<br/>name: outyet-v1<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    name: outyet<br/>    version: “1”<br/>  template:<br/>  metadata:<br/>    labels:<br/>      name: outyet<br/>      version: “1”<br/>  spec:<br/>    containers:<br/>      — image: gcr.io/&lt;project-id&gt;/outyet:v1<br/>        name: outyet<br/>        ports:<br/>          — containerPort: 8080<br/>            hostPort: 8080<br/>            protocol: TCP</span></pre><p id="9a66" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">接下来，我们将为我们的应用程序创建一个服务。用下面的内容创建一个“outyet-service.yml ”:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="41c4" class="kx jm hi kt b fi ky kz l la lb">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: outyet<br/>  labels:<br/>    name: outyet<br/>spec:<br/>  ports:<br/>    — port: 80<br/>      targetPort: 8080<br/>      protocol: TCP<br/>  selector:<br/>    name: outyet<br/>  type: LoadBalancer<br/></span></pre><h1 id="c1c9" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">部署容器引擎集群</h1><p id="c293" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">接下来，我们将部署我们的容器引擎集群。我们将再次使用gcloud工具。您可能会收到关于安装“alpha”组件的<br/>警告。当被询问时，只需说“是”来安装它们。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="14e3" class="kx jm hi kt b fi ky kz l la lb">$ gcloud alpha container clusters create outyet<br/>$ gcloud config set container/cluster outyet</span></pre><h1 id="faa4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">创建复制控制器</h1><p id="9036" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">创建集群后，我们可以部署应用程序。首先，我们将创建复制控制器:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0029" class="kx jm hi kt b fi ky kz l la lb">$ gcloud alpha container kubectl create -f outyet-rc.yml</span></pre><p id="28dd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">豆荚需要几分钟才能出来。您可以使用以下命令查看pod是否准备好了<br/>:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="fd01" class="kx jm hi kt b fi ky kz l la lb">$ gcloud alpha container kubectl get pods</span></pre><p id="07ab" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这些豆荚一开始会说它们的状态是“待定”,但当它们准备好时会变成<br/> <em class="ik">运行</em>。</p><h1 id="5315" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">创建服务</h1><p id="7322" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">使用以下命令创建服务。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="db76" class="kx jm hi kt b fi ky kz l la lb">$ gcloud alpha container kubectl create -f outyet-service.yml</span></pre><p id="f6cd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">创建服务后，通过查看该命令的<br/>输出，我们可以看到它已经创建:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9ce4" class="kx jm hi kt b fi ky kz l la lb">$ gcloud alpha container kubectl get services</span></pre><p id="05df" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">该服务使用容器引擎的<em class="ik">负载平衡器</em>特性为我们的服务建立一个<br/>网络负载平衡器。我们可以使用以下命令获取服务的外部IP:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="648f" class="kx jm hi kt b fi ky kz l la lb">$ gcloud compute forwarding-rules list</span></pre><p id="0aa1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这将显示我们服务的IP地址。记下IP地址。<br/>最后，我们可以创建一个防火墙规则来允许访问我们的节点:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b2d8" class="kx jm hi kt b fi ky kz l la lb">$ gcloud compute firewall-rules create outyet-http — allow tcp:80 — target-tags k8s-outyet-node</span></pre><p id="ebbb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在我们可以在<em class="ik"> http:// &lt; IP地址&gt; / </em>查看应用</p><figure class="ko kp kq kr fd ld er es paragraph-image"><div class="er es lc"><img src="../Images/bd12bff32a10fe7c4760e62a0f4818df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-uFvFULa3QEtQqE1SuGeCQ.png"/></div></figure><h1 id="d8b4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">升级应用程序</h1><p id="9410" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">Go 1.4已经推出，所以应用程序并不令人兴奋。让我们更新它，以便它<br/>检查Go 1.5。让我们覆盖docker文件的CMD，使它看起来像这样:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3a7e" class="kx jm hi kt b fi ky kz l la lb">FROM golang:onbuild<br/>CMD [“go-wrapper”, “run”, “-version=1.5”]<br/>EXPOSE 8080</span></pre><p id="bee0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">接下来，我们将构建、标记和推送更新的docker映像:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5457" class="kx jm hi kt b fi ky kz l la lb">$ docker build -t outyet .<br/>$ docker tag outyet gcr.io/&lt;project-id&gt;/outyet:v2<br/>$ gcloud preview docker push gcr.io/&lt;project-id&gt;/outyet:v2</span></pre><p id="3be5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">接下来让我们更新我们的<em class="ik"> outyet-rc.yml </em>中所有显示为<em class="ik"> v1 </em>的地方，并将其更改为<em class="ik"> v2 </em>。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="719a" class="kx jm hi kt b fi ky kz l la lb"><br/>kind: ReplicationController<br/>apiVersion: v1<br/>metadata:<br/>  name: outyet-v2<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    name: outyet<br/>    version: “2”<br/>  template:<br/>    metadata:<br/>      labels:<br/>        name: outyet<br/>        version: “2”<br/>    spec:<br/>      containers:<br/>        — image: gcr.io/&lt;project-id&gt;/outyet:v2<br/>          name: outyet<br/>          ports:<br/>            — containerPort: 8080<br/>              hostPort: 8080<br/>              protocol: TCP</span></pre><p id="fca6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">接下来，将我们的复制控制器<em class="ik"> outyet-v1 </em>滚动更新到我们新的<br/> <em class="ik"> outyet-v2 </em>:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1295" class="kx jm hi kt b fi ky kz l la lb">$ gcloud alpha container kubectl rollingupdate outyet-v1 -f outyet-rc.yml — update-period=10s</span></pre><p id="b919" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这应该需要大约30秒来运行，因为我们有3个副本，并且我们已经将每个副本的更新周期设置为10秒。</p><p id="aa48" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">运行之后，我们可以再次刷新我们的应用程序，看看Go 1.5是否已经发布:)</p><figure class="ko kp kq kr fd ld er es paragraph-image"><div class="er es lc"><img src="../Images/a5c4e8e39da131182a37c953b45d1fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*AYqpJF0oNKADydUCUgnOCA.png"/></div></figure><h1 id="4b61" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">清除</h1><p id="ed7d" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">请确保删除您的群，这样您就不会被收取太多费用:)</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="94e0" class="kx jm hi kt b fi ky kz l la lb">$ gcloud alpha container clusters delete outyet</span></pre><h1 id="7996" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结论</h1><p id="6b69" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it ji kl iw ix jj km ja jb jk kn je jf jg hb bi translated">我真的认为容器是未来每个人开发应用程序的方式，所以希望这给了你一个如何部署Go应用程序并使用容器引擎升级它的想法。下一步，尝试一下Kubernetes repo中的许多示例应用程序。</p></div></div>    
</body>
</html>