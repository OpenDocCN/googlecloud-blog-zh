<html>
<head>
<title>How to set up Cloud Build for Firebase Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Firebase云功能设置云构建</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-set-up-cloud-build-for-firebase-cloud-functions-cffcf2812302?source=collection_archive---------0-----------------------#2018-10-05">https://medium.com/google-cloud/how-to-set-up-cloud-build-for-firebase-cloud-functions-cffcf2812302?source=collection_archive---------0-----------------------#2018-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="http://soru.ai" rel="noopener ugc nofollow" target="_blank"> Soru </a>，我们系统的一部分运行在Firebase云功能和Firebase主机上。我们的设置由各种环境组成，如staging和prod。我们需要一个简单的CI/CD解决方案，所以我们决定使用Google Cloud Build。</p><p id="b7ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将讨论如何通过云构建配置来部署云功能。我们的渐进式web应用程序是使用完全相同的原则构建和部署到Firebase主机的。</p><p id="937b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这些内容大部分存在于谷歌官方文档中，即这里的<a class="ae jd" href="https://cloud.google.com/cloud-build/docs/configuring-builds/build-test-deploy-artifacts" rel="noopener ugc nofollow" target="_blank">和这里的</a>和<a class="ae jd" href="https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-secrets-credentials" rel="noopener ugc nofollow" target="_blank">和</a>，但也有一些问题。我们想给你一个经过测试和部署的工作示例。</p><h1 id="9fdc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">构建Firebase SDK</h1><p id="99a0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，您需要为您的项目构建firebase SDK，这样您就可以从云构建配置中调用<code class="du kh ki kj kk b">firebase deploy</code>。这是你需要做的一次性事情，所以如果你愿意，你可以把它放在一个单独的回购中。</p><p id="4993" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是Dockerfile文件:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="d466" class="kt jf hi kk b fi ku kv l kw kx"># Node 6<br/>FROM node:boron<br/># install Firebase CLI<br/>RUN npm install -g firebase-tools</span><span id="243c" class="kt jf hi kk b fi ky kv l kw kx">ENTRYPOINT ["/usr/local/bin/firebase"]</span></pre><p id="b2e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您对firebase函数使用Node8运行时，在部署过程中使用await/async或其他Node 8特定特性时会出现语法错误。原因是我们在上面的docker文件中使用的节点版本实际上是节点6。这在Google Cloud文档中并没有明确说明，所以它可能会派上用场。节点8的正确Dockerfile应该是:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="044f" class="kt jf hi kk b fi ku kv l kw kx"># Node 8<br/>FROM node:carbon<br/># install Firebase CLI<br/>RUN npm install -g firebase-tools</span><span id="13ee" class="kt jf hi kk b fi ky kv l kw kx">ENTRYPOINT ["/usr/local/bin/firebase"]</span></pre><p id="49bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有config.yaml</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="76a7" class="kt jf hi kk b fi ku kv l kw kx">steps:<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  args: [ 'build', '-t', 'gcr.io/[PROJECT_ID]/firebase', '.' ]<br/>images:<br/>- 'gcr.io/[PROJECT ID]/firebase'</span></pre><p id="8334" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后你跑</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="98f1" class="kt jf hi kk b fi ku kv l kw kx">gcloud builds submit --project [PROJECT_ID]--config=config.yaml .</span></pre><p id="0eeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在Google的私有容器注册表中构建并存储图像，以备后用。</p><h1 id="87da" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">糟糕的解决方案</h1><p id="83f0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了从服务帐户运行<code class="du kh ki kj kk b">firebase deploy</code>,我们需要生成一个访问令牌。运行以下命令并记下令牌。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="a63a" class="kt jf hi kk b fi ku kv l kw kx">firebase login:ci</span></pre><p id="07e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，编写我们将在构建触发器中使用的云构建配置非常简单。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="cca4" class="kt jf hi kk b fi ku kv l kw kx">steps:<br/>  - name: 'gcr.io/cloud-builders/npm:node-6.14.4'<br/>    args: [ 'install' ]<br/>  - name: 'gcr.io/[PROJECT_ID]/firebase'<br/>    args: [ 'deploy', '--project', [PROJECT_ID], '--token', '[TOKEN]']</span></pre><p id="f6f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行npm安装时，请注意<code class="du kh ki kj kk b">node-6.14.4</code>标记。我不断得到以下错误，因为默认使用的<code class="du kh ki kj kk b">node-8.12.0</code>与我的设置不兼容。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="a841" class="kt jf hi kk b fi ku kv l kw kx">Step #1: Error: Error parsing triggers: Failed to load gRPC binary module because it was not installed for the current system<br/>Step #1: Expected directory: node-v48-linux-x64-glibc<br/>Step #1: Found: [node-v57-linux-x64-glibc]</span></pre><p id="33ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，如果你想检查上面的配置，这是一个明显的问题。永远不要让您的访问标记出现在源代码管理中。因此，我强烈建议不要使用上面的脚本。相反，您可以将您的令牌存储在Google云密钥管理服务中，并将其作为一个秘密环境变量放入您的云构建配置中。</p><h1 id="b993" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">好的解决方案</h1><p id="9d7a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，我们需要创建一个钥匙链和一把钥匙。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="de75" class="kt jf hi kk b fi ku kv l kw kx">gcloud kms keyrings create [KEYRING_NAME] \<br/>  --location global \<br/>  --project=[PROJECT_ID]</span><span id="ec37" class="kt jf hi kk b fi ky kv l kw kx">gcloud kms keys create [KEY_NAME] \<br/>  --location=global \<br/>  --keyring=[KEYRING_NAME] \<br/>  --purpose=encryption \<br/>  --project=[PROJECT_ID]</span></pre><p id="8e86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要使用由<code class="du kh ki kj kk b">firebase login:ci</code>生成的令牌，并将它赋给一个环境变量。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="0f46" class="kt jf hi kk b fi ku kv l kw kx">export FIREBASE_TOKEN=[TOKEN]</span></pre><p id="7d71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您错误地登记或分发了令牌，您总是可以通过执行<code class="du kh ki kj kk b">firebase logout --token [TOKEN]</code>来撤销它。否则，这些令牌没有过期时间，因此它们永远有效。</p><p id="779d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，您需要加密令牌，以便我们可以在配置中使用加密版本。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="5ebc" class="kt jf hi kk b fi ku kv l kw kx">echo -n $FIREBASE_TOKEN | gcloud kms encrypt \<br/>  --plaintext-file=- \<br/>  --ciphertext-file=- \<br/>  --location=global \<br/>  --project=[PROJECT_ID] \<br/>  --keyring=[KEYRING_NAME] \<br/>  --key=[KEY_NAME] | base64</span></pre><p id="f47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要忘记将项目id放在加密脚本中。如果您只有一个项目，默认设置将会起作用。然而，如果不同的环境有不同的项目，事情可能会变得混乱。</p><p id="f15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，您有了一个可以安全分发的加密base64字符串。</p><p id="cb11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">云构建的新配置如下所示:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="584e" class="kt jf hi kk b fi ku kv l kw kx">steps:<br/>- name: 'gcr.io/cloud-builders/npm:node-6.14.4'<br/>  args: [ 'install' ]<br/>- name: 'gcr.io/[PROJECT_ID]/firebase'<br/>  args: [ 'deploy', '--project', '[PROJECT_ID]']<br/>  secretEnv: ['FIREBASE_TOKEN']<br/>secrets:<br/>- kmsKeyName: projects/[PROJECT_ID]/locations/global/keyRings/[KEYRING_NAME]/cryptoKeys/[KEY_NAME]<br/>  secretEnv:<br/>    FIREBASE_TOKEN: [ENCRYPTED_TOKEN]</span></pre><p id="d5e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在编写如下部署步骤时遇到了一个问题:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="35a5" class="kt jf hi kk b fi ku kv l kw kx">- name: 'gcr.io/[PROJECT ID]/firebase'<br/>  args: [ 'deploy', '--project', '[PROJECT ID]', --token, '$$FIREBASE_TOKEN']<br/>  secretEnv: ['FIREBASE_TOKEN']</span></pre><p id="5811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的配置是基于<a class="ae jd" href="https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-secrets-credentials#example_build_request_using_an_encrypted_variable" rel="noopener ugc nofollow" target="_blank">文档</a>的，但是由于某种原因，这种传递令牌的方式不起作用，但是简单地设置环境变量<code class="du kh ki kj kk b">$FIREBASE_TOKEN</code>就足够了，所以您可以删除<code class="du kh ki kj kk b">--token</code>参数。(我还是不知道为什么这样不行。)</p><p id="fade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在结束之前的最后一句话:确保服务帐户<code class="du kh ki kj kk b">&lt;id&gt;@cloudbuild.gserviceaccount.com</code>具有<code class="du kh ki kj kk b">roles/cloudkms.cryptoKeyDecrypter</code>(云KMS密钥解密器)角色，以便它可以解密令牌。</p><h1 id="9447" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">设置构建触发器</h1><p id="d277" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">好了，现在你已经得到了你需要的一切。为了完整起见，我还将展示如何在控制台上设置构建触发器。</p><ul class=""><li id="8eaf" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">转到GCP控制台并搜索构建触发器</li><li id="c3b0" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">添加触发器并选择您的存储库托管选项。我们的是GitHub。</li><li id="0ef6" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">认证后，您将看到以下配置页面。</li></ul><figure class="kl km kn ko fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ln"><img src="../Images/a026c9948d39aefbb7dcf4afd2eeb43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoX2FuwH5fB_ktO81t8xWg.png"/></div></div></figure><p id="7a24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，当我们将代码合并到<code class="du kh ki kj kk b">master</code>分支时，repo中的配置<code class="du kh ki kj kk b">/cloudbuild/staging.yaml</code>触发并将服务部署到登台环境。</p><p id="6749" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以配置您的代码，以便任何检入到任何分支的代码也可以启动测试管道。我们将在另一篇博文中向您展示如何将云构建结果与GitHub repo挂钩，这样您就可以在构建/测试失败时阻止合并。</p><p id="9376" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这有所帮助，并随时建议改进。</p><p id="4a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！</p></div></div>    
</body>
</html>