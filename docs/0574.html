<html>
<head>
<title>Kubernetes 110: Your First Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 110:您的首次部署</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-110-your-first-deployment-bf123c1d3f8?source=collection_archive---------0-----------------------#2018-04-19">https://medium.com/google-cloud/kubernetes-110-your-first-deployment-bf123c1d3f8?source=collection_archive---------0-----------------------#2018-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e09f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你已经<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16">读过我对Kubernetes </a>的介绍，你应该对构成Kubernetes的基本部分有很好的基础理解。然而，如果你和我一样，你不会完全理解一个概念，除非你亲自动手。本文是将服务实际部署到云的过程的系列文章中的第一篇。具体来说，本教程将介绍如何使用Google Kubernetes引擎部署Gitea，一个开源的git托管服务。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a8c4da3d53abaaed27f31c9186aeed72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bxty1VICQ5czvcGymLAhaA.png"/></div></div></figure><p id="507a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Gitea没有什么特别的地方，但是通过将一个任意的开源应用程序部署到云的过程将会给我们一些使用Kubernetes的实际操作经验。另外，最后你会得到一个很棒的自托管服务，你可以用它来托管你未来的项目！</p><h1 id="f79e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">设置集群</h1><h2 id="6092" class="ko jr hi bd js kp kq kr jw ks kt ku ka iq kv kw ke iu kx ky ki iy kz la km lb bi translated">kubectl和gcloud</h2><p id="c493" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">设置Kubernetes环境时使用的最重要的工具是<em class="lh"> kubectl </em>命令。这个命令允许您与Kubernetes API进行交互。它用于创建、更新和删除Kubernetes资源，如pod、部署和负载平衡器。</p><p id="51af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，有一个问题:<em class="lh"> kubectl </em>不能用于直接供应运行您的pod的节点或集群。这是因为Kubernetes的设计是平台不可知的。Kubernetes不知道也不关心它在哪里运行，所以它没有内置的方式来与您选择的云提供商通信，以代表您租用节点。因为我们在本教程中使用Google Kubernetes引擎，所以我们需要使用<em class="lh"> gcloud </em>命令来完成这些任务。</p><p id="a358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，<em class="lh"> gcloud </em>用于提供<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16"> my Kubernetes 101 post </a>上“硬件”下列出的资源，<em class="lh"> kubectl </em>用于管理“软件”下列出的资源</p><p id="d3ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程假设您的系统上已经安装了<em class="lh"> kubectl </em>和<em class="lh"> gcloud </em>。如果你是全新开始，你首先会想检查一下<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/quickstart" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎快速启动</a>的第一部分，注册一个GCP账户，建立一个项目，启用计费，并安装命令行工具。</p><p id="f8e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦您的环境准备就绪，您就可以通过运行以下命令来创建集群:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="c53a" class="ko jr hi lj b fi ln lo l lp lq"># create the cluster<br/># by default, 3 standard nodes are created for our cluster<br/>gcloud container clusters create my-cluster --zone us-west1-a</span><span id="9cc5" class="ko jr hi lj b fi lr lo l lp lq"># get the credentials so we can manage it locally through kubectl<br/># creating a cluster can take a few minutes to complete<br/>gcloud container clusters get-credentials my-cluster \<br/>     --zone us-west1-a</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ls"><img src="../Images/b86a4076046a9ca92e71cd4b2601a7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GurIVeqjKYDigegfXE3oA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">我们现在有一个由三个n1-standard1节点组成的调配集群</figcaption></figure><p id="b81b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<em class="lh"> gcloud </em>命令，你还可以通过谷歌云控制台页面管理你的资源。运行前面的命令后，您应该看到您的集群出现在GKE部分下的<a class="ae jd" href="https://console.cloud.google.com/kubernetes" rel="noopener ugc nofollow" target="_blank">。您还应该在GCE部分</a>下看到一个配置为您的节点<a class="ae jd" href="https://console.cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank">的虚拟机列表。请注意，虽然GCE UI允许您从该页面删除虚拟机，但它们是由集群管理的，当集群发现它们丢失时，会重新创建它们。当您完成本教程并希望永久删除虚拟机时，您可以通过删除群集本身来一次删除所有内容。</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/5f5a61fcbc4eb25c0f6e694ab6a2aa67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZhS4icedu0sFKHXW6c4v1w.png"/></div></div></figure><h1 id="3466" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">部署应用程序</h1><h2 id="9ab5" class="ko jr hi bd js kp kq kr jw ks kt ku ka iq kv kw ke iu kx ky ki iy kz la km lb bi translated">YAML:声明式基础设施</h2><p id="4d22" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">既然我们的集群已经上线，是时候让它发挥作用了。向Kubernetes添加资源有两种方式:通过命令行使用<code class="du ly lz ma lj b">kubectl add</code>进行交互，以及通过在<a class="ae jd" href="https://docs.ansible.com/ansible/latest/YAMLSyntax.html" rel="noopener ugc nofollow" target="_blank"> YAML </a>文件<a class="ae jd" href="#34aa" rel="noopener ugc nofollow"> </a>中定义资源进行声明。</p><p id="8c30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然使用<code class="du ly lz ma lj b">kubectl add</code>的交互式部署对于实验来说很棒，但是当你想要构建可维护的东西时，YAML是一个不错的选择。通过将所有的Kubernetes资源写入YAML文件，可以将集群的整个状态记录在一组易于维护的文件中，这些文件可以像系统的其他部分一样进行版本控制和管理。这样，托管服务所需的所有指令都可以与代码一起保存。</p><h2 id="7c9d" class="ko jr hi bd js kp kq kr jw ks kt ku ka iq kv kw ke iu kx ky ki iy kz la km lb bi translated">添加Pod</h2><p id="0205" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">为了展示Kubernetes YAML文件的基本示例，让我们向集群添加一个pod。创建一个名为gitea.yaml的新文件，并用以下文本填充它:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="18bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个豆荚是相当基本的。第2行声明我们正在创建的资源类型是一个pod第1行说这个资源是在Kubernetes API的v1中定义的。第3–8行描述了我们的pod的属性。在这种情况下，pod的原始名称是“gitea-pod”，它包含一个我们称之为“gitea-container”的容器。</p><p id="5bc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第8行是最有趣的部分。这一行定义了我们想要运行的容器图像；在这种情况下，图像在<em class="lh"> gitea/gitea </em>存储库中标记为1.4。Kubernetes将告诉内置的容器运行时找到所请求的容器映像，并将其下拉到pod中。因为默认的容器运行时是Docker，所以它会找到托管在Dockerhub上的gitea存储库，并下拉请求的映像。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="5bf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经写出了YAML，我们将它应用到我们的集群:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="8852" class="ko jr hi lj b fi ln lo l lp lq">kubectl apply -f gitea.yaml</span></pre><p id="543a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个命令将导致Kubernetes读取我们的YAML文件，并相应地更新集群中的任何资源。要查看新创建的pod的运行情况，您可以运行<code class="du ly lz ma lj b">kubectl get pods</code>。你应该看到吊舱在运行。</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="7712" class="ko jr hi lj b fi ln lo l lp lq">$ kubectl get pods</span><span id="2793" class="ko jr hi lj b fi lr lo l lp lq">NAME        READY     STATUS    RESTARTS   AGE<br/>gitea-pod   1/1       Running   0          9m</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/24f4c454505b00c0793d104f36c42a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yfjysGL85QF6qoO7-bYXQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">Gitea现在在集群的一个pod中运行</figcaption></figure><p id="983d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果需要更多信息，可以使用以下命令查看容器的标准输出:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="730c" class="ko jr hi lj b fi ln lo l lp lq">$ kubectl logs -f gitea-pod</span><span id="5c29" class="ko jr hi lj b fi lr lo l lp lq">Generating /data/ssh/ssh_host_ed25519_key...<br/>Feb 13 21:22:00 syslogd started: BusyBox v1.27.2<br/>Generating /data/ssh/ssh_host_rsa_key...<br/>Generating /data/ssh/ssh_host_dsa_key...<br/>Generating /data/ssh/ssh_host_ecdsa_key...<br/>/etc/ssh/sshd_config line 32: Deprecated option UsePrivilegeSeparation<br/>Feb 13 21:22:01 sshd[12]: Server listening on :: port 22.<br/>Feb 13 21:22:01 sshd[12]: Server listening on 0.0.0.0 port 22.<br/>2018/02/13 21:22:01 [T] AppPath: /app/gitea/gitea<br/>2018/02/13 21:22:01 [T] AppWorkPath: /app/gitea<br/>2018/02/13 21:22:01 [T] Custom path: /data/gitea<br/>2018/02/13 21:22:01 [T] Log path: /data/gitea/log<br/>2018/02/13 21:22:01 [I] Gitea v1.4.0+rc1-1-gf61ef28 built with: bindata, sqlite<br/>2018/02/13 21:22:01 [I] Log Mode: Console(Info)<br/>2018/02/13 21:22:01 [I] XORM Log Mode: Console(Info)<br/>2018/02/13 21:22:01 [I] Cache Service Enabled<br/>2018/02/13 21:22:01 [I] Session Service Enabled<br/>2018/02/13 21:22:01 [I] SQLite3 Supported<br/>2018/02/13 21:22:01 [I] Run Mode: Development<br/>2018/02/13 21:22:01 Serving [::]:3000 with pid 14<br/>2018/02/13 21:22:01 [I] Listen: <a class="ae jd" href="http://0.0.0.0:3000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000</a></span></pre><p id="d918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，现在有一个服务器在我们集群的容器内运行！不幸的是，我们将无法访问它，直到我们开始开放入口通道(在未来的帖子中)。</p><h2 id="39b4" class="ko jr hi bd js kp kq kr jw ks kt ku ka iq kv kw ke iu kx ky ki iy kz la km lb bi translated">部署</h2><p id="3316" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">正如在<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16"> Kubernetes 101 </a>中所解释的，pod通常不会直接在Kubernetes中运行。相反，我们应该定义一个部署来管理我们的pod。</p><p id="340d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们删除已经运行的pod:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="a85d" class="ko jr hi lj b fi ln lo l lp lq">kubectl delete -f gitea.yaml</span></pre><p id="6a81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令从集群中删除YAML文件中定义的所有资源。我们现在可以修改我们的YAML文件，如下所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="51ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个看起来比我们之前做的豆荚要复杂一点。这是因为我们在这里实际上定义了两个不同的对象:部署本身(第1–9行)，以及它所管理的pod的模板(第10–17行)。</p><p id="450a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6号线是我们部署中最重要的部分。它定义了我们想要运行的pod的副本数量。在这个例子中，我们只请求一个副本，因为Gitea在设计时没有考虑到多个pod。<a class="ae jd" href="#7bb9" rel="noopener ugc nofollow"> </a></p><p id="b959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里还引入了另一个新概念:<a class="ae jd" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">标签和选择器</a>。标签只是用户定义的与Kubernetes资源相关的键值存储。选择器用于检索匹配给定标签查询的资源。在这个例子中，第13行将标签“app=gitea”分配给这个部署创建的所有pod。现在，如果部署需要检索它创建的所有pod的列表(例如，确保它们都是健康的)，它将使用在第8–9行定义的选择器。通过这种方式，部署可以通过搜索那些被分配了“app=gitea”标签的单元来跟踪它所管理的单元。</p><p id="2afd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下，标签是用户定义的。在上面的例子中，“app”对Kubernetes来说并没有什么特别的意义，它只是一种我们可能会发现对组织我们的系统有用的方式。话虽如此，但Kubernetes 会自动应用某些<a class="ae jd" href="https://kubernetes.io/docs/reference/labels-annotations-taints/" rel="noopener ugc nofollow" target="_blank">标签，其中包含有关系统的信息。</a></p><p id="daf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经创建了新的YAML文件，我们可以将其重新应用到我们的群集:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="e4fd" class="ko jr hi lj b fi ln lo l lp lq">kubectl apply -f gitea.yaml</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b115fc996998a451c04318b7a7ce857e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cOLcYihvUwX4JXGoU16Ew.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">现在，我们的pod由一个部署来管理</figcaption></figure><p id="cd08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们运行<code class="du ly lz ma lj b">kubectl get pods</code>,我们现在可以运行我们的新pod，正如我们的部署中所指定的:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="7488" class="ko jr hi lj b fi ln lo l lp lq">$ kubectl get pods</span><span id="0e4a" class="ko jr hi lj b fi lr lo l lp lq">NAME                               READY     STATUS     RESTARTS<br/>gitea-deployment-8944989b8-5kmn2   0/1       Running    0<br/></span></pre><p id="bab4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到关于部署本身的信息:</p><pre class="jf jg jh ji fd li lj lk ll aw lm bi"><span id="4a66" class="ko jr hi lj b fi ln lo l lp lq">$ kubectl get deployments</span><span id="b20c" class="ko jr hi lj b fi lr lo l lp lq">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>gitea-deployment   1         1         1            1           4m</span></pre><p id="bda8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试以确保一切正常，尝试用<code class="du ly lz ma lj b">kubectl delete pod &lt;pod_name&gt;</code>删除pod。你应该很快看到一个新的弹出回到它的位置。这就是部署的魔力！</p><p id="933b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能已经注意到新的pod有一个奇怪的，部分随机生成的名字。这是因为pod现在是由部署批量创建的，并且是短暂的。当包裹在部署中，豆荚应该被<a class="ae jd" href="http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/" rel="noopener ugc nofollow" target="_blank">认为是牛而不是宠物。</a></p><h2 id="1ef2" class="ko jr hi bd js kp kq kr jw ks kt ku ka iq kv kw ke iu kx ky ki iy kz la km lb bi translated">下一步是什么</h2><p id="568e" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我们现在有Gitea软件在我们的集群中运行，但是在我们可以通过web浏览器与它交互之前，我们还有一段路要走。这个系列的下一篇文章<a class="ae jd" rel="noopener" href="/@sanche/kubernetes-120-networking-basics-3b903f13093a">在这里</a>，讲述了Kubernetes的基本网络特性。本系列的后续文章将讨论持久存储、环境变量等等。请务必在Medium和<a class="ae jd" href="https://twitter.com/DanSanche21" rel="noopener ugc nofollow" target="_blank"> Twitter (@DanSanche21) </a>上关注我，以便在新文章发布时获得通知。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="235b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">脚注</p><ol class=""><li id="34aa" class="mk ml hi ih b ii ij im in iq mm iu mn iy mo jc mp mq mr ms bi translated">^ JSON也可以，但是YAML是标准的</li></ol><p id="7bb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<a class="ae jd" href="#450a" rel="noopener ugc nofollow"> ^ </a> Gitea被设计成在一台服务器上本地运行。它假设它运行在一台机器上，可以在没有冲突的情况下读写文件到它的目录中。如果我们创建Gitea pod的多个副本，并试图让它们访问相同的数据，这些副本将不知道如何协调读取和写入，这可能会导致问题。因为Gitea的设计不能正确地协调多个pod，所以在集群中拥有多个副本是没有意义的。</p></div></div>    
</body>
</html>