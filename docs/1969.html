<html>
<head>
<title>Automating tenant pod scheduling using Policy Controller mutations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用策略控制器突变自动化租户pod调度</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/automating-tenant-pod-scheduling-using-policy-controller-mutations-b325f4616943?source=collection_archive---------1-----------------------#2021-09-24">https://medium.com/google-cloud/automating-tenant-pod-scheduling-using-policy-controller-mutations-b325f4616943?source=collection_archive---------1-----------------------#2021-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/80e1216a3ce4b26adb2d1692ba095626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Kcw4qJvieT4Yh46Bdry9Q.png"/></div></div></figure><div class=""/><p id="a32d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">这篇文章描述了使用Anthos配置管理</em> <a class="ae jp" href="https://cloud.google.com/anthos-config-management/docs/concepts/policy-controller" rel="noopener ugc nofollow" target="_blank"> <em class="jo">策略控制器</em> </a> <em class="jo"> </em> <a class="ae jp" href="https://cloud.google.com/anthos-config-management/docs/how-to/mutation" rel="noopener ugc nofollow" target="_blank"> <em class="jo">突变</em> </a> <em class="jo">在多租户GKE集群中的租户名称空间中自动配置pod。</em></p><p id="7333" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于多租户用例，通常为每个租户划分Kubernetes集群的部分。在最简单的情况下，这可能意味着为每个租户创建一个名称空间。然而，对于其他用例，您可能还希望在专用节点上运行您的租户工作负载。例如，如果您的租户需要更好的相互隔离，或者需要特定的机器配置文件或硬件，如GPU。</p><p id="167f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，您需要确保部署到一个租户名称空间的任何pod只被调度到专用于该租户的节点上。您通常通过对节点应用特定于租户的污点和标签，然后对租户的pod应用相应的容差和节点亲和性来解决这个问题。</p><ul class=""><li id="0ec9" class="jq jr ht is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated"><a class="ae jp" href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank"> <em class="jo">节点相似性</em> </a>是pod的一个属性，<em class="jo">将它们吸引</em>到一组节点</li><li id="893d" class="jq jr ht is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated"><a class="ae jp" href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">污点</em> </a>则相反——它们允许一个节点<em class="jo">排斥</em>一组豆荚</li></ul><p id="4ea0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以同时使用nodeAffinity和taints来确保给定租户的pod只被调度到适当的节点上。请注意，如果您单独使用污点，pod可能会被调度到某个其他未被污染的节点上。您还必须使用nodeAffinity来确保pod本身需要一个适当的节点。</p><h2 id="0218" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">创建租户节点</h2><p id="8e3e" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">使用GKE，您可以为每个租户创建一个专用的节点池。您可以<a class="ae jp" href="https://cloud.google.com/kubernetes-engine/docs/how-to/node-taints" rel="noopener ugc nofollow" target="_blank">将污点</a>和标签应用到节点池，以便污点和标签应用到池中的所有节点(以及任何未来的节点，例如由自动缩放器创建的节点)。</p><p id="bf5e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的代码片段为<em class="jo">租户1 </em>创建了一个新的节点池，并应用了一个引用租户名称的污点和标签。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="dd6f" class="ke kf ht lj b fi ln lo l lp lq">gcloud container node-pools create tenant1-pool \<br/> ---zone europe-west1-b --cluster cluster-1 \<br/> --num-nodes=2 \<br/> --node-labels="tenant=tenant1" \<br/> --node-taints="tenant=tenant1:NoSchedule"</span></pre><h2 id="e400" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">配置窗格</h2><p id="e78e" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">接下来，我们需要配置我们的pod，以便它们只能被调度到正确的节点池上。具体来说，我们需要确保任何以租户名称空间为目标的pod都具有正确的nodeAffinity和容忍度。以下YAML显示了一个带有nodeAffinity和toleration集的部署片段。您可以在上面链接的文档中了解配置nodeAffinity和tolerations的不同方法——这不是我们在这里的原因！</p><figure class="le lf lg lh fd hk"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h2 id="cfd7" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">自动化pod配置</h2><p id="6bfd" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">上面的YAML在部署中正确地配置了pod，以便pod仅被调度到我们的<em class="jo"> tenant1-pool </em>节点池。然而，在每个部署或类似的部署中要包含相当多的样板文件，特别是如果每个租户有多个部署，并且我们在集群中有多个租户。</p><p id="f849" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有几种方法可以减少维护这种样板文件的工作量。我们可以使用模板引擎为每个租户应用正确的值。我们可以使用<a class="ae jp" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>来“修补和合并”部署，以便将节点亲和性和耐受性应用于每个部署。</p><p id="f9a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，如果我们能够<em class="jo">自动化</em>应用nodeAffinity和toleration到pod上，那将会非常有用。一种方法是用<em class="jo">变异</em> <a class="ae jp" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">接纳控制器</em> </a>。准入控制器拦截对Kubernetes API服务器的请求，以便在集群中创建对象之前对其进行验证或变更。使用这种准入控制器方法意味着单个租户部署不需要关心如何正确编写YAML。准入控制器自动添加配置。</p><h2 id="621a" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">Anthos配置管理策略控制器</h2><p id="0c81" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">从历史上看，编写准入控制器是一种高级用例。然而，<a class="ae jp" href="https://cloud.google.com/anthos-config-management/docs/overview" rel="noopener ugc nofollow" target="_blank"> Anthos配置管理</a> <a class="ae jp" href="https://cloud.google.com/anthos-config-management/docs/concepts/policy-controller" rel="noopener ugc nofollow" target="_blank">策略控制器</a>现在提供了一种设置简单变异的简单方法。</p><p id="f72a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PolicyController基于开源<a class="ae jp" href="https://open-policy-agent.github.io/gatekeeper/website/docs/" rel="noopener ugc nofollow" target="_blank">开放策略代理看门人</a>项目。PolicyController的核心用例是作为一个<em class="jo">验证</em>准入控制器。它在创建群集资源之前对其进行验证，例如，确保群集资源符合安全规则。然而，PolicyController现在也提供了一种简单的方法来进行简单的资源<a class="ae jp" href="https://cloud.google.com/anthos-config-management/docs/how-to/mutation" rel="noopener ugc nofollow" target="_blank">突变</a>。我们可以通过写一些YAML来改变资源！(请注意，在撰写本文时，策略控制器突变特性是GA前的特性)。</p><p id="cfe3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，首先您需要在您的GKE集群中安装策略控制器。您需要设置“启用突变”标志来激活突变功能。安装后，您可以通过应用YAMLs来配置突变，如下所示。</p><h2 id="5a5d" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">通过突变增加耐受性和nodeAffinity</h2><p id="42c4" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">下面的代码片段配置了一个变异，以便将一个<em class="jo">tenant = tenant 1:no schedule</em>容错添加到<em class="jo"> tenant1-ns </em>名称空间中的所有pod。我们实际上是将<em class="jo"> value </em>元素的内容附加到pod的<em class="jo">spec . tolerances</em>元素中。</p><figure class="le lf lg lh fd hk"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="41be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，下面的代码片段配置了一个变异，该变异将一个<em class="jo"> tenant1 </em> nodeAffinity添加到<em class="jo"> tenant1-ns </em>名称空间中的所有pod。</p><figure class="le lf lg lh fd hk"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h2 id="b02d" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">结论</h2><p id="9742" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">在这篇文章中，我们看到了如何使用<a class="ae jp" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank"> PolicyController突变</a>来自动配置租户pod，以便它们只被调度到特定于租户的节点上。这种方法提供了一些好处:</p><ul class=""><li id="6747" class="jq jr ht is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">租户应用程序开发人员无需担心如何正确配置他们的所有部署。适当的容差和节点关联性被添加到部署到租户命名空间的任何pod。</li><li id="c42a" class="jq jr ht is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">类似地，突变可以由平台团队或者管理集群的人来管理和维护。</li><li id="7087" class="jq jr ht is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">你不需要写任何代码。它内置于PolicyController中。</li></ul><p id="3e3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，您也应该密切关注最佳实践和注意事项:</p><ul class=""><li id="d40e" class="jq jr ht is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">变异的准入控制器可能会让开发人员感到困惑，因为他们的资源被悄悄地修改了</li><li id="94e1" class="jq jr ht is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">注意不要让突变覆盖了其他的pod配置。</li></ul></div></div>    
</body>
</html>