<html>
<head>
<title>Migrating applications between Kubernetes clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes集群之间迁移应用程序</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/migrating-applications-between-kubernetes-clusters-8455cf1bfccd?source=collection_archive---------0-----------------------#2021-01-11">https://medium.com/google-cloud/migrating-applications-between-kubernetes-clusters-8455cf1bfccd?source=collection_archive---------0-----------------------#2021-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="12a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；DR </strong>:在Kubernetes部署之间逐步迁移应用程序，以便不影响集群内流量，这可能是一项挑战。本文提出了一种利用标准但强大的工具的方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f73955029e16549520c8df458b72cba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8M92eajI4dtEZOgssncp_Q.png"/></div></div></figure><p id="dbcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从未在两个Kubernetes集群之间迁移过应用程序的请举手！</p><p id="aa8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很简单，对吧？不完全是。不总是。</p><p id="bc5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能有几个原因:例如，它可能是由于一些主要的平台升级，或者是由于持续的资源重组。</p><p id="8e2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然原则上这似乎是一项非常简单的任务，但是随着应用程序之间的依赖性增加，以及在迁移过程中减少停机时间的需求增加，这一过程可能会变得更加复杂。</p><p id="4e9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一种方法可以包括在新的集群中重新创建相同的环境，并且一旦新的部署就绪，最终切换任何外部DNS记录。遗憾的是，这并不总是可能的。</p><p id="30a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单的用例将让我们更好地理解这个问题以及如何解决它。</p><p id="ed8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们想象一个Kubernetes集群运行两个应用程序；一个依靠另一个。它们归不同的团队所有，这些团队可以以不同的速度迁移它们。</p><p id="f3fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将如何逐步迁移应用程序，避免停机？</p><p id="72b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续之前，让我们指出几个基本的、坚定的假设，这些假设与迁移并不严格相关，但肯定会降低总体集群维护工作量，并理顺迁移过程:</p><ul class=""><li id="e2fd" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">应用程序应该总是使用DNS名称而不是IP地址来引用内部和外部服务</li><li id="c898" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">清楚地了解我们的应用程序之间的关系很重要。这将有助于我们主动准备迁移，并及时应对可能出现的故障。</li></ul><p id="5a40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们陈述了游戏的基本规则，让我们回到我们的例子。</p><p id="6828" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何将一个应用程序移动到新的集群，使得另一个应用程序甚至不知道它的依赖关系已经被迁移，从而避免故障？</p><p id="af93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我开始触及问题的表面时，一些术语，如多集群、集群联合和服务网格，突然出现在我的脑海中。</p><p id="fbb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多工具可以用来构建多集群环境、创建集群联盟和高效管理“微服务网络”。T2只是众多例子中的一个。</p><p id="54d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了，看来我们成功了！…嗯，不完全是。</p><p id="68ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数多集群和联合工具都带有重要的警告:两个Kubernetes集群需要运行非常相似(如果不是相同的话)的Kubernetes版本，但情况肯定不总是这样。此外，许多用户可能会发现，仅仅为了迁移而使用这些工具是多余的，而且在他们的系统中注入这些工具是有风险的。</p><p id="bc35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文采用了一种更保守的方法，利用了一组基本但强大的工具，比如DNS、Kubernetes服务和一个可选的入口控制器。</p><h1 id="7b23" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">我的环境</h1><p id="3b2c" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我将使用<a class="ae kd" href="https://cloud.google.com/gcp" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>进行演示。这将包括几个Kubernetes集群(以及一些负载平衡器，在我们创建服务时提供)和云DNS。</p><p id="761f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还将利用<a class="ae kd" href="https://traefik.io" rel="noopener ugc nofollow" target="_blank"> Traefik </a>作为入口控制器。虽然这不是强制性的，但是强烈建议这样做，因为这样可以避免为每个要迁移的应用程序创建单个负载平衡器服务(以及相关的内部GCP负载平衡器)。我们一完成这些步骤，事情就会变得更清楚了。无论如何，记住你可以选择用你最喜欢的入口替换Traefik。</p><h1 id="687a" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">演示时间！</h1><p id="2c42" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我准备了两个空集群:<code class="du lh li lj lk b">cluster-old</code>和<code class="du lh li lj lk b">cluster-new</code>。</p><p id="8c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将开始在旧集群中部署两个应用程序:<code class="du lh li lj lk b">app1</code>和<code class="du lh li lj lk b">app2</code>。为了让实验更有趣，这两款应用将部署在不同的名称空间:分别是<code class="du lh li lj lk b">app1-ns</code>和<code class="du lh li lj lk b">app2-ns</code>。</p><p id="961f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个应用程序都由一个pod和一个引用它的同名ClusterIP服务组成。</p><p id="e4f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">App1是一个哑HTTP服务器，它在其根端口80上返回消息<code class="du lh li lj lk b">"Hello, I’m app1"</code>。</p><p id="d955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我用来创建pod的Kubernetes清单:</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="0f92" class="lp kf hi lk b fi lq lr l ls lt"># app1-pod.yaml</span><span id="2aad" class="lp kf hi lk b fi lu lr l ls lt">kind: Pod<br/>apiVersion: v1<br/>metadata:<br/>  name: app1<br/>  labels:<br/>    app: app1<br/>spec:<br/>  containers:<br/>    - name: app1<br/>      image: hashicorp/http-echo:0.2.3<br/>      args:<br/>        - "-text=Hello, I'm app1"<br/>        - "-listen=:80"</span></pre><p id="74d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是服务的一部分:</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="dc83" class="lp kf hi lk b fi lq lr l ls lt"># app1-svc.yaml</span><span id="fe94" class="lp kf hi lk b fi lu lr l ls lt">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: app1<br/>spec:<br/>  selector:<br/>    app: app1<br/>  ports:<br/>    - port: 80</span></pre><p id="4f01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lh li lj lk b">App2</code>是一个非常简单的客户端:它使用curl每秒查询一次<code class="du lh li lj lk b">app1</code>。将收到的回复写入系统标准输出，我们将能够看到它们查询容器日志。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="126a" class="lp kf hi lk b fi lq lr l ls lt"># app2-pod.yaml</span><span id="4fe8" class="lp kf hi lk b fi lu lr l ls lt">kind: Pod<br/>apiVersion: v1<br/>metadata:<br/>  name: app2<br/>  labels:<br/>    app: app2<br/>spec:<br/>  containers:<br/>    - name: app2<br/>      image: curlimages/curl:7.74.0<br/>      command: ["/bin/sh", "-c"]<br/>      args:<br/>        - &gt;<br/>          while true; do<br/>            curl -s -X GET http://app1.app1-ns<br/>            sleep 1<br/>          done</span></pre><p id="1cfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建名称空间并部署应用程序。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="bc21" class="lp kf hi lk b fi lq lr l ls lt">kubectl create namespace app1-ns<br/>kubectl apply -f app1-pod.yaml --namespace app1-ns<br/>kubectl apply -f app1-svc.yaml --namespace app1-ns</span><span id="cfc9" class="lp kf hi lk b fi lu lr l ls lt">kubectl create namespace app2-ns<br/>kubectl apply -f app2-pod.yaml --namespace app2-ns</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/8c178ea17f2853cdccd2cb0314190ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nemk1bSIi2pQ8PgYbjmpDg.png"/></div></div></figure><p id="3fc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标是将这些应用程序从旧集群迁移到新集群，其中只创建了两个空的名称空间。</p><p id="dcb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最关键的部分是迁移<code class="du lh li lj lk b">app1</code>就不用说了，以至于<code class="du lh li lj lk b">app2</code>都没注意到前者已经被挪过去了。</p><p id="32f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在高层次上，<strong class="ih hj">这个想法是在旧的集群中创建一个新的服务，它不是指向本地app1应用程序，而是通过一个外部DNS条目链接到它的一个克隆，位于新的集群中。</strong></p><p id="fa65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个过程中，在修改任何现有的路由之前，我们总是能够测试新创建的组件是否工作。</p><p id="a6d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始实现该机制，首先确保该机制在同一个集群中工作:<code class="du lh li lj lk b">app2</code>将很快通过外部DNS与<code class="du lh li lj lk b">app1</code>通信。</p><p id="4c2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装Traefik是第一步。我就不赘述了，因为这不是本文的目的。我只是简单地遵循了<a class="ae kd" href="https://doc.traefik.io/traefik/getting-started/install-traefik/" rel="noopener ugc nofollow" target="_blank">官方helm安装指南</a>，并添加了一个<a class="ae kd" href="https://cloud.google.com/kubernetes-engine/docs/how-to/internal-load-balancing" rel="noopener ugc nofollow" target="_blank">注释</a>来创建一个<a class="ae kd" href="https://cloud.google.com/load-balancing/docs/internal" rel="noopener ugc nofollow" target="_blank"> GCP内部负载平衡器</a>，而不是默认的<a class="ae kd" href="https://cloud.google.com/load-balancing/docs/https" rel="noopener ugc nofollow" target="_blank"> HTTP全局负载平衡器</a>，这个实验并不真正需要。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="5123" class="lp kf hi lk b fi lq lr l ls lt">kubectl create namespace traefik<br/><br/>helm repo add traefik https://helm.traefik.io/traefik<br/>helm repo update</span><span id="e9a4" class="lp kf hi lk b fi lu lr l ls lt">helm install \<br/>     --set service.annotations."cloud\.google\.com/load-balancer-type"=Internal \<br/>     --namespace traefik \<br/>     traefik \<br/>     traefik/traefik</span></pre><p id="d9e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几秒钟后，您应该会看到为Traefik LoadBalancer服务分配的专用IP地址。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="eb15" class="lp kf hi lk b fi lq lr l ls lt">kubectl get services -n traefik<br/><br/>NAME      TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)                      AGE<br/>traefik   LoadBalancer   10.72.4.210   192.168.100.16   80:31679/TCP,443:31228/TCP   45s</span></pre><p id="c2a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">把它记下来。我们很快就会需要它。</p><p id="2da5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转向云DNS，创建一个<a class="ae kd" href="https://cloud.google.com/dns/docs/zones#create-private-zone" rel="noopener ugc nofollow" target="_blank">私有DNS区域</a>。例如，<code class="du lh li lj lk b">mycompany.internal</code></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/29a16fd44e54a60f9239474d5e8c8149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e9hiRx3WlZcBeyIH"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">在云DNS中创建DNS专用区域</figcaption></figure><p id="26e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kd" href="https://cloud.google.com/dns/docs/records" rel="noopener ugc nofollow" target="_blank">创建一个A记录</a>，<code class="du lh li lj lk b"><em class="mb">old.mycompany.internal</em></code>，指向刚刚分配的负载平衡器IP。</p><p id="cdc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成后，您的DNS面板应该如下所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/1485bb617bac235f3f1dfecb4bec8cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NKmpJ9sPcIU8LOzu"/></div></div></figure><p id="8fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在旧集群中:</p><p id="2625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">制作您的<code class="du lh li lj lk b">app1</code>服务的副本。比如称之为<code class="du lh li lj lk b"><em class="mb">app1-internal</em></code>。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="4be1" class="lp kf hi lk b fi lq lr l ls lt"># app1-internal-svc.yaml</span><span id="fc45" class="lp kf hi lk b fi lu lr l ls lt">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: app1-internal<br/>spec:<br/>  selector:<br/>    app: app1<br/>  ports:<br/>    - port: 80</span></pre><p id="0925" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一条<a class="ae kd" href="https://doc.traefik.io/traefik/routing/providers/kubernetes-crd/#kind-ingressroute" rel="noopener ugc nofollow" target="_blank">进刀路线</a>。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="6607" class="lp kf hi lk b fi lq lr l ls lt"><em class="mb"># app1-ingress-route.yaml</em></span><span id="64e9" class="lp kf hi lk b fi lu lr l ls lt"><em class="mb">apiVersion: traefik.containo.us/v1alpha1<br/>kind: IngressRoute<br/>metadata:<br/>  name: app1<br/>spec:<br/>  entryPoints:<br/>    - web<br/>  routes:<br/>  - kind: Rule<br/>    match: Host(`app1.app1-ns`) || Host(`app1.app1-ns.svc.local`)<br/>    services:<br/>    - kind: Service<br/>      name: app1-internal<br/>      namespace: app1-ns<br/>      port: 80</em></span></pre><p id="5af6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们要么匹配目标主机名<code class="du lh li lj lk b">app1.app1-ns</code> <em class="mb"> </em>要么匹配<em class="mb"> </em> <code class="du lh li lj lk b">app1.app1-ns.svc.cluster.local</code>。这是因为，除了我们将实施的不同策略之外，请求仍将使用原始目的主机报头到达<code class="du lh li lj lk b">app1</code>。</p><p id="f086" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们部署这两个组件:</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="0aaf" class="lp kf hi lk b fi lq lr l ls lt">kubectl apply -f app1-internal-svc.yaml --namespace app1-ns<br/>kubectl apply -f app1-ingress-route.yaml --namespace app1-ns</span></pre><p id="80b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候验证我们的应用程序可以通过新路径到达了。为此，我已经进入了<code class="du lh li lj lk b">app2</code>客户端，并通过新地址手动卷曲<code class="du lh li lj lk b">app1</code>。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="d486" class="lp kf hi lk b fi lq lr l ls lt">kubectl exec -it -n app2-ns app2 /bin/sh<br/><br/>curl -H “Host: app1.app1-ns” http://old.mycompany.internal<br/>Hello, I'm app1</span></pre><p id="6193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我指定了一个主机头。如果不这样做，您将会收到Traefik的<code class="du lh li lj lk b"><em class="mb">“404: Page not found.”</em></code>回复。</p><p id="96dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个<a class="ae kd" href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname" rel="noopener ugc nofollow" target="_blank">外部名称</a>服务，指向<code class="du lh li lj lk b"><em class="mb">old.mycompany.internal</em></code> <em class="mb">。</em></p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="0991" class="lp kf hi lk b fi lq lr l ls lt">app1-ext-old-svc.yaml</span><span id="8b35" class="lp kf hi lk b fi lu lr l ls lt">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: app1<br/>spec:<br/>  externalName: old.mycompany.internal<br/>  type: ExternalName</span></pre><p id="7388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，用刚刚创建的服务替换<code class="du lh li lj lk b"><em class="mb">app1-ns</em></code>中原来的<code class="du lh li lj lk b">app1</code>服务。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="06ae" class="lp kf hi lk b fi lq lr l ls lt">kubectl replace -f Desktop/medium/app1-ext-old-svc.yaml -n app1-ns</span></pre><p id="a069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实验过程中，我一直在app2上记录日志，我从未明显注意到app1停止响应。</p><p id="46bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lh li lj lk b">App1</code>仍然生活在旧集群中，但是从现在开始，客户端请求转到ExternalName服务，出集群到云DNS，回到Traefik，通过新的<code class="du lh li lj lk b">app1-internal</code>服务，最后到pod。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/5ea11d9c78f0de495d1bb5a8f465bb0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCODy2-98WRTbtuv7THOQg.png"/></div></div></figure><h1 id="afca" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">迁移</h1><p id="5724" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">既然我们头脑中的机制起作用了，我们就为迁移做好了准备。</p><p id="393f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们设置新的集群。正如我们在旧版本中所做的:</p><ul class=""><li id="322c" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">在名称空间中部署<code class="du lh li lj lk b">app1</code>和<code class="du lh li lj lk b">app2</code>(命令同上)</li><li id="8415" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">部署Traefik(命令同上)。获取新的内部负载平衡器IP</li><li id="3635" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在<code class="du lh li lj lk b">mycompany.internal</code>中创建另一个A记录。将其称为<code class="du lh li lj lk b">new.mycompany.internal</code>，并指向新的集群入口IP</li><li id="b055" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">部署在旧集群中部署的相同Traefik IngressRoute</li><li id="59dc" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在<code class="du lh li lj lk b"><em class="mb">app1-ns</em></code>名称空间中部署<code class="du lh li lj lk b">app1-internal</code>服务(命令同上)</li></ul><p id="5f92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个指向刚刚创建的DNS名称的新ExternalName服务。</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="41f9" class="lp kf hi lk b fi lq lr l ls lt"># app1-ext-new-svc.yaml</span><span id="6c30" class="lp kf hi lk b fi lu lr l ls lt">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: app1<br/>spec:<br/>  externalName: new.mycompany.internal<br/>  type: ExternalName</span></pre><p id="1a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们用刚刚创建的服务替换旧集群中的旧ExternalName服务:</p><pre class="je jf jg jh fd ll lk lm ln aw lo bi"><span id="c17b" class="lp kf hi lk b fi lq lr l ls lt">kubectl replace -f Desktop/medium/svc-ext-name-new.yaml -n app1-ns</span></pre><p id="7af8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上没有停机，旧集群中的<code class="du lh li lj lk b">app2</code>客户机将开始与新集群中的<code class="du lh li lj lk b">app1</code>应用程序通信。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/c9b15ceb451191692b27f971436c9fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2r6vcuo5W-H2vNQxsTM15A.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">旧集群中的App2与新集群中的app1通信</figcaption></figure><p id="ba01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，这个过程对于<code class="du lh li lj lk b">app2</code>是完全透明的，因为我们没有改变其中对<code class="du lh li lj lk b">app1</code>的任何引用。</p><p id="d0c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以对<code class="du lh li lj lk b">app2</code>重复相同的过程，从而完成迁移。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/817b62d20a4c407b6ad9a63648c63382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4shBAEyX_9_2uyNLzs0Ag.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">应用程序已被移动到新群集。现在，它能够像在迁移之前一样引用app1</figcaption></figure><p id="081e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迁移完成后:</p><ul class=""><li id="9234" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><code class="du lh li lj lk b">app1</code>服务可以转换回ClusterIP服务</li><li id="5d83" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">旧的集群可以被移除</li><li id="ad87" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">可以删除新集群中的云DNS区域、Traefik和<code class="du lh li lj lk b"><em class="mb">app1-internal</em></code>服务</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/6194d2aaca05eaf64246b25387235a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0elahjpWkZlWChwuqpidbA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">用于迁移和旧集群的组件将被删除。迁移已完成</figcaption></figure><p id="9ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这是一个最小的设置，但是将相同的过程扩展到更大的部署应该是相当容易的，并且可以自动地大规模应用。但这是另一个话题了！</p><p id="df98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽情享受吧！</p><blockquote class="md me mf"><p id="b413" class="if ig mb ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">感谢<a class="mj mk ge" href="https://medium.com/u/4eb6c1562d42?source=post_page-----8455cf1bfccd--------------------------------" rel="noopener" target="_blank"> Ludovico Magnocavallo </a>分享你的想法并帮助我完成这篇文章！</p></blockquote></div></div>    
</body>
</html>