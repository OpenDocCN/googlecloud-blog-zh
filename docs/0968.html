<html>
<head>
<title>Google Cloud Run Deploy and Elasticity Benchmark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google云运行部署和弹性基准测试</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-run-deploy-and-elasticity-benchmark-15704e46c54?source=collection_archive---------1-----------------------#2019-04-10">https://medium.com/google-cloud/google-cloud-run-deploy-and-elasticity-benchmark-15704e46c54?source=collection_archive---------1-----------------------#2019-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="ded1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="1a59" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">谷歌刚刚宣布了Cloud Run，这是一种新的无服务器解决方案，可以在不管理底层基础设施的情况下运行容器化的应用程序。云运行完全管理服务的负载平衡和自动扩展。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/4e227fad61eabeb02b12dab707b6b33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*_tm9nijr2SW7M0dz.png"/></div></figure><p id="1437" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">在本文中，我将部署一个容器化的应用程序，并对其进行测试，重点关注:</p><ul class=""><li id="de43" class="ko kp hi jf b jg kj jk kk jo kq js kr jw ks ka kt ku kv kw bi translated">云运行部署服务的速度有多快</li><li id="d3d4" class="ko kp hi jf b jg kx jk ky jo kz js la jw lb ka kt ku kv kw bi translated">如何快速扩展云运行以处理大量并发用户</li></ul><h1 id="155e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">部署</h1><h2 id="edcb" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">Python应用程序</h2><p id="0d12" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们创建并部署一个简单的Python应用程序进行测试。详细说明可以在这里找到:<a class="ae lq" href="https://cloud.google.com/run/docs/quickstarts/build-and-deploy" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/run/docs/quick starts/build-and-deploy</a></p><p id="e808" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">该应用程序由两个文件组成:app.py和Dockerfile。它简单地返回“Hello World！”。</p><p id="c493" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">helloworld/app.py</p><pre class="kc kd ke kf fd lr ls lt lu aw lv bi"><span id="1cd6" class="lc ig hi ls b fi lw lx l ly lz">import os</span><span id="ebbb" class="lc ig hi ls b fi ma lx l ly lz">from flask import Flask</span><span id="e8b3" class="lc ig hi ls b fi ma lx l ly lz">app = Flask(__name__)</span><span id="c7d9" class="lc ig hi ls b fi ma lx l ly lz"><a class="ae lq" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def hello_world():<br/>    target = os.environ.get('TARGET', 'World')<br/>    return 'Hello {}!\n'.format(target)</span><span id="4162" class="lc ig hi ls b fi ma lx l ly lz">if __name__ == "__main__":<br/>    app.run(debug=True,host='0.0.0.0',port=int(os.environ.get('PORT', 8080)))</span></pre><h2 id="a573" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">构建容器映像</h2><p id="80b8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我将利用云构建来构建映像。在Dockerfile文件所在的目录中运行该命令。</p><pre class="kc kd ke kf fd lr ls lt lu aw lv bi"><span id="8d41" class="lc ig hi ls b fi lw lx l ly lz">gcloud builds submit — tag gcr.io/jeanno-cloud-run-test/helloworld</span></pre><p id="95ea" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">构建时间很大程度上取决于Dockerfile文件和应用程序的大小。对于这个简单的Python应用程序。只花了24秒就建成了。到目前为止，这只是一个标准的Docker图像构建，没有什么花哨的。</p><h1 id="0fc8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">部署时间</h1><p id="15c8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">此时，我已经构建了一个容器映像，它位于:</p><pre class="kc kd ke kf fd lr ls lt lu aw lv bi"><span id="022d" class="lc ig hi ls b fi lw lx l ly lz">gcr.io/jeanno-cloud-run-test/helloworld</span></pre><p id="dc23" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">现在，越来越有意思了。借助云运行，我可以在不到30秒的时间内快速轻松地将服务启动到就绪状态。我使用下面的命令来部署和测量所需的时间。</p><pre class="kc kd ke kf fd lr ls lt lu aw lv bi"><span id="19f7" class="lc ig hi ls b fi lw lx l ly lz">time gcloud beta run deploy hello — image gcr.io/jeanno-cloud-run-test/helloworld — region=us-central1 — allow-unauthenticated</span><span id="1ced" class="lc ig hi ls b fi ma lx l ly lz">Deploying container to Cloud Run service [hello] in project [jeanno-cloud-run-test] region [us-central1]<br/>✓ Deploying new service... Done.                     <br/>  ✓ Creating Revision...<br/>  - Routing traffic...<br/>Done.<br/>Service [hello] revision [hello-00001] has been deployed and is serving traffic at <a class="ae lq" href="https://hello-3o53mu62aa-uc.a.run.app" rel="noopener ugc nofollow" target="_blank">https://hello-3o53mu62aa-uc.a.run.app</a></span><span id="d411" class="lc ig hi ls b fi ma lx l ly lz">real    0m21.006s<br/>user    0m0.408s<br/>sys     0m0.082s</span></pre><p id="74ff" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">之后，我立即点击打开链接，在浏览器中打开。加载页面花了大约2秒钟。从开始部署到准备就绪，只需要大约23秒的时间。</p><p id="1b14" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">附注:我本可以在脚本中包含curl，并对其计时以获得更精确的度量，但这没关系，因为它不应该有太大的差异。</p><h1 id="cdaa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">横向扩展和压力测试</h1><h2 id="7838" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">方法学</h2><p id="acec" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在有趣的部分来了。我已经准备好了服务，是时候对它进行压力测试了。我将使用JMeter在美国中心1的n1-standard-64 (64个vCPUs，240 GB内存)计算引擎实例上执行测试。</p><p id="9599" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">由于计算引擎实例更靠近云运行区域(也在美国中心1)，往返时间要短得多，因此每秒可以实现更高的请求数。</p><p id="1363" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">我使用下面的JMeter命令开始测试。</p><pre class="kc kd ke kf fd lr ls lt lu aw lv bi"><span id="aa88" class="lc ig hi ls b fi lw lx l ly lz">jmeter -n -t test-plan.jmx -p jmeter.properties</span></pre><p id="57da" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">在测试计划中，我设置了一个5秒钟的斜坡，最多可以容纳5000个并发用户。每个用户由一个线程代表，线程将继续一个接一个地发出HTTP请求。按照test-plan.jmx中的规定，在JMeter中检查响应，以确保它具有HTTP状态代码200。测试将运行120秒。</p><p id="6715" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">由于当没有活动流量时，云运行扩展到0，我们可以想象它是一个处理大量意外峰值流量的空闲服务，需要快速扩展以匹配负载。</p><p id="f16b" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">我还为它指定了额外的JMeter属性，让它每10秒给我一个摘要，而不是默认的30秒。</p><h2 id="b9c4" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">结果</h2><p id="ec0b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">JMeter运行完毕后，会生成一个jmeter.log文件。让我们关注这三个指标:每秒请求数(RPS)、平均请求时间和最大请求时间。这里有一个图表来直观地显示结果。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es mb"><img src="../Images/72dd7ec59b7404ec7a8ddbeb3c8cb4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*koNAzF6o6e80cC05"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">JMeter结果</figcaption></figure><p id="987e" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">每秒的请求数在40秒内以指数级增长到60k以上，这是非常令人印象深刻的。平均值。在上升过程中，请求时间略少于1000毫秒，最终下降到不到100毫秒。最大值。请求时间在上升期间为5000毫秒到10000毫秒，然后迅速下降到不到2000毫秒。RTS在最后的下降是因为JMeter线程的下降，所以我们应该忽略这一部分。</p><p id="4da1" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">只有不到1%的错误(带有HTTP状态代码的713响应！= 200)发生在斜坡上升时间(7.1–17.1秒)开始时。并且在每个其他间隔中出现1或0个误差。</p><p id="a19c" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">即使在加速期间，大多数请求也在不到1000毫秒的时间内成功完成。同样，我没有配置任何东西来处理峰值。它完全由Cloud Run管理，以提供这样的可扩展性。</p><h1 id="7df7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">超越</h1><p id="b09c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">此时，你可能会问:“云运行的极限是什么？”。显然我还没有达到极限。</p><p id="8c29" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">在撰写本文时，Cloud Run中容器实例的最大数量被限制为1000个。每个容器最多可以处理80个并发连接。云运行服务可以处理多达80，000个并发连接。60k RPS/5000 * 80000 = 960k RPS。通过简单的计算，我理论上预计我的服务最多可以处理96万RPS。</p><p id="fbcc" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">RPS在很大程度上取决于请求处理时间。如果每个请求需要1秒钟处理，该服务最多只能处理80k RPS。</p><p id="f885" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">然而，通过GCP支持可以增加容器实例的最大数量，这意味着云运行的实际限制实际上取决于区域容量。</p><p id="bb47" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">为了进行更大规模的实验，我需要一个分布式的负载测试解决方案。我现在没有这样的设置。如果你想看这个，请告诉我，我们甚至可能想尝试打破云运行(因为我的同事也渴望看到这一点)。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="f568" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">如果你喜欢这篇文章或觉得它有帮助，你可以给我几个掌声，并关注我，当我的下一篇文章出来时，你会收到通知！</p></div></div>    
</body>
</html>