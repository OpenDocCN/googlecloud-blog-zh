<html>
<head>
<title>Extracting JSON key value pairs in BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在BigQuery中提取JSON键值对</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/extracting-json-key-value-pairs-in-bigquery-1bb9d0ec0b6d?source=collection_archive---------0-----------------------#2022-10-24">https://medium.com/google-cloud/extracting-json-key-value-pairs-in-bigquery-1bb9d0ec0b6d?source=collection_archive---------0-----------------------#2022-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="1cd9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">BigQuery中JSON的简短介绍</h1><p id="6d01" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Bigquery不久前引入了处理JSON结构的能力。它既支持表示JSON结构的字符串值，也支持本地JSON数据类型。你可以在这里找到很好的介绍<a class="ae kb" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/json-data" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="656d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">Bigquery提供了使用如下路径语句查询JSON(以及带有JSON的字符串)的能力:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9153" class="kq ig hi km b fi kr ks l kt ku">JSON_EXTRACT(json_field, "$.path.to.my.data")<!-- --> </span></pre><p id="b8c0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">或简称:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2479" class="kq ig hi km b fi kr ks l kt ku">jsonfield.path.to.my.data</span></pre><p id="14ac" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">从JSON中提取数据有很多方便的函数，但是也有一些限制。</p><h1 id="744b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">挑战</h1><p id="5c47" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最近我遇到了一个情况，我们需要在json字典中提取条目。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4d1e" class="kq ig hi km b fi kr ks l kt ku">{<br/>   "temp": 30, "elevation":120<br/>}<br/>{<br/>   "Ambience": "high", "sound":"fair"<br/>}<br/>{<br/>    "temp": 10, "sound":"bad"<br/>}</span></pre><p id="9ce5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">最简单的方法是使用:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b5b0" class="kq ig hi km b fi kr ks l kt ku">JSON_EXTRACT(json_expr, "$.temp")</span></pre><p id="bebd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">不幸的是，运行时密钥是未知的，所以不可能编写json路径。</p><p id="e4ea" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">第一种方法从可能的关键字列表开始:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="60fd" class="kq ig hi km b fi kr ks l kt ku">DECLARE wanted_keys array&lt;STRING&gt; <br/>   DEFAULT  ARRAY["temp","Ambience", "sound"];</span></pre><p id="b19a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">然后可以迭代<code class="du kv kw kx km b">wanted_keys</code>来提取值</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="908b" class="kq ig hi km b fi kr ks l kt ku">SELECT  <br/>   city_record.city, <br/>   wanted_key.name,<br/>  JSON_EXTRACT(city_record.payload, '$.'||wanted_key.name))</span></pre><p id="b59b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">事实证明，我们不能在<code class="du kv kw kx km b">JSON_EXTRACT</code>函数中动态创建路径参数。它必须是常量或查询参数(即它需要是常量)。</p><p id="bc5d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">因此，我们引入了一个定制的Java脚本来提取基于动态键的值:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2cb6" class="kq ig hi km b fi kr ks l kt ku">CREATE temp  FUNCTION CUSTOM_JSON_EXTRACT(json STRING, json_path STRING) RETURNS STRING<br/>LANGUAGE js AS """ <br/>  try {<br/>     var obj = JSON.parse(json);<br/>     var result;<br/>     var arg;<br/>     if (obj) {<br/>        if (json_path &amp;&amp; obj.hasOwnProperty(json_path)) {<br/>          result = JSON.stringify(obj[json_path]);<br/>        }<br/>        return (result.length ? result : false);<br/>     }<br/>} catch (e) { return null }<br/>""";</span></pre><p id="c1d3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该查询现在可以遍历数据记录和所需的键，并一次提取一行:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="777d" class="kq ig hi km b fi kr ks l kt ku">FOR city_record in (SELECT  city, payload from DATA)<br/>DO<br/>  FOR wanted_key in (SELECT * from unnest(wanted_keys) as name)<br/>  DO<br/>    IF city_record.payload like '%"'||wanted_key.name||'"%'<br/>    THEN<br/>      INSERT INTO results (<br/>        SELECT  city_record.city, wanted_key.name,<br/>        CUSTOM_JSON_EXTRACT(city_record.payload, wanted_key.name));<br/>     END IF;<br/>   END FOR;<br/>END FOR;</span></pre><p id="8d8d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这样做很好，但是有一个明显的问题:这个双循环中的每个<code class="du kv kw kx km b">INSERT INTO results</code>语句都是一个Bigquery任务！如果您处理1000行3个可能的键，您将启动多达3000个bigquery作业。它们将按顺序执行。Bigquery所有的并行处理能力都消失了！</p><h1 id="b600" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">更好的解决方案</h1><p id="efcc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">更好的解决方案是:</p><ul class=""><li id="6e02" class="ky kz hi jf b jg kc jk kd jo la js lb jw lc ka ld le lf lg bi translated">创建一个javascript，将字典转换成键值对列表</li><li id="e677" class="ky kz hi jf b jg lh jk li jo lj js lk jw ll ka ld le lf lg bi translated">将它们与原始行交叉连接，为每个键创建一行</li><li id="6f04" class="ky kz hi jf b jg lh jk li jo lj js lk jw ll ka ld le lf lg bi translated">用<code class="du kv kw kx km b">wanted_keys</code>列表连接这些行</li></ul><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8aa7" class="kq ig hi km b fi kr ks l kt ku">-- extract all key value pairs as an array from a json dict<br/>-- input: json string with a dictionary<br/>-- returns:  list of struct &lt;key, value&gt;<br/>CREATE TEMP  FUNCTION EXTRACT_KV_PAIRS(json_str STRING)<br/>RETURNS ARRAY&lt;STRUCT&lt;key STRING, value STRING&gt;&gt;<br/>LANGUAGE js AS """<br/>  try{ <br/>    const json_dict = JSON.parse(json_str); <br/>    const all_kv = Object.entries(json_dict).map(<br/>        (r)=&gt;Object.fromEntries([["key", r[0]],["value",  <br/>                                   JSON.stringify(r[1])]]));<br/>    return all_kv;<br/>  } catch(e) { return [{"key": "error","value": e}];}<br/>""";</span><span id="5d1e" class="kq ig hi km b fi lm ks l kt ku">-- make our sample data<br/>WITH<br/>make_table AS(<br/>   SELECT "NYC" as City, '{"temp": 30, "elevation":120}' as payload<br/>   UNION ALL<br/>   SELECT "SF" ,  '{"Ambience": "high", "sound":"fair"}'<br/>   UNION ALL<br/>   SELECT "LA" ,  '{"temp": 10, "sound":"medium"}'<br/>),<br/>-- make the sample wanted keys<br/>wanted_keys AS(<br/>  SELECT * FROM<br/>  UNNEST(ARRAY["temp","Ambience", "sound"]) <br/>  AS wanted<br/>),<br/>-- turn the dictionary into a list<br/>extracted_pairs as (<br/>  SELECT city,<br/>  EXTRACT_KV_PAIRS(payload) as kv_list <br/>  FROM make_table<br/>),<br/>-- now expand the list into individual rows<br/>all_pairs AS(<br/>  SELECT city, kv_pair.key AS key, kv_pair.value AS value<br/>  FROM extracted_pairs<br/>  CROSS JOIN UNNEST (kv_list) as kv_pair<br/>)<br/>-- now restrict it to those rows <br/>-- that match the keys we are looking for<br/>SELECT city, key, value<br/>FROM all_pairs<br/>JOIN wanted_keys on key = wanted</span></pre><p id="2977" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这个解决方案以全BigQuery速度运行。以前的解决方案需要几分钟甚至几小时才能运行，而现在的解决方案只需几秒钟就能运行</p></div></div>    
</body>
</html>