<html>
<head>
<title>Configure Streams in Datastream with predefined tables in BigQuery for PostgreSQL as source.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PostgreSQL的BigQuery中预定义的表作为源来配置数据流中的流。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/configure-streams-in-datastream-with-predefined-tables-in-bigquery-for-postgresql-as-source-528340f7989b?source=collection_archive---------1-----------------------#2022-11-18">https://medium.com/google-cloud/configure-streams-in-datastream-with-predefined-tables-in-bigquery-for-postgresql-as-source-528340f7989b?source=collection_archive---------1-----------------------#2022-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="cfa0" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这是PostgreSQL和BigQuery在数据流上解决真实世界场景系列的第3部分，如果有兴趣查看所有策划的场景<a class="ae jh" rel="noopener" href="/@mahtodeepak/solving-real-world-scenarios-on-datastream-for-postgresql-and-bigquery-b79334a065fc">请点击我。</a></p></blockquote><p id="dead" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我没有预料到使用Datastream从PostgreSQL到BigQuery的公开预览会如此有趣。这是我的第三篇博客，如果你想玩得开心，可以好好看看第一篇<a class="ae jh" rel="noopener" href="/google-cloud/configure-google-cloud-datastream-for-only-certain-dmls-on-postgresql-as-source-16e4ad789ef8">第一篇</a>和第二篇<a class="ae jh" rel="noopener" href="/google-cloud/configure-streams-from-partition-table-in-postgresql-to-non-partition-in-bigquery-using-datastream-3238fe3321d9">关于以PostgreSQL为源的数据流的博客。</a></p><p id="e825" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如果我们有一个客户场景，让PostgreSQL to BigQuery从作为源的<strong class="il hj">非分区</strong>表复制到<strong class="il hj">分区</strong>表或<strong class="il hj"> alter columns数据类型</strong>会怎样？我们将探索如何实现它的方法，但首先让我们更好地理解在BigQuery中创建的表，这些表是使用Datastream从PostgreSQL流式传输的一部分。</p><p id="f363" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">主键是复制捕获更改并应用于目标的重要约束。在BigQuery中，主键作为表定义的一部分被转换为一个簇。我们来拿个样表做参考。我们将在BigQuery中映射数据流如何转换PostgreSQL中的表。</p><p id="90f9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">PostgreSQL表在order_id列上定义了主键约束。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/ccce3af02ec75fa9ebe9ac0c112f828a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ta_OseVP4bgiYpArie4ow.png"/></div></div></figure><p id="55b3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">数据流将表转换如下。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jx"><img src="../Images/e0a6ddbc4435b032373bae547e647f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOxyRoF8E5Nwj6Ikd73j6g.png"/></div></div></figure><p id="43f8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">看一看这两个截图，并尝试在PostgreSQL和BigQuery表之间映射细节。它包括多个数据点，让我们根据它是如何编号的来讨论。</p><h2 id="28a1" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ji kj kk kl jj km kn ko jk kp kq kr ks bi translated">1.PostgreSQL表中的主键。</h2><p id="116f" class="pw-post-body-paragraph ii ij hi il b im kt io ip iq ku is it ji kv iw ix jj kw ja jb jk kx je jf jg hb bi translated">Primary被转换为BigQuery表中的聚类。聚类主要是根据列对表中的数据进行排序。它提高了查询性能，降低了BigQuery的成本。同一组列上的主键也应用于BigQuery，但不是强制的。</p><h2 id="1215" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ji kj kk kl jj km kn ko jk kp kq kr ks bi translated">2.数据流元数据。</h2><p id="7a3f" class="pw-post-body-paragraph ii ij hi il b im kt io ip iq ku is it ji kv iw ix jj kw ja jb jk kx je jf jg hb bi translated">数据流向事件添加额外的元数据，例如，作为初始回填和连续更改的一部分，将更改推送到BigQuery。它包括唯一的事件id和源事件的时间戳。</p><h2 id="3b15" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ji kj kk kl jj km kn ko jk kp kq kr ks bi translated">3.最大过期时间</h2><p id="406f" class="pw-post-body-paragraph ii ij hi il b im kt io ip iq ku is it ji kv iw ix jj kw ja jb jk kx je jf jg hb bi translated">创建流时，我们有一个选项来配置过时限制。它定义了数据的新鲜度，并对成本有直接影响。基于过时限制，数据流创建表并在BigQuery中为表定义max_staleness。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ky"><img src="../Images/e462c4802de3719b3af78768196bfcb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UpSS-qh3nW9_Wvxe"/></div></div></figure><h2 id="0437" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ji kj kk kl jj km kn ko jk kp kq kr ks bi translated">4.BigQuery中的表名。</h2><p id="a69e" class="pw-post-body-paragraph ii ij hi il b im kt io ip iq ku is it ji kv iw ix jj kw ja jb jk kx je jf jg hb bi translated">数据流根据来自源的表的架构创建具有相同数据集或数据集的表。该表通常在BigQuery内或根据创建流时设置的前缀追加模式名，即&lt;&lt;<em class="ik">schemaname</em><strong class="il hj">_</strong><em class="ik">table _ name</em>&gt;&gt;。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kz"><img src="../Images/3357584248a33072c3e214b0996f3a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5hjmkK7iaUCJR2iX"/></div></div></figure><p id="af42" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">分享所有细节的原因是为了理解由数据流创建的BigQuery表，并在任何情况下使用它作为覆盖表定义的参考。</p><p id="775b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如果我们需要<strong class="il hj">在BigQuery表上定义分区</strong>,那么通过根据数据流使用的BigQuery writer定义我们自己的表定义，就可以使用来自数据源的数据流进行复制。在某些情况下，我们也可以用<strong class="il hj">覆盖BigQuery中定义的</strong>数据类型。</p><p id="0018" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">作为BigQuery自定义表引用的SQL代码段。</p><pre class="jm jn jo jp fd la lb lc bn ld le bi"><span id="3f37" class="lf jz hi lb b be lg lh l li lj">CREATE OR REPLACE TABLE  `projectname.partition_test.public_order_non_partition_onepkcolumn`<br/>  (<br/>  order_id INT64,<br/>  ordered_at TIMESTAMP,<br/>  shipped_at TIMESTAMP,<br/>  order_amount FLOAT64,<br/>  customer_id STRING(255),<br/>  datastream_metadata STRUCT&lt;uuid STRING, source_timestamp INT64&gt;,<br/>    PRIMARY KEY (order_id) NOT ENFORCED)<br/>PARTITION BY<br/>  DATE(ordered_at)<br/>CLUSTER BY order_id<br/>OPTIONS(max_staleness = INTERVAL 5 MINUTE);</span></pre><p id="4ee4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">覆盖表定义可能会导致异常，需要进行测试。下面是在以PostgreSQL为源启动流之前，在BigQuery中覆盖的示例表DDL，在我的测试中它工作得很好。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lk"><img src="../Images/75bd773d13f2fdfa9a77d33393b287c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPkDPKMJ-DtudlvtY0vkVA.png"/></div></div></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ll"><img src="../Images/0f32da34a5e1f751e034ab7a7eed532b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfpfU7F0pe1a26o6uRku3w.png"/></div></div></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lm"><img src="../Images/e9edde3f91fea44c4559b83fe3a131b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_v_ZpOOeLZXk--c6yVrVA.png"/></div></div></figure><p id="30e2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">其他注意事项，请注意在尝试自定义BigQuery定义时可能会遇到的数据流故障。</p><blockquote class="if ig ih"><p id="be06" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">大查询编写器写入失败</p><p id="279f" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">big query _ UNSUPPORTED _ PRIMARY _ KEY _ CHANGE</p></blockquote><p id="c9bb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这可能是由于不正确的表定义或BigQuery中覆盖的列数据类型造成的。请使用博客中共享的参考表，如果问题仍然存在，请联系谷歌云支持。</p><h2 id="ae5d" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ji kj kk kl jj km kn ko jk kp kq kr ks bi translated">结论</h2><p id="9631" class="pw-post-body-paragraph ii ij hi il b im kt io ip iq ku is it ji kv iw ix jj kw ja jb jk kx je jf jg hb bi translated">添加分区或改变列数据类型是使用数据流复制到BigQuery的一个非常常见的场景。有了博客中分享的知识，我们可以在启动流作业和测试复制之前覆盖目标表定义。</p><h2 id="f637" class="jy jz hi bd ka kb kc kd ke kf kg kh ki ji kj kk kl jj km kn ko jk kp kq kr ks bi translated">进一步阅读</h2><blockquote class="if ig ih"><p id="5ac3" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">查看附加的<a class="ae jh" href="https://mahtodeepak.medium.com/b79334a065fc" rel="noopener">博客</a>，解决PostgreSQL和BigQuery的数据流上的真实场景。</p></blockquote></div></div>    
</body>
</html>