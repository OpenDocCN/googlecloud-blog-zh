<html>
<head>
<title>End-to-End Crypto Shredding (Part II): Data Deletion/Retention with Crypto Shredding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端加密粉碎(第二部分):使用加密粉碎的数据删除/保留</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/end-to-end-crypto-shredding-part-ii-data-deletion-retention-with-crypto-shredding-a67f5300a8c8?source=collection_archive---------0-----------------------#2019-09-09">https://medium.com/google-cloud/end-to-end-crypto-shredding-part-ii-data-deletion-retention-with-crypto-shredding-a67f5300a8c8?source=collection_archive---------0-----------------------#2019-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8a91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的博客中，我展示了如何利用BigQuery的AEAD加密功能来实现数据删除，也称为加密删除。但是，我将这个演示局限于BigQuery中的数据。但是数据很少只存在于一个系统中。如果我们必须删除管道中所有现有系统的数据，该怎么办？除了BigQuery之外，我们如何应用相同的数据加密删除策略？</p><p id="d026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了做好准备，让我们对用例、需求和结果做一些假设。假设我们从外部数据源获取数据，并最终将这些数据存储在多个地方以供使用，例如:</p><p id="c202" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-用于分析目的的BigQuery</p><p id="7a18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-快速查找数据库，如<a class="ae jd" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank">云数据存储</a>，供应用程序使用。</p><p id="e305" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就业务需求而言，假设我们被要求提供方法和保证，以便对于给定的记录(user-id或任何唯一的id)，我们的管道确保从存储记录的任何地方删除数据。</p><p id="e213" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更具体地说明这一点，让我们想象一下我们最初的管道:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/2edbe63e1356ff7fd726eac90797f377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gsJuHiN9_nfn7N6l"/></div></div></figure><p id="15b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的管道中，发布/订阅以一些ID和有效负载的形式接收数据。为简单起见，有效载荷是一个字符串，但实际上，有效载荷可以是多个字段，即位置、浏览器类型等。此外，Dataflow充当一个简单的路由器，将数据存储在云数据存储和BigQuery中。我意识到真实世界的架构和数据模型可能比这个例子更复杂，但是保持它的简单来表达逻辑</p><p id="9ca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据上述体系结构，满足从所有系统中删除数据的要求的一种方法是简单地利用自动工作流，从每个存储中单独删除数据。虽然这种方法可行，但它面临一些挑战:</p><ul class=""><li id="86e9" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">将数据存储和复制到少数几个系统是很常见的。从多个异构系统中删除数据可能很难实现(多个逻辑、代码库等)。</li><li id="672d" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">面对我们无法控制的系统造成的错误，数据删除可能会不一致。换句话说，系统可能无法删除我们的记录，或者更糟的是，它可能在后台无法删除时异步指示成功。</li><li id="c6dc" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">就性能和成本而言，它可能效率低下，具体取决于数据存储模型。例如，可能需要扫描整个数据集才能找到需要删除的记录。这是低效的，并且有时是昂贵的。</li></ul><p id="cbad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想的删除流程应该是我们完全控制的流程，并且易于实施、高效(成本和性能)且一致。这篇文章的其余部分将展示如何实现一个满足这些需求的过程。</p><p id="1d85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的<a class="ae jd" rel="noopener" href="/google-cloud/bigquery-encryption-functions-part-i-data-deletion-retention-with-crypto-shredding-7085ecf6e53f">前一篇博客</a>中，为了删除数据，我们用以下伪逻辑利用加密功能:</p><ol class=""><li id="498b" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc ke jw jx jy bi translated">用唯一的加密密钥加密给定的记录。</li><li id="c684" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc ke jw jx jy bi translated">存储记录及其加密密钥的映射。</li><li id="fe1c" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc ke jw jx jy bi translated">要删除您的记录，只需从映射表中删除加密密钥。这使得解密不可能，并且记录无用(被删除)。</li></ol><p id="d79d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions" rel="noopener ugc nofollow" target="_blank"> AEAD函数</a>在BigQuery中演示了上述步骤。BigQuery的AEAD加密功能的伟大之处在于，它的实现基于谷歌的开源库，名为<a class="ae jd" href="https://github.com/google/tink" rel="noopener ugc nofollow" target="_blank"> Tink </a>。这为我们提供了在BigQuery内部和/或外部加密/解密数据的能力，这对于实现跨异构系统的端到端加密分解至关重要。鉴于此，下面是端到端逻辑的修改后的伪逻辑:</p><ol class=""><li id="b6ac" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc ke jw jx jy bi translated">在数据接收点，用唯一的加密密钥加密给定的记录。</li><li id="1dce" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc ke jw jx jy bi translated">将记录的映射及其加密密钥存储在数据的所有使用者都可以访问的外部加密密钥映射存储中。</li><li id="e3c8" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc ke jw jx jy bi translated">为了消费给定的记录，消费者从外部加密密钥映射存储中读取解密密钥。</li><li id="2e12" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc ke jw jx jy bi translated">为了删除给定的记录，从外部加密密钥映射存储中删除加密密钥。通过从共享存储器中删除加密密钥，我们保证没有消费者能够解密记录。</li></ol><p id="582c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将上面的伪逻辑应用于我们的初始架构:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kf"><img src="../Images/c1c0c44fd8a476ec14dd75c4b748e11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vF-J9DhEr7nOmyr9"/></div></div></figure><p id="f7a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的架构有许多新的组件和集成点</p><p id="ba22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Tink Encryptor </strong>是一个云数据流逻辑，它从Pub/Sub中读取数据，然后为之前未见过的任何新记录生成新密钥，或者如果这是重复记录，则检索现有的加密密钥。为了存储新键或检索现有键，云Bigtable充当共享存储。嵌入在云数据流逻辑中的Tink库支持密钥生成、加密和解密过程。这里有一个简单的例子:</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="7ba3" class="kl km hi kh b fi kn ko l kp kq">AeadConfig.<em class="kr">register</em>();<br/></span><span id="f323" class="kl km hi kh b fi ks ko l kp kq"><strong class="kh hj">private static byte</strong>[] encrypt(String payload, String key, String password) <strong class="kh hj">throws </strong>GeneralSecurityException,IOException {</span><span id="881a" class="kl km hi kh b fi ks ko l kp kq">   KeysetHandle keysetHandle = CleartextKeysetHandle.read(JsonKeysetReader.withString(key));</span><span id="b46c" class="kl km hi kh b fi ks ko l kp kq">   Aead aead = AeadFactory.getPrimitive(keysetHandle);</span><span id="de37" class="kl km hi kh b fi ks ko l kp kq"><strong class="kh hj">   return </strong>aead.encrypt(payload.getBytes(),<strong class="kh hj"> </strong>password.getBytes());</span><span id="2f81" class="kl km hi kh b fi ks ko l kp kq">}</span><span id="194a" class="kl km hi kh b fi ks ko l kp kq"><strong class="kh hj">private </strong>String generateKey() <strong class="kh hj">throws </strong>GeneralSecurityException, IOException {</span><span id="256e" class="kl km hi kh b fi ks ko l kp kq">   ByteArrayOutputStream stream = <strong class="kh hj">new </strong>ByteArrayOutputStream();</span><span id="bf70" class="kl km hi kh b fi ks ko l kp kq">   KeysetHandle keysetHandle =   KeysetHandle.<em class="kr">generateNew</em>(AeadKeyTemplates.<strong class="kh hj"><em class="kr">AES128_GCM</em></strong>);</span><span id="5d75" class="kl km hi kh b fi ks ko l kp kq">   CleartextKeysetHandle.<em class="kr">write</em>(keysetHandle,  JsonKeysetWriter.<em class="kr">withOutputStream</em>(stream));</span><span id="b398" class="kl km hi kh b fi ks ko l kp kq"><strong class="kh hj">   return </strong> <strong class="kh hj">new </strong>String(stream.toByteArray());</span><span id="4f4a" class="kl km hi kh b fi ks ko l kp kq">}</span></pre><p id="a9bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据流路由器</strong>从我们的初始图来看，保持不变，但是现在路由加密数据而不是原始记录。</p><p id="c2e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解密记录进行处理，记录的消费者，即我们的应用程序和BigQuery，必须从Bigtable中检索加密密钥。通过调用<a class="ae jd" href="https://cloud.google.com/bigtable/docs/reference/libraries" rel="noopener ugc nofollow" target="_blank">Bigtable API</a>就可以从我们的应用程序中调用Bigtable。</p><p id="a239" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让BigQuery检索解密密钥，我们利用了BigQuery对Bigtable 的联邦访问<a class="ae jd" href="https://cloud.google.com/bigquery/external-data-bigtable" rel="noopener ugc nofollow" target="_blank">的支持。BigQuery中的解密过程包括将加密的记录与Bigtable中的映射表连接起来。我们很快就会看到一个例子。</a></p><p id="16d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，为了<strong class="ih hj">从我们所有的系统(在这个例子中是BigQuery和Cloud Datastore)中删除</strong>给定的记录，我们简单地从Bigtable中删除映射键，使得记录的解密变得不可能。</p><p id="99be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">big query中的解密</strong></p><p id="348a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过一个例子来使BigQuery解密过程更加具体。</p><p id="cfb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在BigQuery中，我们有两个表:</p><p id="bb28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中一个加密了最初通过我们的数据流路由器路由到BigQuery的数据:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kt"><img src="../Images/508a87efd321de8bd0769252f17107d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*h04k-H5raOVPrs90L3jeFQ.png"/></div></figure><p id="8cdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个外部表指向Bigtable中的键映射表:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/8851fe51995ffcc820702bab95d81c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dsInLIM8vax7fxKX8xaYA.png"/></div></div></figure><p id="1b69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解密BigQuery中的数据，我们将在这两个表之间进行连接。连接查询允许我们向BigQuery的AEAD提供解密密钥和encrypted_payload。解密字符串函数:</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="2e78" class="kl km hi kh b fi kn ko l kp kq">SELECT</span><span id="3e2e" class="kl km hi kh b fi ks ko l kp kq">data.id AS ID,</span><span id="7f93" class="kl km hi kh b fi ks ko l kp kq"><strong class="kh hj">SAFE.AEAD.DECRYPT_STRING</strong>( KEYS.KEYSET_FROM_JSON( <strong class="kh hj">mapping.cf1.key.cell.value</strong>), FROM_BASE64(<strong class="kh hj">data.encrypted_payload</strong>), "some_password") AS payload</span><span id="59e9" class="kl km hi kh b fi ks ko l kp kq">FROM</span><span id="69e5" class="kl km hi kh b fi ks ko l kp kq">    dataset.encrypted_table data</span><span id="d386" class="kl km hi kh b fi ks ko l kp kq">JOIN</span><span id="f929" class="kl km hi kh b fi ks ko l kp kq">    dataset.bigtable_table mapping</span><span id="76fd" class="kl km hi kh b fi ks ko l kp kq">ON</span><span id="a5d2" class="kl km hi kh b fi ks ko l kp kq">    mapping.rowKey = data.id</span></pre><p id="3489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重要注意事项</strong></p><p id="c1f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在高层次上演示了如何实现端到端加密粉碎功能后，我想指出几个重要的考虑事项:</p><p id="d750" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">仅将这种模式用于加密粉碎</strong>:虽然实现的逻辑利用加密功能来实现<strong class="ih hj">加密粉碎</strong>，但是由于我将进一步讨论的一些限制，它不能满足需要<strong class="ih hj">加密</strong>以保护隐私和安全的用例。更具体地说，BigQuery的AEAD函数只能接受字符串或二进制形式的加密/解密密钥。这带来了一个挑战，即存储在外部映射存储中的键最终必须转换为字符串或二进制。这意味着我们不能在Bigtable中加密我们的加密密钥。换句话说，在我们的例子中，Bigtable以纯文本JSON格式存储AEAD加密/解密密钥。虽然可以使用GCP IAM策略保护Bigtable访问，但是为了满足加密和隐私用例，密钥应该加密存储。既能满足加密粉碎又能满足隐私/安全加密的理想解决方案是将加密密钥存储在KMS系统中，如云KMS。除此之外，BigQuery应该允许从云KMS检索密钥，而不是二进制或字符串格式。我希望在BigQuery中实现类似的东西:</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="c96e" class="kl km hi kh b fi kn ko l kp kq">SELECT</span><span id="69cd" class="kl km hi kh b fi ks ko l kp kq">data.id AS ID,</span><span id="eca6" class="kl km hi kh b fi ks ko l kp kq">SAFE.AEAD.DECRYPT_STRING( KEYS.KEYSET_FROM_KMS(mapping.kms_key_id, kms_instance_name), FROM_BASE64(data.encrypted_payload), “some_password”) AS payload</span><span id="3026" class="kl km hi kh b fi ks ko l kp kq">FROM</span><span id="9831" class="kl km hi kh b fi ks ko l kp kq">    dataset.encrypted_table data</span><span id="501a" class="kl km hi kh b fi ks ko l kp kq">JOIN</span><span id="b328" class="kl km hi kh b fi ks ko l kp kq">    dataset.bigtable_table mapping</span><span id="b060" class="kl km hi kh b fi ks ko l kp kq">ON</span><span id="195e" class="kl km hi kh b fi ks ko l kp kq">    mapping.rowKey = data.id</span></pre><blockquote class="kv kw kx"><p id="8e4d" class="if ig kr ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated">注意:这只是一个例子，并不是一个真正的BigQuery函数</p></blockquote><p id="23ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">微调您的架构:</strong>本博客中提供的架构和示例逻辑仅用于演示目的。考虑到他们自己的技术需求和要求，人们应该非常仔细地考虑如何构建。这方面的一个例子是数据模型和用于加密到密钥映射的外部存储的选择。或者，如何在数据流或消费应用程序中实现Tink加密/解密/密钥生成逻辑。</p><p id="4f79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用加密粉碎作为一种永久且一致地删除数据而不牺牲性能的方式是一种非常有效的模式，不需要更复杂的方法，如BigQuery中的DML语句或对数据管道其他部分的高频delete API调用。只需删除加密密钥，所有属于该密钥的记录都被认为不可能在我们的管道中的任何地方解密。除此之外，通过使用Tink库，人们不仅可以将类似的逻辑应用于GCP本地工具(BigQuery、Datastore等)，还可以应用于许多其他工具和框架，如Apache Kafka、Apache Spark等。</p><p id="eded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在阅读本文后，您对这种模式的适用性有什么看法，我很乐意听到您的意见。这种模式有意义吗？请随时联系我:<a class="ae jd" href="https://twitter.com/pdeyhim" rel="noopener ugc nofollow" target="_blank"> @pdeyhim </a></p></div></div>    
</body>
</html>