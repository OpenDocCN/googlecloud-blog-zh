<html>
<head>
<title>DBT BigQuery Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DBT大查询性能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/dbt-bigquery-performance-277b17f5613d?source=collection_archive---------0-----------------------#2021-06-25">https://medium.com/google-cloud/dbt-bigquery-performance-277b17f5613d?source=collection_archive---------0-----------------------#2021-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="1de7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="0335" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">DBT是编排和管理针对数据仓库运行的SQL的一个很好的工具。当使用BigQuery时，对DBT运行的进行<strong class="jf hj">分析并捕获<strong class="jf hj">插槽使用情况</strong>和处理的<strong class="jf hj">字节</strong>来测量成本是很有用的。</strong></p><h2 id="59c4" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">DBT增强</h2><p id="aee5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">DBT <a class="ae kp" href="https://github.com/fishtown-analytics/dbt/issues/2808" rel="noopener ugc nofollow" target="_blank">问题2808 </a>和<a class="ae kp" href="https://github.com/fishtown-analytics/dbt/pull/2809" rel="noopener ugc nofollow" target="_blank"> PR 2809 </a>用dbt_invocation_id为每个BigQuery作业添加了一个标签。这可以从BigQuery的<a class="ae kp" href="https://cloud.google.com/bigquery/docs/information-schema-jobs" rel="noopener ugc nofollow" target="_blank"> INFORMATION_SCHEMA </a>作业日志中提取。作业日志可以按用户、项目、文件夹或组织提供，这完全取决于您的访问权限。您还可以从BigQuery <a class="ae kp" href="https://cloud.google.com/bigquery/docs/reference/auditlogs" rel="noopener ugc nofollow" target="_blank">审计日志</a>中获取作业日志。在本例中，将使用JOBS_BY_PROJECT。最后，跟踪DBT元数据的<a class="ae kp" href="https://docs.getdbt.com/reference/project-configs/on-run-start-on-run-end" rel="noopener ugc nofollow" target="_blank"> on-run-start </a>钩子可以被组合。</p><p id="ab7b" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><em class="kv">你到底是怎么问的？让我给你看看！</em></p><h1 id="a25d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">跟踪绩效步骤</h1><p id="0734" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用Felipe Hoffa的<a class="ae kp" href="https://hoffa.medium.com/get-started-with-bigquery-and-dbt-the-easy-way-36b9d9735e35" rel="noopener">开始使用BigQuery和dbt，这是一个简单的方法</a>让你的第一个模型运行起来。这叫做first_model。</p><h2 id="3ef6" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">步骤1:为DBT创建作业日志</h2><p id="4e9c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在每次运行之前，创建运行日志表(如果它不存在),并插入一行，其中包含当前时间戳、调用id和DBT项目名称。可以添加其他元数据来跟踪许多其他细节。</p><p id="05e8" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这是添加到dbt_project.yml中的代码，可以添加到first_project中。DBT提供了大量宏，包括<a class="ae kp" href="https://docs.getdbt.com/reference/dbt-jinja-functions/invocation_id" rel="noopener ugc nofollow" target="_blank"> invocation_id </a>。</p><p id="c2ff" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">配置:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d324" class="kb ig hi lb b fi lf lg l lh li">on-run-start:<br/>  - &gt;<br/>    CREATE TABLE IF NOT EXISTS `&lt;project&gt;.temp.dbt_log`<br/>    (start_time TIMESTAMP,<br/>     invocation_id STRING,<br/>     project_name STRING)<br/>  - &gt;<br/>    INSERT INTO `&lt;project&gt;.temp.dbt_log` VALUES<br/>    (CURRENT_TIMESTAMP(),<br/>     '{{invocation_id}}',<br/>     '{{project_name}}')</span></pre><h2 id="3cbc" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">第二步:跑DBT</h2><p id="d443" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">从first_project目录正常运行dbt:<code class="du lj lk ll lb b">./local/bin/dbt run</code></p><h2 id="2a8f" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">第三步:分析结果</h2><p id="149e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">请记住，INFORMATION_SCHEMA必须由<strong class="jf hj">区域</strong>指定。在下面的示例中，地区是欧盟。</p><p id="6a4a" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">使用子选择，我们可以将INFORMATION_SCHEMA jobs表中的匹配标签值连接到dbt_log表中。</p><p id="38a7" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">首先，我们额外的一个查询分析DBT运行。这仅提取过去两天的数据(如果表已分区，则减少表扫描)。查询如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fd18" class="kb ig hi lb b fi lf lg l lh li">SELECT<br/>  dbt_log.invocation_id,<br/>  dbt_log.project_name,<br/>  SUM(1) AS jobs,<br/>  MIN(jobs.start_time) AS start_time,<br/>  -- If there is no end_time (null), then runtime is 0.<br/>  IFNULL(<br/>    TIMESTAMP_DIFF(<br/>      MAX(jobs.end_time),<br/>      MIN(jobs.start_time),<br/>      SECOND),<br/>    0)<br/>    AS runtime_secs,<br/>  SUM(IFNULL(jobs.total_slot_ms, 0))/1e3<br/>    AS total_slot_secs,<br/>  SUM(IFNULL(jobs.total_bytes_processed, 0))/POW(2, 30)<br/>    AS total_gb_processed<br/>FROM<br/>  `temp.dbt_log` dbt_log<br/>  JOIN `region-eu.INFORMATION_SCHEMA.JOBS_BY_PROJECT` jobs<br/>  ON (dbt_log.invocation_id =<br/>      -- Select the value (any value) where key is dbt_invocation_id<br/>      (SELECT ANY_VALUE(l.value) FROM jobs.labels l<br/>       WHERE l.key='dbt_invocation_id')<br/>     )<br/>WHERE<br/>  dbt_log.start_time &gt;<br/>    TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 2 DAY) AND<br/>  jobs.creation_time &gt;<br/>    TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 2 DAY)<br/>GROUP BY<br/>  1,2</span></pre><p id="5964" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">最后，我们将这些信息组合在一起，以获得汇总统计数据:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5425" class="kb ig hi lb b fi lf lg l lh li">WITH<br/>  RunAnalysis AS (<br/>    &lt;analysis query&gt;<br/>  )<br/>SELECT<br/>  project_name,<br/>  SUM(1) AS runs,<br/>  SUM(jobs)/SUM(1) AS avg_jobs,<br/>  SUM(runtime_secs)/SUM(1) AS avg_runtime_secs,<br/>  SUM(total_slot_secs) AS total_slot_secs,<br/>  SUM(total_gb_processed) AS total_gb_processed,<br/>  -- BigQuery has large variation in parallel. This is<br/>  -- a crude measure of how many slots (on average) you're using<br/>  -- in parallel during queries<br/>  SUM(total_slot_secs)/SUM(runtime_secs) AS avg_parallelism,<br/>  MIN(start_time) AS first_run,<br/>  MAX(start_time) AS last_run<br/>FROM<br/>  RunAnalysis<br/>GROUP BY<br/>  1;</span></pre><p id="fc73" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">查询结果:</p><figure class="kw kx ky kz fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lm"><img src="../Images/200c058ea12d188a13d2ea0a0961a057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlIyutU9mhzoaY7LBhPaLg.png"/></div></div></figure><h1 id="95c3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="8937" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过将DBT invocation_id公开到BigQuery日志中，它支持丰富的数据分析模式。BigQuery日志引用了表、完整查询和许多其他有趣的属性，这些属性可以与DBT运行和元数据相关联。</p></div></div>    
</body>
</html>