<html>
<head>
<title>Workflows tips’n tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作流程提示和技巧</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/workflows-tipsn-tricks-d7196eb5098d?source=collection_archive---------0-----------------------#2022-11-04">https://medium.com/google-cloud/workflows-tipsn-tricks-d7196eb5098d?source=collection_archive---------0-----------------------#2022-11-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7e5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我们在使用<a class="ae jd" href="https://cloud.google.com/workflows" rel="noopener ugc nofollow" target="_blank">工作流</a>时发现的一些有用的一般提示和技巧:</p><p id="428b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">避免硬编码网址</strong></p><p id="786b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为工作流是关于调用API和服务URL的，所以有一些干净的方法来处理这些URL是很重要的。您可以将它们硬编码到您的工作流定义中，但是问题是您的工作流会变得更难维护。特别是，当您在多个环境中工作时会发生什么？您必须复制您的YAML定义，并为生产环境、暂存环境和开发环境使用不同的URL。在多个文件中对本质上相同的工作流进行修改容易出错，并且很快变得很痛苦。为了避免对这些URL进行硬编码，有几种方法。</p><p id="3ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个是将这些URL具体化，<a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/tree/master/multi-env-deployment#option-1-use-urls-as-runtime-arguments" rel="noopener ugc nofollow" target="_blank">将它们作为工作流执行参数</a>传递。这对于通过CLI、通过各种客户端库或其余的&amp;gRPC API启动的工作流执行非常有用。然而，在事件触发的工作流的情况下，第一种方法有一个限制，其中调用者是Eventarc。在这种情况下，Eventarc决定传递哪些参数(即事件有效载荷)。在这种情况下，无法传递额外的参数。</p><p id="44df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更安全的方法是使用一些占位符替换技术。在部署更新的定义之前，只需使用一个工具来替换定义文件中的一些特定字符串标记。我们使用一些Clo <a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/tree/master/multi-env-deployment#option-2-use-cloud-build-to-deploy-multiple-versions" rel="noopener ugc nofollow" target="_blank"> ud构建步骤探索了这种方法，这些步骤执行一些字符串替换</a>。您仍然有一个单一的工作流定义文件，但是您为不同的环境部署了变体。如果您正在使用Terraform来配置您的基础设施，我们会为您提供帮助，您也可以使用类似于Terraform 的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/tree/master/multi-env-deployment#option-3-use-terraform-to-deploy-multiple-versions" rel="noopener ugc nofollow" target="_blank">技术。</a></p><p id="ee39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有其他可能的方法，比如利用Secret Manager和专用的<a class="ae jd" href="https://cloud.google.com/workflows/docs/reference/googleapis/secretmanager/Overview" rel="noopener ugc nofollow" target="_blank">工作流连接器</a>，来存储和检索这些URL。或者你也可以<a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/tree/master/gcs-read-write-json#load-environment-specific-variables-from-a-json-file-in-gcs" rel="noopener ugc nofollow" target="_blank">在一个云存储桶</a>中读取一些JSON文件，在其中你将存储那些环境特定的细节。</p><p id="b647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">利用子步骤</strong></p><p id="c7bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了分支或循环，定义步骤是一个相当连续的过程。一步接一步。步骤是它们自己的原子操作。然而，通常情况下，一些步骤实际上是齐头并进的，比如进行API调用、记录其结果、检索部分有效负载并将其分配到一些变量中。实际上，您可以将普通步骤重组为子步骤。当您从一组步骤转移到另一组步骤时，这变得很方便，而不必指向正确的原子步骤。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1af5" class="jn jo hi jj b fi jp jq l jr js">main:<br/>    params: [input]<br/>    steps:<br/>    - callWikipedia:<br/>        steps:<br/>        - checkSearchTermInInput:<br/>            switch:<br/>                - condition: ${"searchTerm" in input}<br/>                  assign:<br/>                    - searchTerm: ${input.searchTerm}<br/>                  next: readWikipedia<br/>        - getCurrentTime:<br/>            call: http.get<br/>            args:<br/>                url: …<br/>            result: currentDateTime<br/>        - setFromCallResult:<br/>            assign:<br/>                - searchTerm: ${currentDateTime.body.dayOfTheWeek}<br/>        - readWikipedia:<br/>            call: http.get<br/>            args:<br/>                url: <a class="ae jd" href="https://en.wikipedia.org/w/api.php" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/api.php</a><br/>                query:<br/>                    action: opensearch<br/>                    search: ${searchTerm}<br/>            result: wikiResult<br/>    - returnOutput:<br/>            return: ${wikiResult.body[1]}</span></pre><p id="bcd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">换行表达式</strong></p><p id="1bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">美元/花括号＄{ }表达式不是YAML规范的一部分，所以你放进去的东西有时与YAML的期望不太相符。例如，在表达式的字符串中放一个冒号可能会有问题，因为YAML解析器认为冒号是YAML键的结尾，是右边的开始。所以为了安全起见，你可以用引号将表达式括起来，比如:' ${…} '</p><p id="b2d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">表达式可以跨越几行，也可以跨越表达式中的字符串。这对于针对大查询的SQL查询来说很方便，就像我们的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/tree/master/bigquery-parallel" rel="noopener ugc nofollow" target="_blank">示例</a>中一样:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ff9d" class="jn jo hi jj b fi jp jq l jr js">query: ${<br/>    "SELECT TITLE, SUM(views)<br/>    FROM `bigquery-samples.wikipedia_pageviews." + table + "`<br/>    WHERE LENGTH(TITLE) &gt; 10<br/>    GROUP BY TITLE<br/>    ORDER BY SUM(VIEWS) DESC<br/>    LIMIT 100"<br/>}</span></pre><p id="28d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用声明式API调用替换无逻辑服务</strong></p><p id="e0ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/serverless-photosharing-workshop/" rel="noopener ugc nofollow" target="_blank">无服务器车间</a>的实验室1中，我们有一个<a class="ae jd" href="https://github.com/GoogleCloudPlatform/serverless-photosharing-workshop/blob/master/functions/image-analysis/nodejs/index.js#L19" rel="noopener ugc nofollow" target="_blank">功能服务</a>，它调用云视觉API，检查布尔属性，然后将结果写入Firestore。但是可以从工作流中以声明方式调用Vision API。布尔检查可以用一个开关条件表达式来完成，甚至写入Firestore也可以通过一个声明性API调用来完成。当在<a class="ae jd" href="https://github.com/GoogleCloudPlatform/serverless-photosharing-workshop/blob/master/workflows/workflows.yaml#L33" rel="noopener ugc nofollow" target="_blank">实验室6 </a>重写我们的应用程序以使用编排的方法时，我们将那些无逻辑的调用转移到声明性API调用中。</p><p id="0a3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时工作流缺少一些您需要的内置函数，因此您别无选择，只能使用一个函数来完成工作。但是当你有一些非常没有逻辑的代码，只是进行一些API调用时，你最好使用Workflows语法来声明性地编写它。</p><p id="0de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这并不意味着所有的事情，或者尽可能多的事情，都应该在工作流中以声明的方式完成。Workflows不是锤子，也绝对不是编程语言。因此，当存在真正的逻辑时，您肯定需要调用一些代表该业务逻辑的服务。</p><p id="bccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">储存你需要的，释放你能释放的</strong></p><p id="c19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工作流不断地向工作流执行授予更多的内存，但是有时候，对于较大的API响应负载，您会很高兴有更多的内存。这时，明智的内存管理可能是一件好事。你可以有选择地存储变量:不要存储太多，只存储你真正需要的有效载荷部分。一旦你知道你不需要某个变量的内容，你也可以把这个变量重新赋值为null，这样也可以释放内存。同样，首先，如果API允许您更积极地过滤结果，您也应该这样做。最后但并非最不重要的一点是，如果您调用的服务返回一个巨大的负载，而这个负载在工作流内存中放不下，那么您可以将调用委托给自己的函数，这个函数会代表您进行调用，并只返回您真正感兴趣的部分。</p><p id="ac79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要忘记查看关于<a class="ae jd" href="https://cloud.google.com/workflows/quotas" rel="noopener ugc nofollow" target="_blank">配额和限制</a>的文档，以了解更多可能的情况。</p><p id="8349" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">利用子工作流和调用外部工作流的能力</strong></p><p id="9c7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的工作流程中，有时您可能需要重复一些步骤。这时<a class="ae jd" href="https://cloud.google.com/workflows/docs/reference/syntax/subworkflows" rel="noopener ugc nofollow" target="_blank">子工作流</a>就变得很方便了。子工作流类似于子例程、程序或方法。它们是一种使一组步骤可在工作流的几个地方重用的方法，可能用不同的参数进行参数化。唯一的缺点可能是子工作流只是工作流定义的一部分，所以它们不能在其他工作流中重用。在这种情况下，您实际上可以创建一个专用的可重用工作流，因为您也可以<a class="ae jd" href="https://cloud.google.com/workflows/docs/reference/googleapis/workflowexecutions/Overview" rel="noopener ugc nofollow" target="_blank">从其他工作流中调用工作流</a>！用于工作流的工作流连接器可以提供帮助。</p><p id="7761" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="5848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经介绍了一些提示和技巧，并且回顾了一些关于如何充分利用工作流的有用建议。当然还有其他我们忘记了的。所以请在Twitter上与<a class="ae jd" href="https://twitter.com/meteatamel" rel="noopener ugc nofollow" target="_blank"> @meteatamel </a>和<a class="ae jd" href="https://twitter.com/glaforge" rel="noopener ugc nofollow" target="_blank"> @glaforge </a>分享它们。</p><p id="bfb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要忘记仔细检查工作流程<a class="ae jd" href="https://cloud.google.com/workflows/docs" rel="noopener ugc nofollow" target="_blank">文档</a>中的内容。特别是，看看<a class="ae jd" href="https://cloud.google.com/workflows/docs/reference/stdlib/overview" rel="noopener ugc nofollow" target="_blank">标准库</a>的内置函数，看看<a class="ae jd" href="https://cloud.google.com/workflows/docs/reference/googleapis" rel="noopener ugc nofollow" target="_blank">您可以使用的连接器</a>列表，甚至可能打印出<a class="ae jd" href="https://cloud.google.com/workflows/docs/reference/syntax/syntax-cheat-sheet" rel="noopener ugc nofollow" target="_blank">语法备忘单</a>！</p><p id="526c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，在文档门户中查看所有的<a class="ae jd" href="https://cloud.google.com/workflows/docs/samples" rel="noopener ugc nofollow" target="_blank">示例</a>，以及所有的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos" rel="noopener ugc nofollow" target="_blank">工作流演示</a> Mete和我已经构建并开源了。</p></div></div>    
</body>
</html>