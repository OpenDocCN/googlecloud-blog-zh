<html>
<head>
<title>Use multiple paths in Cloud Functions, Python and Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云函数、Python和Flask中使用多路径</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/use-multiple-paths-in-cloud-functions-python-and-flask-fc6780e560d3?source=collection_archive---------0-----------------------#2021-06-08">https://medium.com/google-cloud/use-multiple-paths-in-cloud-functions-python-and-flask-fc6780e560d3?source=collection_archive---------0-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cf773e45acb27d9b5b4995f2755f1bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23ZDjJbTjxmABLN1oSRygA.png"/></div></div></figure><p id="7e8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">功能即服务，或FaaS，一直是应用程序开发的基石。由于AWS Lambda服务的普及，所有主要的云提供商都提供了自己的版本，具有不同的功能。他们还将这一原则扩展到容器，例如在谷歌云上运行的<a class="ae jo" href="https://cloud.google.com/run/docs" rel="noopener ugc nofollow" target="_blank">云。</a></p><p id="7f35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Google Cloud上，<a class="ae jo" href="https://cloud.google.com/functions/docs" rel="noopener ugc nofollow" target="_blank"> Cloud Functions是FaaS服务</a>，要使用它，你必须执行预定义的代码结构。在Python中，为了处理HTTP请求，函数签名如下</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="6616" class="jy jz hi ju b fi ka kb l kc kd">def my_function(request):<br/>  ...<br/>  return "response", 200 #http code</span></pre><h1 id="9fd9" class="ke jz hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">FaaS常见问题</h1><p id="2573" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">当你部署一个功能时，它“只有一个功能”，只完成一个任务。这种固执己见的设计允许更好的可伸缩性和关注点分离。</p><p id="2e37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种选择的结果可以在调用该函数的可用URL中看到</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="94dc" class="jy jz hi ju b fi ka kb l kc kd">https://&lt;region&gt;-&lt;projectID&gt;.cloudfunctions.net/&lt;functionName&gt;</span></pre><p id="9f21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg">只有一条路径合适。没有子路径配置，没有路径路由定义。</em></p><p id="f5c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，有时，你想做更多，即使这不是一个好模式，你需要(或想要)使用REST API定义来访问资源，通过使用路径参数。<br/> <em class="lg">例如:</em> <code class="du lh li lj ju b"><em class="lg">/&lt;functionName&gt;/user/&lt;userId&gt;</em></code></p><h1 id="caca" class="ke jz hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Flask路由和云函数限制</h1><p id="609f" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">Flask framework提出了一种惯用的方法来实现这一点。你定义你的Flask App，你的路线，就这些<em class="lg"> ( </em> <a class="ae jo" href="https://flask.palletsprojects.com/en/1.1.x/quickstart/" rel="noopener ugc nofollow" target="_blank"> <em class="lg">你可以在任何教程/入门</em> </a> <em class="lg"> ) </em></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="992d" class="jy jz hi ju b fi ka kb l kc kd">from flask import Flask, request<br/><br/>app = Flask("internal")<br/><br/>@app.route('/user/&lt;string:id&gt;', methods=['GET', 'POST'])<br/>def users(id):<br/>    &lt;do something&gt;<br/>    print(id)<br/>    return id, 200</span></pre><p id="dc19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可悲的是，对于云函数，即使<a class="ae jo" href="https://cloud.google.com/functions/docs/concepts/exec#functions-concepts-stateless-python" rel="noopener ugc nofollow" target="_blank">云函数基于Flask请求定义</a>，你也不能，因为你不管理Flask root app，只管理云函数端点，仅此而已！！</p><p id="bcfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地理解，实现类似于</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="6db5" class="jy jz hi ju b fi ka kb l kc kd">############### MANAGED BY GOOGLE ####################</span><span id="4dbb" class="jy jz hi ju b fi lk kb l kc kd">from flask import Flask, request<br/><br/>app = Flask("google_managed")<br/><br/>@app.route('/my_function', methods=['GET', 'POST'])<br/>def common_cloud_functions_function():<br/>    return my_function(request)</span><span id="a79e" class="jy jz hi ju b fi lk kb l kc kd">############### MANAGED AND PROVIDED BY YOU ####################<br/>def my_function(request):<br/>  ...<br/>  return "response", 200 #http code</span></pre><blockquote class="ll"><p id="3a6b" class="lm ln hi bd lo lp lq lr ls lt lu jn dx translated">如何在不管理Flask服务器的情况下执行基于路径的路由？</p></blockquote><h1 id="edfc" class="ke jz hi bd kf kg kh ki kj kk kl km kn ko lv kq kr ks lw ku kv kw lx ky kz la bi translated">手动烧瓶调用</h1><p id="0a75" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">Flask是一个执行两个主要任务的框架</p><ul class=""><li id="14f9" class="ly lz hi is b it iu ix iy jb ma jf mb jj mc jn md me mf mg bi translated">基于URL映射执行路由</li><li id="568e" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">监听并服务于网络服务器</li></ul><p id="bd69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原则是只重用路由部分，不重用监听和服务；这一部分由云函数运行时执行。这个解决方案的主要兴趣是重用Flask惯用路径规则定义的能力，以及保持开发人员熟悉的环境。</p><p id="bd15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，当收到请求时，我们必须:</p><ul class=""><li id="e968" class="ly lz hi is b it iu ix iy jb ma jf mb jj mc jn md me mf mg bi translated">创建新的上下文</li><li id="39c1" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">复制请求的主要值(数据、头、路径等)</li><li id="3a1b" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">分派和处理请求</li></ul><p id="772a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，让我们编码吧！</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7057" class="jy jz hi ju b fi ka kb l kc kd">from flask import Flask, request</span><span id="8811" class="jy jz hi ju b fi lk kb l kc kd">#Define an internal Flask app<br/>app = Flask("internal")</span><span id="03b7" class="jy jz hi ju b fi lk kb l kc kd">#Define the internal path, idiomatic Flask definition<br/>@app.route('/user/&lt;string:id&gt;', methods=['GET', 'POST'])<br/>def users(id):<br/>    print(id)<br/>    return id, 200</span><span id="afea" class="jy jz hi ju b fi lk kb l kc kd">#Comply with Cloud Functions code structure for entry point<br/>def my_function(request):<br/>    #Create a new app context for the internal app<br/>    internal_ctx = app.test_request_context(path=request.full_path,<br/>                                            method=request.method)<br/>    <br/>    #Copy main request data from original request<br/>    #According to your context, parts can be missing. Adapt here!<br/>    internal_ctx.request.data = request.data<br/>    internal_ctx.request.headers = request.headers<br/>    <br/>    #Activate the context<br/>    internal_ctx.push()<br/>    #Dispatch the request to the internal app and get the result <br/>    return_value = app.full_dispatch_request()<br/>    #Offload the context<br/>    internal_ctx.pop()<br/>    <br/>    #Return the result of the internal app routing and processing      <br/>    return return_value</span></pre></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="96fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云功能照常部署，并提供相同的端点。但是，这一次，您可以请求您的新路径。尝试这个请求</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="8836" class="jy jz hi ju b fi ka kb l kc kd">curl https://&lt;region&gt;-&lt;projectID&gt;.cloudfunctions.net/&lt;functionName&gt;/user/123</span><span id="81e4" class="jy jz hi ju b fi lk kb l kc kd"># The return is 123</span></pre><h1 id="da1b" class="ke jz hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">解锁云功能限制…..还是不要！！</h1><p id="4fff" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">该解决方案允许您释放云功能的路由能力，并实现不止一个目的的端点。您可以获得一致性和效率(部署更少的功能)</p><p id="da02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，请记住，这只是一种变通方法，甚至是一种黑客行为，云函数并不是为此目的而设计的。</p><p id="2da6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想要创建一个API后端，在同一个实例上处理并发请求，拥有一个开发人员友好的环境(用于测试、打包、可移植性等)，Cloud Run是一个更适合的产品！</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="630c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg">免责声明:我不是Python开发者，一些代码部分可以改进得更地道。请不吝赐教，改进这些代码示例！</em></p></div></div>    
</body>
</html>