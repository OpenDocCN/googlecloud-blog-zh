<html>
<head>
<title>3 solutions to mitigate the cold-starts on Cloud Run.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减轻云运行冷启动的3种解决方案。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/3-solutions-to-mitigate-the-cold-starts-on-cloud-run-8c60f0ae7894?source=collection_archive---------0-----------------------#2020-11-09">https://medium.com/google-cloud/3-solutions-to-mitigate-the-cold-starts-on-cloud-run-8c60f0ae7894?source=collection_archive---------0-----------------------#2020-11-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d555734d59c60a41d2d7e2df43007274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-NTIruOTt1Z0DRPRtj_nQ.png"/></div></div></figure><p id="0393" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无服务器模式，在其终极设计中，只允许<strong class="is hj">在你使用服务</strong>时付费。使用Cloud Run，您只需支付正在处理的请求。剩下的<strong class="is hj">时间里，你什么都不用付出</strong>。其他服务如<strong class="is hj">云函数</strong>、<strong class="is hj"> App Engine (standard) </strong>也是如此，甚至在其他云上Azure函数或AWS Lambda也是如此。</p><p id="0311" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使这成为可能并可持续，云提供商<strong class="is hj">需要在服务空闲时保存资源</strong>，从而<strong class="is hj">停止空闲实例</strong>，因此<strong class="is hj">缩减至0 </strong>。<br/>从0开始，当一个新的请求进来时，你的应用需要被加载到一个实例上，启动/初始化，然后准备好服务流量。<strong class="is hj">该初始化比已经初始化的实例(<em class="jo">热启动</em>)花费更多的时间(<em class="jo">冷启动)</em> </strong>)。</p><blockquote class="jp"><p id="01f9" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">如何减轻或消除云运行中的这种冷启动？</p></blockquote><p id="8d58" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">我将介绍3种可能的解决方案及其利弊。</p><h1 id="8f06" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">最小实例特征</h1><p id="58b7" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">第一个解决方案是一个<strong class="is hj">内置的</strong>和新鲜的<a class="ae lh" href="https://cloud.google.com/run/docs/configuring/min-instances" rel="noopener ugc nofollow" target="_blank">新特性:最小实例</a>。它允许<strong class="is hj">定义保持温暖的最小实例数量</strong>，即使服务不服务任何请求，因此<strong class="is hj">减少/避免冷启动。</strong></p><p id="15c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为是内置的特性，<strong class="is hj">用起来很轻松简单。<a class="ae lh" href="https://cloud.google.com/sdk/gcloud/reference/beta/run/deploy#--min-instances" rel="noopener ugc nofollow" target="_blank">使用<code class="du li lj lk ll b">gcloud</code> CLI <em class="jo">(目前为测试版)</em>或直接通过UI使用</a> <code class="du li lj lk ll b"><a class="ae lh" href="https://cloud.google.com/sdk/gcloud/reference/beta/run/deploy#--min-instances" rel="noopener ugc nofollow" target="_blank">--min-instance</a>s</code> <a class="ae lh" href="https://cloud.google.com/sdk/gcloud/reference/beta/run/deploy#--min-instances" rel="noopener ugc nofollow" target="_blank">参数</a>部署您的服务</strong></p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/28a4e2867cb5b9ba470f58650ae6f3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*PLPlJLjZmLEBWFvPg6s5Xw.png"/></div></figure><p id="cfc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该解决方案<strong class="is hj">防止冷启动从0到1，但也达到最小实例值</strong>。因此，需要1个以上的实例来服务流量，<strong class="is hj">扩大规模更平滑</strong>。<br/></p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/09acd4e2b66ff6d5fa345a47b991d1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlqK0xDlI0vwlMnyFgufDQ.png"/></div></div></figure><p id="19dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，这个<strong class="is hj">特性是有代价的:</strong> <a class="ae lh" href="https://cloud.google.com/run/pricing#tables" rel="noopener ugc nofollow" target="_blank">空闲实例在不服务流量时被计费</a> <strong class="is hj">。<br/> <em class="jo">服务流量时，适用标准费率。</em></strong></p><p id="b6dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，<strong class="is hj">空闲实例的成本</strong>:</p><ul class=""><li id="7b65" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">vCPU标准费率的约10%。</li><li id="350a" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">内存标准速率的100%。</li></ul><h1 id="f20d" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">预定轮询请求</h1><p id="f5a8" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">第二种解决方案<strong class="is hj">使用</strong> <a class="ae lh" href="https://cloud.google.com/scheduler" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">云调度器</strong> </a> <strong class="is hj">来定期轮询</strong>云运行服务并<strong class="is hj">保持实例预热</strong>。</p><p id="7ed7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该解决方案<strong class="is hj">仅防止从0到1 </strong>的冷启动。此外，这只是<strong class="is hj">配置，不需要额外的代码</strong>。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/69981155f7fdf93322490f057d376568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDeqf1sQCtWWT1iUqhB-Qw.png"/></div></div></figure><p id="0aab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与解决方案1相比，这个<strong class="is hj">解决方案是免费的</strong>(或者至少非常实惠)。然而，它的主要问题是可能的“无实例”期。<br/> <em class="jo">事实上，即使您将调度程序设置为每分钟轮询一次(云调度程序的最低周期)，当前实例也可以在轮询后立即终止，并且在长达60秒的时间内，用户可以冷启动。</em></p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="e6a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该解决方案<strong class="is hj">易于配置:</strong></p><ul class=""><li id="4882" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">转到<a class="ae lh" href="https://console.cloud.google.com/cloudscheduler" rel="noopener ugc nofollow" target="_blank">云调度程序页面</a></li><li id="2477" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">创建新工作</li><li id="59e0" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">命名你的工作，选择你的频率，粘贴你的云运行服务网址。<em class="jo">你可以在这里添加你想要的路径</em></li><li id="cded" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">然后选择HTTP作为目标并配置HTTP谓词</li></ul><p id="2fe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">就这些！！</strong> <br/>如果您有<strong class="is hj">私有云运行服务，则需要额外配置</strong></p><ul class=""><li id="027f" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">点击<code class="du li lj lk ll b">SHOW MORE</code>扩展验证能力</li><li id="bf28" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">选择<code class="du li lj lk ll b">Add OIDC Token</code>，填写您的服务账户(必须有<code class="du li lj lk ll b">roles/run.invoker</code>)</li><li id="568b" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">将云运行服务根URL <em class="jo"> ( </em> <strong class="is hj"> <em class="jo">)无多余路径</em> </strong> <em class="jo"> ) </em>粘贴到受众字段。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/0606235f5f44737c56ff8e9dfaefd10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*4mADCcDJbfZh7m_VHKAtpw.png"/></div></figure><h1 id="4b25" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">无限循环</h1><p id="c2a0" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">第三种方案采用<a class="ae lh" href="https://cloud.google.com/blog/topics/developers-practitioners/graceful-shutdowns-cloud-run-deep-dive" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">优雅终止</strong> </a> <strong class="is hj">特征</strong>。它允许应用程序<strong class="is hj">接收SIGTERM通知</strong>，捕捉它并<strong class="is hj">在接下来的10秒内执行操作</strong>。</p><p id="d2b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使宽限终止时间很短，它也留出了执行动作的时间，比如<strong class="is hj">自己调用服务</strong>！像这样，</p><ol class=""><li id="2fb3" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn mp ly lz ma bi translated">当一个<strong class="is hj">实例关闭时，</strong>会发送一个SIGTERM通知</li><li id="e159" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn mp ly lz ma bi translated">通知运行优雅终止过程，该过程<strong class="is hj">调用当前服务的URL</strong></li><li id="097a" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn mp ly lz ma bi translated">如果当前没有运行其他实例，则会创建并启动一个新实例。像这样，总是有一个实例warm来服务流量<em class="jo">(除了在新实例创建的冷启动期间)</em>。综上，<strong class="is hj"><em class="jo">SIGTERM通知上的无限循环。</em>T13】</strong></li></ol></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="737a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该解决方案<strong class="is hj">仅防止从0到1 </strong>的冷启动。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/7489de35e82aefbc5d863e6e885dc071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BOTkows2Wzz0BZsoMlMbQ.png"/></div></div></figure><ul class=""><li id="3fd4" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">如果在冷启动期间发送用户请求，用户<strong class="is hj">可以等待更长时间。<em class="jo">冷启动时间越短，用户在冷启动期间发送请求的可能性就越小。</em></strong></li><li id="eb48" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">没有解决方案2中的长“无实例”期，因此用户请求冷启动的可能性更小。</li><li id="aa5c" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">没有方案1中的<strong class="is hj">成本</strong>。<em class="jo">自由层包括这个过程。</em></li><li id="f1e7" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">有额外的代码来实现(Go中大约100行)</li></ul></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="4988" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，一个<strong class="is hj">实例不知道如何称自己为</strong>服务URL。我们必须<strong class="is hj">检索这个信息</strong>。为此，需要</p><ul class=""><li id="739c" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated"><strong class="is hj">部署服务的区域</strong>。我们可以从具有<code class="du li lj lk ll b">/instance/region</code>端点的 <a class="ae lh" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">元数据服务器</strong> </a> <strong class="is hj"> </strong>中获取<strong class="is hj">。<em class="jo">注:t </em> <strong class="is hj"> <em class="jo">他的端点是针对云运行</em> </strong> <em class="jo">的，对于计算引擎来说是不存在的。</em></strong></li><li id="35fb" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated"><strong class="is hj">项目ID或项目编号</strong>，两者皆有可能。碰巧的是，<strong class="is hj">元数据服务器也提供了项目编号</strong>，并且与区域值同时提供。</li></ul><pre class="ln lo lp lq fd mr ll ms mt aw mu bi"><span id="2a64" class="mv kf hi ll b fi mw mx l my mz">func getProjectAndRegion() (prNb string, region string, err error) {<br/>   resp, err := metadata.Get("/instance/region")<br/>   if err != nil {<br/>      return<br/>   }<br/>   // response pattern is projects/&lt;projectNumber&gt;/regions/&lt;region&gt;<br/>   r := strings.Split(resp,"/")<br/>   prNb = r[1]<br/>   region = r[3]<br/>   return<br/>}</span></pre><ul class=""><li id="ab07" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated"><strong class="is hj">服务名</strong>。它由<a class="ae lh" href="https://cloud.google.com/run/docs/reference/container-contract#env-vars" rel="noopener ugc nofollow" target="_blank">云运行默认环境变量</a>T1】提供</li></ul><p id="769e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这些值，<strong class="is hj">就可以执行对</strong> <a class="ae lh" href="https://cloud.google.com/run/docs/reference/rest/v1/namespaces.services/get" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">云运行REST API </strong> </a> <code class="du li lj lk ll b"><a class="ae lh" href="https://cloud.google.com/run/docs/reference/rest/v1/namespaces.services/get" rel="noopener ugc nofollow" target="_blank">namespaces.services.get</a></code>的调用，并让<strong class="is hj">获取服务的URL</strong>。为此，必须授予云运行服务帐户<code class="du li lj lk ll b">roles/run.viewer</code>。</p><pre class="ln lo lp lq fd mr ll ms mt aw mu bi"><span id="8013" class="mv kf hi ll b fi mw mx l my mz">func getCloudRunUrl(region string, projectNumber string, service string) (url string, err error) {<br/>   ctx := context.Background()<br/>   client, err := google.DefaultClient(ctx)<br/><br/>   cloudRunApi := fmt.Sprintf("https://%s-run.googleapis.com/apis/serving.knative.dev/v1/namespaces/%s/services/%s", region, projectNumber, service)<br/>   resp, err := client.Get(cloudRunApi)<br/><br/>   if err != nil {<br/>     ...<br/>   }<br/>   defer resp.Body.Close()<br/>   body, err := ioutil.ReadAll(resp.Body)<br/>   if err != nil {<br/>      ...<br/>   }<br/>   cloudRunResp := &amp;CloudRunAPIUrlOnly{}<br/>   json.Unmarshal(body, cloudRunResp)<br/>   url = cloudRunResp.Status.URL<br/>   return<br/>}</span><span id="5be8" class="mv kf hi ll b fi na mx l my mz">// Minimal type to get only the interesting part in the answer<br/>type CloudRunAPIUrlOnly struct {<br/>   Status struct {<br/>      URL string `json:"url"`<br/>   } `json:"status"`<br/>}</span></pre><p id="6815" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了云运行服务URL，现在<strong class="is hj">调用这个URL </strong>就很简单了。在我的例子中，我在根路径<code class="du li lj lk ll b">/</code>上执行了一个<code class="du li lj lk ll b">GET</code>。但是您可以自定义调用路径和HTTP方法。<br/> <em class="jo">注意:即使您调用了一个不存在的路径，并且您得到一个404 HTTP错误，服务已经被调用并且实例已经被创建！</em></p><p id="6469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于一个<strong class="is hj">更通用的解决方案</strong>，我实现了一个<a class="ae lh" href="https://cloud.google.com/run/docs/authenticating/service-to-service#go" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">服务对服务调用</strong>。</a>对于公有云运营服务来说<strong class="is hj">没用，但是<strong class="is hj">涵盖了私有云运营服务</strong>的情况。<br/> <em class="jo">在私有云运行服务的情况下，云运行服务账户必须有</em> <code class="du li lj lk ll b"><em class="jo">roles/run.invoker</em></code> <em class="jo">被授予对自身进行呼叫的授权。</em></strong></p><p id="f148" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我也<strong class="is hj">循环，直到我有一个2XX HTTP代码</strong>。<em class="jo">这个循环可以无限但是，不要紧，</em><strong class="is hj"><em class="jo">10s后实例被杀死</em> </strong> <em class="jo">！</em></p><pre class="ln lo lp lq fd mr ll ms mt aw mu bi"><span id="0622" class="mv kf hi ll b fi mw mx l my mz">func selfCall(url string) {<br/>   tokenURL := fmt.Sprintf("/instance/service-accounts/default/identity?audience=%s", url)<br/>   idToken, err := metadata.Get(tokenURL)<br/>   if err != nil {<br/>      ...<br/>   }<br/><br/>   req, err := http.NewRequest("GET", url, nil)<br/>   if err != nil {<br/>      ...<br/>   }<br/>   req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", idToken))<br/>   for resp,err := http.DefaultClient.Do(req); err != nil || resp.StatusCode&gt;=300; {<br/>      fmt.Println("self call not successful, retry")<br/>   }<br/>   fmt.Println("Self call success. Goodbye")<br/>   os.Exit(0)<br/>}</span></pre><p id="0c7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">你可以在GitHub资源库</em><em class="jo"><br/></em><strong class="is hj"><em class="jo">上找到</em> <a class="ae lh" href="https://github.com/guillaumeblaquiere/cloudrun-sigterm-selfcall" rel="noopener ugc nofollow" target="_blank"> <em class="jo">完整代码:我在万圣节晚上创造了这个僵尸代码！</em></a></strong></p><p id="62e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该代码<strong class="is hj">可适用于任何语言</strong>。我将很乐意帮助你实现这个目标。</p><h1 id="aff9" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">选择你需要的</h1><p id="b789" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">最后，你有三个不同约束和期望的解决方案。</p><ul class=""><li id="ce8d" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated"><strong class="is hj">最小实例</strong>内置解决方案是<strong class="is hj">最贵的</strong>，也是<strong class="is hj">企业级解决方案</strong>，只需<strong class="is hj"> <em class="jo">一键</em>配置</strong>即可<strong class="is hj">防止1个以上实例</strong>冷启动。</li><li id="7532" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated"><strong class="is hj">计划轮询</strong>非常经济实惠，并且<strong class="is hj">只需要配置</strong>和<strong class="is hj"> </strong>云调度程序。然而，该解决方案仅涵盖从0到1的情况，并且也是<strong class="is hj">防止冷启动最差的解决方案。</strong></li><li id="0c81" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated"><strong class="is hj">短期管理</strong>解决方案是<strong class="is hj">成本(最便宜的解决方案)和冷启动预防之间最平衡的解决方案</strong>。然而，与前一个解决方案一样，该解决方案仅覆盖<strong class="is hj">从0到1实例的情况以及所需的代码更新</strong> <em class="jo">(以及维护、测试……)</em></li></ul><p id="0991" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据你的需求、预算和技能，<strong class="is hj">选择最适合的</strong>！</p></div></div>    
</body>
</html>