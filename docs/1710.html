<html>
<head>
<title>Fine-tuning Pub/Sub performance with batch and flow control settings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过批处理和流量控制设置微调发布/订阅性能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/pub-sub-flow-control-batching-9ba9a75bce3b?source=collection_archive---------0-----------------------#2020-12-14">https://medium.com/google-cloud/pub-sub-flow-control-batching-9ba9a75bce3b?source=collection_archive---------0-----------------------#2020-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f3016f10c8b09d46f7dd298e8a179fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*JV-vjRPyk5uxsfyD.png"/></div></figure><p id="74d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://cloud.google.com/pubsub/docs/overview" rel="noopener ugc nofollow" target="_blank"> Google Cloud Pub/Sub </a>经常被用作大规模流媒体分析管道的事件消化和交付服务。当设计具有下游依赖性的大规模管道时，当在您的服务中使用云发布/订阅时，重要的是要考虑发布者<strong class="io hj">批处理</strong>和订阅者<strong class="io hj">流量控制</strong>属性，以在<strong class="io hj"> <em class="jl">成本</em> </strong> <em class="jl">、</em> <strong class="io hj">、<em class="jl">延迟</em> </strong>、和<strong class="io hj"> <em class="jl">吞吐量</em> </strong>之间找到正确的平衡。在本文的上下文中，延迟是指下游依赖项接收发布的数据所需的时间，而吞吐量是指每秒发布的消息数。</p><figure class="jn jo jp jq fd ij er es paragraph-image"><div class="er es jm"><img src="../Images/25e4815b13c66fa40ede39adca30cc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*W46BPXAt14jyzniiGZmDCQ.png"/></div></figure><h1 id="bace" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">定量</h1><p id="8e39" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">在Cloud Pub/Sub的上下文中，<a class="ae jk" href="https://cloud.google.com/pubsub/docs/publisher#batching" rel="noopener ugc nofollow" target="_blank">批处理</a>是指由<a class="ae jk" href="https://cloud.google.com/pubsub/docs/overview#publisher-subscriber-relationships" rel="noopener ugc nofollow" target="_blank">发布者</a>在单个发布请求中发布到主题的一个或多个消息的组。批处理在<a class="ae jk" href="https://cloud.google.com/pubsub/docs/reference/libraries" rel="noopener ugc nofollow" target="_blank">客户端库</a>中默认完成，或者由用户明确完成。此功能的目的是允许更高的消息吞吐量，同时也为消息通过服务的各个层提供更有效的方式。调整批量大小(即在发布请求中发送多少消息或字节)可用于实现所需的吞吐量水平。</p><p id="0df4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">理想情况下，如果不考虑成本，并且满足用例需求，可以在禁用批处理的情况下按需创建发布者的实例。这通过水平扩展发布者的数量来最小化延迟并最大化吞吐量。</p><p id="9062" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jl">注意:1000字节是最小的请求大小，因此如果请求小于1000字节，出于成本考虑，将向上舍入到1000字节。</em></p><p id="4804" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，在大多数情况下，成本是一个考虑因素，因此在单个发布请求中发送多条消息是用较少的发布者达到同等吞吐量的一种方法。由于消息将被保留以填充批，这可能会导致延迟增加。</p><h2 id="5c77" class="ku js hi bd jt kv kw kx jx ky kz la kb ix lb lc kf jb ld le kj jf lf lg kn lh bi translated">批处理功能</h2><p id="7c04" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">特定于发布者端批处理的特性包括<code class="du li lj lk ll b">setElementCountThreshold()</code>、<code class="du li lj lk ll b">setRequestByteThreshold()</code>和<code class="du li lj lk ll b">setDelayThreshold()</code>，作为发布者客户端<code class="du li lj lk ll b">setBatchSettings()</code>的一部分(不同客户端库中的命名略有不同)。这些特性可以用来微调批处理的行为，以便在<em class="jl">成本、延迟、</em>和<em class="jl">吞吐量之间找到更好的平衡。</em></p><p id="8730" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du li lj lk ll b">setElementCountThreshold()</code>和<code class="du li lj lk ll b">setRequestByteThreshold()</code>通过指定消息或字节的最大数量来控制发布请求的最大大小。目标是在高吞吐量和与处理高吞吐量所需的订户资源相关联的成本之间找到正确的平衡。</p><p id="2b71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jl">注意:单次批量发布的最大消息数为1000条或10 MB。</em></p><p id="c387" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du li lj lk ll b">setDelayThreshold()</code>提供了控制发送批处理前等待时间的灵活性，特别是关于为填充批处理而保存消息的时间。减小该值可改善延迟，而增大该值可增加填满整个批次的可能性，适用于对延迟不太敏感的应用。</p><p id="3584" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些批处理属性的示例可在<a class="ae jk" href="https://cloud.google.com/pubsub/docs/samples/pubsub-publisher-batch-settings" rel="noopener ugc nofollow" target="_blank">发布批处理设置</a>文档中找到。</p><h1 id="71e9" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">流控制</h1><p id="a82a" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">数据管道经常会收到发布流量中的零星峰值，这可能会使订户不知所措，难以跟上。对于订阅中发布的高吞吐量，通常的反应是动态地自动调整订阅方资源，以使用更多的消息。但是，这可能会产生不必要的成本，例如，您可能需要使用更多的虚拟机，从而导致额外的容量规划。</p><p id="8a6e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://cloud.google.com/pubsub/docs/pull#config" rel="noopener ugc nofollow" target="_blank">订户端的流量控制</a>功能允许订户调节接收消息的速率，从而有助于控制管道上这些任务的不健康行为。这些特性提供了额外的功能来调整服务对发布吞吐量的突然峰值或下降的敏感程度。这减少了与自动扩展相关的不必要成本，以维持更高的吞吐量。</p><p id="36df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">理想情况下，具有无限订户容量的服务可以通过在订户资源上水平扩展来最小化延迟和最大化吞吐量。然而，在大多数服务受用户容量限制的情况下，流量控制允许用户定义用户容量。这些流量控制功能可用于在吞吐量和端到端延迟之间找到最佳平衡。</p><h2 id="cefc" class="ku js hi bd jt kv kw kx jx ky kz la kb ix lb lc kf jb ld le kj jf lf lg kn lh bi translated"><strong class="ak">流量控制特性</strong></h2><p id="1002" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">有助于调整订户上的流量控制和其他设置的一些特性有<code class="du li lj lk ll b">setMaxOutstandingElementCount()</code>、<code class="du li lj lk ll b">setMaxOutstandingRequestBytes()</code>和<code class="du li lj lk ll b">setMaxAckExtensionPeriod()</code>(同样，不同客户端库中的命名略有不同)。</p><p id="02cc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du li lj lk ll b">setMaxOutstandingElementCount()</code>和<code class="du li lj lk ll b">setMaxOutstandingRequestBytes()</code>是订户客户端上<code class="du li lj lk ll b">setFlowControlSettings()</code>的一部分，它们设置了未被发布/订阅接收到ack/nack的消息的最大数量和字节。一旦达到此限制，客户端将无法提取更多的消息，直到已经提取的消息得到确认。这提供了一种将吞吐量与运行更多订阅者的相关成本相匹配的方法。</p><p id="0827" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du li lj lk ll b">setMaxAckExtensionPeriod()</code>在订阅者客户端设置发布/订阅需要等待ack或n ack的最长时间。它通过让发布/订阅在一定时间后将消息重新传递给另一个客户端，来防止消息滞留在任何一个订阅者客户端上。<em class="jl">发布/订阅客户端库自动对正在处理的消息调用</em> <code class="du li lj lk ll b"><em class="jl">modifyAckDeadline()</em></code> <em class="jl">，直到</em> <code class="du li lj lk ll b"><em class="jl">setMaxAckExtensionPeriod()</em></code> <em class="jl">过去，默认为1小时。</em>如果消息在此时间段内既未被确认也未被否定，则它们将过期，并有资格重新传递。</p><p id="d1ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正在使用的这些设置的示例可在<a class="ae jk" href="https://cloud.google.com/pubsub/docs/samples/pubsub-subscriber-flow-settings" rel="noopener ugc nofollow" target="_blank">订阅流量控制</a>文档中找到。</p><h1 id="e597" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">流量控制和配料</h1><p id="1356" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">虽然流量控制功能在订阅服务器上工作，批处理功能在发布服务器上工作，但两者都可以结合使用，以抵消不同级别的<em class="jl">成本、延迟、</em>和<em class="jl">吞吐量</em>，从而找到最能满足服务需求的平衡点。</p><p id="9618" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以按需创建发布者和订阅者的服务可以产生低端到端延迟和高吞吐量，但代价是与更多计算资源相关联的更高成本。可以考虑批处理和流量控制优化，以将云发布/订阅服务成本控制在预算内。</p><p id="ba98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">批处理和流量控制都是通过限制资源来优化成本，然而它们是以相反的方式实现的。批处理侧重于用更少的发布者资源提供更高的吞吐量，而流控制侧重于以吞吐量为代价减少订阅者资源。类似地，这两种功能都在延迟方面做出了妥协，延迟由资源决定，这反过来有助于降低成本。当使用这些特性时，检查用例如何从这些优化中获益是很重要的。</p><p id="9816" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">批处理的好处是更高的吞吐量，但是这只有在下游处理所需的订户资源能够支持时才有效。根据使用情况，可以在需要时创建订户，以最大化吞吐量并最小化端到端延迟。这是通过允许在更大的计算资源池中分配更多工作来实现的。但是，在发布的吞吐量难以预测且存在预算限制的情况下，峰值或持续的高吞吐量可能成本高昂，并会导致不健康的管道行为，从而导致不必要的延迟和对下游的影响。这种不必要的行为可以通过使用流量控制功能来缓解，方法是限制计算资源，从而限制接收消息的速率。一般来说，这样做的好处是可以控制用户对高吞吐量时期的反应，但会增加延迟。</p><h2 id="7a2d" class="ku js hi bd jt kv kw kx jx ky kz la kb ix lb lc kf jb ld le kj jf lf lg kn lh bi translated">消息重新传递和重复率</h2><p id="92e8" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">但是，发布者的批处理配置有一个地方会影响订阅者— <em class="jl">一个批处理中的所有消息都必须在该批处理的确认截止日期之前得到确认，否则整个批处理都要重新排队等待传递</em>。当服务器在内存中缓存单个消息确认以尝试避免重新传递时，确认消息花费的时间越长，订户就越有可能使用不同的服务器，或者服务器将重新启动并丢失状态。因此，这些未确认的批次中先前已确认消息的记录将会丢失，并可能导致更高的重复率。因为云发布/订阅保证至少一次消息传递，所以重复率预计为0.1%。如果重复率增加超过预期值，可以做一些事情来更好地调整服务:</p><ul class=""><li id="1905" class="lm ln hi io b ip iq it iu ix lo jb lp jf lq jj lr ls lt lu bi translated">通过以更高的速率确认消息来减少确认延迟。</li><li id="1f00" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">通过调整订户客户端上的<code class="du li lj lk ll b">setMaxExtensionPeriod()</code>来增加ack截止时间。这给了订户更多的时间来处理消息。</li><li id="0cf1" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">检查代码中某些消息没有得到确认的错误。这通常是未被捕获的异常的结果。为了对此进行调试，在收到消息后立即记录消息ID，然后在对消息调用<code class="du li lj lk ll b">ack()</code>后立即记录消息ID可能会有所帮助。确保收到的所有消息都有相应的<code class="du li lj lk ll b">ack()</code>呼叫。</li><li id="e591" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">如果消息之间的确认延迟差异很大，或者有些消息无法得到确认，则以较小的批量发布会有所帮助。小批量有助于减少将整批标记为已确认所需的消息数量。</li><li id="542e" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">如果用户确认消息太慢，则减少<code class="du li lj lk ll b">setMaxOutstandingElementCount()</code>或<code class="du li lj lk ll b">setMaxOutstandingRequestBytes()</code>(通常在消息拉取和消息确认之间执行多个操作时)。在相同的时间内处理更少的消息和ack可以防止消息过早过期和被重新传递。</li></ul><p id="121f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总之，目标是使用<strong class="io hj"> <em class="jl">消息大小</em></strong><em class="jl"/><strong class="io hj"><em class="jl">发布者吞吐量</em> </strong> <em class="jl">和</em> <strong class="io hj"> <em class="jl">订阅者处理延迟</em> </strong> <em class="jl"> </em>来优化<em class="jl">成本、延迟和吞吐量。</em>这些优化是通过<strong class="io hj"><em class="jl"/></strong><em class="jl"/><strong class="io hj"><em class="jl">流量控制</em> </strong> <em class="jl"> </em>和<em class="jl"> </em> <strong class="io hj"> <em class="jl">批处理</em> </strong>之间的权衡组合来实现的。</p></div></div>    
</body>
</html>