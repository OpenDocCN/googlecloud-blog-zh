<html>
<head>
<title>Build a blog application on Google App Engine: Comment module (part 7)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google App Engine上构建一个博客应用程序:评论模块(第7部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-comment-module-part-7-b18e907e3e38?source=collection_archive---------2-----------------------#2018-12-11">https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-comment-module-part-7-b18e907e3e38?source=collection_archive---------2-----------------------#2018-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/44ff1d5d8cb0314c01d865fc9163cdf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTsEafc6yC3GvAx6AxIVLA.jpeg"/></div></div></figure><p id="218b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是关于如何使用<strong class="is hj"> Google Datastore </strong>在Node.js中构建一个小型博客应用程序并将其部署到<strong class="is hj"> Google App Engine </strong>的多部分教程的第七部分。如果你错过了开头，<a class="ae jo" rel="noopener" href="/google-cloud/build-a-blog-application-on-google-app-engine-setup-part-1-38dab981b779">跳到第一部分</a>，在那里我解释如何建立这个项目，在那里你会找到其他部分的链接。</p><p id="b037" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经走了很长一段路，我们的申请也快完成了。在本节中，<strong class="is hj">我们将构建<em class="jp">评论</em>模块，顾名思义，该模块允许用户对帖子</strong>发表评论。由于许多代码将与我们在其他模块中所做的类似，所以我不会详细介绍。我们需要创建的主要层有:</p><ul class=""><li id="325f" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated"><strong class="is hj">数据库层。</strong></li><li id="fbde" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">将与数据库层交互的<strong class="is hj">域层</strong>。</li><li id="ba91" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">一个<strong class="is hj">路由处理器层</strong>在HTTP请求和我们的域层之间建立桥梁。</li></ul><h1 id="edeb" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">评论数据库</h1><p id="c651" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">就像<em class="jp"> BlogPost </em>层一样，<em class="jp">评论</em>层将<strong class="is hj">成为我们<em class="jp">博客</em>模块</strong>的一个子模块。让我们从添加我们的<em class="jp">注释</em>类型脚本类型开始，然后我们将准备创建数据库访问层来与数据存储交互。</p><p id="d15d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“<em class="jp"> modules/blog </em>”文件夹中创建一个“<em class="jp"> comment </em>”文件夹，并在其中添加一个“<em class="jp"> models.ts </em>”文件，其内容如下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0a29" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/comment/models.ts</span><span id="053d" class="lq kf hi lm b fi lv ls l lt lu">export type CommentType = {<br/>  blogPost: number;<br/>  createdOn: Date;<br/>  createdOnFormatted?: string;<br/>  name: string;<br/>  comment: string;<br/>  website: string;<br/>};</span></pre><p id="9388" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们有了自己的<em class="jp"> CommentType </em> <strong class="is hj">让我们构建数据库层</strong>。在同一文件夹中创建一个“<em class="jp"> comment.db.ts </em>”文件，并添加以下内容:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="47bb" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/comment/comment.db.ts</span><span id="90b4" class="lq kf hi lm b fi lv ls l lt lu">import Joi from "joi";<br/>import distanceInWords from "date-fns/distance_in_words";<br/>import { Entity, Query, QueryListOptions } from "gstore-node";</span><span id="c575" class="lq kf hi lm b fi lv ls l lt lu">import { Context } from "../models";<br/>import { CommentType } from "./models";</span><span id="daf0" class="lq kf hi lm b fi lv ls l lt lu">export interface CommentDB {<br/>  getComments(<br/>    postId: number | string,<br/>    options?: QueryListOptions &amp; { withVirtuals?: boolean }<br/>  ): Promise&lt;any&gt;;<br/>  createComment(data: CommentType): Promise&lt;CommentType&gt;;<br/>  deleteComment(<br/>    id: number | string | (number | string)[]<br/>  ): Promise&lt;any&gt;;<br/>}</span><span id="86a6" class="lq kf hi lm b fi lv ls l lt lu">export default ({ gstore }: Context): CommentDB =&gt; {<br/>  const { Schema } = gstore;</span><span id="2338" class="lq kf hi lm b fi lv ls l lt lu">  /**<br/>   * We use "Joi" to validate this Schema<br/>   */<br/>  const schema = new Schema&lt;CommentType&gt;(<br/>    {<br/>      blogPost: { joi: Joi.number() },<br/>      createdOn: {<br/>        joi: Joi.date().default(<br/>          () =&gt; new Date(),<br/>          "Current datetime of request"<br/>        ),<br/>        write: false<br/>      },<br/>      // user name must have minimum 3 characters<br/>      name: { joi: Joi.string().min(3) },<br/>      // comment must have minimum 10 characters<br/>      comment: {<br/>        joi: Joi.string().min(10),<br/>        excludeFromIndexes: true<br/>      },<br/>      website: {<br/>        joi: Joi.string()<br/>          .uri() // validate url<br/>          .allow(null)<br/>      }<br/>    },<br/>    { joi: true } // tell gstore that we will validate with Joi<br/>  );</span><span id="e484" class="lq kf hi lm b fi lv ls l lt lu">  /**<br/>   * We add a virtual property "createdOnFormatted" (not persisted <br/>   * in the Datastore) to display the date in our View<br/>   */<br/>  schema<br/>    .virtual("createdOnFormatted")<br/>    .get(function getCreatedOnFormatted() {<br/>      return `${distanceInWords(<br/>        new Date(),<br/>        new Date(this.createdOn)<br/>      )} ago`;<br/>    });</span><span id="946b" class="lq kf hi lm b fi lv ls l lt lu">  /**<br/>   * Create a "Comment" Entity Kind Model passing our schema<br/>   */<br/>  const Comment = gstore.model("Comment", schema);</span><span id="4c9f" class="lq kf hi lm b fi lv ls l lt lu">  /**<br/>   * DB API<br/>   */<br/>  return {<br/>    async getComments(postId, options = { limit: 3 }) {<br/>      const query = Comment.query()<br/>        .filter("blogPost", postId)<br/>        .order("createdOn", { descending: true })<br/>        .limit(options.limit);</span><span id="2085" class="lq kf hi lm b fi lv ls l lt lu">      if (options.start) {<br/>        query.start(options.start);<br/>      }</span><span id="0d6e" class="lq kf hi lm b fi lv ls l lt lu">      const { entities, nextPageCursor } = await query.run({<br/>        format: "ENTITY"<br/>      });</span><span id="925d" class="lq kf hi lm b fi lv ls l lt lu">      return {<br/>        entities: (&lt;Entity&lt;CommentType&gt;[]&gt;entities).map(entity =&gt;<br/>          // Return Json with virtual properties<br/>          entity.plain({ virtuals: !!options.withVirtuals })<br/>        ),<br/>        nextPageCursor<br/>      };<br/>    },<br/>    async createComment(data) {<br/>      const entityData = Comment.sanitize(data);<br/>      const comment = new Comment(entityData);<br/>      const entity = await comment.save();</span><span id="f507" class="lq kf hi lm b fi lv ls l lt lu">      return entity.plain({ virtuals: true });<br/>    },<br/>    deleteComment(id) {<br/>      return Comment.delete(id);<br/>    }<br/>  };<br/>};</span></pre><p id="c1f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到，对于我们的<em class="jp">注释</em>模式，我已经决定使用<a class="ae jo" href="https://github.com/hapijs/joi" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Joi </strong> </a>来验证属性。<em class="jp"> Joi </em>是一个强大的对象模式验证，与<a class="ae jo" href="https://sebloix.gitbook.io/gstore-node/schema/value_validation" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> gstore验证</strong> </a>相比，它可以让你指定更细粒度的规则(比如字符串的长度)(虽然任何验证都可以通过<em class="jp">自定义验证函数</em>来实现，但不如Joi那么简单)。在许多情况下，<code class="du lw lx ly lm b">gstore</code>验证就足够了，但是如果您需要更好的规则，您可能想使用Joi。请记住<strong class="is hj">您需要单独安装Joi npm包</strong>，因为在安装<code class="du lw lx ly lm b">gstore-node</code>时默认情况下它不会出现。<br/>一个重要的注意事项:<strong class="is hj">你不能在同一个模式上混合两种</strong> <strong class="is hj">类型的验证</strong>，如果你选择使用<em class="jp"> Joi </em>，你必须在模式<em class="jp">选项</em>对象中用<code class="du lw lx ly lm b">{ joi: true }</code>指定它。阅读文档了解所有信息。</p><p id="ebc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在声明了<em class="jp">注释</em>模式之后，我们使用它的一个助手方法:<code class="du lw lx ly lm b">virtual()</code>。这个方法允许我们<strong class="is hj">在实体</strong>上创建虚拟属性。虚拟属性是动态创建的，并且<strong class="is hj">不存储在数据存储</strong>中。每当我们在实体上调用<code class="du lw lx ly lm b">plain()</code>方法时，这些虚拟属性就被添加到实体数据中。例如:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5262" class="lq kf hi lm b fi lr ls l lt lu">const entityData = someEntity.plain({ virtuals: true });</span></pre><p id="719f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于我们的<em class="jp">注释</em>模式，我们声明了一个<code class="du lw lx ly lm b">createdOnFormatted</code>虚拟属性。它将把<code class="du lw lx ly lm b">createdOn</code>日期属性格式化为一个文字字符串(例如“1小时前”)。</p><p id="a739" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面，在我们的API方法<code class="du lw lx ly lm b">getComments()</code>中，你可以看到我们将结果的数量限制为<strong class="is hj"> 3个注释</strong>。如果提供了一个<code class="du lw lx ly lm b">start</code>选项(对应于我们之前查询的<code class="du lw lx ly lm b">nextPageCursor</code>值),我们会将其转发给Google Datastore查询对象。这个<strong class="is hj">允许我们进行分页</strong>，并且在我们的视图中有一个“<em class="jp"> Load more </em>”按钮来获取更多的评论。</p><p id="36c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！这都是针对数据库层的。现在让我们创建将使用它的<strong class="is hj">域层</strong>。</p><h1 id="4973" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">评论域</h1><p id="18c0" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在同一个文件夹中，创建一个“<em class="jp"> comment.domain.ts </em>”文件，并添加以下内容:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="fdb2" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/comment/comment.domain.ts</span><span id="6306" class="lq kf hi lm b fi lv ls l lt lu">import { QueryListOptions } from "gstore-node";<br/>import { CommentType } from "./models";<br/>import { Context, Modules } from "../models";</span><span id="056e" class="lq kf hi lm b fi lv ls l lt lu">export interface CommentDomain {<br/>  getComments(<br/>    postId: number | string,<br/>    options?: QueryListOptions &amp; { withVirtuals?: boolean }<br/>  ): Promise&lt;any&gt;;<br/>  createComment(<br/>    postId: number | string,<br/>    data: CommentType<br/>  ): Promise&lt;CommentType&gt;;<br/>  deleteComment(<br/>    id: number | string | (number | string)[]<br/>  ): Promise&lt;any&gt;;<br/>}</span><span id="482c" class="lq kf hi lm b fi lv ls l lt lu">export default (<br/>  _: Context,<br/>  { commentDB }: Modules<br/>): CommentDomain =&gt; {<br/>  const getComments = (<br/>    postId: number | string,<br/>    options: QueryListOptions &amp; { withVirtuals?: boolean }<br/>  ) =&gt; {<br/>    postId = +postId;</span><span id="890f" class="lq kf hi lm b fi lv ls l lt lu">    if (options.start) {<br/>      options.start = decodeURIComponent(options.start);<br/>    }</span><span id="710a" class="lq kf hi lm b fi lv ls l lt lu">    return commentDB.getComments(postId, options);<br/>  };</span><span id="e22f" class="lq kf hi lm b fi lv ls l lt lu">  const createComment = (<br/>    postId: number | string,<br/>    data: CommentType<br/>  ) =&gt; {<br/>    postId = +postId;<br/>    const entityData = { ...data, blogPost: postId };<br/>    return commentDB.createComment(entityData);<br/>  };</span><span id="c5c8" class="lq kf hi lm b fi lv ls l lt lu">  const deleteComment = (<br/>    id: number | string | (number | string)[]<br/>  ) =&gt; commentDB.deleteComment(id);</span><span id="aca7" class="lq kf hi lm b fi lv ls l lt lu">  return {<br/>    getComments,<br/>    createComment,<br/>    deleteComment<br/>  };<br/>};</span></pre><p id="71a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">话不多说，<strong class="is hj">一个简单的CRUD接口，调用我们的DB层</strong>。我们需要将<code class="du lw lx ly lm b">commentDB</code>提供给<code class="du lw lx ly lm b">Modules</code> Typescript类型，因此从我们的<em class="jp"> Blog </em>模块中打开“<em class="jp"> models.ts </em>”文件，并进行以下修改:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="04da" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/models.ts</span><span id="0441" class="lq kf hi lm b fi lv ls l lt lu">...</span><span id="d9a2" class="lq kf hi lm b fi lv ls l lt lu">import { BlogPostDomain } from "./blog-post/blog-post.domain";<br/>import { CommentDB } from "./comment/comment.db"; // ***<br/>import { CommentDomain } from "./comment/comment.domain"; // ***</span><span id="6c90" class="lq kf hi lm b fi lv ls l lt lu">...</span><span id="5a1e" class="lq kf hi lm b fi lv ls l lt lu">export type Modules = {<br/>  blogPost?: BlogPostModule;<br/>  blogPostDB?: BlogPostDB;<br/>  blogPostDomain?: BlogPostDomain;<br/>  commentDB?: CommentDB; // ***<br/>  commentDomain?: CommentDomain; // ***<br/>  images?: ImagesModule;<br/>  utils?: UtilsModule;<br/>};</span><span id="0f56" class="lq kf hi lm b fi lv ls l lt lu">// *** = Add this line</span></pre><p id="c102" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，让我们快速地<strong class="is hj">添加路由处理程序来调用我们的域层</strong>。</p><h1 id="6c1c" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">注释路由处理程序</h1><p id="6eef" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在<em class="jp"> Comment </em>模块中创建一个“<em class="jp">Comment . routes-handlers . ts</em>”文件，并添加以下内容:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="6b64" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/comment/comment.routes-handlers.ts</span><span id="144e" class="lq kf hi lm b fi lv ls l lt lu">import { Request, Response } from "express";<br/>import { Context, Modules } from "../models";</span><span id="5da6" class="lq kf hi lm b fi lv ls l lt lu">export interface CommentRoutes {<br/>  getComments(req: Request, res: Response): any;<br/>  createComment(req: Request, res: Response): any;<br/>  deleteComment(req: Request, res: Response): any;<br/>}</span><span id="6670" class="lq kf hi lm b fi lv ls l lt lu">export default (<br/>  _: Context,<br/>  { commentDomain }: Modules<br/>): CommentRoutes =&gt; {<br/>  const getComments = async (req: Request, res: Response) =&gt; {<br/>    const postId = req.params.id;<br/>    let result;<br/>    try {<br/>      result = await commentDomain.getComments(postId, {<br/>        start: req.query.start,<br/>        limit: 3,<br/>        withVirtuals: true<br/>      });<br/>    } catch (err) {<br/>      return res.status(400).json(err);<br/>    }</span><span id="49e2" class="lq kf hi lm b fi lv ls l lt lu">    res.json(result);<br/>  };</span><span id="0ba7" class="lq kf hi lm b fi lv ls l lt lu">  const createComment = async (req: Request, res: Response) =&gt; {<br/>    const postId = req.params.id;<br/>    let comment;<br/>    try {<br/>      comment = await commentDomain.createComment(postId, req.body);<br/>    } catch (err) {<br/>      return res.status(400).json(err);<br/>    }</span><span id="61a1" class="lq kf hi lm b fi lv ls l lt lu">    res.json(comment);<br/>  };</span><span id="f50e" class="lq kf hi lm b fi lv ls l lt lu">  const deleteComment = async (req: Request, res: Response) =&gt; {<br/>    const commentId = req.params.id;<br/>    let result;<br/>    try {<br/>      result = await commentDomain.deleteComment(commentId);<br/>    } catch (err) {<br/>      return res.status(400).json(err);<br/>    }</span><span id="e4b0" class="lq kf hi lm b fi lv ls l lt lu">    res.send(result);<br/>  };</span><span id="6eaf" class="lq kf hi lm b fi lv ls l lt lu">  return {<br/>    getComments,<br/>    createComment,<br/>    deleteComment<br/>  };<br/>};</span></pre><p id="b885" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，代码是不言自明的。我们路线的三个<strong class="is hj">快递处理员</strong>。我们将在一分钟内创建API路由，但首先让我们快速地<strong class="is hj">初始化这3层</strong>。<br/>在我们的<em class="jp"> Comment </em>模块的根目录下创建一个“<em class="jp"> index.ts </em>”文件，并添加以下内容:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2e0f" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/comment/index.ts</span><span id="525d" class="lq kf hi lm b fi lv ls l lt lu">import initDB, { CommentDB } from "./comment.db";<br/>import initRoutes, {<br/>  CommentRoutes<br/>} from "./comment.routes-handlers";<br/>import initDomain, { CommentDomain } from "./comment.domain";<br/>import { Context } from "../models";</span><span id="f8af" class="lq kf hi lm b fi lv ls l lt lu">export * from "./models";</span><span id="d724" class="lq kf hi lm b fi lv ls l lt lu">export interface CommentModule {<br/>  commentDB: CommentDB;<br/>  commentDomain: CommentDomain;<br/>  routesHandlers: CommentRoutes;<br/>}</span><span id="9cfd" class="lq kf hi lm b fi lv ls l lt lu">export default (context: Context): CommentModule =&gt; {<br/>  const commentDB = initDB(context);<br/>  const commentDomain = initDomain(context, { commentDB });<br/>  const routesHandlers = initRoutes(context, { commentDomain });</span><span id="6680" class="lq kf hi lm b fi lv ls l lt lu">  return {<br/>    commentDB,<br/>    commentDomain,<br/>    routesHandlers<br/>  };<br/>};</span></pre><p id="190c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这与我们用<em class="jp"> BlogPost </em>模块所做的非常相似。我们初始化我们的3层并导出它们。我们现在需要<strong class="is hj">将我们的<em class="jp">评论</em>模块添加到博客<em class="jp">模块</em>类型</strong>中。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f51f" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/models.ts</span><span id="025b" class="lq kf hi lm b fi lv ls l lt lu">...<br/>import { BlogPostDomain } from "./blog-post/blog-post.domain";<br/>import { CommentModule } from "./comment"; // Add this line<br/>import { CommentDB } from "./comment/comment.db";<br/>...</span><span id="4dd7" class="lq kf hi lm b fi lv ls l lt lu">export type Modules = {<br/>  blogPost?: BlogPostModule;<br/>  comment?: CommentModule; // Add this line<br/>  ...<br/>};</span></pre><p id="c971" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并对模块进行初始化…</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="cb18" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/index.ts</span><span id="4784" class="lq kf hi lm b fi lv ls l lt lu">...<br/>import initBlogPost, { BlogPostModule } from "./blog-post";<br/>import initComment, { CommentModule } from "./comment"; // Add this</span><span id="554a" class="lq kf hi lm b fi lv ls l lt lu">import { Context, Modules } from "./models";</span><span id="5c6f" class="lq kf hi lm b fi lv ls l lt lu">export interface BlogModule {<br/>  webRouter: Router;<br/>  apiRouter: Router;<br/>  blogPost: BlogPostModule;<br/>  comment: CommentModule; // Add this line<br/>}</span><span id="9f16" class="lq kf hi lm b fi lv ls l lt lu">export default (context: Context, modules: Modules): BlogModule =&gt; {<br/>  const comment = initComment(context); // Add this line<br/>  // Edit the following line:<br/>  const blogPost = initBlogPost(context, { ...modules, comment });<br/>  const { webRouter, apiRouter } = initRoutes(context, {<br/>    blogPost,<br/>    comment, // Add this line<br/>  });</span><span id="b2d4" class="lq kf hi lm b fi lv ls l lt lu">  return {<br/>    webRouter,<br/>    apiRouter,<br/>    blogPost,<br/>    comment // Add this line<br/>  };<br/>};</span></pre><p id="90e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们<strong class="is hj">创建我们的REST API路由</strong>，这将允许我们<strong class="is hj">添加/删除和列出博客文章的评论</strong>。<br/>打开“<em class="jp"> blog.routes.ts </em>”文件，添加以下内容:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b6c2" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/blog.routes.ts</span><span id="7695" class="lq kf hi lm b fi lv ls l lt lu">import express from "express";<br/>import bodyParser from "body-parser"; // Add this line<br/>import { Context, Modules } from "./models";</span><span id="30d6" class="lq kf hi lm b fi lv ls l lt lu">export default (<br/>  context: Context,<br/>  { blogPost, comment }: Modules<br/>) =&gt; {<br/>  // WEB<br/>  ...</span><span id="c1ff" class="lq kf hi lm b fi lv ls l lt lu">  // API<br/>  const apiRouter = express.Router();<br/>  apiRouter.delete("/blog/:id", blogPost.routesHandlers.deletePost);<br/>  apiRouter.get(<br/>    "/blog/:id/comments",<br/>    comment.routesHandlers.getComments<br/>  );<br/>  apiRouter.post(<br/>    "/blog/:id/comments",<br/>    // We need the bodyParser middleware to parse the form data<br/>    bodyParser.json(),<br/>    comment.routesHandlers.createComment<br/>  );<br/>  apiRouter.delete(<br/>    "/comments/:id",<br/>    comment.routesHandlers.deleteComment<br/>  );<br/>};</span></pre><p id="8058" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们有一个REST API来管理评论，继续在你的帖子上创建一些评论。你也可以测试<strong class="is hj">gstore验证</strong>，比如为<code class="du lw lx ly lm b">website</code>字段传递一个错误的URL或者一个少于10个字符的注释。您应该会收到一个验证错误…太好了！我希望您开始看到模式验证的好处:)</p><h1 id="6880" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">清除注释</h1><p id="f90a" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">就像我们的特色图片一样，<strong class="is hj">当我们删除一篇文章</strong>时，我们希望删除与它相关的所有评论。你可能猜到了，我们需要<strong class="is hj">另一个中间件</strong>，我们将在一个<em class="jp"> BlogPost </em>实体从数据存储中删除后挂钩它。</p><p id="53b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先添加一个处理程序来删除BlogPost实体的评论:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2cb2" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/comment/comment.db.ts</span><span id="cca2" class="lq kf hi lm b fi lv ls l lt lu">...</span><span id="b4a1" class="lq kf hi lm b fi lv ls l lt lu">export interface CommentDB {<br/>  ...<br/>  deleteComment(<br/>    id: number | string | (number | string)[]<br/>  ): Promise&lt;any&gt;;<br/>  deletePostComment(postId: number): Promise&lt;any&gt;; // Add this line<br/>}</span><span id="60b3" class="lq kf hi lm b fi lv ls l lt lu">export default ({ gstore }: Context): CommentDB =&gt; {</span><span id="ecd6" class="lq kf hi lm b fi lv ls l lt lu">  ...</span><span id="77a6" class="lq kf hi lm b fi lv ls l lt lu">  /**<br/>   * DB API<br/>   */<br/>  return {<br/>    ...</span><span id="ff86" class="lq kf hi lm b fi lv ls l lt lu">    deleteComment(id) {<br/>      return Comment.delete(id);<br/>    },<br/>    async deletePostComment(postId) {<br/>      /**<br/>       * A keys-only query returns just the keys of the entities<br/>       * instead of the entities data, at lower latency and cost.<br/>       */<br/>      const { entities } = await Comment.query()<br/>        .filter("blogPost", postId)<br/>        .select("__key__")<br/>        .run();</span><span id="2bc6" class="lq kf hi lm b fi lv ls l lt lu">      const keys = (entities as Array&lt;any&gt;).map(<br/>        entity =&gt; entity[gstore.ds.KEY]<br/>      );</span><span id="672b" class="lq kf hi lm b fi lv ls l lt lu">      /**<br/>       * Use <a class="ae jo" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/datastore datastore.delete() APi to <br/>       * delete the keys.<br/>       * Reminder: gstore.ds is an alias to the underlying <br/>       * google datastore instance.<br/>       */<br/>      return gstore.ds.delete(keys);<br/>    }<br/>  };<br/>};</span></pre><p id="059c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建将使用这个处理程序的中间件。打开“<em class="jp"> blog-post.db.hooks.ts </em>”文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7a7d" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/blog-post/blog-post.db.hooks.ts</span><span id="fbe1" class="lq kf hi lm b fi lv ls l lt lu">import { Entity } from 'gstore-node';<br/>import { DatastoreKey } from '@google-cloud/datastore/entity';<br/>...</span><span id="2713" class="lq kf hi lm b fi lv ls l lt lu">export default (<br/>  { gstore }: Context,<br/>  { images, utils, commentDB }: Modules // Edit this line<br/>) =&gt; {</span><span id="7919" class="lq kf hi lm b fi lv ls l lt lu">  ...</span><span id="c943" class="lq kf hi lm b fi lv ls l lt lu">  /**<br/>   * Delete all the comments of a BlogPost after it has been deleted<br/>   *<br/>   * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} key The key of the entity deleted<br/>   */<br/>  function deleteComments({ key }: { key: DatastoreKey }) {<br/>    const { id } = key;<br/>    return commentDB.deletePostComment(+id);<br/>  }</span><span id="2561" class="lq kf hi lm b fi lv ls l lt lu">  return {<br/>    initEntityData,<br/>    deletePreviousImage,<br/>    deleteFeatureImage,<br/>    deleteComments // Add this line<br/>  };<br/>};</span></pre><p id="00f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们需要将这个中间件附加到我们的<em class="jp"> BlogPost </em>模式中。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="51e5" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/blog-post/blog-post.domain.ts</span><span id="170a" class="lq kf hi lm b fi lv ls l lt lu">...</span><span id="547a" class="lq kf hi lm b fi lv ls l lt lu">export default (<br/>  context: Context,<br/>  { blogPostDB, images, utils, comment }: Modules<br/>): BlogPostDomain =&gt; {<br/>  /**<br/>   * Add "pre" and "post" hooks to our Schema<br/>   */<br/>  const {<br/>    initEntityData,<br/>    deletePreviousImage,<br/>    deleteFeatureImage,<br/>    deleteComments // Add this<br/>  } = initDBhooks(context, {<br/>    images,<br/>    utils,<br/>    comment<br/>  });<br/>  blogPostDB.addPreSaveHook([deletePreviousImage, initEntityData]);<br/>  blogPostDB.addPreDeleteHook(deleteFeatureImage);<br/>  blogPostDB.addPostDeleteHook(deleteComments); // Add this</span><span id="b11c" class="lq kf hi lm b fi lv ls l lt lu">  ...<br/>};</span></pre><p id="fdee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们现在可以删除一篇博客文章以及与之相关的所有评论。</p><p id="59f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们的<em class="jp">评论</em>模块完成。我希望到现在为止，您已经开始看到我们为我们的应用程序建立的架构的好处了。通过<strong class="is hj">在模块和层中组织我们的应用程序，并通过输入和输出连接它们，</strong>我们的代码非常可伸缩，可测试，如果出现错误，我们应该能够很快找到它。<br/>我们还可以轻松地更改/交换任何模块的数据库层，并为我们的领域层提供一个新的数据库层(它不关心数据来自哪里)，我们的应用程序将完全像以前一样工作。</p><h1 id="f473" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">最后一次触摸…</h1><p id="2b76" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">让我们为博客应用程序添加最后一个细节。如果您还记得，当我们创建<em class="jp"> BlogPost </em>模块时，我们在<em class="jp"> BlogPost </em>模式上声明了一个<code class="du lw lx ly lm b">excerpt</code>属性。摘录是我们文章的一小段摘录，我们希望在主页上显示为文章内容的预览。我们可以为它创建一个虚拟财产，但是让我们把它添加到我们已经有的<code class="du lw lx ly lm b">initData()</code>中间件中。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="d218" class="lq kf hi lm b fi lr ls l lt lu">// modules/blog/blog-post/blog-post.hooks.ts</span><span id="22a0" class="lq kf hi lm b fi lv ls l lt lu">import R from 'ramda';<br/>...</span><span id="770f" class="lq kf hi lm b fi lv ls l lt lu">export default (<br/>  { gstore }: Context,<br/>  { images, utils }: Modules<br/>) =&gt; {<br/>  /**<br/>   * Initialize the entityData before saving it in the Datastore<br/>   */<br/>  function initEntityData(): Promise&lt;any&gt; {<br/>    /**<br/>     * Reminder: "compose" execute the functions from right --&gt; left<br/>     */<br/>    this.entityData = R.compose(<br/>      createExcerpt,<br/>      addCloudStorageData<br/>    )(this.entityData);</span><span id="faf3" class="lq kf hi lm b fi lv ls l lt lu">    return Promise.resolve();<br/>  }</span><span id="b64c" class="lq kf hi lm b fi lv ls l lt lu">  function addCloudStorageData(entityData: any) { ... }</span><span id="18bb" class="lq kf hi lm b fi lv ls l lt lu">  /**<br/>   * Generate the excerpt from the "content" value<br/>   */<br/>  function createExcerpt(entityData: any) {<br/>    return {<br/>      ...entityData,<br/>      excerpt: utils.string.createExcerpt(entityData.content)<br/>    };<br/>  }</span><span id="7ff5" class="lq kf hi lm b fi lv ls l lt lu">  ...<br/>};</span></pre><p id="61a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<a class="ae jo" href="https://www.npmjs.com/package/ramda" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> Ramda </em> </a> <code class="du lw lx ly lm b">compose()</code>方法来链接我们的实体数据初始化。我承认仅仅为了这个增加一个新的依赖是多余的…但是我想增加一点函数式编程来结束这个教程！:)继续创建一个新帖子，现在你应该有一个你的帖子的简短摘录出现在主页上。</p><p id="6cc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们的申请完成了！感谢阅读，我希望我没有失去你，如果你有任何问题，请在评论中联系我。<br/>这是我的第一篇长篇教程，我必须承认，在需要解释的内容和不需要解释的内容之间找到恰当的平衡并不容易:)我希望我成功地让你对尝试在Google App Engine上构建自己的Node.js应用程序并使用数据存储来存储你的内容感到兴奋。</p><p id="7730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要做的最后一件事是<strong class="is hj">在</strong> <a class="ae jo" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">谷歌云</strong> </a> <strong class="is hj">上部署我们的应用程序，并让它对我们的用户可用。</strong></p><p id="8e17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在本教程的下一个也是最后一个部分中完成<a class="ae jo" rel="noopener" href="/@sebelga/build-a-node-js-app-on-google-datastore-deploy-to-google-cloud-part-8-e72a8eaed9f7">，让我们开始吧！</a></p></div></div>    
</body>
</html>