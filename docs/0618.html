<html>
<head>
<title>Kubernetes container debugging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes容器调试</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-container-debugging-a2b87f4ff145?source=collection_archive---------0-----------------------#2018-05-25">https://medium.com/google-cloud/kubernetes-container-debugging-a2b87f4ff145?source=collection_archive---------0-----------------------#2018-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="afbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一大堆容器指南(为了方便起见大多被忽略了)同样适用于Kubernetes。我需要在<a class="ae jd" href="https://www.google.com/search?q=don%27t+run+containers+as+root" rel="noopener ugc nofollow" target="_blank">中做得更好，不作为根</a>运行容器，但是我在运行(<a class="ae jd" href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html" rel="noopener ugc nofollow" target="_blank">哑-init </a>和)每个容器一个过程中做得不错(尤其是对于Golang)。</p><p id="e057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，当我在开发Deployments时，这些方法经常不能在第一次使用。那么如何调试这些问题呢？</p><p id="3018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等等，如果它是一个在本地工作的容器，难道不能保证它在任何地方都能工作吗？是的，但是…没有集装箱是一个岛…或者…它的工作，直到我试图除以零…</p><p id="a00e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题在于运行的容器(像函数一样)依赖于运行时配置(数据)，这在不同的环境中有不同的表现。</p><p id="e7a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，问题是，对于所讨论的容器，包含符号链接的卷引用(当前)不起作用。当在Docker下本地部署容器时，这种情况没有出现，因为使用了简单的文件-文件主机卷装载。</p><p id="9bcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当部署到Kubernetes时，使用大量的Secrets(包含钱包文件)，问题浮出水面。这是因为Secrets(和ConfigMaps)使用符号链接呈现文件。机密或配置地图提供了向Kubernetes上的容器(pod)呈现基于文件的内容的最佳实践。</p><h2 id="b02c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">直通式</h2><p id="ad79" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我将使用最近的一个例子<a class="ae jd" rel="noopener" href="/google-cloud/ethereum-on-google-cloud-platform-8f10c82493ca"/>将Ethereum部署到Kubernetes。这是一个包含第三方容器的实际例子(我认为这是一个潜在的问题)。</p><p id="3c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我花了一些时间来确定问题，因为在本地运行容器(！)没有提出问题。</p><p id="b310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提供这些命令是为了显示“工作”并帮助解释问题。您不需要自己运行这些命令。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="bf43" class="je jf hi kj b fi kn ko l kp kq">mkdir -p /tmp/keystore</span></pre><p id="385e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将起作用:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="ca57" class="je jf hi kj b fi kn ko l kp kq">docker run \<br/>--rm \<br/>--interactive \<br/>--tty \<br/>--volume=/tmp/keystore:/keystore \<br/>ethereum/client-go \<br/>  --rinkeby<br/>  --keystore=/keystore<br/>  console</span></pre><p id="d786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它运行<code class="du kr ks kt kj b"><a class="ae jd" href="https://github.com/ethereum/go-ethereum/wiki/geth" rel="noopener ugc nofollow" target="_blank">geth</a></code>——最终的以太网Golang实现——作为“rinkeby”网络上的测试节点*使用* <code class="du kr ks kt kj b">/keystore</code>存储钱包文件。主机目录<code class="du kr ks kt kj b">/tmp/keystore</code>在容器上映射为<code class="du kr ks kt kj b">/keystore</code>。</p><p id="4eaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该容器产生大量日志记录，但是在那里的某个地方会有一个控制台，我们可以在<code class="du kr ks kt kj b">/keystore</code>目录中创建一个新的持久化为钱包文件的Ethereum帐户:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="dccf" class="je jf hi kj b fi kn ko l kp kq">&gt; personal<br/>{<br/>  listAccounts: [],<br/>  listWallets: [],...</span><span id="169e" class="je jf hi kj b fi ku ko l kp kq">&gt; personal.newAccount("some-random-password")<br/>"0x208507fd69e7ccf2af33f1ddc55e2738751c9aad"<br/>&gt; personal<br/>{<br/>  listAccounts: ["0x208507fd69e7ccf2af33f1ddc55e2738751c9aad"],<br/>  listWallets: [{<br/>      accounts: [{...}],<br/>      status: "Locked",<br/>      url: "keystore:///keystore/UTC--2018-05-25T16-32-28.467584997Z--208507fd69e7ccf2af33f1ddc55e2738751c9aad"<br/>  }],</span></pre><blockquote class="kv kw kx"><p id="ffd9" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>以太坊账号开始<code class="du kr ks kt kj b">0x2085</code>。它存储在一个格式为<code class="du kr ks kt kj b">UTC — [[data-created]] — [[account]</code>的钱包文件中。</p></blockquote><p id="02d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">退出容器后，钱包就在<code class="du kr ks kt kj b">/tmp/keystore/</code>创建了。更重要的是，因为这是在主机文件系统上持久化的，所以如果我使用相同的卷装载重新运行容器，帐户仍然是:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="5955" class="je jf hi kj b fi kn ko l kp kq">ls /tmp/keystore/<br/>UTC--2018-05-25T16-32-28.467584997Z--208507fd69e7ccf2af33f1ddc55e2738751c9aad</span></pre><p id="2394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的。简单明了，没有问题。</p><p id="8af9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我将向您展示这个错误。我是在将这个工作配置部署到Kubernetes之后才发现这个错误的。我花了一些时间才意识到这个问题，这不是Kubernetes的问题，并在没有Kubernetes的情况下创建了这个repro。</p><p id="ed7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码在目录<code class="du kr ks kt kj b">/tmp/lnkeystore</code>中创建了一个符号链接(同名),指向<code class="du kr ks kt kj b">/tmp/keystore</code>目录中的底层文件。除了不同的目录名之外，这两个wallet文件之间的唯一区别是我们创建了一个文件，它是指向已知工作的wallet文件的符号链接:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="f7cd" class="je jf hi kj b fi kn ko l kp kq">ACCOUNT="208507fd69e7ccf2af33f1ddc55e2738751c9aad"<br/>WALLET="UTC--2018-05-25T16-32-28.467584997Z--${ACCOUNT}"</span><span id="541e" class="je jf hi kj b fi ku ko l kp kq">mkdir -p /tmp/lnkeystore<br/>ln -s \<br/>  /tmp/keystore/${WALLET} \<br/>  /tmp/lnkeystore</span></pre><p id="5fb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果我现在使用<code class="du kr ks kt kj b">/tmp/<strong class="ih hj">ln</strong>keystore</code>而不是<code class="du kr ks kt kj b">/tmp/keystore</code>来运行容器，那么容器中将不会出现帐户。这是因为出现了一个错误，即如果wallet文件是一个符号链接，容器无法识别它:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="bf4e" class="je jf hi kj b fi kn ko l kp kq">docker run \<br/>--rm \<br/>--interactive \<br/>--tty \--volume=/tmp/lnkeystore:/keystore \<br/>ethereum/client-go \<br/>  --rinkeby<br/>  --keystore=/keystore<br/>  console</span></pre><blockquote class="kv kw kx"><p id="e372" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>唯一的变化在<code class="du kr ks kt kj b"> — volume=/tmp/lnkeystore</code>。</p></blockquote><p id="1fc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且，如果我在容器中运行personal，我希望帐户(和钱包)存在，但是容器看不到它们:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="4e70" class="je jf hi kj b fi kn ko l kp kq">&gt; personal<br/>{<br/>  listAccounts: [],<br/>  listWallets: [],</span></pre><h2 id="8393" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">Kubernetes调试</h2><p id="143a" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">那么，我是如何在Kubernetes中发现这个问题的，又是如何调试的呢？</p><p id="40f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现的问题如上所述:如果以太坊钱包文件是一个符号链接，帐户不会被发现。部署到Kubernetes后，我希望能够重用现有的帐户和钱包。但是，这不起作用。部署没有找到我的帐户(钱包)。</p><p id="cdd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用第三方容器映像(<code class="du kr ks kt kj b">ethereum/client-go</code>)不鼓励(但不阻止)使用或更改容器映像来调试|修复问题。将容器映像更改为debug是一种常见的方法，也很有帮助。在这种情况下，映像使用了<a class="ae jd" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> Alpine </a>，Alpine提供了一个最小的操作系统，我们可以使用它来调查问题。我将简要介绍这种方法。</p><p id="d900" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是<code class="du kr ks kt kj b">ethereum/client-go</code>的简介。您可以看到，方便发布的<code class="du kr ks kt kj b">Dockerfile</code>显示运行时映像是从Alpine构建的:</p><p id="d91f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://hub.docker.com/r/ethereum/client-go/~/dockerfile/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/ethereum/client-go/~/dockerfile/</a></p><p id="84f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，最好不要包含操作系统(甚至不要像Alpine那样受限制),而只包含我们想要运行的进程(可能与dump-init结合使用)。在这种情况下我们能做什么？这个问题没有正式的解决方案，但是有一个很好的方法。我也将展示这种方法。</p><h2 id="f5e7" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">包含调试工具的容器</h2><p id="9df4" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">如果您想要调试的容器包括一个shell和一些调试工具，那么这个过程会更容易。如果更简单为什么不是所有的图片都包括这些？</p><p id="e3b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">做好一件事的原则鼓励我们不要包含我们*可能*需要的组件，而是专注于我们必须拥有的组件。更多的组件还会导致更大的攻击面，并需要更多的维护。</p><p id="b7c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，确定您的容器中有什么shell和工具。如果你创造了这个形象，你就会知道这一点。如果你使用的是第三方图片，作者通常会记录配套图片<code class="du kr ks kt kj b">Dockerfile</code>。</p><p id="053e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们这里使用的例子中，我们知道(从上面)我们有阿尔卑斯山。Alpine的shell叫做<code class="du kr ks kt kj b">ash</code>，它包含了一系列我们可以使用的Linux命令行工具。</p><p id="07f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，确定你的吊舱。在Kubernetes豆荚聚合容器中。多(！)的时候，pod运行单个容器。以下内容适用于我的以太坊部署，但我会边走边解释。</p><p id="1b9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有一个名为“以太坊”的名称空间，并且我有一个部署，它导致一个单独的Pod运行一个名为“以太坊”的容器:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a335" class="je jf hi kj b fi kn ko l kp kq">kubectl get pods --namespace=ethereum<br/>NAME                        READY     STATUS    RESTARTS   AGE<br/>ethereum-7f967cbbb4-ch22q   2/2       Running   0          9m</span></pre><p id="7595" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要(Pod)名称:<code class="du kr ks kt kj b">ethereum-7f967cbbb4-ch22q</code></p><p id="3bbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我知道(因为是我创建的)Pod包含一个容器，该容器的名称也是<code class="du kr ks kt kj b">ethereum</code>。我们知道它正在运行<code class="du kr ks kt kj b">ash</code>，因此我们可以:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="e14e" class="je jf hi kj b fi kn ko l kp kq">kubectl exec ethereum-7f967cbbb4-ch22q \<br/>--stdin \<br/>--tty \<br/>--container=ethereum \<br/>--namespace=ethereum \<br/>-- ash</span></pre><p id="3fbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将返回一个shell提示符，因此——如下所示——可以列出名为<code class="du kr ks kt kj b">/keystore</code>的卷挂载的内容:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="e5b7" class="je jf hi kj b fi kn ko l kp kq">/ #<br/>/ # ls /keystore<br/>UTC--2018-05-25T16-32-28.467584997Z--208507fd69e7ccf2af33f1ddc55e2738751c9aad</span></pre><p id="7dab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且，我们知道我们也应该在这个容器中运行一个<code class="du kr ks kt kj b">geth</code>进程:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="7b3b" class="je jf hi kj b fi kn ko l kp kq">/ # ps aux<br/>PID   USER     TIME   COMMAND<br/>    1 root       0:47 geth --rinkeby --keystore=/cache ...<br/>   23 root       0:00 ash<br/>   30 root       0:00 ps aux</span></pre><p id="0b79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这是有用的。</p><p id="8a38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且，仍然在shell中，您可以通过下面的代码获得一个针对该<code class="du kr ks kt kj b">geth</code>进程的控制台:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c5b6" class="je jf hi kj b fi kn ko l kp kq">/ # geth attach <a class="ae jd" href="http://localhost:8545" rel="noopener ugc nofollow" target="_blank">http://localhost:8545</a> console<br/>Welcome to the Geth JavaScript console!</span><span id="8339" class="je jf hi kj b fi ku ko l kp kq">instance: Geth/v1.8.9-unstable-d6ed2f67/linux-amd64/go1.10.2<br/>coinbase: 0x3df64eff7ae6bde185de128a97bc0a9539427453<br/>at block: 2346567 (Fri, 25 May 2018 17:16:13 UTC)<br/> modules: eth:1.0 net:1.0 personal:1.0 rpc:1.0 web3:1.0</span><span id="450a" class="je jf hi kj b fi ku ko l kp kq">&gt; personal<br/>{<br/>  listAccounts: [],<br/>  listWallets: [],...</span></pre><p id="44fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的错误:-(</p><p id="d7cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决该问题后，相同的行为将再次出现:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="43a7" class="je jf hi kj b fi kn ko l kp kq">/ # geth attach <a class="ae jd" href="http://localhost:8545" rel="noopener ugc nofollow" target="_blank">http://localhost:8545</a> console<br/>Welcome to the Geth JavaScript console!</span><span id="47e4" class="je jf hi kj b fi ku ko l kp kq">instance: Geth/v1.8.9-unstable-d6ed2f67/linux-amd64/go1.10.2<br/>coinbase: 0x3df64eff7ae6bde185de128a97bc0a9539427453<br/>at block: 2346567 (Fri, 25 May 2018 17:16:13 UTC)<br/> modules: eth:1.0 net:1.0 personal:1.0 rpc:1.0 web3:1.0</span><span id="3b1a" class="je jf hi kj b fi ku ko l kp kq">&gt; personal<br/>{<br/>  listAccounts: ["0x208507fd69e7ccf2af33f1ddc55e2738751c9aad"],<br/>  listWallets: [{<br/>      accounts: [{...}],<br/>      status: "Locked",<br/>      url: "keystore:///cache/UTC--2018-05-25T16-32-28.467584997Z--208507fd69e7ccf2af33f1ddc55e2738751c9aad"<br/>  }],<br/>  deriveAccount: function(),</span></pre><blockquote class="kv kw kx"><p id="2304" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong></p></blockquote><p id="7417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的容器有外壳和/或调试工具，这种方法就很好。</p><p id="6626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，它应该变得越来越不常见，因为它打破了良好容器形象设计的一个(或多个)原则。所以…</p><h2 id="7942" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">不包含调试工具的容器</h2><p id="75f2" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">这种方法允许我们保持我们的容器最小，但是如果我们需要的话，可以运行sidecar调试容器。我认为这是一个很好的妥协。</p><p id="9639" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说清楚一点，我建议你不要一直开边车。这可能会成为一件事，但照现在的情况看，这落入了上述陷阱。黑客(！)是在需要时*只*部署调试容器。</p><p id="47a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是对于Kubernetes，这就更棘手了，因为您需要注射(！？)将调试容器放入您要调试的容器旁边的Pod中。</p><p id="11bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">救援部署。</p><p id="e7ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该使用部署将资源部署到Kubernetes。您应该使用规范文件来描述这些部署。如果需要，您可以*始终*为任何Kubernetes资源创建一个规格文件:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a739" class="je jf hi kj b fi kn ko l kp kq">kubectl get [RESOURCE]/[NAME] --namespace=[NAMESPACE] --output=yaml</span></pre><p id="d913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，给定表单的部署:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="28e3" class="je jf hi kj b fi kn ko l kp kq">kind: Deployment<br/>...<br/>spec:<br/>  containers:<br/>  - name: x<br/>    ...<br/>  - name: y<br/>    ...</span></pre><p id="27b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以(！)将其编辑为如下所示，然后应用:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a147" class="je jf hi kj b fi kn ko l kp kq">kind: Deployment<br/>...<br/>spec:<br/>  containers:<br/>  - name: x<br/>    ...<br/>  - name: y<br/>    ...<br/>  - name: debug<br/>    image: alpine<br/>    command: ["ash","-c","[[MY DEBUGGING COMMANDS]]"]</span></pre><blockquote class="kv kw kx"><p id="d5bb" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>您并不限于使用高山。因为您指定了容器图像，所以您可以使用您想要的图像:<code class="du kr ks kt kj b">ubuntu</code>、<code class="du kr ks kt kj b">busybox</code>、<code class="du kr ks kt kj b">most-excellent-debugging — tools</code>等。</p></blockquote><p id="64cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有什么用？它向Pod添加了另一个名为<code class="du kr ks kt kj b">debug</code>的容器，运行一些预定义的调试命令|脚本。</p><p id="e2fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您事先不知道您想要什么调试命令，那么您可以使用第二个技巧，即让调试容器保持忙碌-无所事事:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="1630" class="je jf hi kj b fi kn ko l kp kq">kind: Deployment<br/>...<br/>spec:<br/>  containers:<br/>  - name: x<br/>    ...<br/>  - name: y<br/>    ...<br/>  - name: debug<br/>    image: alpine<br/>    command: ["ash","-c","while true; do sleep 60s; done"]</span></pre><p id="0623" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这避免了调试容器终止，这将导致Kubernetes焦虑，因为它一直试图重新创建该容器；-)它会产生一个Pod，其中包含一个名为<code class="du kr ks kt kj b">debug</code>的容器，您可以将<code class="du kr ks kt kj b">kubectl exec</code>放入其中进行调试。</p><p id="6c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在这里看到<code class="du kr ks kt kj b">debug</code>在我的以太网部署中运行。在屏幕截图的底部“Containers”下是一个名为“debug”的容器，来自“alpine”图像:</p><figure class="ke kf kg kh fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lc"><img src="../Images/a981a5675e90fdf84c366b4bb0649c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3FTml_8-cp5r_klzqlTAw.png"/></div></div></figure><p id="f7ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以像以前一样访问此容器:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="cdac" class="je jf hi kj b fi kn ko l kp kq">kubectl exec ethereum-7f967cbbb4-ch22q \<br/>--stdin \<br/>--tty \<br/>--container=ethereum \<br/>--namespace=ethereum \<br/>-- ash</span></pre><p id="9a20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果——就像我的情况一样——您需要访问正在调试的容器正在使用的卷装载，您只需要在调试容器上复制卷装载:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="1c04" class="je jf hi kj b fi kn ko l kp kq">containers:<br/>- name: debug<br/>  image: alpine<br/>  command: ["ash","-c","while true; do sleep 60s; done"]<br/>  volumeMounts:<br/>  - name: keystore<br/>    mountPath: /keystore<br/>  - name: cache<br/>    mountPath: /cache      <br/>- name: ethereum<br/>  image: ethereum/client-go<br/>  args: [...]<br/>   volumeMounts:<br/>   - name: datadir<br/>     mountPath: /datadir<br/>   - name: keystore<br/>     mountPath: /keystore<br/>   - name: cache<br/>     mountPath: /cache<br/>volumes:<br/>- name: datadir<br/>  persistentVolumeClaim:<br/>  claimName: datadir<br/>- name: keystore<br/>  secret:<br/>    secretName: keystore<br/>- name: cach<br/>  emptyDir: {}</span></pre><p id="3597" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在概念上，Kubernetes <code class="du kr ks kt kj b">Pod</code>类似于<code class="du kr ks kt kj b">localhost</code>。并且，为<code class="du kr ks kt kj b">Pod</code>定义的任何体积(在这种情况下)都可以安装到它的任何容器中。太棒了。所以这对我们来说非常合适。</p><p id="75ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调试完问题后，通过删除调试容器恢复部署规范，并将部署重新应用于您的集群。</p><p id="eae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是(新的)豆荚。Kubernetes用新的部署删除了以前的Pod。这不再容纳<code class="du kr ks kt kj b">debug</code>容器:</p><figure class="ke kf kg kh fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lk"><img src="../Images/14ab360015ac13f0dfba304c2033af8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbHUi0Um4DXgFPJZ0uJkig.png"/></div></div></figure><h2 id="a652" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">解决问题</h2><p id="25ae" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">完成调试示例后，我对部署无法工作感到困惑。当使用Secrets部署到Kubernetes时，我很快确定我无法访问以太坊帐户(和钱包)。</p><p id="ad2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我尝试使用配置图而不是密码。同样的问题。这是因为ConfigMaps和Secrets都将卷装入的文件显示为符号链接。他们这样做是为了提供Kubernetes所需要的活力。所以链接的使用是不可避免的。</p><p id="0c1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个办法是创建一个持久磁盘，并将这个“旧学校”连接到Pod。出于多种原因，这是一个糟糕的选择。首先，它需要手动创建、格式化、安装等。磁盘的。第二，持久磁盘现在才成为<a class="ae jd" href="https://cloudplatform.googleblog.com/2018/05/Get-higher-availability-with-Regional-Persistent-Disks-on-Google-Kubernetes-Engine.html" rel="noopener ugc nofollow" target="_blank">区域</a>(然后只有2个副本；这降低了Kubernetes在将基于区域的磁盘绑定到区域浮动单元时的灵活性，尤其是对于区域集群。</p><p id="2254" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">永恒之盘作品:-(</p><p id="74e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它能工作是因为我复制进去的钱包文件不是符号链接。</p><p id="39d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我创造了我已经添加到我的原始职位的黑客技巧。Kubernetes支持名为<code class="du kr ks kt kj b"><a class="ae jd" href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir" rel="noopener ugc nofollow" target="_blank">emptyDir</a></code>的动态卷类型。我想知道，如果我把动态管理账户(钱包)从秘密复制到T1会发生什么？我还会有一个文件-文件(不是链接)吗？这个管用！</p><p id="9494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这是一个破解和变通办法，但是我现在使用一个init容器将钱包文件从Secret复制到一个<code class="du kr ks kt kj b">emptyDir</code>*在*以太坊容器启动之前。以太坊容器被配置为在<code class="du kr ks kt kj b">emtpyDir</code>卷而不是秘密卷中寻找钱包。</p><p id="dffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切都很好。</p><h2 id="e97e" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">旁白:容器优化的操作系统</h2><p id="c04b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">谷歌的容器优化操作系统(COS)采用了类似的原理。COS是一个极简操作系统(！).这带来的一个挑战是，如果您将一个基本容器部署到COS，您没有任何工具可以帮助调试。</p><p id="4a3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">COS提供<a class="ae jd" href="https://github.com/coreos/toolbox" rel="noopener ugc nofollow" target="_blank"> CoreOS工具箱</a>:</p><p id="dfb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/container-optimized-os/docs/how-to/toolbox" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/container-optimized-OS/docs/how-to/toolbox</a></p><p id="339a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CoreOS没有为toolbox发布容器图像，但谷歌确实提供了一个图像(通过<a class="ae jd" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册表</a>【GCR】)，它还包括<a class="ae jd" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank">谷歌云SDK </a>(又名<code class="du kr ks kt kj b">gcloud</code>)。</p><p id="1da0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google的CoreOS工具箱图片是:<code class="du kr ks kt kj b">gcr.io/google-containers/toolbox</code></p><p id="ce99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以——如果你愿意——在前面描述的Kubernetes调试中利用CoreOS工具箱，只需引用GCR映像并将<code class="du kr ks kt kj b">ash</code>替换为<code class="du kr ks kt kj b">bash</code>:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="f751" class="je jf hi kj b fi kn ko l kp kq">kind: Deployment<br/>...<br/>spec:<br/>  containers:<br/>  - name: x<br/>    ...<br/>  - name: y<br/>    ...<br/>  - name: debug<br/>    image: gcr.io/google-containers/toolbox<br/>    command: ["bash","-c","while true; do sleep 60s; done"]</span></pre><p id="0cd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随时欢迎反馈。</p><p id="0198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p></div></div>    
</body>
</html>