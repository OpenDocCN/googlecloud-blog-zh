<html>
<head>
<title>Troubleshooting services on GKE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GKE的故障排除服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/troubleshooting-services-on-gke-872470e60d51?source=collection_archive---------1-----------------------#2020-11-03">https://medium.com/google-cloud/troubleshooting-services-on-gke-872470e60d51?source=collection_archive---------1-----------------------#2020-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ad4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇<a class="ae jd" rel="noopener" href="/google-cloud/setting-up-cloud-operations-for-gke-a21b49979693">帖子</a>中，我回顾了新的GKE监控仪表板，并使用它快速找到了感兴趣的GKE实体。在那里，我使用实体细节窗格中上下文相关的“创建警报策略”链接设置了一个关于容器重启的警报。这一次，我想尝试使用这个设置来解决一个事件。</p><h1 id="83f0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">设置</h1><h2 id="1a19" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">该应用程序</h2><p id="128e" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">你可以在这里看到我为测试这个<a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/blob/master/crashing-pod-demo/main.go" rel="noopener ugc nofollow" target="_blank">而创建的简单演示应用的完整代码。基本思想是它公开了两个端点——一个是/ endpoint，它只是一个“hello world”，一个是/crashme端点，它使用Go的os。退出(1)以终止该过程。然后，我使用云构建创建了一个容器映像，并将它部署到GKE。最后，我用负载平衡器公开了服务。</a></p><p id="886e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署服务后，我检查了正在运行的pod:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="92ad" class="kc jf hi la b fi le lf l lg lh">✗ kubectl get pods</span><span id="9bbe" class="kc jf hi la b fi li lf l lg lh">NAME READY STATUS RESTARTS AGE</span><span id="d56b" class="kc jf hi la b fi li lf l lg lh">restarting-deployment-54c8678f79-gjh2v 1/1 Running 0 6m38s</span><span id="dcd4" class="kc jf hi la b fi li lf l lg lh">restarting-deployment-54c8678f79-l8tsm 1/1 Running 0 6m38s</span><span id="0cbf" class="kc jf hi la b fi li lf l lg lh">restarting-deployment-54c8678f79-qjrcb 1/1 Running 0 6m38s</span></pre><p id="4f9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，最初每个pod的重新启动次数为零。当我点击/crashme端点时，我看到了一个重启:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="de0c" class="kc jf hi la b fi le lf l lg lh">✗ kubectl get pods</span><span id="dc81" class="kc jf hi la b fi li lf l lg lh">NAME READY STATUS RESTARTS AGE</span><span id="7595" class="kc jf hi la b fi li lf l lg lh">restarting-deployment-54c8678f79-gjh2v 1/1 Running 1 9m28s</span><span id="c4b6" class="kc jf hi la b fi li lf l lg lh">restarting-deployment-54c8678f79-l8tsm 1/1 Running 0 9m28s</span><span id="bf36" class="kc jf hi la b fi li lf l lg lh">restarting-deployment-54c8678f79-qjrcb 1/1 Running 0 9m28s</span></pre><p id="273b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我能够确认对端点的每个请求都会导致重启。然而，我必须小心不要太频繁地这样做——否则，容器会进入CrashLoopBackOff，并且服务再次可用需要时间。我最终在我的shell (zsh)中使用了这个简单的循环来在需要的时候触发重启:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="efae" class="kc jf hi la b fi le lf l lg lh">while true;</span><span id="5ff0" class="kc jf hi la b fi li lf l lg lh">  do</span><span id="8035" class="kc jf hi la b fi li lf l lg lh">    curl <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/$IP_ADDRESS/crashme;">http://$IP_ADDRESS:8080/crashme;</a></span><span id="15d5" class="kc jf hi la b fi li lf l lg lh">    sleep 45;</span><span id="5d42" class="kc jf hi la b fi li lf l lg lh">done</span></pre><h1 id="fa71" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">警报</h1><p id="a9d3" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">下一步是设置警报策略。我是这样配置的:</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/803735eacc07ccf8911b2f17434bfa9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fAyZ52ZY7BeZTsFE"/></div></div></figure><p id="a1e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了<code class="du lr ls lt la b">kubernetes.io/container/restart_count</code>指标，过滤到特定的容器名称(如部署yaml <a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/blob/master/crashing-pod-demo/deployment.yaml" rel="noopener ugc nofollow" target="_blank">文件</a>中所指定的)，并配置了如果任何时间序列超过0就触发警报——这意味着如果观察到任何容器重启。</p><p id="0cab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置完成了——我现在准备测试，看看会发生什么！</p><h1 id="9ccd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">测试警报</h1><p id="110b" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">当我准备好了，我开始循环脚本，每45秒到达/crashme端点。<code class="du lr ls lt la b">restart_count</code>指标每60秒采样一次，所以仪表板上很快就出现了一个警报:</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/b672d8f9e99ec8708f3cc061202ce123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_dpFfJripTmqLyUF"/></div></div></figure><p id="9cea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将鼠标移至事件上方，以获取更多相关信息:</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/84f47bc979a0cf99c2431d0c047eccb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ihUXko2bUA2bYiRy"/></div></div></figure><p id="5bac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这已经比以前版本的UI有所改进，在以前的版本中，我不能与事件卡片进行交互。</p><p id="5f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我点击“查看事件”。这将我带到事件详细信息屏幕，在那里我可以看到触发它的特定资源。在我的例子中，它指向容器:</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lu"><img src="../Images/9e1602688e34a238db5ee7b6a3dcd7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7qrFVXGuwWPnmZtn"/></div></div></figure><p id="dbc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我点击查看日志来查看日志(在新的日志查看器中！)—果然，很明显，警报是由容器重启触发的:</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/d345fac4b052a68946cd11054c8d44de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xU_egFlXUVEabSFw"/></div></div></figure><p id="43ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些都很好地结合在一起，使事故期间的故障排除更加容易！</p><h1 id="6511" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">总之…</h1><p id="86ec" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我是新的GKE仪表板的忠实粉丝，我真的很喜欢新的警报时间线，我喜欢事件被清楚地标记出来，并且我可以实际上与它们进行交互，以获得所发生事情的完整细节，一直到告诉我实际问题的容器日志。</p><p id="309d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读，欢迎再次光临。像往常一样，请让我知道你还想看到我做什么SRE或可观察性的话题。现在比以往任何时候都更需要保持健康！</p></div></div>    
</body>
</html>