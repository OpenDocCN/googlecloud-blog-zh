<html>
<head>
<title>Benchmark Spanner Change Watcher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基准扳手变化观察器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/benchmark-spanner-change-watcher-e5b6cc2ac618?source=collection_archive---------2-----------------------#2021-04-13">https://medium.com/google-cloud/benchmark-spanner-change-watcher-e5b6cc2ac618?source=collection_archive---------2-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4dfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud Spanner Change Watcher是Google Cloud Spanner的一个<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher" rel="noopener ugc nofollow" target="_blank">开源库</a>，用于观察和发布来自云Spanner数据库的变化。本文中的示例需要1.1.0或更高版本的扳手变化观察器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/5ea3e6661905a239ecd25ee94bea5a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*iNlSTFEy1xpftvwji_PIXA.png"/></div></figure><p id="2569" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该库附带了一个样例基准测试应用程序，可以用来为一个更改观察器尝试不同的配置，以测试相应的性能和负载。基准应用程序使用一个带有辅助索引的示例表，为了简单起见，这两个表都是由基准应用程序自动创建的。<a class="ae jd" rel="noopener" href="/@knutolavloite/scaling-up-spanner-change-watcher-82315fbc8962">表格和二级索引与本文</a>中推荐的设置相对应，建议在继续阅读本文之前阅读文章中的<a class="ae jd" rel="noopener" href="/@knutolavloite/scaling-up-spanner-change-watcher-82315fbc8962">，以了解如何设置示例表格。</a></p><p id="db95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文展示了许多关于如何使用这个基准应用程序测试不同配置的例子。</p><h1 id="2cf8" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">运行基准应用程序</h1><p id="83b9" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">基准应用程序位于存储库中的<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/tree/master/samples/spanner-change-watcher-samples" rel="noopener ugc nofollow" target="_blank">spanner-change-watcher-samples</a>项目中，是一个随时可以运行的Java控制台应用程序。它有两个必需的命令行参数:</p><ul class=""><li id="17a3" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated"><code class="du ky kz la lb b">--instance: The Cloud Spanner instance to use</code></li><li id="3ea1" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc ku kv kw kx bi translated"><code class="du ky kz la lb b">--database: The Cloud Spanner database to use</code></li></ul><p id="2d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有其他参数都是可选的，可用于尝试不同的配置和写入负载。</p><p id="430b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果数据库、表和二级索引尚不存在，它们都将被自动创建。基准应用程序将在内部启动两个进程:</p><ol class=""><li id="7a93" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc lh kv kw kx bi translated">更新程序:更新程序将向数据表写入随机更改，以模拟表上的写负载。可以通过设置<code class="du ky kz la lb b">transactionsPerSecond</code>和<code class="du ky kz la lb b">mutationsPerTransaction</code>参数来配置更新器的写入负载。默认设置将使用每秒1个事务和每个事务5个突变的低写入吞吐量，平均每秒总共5个突变。</li><li id="3060" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">观察器:观察器将轮询数据表中由更新器写入的更改。观察器将计算它所看到的变化的数量，否则它不会对这些变化做任何事情。观察器的默认设置将等同于本文中<a class="ae jd" rel="noopener" href="/@knutolavloite/scaling-up-spanner-change-watcher-82315fbc8962">为大型表推荐的观察器设置。</a></li></ol><h2 id="e6ed" class="li jn hi bd jo lj lk ll js lm ln lo jw iq lp lq ka iu lr ls ke iy lt lu ki lv bi translated">使用Maven运行基准应用程序</h2><p id="fa45" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在本地开发机器上运行基准应用程序的最简单方法是使用Maven exec插件。在您的IDE中执行基准应用程序也是可能的，但不建议这样做，因为大多数IDE中的控制台支持有限。</p><p id="b892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航到<code class="du ky kz la lb b">spanner-change-watcher/samples/spanner-change-watcher-samples</code>目录并执行以下命令:</p><p id="b07a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">mvn exec:java -Dexec.args="-i my-instance -d watcher-benchmark-db"</code></p><p id="f3dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将使用云扳手实例“my-instance”和数据库“watcher-benchmark-db”启动基准测试应用程序，否则将使用默认选项。<strong class="ih hj">“我的实例”必须是现有实例。</strong></p><h1 id="89d5" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">基准应用程序输出</h1><p id="ebd1" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">使用默认设置运行基准应用程序应该会得到类似如下的输出:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lw"><img src="../Images/f229d97bee358b55c5aed7b4abb9e812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*Nv2oZUo7LBPRfTtKRzn7dA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">使用默认设置对应用程序输出进行基准测试</figcaption></figure><p id="b38d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面说出来的意思是:</p><ol class=""><li id="db42" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc lh kv kw kx bi translated">测试持续时间:基准测试运行的时间。</li><li id="9e8f" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated"># Transactions:应用程序到目前为止已经执行的写事务的数量。</li><li id="af9c" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated"># Mutations:应用程序到目前为止已经执行的突变总数。</li><li id="14b7" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated"># Received changes:到目前为止，观察器收到的更改总数。当您用一个新的数据库开始基准测试时，这个数字将等于或略小于已经执行的突变数。以后的运行可以显示接收到的变更数量比执行的突变数量多。如果在有尚未报告的突变时停止基准应用程序，就会发生这种情况。这些变化将在下一次基准运行时报告。</li><li id="e448" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">更改通知延迟:更改的提交时间戳和报告更改的时刻之间的秒数。</li><li id="98e7" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">Avg poll time last minute:数据库上的更改轮询查询持续的平均秒数。该值从<a class="ae jd" href="https://cloud.google.com/spanner/docs/introspection/query-statistics" rel="noopener ugc nofollow" target="_blank">SPANNER _ SYSQUERY _ STATS _ TOP _ MINUTE</a>表中读取。</li><li id="1a3a" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">Spanner CPU time last minute:一个由<strong class="ih hj">计算出的</strong>值，该值表示单个CPU的总可用时间占所有所需轮询查询总数的比例。该值计算为<code class="du ky kz la lb b">(avg_query_time * execution_count) / 60 seconds</code>。该值<strong class="ih hj">不一定等于云扳手</strong>上的实际CPU负载。</li></ol><h1 id="795e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">测试不同的配置</h1><p id="570e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">基准应用程序支持大量命令行参数，这些参数可用于尝试不同的观察器配置和写吞吐量。以下示例是在单节点区域云扳手实例上执行的。根据节点数和区域与多区域设置，您自己的设置结果可能会有所不同。</p><p id="edb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最重要的配置选项包括:</p><ol class=""><li id="d9f0" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc lh kv kw kx bi translated">transactionsPerSecond (w):应用程序平均每秒应该执行的随机写入事务的数量。将使用一个线程池来执行事务，该线程池将在平均与该配置中的数量相匹配的随机时间调度事务。</li><li id="6872" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">mutationsPerTransaction (m):每个事务平均将执行的变异数。每个事务的实际突变数量将在[1，2m]的范围内，平均值为m</li><li id="e8f9" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">numWatchers (n):要使用的不同观察器的数量。示例表包含一个分片列，该列包含37个不同的值。因此，最多可以使用37个不同的观察器，每个观察器观察一组单独的碎片值。默认配置将使用一个观察器来观察所有碎片，这对于大多数用例来说已经足够了。如果写吞吐量超过了单个观察器可以处理的最大更改数量，那么下一步最好使用多个观察器。单个观察器可以处理的数量变化将取决于您的Cloud Spanner实例中的节点数量。本例中的单个节点实例每秒可以处理大约3000到5000个突变。</li><li id="63cf" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">pollInterval (p):每次轮询查询之间的时间间隔。默认值为1秒。将该值设置为较高的时间间隔可以减少由观察器引起的Cloud Spanner实例的负载，因为将执行较少的轮询查询。</li><li id="fc17" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">limit (l):轮询查询在一次轮询中获取的最大更改数。默认值为10，000。如果轮询返回<limit>数量的更改，将在此轮询之后立即安排一个新的轮询查询，以获取下面的<limit>更改。将limit设置为较低的值，将poll interval设置为较高的值，这可能是一个很好的策略，可以为接收突发写的表获得更动态的轮询行为。例如，如果轮询间隔设置为10秒，限制为500，则该表将仅每10秒轮询一次，除非该表在10秒间隔内接收到超过500个突变。</limit></limit></li></ol><h2 id="12d0" class="li jn hi bd jo lj lk ll js lm ln lo jw iq lp lq ka iu lr ls ke iy lt lu ki lv bi translated">默认(推荐)配置</h2><p id="494e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">基准应用程序使用的<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/SpannerTableTailer.java" rel="noopener ugc nofollow" target="_blank"> SpannerTableTailer </a>的默认配置如下:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">默认表观察器配置</figcaption></figure><p id="477e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该配置与本文中描述的<a class="ae jd" rel="noopener" href="/@knutolavloite/scaling-up-spanner-change-watcher-82315fbc8962">推荐设置相对应。</a></p><p id="3955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下表显示了基准应用程序使用不同写入负载和观察器默认配置的结果。测试是针对已经包含1700万条记录的表执行的。轮询更改时是否需要使用辅助索引很大程度上取决于表中记录的总数。</p><pre class="jf jg jh ji fd md lb me mf aw mg bi"><span id="3d26" class="li jn hi lb b fi mh mi l mj mk">|  Load   | -w | -m  | -n |  -p  |   -l  |  Avg   | CPU | Latency |<br/>|---------|----|-----|----|------|-------|--------|-----|---------|<br/>| V light |  1 |   5 |  1 | PT1S | 10000 | 0.0085 | 0%  | 1 sec   |<br/>| Light   |  5 |  20 |  1 | PT1S | 10000 | 0.0191 | 1%  | 1 sec   |<br/>| Medium  | 10 |  50 |  1 | PT1S | 10000 | 0.0575 | 3%  | 1 sec   |<br/>| High    | 25 | 100 |  1 | PT1S | 10000 | 0.2912 | 12% | 2 sec   |<br/>| V high  | 50 | 200 |  1 | PT1S | 10000 | 2.1908 | 69% | *       |<br/>| V high  | 50 | 200 |  2 | PT1S | 10000 | 0.8298 | 42% | 5 sec   |<br/>| V high  | 50 | 200 |  4 | PT1S | 10000 | 0.2791 | 42% | 2 sec   |<br/>| V high  | 50 | 200 |  8 | PT1S | 10000 | 0.1355 | 48% | 1 sec   |</span></pre><p id="4ec9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前四个写加载场景可以由一个观察器处理(n = 1)。在单节点Cloud Spanner设置中，一个观察器无法处理每秒50个事务、每个事务写入200个突变、每秒总共10，000个突变的“极高”写入负载场景。单个观察器将开始越来越滞后于更新，并且等待时间将持续增加。添加第二个观察器就足以让场景工作，尽管平均延迟大约为5秒。添加更多的观察器将进一步减少延迟。</p><h2 id="9424" class="li jn hi bd jo lj lk ll js lm ln lo jw iq lp lq ka iu lr ls ke iy lt lu ki lv bi translated">禁用表提示/辅助索引</h2><p id="7e4f" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">前面的示例使用了基准应用程序的默认配置。这意味着表观察器将使用一个表提示，指示Cloud Spanner在查询时使用二级索引。如果我们删除这个表提示，Cloud Spanner将(在撰写本文时)默认不使用二级索引。这将对轮询查询的性能产生负面影响。确切的影响将取决于表中的行数。如果您用一个新创建的表进行测试，您将获得比让基准应用程序在高写负载下运行一段时间(例如<code class="du ky kz la lb b">-w 25 -m 100</code>)更好的结果。</p><p id="11b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">禁用表格提示的命令行参数是<code class="du ky kz la lb b">--disableTableHint</code>。</p><pre class="jf jg jh ji fd md lb me mf aw mg bi"><span id="c927" class="li jn hi lb b fi mh mi l mj mk">| Load  | -w | -m | -n |  -p  |  -l   |   Avg   | CPU  |  Latency  |<br/>|-------|----|----|----|------|-------|---------|------|-----------|<br/>| Light |  5 | 20 |  1 | PT1S | 10000 | 85.0711 | 283% | 30-60 sec |<br/>| Light |  5 | 20 |  2 | PT1S | 10000 | 80.8160 | 404% | 30-60 sec |<br/>| Light |  5 | 20 |  8 | PT1S | 10000 | 80.7088 | 929% | &gt; 60 sec  |<br/>| Light |  5 | 20 | 37 | PT1S | 10000 | 81.6249 | 910% | &gt; 60 sec  |</span></pre><p id="c8f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">禁用表提示将对表更改监视器的性能产生巨大影响。确切的值在很大程度上取决于被监视的表中现有的行数，因为轮询查询将使用全表扫描，而不是使用辅助索引。</p><h2 id="a48c" class="li jn hi bd jo lj lk ll js lm ln lo jw iq lp lq ka iu lr ls ke iy lt lu ki lv bi translated">禁用碎片提供程序</h2><p id="f20c" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们还可以禁用shard provider，它告诉观察器只观察shard列中值在-37和37之间的变化。这个shard提供者向轮询查询添加了一个<code class="du ky kz la lb b">WHERE ShardId IN (-37, -36, ..., 36, 37)</code>子句，这乍一看似乎是不必要的。然而，它确实使Cloud Spanner更有效地扫描二级索引成为可能，因为我们事先有效地告诉Cloud Spanner，它只需要查找这些特定的值。如果我们忽略这一点，Cloud Spanner在访问索引的每个不同部分之前，首先需要扫描索引中所有不同的碎片值。或者，Cloud Spanner将对整个索引进行全面扫描。</p><p id="66d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">禁用表格提示的命令行参数是<code class="du ky kz la lb b">--disableShardProvider</code>。请注意，只有当观察者的数量为1时，基准应用程序才允许您禁用shard provider。否则，您将有多个观察者观察表的同一个部分(being整个表)。仍然使用指示Cloud Spanner使用二级索引的表提示，由于它是一个空过滤索引，基准测试应用程序将向观察器添加一个<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/NotNullShardProvider.java" rel="noopener ugc nofollow" target="_blank"> NotNullShardProvider </a>。这个提供者只需在轮询查询中添加一个<code class="du ky kz la lb b">WHERE ShardId IS NOT NULL</code>子句。</p><pre class="jf jg jh ji fd md lb me mf aw mg bi"><span id="6b67" class="li jn hi lb b fi mh mi l mj mk">|  Load  | -w | -m  | -n |  -p  |  -l   |   Avg   | CPU  | Latency |<br/>|--------|----|-----|----|------|-------|---------|------|---------|<br/>| Light  |  5 |  20 |  1 | PT1S | 10000 | 14.0975 | 140% | 11 sec  |<br/>| Medium | 10 |  50 |  1 | PT1S | 10000 | 13.7384 | 160% | 10 sec  |<br/>| High   | 25 | 100 |  1 | PT1S | 10000 | 14.8597 | 173% | *       |</span></pre><p id="5b09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">观察器将能够跟上低和中等写入负载，但是高写入负载将淹没它。与使用指定每个可能碎片值的碎片提供者相比，在低和中等写入负载下的性能也要差得多。</p><p id="d8d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/NotNullShardProvider.java" rel="noopener ugc nofollow" target="_blank"> NotNullShardProvider </a>而不是ShardProvider来指定shard列中所有可能的值，在某些特定场景中仍然很有用:</p><ul class=""><li id="1cf9" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">如果shard列可以包含任意随机值，而不仅仅是一组特定的值。在这些情况下，使用NotNullShardProvider仍然比完全不使用ShardProvider要好。</li><li id="cea1" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc ku kv kw kx bi translated">如果您通过将commit timestamp设置为null来定期从辅助null筛选索引中删除较旧的项，NotNullShardProvider将会执行得非常好，因为所有不相关的条目都已经从索引中删除了。关于如何从一个空过滤的二级索引中删除旧条目的更多信息，请参见本文中的<a class="ae jd" rel="noopener" href="/@knutolavloite/scaling-up-spanner-change-watcher-82315fbc8962">相关章节。</a></li></ul><h2 id="1fe4" class="li jn hi bd jo lj lk ll js lm ln lo jw iq lp lq ka iu lr ls ke iy lt lu ki lv bi translated">增加轮询间隔</h2><p id="c6c7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">如果您的表没有接收到连续的写入流，而是接收到突发的写入流，那么设置更高的轮询间隔是有意义的。这将减少常规轮询查询的执行频率，从而降低数据库的总负载。每次轮询将总是获取所有可用的更改，而不管已配置的限制。该限制将仅决定在一个轮询查询中获取多少更改。如果一个查询返回<code class="du ky kz la lb b">limit</code>变更，将直接执行一个新的轮询查询来获取下一组变更。以下命令行参数显示了这一效果:</p><pre class="jf jg jh ji fd md lb me mf aw mg bi"><span id="1a24" class="li jn hi lb b fi mh mi l mj mk">&gt; mvn exec:java -Dexec.args=" \<br/>&gt; -i my-instance \<br/>&gt; -d my-database \<br/>&gt; -w 0.5 -m 500 -l 1000 -p PT10S"</span></pre><p id="a900" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更改监视器将每10秒执行一次轮询查询，最多允许1000次更改。如果查询返回1，000个更改，将立即执行新的轮询查询来获取剩余的更改。这将重复进行，直到轮询查询收到的更改少于1，000个。观察器将再等待10秒钟，然后再次轮询。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ml"><img src="../Images/e4c8b9de4893fbeb3be4343efa72f112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*esgBMXCXAo8-BQDxEGQIsw.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">每10秒轮询一次—更高的延迟，更低的负载</figcaption></figure><p id="c30b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将以变更通知延迟为代价，换取后端负载的减少。确切的差异将取决于表中写入的突发性。与下面的屏幕截图进行比较，该截图来自具有以下设置的运行:</p><pre class="jf jg jh ji fd md lb me mf aw mg bi"><span id="af2e" class="li jn hi lb b fi mh mi l mj mk">&gt; mvn exec:java -Dexec.args=" \<br/>&gt; -i my-instance \<br/>&gt; -d my-database \<br/>&gt; -w 0.5 -m 500 -l 10000 -p PT1S"</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ml"><img src="../Images/a8afefe120378e9aa64d018885aaf301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*p1WC1cT21kIyYYN-1zZiaQ.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">每1秒轮询一次—延迟更低，(稍微)负载更高</figcaption></figure><h1 id="3f60" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">结论</h1><p id="9583" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">扳手变化观察器的样本目录中的基准应用程序可用于结合不同的写入负载测试扳手表观察器的不同配置。基准应用程序中使用的默认配置是接收大量写操作的大型表的推荐设置。该设置包括:</p><ol class=""><li id="5843" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc lh kv kw kx bi translated">包含相对较小的一组固定值的(计算)分片列。示例表使用表中一些数据的散列的模19，这给出了范围[-18，18]内的一组固定碎片值。</li><li id="cba6" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">shard列和commit timestamp列上的(空筛选的)辅助索引。</li><li id="8422" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">一个FixedShardProvider，其数组<int64>包含范围[-18，18]内的所有值。</int64></li><li id="a9bc" class="kp kq hi ih b ii lc im ld iq le iu lf iy lg jc lh kv kw kx bi translated">强制使用上述第2点中的二级索引的表提示。</li></ol></div></div>    
</body>
</html>