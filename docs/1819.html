<html>
<head>
<title>Google Cloud Spanner: Stream Data from a Query to a Transaction in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Cloud Spanner:从查询到NodeJS中的事务的数据流</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-spanner-stream-data-from-a-query-to-a-transaction-in-nodejs-8572492b98be?source=collection_archive---------4-----------------------#2021-03-01">https://medium.com/google-cloud/google-cloud-spanner-stream-data-from-a-query-to-a-transaction-in-nodejs-8572492b98be?source=collection_archive---------4-----------------------#2021-03-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ee57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/spanner" rel="noopener ugc nofollow" target="_blank"> Google Cloud Spanner </a>是一个全面管理、可扩展的关系数据库服务，用于区域和全球应用数据。它是第一个可扩展的、企业级的、全球分布的、高度一致的数据库服务，专为云构建，将关系数据库结构的优势与非关系水平扩展相结合。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/5ea3e6661905a239ecd25ee94bea5a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*iNlSTFEy1xpftvwji_PIXA.png"/></div></figure><p id="5035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cloud Spanner中的查询可以使用<a class="ae jd" href="https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ExecuteStreamingSql" rel="noopener ugc nofollow" target="_blank">流RPC </a>来执行。<a class="ae jd" href="https://github.com/googleapis/nodejs-spanner" rel="noopener ugc nofollow" target="_blank"> NodeJS客户端库</a>使用这个流API以标准NodeJS流的形式返回查询结果。这些流可以通过管道与其他流一起将数据写入其他输出，如果写流比查询流慢，NodeJS会自动对读流施加反压力。这篇文章展示了如何在Cloud Spanner上将查询结果流式传输到读/写事务中，以便将(一些)查询数据写回Spanner。</p><p id="3bb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://googleapis.dev/nodejs/spanner/latest/Database.html#runTransaction" rel="noopener ugc nofollow" target="_blank"> Database#runTransaction </a>函数应用于在事务中向Cloud Spanner写入数据。然而，这不是一个流，NodeJS只会在读流通过管道进入另一个流时对其施加反压力。因此，我们需要实现自己的自定义流实现，将数据写入Spanner。参见<a class="ae jd" href="https://nodejs.org/docs/latest/api/stream.html#stream_implementing_a_writable_stream" rel="noopener ugc nofollow" target="_blank"> NodeJS文档</a>了解更多关于如何实现定制写流的背景信息。</p><h1 id="64f9" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">步骤1:每个事务写一行</h1><p id="e116" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们将从一个简单的实现开始，每个事务只写一行。为此，我们需要创建一个简单的Writable实现来覆盖<a class="ae jd" href="https://nodejs.org/docs/latest/api/stream.html#stream_writable_write_chunk_encoding_callback_1" rel="noopener ugc nofollow" target="_blank"> Writable。_编写</a>方法。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kp kq l"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">可写流，每个事务写一行</figcaption></figure><p id="3f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码示例将选择Singers表中的所有行，然后将所有这些行写回到同一个表中，有效地复制了表中的所有行。每一行都在单独的事务中写入。</p><p id="ea1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">NodeJS将对读流施加反压力，并保持较低的内存消耗，因为写流比读流慢得多。我们不需要为背压的发生实现任何自定义逻辑。</p><p id="fefd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确切的内存消耗将取决于正在读取的表的大小以及Cloud Spanner如何对查询结果进行分区。查询结果由一个<a class="ae jd" href="https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.PartialResultSet" rel="noopener ugc nofollow" target="_blank">PartialResultSet</a>流组成，内存使用量将至少与一个partial resultset的大小一样大。</p><h1 id="4b1c" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">步骤2:每个事务写多行</h1><p id="dd52" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">上面的例子是可行的，但是效率非常低。最好是将更多的行批处理在一起，并在一个事务中写入这些行，而不是启动一个单独的事务。这可以通过实现可写的<a class="ae jd" href="https://nodejs.org/docs/latest/api/stream.html#stream_writable_writev_chunks_callback" rel="noopener ugc nofollow" target="_blank">来实现。_writev </a>方法而不是可写的。_写。</p><p id="350a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们可以在传递给流构造函数的选项中设置一个<a class="ae jd" href="https://nodejs.org/docs/latest/api/stream.html#stream_new_stream_writable_options" rel="noopener ugc nofollow" target="_blank"> highWaterMark </a>。对于对象流，highWaterMark的默认值是16。这意味着在创建一个事务并将它们写在一起之前，我们的流最多只能缓冲16行。根据行的大小和可用内存，该值可以增加到更高的值。较高的值将确保较高的吞吐量，但会增加内存消耗。</p><p id="c36d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此示例使用200行的高水位线。这可以进一步增加，但必须保持在Cloud Spanner的<a class="ae jd" href="https://cloud.google.com/spanner/quotas#limits_for_creating_reading_updating_and_deleting_data" rel="noopener ugc nofollow" target="_blank">交易限额</a>内。一个事务最多可以写入20，000个变异，其中一个变异大约等于每个变异中的行数*列数。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kp kq l"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">可写流，每个事务最多写入200行</figcaption></figure><h1 id="d16e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">结论</h1><p id="9c3e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">来自Cloud Spanner的查询结果可以作为NodeJS流返回，并通过管道传输到任何其他NodeJS可写流中。上面的例子已经表明:</p><ol class=""><li id="9491" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">如何创建自定义流以将数据写入云扳手事务。</li><li id="3f5e" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">我们如何使用NodeJS流的内部缓冲和背压机制来提高从查询到事务的数据流的执行速度，同时保持对内存使用的控制。</li></ol></div></div>    
</body>
</html>