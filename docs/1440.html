<html>
<head>
<title>GCP GitOps Style CICD with Cloud Build to Deploy Helm Chart to GKE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP GitOps风格的CICD与云建设部署舵图到GKE</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/gcp-gitops-style-cicd-with-cloud-build-to-deploy-helm-chart-to-gke-fa003b999b1e?source=collection_archive---------0-----------------------#2020-05-24">https://medium.com/google-cloud/gcp-gitops-style-cicd-with-cloud-build-to-deploy-helm-chart-to-gke-fa003b999b1e?source=collection_archive---------0-----------------------#2020-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ad5c74153288166c961554959178694e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4G_wNGRDJvj25hQmbo7r0w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">乔恩·卡塔赫纳通过<a class="ae iu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的两个车轮图片</figcaption></figure><p id="2d85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过学习本教程，您将:</p><ul class=""><li id="48cd" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">使用云构建实现CI管道，以构建容器化的应用程序并将其上传到GCR</li><li id="5c30" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">使用云构建实现CD管道以在GKE部署helm chart</li><li id="8b82" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">按照GitOps惯例建设CICD管道</li></ul><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/2072dd4fb71ea17099cf56fe682e1b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*sqjJFk1ySy-Mr09NXf85iw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们将在本文中构建的CICD管道</figcaption></figure><p id="c78e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上图展示了我们将要建设的CICD管道。请注意，有两种方法可以触发CD管道:</p><ul class=""><li id="2070" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">您更改舵图，并将拉式请求合并到CD回购的主分支</li><li id="c5b5" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">您更改应用程序，并将拉请求合并到CI repo的主分支，它进一步克隆CD repo，更新helm图表(更改<code class="du km kn ko kp b">values.yaml</code>中的<code class="du km kn ko kp b">image.tag</code>字段)，然后将更改推送到CD repo</li></ul><p id="7536" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了简化事情，在第二种情况下，我们将只改变<code class="du km kn ko kp b">image.tag</code>字段。实际上你可以在<code class="du km kn ko kp b">Chart.yaml</code>中进一步更新其他东西，比如元数据。另请注意，我们直接将更改推送到CD回购，在现实生活中，您可能需要创建一个拉取请求。</p><h1 id="3160" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">先决条件</h1><p id="f3c2" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">在你能跟随这个教程之前，你需要下列东西:</p><ul class=""><li id="05a7" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">您有权访问的正在运行的GKE集群</li><li id="e7a0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">GCP云资源存储库中的CI和CD repos</li><li id="1515" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">您的云构建服务帐户(<code class="du km kn ko kp b">&lt;project number&gt;@cloudbuild.gserviceaccount.com</code>)拥有作为Kubernetes引擎开发者和源代码库作者的IAM角色</li></ul><h1 id="abe8" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">动机</h1><p id="d2a3" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">毫无疑问，Helm是最受欢迎和经过现场测试的工具，用于进行k8s部署。然而，GCP的托管管道工具Cloud Build并不提供将helm chart部署到GCP的托管k8s集群GKE的官方支持。</p><p id="b4f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，众所周知的GitOps近年来越来越受欢迎。拥有始终包含声明性描述的Git存储库的要点是实用且高效的。此外，干净的git提交历史对于审计跟踪很有用。触发CD管道对helm chart的更改不会触发CI管道来重建应用程序，这可以防止污染提交历史和容器注册表。由于k8s的声明性，它还允许您使用git revert回滚到应用程序或k8s部署的早期版本。</p><p id="897a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">据我所知，还没有关于这个主题的最新文章。<a class="ae iu" href="https://www.padok.fr/en/blog/kubernetes-gcp-cloud-build" rel="noopener ugc nofollow" target="_blank">Patte Hadrien发布的文章</a>讨论了如何在云构建中使用helm，但需要修改以兼容Helm版本3，并且不是GitOps风格的管道。</p><p id="8123" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我想通过提供一个在GCP使用云构建实现GitOps的分步指南来填补这个空白。</p><p id="d076" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，这篇文章叫做GitOps风格的CICD，因为GitOps经常有一个GitOps操作者参与编排步骤。詹金斯X，Argo CD，Flux CD是k8s中GitOps的一些选项。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="8496" class="kq kr hi bd ks kt ma kv kw kx mb kz la lb mc ld le lf md lh li lj me ll lm ln bi translated">介绍</h1><p id="8799" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">云构建是GCP托管服务，它使用户能够通过yaml文件中的声明来执行构建步骤。然后，每个构建步骤将使用docker映像和yaml文件中声明的命令在相应的Docker容器中运行。云构建在同一台机器上连续执行构建的所有步骤。默认情况下，Cloud Build使用一个名为<code class="du km kn ko kp b">/workspace</code>的目录作为工作目录，该目录是持久的，允许步骤通过它共享资产。当云构建运行一个构建步骤时，它会自动将一个<code class="du km kn ko kp b">workspace</code>卷挂载到<code class="du km kn ko kp b">/workspace</code>中。</p><p id="3daf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，云构建还没有官方的支持。幸运的是，社区为我们开发了一个<a class="ae iu" href="https://github.com/GoogleCloudPlatform/cloud-builders-community/tree/master/helm" rel="noopener ugc nofollow" target="_blank">helm builder</a>build step docker映像，它将在本文中使用。</p><p id="e3cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我们将在GCP云资源存储库中托管我们的CICD回购协议。</p><p id="41d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让车轮转动起来！</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="8067" class="kq kr hi bd ks kt ma kv kw kx mb kz la lb mc ld le lf md lh li lj me ll lm ln bi translated">将所需的构建步骤映像上传至GCR</h1><p id="ea4b" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">如前所述，我们需要首先将社区构建步骤docker映像上传到GCR，以便能够在云构建中使用它们。</p><p id="9e54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本教程中，我们需要两张图片，使用helm的<strong class="ix hj"> helm </strong>和编辑yaml文件的<strong class="ix hj"> yq </strong>。你可以把它们上传到你的GCP云壳来加速它。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">上传头盔生成器和yq build step docker图像到GCR</figcaption></figure><p id="26d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，你应该能够在你的GCR中的相应存储库中找到<strong class="ix hj">舵</strong>和<strong class="ix hj"> yq </strong>图像。</p><h1 id="be00" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">在没有CD触发器的情况下实施CI管道</h1><p id="1946" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">在本节中，我们将在GKE建立一个GitOps风格的CI渠道。请记住，我们稍后将修改<code class="du km kn ko kp b">cloudbuild.yaml</code>来集成CI管道和CD管道。</p><p id="6c01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经写了一个简单的go web应用程序和它的<code class="du km kn ko kp b">Dockerfile</code>。这个web应用程序将简单地监听端口8080，并响应“倪好版本&lt;版本号&gt;来自&lt; GKE集群IP &gt;”。</p><p id="85b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对应的<code class="du km kn ko kp b">cloudbuild.yaml</code>也很好理解。它定义了两个步骤:</p><ul class=""><li id="f38c" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hj">构建</strong>，它使用定义的<code class="du km kn ko kp b">Dockerfile</code>构建docker映像，将相应的GCR地址的地址作为名称(gcr . io/$ PROJECT _ ID/go-倪好)，git-commit-SHA作为标签。</li><li id="9a56" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj">推送</strong>，将构建好的图像推送到GCR。</li></ul><p id="8390" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du km kn ko kp b">PROJECT_ID</code>和<code class="du km kn ko kp b">COMMIT_SHA</code>是Cloud Build提供的替代变量，更多细节可以参考这里的<a class="ae iu" href="https://cloud.google.com/cloud-build/docs/configuring-builds/substitute-variable-values" rel="noopener ugc nofollow" target="_blank">文档。</a></p><p id="a2fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我们使用git-commit-SHA作为图像的标签，这是使用GitOps风格管道时推荐的方式，但是您也可以用其他唯一标识符(如语义版本)来替换它。</p><blockquote class="mh mi mj"><p id="dde3" class="iv iw mk ix b iy iz ja jb jc jd je jf ml jh ji jj mm jl jm jn mn jp jq jr js hb bi translated">因为Git为每次提交创建一个唯一的散列，所以建议使用Git散列来标记docker映像，而不是创建一个任意的版本号。除了唯一性之外，每个docker映像都可以使用Git哈希轻松追溯到Git repo历史，以确定docker映像中的确切代码。”</p><p id="0b5b" class="iv iw mk ix b iy iz ja jb jc jd je jf ml jh ji jj mm jl jm jn mn jp jq jr js hb bi translated">Yuen等人的GitOps和Kubernetes。铝</p></blockquote><p id="3c2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的两个步骤都运行一个<code class="du km kn ko kp b">docker</code> docker映像，这是由GCP提供的官方构建步骤映像。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">CI管道中的基本文件</figcaption></figure><p id="449a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们需要在云构建中添加触发器，如下图所示。当提交被推送到主分支时，它将触发在<code class="du km kn ko kp b">cloudbuild.yaml</code>中定义的管道运行。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/89782ec718b4ae5657cbf6dd3ae274b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGpguyTEbrVOw0LY1eRrgQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">云构建CI触发器屏幕截图</figcaption></figure><h1 id="3e61" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">实施CD管道</h1><p id="7904" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">CD管道的回购可在GitHub 中的<a class="ae iu" href="https://github.com/hughluo/go-nihao-cd" rel="noopener ugc nofollow" target="_blank">处获得。</a></p><p id="da6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本节中，我们将实施CD管道，将我们的helm chart部署到GKE。</p><p id="61c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经为我们的go web应用程序生成了一个简单的图表。由于它是通过<code class="du km kn ko kp b">helm create</code>自动生成的，为了简洁起见，我就不在这里附上完整的图表文件了。</p><p id="4589" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我只修改了<code class="du km kn ko kp b">values.yaml</code>中的<code class="du km kn ko kp b">image.repository</code>和<code class="du km kn ko kp b">image.tag</code> <strong class="ix hj"> </strong>，因为我们现在没有CICD集成(我们将在下一节中进行)。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">values.yaml的修改部分</figcaption></figure><p id="19da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是CD管道的<code class="du km kn ko kp b">cloudbuild.yaml</code>文件。我们可以看到，它有两个步骤:</p><ul class=""><li id="9725" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hj">配置kubectl </strong>，其中<strong class="ix hj"> </strong>使用kubectl来配置k8s上下文，以确保我们拥有部署helm图表所需的凭证</li><li id="229b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj">部署图</strong>，哪个嗯……把舵图部署到k8s集群。请注意，我们对values.yaml进行了回复，以提供部署helm图表所需的所有变量。</li></ul><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">CD管道的cloudbuid.yaml</figcaption></figure><p id="4de8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与上一节中的CI repo一样，我们还将在Cloud Build中为CD repo添加一个触发器，如下图所示。</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/33aeca50a89fd152e61307bea4be2e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyrZXLIt1hc8jZRBY9YgLg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">云构建CD触发器截图</figcaption></figure><h1 id="bb95" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">修改CI管道以与CD管道集成</h1><p id="1358" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">CI管道的回购可在GitHub 中的<a class="ae iu" href="https://github.com/hughluo/go-nihao-ci" rel="noopener ugc nofollow" target="_blank">处获得。</a></p><p id="1cfe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们在上一节中看到的，我们依赖于<code class="du km kn ko kp b">values.yaml</code>文件来配置我们的helm图表和底层k8s资源。</p><p id="ed2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本节中，我们将更新以前的CI管道，这样在我们修改应用程序后，CI管道将自动更改<code class="du km kn ko kp b">values.yaml</code>(更新容器标记)，并将提交推送到CD repo，这将触发CD管道将我们更新的图表部署到GKE。</p><p id="63a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用之前上传到GCR的<code class="du km kn ko kp b">yq</code>码头图片来修改<code class="du km kn ko kp b">values.yaml</code>。与以前的版本相比，新版本的<code class="du km kn ko kp b">cloudbuild.yaml</code>，如下图所示，增加了以下步骤:</p><ul class=""><li id="5788" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="ix hj">克隆CD </strong>，将CD repo克隆到我们的云构建虚拟机</li><li id="9b46" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj">更新图表</strong>，该图表使用<code class="du km kn ko kp b">yq</code>将<code class="du km kn ko kp b">values.yaml</code>中的<code class="du km kn ko kp b">image.tag</code>字段修改为git-commit-SHA，这实质上是<strong class="ix hj">构建</strong>步骤中的相同标记。</li><li id="6a5e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="ix hj"> Push CD </strong>，然后将上一步的提交推送到CD repo。</li></ul><p id="4604" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们在提交消息中添加了一些有用的信息。它帮助我们跟踪哪个CI提交触发了CD管道。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用于CI管道的cloudbuild.yaml，与CD集成</figcaption></figure><h1 id="686f" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="df1e" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">原来如此！到目前为止，您可以尝试提交对CI存储库的更改以触发CI管道，这也将推动对CD存储库的更改以触发CD管道。您还可以使用<code class="du km kn ko kp b">git revert</code>来转换先前的提交，以查看它如何回滚到相应的版本。</p><p id="a774" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我相信我会让你相信，通过使用云构建，在GCP实现GitOps风格的CICD管道是很容易的。GitOps非常适合构建CICD管道，因为现在构建和部署都是声明式的。</p><p id="1dec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在现实生活中，您可以为您的开发和测试环境这样做。你应该用<code class="du km kn ko kp b">git branch</code>。但是，对于生产环境中的CD，您必须引入额外的步骤，以确保管道只有在通过测试环境中的必要测试后才会被触发。在现实生活中，根据您的组织，您可能还需要引入额外的人工干预。尽管在perfect world中，您可以只通过git命令和pull请求与您的CICD进行交互。</p><p id="dc55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读:)</p><h1 id="c4e0" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">参考</h1><p id="e06d" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated"><a class="ae iu" href="https://www.manning.com/books/gitops-and-kubernetes" rel="noopener ugc nofollow" target="_blank"> GitOps and Kubernetes </a>，一本由Billy Yuen、Alexander Matyushentsev、Todd Ekenstam和Jesse Suen撰写的精彩书籍</p><p id="41ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.padok.fr/en/blog/kubernetes-gcp-cloud-build" rel="noopener ugc nofollow" target="_blank">谷歌云平台上的Kubernetes:通过云构建实现自动化部署</a>，Patte Hadrien的一篇简洁的博客文章</p><p id="480b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GCP文档，在这里你可以找到几乎所有关于GCP问题的答案。虽然你必须有耐心，因为关键信息可能隐藏在某个鬼祟的地方…</p></div></div>    
</body>
</html>