<html>
<head>
<title>Helm Chart for Fabric</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">织物舵图</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/helm-chart-for-fabric-1017c9efbf19?source=collection_archive---------0-----------------------#2018-09-06">https://medium.com/google-cloud/helm-chart-for-fabric-1017c9efbf19?source=collection_archive---------0-----------------------#2018-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6e2d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">编程笔记</h2></div><p id="535a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我上周在的一个<a class="ae jt" rel="noopener" href="/google-cloud/helm-chart-for-fabric-for-kubernetes-80408b9a3fb6">故事中提到的，我已经<strong class="iz hj"> un </strong>成功尝试为Kubernetes的</a><a class="ae jt" href="https://www.hyperledger.org/projects/fabric" rel="noopener ugc nofollow" target="_blank"> Hyperledger Fabric </a>创建<a class="ae jt" href="https://www.helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>图表。GitHub上记录了各种方法(<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x" rel="noopener ugc nofollow" target="_blank"> v1.2 </a>，<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric" rel="noopener ugc nofollow" target="_blank"> v1.1 </a>)，但是没有一种方法可以在没有一些手工操作的情况下工作。这个故事试图总结我的编程笔记。</p><h2 id="c997" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">赫尔姆？</h2><p id="3248" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">Helm已经成为Kubernetes应用程序部署的首选，也是许多Kubernetes应用程序的部署选择。IIUC Helm的下一个版本将包括重大变化，包括从集群端管理的变化。由于为Kubernetes构建云市场部署的需求，我几乎从一开始就使用了Helm的仅客户端和<code class="du ku kv kw kx b">helm template</code>方法。</p><p id="cb8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经使用Google的云部署管理器、bash、Jsonnet和Helm来部署Kubernetes解决方案，但我不相信Helm目前为应用程序部署开发人员提供的独特价值。因为它是事实上的标准，所以应用程序最终用户使用它会有好处。</p><p id="10c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">现有技术</strong></p><p id="4b07" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我要感谢IBM的各位同仁，他们在我的冒险中慷慨相助。我从IBM为IBM Container Service开发的Fabric的掌舵图开始这个项目。后来，IBMers加里和Yacov帮助我了解了织物概念，并提供了指导。</p><h2 id="1c50" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">读写很多</h2><p id="6f63" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我为Fabric绘制的掌舵图假设有一个<a class="ae jt" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes" rel="noopener ugc nofollow" target="_blank">读写多</a>卷可供群集使用。Google <a class="ae jt" href="https://cloud.google.com/persistent-disk/" rel="noopener ugc nofollow" target="_blank">持久盘</a>不支持读写多卷(直接)。</p><p id="11d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，我使用了一个Kubernetes <a class="ae jt" href="https://github.com/kubernetes/examples/tree/bdda4f31e60d171f77252e7d041e9c6877565f73/staging/volumes/nfs" rel="noopener ugc nofollow" target="_blank">样本</a>，展示了如何在持久磁盘上运行NFS。NFS服务器被配置为可读写的许多永久卷和永久卷都可以对其进行声明。</p><p id="e842" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于Fabric Helm图表，有一个<code class="du ku kv kw kx b">shared</code>声明，用于存储crypto-config、genesis块、通道事务的输出，以及部署用来跟踪状态的类似信号量的文件。</p><p id="a94c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个解决方案非常有效。它有点隐蔽，但这是一个可靠的，熟悉的和廉价的方式来获得读写许多与Kubernetes引擎。</p><h2 id="98f0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">标记</h2><p id="82ab" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">Helm有一套有价值的<a class="ae jt" href="https://docs.helm.sh/chart_best_practices" rel="noopener ugc nofollow" target="_blank">最佳实践</a>，包括资源标签<a class="ae jt" href="https://docs.helm.sh/chart_best_practices/#labels-and-annotations" rel="noopener ugc nofollow" target="_blank"/>。当我记录这一点时，我意识到我要么偏离了当前的指导，要么没有准确地执行它(抱歉)。</p><p id="9cc0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我一直试图遵循以下方法:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="5029" class="ju jv hi kx b fi lg lh l li lj">app.kubernetes.io/name: {{ include "hyperledger-fabric.chart" . }}<br/>app.kubernetes.io/version: {{ .Chart.Version }}<br/>app: {{ include "hyperledger-fabric.name" . }}<br/>chart: {{ include "hyperledger-fabric.chart" . }}<br/>release: {{ .Release.Name }}<br/>heritage: {{ .Release.Service }}<br/>component: peer<br/>org: {{ $orgName }}<br/>peer: {{ $peerID | quote }}</span></pre><p id="dc4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Component反映了Fabric组件的类型:peer、orderer、ca等。谨慎的做法是也使用标签来说明组织名称和对等ID。标签可能有“太多”的地方，但这个列表远非如此。一般来说，你不应该*使用Kubernetes的名字来引用反映Kubernetes自己的方法的资源，例如，根据标签和类似的原因来选择pod:动态性和多维性。</p><h2 id="a340" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">配置映射</h2><p id="cebc" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">Fabric的配置文件<code class="du ku kv kw kx b">crypto-config.yaml</code>和<code class="du ku kv kw kx b">configtx.yaml</code>是Kubernetes配置映射的自然选择，两者都反映为存储库中的配置映射(<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/configtx-configmap.yaml" rel="noopener ugc nofollow" target="_blank">链接</a>、<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/crypto-config-configmap.yaml" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><p id="bed9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我面临的一个挑战是希望能够在部署期间解析这些文件以提取值。例如，<code class="du ku kv kw kx b">crypto-config.yaml</code>定义了订购者的姓名、组织及其名称以及对等用户和用户的初始数量。这些值都是构建精确网络所必需的。</p><p id="ca16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，虽然配置映射可用于托管一组键-值对，但配置映射不允许任何值层次结构；如果值本身是键值对，则不能通过配置映射直接访问。因此，虽然将YAML文件编码为ConfigMap值很简单，但是不可能将任意的YAML文件反射为config map。</p><p id="5149" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与ConfigMaps不同，Helm的<code class="du ku kv kw kx b">values.yaml</code>当然可以反映任意的YAML文件，并且Helm模板可以直接访问文件中的任何值。出于这个原因，我手动将<code class="du ku kv kw kx b">configtx.yaml</code>和<code class="du ku kv kw kx b">crypto-config.yaml</code>文件内容的子集反映在<code class="du ku kv kw kx b">values.yaml</code>中，这样我就可以直接访问每个组织的对等体数量。参见<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/values.yaml" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="d6b6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，这允许:在crypto-config.yaml中定义的对等组织上迭代，以便创建资源:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="a137" class="ju jv hi kx b fi lg lh l li lj">{{- range $i, $org := .Values.cryptoconfig.PeerOrgs }}<br/>{{- $orgName := $org.Name | lower }}<br/>{{- end }}</span></pre><p id="fd35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">问题</strong>:如何从头盔更直接的访问<code class="du ku kv kw kx b">crypto-config.yaml</code>和<code class="du ku kv kw kx b">configtx.yaml</code>？</p><p id="f7a2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">问题</strong>:crypto-config . YAML和configtx.yaml看起来有什么出入(是吗？)共享密钥已协调？为什么要分割？</p><p id="ac74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">问题</strong> : Fabric支持YAML锚&amp;引用，但是在values.yaml中不支持这些引用，并且大部分被展平(或排除)。</p><h2 id="55d6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">拔靴带</h2><p id="cd1f" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/bootstrap-deployment.yaml" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="36df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始提供网络之前，需要做一些准备工作。这些步骤(幸运的是)是一组线性步骤，但是必须记录成功完成的步骤。完成被异步地用来阻止其他步骤的启动:例如，在<code class="du ku kv kw kx b">cryptogen</code>运行之前，不可能做任何事情(启动一个对等体)。</p><p id="5ee2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes和Helm都没有包含协调需要依赖和分支的部署的机制。这个事实让我顿悟到对赫尔姆的失望。我意识到，特别是它的客户端专用功能，以及<code class="du ku kv kw kx b">helm template</code>命令的名称(也许不是讽刺的),使得Helm更像是一个模板工具，而不是部署工具。</p><p id="820b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总之，如果Helm只是模板，我更喜欢使用Jsonnet。虽然我是Golang的粉丝，但我不太喜欢Golang模板化(即使是在与Go一起编写时)和for (JSON sic。)模板化，更喜欢简单的Jsonnet。</p><p id="82ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过Helm，我生成了一组Kubernetes清单，将它们放在集群上，让集群(大部分情况下很少)协调资源的创建。</p><p id="3676" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，因为Helm和Kubernetes都不支持依赖或分支，开发人员必须求助于模糊的方法来实现这一点。在我的例子中，我借鉴了IBM的解决方案对信号量文件的使用。这是一个很好的解决问题的方法，但是，如果不深入研究清单文件并想知道为什么名为<code class="du ku kv kw kx b">cryptogen_complete</code>的文件被触摸，这个意图就不明显。</p><p id="9246" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为引导步骤是一次性的，所以我使用Kubernetes作业资源来表示它。我经常在这个清单和其他清单中使用<code class="du ku kv kw kx b">initContainers</code>。<code class="du ku kv kw kx b">initContainers</code>，顾名思义，是主<code class="du ku kv kw kx b">containers</code>赛事的预备容器。有趣的是，<code class="du ku kv kw kx b">initContainers</code>是按照它们被定义的顺序运行的。这提供了一种方便的方法来将一组线性步骤分解成一些易于从Kubernetes监视中观察到的内容。</p><p id="6177" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于自举，我们:</p><ol class=""><li id="a966" class="lk ll hi iz b ja jb jd je jg lm jk ln jo lo js lp lq lr ls bi translated"><code class="du ku kv kw kx b">cryptogen</code>生成</li><li id="bbde" class="lk ll hi iz b ja lt jd lu jg lv jk lw jo lx js lp lq lr ls bi translated"><code class="du ku kv kw kx b">configtxgen</code>(创世纪)</li><li id="1a38" class="lk ll hi iz b ja lt jd lu jg lv jk lw jo lx js lp lq lr ls bi translated"><code class="du ku kv kw kx b">configtxgen</code>(频道)</li><li id="c8ea" class="lk ll hi iz b ja lt jd lu jg lv jk lw jo lx js lp lq lr ls bi translated">ForEach锚点<code class="du ku kv kw kx b">configtxgen</code>(锚点对等事务)</li></ol><p id="c5fb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这转化为(伪模板):</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="4580" class="ju jv hi kx b fi lg lh l li lj">initContainers:</span><span id="92e4" class="ju jv hi kx b fi ly lh l li lj"># 1st step<br/>- name: cryptogen<br/>  image: cryptogen<br/>  args:<br/>  - generate</span><span id="1d21" class="ju jv hi kx b fi ly lh l li lj"># 2nd step<br/>- name: configtxgen-genesis<br/>  image: configtxgen<br/>  args:<br/>  - ...<br/>  - -outputBlock</span><span id="ac14" class="ju jv hi kx b fi ly lh l li lj"># 3rd step<br/>- name: configtxgen-channel<br/>  image: configtxgen<br/>  args:<br/>  - ...<br/>  - outputCreateChannelTx</span><span id="36ea" class="ju jv hi kx b fi ly lh l li lj"># 4th step<br/>{{- range $org := .Values.configtx.Organizations }}<br/>- name: anchor-{{ $org.ID | lower }}<br/>  image: configtxgen<br/>  args:<br/>  - ...<br/>  - -outputAnchorPeersUpdate<br/>{{- end }}</span><span id="9411" class="ju jv hi kx b fi ly lh l li lj">containers:<br/>...</span></pre><p id="62ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意几件事。该作业中的实际<code class="du ku kv kw kx b">containers</code>主要是输出步骤，动作在<code class="du ku kv kw kx b">initContainers</code>中。我为<code class="du ku kv kw kx b">cryptogen</code>和<code class="du ku kv kw kx b">configtxgen</code>构建了容器。这些二进制文件是为Debian|Ubuntu(使用libc)构建的，我想使用一个轻量级的运行时环境，比如Alpine。将这些二进制文件放入容器中增加了流程的清晰度，并且与作为容器映像提供的其他Fabric二进制文件更加一致。</p><p id="4da2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">容器执行<code class="du ku kv kw kx b">configtxgen</code> <code class="du ku kv kw kx b">inspectBlock</code>和<code class="du ku kv kw kx b">inspectChannelCreateTx</code>(查看)命令。还有一个容器触动<code class="du ku kv kw kx b">/shared/bootstrapped</code>来充当自举成功完成的信号量。</p><h2 id="909a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">渠道创建和对等加入</h2><p id="bc3e" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/channel-create-job.yaml" rel="noopener ugc nofollow" target="_blank">链接</a>，<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/peer-join-deployment.yaml" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="d0f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建渠道是Kubernetes的另一项工作。与其他Fabric资源一样，它使用一个<code class="du ku kv kw kx b">initContainer</code>来检查semamphore文件的创建，从而阻止成功完成自举。最初，这项工作还阻止了使用<code class="du ku kv kw kx b">peer node status</code>的锚节点的可用性，但是Yacov@IBM指出这是多余的，并且还会导致部署问题。一旦成功创建了通道，就会创建另一个文件信号量，它发出信号通知对等体加入命令继续执行。</p><p id="1673" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个图表中，每个对等体然后加入通道。因此，部署类似于对等体创建，它遍历组织，然后动态地遍历组织中定义的每个对等体，并运行正确配置的<code class="du ku kv kw kx b">peer channel join</code>命令。</p><p id="0d23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，每个组织必须用该组织的锚定对等点更新一次渠道。</p><h2 id="7635" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">CA，CLI，订购者</h2><p id="4727" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/ca-deployment.yaml" rel="noopener ugc nofollow" target="_blank">链接</a>、<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/cli-deployment.yaml" rel="noopener ugc nofollow" target="_blank">链接</a>、<a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/orderer-deployment.yaml" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="37f4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些资源易于部署。它们采用跨结构节点类型使用的简单模式。单个Pod(尽管是由部署管理的)由一个服务作为前端。该服务为结构节点和端口提供DNS名称，例如<code class="du ku kv kw kx b">7050</code>上的gRPC。</p><p id="15c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">CLI是调试、安装和实例化链代码的有用工具。当我在解决这个命令失败的原因时，我将命令模板化以使自己快速回到instantiate命令。</p><p id="4ae0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进入CLI:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="f92d" class="ju jv hi kx b fi lg lh l li lj">kubectl exec \<br/>--stdin \<br/>--tty \<br/>$(\<br/>  kubectl get pods \<br/>  --selector=<strong class="kx hj">component=cli,org=org1</strong> \<br/>  --output=jsonpath="{ .items[0].metadata.name }" \<br/>  --namespace=${NAMESPACE} \<br/>  --context=${CONTEXT} \<br/>) \<br/>--container=cli \<br/>--namespace=${NAMESPACE} \<br/>--context=${CONTEXT} \<br/>-- bash</span></pre><p id="df5d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="775c" class="ju jv hi kx b fi lg lh l li lj">peer chaincode install \<br/>--name=${NAME} \<br/>--version=${VERSION} \<br/>--path=github.com/chaincode/example02/go/</span><span id="6bd0" class="ju jv hi kx b fi ly lh l li lj">2018-08-24 [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc<br/>2018-08-24 [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc<br/>2018-08-24 [main] main -&gt; INFO 003 Exiting.....</span></pre><p id="34d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可以通过以下方式确认:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="5aca" class="ju jv hi kx b fi lg lh l li lj">peer chaincode list \<br/>--channelID=$CHANNEL_NAME \<br/>--installed</span><span id="3391" class="ju jv hi kx b fi ly lh l li lj">Get installed chaincodes on peer:<br/>Name: ex02, Version: 2.0, Path: github.com/chaincode/example02/go/, Id: 33620f48ee049ffbb7f763f77a3bde54b768ebba9d502532c9bbb98e66fdba3e<br/>2018-08-24 [main] main -&gt; INFO 001 Exiting.....</span></pre><p id="15e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">挑战在于实例化:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="bd74" class="ju jv hi kx b fi lg lh l li lj">peer chaincode instantiate \<br/>--orderer=${RELEASE_NAME}-hyperledger-fabric-orderer:7050 \<br/>--cafile=/shared/.../tlsca.example.com-cert.pem \<br/>--channelID=$CHANNEL_NAME \<br/>--name=${NAME} \<br/>--version=${VERSION} \<br/>--ctor='{"Args":["init","a", "100", "b","200"]}' \<br/>--policy="OR ('Org1MSP.peer','Org2MSP.peer')"</span></pre><p id="d6de" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其价值与以下各项保持一致:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="ca4e" class="ju jv hi kx b fi lg lh l li lj">Error: Error endorsing chaincode: rpc error: code = Unknown desc = timeout expired while starting chaincode ex02:2.0(networkid:dev,peerid:org1-peer0,tx:82221c06970c59e6a745c04515446d6776aa2f8899fc1d2a808954c81db07ee1)</span></pre><p id="cfce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢Yacov@IBM，这个问题被确定为使用docker-in-docker的Fabric的挑战，我在下面的“<strong class="iz hj">Peer</strong>”中简要总结了这个问题，并在我上周的总结故事[ <a class="ae jt" rel="noopener" href="/google-cloud/helm-chart-for-fabric-for-kubernetes-80408b9a3fb6">链接</a> ]中更完整地总结了这个问题。</p><h2 id="62f7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">同行</h2><p id="3786" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><a class="ae jt" href="https://github.com/DazWilkin/hyperledger-fabric-1.2.x/blob/master/templates/peer-deployment.yaml" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="1b3c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成功完成引导步骤时的对等创建块。其他几个部署步骤同样会阻止引导。为了明确这一事实，我使用了<code class="du ku kv kw kx b">initContainers</code>，他们简单地说:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="f6a1" class="ju jv hi kx b fi lg lh l li lj">- name: await-bootstrapped<br/>        image: busybox<br/>        imagePullPolicy: IfNotPresent<br/>        command:<br/>        - ash<br/>        - -c<br/>        - |<br/>          while [ ! -f /shared/bootstrapped ]; do<br/>            echo Awaiting /shared/bootstrapped<br/>            sleep 15s<br/>          done</span></pre><p id="058b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想根据<code class="du ku kv kw kx b">crypto- config.yaml</code>中定义的意图提供对等点。正如我上面提到的，我从<code class="du ku kv kw kx b">crypto-config.yaml</code>和<code class="du ku kv kw kx b">configtx.yaml</code>中复制了显著的组块来达到这个目的。因此，对等部署包括对[对等]组织的迭代，以及对每个对等组织的迭代:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="4a3e" class="ju jv hi kx b fi lg lh l li lj">{{- range $i, $org := .Values.cryptoconfig.PeerOrgs }}<br/>  {{- $orgName := $org.Name | lower }}<br/>  {{- range $j, $peerID := until ( $org.Template.Count | int) }}<br/>    {{- $orgFullName  := printf "%s.example.com" $orgName }}<br/>    {{- $peerName     := printf "peer%d" $peerID }}<br/>    {{- $peerFullName := printf "%s.%s" $peerName $orgFullName }}<br/>    ...<br/>  {{- end }}<br/>{{- end }}</span></pre><p id="2746" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在内部循环中，为每个对等体和将对等体(Pod)暴露给结构网络中的其他实体的伴随服务创建部署。</p><p id="7c75" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">取一个组织名称(例如原型<code class="du ku kv kw kx b">Org1</code>)和一个对等名称(例如原型<code class="du ku kv kw kx b">Peer0</code>)并将它们映射到<code class="du ku kv kw kx b">x-hyperledger-fabric-org1-peer0</code>和<code class="du ku kv kw kx b">org1.example.com</code>是很简单的。我将把这个讨论推迟到“<strong class="iz hj">命名</strong>”部分(见下文)。</p><p id="7440" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同行也挂载<code class="du ku kv kw kx b">docker.sock</code>。当调用chaincode <code class="du ku kv kw kx b">instantiate</code>命令时，对等体获取<code class="du ku kv kw kx b">install</code> chaincode并使用<a class="ae jt" href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" rel="noopener ugc nofollow" target="_blank"> docker-in-docker </a>到<code class="du ku kv kw kx b">create</code>一个docker映像，<code class="du ku kv kw kx b">attach</code>然后<code class="du ku kv kw kx b">start</code>它:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="033f" class="ju jv hi kx b fi lg lh l li lj">IMAGE=$(\<br/>  docker images --format="{{ .Repository }}" \<br/>  | grep dev-org1-peer0-example02-2.0\<br/>)</span><span id="8307" class="ju jv hi kx b fi ly lh l li lj">docker events --filter=image=${IMAGE}</span><span id="a212" class="ju jv hi kx b fi ly lh l li lj">2018-08-22 container <strong class="kx hj">create</strong> 132bbe(image=dev-org1-peer0-ex02-2.0)<br/>2018-08-22 container <strong class="kx hj">attach</strong> 132bbe(image=dev-org1-peer0-ex02-2.0)<br/>2018-08-22 container <strong class="kx hj">start</strong> 132bbe(image=dev-org1-peer0-ex02-2.0)</span></pre><p id="b049" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，这会导致容器在主机上的Docker引擎的上下文中运行(在本例中是Kubernetes节点)。如果容器试图与例如<code class="du ku kv kw kx b">x-hyperledger-fabric-org1-peer0</code>对话，它会失败。该名称是一个Kubernetes DNS名称，Kubernetes名称在群集外部无法解析。这是我上周在总结<a class="ae jt" rel="noopener" href="/google-cloud/helm-chart-for-fabric-for-kubernetes-80408b9a3fb6">故事</a>中描述的突出问题之一。</p><p id="083c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">调试:</strong>如何找到一个Pod正在运行的节点？</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="c88a" class="ju jv hi kx b fi lg lh l li lj">PROJECT=[[YOUR-PROJECT]]<br/>NAMESPACE=[[YOUR-NAMESPACE]] # Optional<br/>CONTEXT=[[YOUR-CONTEXT]] # Optional<br/>SELECTOR="<strong class="kx hj">component=peer,org=org1,peer=0</strong>"</span><span id="f157" class="ju jv hi kx b fi ly lh l li lj">gcloud compute ssh $(\<br/>  kubectl get pods \<br/>  --selector=${SELECTOR} \<br/>  --output=jsonpath="{.items[0].spec.nodeName }" \<br/>  --namespace=${NAMESPACE} \<br/>  --context=${CONTEXT}) \<br/>--project=${PROJECT}</span></pre><blockquote class="lz ma mb"><p id="d3ba" class="ix iy mc iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>这结合了一个<code class="du ku kv kw kx b">kubectl</code>命令，该命令获取一个Pod的节点名，然后与<code class="du ku kv kw kx b">gcloud</code>一起使用，ssh到实例中。</p></blockquote><p id="4999" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我仍然不清楚哪些环境变量是必需的，哪些是可选的，哪些环境变量的默认值对于简单的<code class="du ku kv kw kx b">peer node start</code>命令来说是可以接受的。</p><p id="4b2f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">特性请求:我希望文档能够扩展到包含与每个命令相关的环境变量列表。</p><h2 id="926b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">命名</h2><p id="6272" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">命名仍然是一个挑战。协调Helm|Kubernetes命名(最佳实践)和Fabric命名的问题仍未解决。</p><h2 id="e2b3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">港口</h2><p id="e320" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">最初，我天真地为每个服务生成了<code class="du ku kv kw kx b">NodePorts</code>。如果没有指定<code class="du ku kv kw kx b">--type=NodePort</code>服务，则分配一个可用端口。最初，我没有仔细考虑这个过程，并试图计算服务的节点端口，并将它们分布在端口空间中。</p><p id="e073" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是个坏主意。</p><p id="71cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不仅使我有可能需要调整端口空间来确保必要的组织、对等体等。有足够的港口满足他们的需求，但更重要的是，我忘记了Kubernetes的一个宗旨。也就是说，我总是可以查找分配给服务的节点端口:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="1d6c" class="ju jv hi kx b fi lg lh l li lj">kubectl get services \<br/>--selector=${SELECTOR} \<br/>--output=jsonpath='{.spec.ports[?(@.name=="grpc")].nodePort}" \<br/>--namespace=${NAMESPACE} \<br/>--context=${CONTEXT}</span></pre><blockquote class="lz ma mb"><p id="9e88" class="ix iy mc iz b ja jb ij jc jd je im jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>上面用JSONPath对<code class="du ku kv kw kx b">ports</code>的数组进行过滤，得到一个名为<code class="du ku kv kw kx b">grpc</code>的，它的<code class="du ku kv kw kx b">nodePort</code>值就是结果。</p></blockquote><p id="7fc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，经过思考，我意识到大多数服务不需要在原型中的集群之外公开，因此，我可以完全放弃节点端口，使用集群IP。</p><p id="9af8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我需要向外部公开结构节点时，我将让集群自动分配节点端口，然后使用类似上面的查询来确定特定资源的端口。</p><h2 id="8cd4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">日志</h2><p id="a35c" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">日志记录非常重要，使用Kubernetes引擎可以很容易地从任何Pod |容器中快速获取日志。再一次，我在调试过程中反复检查日志，并从模板化命令中受益:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="70de" class="ju jv hi kx b fi lg lh l li lj">PROJECT=<br/>CLUSTER=<br/>REGION=<br/>NAMESPACE=<br/>CONTEXT=</span><span id="6118" class="ju jv hi kx b fi ly lh l li lj">COMPONENT="peer"<br/>ORG="org1"<br/>PEER="2"</span><span id="6511" class="ju jv hi kx b fi ly lh l li lj">POD=$(\<br/>  kubectl get pods \<br/>  --selector=component=${COMPONENT},org=${ORG},peer=${PEER} \<br/>  --namespace=${NAMESPACE} \<br/>  --context=${CONTEXT} \<br/>  --output=jsonpath="{.items[].metadata.name}"\<br/>) &amp;&amp; echo ${POD}</span><span id="e283" class="ju jv hi kx b fi ly lh l li lj">AFTER=$(date --rfc-3339=s --date="1 hour ago" | sed "s| |T|")<br/>BEFORE=$(date --rfc-3339=s | sed "s| |T|")</span><span id="ebf1" class="ju jv hi kx b fi ly lh l li lj">FILTER="resource.type=\"k8s_container\" "\<br/>"resource.labels.location=\"${REGION}\" "\<br/>"resource.labels.cluster_name=\"${CLUSTER}\" "\<br/>"resource.labels.pod_name=\"${POD}\" "\<br/>"timestamp&gt;=\"${AFTER}\" "\<br/>"timestamp&lt;=\"${BEFORE}\""</span><span id="d273" class="ju jv hi kx b fi ly lh l li lj">gcloud logging read "${FILTER}" \<br/>--project=${PROJECT} \<br/>--format=json \<br/>--order=asc \<br/>| jq --raw-output '.[].textPayload | rtrimstr("\n")'</span></pre><p id="ea9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，唷！但我向你保证，这很有帮助。-)</p><p id="c9ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上半部分仅仅定义了常量。再一次，Kubernetes广泛使用标签，确实有助于过滤资源。在这里，我通过各种对等节点进行过滤。<code class="du ku kv kw kx b">kubectl</code>用于识别感兴趣的Pod的运行时名称。</p><p id="c8b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，这被合并到提供给<code class="du ku kv kw kx b">gcloud logging</code>的冗长的过滤字符串中。本质上，我们提供了集群的规范(名称、区域)、Pod的名称，并且在本例中，定义了覆盖最后一个小时的时间戳。这可以用<code class="du ku kv kw kx b">--freshness</code>标志来代替，但是它只支持降序排列(这不太有用)。</p><p id="fadf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们把所有东西放在一起，根据<code class="du ku kv kw kx b">JSON</code>中的过滤器提取日志，然后通过管道传输到<code class="du ku kv kw kx b">jq</code>，提取textPayload，并修剪多余的换行符(通过Fabric？)在日志中:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="3e6a" class="ju jv hi kx b fi lg lh l li lj">[nodeCmd] serve -&gt; INFO 001 Starting peer:<br/> Version: 1.1.0<br/> Go version: go1.9.2<br/> OS/Arch: linux/amd64<br/> Experimental features: false<br/> Chaincode:<br/>  Base Image Version: 0.4.6<br/>  Base Docker Namespace: hyperledger<br/>  Base Docker Label: org.hyperledger.fabric<br/>  Docker Namespace: hyperledger<br/>[ledgermgmt] initialize -&gt; INFO 002 Initializing ledger mgmt<br/>[kvledger] NewProvider -&gt; INFO 003 Initializing ledger provider<br/>[kvledger] NewProvider -&gt; INFO 004 ledger provider Initialized<br/>[ledgermgmt] initialize -&gt; INFO 005 ledger mgmt initialized<br/>[peer] func1 -&gt; INFO 006 Auto-detected peer address: 10.0.2.8:7051<br/>[peer] func1 -&gt; INFO 007 Returning x-hyperledger-fabric-org1-peer0:7051<br/>[peer] func1 -&gt; INFO 008 Auto-detected peer address: 10.0.2.8:7051<br/>[peer] func1 -&gt; INFO 009 Returning x-hyperledger-fabric-org1-peer0:7051<br/>[eventhub_producer] start -&gt; INFO 00a\ Event processor started</span></pre><h2 id="28db" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论</h2><p id="1c6c" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">当我在我的编程笔记中回顾它时，我将继续用额外的信息调整这些笔记。希望这对别人有帮助|有见地。</p><p id="bf51" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>