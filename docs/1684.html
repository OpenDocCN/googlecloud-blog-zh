<html>
<head>
<title>Introducing Eventarc in Pic-a-Daily Serverless Workshop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Pic-a-Daily无服务器研讨会中介绍Eventarc</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/introducing-eventarc-in-pic-a-daily-serverless-workshop-963e29785b75?source=collection_archive---------2-----------------------#2020-11-30">https://medium.com/google-cloud/introducing-eventarc-in-pic-a-daily-serverless-workshop-963e29785b75?source=collection_archive---------2-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="edaa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">pic-a-每日无服务器研讨会</h1><p id="45a6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你可能知道，<a class="ae kb" href="https://twitter.com/glaforge" rel="noopener ugc nofollow" target="_blank"> Guillaume Larforge </a>和我有一个<a class="ae kb" href="https://codelabs.developers.google.com/serverless-workshop/" rel="noopener ugc nofollow" target="_blank">的无服务器日常摄影工作室</a>。在本次研讨会中，我们使用Google Cloud无服务器技术(如云功能、应用程序引擎、云运行等)构建了一个图片共享应用程序。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/6da3b1ec7df7b58205f97dad2461c297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YzGuUuzqA_azGxdI.png"/></div></div></figure><p id="ff6b" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">我们最近在车间增加了一项新服务。在这篇博文中，我想谈谈这项新服务。我还想谈谈<a class="ae kb" href="https://cloud.google.com/blog/products/serverless/build-event-driven-applications-in-cloud-run" rel="noopener ugc nofollow" target="_blank"> Eventarc </a>以及它如何帮助我们将事件添加到新服务中。</p><h1 id="2bb8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">以前的建筑</h1><p id="17aa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是之前Pic-a-Daily的架构:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kt"><img src="../Images/48399fbb3cae7375b8728e8379c35d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MMiH1wjPjCUu5Wsi.png"/></div></div></figure><p id="4225" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">概括一下:</p><ol class=""><li id="e0bb" class="ku kv hi jf b jg ko jk kp jo kw js kx jw ky ka kz la lb lc bi translated">用户通过前端上传图片到图片桶。</li><li id="beee" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">图像分析云功能接收上传事件，提取图像的元数据并保存到Firestore。</li><li id="9ef2" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">缩略图服务通过发布/订阅接收上传事件，调整图像大小并保存到缩略图桶。</li><li id="7cd2" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka kz la lb lc bi translated">拼贴服务创建缩略图拼贴。</li></ol><h1 id="3320" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">图像垃圾收集器服务</h1><p id="0db0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">以前架构的一个问题是图像删除。当图像从图片桶中删除时，缩略图桶中图像的缩略图和Firestore中图像的元数据仍然存在。</p><p id="9a83" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">为了解决这个问题，我们创建了一个新的云运行服务，图像垃圾收集器，在图像被删除后进行清理。</p><p id="9569" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">为了将云存储事件发送到图像垃圾收集器，我们可以使用Pub/Sub推送消息，就像我们在缩略图服务中所做的那样。然而，我们决定使用Eventarc来代替。</p><h1 id="3f41" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Eventarc是什么？</h1><p id="dd3f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们<a class="ae kb" href="https://cloud.google.com/blog/products/serverless/build-event-driven-applications-in-cloud-run" rel="noopener ugc nofollow" target="_blank">早在10月份就宣布</a> Eventarc是一个新的事件功能，允许你从60多个谷歌云资源发送事件到云运行。这是通过从各种来源读取审计日志并将它们作为CloudEvents发送到云运行服务来实现的。还可以选择从自定义应用程序的发布/订阅主题中读取事件。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es li"><img src="../Images/e7d7c633cb42a6036362811646cfe5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*N3HQ9WIkVOwl-tpZ.png"/></div></figure><p id="95a3" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">我们决定尝试Eventarc作为获取事件的新方法。我们还想避免我们必须在缩略图服务中进行的所有设置，以便通过发布/订阅将云存储事件发送到云上。参见<a class="ae kb" href="https://codelabs.developers.google.com/codelabs/cloud-picadaily-lab2?hl=en&amp;continue=https%3A%2F%2Fcodelabs.developers.google.com%2Fserverless-workshop%2F#9" rel="noopener ugc nofollow" target="_blank">详情</a>。</p><h1 id="5820" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">当前架构</h1><p id="cfc3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当前的架构现在看起来是这样的，带有Eventarc和图像垃圾收集器:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lj"><img src="../Images/518f91a77fc90e53947f9d1f570fabf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4CMcoAuDmAfeoAg2.png"/></div></div></figure><h1 id="78a5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">图像垃圾收集器代码</h1><p id="eb63" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你可以在这里查看图像垃圾收集器<a class="ae kb" href="https://github.com/GoogleCloudPlatform/serverless-photosharing-workshop/tree/master/services/garbage-collector" rel="noopener ugc nofollow" target="_blank">的完整代码。我将强调代码的一些部分。</a></p><p id="d86b" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">映像垃圾收集器从Eventarc接收封装到CloudEvents中的审计日志。它首先使用<a class="ae kb" href="https://www.npmjs.com/package/cloudevents" rel="noopener ugc nofollow" target="_blank"> CloudEvents SDK </a>读取CloudEvent:</p><pre class="kd ke kf kg fd lk ll lm ln aw lo bi"><span id="a918" class="lp ig hi ll b fi lq lr l ls lt">const { HTTP } = require("cloudevents");<br/>...<br/>const cloudEvent = HTTP.toEvent({ headers: req.headers, body: req.body });</span></pre><p id="f83f" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">CloudEvent的<code class="du lu lv lw ll b">data</code>字段有实际的审计日志。有<a class="ae kb" href="https://www.npmjs.com/package/@google/events" rel="noopener ugc nofollow" target="_blank"> Google Events </a>库将数据解析成审计日志:</p><pre class="kd ke kf kg fd lk ll lm ln aw lo bi"><span id="bd70" class="lp ig hi ll b fi lq lr l ls lt">const {toLogEntryData} = require('@google/events/cloud/audit/v1/LogEntryData');</span><span id="95f1" class="lp ig hi ll b fi lx lr l ls lt">...</span><span id="c083" class="lp ig hi ll b fi lx lr l ls lt">const logEntryData = toLogEntryData(cloudEvent.data);</span></pre><p id="1614" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">剩下的代码是从事件中提取bucket和object name，然后从thumbnails bucket和Firestore集合中删除它:</p><pre class="kd ke kf kg fd lk ll lm ln aw lo bi"><span id="3f4d" class="lp ig hi ll b fi lq lr l ls lt">const tokens = logEntryData.protoPayload.resourceName.split('/');<br/>const bucket = tokens[3];<br/>const objectName = tokens[5];</span><span id="875f" class="lp ig hi ll b fi lx lr l ls lt">// Delete from thumbnails<br/>try {<br/>    await storage.bucket(bucketThumbnails).file(objectName).delete();<br/>    console.log(`Deleted '${objectName}' from bucket '${bucketThumbnails}'.`);<br/>}<br/>catch(err) {<br/>    console.log(`Failed to delete '${objectName}' from bucket '${bucketThumbnails}': ${err}.`);<br/>}</span><span id="f186" class="lp ig hi ll b fi lx lr l ls lt">// Delete from Firestore<br/>try {<br/>    const pictureStore = new Firestore().collection('pictures');<br/>    const docRef = pictureStore.doc(objectName);<br/>    await docRef.delete();</span><span id="92c0" class="lp ig hi ll b fi lx lr l ls lt">console.log(`Deleted '${objectName}' from Firestore collection 'pictures'`);<br/>}<br/>catch(err) {<br/>    console.log(`Failed to delete '${objectName}' from Firestore: ${err}.`);<br/>}</span></pre><h1 id="c06e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建触发器</h1><p id="7ca1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，我们需要通过Eventarc将云存储中的事件连接到新服务。这是通过一个触发器实现的:</p><pre class="kd ke kf kg fd lk ll lm ln aw lo bi"><span id="4a8e" class="lp ig hi ll b fi lq lr l ls lt">gcloud beta eventarc triggers create trigger-${SERVICE_NAME} \<br/>  --destination-run-service=${SERVICE_NAME} \<br/>  --destination-run-region=europe-west1 \<br/>  --matching-criteria="type=google.cloud.audit.log.v1.written" \<br/>  --matching-criteria="serviceName=storage.googleapis.com" \<br/>  --matching-criteria="methodName=storage.objects.delete" \<br/>  --<a class="ae kb" href="mailto:service-account=${PROJECT_NUMBER}-compute@developer.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">service-account=${PROJECT_NUMBER}-compute@developer.gserviceaccount.com</a></span></pre><p id="1445" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">请注意，我们正在匹配云存储的审计日志，并专门寻找<code class="du lu lv lw ll b">storage.objects.delete</code>事件。</p><p id="1913" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">如果你想试试我们的工作室和新实验室，这里有一些链接:</p><ul class=""><li id="633b" class="ku kv hi jf b jg ko jk kp jo kw js kx jw ky ka ly la lb lc bi translated"><a class="ae kb" href="https://codelabs.developers.google.com/serverless-workshop/" rel="noopener ugc nofollow" target="_blank"> Pic-a-Daily无服务器车间</a>(g.co/codelabs/serverless-workshop)</li><li id="09b1" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ly la lb lc bi translated"><a class="ae kb" href="https://codelabs.developers.google.com/codelabs/cloud-picadaily-lab5" rel="noopener ugc nofollow" target="_blank"> Pic-a-daily: Lab 5 —图像垃圾收集器</a></li><li id="5aca" class="ku kv hi jf b jg ld jk le jo lf js lg jw lh ka ly la lb lc bi translated"><a class="ae kb" href="https://github.com/GoogleCloudPlatform/serverless-photosharing-workshop" rel="noopener ugc nofollow" target="_blank">车间代码</a></li></ul><p id="509c" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated">一如既往，如有任何问题/反馈，请随时在Twitter <a class="ae kb" href="https://twitter.com/meteatamel" rel="noopener ugc nofollow" target="_blank"> @meteatamel </a>上联系我。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="1c74" class="pw-post-body-paragraph jd je hi jf b jg ko ji jj jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka hb bi translated"><em class="mg">最初发布于</em><a class="ae kb" href="https://atamel.dev/posts/2020/11-30_eventarc-serverless-workshop/" rel="noopener ugc nofollow" target="_blank"><em class="mg">https://atamel . dev</em></a><em class="mg">。</em></p></div></div>    
</body>
</html>