<html>
<head>
<title>Deploying Scipy &amp; Numpy With Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker部署Scipy &amp; Numpy</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploying-scipy-numpy-with-docker-205e9afac3b0?source=collection_archive---------0-----------------------#2017-07-04">https://medium.com/google-cloud/deploying-scipy-numpy-with-docker-205e9afac3b0?source=collection_archive---------0-----------------------#2017-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d8d9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><em class="ix">最初发布于2015年9月2日之前的博客</em></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/c4816d8f9061dc42e0877aad7fed2ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dycaOuAjZWl1gpj4G_1kWg.jpeg"/></div></div></figure><p id="4b8f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">码头工人很体面，对吗？谷歌表示同意。这是他们云托管平台的核心部分。</p><h1 id="81b8" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">一点背景</h1><p id="c845" class="pw-post-body-paragraph jk jl hi jm b jn kz ij jp jq la im js jt lb jv jw jx lc jz ka kb ld kd ke kf hb bi translated"><strong class="jm hj">TL；DR </strong>:没有Debian的SciPy和NumPy的<code class="du le lf lg lh b">pip</code>轮<strong class="jm hj"> &gt; </strong>我们必须在<code class="du le lf lg lh b">pip install</code> <strong class="jm hj"> &gt; </strong>期间从源代码编译它需要很长时间。</p><p id="b6a7" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在过去的几周里，我与所有主要的主机提供商合作，努力为一个特定的Python项目找到最合适的归宿。每个平台都有一个棘手的问题，那就是需要编译SciPy。棘手的问题并不是让编译变得更容易——这通常很容易——而是如果从源代码编译所花费的时间。</p><p id="5fe0" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果你只在MacBook上使用SciPy，你可能会奇怪我在说什么。<code class="du le lf lg lh b">pip install scipy</code>对你来说不到30秒？是的，确实如此...在MacOS上。这要归功于pip团队不久前推出的一个叫做<a class="ae kg" href="https://pip.pypa.io/en/latest/reference/pip_wheel.html" rel="noopener ugc nofollow" target="_blank"> pip wheel </a>的小巧功能。这使得发布到包索引的项目的维护者可以预先构建他们的项目，并让您下载这些项目。简而言之，你下载一份已经为你的硬件和操作系统编译好的SciPy。</p><p id="1576" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">像SciPy这样维护软件包的聪明人可以为流行的操作系统和硬件风格构建各种轮子。不幸的是，SciPy团队目前只为MacOS发布了一个轮子。</p><p id="a006" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">最后，这意味着当我们在Linux虚拟机上<code class="du le lf lg lh b">pip install scipy numpy</code>时，我们必须等待它们编译；这太费时间了。运行您的CI作业以发布新版本，这需要20分钟？不理想；失败的可能性也更高。</p><h1 id="0dcf" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated">解决方案</h1><p id="cef4" class="pw-post-body-paragraph jk jl hi jm b jn kz ij jp jq la im js jt lb jv jw jx lc jz ka kb ld kd ke kf hb bi translated">我认为最好的方法是创建2个Docker图像。</p><p id="f153" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><a class="ae kg" href="https://dajos.azurewebsites.net/deploying-scipy-to-docker/#wheel.docker" rel="noopener ugc nofollow" target="_blank"><strong class="jm hj">wheel . docker</strong></a>—第一个<code class="du le lf lg lh b">Dockerfile</code>负责创建一个<code class="du le lf lg lh b">/wheelhouse</code>文件夹，里面装满了从我的应用程序<code class="du le lf lg lh b">requirements.txt</code>文件中构建的包。仅当<code class="du le lf lg lh b">requirements.txt</code>改变时，才需要构建该图像。当一个项目达到某个稳定点(生产？).</p><p id="52bf" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><a class="ae kg" href="https://dajos.azurewebsites.net/deploying-scipy-to-docker/#main.docker" rel="noopener ugc nofollow" target="_blank"><strong class="jm hj">main . docker</strong></a>—第二个<code class="du le lf lg lh b">Dockerfile</code>将从第一个和<code class="du le lf lg lh b">pip install --no-index -f /wheelhouse</code>中构建。这意味着，它将只使用我们在第一次构建中创建的<code class="du le lf lg lh b">.whl</code>包。这将大大减少在每次部署中将我们的需求安装到虚拟环境中所需的时间。</p><p id="df64" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">每个<code class="du le lf lg lh b">Dockerfile</code>的内容如下。</p><p id="0639" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">更进一步。我之前提到过CI工作。我为此部署创建了2个作业。主要工作是在部署之前负责运行<code class="du le lf lg lh b">main.docker</code>构建和测试。它还依赖于车轮作业。车轮作业将检查<code class="du le lf lg lh b">requirments.txt</code>自上次构建以来是否已被修改。如果是的话，那么当它编译轮子的时候，我们有一个很长的构建，但是几乎总是会跳过这个构建。</p><p id="8431" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">最终结果是，现在大多数部署只需要不到一分钟的时间(包括测试和发布),而从源代码开始完整构建需要大约30分钟。</p><h1 id="492b" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated"><code class="du le lf lg lh b">wheel.docker</code></h1><p id="3275" class="pw-post-body-paragraph jk jl hi jm b jn kz ij jp jq la im js jt lb jv jw jx lc jz ka kb ld kd ke kf hb bi translated">构建时，记得为<code class="du le lf lg lh b">main.docker</code>到<code class="du le lf lg lh b">FROM ...</code>进行适当标记。比如:<code class="du le lf lg lh b">docker build -t myapp/wheels/build -f wheel.docker .</code></p><pre class="iz ja jb jc fd li lh lj lk aw ll bi"><span id="c66d" class="lm ki hi lh b fi ln lo l lp lq"># [START docker]<br/>FROM google/python  <br/># [END docker]</span><span id="e690" class="lm ki hi lh b fi lr lo l lp lq"># [START system dependencies]<br/>RUN apt-get install -y \  <br/>    libpng-dev \<br/>    freetype* \<br/>    libblas-dev \<br/>    liblapack-dev \<br/>    libatlas-base-dev \<br/>    gfortran<br/># [END system dependencies]</span><span id="0b45" class="lm ki hi lh b fi lr lo l lp lq"># [START app environment]<br/>WORKDIR /app  <br/>ADD requirements.txt /app/requirements.txt  <br/>RUN virtualenv /env  <br/>RUN /env/bin/pip install --upgrade pip  <br/># [END app environment]</span><span id="3370" class="lm ki hi lh b fi lr lo l lp lq"># [START install &amp; configure wheel]<br/>RUN /env/bin/pip install wheel  <br/>ENV PIP_WHEEL_DIR=/wheelhouse  <br/>ENV WHEELHOUSE=/wheelhouse  <br/>ENV PIP_FIND_LINKS=/wheelhouse  <br/># [START install &amp; configure wheel]</span><span id="5ca5" class="lm ki hi lh b fi lr lo l lp lq">RUN while read p; do /env/bin/pip wheel $p; done &lt; requirements.txt</span></pre><h1 id="1f4c" class="kh ki hi bd kj kk kl km kn ko kp kq kr io ks ip kt ir ku is kv iu kw iv kx ky bi translated"><code class="du le lf lg lh b">main.docker</code></h1><p id="7e09" class="pw-post-body-paragraph jk jl hi jm b jn kz ij jp jq la im js jt lb jv jw jx lc jz ka kb ld kd ke kf hb bi translated">如果使用该文件，可能需要更改<code class="du le lf lg lh b">ENTRYPOINT</code>。</p><pre class="iz ja jb jc fd li lh lj lk aw ll bi"><span id="5fd9" class="lm ki hi lh b fi ln lo l lp lq"># [START docker]<br/>FROM myapp/wheels/build  <br/># [END docker]</span><span id="2421" class="lm ki hi lh b fi lr lo l lp lq"># [START configure app env]<br/>WORKDIR /app</span><span id="58c5" class="lm ki hi lh b fi lr lo l lp lq">RUN while read p; \  <br/>    do /env/bin/pip install --no-index -f /wheelhouse $p; \<br/>    done &lt; requirements.txt</span><span id="f01b" class="lm ki hi lh b fi lr lo l lp lq">ADD . /app  <br/># [END configure app env]</span><span id="8aa7" class="lm ki hi lh b fi lr lo l lp lq">EXPOSE 8080  <br/>CMD []</span><span id="8978" class="lm ki hi lh b fi lr lo l lp lq"># [START Application Definition]<br/>ENTRYPOINT ["/env/bin/python", "/app/wsgi.py"]  <br/># [END Application Definition]</span></pre></div></div>    
</body>
</html>