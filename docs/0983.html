<html>
<head>
<title>OpenCensus and SLOs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCensus和SLOs</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/opencensus-and-slos-93bfe54e25f3?source=collection_archive---------0-----------------------#2019-04-27">https://medium.com/google-cloud/opencensus-and-slos-93bfe54e25f3?source=collection_archive---------0-----------------------#2019-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="34bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCensus页面<a class="ae jd" href="https://opencensus.io/guides/debugging/incidents/" rel="noopener ugc nofollow" target="_blank">事件调试工作流程</a>给出了使用OpenCensus和相关开源工具的路线图，以准备支持生产中的应用程序，快速响应事件，评估范围和严重性，并确定原因。该页面包括一个关于使用OpenCensus监控服务水平目标的简短讨论，我想在这里更详细地研究一下。页面中使用的示例应用程序在Go <a class="ae jd" href="https://opencensus.io/guides/http/go/net_http/server/" rel="noopener ugc nofollow" target="_blank"> HTTP服务器集成</a>指南中提供。OpenCensus HTTP集成的好处在于，只需初始化导出器并注册HTTP集成视图，就可以获得应用程序代码的基本工具。Prometheus用作监控后端，用于存储和可视化OpenCensus收集的指标数据。其他监控后端，如<a class="ae jd" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>，也可以通过使用可插入的OpenCensus导出库或代理导出器与该应用程序一起使用。然而，Prometheus有一种方便的查询语言，可以用公式表示出用于计算服务水平指标的表达式。这就是我将在这里展示的。</p><p id="7a41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌<a class="ae jd" href="http://shop.oreilly.com/product/0636920041528.do" rel="noopener ugc nofollow" target="_blank">网站可靠性工程</a>书将<a class="ae jd" href="https://landing.google.com/sre/sre-book/chapters/service-level-objectives/" rel="noopener ugc nofollow" target="_blank">服务水平目标</a> (SLO)定义为“由SLI测量的服务水平的目标值或值的范围。”服务水平指标(SLI)是“所提供的服务水平的某个方面的定量测量”OpenCensus页面上给出的示例是在一分钟间隔内计算的成功HTTP响应与总响应的比率:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="f166" class="jn jo hi jj b fi jp jq l jr js">SLI = QPS_200 / QPS</span></pre><p id="e5b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中QPS_200是每秒有2xx(成功)响应的请求(查询), QPS是每秒的请求总数。这是一个非常简单的SLI，但有局限性。正如OpenCensus页面中提到的，黑盒探测器是更好的选择，可以更好地代表用户体验。无论如何，现在让我们从服务器上测量的成功率开始，看看它是如何处理SLO违规的。</p><h1 id="055a" class="jt jo hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">模拟SLO违规</h1><p id="1640" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">让我们假设我们将SLO设为99.9%。也就是说，如果少于99.9%的请求在一分钟内被成功返回，那么我们就离开了SLO。页面中的示例程序总是模拟成功的结果，这不是很令人兴奋，所以让我们更改它以生成一些错误。我们可以从均匀随机分布中产生误差，但这不像区域断电展开。低级别的后台错误可以很容易地通过重试来处理，通常不会导致停机。如果我们只离开SLO一分钟，对商业的影响不会太严重。大多数停机都是由于错误的配置推送、软件错误、相关服务故障或未包含的局部故障造成的。</p><p id="4e34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑未包含的局部故障。这些会导致级联故障的重大事故，对业务产生重大影响。例如，假设您有一个服务器故障，将流量转移到第二台服务器。但是，第二台服务器已经承载了大量负载，因此也会失败。失去两台服务器后，突然转移的负载会导致更多服务器停机。我们可以用<a class="ae jd" href="https://www.mit.edu/~kardar/teaching/projects/chemotaxis(AndreaSchmidt)/random.htm" rel="noopener ugc nofollow" target="_blank">随机行走</a>对此建模，而不是误差的随机均匀分布。二维空间中的随机行走就像一只昆虫在地面上随机游荡，不可预测地远离它的原点。我们可以用一个变量中随机增量的累积来模拟一维的随机行走。这就像现实生活一样，我们会得到随机的变化，它会逐渐偏离正常状态，越过一个可接受的点，到达一个不太可能回到原来可接受状态的值。</p><p id="a04b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于OpenCensus <a class="ae jd" href="https://opencensus.io/guides/http/go/net_http/server/" rel="noopener ugc nofollow" target="_blank"> Go HTTP服务器指南</a>中的示例代码，我们添加了一个模拟随机行走的函数。如果它超过了给定的阈值，那么我们返回一个失败。示例Go代码的第一个修改应该添加在import语句之后:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="3848" class="jn jo hi jj b fi jp jq l jr js">type randomWalkBool struct {</span><span id="759a" class="jn jo hi jj b fi kv jq l jr js">  maxInc, intVal, threshold int</span><span id="fdc0" class="jn jo hi jj b fi kv jq l jr js">}</span><span id="8752" class="jn jo hi jj b fi kv jq l jr js">func (rw *randomWalkBool) nextValue() bool {</span><span id="12e1" class="jn jo hi jj b fi kv jq l jr js">  rw.intVal += rand.Intn(rw.maxInc) — rw.maxInc / 2</span><span id="b596" class="jn jo hi jj b fi kv jq l jr js">  return rw.intVal &lt; rw.threshold</span><span id="0667" class="jn jo hi jj b fi kv jq l jr js">}</span></pre><p id="472f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该结构中的intVal字段存储一个累积量，该累积量随着对函数nextValue()的每次调用而随机变化。我们可以在主函数中实例化它，增量大小如下:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ec2e" class="jn jo hi jj b fi jp jq l jr js">func main() {</span><span id="1a4c" class="jn jo hi jj b fi kv jq l jr js">  rwSuccess := randomWalkBool{999, 0, 400}</span></pre><p id="3251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我花了一点实验来得出模拟失败的参数值，因为我没有研究随机行走的统计理论。当我们收到一个HTTP请求时，如果下一个值高于阈值，我们将返回一个服务器错误:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="cc70" class="jn jo hi jj b fi jp jq l jr js">originalHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {</span><span id="b067" class="jn jo hi jj b fi kv jq l jr js">  …</span><span id="0488" class="jn jo hi jj b fi kv jq l jr js">  if !rwSuccess.nextValue() {</span><span id="0a12" class="jn jo hi jj b fi kv jq l jr js">    http.Error(w, “You got unlucky”, http.StatusServiceUnavailable)</span><span id="4947" class="jn jo hi jj b fi kv jq l jr js">    return</span><span id="96f3" class="jn jo hi jj b fi kv jq l jr js">  }</span></pre><h1 id="efd8" class="jt jo hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在Prometheus中绘制服务水平指标</h1><p id="e155" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">请求速率可以使用<a class="ae jd" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank"> Prometheus查询语言</a>在1分钟的时间间隔内通过以下表达式进行计算:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b441" class="jn jo hi jj b fi jp jq l jr js">rate(ochttp_tutorial_opencensus_io_http_server_response_count_by_status_code[1m])</span></pre><p id="97e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请求率的图表视图如下所示。</p><figure class="je jf jg jh fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/b726e21ad52851dfcf1a28168733cd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WHWpvLbA4QGEinF5"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd ju">截图:普罗米修斯控制台</strong>中的请求率视图</figcaption></figure><p id="d406" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">绿线是错误率，红线是成功请求率。SLI的简单计算由直接翻译SLI公式的表达式给出:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="98e9" class="jn jo hi jj b fi jp jq l jr js">rate(ochttp_tutorial_opencensus_io_http_server_response_count_by_status_code{http_status=~”2.*”}[1m]) / rate(ochttp_tutorial_opencensus_io_http_server_response_count_by_status_code[1m])</span></pre><p id="3232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这方面的图表如下所示。</p><figure class="je jf jg jh fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/8ada5d41862c17404ed94c1a55cb65c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rp66tomraozZi35K"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd ju">截图:SLI的简单计算</strong></figcaption></figure><p id="478d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个有点令人失望的连续值1.0打破be没有价值。普罗米修斯最佳实践页面上的<a class="ae jd" href="https://prometheus.io/docs/practices/histograms/" rel="noopener ugc nofollow" target="_blank">直方图和摘要</a>提出了一个更好的公式:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ba35" class="jn jo hi jj b fi jp jq l jr js">sum(rate(ochttp_tutorial_opencensus_io_http_server_response_count_by_status_code{http_status=~”2.*”}[1m])) / sum(rate(ochttp_tutorial_opencensus_io_http_server_response_count_by_status_code[1m]))</span></pre><p id="e646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将生成以下图表:</p><figure class="je jf jg jh fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lj"><img src="../Images/de8c1cf187e6ae1c425af6ef40035b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5wBmf7EicNKSRTLg"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd ju">截图:SLI更好的计算</strong></figcaption></figure><p id="5dc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那看起来好多了。但是等等。我们出SLO了！下一步将是设置警报，这样你就可以发现你不在SLO，并迅速做出反应。</p></div></div>    
</body>
</html>