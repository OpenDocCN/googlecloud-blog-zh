<html>
<head>
<title>Designing CI/CD pipeline for folder-based Terraform code using Git Tags and Google Cloud Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Git标签和Google Cloud Build为基于文件夹的Terraform代码设计CI/CD管道</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/designing-ci-cd-pipeline-for-folder-based-terraform-code-using-git-tags-and-google-cloud-build-10283620ae78?source=collection_archive---------3-----------------------#2022-11-22">https://medium.com/google-cloud/designing-ci-cd-pipeline-for-folder-based-terraform-code-using-git-tags-and-google-cloud-build-10283620ae78?source=collection_archive---------3-----------------------#2022-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/072cb83949401831988bba1ad372e416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QgFLAgMQjxmKMc9d"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@craftedbygc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">绿色变色龙</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="96da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文假设读者有一些使用Terraform、GitHub和Google Cloud Build的经验。让我们快速更新一下关于Google Cloud Build的知识。Google Cloud Build是由Google提供的无服务器构建、测试和部署平台，可帮助用户:</p><ul class=""><li id="4555" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">跨所有编程语言快速构建软件，包括Java、Go、Node.js等等</li><li id="a107" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">跨多个环境部署，例如虚拟机、无服务器、Kubernetes或Firebase</li><li id="6847" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">在您的私有网络中访问云托管的完全受管CI/CD工作流</li><li id="046f" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">通过数据驻留将静态数据保留在某个地理区域或特定位置</li></ul><p id="a296" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要更详细地了解Google Cloud Build，请参考官方产品链接:</p><div class="kh ki ez fb kj kk"><a href="https://cloud.google.com/build" rel="noopener  ugc nofollow" target="_blank"><div class="kl ab dw"><div class="km ab kn cl cj ko"><h2 class="bd hj fi z dy kp ea eb kq ed ef hh bi translated">云构建无服务器CI/CD平台|谷歌云</h2><div class="kr l"><h3 class="bd b fi z dy kp ea eb kq ed ef dx translated">发送反馈在我们的无服务器CI/CD平台上构建、测试和部署。新客户可获得300美元的免费积分，用于…</h3></div><div class="ks l"><p class="bd b fp z dy kp ea eb kq ed ef dx translated">cloud.google.com</p></div></div><div class="kt l"><div class="ku l kv kw kx kt ky io kk"/></div></div></a></div><h1 id="addc" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">什么是“基于文件夹”的地形代码？</strong></h1><p id="d407" class="pw-post-body-paragraph iv iw hi ix b iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">让我们首先理解我们所说的“基于文件夹”的Terraform代码是什么意思。简单来说，基于文件夹的terraform代码将有多个文件夹，每个文件夹包含一些Terraform代码。文件夹通常用于隔离和独立管理属于不同应用程序或服务的Terraform代码。对于在彼此之间共享terraform输出的服务来说，将所有这些服务文件夹放在同一个Git存储库下是理想的。例如，我们可以为引导、资源管理、网络、安全和项目工厂服务对Terraform代码进行分组。所有这些文件夹都位于为设置登录区而创建的git存储库的根目录下。请参考下面的截图:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/b8d858cb9c3ba92dd26060e3034b940b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOHJrWxnKwmob5rFsCrQ1Q.png"/></div></div></figure><h1 id="e22d" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">挑战</strong></h1><p id="2b3b" class="pw-post-body-paragraph iv iw hi ix b iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">由于这种文件夹结构，我们将不得不进入每个文件夹并执行所需的Terraform命令。由于我们使用Google Cloud Build作为我们的CICD平台，我们需要一种方法来告诉Cloud Build它需要导航到哪个文件夹来运行terraform init，计划和应用命令。</p><p id="39ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是我们可以使用的不理想的替代方案或方法的总结:</p><ol class=""><li id="eca4" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mh jz ka kb bi translated">对于N个文件夹，我们可以创建相应的N个云构建触发器，每个触发器都有各自的文件夹路径，在<a class="ae iu" href="https://cloud.google.com/build/docs/configuring-builds/substitute-variable-values#using_user-defined_substitutions" rel="noopener ugc nofollow" target="_blank">用户定义的替换</a>中，如“_WORKSTREAM_PATH”。这些触发器的触发事件将是主分支或主分支的“推送至分支”。这种方法的问题在于它根本不是动态的。随着文件夹数量的增加，管理相应的云构建触发器变得越来越困难。此外，每当对主分支/主分支的提交被合并时，所有N个云构建触发器将被同时执行，而不管由此对其他服务的任何可能影响</li><li id="34c1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mh jz ka kb bi translated">创建以N个文件夹命名的N个分支也不是一个好主意，因为我们必须分别管理这N个分支。处理不断增加的文件夹数量和分支合并将是一场噩梦(仅举几例)</li></ol><h1 id="837d" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">解决方案</strong></h1><p id="ba4d" class="pw-post-body-paragraph iv iw hi ix b iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">如果我们仔细观察可用于云构建触发器的事件触发器选项，我们可以看到以下内容:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/59ca46efd45947a3a1c3e0e5b38dbaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrUzux-G2a0GFQ1I9DPA5w.png"/></div></div></figure><p id="3b92" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们探索“推送新标签”选项，会怎么样？</p><p id="72e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当git标签被推送到已经为其创建了云构建触发器的相应git存储库时,“Push new tag”事件调用云构建触发器。当git标签被推送到git存储库时，连接的云构建触发器在它的一个名为“$TAG_NAME”的替换中捕获标签名称。除了这种替换，云构建还捕获以下默认替换:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/ac8d288a4d701040c9624db6efe0bc17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EL8pAKyop7Keohfn0WlCfA.png"/></div></div></figure><p id="f457" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要了解更多关于云构建替换的信息，请点击这里的链接<a class="ae iu" href="https://cloud.google.com/build/docs/configuring-builds/substitute-variable-values" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="03cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于Cloud Build在替换“$TAG_NAME”中捕获标记名，我们可以用我们的Terraform文件夹之一来命名标记。这是传达云构建CICD管道应该使用哪个Terraform文件夹来运行所需的Terraform命令的一种非常容易和简单的方式。对于前面显示的文件夹结构图，git标记名可以采用以下格式:</p><ul class=""><li id="5d5c" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">02-联网-对等-201768</li><li id="6bf0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">00-自举测试</li><li id="27ad" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">03-项目-工厂-产品</li><li id="c4cf" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">02-安全-scc</li></ul><p id="33c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在云构建触发器中，我们可以使用以下正则表达式来确保只有所需的标记名调用云构建触发器:</p><p id="7c84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mk">(00-bootstrap | 01-resman | 02-networking-peering | 02-security | 03-project-factory)。* </em></p><p id="6576" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样的可以在下面的截图中看到:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/7fd10a6bc81e1ba96c310913c483b555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3FtyBQ1go_TtbqgRTkp5Mw.png"/></div></div></figure><p id="1662" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以再次确保使用带有以下正则表达式的简单shell命令从cloudbuild.yaml中的git标记获得正确的stage/folder名称:</p><pre class="md me mf mg fd mm mn mo bn mp mq bi"><span id="1be6" class="mr la hi mn b be ms mt l mu mv">$ echo "$TAG_NAME" | egrep -o "(00-bootstrap|01-resman|02-networking-peering|02-security|03-project-factory)" &gt; EXTRACTED_TAG</span></pre><h1 id="6eb2" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">完整的CI/CD战略</h1><p id="1262" class="pw-post-body-paragraph iv iw hi ix b iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">首先，我们需要为每个阶段/文件夹创建一个拉请求触发器。在这些触发器中，必须将_WORKSTREAM_PATH用户定义的替换设置为相应的阶段/文件夹。例如，如果我们有5个阶段，那么我们将需要相应的5个拉请求触发器。这些拉请求触发器将按特定顺序执行terraform init、terraform validate和terraform plan。</p><p id="ade0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们希望每个阶段/文件夹都有单独的拉请求触发器，以确保它们相互之间是解耦的。如果所有阶段都有一个管道/触发器，那么其中一个阶段的代码错误会阻塞整个管道，从而无法对其他阶段进行更改。解耦管道的变更可以在每个阶段独立展开。此外，如果我们只有一个用于所有阶段的CICD管道，将需要很多时间来完成它的执行。随着每个服务文件夹中资源数量的增加，CICD管道的执行时间会持续增加。</p><p id="1da5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cloud Build有一个方便的特性，我们可以将构建日志发送到GitHub，这样您就可以在pull请求中直接看到执行日志。下面的屏幕截图显示了启用的选项:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/75e54f6e6fb3e2e973a02f8f2f34eeea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObEWuX4415Xj1ZY0FTE5tg.png"/></div></div></figure><p id="9f58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们对terraform计划感到满意，我们就可以继续合并拉取请求。合并拉请求不会自动触发terraform应用管道。这是因为我们已经创建了一个云构建触发器，该触发器仅在推送git标签时被调用，而不是将提交推送到分支。</p><p id="135d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为了对您最近推送/合并的提交运行terraform apply，我们需要为相应的阶段/文件夹推送一个标记，该阶段/文件夹的更改请求是为其提出的。有两种方法可以做到这一点:</p><ol class=""><li id="35ff" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js mh jz ka kb bi translated">我们可以使用GitHub控制台发布带有所需标签的版本。<strong class="ix hj">注意:</strong>根本不需要创建一个发布来推送标签。只有在使用GitHub控制台时，这才是必需的</li><li id="c25f" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js mh jz ka kb bi translated">我们可以使用git命令来推送所需的标签。使用以下命令来完成此操作:</li></ol><pre class="md me mf mg fd mm mn mo bn mp mq bi"><span id="9496" class="mr la hi mn b be ms mt l mu mv">$ git tag &lt;tag_name&gt;<br/>$ git push origin &lt;tag_name&gt;</span></pre><p id="fc13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦推送标签，将调用云构建触发器，该触发器将使用标签名称导航到正确的文件夹，以执行terraform apply命令以及terraform init和terraform plan。</p><h1 id="a079" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">云构建yaml文件示例</strong></h1><h2 id="7065" class="mx la hi bd lb my mz na lf nb nc nd lj jg ne nf ln jk ng nh lr jo ni nj lv nk bi translated"><strong class="ak">拉请求yaml文件</strong></h2><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><h2 id="c8ed" class="mx la hi bd lb my mz na lf nb nc nd lj jg ne nf ln jk ng nh lr jo ni nj lv nk bi translated">推送标签yaml文件</h2><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure></div></div>    
</body>
</html>