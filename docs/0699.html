<html>
<head>
<title>Kubernetes All NodePorts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes所有节点端口</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-all-nodeports-885f17d192ba?source=collection_archive---------0-----------------------#2018-07-25">https://medium.com/google-cloud/kubernetes-all-nodeports-885f17d192ba?source=collection_archive---------0-----------------------#2018-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9eaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在为Hyperledger Fabric做一个更动态的舵图。这种动态性(可能)需要动态数量的节点端口。</p><p id="9c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">抛开</em> </strong> <em class="jd">:我仍然不确定是否每个对等体的服务都需要其端口以这种方式暴露在集群之外。</em></p><p id="3732" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，当我采用这种方法时，列举集群公开的所有节点端口对我来说很有用。您可能会对该代码感兴趣。如果没有别的，它显示了为Kubernetes 使用<a class="ae je" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> Go(lang)客户端是多么容易。</a></p><p id="cbf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两条路，当然</p><p id="e864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两者都源自客户回购中提供的集群外示例。</p><h2 id="a3cb" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">排序切片</h2><p id="bf5e" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">第一个排序切片。首先，在编写了基于树的解决方案(参见“第二个”)之后，我写了这个简化版。</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="603a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">消费者go-routine ( <code class="du km kn ko kp b">#63–75</code>)在包含集群的节点端口列表(可能是未排序的)的通道上进行搜索，将它们插入一个片，并对该片进行排序。单个结果被放在一个<code class="du km kn ko kp b">result</code>通道上，阻塞go例程，直到该消息的消费者读取它并返回结果，从而结束程序(<code class="du km kn ko kp b">#103</code>)。因为通道读|写被阻塞，所以没有必要等待go-routine。</p><p id="fd4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生产者go-routines ( <code class="du km kn ko kp b">#78–99</code>)形成一个层级。因为Kubernetes Go客户端允许枚举所有集群的服务，而不考虑名称空间，所以为每个服务创建一个Go例程。每个服务可能会公开n(？)NodePorts，虽然这个数字很小，但是对于giggles，我们创建了一个go-routine来处理它们中的每一个(可能很浪费！？).</p><p id="f8b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们检查服务之前，我们不知道它是否公开了节点端口，也不知道有多少。因此，当我们遍历服务和它们的端口时，我们为每个创建的go-routine增加一个WaitGroup，并且每个go-routine推迟(减少)WaitGroup的<code class="du km kn ko kp b">Done</code>。</p><p id="28fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du km kn ko kp b">Wait</code> ( <code class="du km kn ko kp b">#97</code>)上的代码块。一旦所有go-routines完成，代码将继续等待，下一步是<code class="du km kn ko kp b">close</code>通道。这就结束了消费者的(！)<code class="du km kn ko kp b">range</code> ( <code class="du km kn ko kp b">#71</code>)，它已经将端口(当它们到达时)附加到一个片上。切片被排序并返回。</p><h2 id="3844" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">行走的树木</h2><p id="7c2c" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">最初，我使用树(而不是切片)作为端口排序的基础。网上有很多例子，但我喜欢Golang在类型上的方法，在这种情况下，会使代码变得复杂。我心中的纯粹主义者认为树只是节点，但是我们必须先实例化一个类型(不能是<code class="du km kn ko kp b">nil</code>)然后才能对它使用方法，因此，我们将使用一个树类型，它的根属性是Node类型，然后是nodes类型:</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="332b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且:</p><figure class="kf kg kh ki fd kj"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="17d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了在<code class="du km kn ko kp b">main.go</code>的进口中引用<code class="du km kn ko kp b">useful.go</code>，唯一的变化是消费者的日常行为。我们现在使用一个<code class="du km kn ko kp b">Tree</code> ( <code class="du km kn ko kp b">#66</code>)，我们将<code class="du km kn ko kp b">Insert</code> ( <code class="du km kn ko kp b">#69</code>)移植到它，我们将<code class="du km kn ko kp b">Walk</code>它(<code class="du km kn ko kp b">#73</code>)的值排序。</p><p id="117f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行任何一种方法都应该(！)在您的<code class="du km kn ko kp b">current-context</code>的节点端口中打印集群的一部分。</p></div></div>    
</body>
</html>