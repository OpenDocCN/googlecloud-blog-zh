<html>
<head>
<title>On-Device Machine Learning: Train And Run TensorFlow Lite Models In Your Flutter Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设备上的机器学习:在你的Flutter应用中训练和运行TensorFlow Lite模型</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/on-device-machine-learning-train-and-run-tensorflow-lite-models-in-your-flutter-apps-15ea796e5ad4?source=collection_archive---------0-----------------------#2021-01-23">https://medium.com/google-cloud/on-device-machine-learning-train-and-run-tensorflow-lite-models-in-your-flutter-apps-15ea796e5ad4?source=collection_archive---------0-----------------------#2021-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="71ea" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用TensorFlow和Keras中的深度迁移学习构建、训练和运行图像分类器神经网络</h2></div></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9f70fc496faee6d275f995791c884d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvjCtpMGlXHQNhkebPgPnA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae ju" href="https://unsplash.com/@casparrubin" rel="noopener ugc nofollow" target="_blank">卡斯珀</a>在<a class="ae ju" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="jv jw jx"><p id="8f15" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">注意:在我写这篇文章的时候，Python的最新版本是3.9。但是，Tensorflow目前只兼容Python版本3.5–3.8。如果你有一个不兼容的Python版本，并且不想降级，你可以使用<a class="ae ju" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>，这是一个基于云的免费在线Jupyter笔记本环境。</p></blockquote></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h2 id="2129" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">本文将分为2个模块:</h2><ul class=""><li id="620b" class="lt lu hi kb b kc lv kf lw lg lx lk ly lo lz ku ma mb mc md bi translated"><strong class="kb hj">训练</strong>一个使用迁移学习的卷积神经网络能够<code class="du me mf mg mh b"><strong class="kb hj"><em class="ka">detect thirty plus different types of Fruits and Vegetables</em></strong></code>。</li><li id="c694" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">创建Flutter UI并导入。tflite文件到项目中，然后测试它并修复可能的错误。</li></ul></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h1 id="afed" class="mn kw hi bd kx mo mp mq lb mr ms mt lf io mu ip lj ir mv is ln iu mw iv lr mx bi translated">模块1:使用TensorFlow和Keras训练神经网络</h1><p id="d1c1" class="pw-post-body-paragraph jy jz hi kb b kc lv ij ke kf lw im kh lg my kk kl lk mz ko kp lo na ks kt ku hb bi translated"><strong class="kb hj">什么是Tensorflow？</strong> → TensorFlow是一个开源库，可以训练和运行深度神经网络(这是一系列机器学习和深度学习)，用于图像识别、单词嵌入、自然语言处理等。下载→<a class="ae ju" href="https://www.tensorflow.org/install" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/install</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nb"><img src="../Images/329d56cd6a91a8cf81e19f6d757ee465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*__zjiM5RAWyNvf6CfMlzbw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">到本文结束时，你将能够制作这个应用程序并在你的手机上运行</figcaption></figure><blockquote class="jv jw jx"><p id="b761" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">首先下载包含所有图像的<strong class="kb hj">数据集</strong>。<strong class="kb hj">我们的神经网络将从这些图像中训练、学习和验证</strong>。你可以从kaggle.com点击<a class="ae ju" href="https://www.kaggle.com/kritikseth/fruit-and-vegetable-image-recognition" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hj">这里</strong> </a>下载我要用的那个。然后提取。zip文件和<strong class="kb hj">在<strong class="kb hj">同一个目录</strong>下创建一个Python Jupyter笔记本</strong>。</p></blockquote><blockquote class="nc"><p id="346a" class="nd ne hi bd nf ng nh ni nj nk nl ku dx translated">可以从我的GitHub Repo→<a class="ae ju" href="https://git.io/JLhpv" rel="noopener ugc nofollow" target="_blank">https://git.io/JLhpv</a>中找到并克隆完整的项目供个人使用</p><p id="8dba" class="nd ne hi bd nf ng nm nn no np nq ku dx translated"><strong class="ak">开始编程吧(Python Jupyter笔记本):</strong></p></blockquote><figure class="nr ns nt nu nv jj"><div class="bz dy l di"><div class="nw nx l"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元格1(导入模块)</figcaption></figure><ul class=""><li id="f131" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">os</strong></code>模块将为我们提供<strong class="kb hj">函数</strong>，用于读取目录内容和写入目录。</li><li id="11f2" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">将<code class="du me mf mg mh b"><strong class="kb hj">base_dir</strong></code> <strong class="kb hj"> </strong>变量设置为包含训练图像的数据集的位置。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ob"><img src="../Images/20a1cdc633fe6a278e58e61dbbe6c577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ol4VffkBEHXglgI6Qb2fhA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元2(预处理，我们准备原始数据以适合构建和训练模型)</figcaption></figure><ul class=""><li id="63b0" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">IMAGE_SIZE = 224</strong></code> →我们要将数据集中的图像设置为的图像尺寸。</li><li id="678f" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">BATCH_SIZE = 64</strong></code> →我们一次输入神经网络的图像数量。</li><li id="2f22" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">rescale=1./255</strong></code> <strong class="kb hj"> </strong>减小文件大小，减少训练时间。</li><li id="898a" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">数据集有一个测试集和一个训练集。验证集通常用于验证我们的神经网络，为我们提供神经网络表现如何的准确性度量。所以对于<code class="du me mf mg mh b"><strong class="kb hj">validation_split=0.2</strong></code>，我们告诉Keras用20%进行验证，80%进行培训</li><li id="75aa" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">然后我们有两个生成器(<code class="du me mf mg mh b"><strong class="kb hj">train_generator</strong></code>和<code class="du me mf mg mh b"><strong class="kb hj">val_generator</strong></code>)，它们获取目录&amp;的路径，生成批量的扩充数据，在这种情况下给出输出:<em class="ka">找到属于36个类的2872个图像，找到属于36个类的709个图像。</em></li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es oc"><img src="../Images/6e999b555864b377b69e06728451b41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMdkuM1-skNn0chH43BqCg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元格3(创建一个包含所有标签的labels.txt文件)</figcaption></figure><ul class=""><li id="e24c" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated">打印数据集的所有键和类(标签),重新检查是否一切正常。</li><li id="69df" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">旋舞需要两个文件:<strong class="kb hj"><em class="ka">labels . txt</em></strong><em class="ka">和</em><strong class="kb hj"><em class="ka">model . tflite</em></strong><em class="ka">。</em></li><li id="968b" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">代码中的<code class="du me mf mg mh b"><strong class="kb hj">‘w’</strong></code>创建一个名为<strong class="kb hj"><em class="ka">labels . txt</em></strong><em class="ka">的新文件，该文件具有标签</em>，如果已经存在，则覆盖它。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es od"><img src="../Images/11d1e34151282241997630f24c6ff8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EO-RCLZp14Zildkq4lCx9g.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元3的输出</figcaption></figure><p id="6c52" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">既然我们已经成功地预处理了原始数据，<strong class="kb hj">是时候开始使用迁移学习来构建我们实际的神经网络了</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es oe"><img src="../Images/e43a0b60153d644e6feac5f60c46c67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tltEaXsJY29rrHrUT_vSlQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者:Yashwardhan Deshmukh</figcaption></figure><p id="6b70" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated"><strong class="kb hj">迁移学习→ </strong>它是一种机器学习方法，我们<strong class="kb hj">在已经预先训练好的神经网络的基础上构建一个神经网络。</strong></p><p id="8e7c" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">基本上，神经网络已经在一些其他任务上受过训练，因此它有助于更有效地理解第二项任务的模式。你可以把它想象成教一个新生的孩子(传统的数学学习)和一个成年人(迁移学习)。</p><p id="b2d2" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">在这里，我们将使用<a class="ae ju" href="https://ai.googleblog.com/2018/04/mobilenetv2-next-generation-of-on.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hj"> MobileNetV2 </strong> </a>，这是一个预训练的CNN(卷积神经网络)架构，可以很好地执行设备上的机器学习，可以预测多达80个不同的类别。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es of"><img src="../Images/55304a6160c527c5efe1a9507836e4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_0_Rk9EXuLZtIOor63HOQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元4(创建迁移学习的基础模型)</figcaption></figure><ul class=""><li id="ea26" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated">我们从抓取MobileNetV2开始。</li><li id="42ce" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">由于我们不想重新训练预训练的CNN，而是添加到它上面，所以使用了<code class="du me mf mg mh b"><strong class="kb hj">include_top=False</strong></code> →这将冻结所有权重，在这种情况下，用于进行预测的模型的全连接输出层不会被加载，从而允许添加和训练新的输出层。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es og"><img src="../Images/d6d6f9c44f1edf05bba83369fd5e2c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTDUc7-CR_3pVj4tu4E2nQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元格5(向NN添加层)</figcaption></figure><ul class=""><li id="5a6f" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">base_model.trainable=False</strong></code> <strong class="kb hj"> </strong> → <strong class="kb hj"> </strong>冻结我们基础模型的所有神经元。</li><li id="c5ad" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">神经网络在一系列层中起作用，因此现在我们将添加我们自己的层:</li></ul><ol class=""><li id="d90d" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">Conv2D</strong></code>是一个2D卷积层，它创建了一个卷积核，这是一个带有层输入的风，有助于产生输出张量。基本上，它试图理解图像的模式。<code class="du me mf mg mh b"><a class="ae ju" href="https://keras.io/api/layers/activations/#relu-function" rel="noopener ugc nofollow" target="_blank"><em class="ka">‘relu’</em></a></code> <em class="ka"> </em>代表<em class="ka"> </em>整流线性单元激活功能。</li><li id="b58d" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">Dropout</strong></code> <strong class="kb hj"> </strong>层防止神经网络<strong class="kb hj">过拟合</strong>，即过于精确到神经网络只能识别数据集中存在的图像而不能识别其他图像的程度。</li><li id="b40c" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">GlobalAveragePooling2D</strong></code> <strong class="kb hj"> </strong>层计算上一层各特征图的平均输出，从而大幅减少数据，为最后一层做模型准备。</li><li id="75e5" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku oh mb mc md bi translated">层是深度连接的层，其中每个神经元接收来自其前一层的所有神经元的输入。<em class="ka">'</em><strong class="kb hj"><em class="ka">36 '</em></strong>这里代表班级的人数。<strong class="kb hj"> <em class="ka"> </em> </strong> <code class="du me mf mg mh b"><a class="ae ju" href="https://keras.io/api/layers/activations/#softmax-function" rel="noopener ugc nofollow" target="_blank"><em class="ka">‘softmax’</em></a></code>将实数向量转换为分类概率向量。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es oi"><img src="../Images/81e54119b2dfaa360cf6b52a306aade1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4Gb1Mb9GCcfRWUT7MCpdA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元6(在离开模型进行训练之前编译模型)</figcaption></figure><ul class=""><li id="4298" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated">我们使用<code class="du me mf mg mh b"><strong class="kb hj">model.compile</strong></code> <strong class="kb hj"> → </strong>，其中<strong class="kb hj"> </strong>定义了损失函数、优化器和度量，因为需要一个<strong class="kb hj">编译的模型</strong>来训练(因为训练使用损失函数和优化器)。</li><li id="599b" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">我们将使用<code class="du me mf mg mh b"><strong class="kb hj">Adam</strong></code>，它是一个流行的优化器，专门为训练深度神经网络而设计。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es oj"><img src="../Images/830e6d8bec9119f46b7c5beb92faf8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GP6IL-6ymUBh0_NhotvNQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元7(训练！)</figcaption></figure><ul class=""><li id="d466" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">epochs</strong></code> →学习算法迭代并遍历整个训练数据集的次数。数值越高，神经网络越精确，但是……数值太高会导致<strong class="kb hj"> <em class="ka">过拟合</em> </strong>，即过于精确，以至于神经网络只能识别数据集中存在的图像，而不能识别其他图像。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ok"><img src="../Images/4c4585363b1e7d07038618971c84540a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEv_6T2Nqt8LlV3rO7GwWQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元7的输出(训练过程，需要一些时间，去做瑜伽)</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ol"><img src="../Images/4e807671724e86345754623c65efb868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCpXBlTxCFwSIIVUeJ8CLw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码单元8(将训练好的神经网络转换成Tensorflow Lite文件)</figcaption></figure><ul class=""><li id="46b0" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">saved_model_dir = ‘’</strong></code> <strong class="kb hj"> → </strong>其中“”表示当前目录。</li><li id="32c2" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">tf.saved_model.save(model, saved_model_dir)</strong></code>→保存到当前目录。</li><li id="c26f" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">接下来的两行<strong class="kb hj">将我们的模型转换成. tflite模型，</strong>由flutter用于设备上的ML。</li><li id="4758" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">最后，我们将转换后的模型写入目录，<strong class="kb hj">为二进制</strong>所以添加<code class="du me mf mg mh b"><strong class="kb hj"><em class="ka">‘wb’</em></strong></code> <strong class="kb hj"> <em class="ka"> </em> </strong>而不是仅仅<code class="du me mf mg mh b"><strong class="kb hj"><em class="ka">‘w’</em></strong></code> <strong class="kb hj"> <em class="ka">。</em> </strong></li><li id="b7f7" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">如果您使用的是Google Colab，请将其添加为额外的代码单元格:</li></ul><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="64d7" class="kv kw hi mh b fi oq or l os ot">#use these codes to download files locally if using google colab<br/>from google.colab import files<br/>files.download(‘model.tflite’)<br/>files.download(‘labels.txt’)</span></pre><p id="69ea" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">现在我们已经有了<strong class="kb hj"><em class="ka">‘model . tflite’</em></strong>和<strong class="kb hj"><em class="ka">‘labels . txt’</em></strong>文件，我们可以将它们导入到一个Flutter项目中了！如果你不知何故搞砸了，你可以从我的GitHub Repo的assets文件夹下载这些文件→【https://git.io/JLhpv T42】</p></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h1 id="9e73" class="mn kw hi bd kx mo mp mq lb mr ms mt lf io mu ip lj ir mv is ln iu mw iv lr mx bi translated">模块2:在Flutter应用程序中导入和使用model.tflite。</h1><p id="0f3e" class="pw-post-body-paragraph jy jz hi kb b kc lv ij ke kf lw im kh lg my kk kl lk mz ko kp lo na ks kt ku hb bi translated">转到'<em class="ka"> Visual Studio代码&gt;视图&gt;命令调色板&gt; Flutter新应用程序项目'</em>或者直接转到终端，导航到目录，然后键入'<code class="du me mf mg mh b">flutter create project_name</code> <em class="ka"> ' </em></p><p id="d500" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">接下来，转到<em class="ka">‘pub spec . YAML’，添加以下依赖项，并保存:</em></p><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="711e" class="kv kw hi mh b fi oq or l os ot">dependencies:<br/>  flutter:<br/>    sdk: flutter<br/>  <strong class="mh hj">tflite:</strong> ^1.1.1<br/>  <strong class="mh hj">image_picker:</strong> ^0.6.7+4</span></pre><blockquote class="jv jw jx"><p id="7761" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">为了使tflite能够工作<em class="hi">，在</em> <code class="du me mf mg mh b"><em class="hi">android/app/build.gradle</em></code> <em class="hi">中，在</em> <code class="du me mf mg mh b"><em class="hi">android</em></code> <em class="hi">块中添加以下设置。</em></p></blockquote><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="4e05" class="kv kw hi mh b fi oq or l os ot">aaptOptions {<br/>        noCompress 'tflite'<br/>        noCompress 'lite'<br/>    }</span></pre><blockquote class="jv jw jx"><p id="9a1c" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">为了使image_picker工作，在 <code class="du me mf mg mh b"><em class="hi">/ios/Runner/Info.plist</em></code> <em class="hi">中的<em class="hi">，添加以下内容到您的</em> <code class="du me mf mg mh b"><em class="hi">Info.plist</em></code> <em class="hi">文件中。</em></em></p></blockquote><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="15f2" class="kv kw hi mh b fi oq or l os ot">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;<br/>&lt;string&gt;Need Camera Access&lt;/string&gt;<br/>&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;<br/>&lt;string&gt;Need Microphone Access&lt;/string&gt;<br/>&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;<br/>&lt;string&gt;Need Photo Accesss&lt;/string&gt;</span></pre><p id="e5d4" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">现在是时候创建一个简单的应用程序了，它显示用户的图像和预测，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nb"><img src="../Images/329d56cd6a91a8cf81e19f6d757ee465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*__zjiM5RAWyNvf6CfMlzbw.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ou"><img src="../Images/0ed42b80493217f2ad6d059e5c496189.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*360UT0ZbxWguy3qCehTmiA.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">它也预测香蕉？！</figcaption></figure><ul class=""><li id="ebe2" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated">在'<em class="ka"> main.dart </em>'文件中，返回带有参数<em class="ka"> home: Home()，</em>的MaterialApp</li><li id="2a12" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku ma mb mc md bi translated">然后创建一个新的“<em class="ka"> home.dart </em>”文件，该文件具有有状态类home()。这将是我们的主页。<strong class="kb hj">让我们开始制作功能性的颤振App: </strong></li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ov"><img src="../Images/3e85422039714b7996b20397df1d537c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*qYbZyQGuoYlYsaU6bx7OUg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">假设您已经导入了素材、tflite、image_picker和dart:io</figcaption></figure><p id="2aab" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated"><code class="du me mf mg mh b"><strong class="kb hj"><em class="ka">_loading</em></strong></code> →用于检查是否选择了图像，<code class="du me mf mg mh b"><strong class="kb hj">_image</strong></code> →选择的图像，<strong class="kb hj"> </strong> <code class="du me mf mg mh b"><strong class="kb hj">_output</strong></code> →预测完成，<code class="du me mf mg mh b"><strong class="kb hj">picker</strong></code> →允许我们从图库或摄像机中选择图像。</p><p id="7872" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">接下来，我们将为这个类编写6种不同的方法:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ow"><img src="../Images/677ff1b04c3522ff96dbf6a26a582906.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*1ZK4YcU6VeZlgQqeVTKbdw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">前两种方法</figcaption></figure><ul class=""><li id="095c" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated"><em class="ka">前2种方法:</em></li></ul><ol class=""><li id="bc87" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">initState()</strong></code> →这是<em class="ka">第一个方法</em>，当创建Home小部件时调用，即启动应用程序并导航到Home()，在实际构建小部件本身之前，initState()函数内的任何内容都将首先被调用或初始化，小部件稍后构建。在这种情况下，我们将使用<em class="ka"> loadModel()，</em>加载我们的模型，这是稍后将编写的另一个方法。之后，我们将传入一个值。</li><li id="6e65" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">dispose()</strong></code> <strong class="kb hj"> → </strong>这种方法处理和清除我们的记忆。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ox"><img src="../Images/a111700ffab6bc24da183e9e59ca2b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhP5QH3hgATvcbA1hIcMRA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">最后4种方法</figcaption></figure><ul class=""><li id="f062" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku ma mb mc md bi translated"><em class="ka">最后4种方法:</em></li></ul><p id="676d" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">3.<code class="du me mf mg mh b"><strong class="kb hj">classifyImage()</strong></code> <strong class="kb hj"> </strong> →该方法对图像运行分类模型。<em class="ka"> numResults </em>是我们拥有的类的数量，然后添加setState来保存更改。</p><p id="abb6" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">4.<code class="du me mf mg mh b"><strong class="kb hj">loadModel()</strong></code> →这个函数将加载我们的模型，因此我们将它放在<em class="ka"> initS </em>方法中。</p><p id="df5f" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">5.<code class="du me mf mg mh b"><strong class="kb hj">pickImage()</strong></code> →该功能用于从相机中抓取图像。</p><p id="3b85" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">6.<code class="du me mf mg mh b"><strong class="kb hj">pickGalleryImage()</strong></code> <strong class="kb hj"> </strong> →该功能用于从用户图库中抓取图像。</p><h2 id="da13" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">扑UI时间！</strong></h2><blockquote class="jv jw jx"><p id="1925" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这部分代码是基本的UI。对于那些了解它如何工作的人可以跳过它，自己写！</p></blockquote><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es oy"><img src="../Images/ae5ceb129002f15e278873100cab5aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6gen3mXN5ERLiIisdY2Gg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">用户界面的第一部分</figcaption></figure><p id="8a59" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">首先，我们必须制作<strong class="kb hj">应用程序栏</strong>，然后制作保存图像的<strong class="kb hj">容器</strong>。在这里，我们将使用<strong class="kb hj">三元运算符</strong> ( <code class="du me mf mg mh b">condition<strong class="kb hj"> ?</strong> true statement <strong class="kb hj">:</strong> false statement</code>)到<strong class="kb hj">来显示一个图像和一个文本小部件，前提是_loading设置为true，_output设置为not null </strong>，否则我们将显示一个空白容器。</p><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="9e97" class="kv kw hi mh b fi oq or l os ot">  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      appBar: AppBar(<br/>        backgroundColor: Colors.black,<br/>        title: Text(<br/>          <strong class="mh hj">'Fruits and Veggies Neural Network'</strong>,<br/>          style: TextStyle(<br/>              color: Colors.white,<br/>              fontWeight: FontWeight.w200,<br/>              fontSize: 20,<br/>              letterSpacing: 0.8),<br/>        ),),</span></pre><blockquote class="jv jw jx"><p id="8646" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">那是AppBar。现在让我们制作一个容器来保存用户选择的图像！</p></blockquote><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="afbe" class="kv kw hi mh b fi oq or l os ot"><br/>      body: Container(<br/>        color: Colors.black.withOpacity(0.9),<br/>        padding: EdgeInsets.symmetric(horizontal: 35, vertical: 50),<br/>        child: Container(<br/>          alignment: Alignment.center,<br/>          padding: EdgeInsets.all(30),<br/>          decoration: BoxDecoration(<br/>            color: Color(0xFF2A363B),<br/>            borderRadius: BorderRadius.circular(30),<br/>          ),<br/>          child: Column(<br/>            mainAxisAlignment: MainAxisAlignment.center,<br/>            children: [<br/>              Container(<br/>                child: Center(<br/>                 <strong class="mh hj"> child: _loading == true<br/>                      ? null</strong> <strong class="mh hj">//show nothing if no picture selected</strong><br/>                      : Container(<br/>                          child: Column(<br/>                            children: [<br/>                              Container(<br/>                                height: 250, width: 250,<br/>                                child: ClipRRect( </span></pre><blockquote class="jv jw jx"><p id="5f0e" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">ClipRRect用于为图像提供圆形边框。</p></blockquote><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="8f80" class="kv kw hi mh b fi oq or l os ot">                                  borderRadius:<br/>                                  BorderRadius.circular(30),<br/>                                  <strong class="mh hj">child:</strong> <strong class="mh hj">Image.file(<br/>                                    _image,</strong><br/>                                    fit: BoxFit.fill,<br/>                                  ),),),<br/>                              Divider(<br/>                                height: 25,thickness: 1,<br/>                              ),<br/>                            <strong class="mh hj">  _output != null<br/>                                  ? Text(</strong><br/>                                     <strong class="mh hj"> 'The object is: ${_output[0]<br/>                                                      ['label']}!',</strong><br/>                                      style: TextStyle(<br/>                                          color: Colors.white,<br/>                                          fontSize: 18,<br/>                                          fontWeight:<br/>                                          FontWeight.w400),<br/>                                    )<br/>                                  <strong class="mh hj">: Container(),</strong><br/>                              Divider(<br/>                                height: 25,<br/>                                thickness: 1,<br/>                              ),],),),),),<br/>                                                      //code contd..</span></pre><p id="c24b" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">接下来，我们制作两个手势检测器，它们分别引用pickImage和pickGalleryImage函数。</p><blockquote class="jv jw jx"><p id="07ee" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">注意:<code class="du me mf mg mh b">onTap</code>里面的<code class="du me mf mg mh b">pickImage</code>(不带括号)是一个函数引用，基本意思是不立即执行，是在用户点击特定的widget之后执行。(回拨)</p><p id="fe25" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><code class="du me mf mg mh b">pickImage()</code>是一个函数调用，它被立即执行。</p></blockquote><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es oz"><img src="../Images/5b62055b337a654a91059c79622a6af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*QIgwplwvJQhHeajR27f_Hg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">UI的第二部分，手势检测器！</figcaption></figure><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="01ad" class="kv kw hi mh b fi oq or l os ot">              Container(<br/>                child: Column(<br/>                  children: [<br/>                    GestureDetector(<br/>                      <strong class="mh hj">onTap: pickImage, </strong>//no parenthesis<br/>                      child: Container(<br/>                        width: <br/>                        MediaQuery.of(context).size.width - 200,<br/>                        alignment: Alignment.center,<br/>                        padding:<br/>                        EdgeInsets.symmetric(horizontal: 24,<br/>                                             vertical: 17),<br/>                        decoration: BoxDecoration(<br/>                            color: Colors.blueGrey[600],<br/>                            borderRadius:<br/>                            BorderRadius.circular(15)),<br/>                        child: Text(<br/>                          <strong class="mh hj">'Take A Photo'</strong>,<br/>                          style: TextStyle(color: Colors.white,<br/>                                           fontSize: 16),<br/>                        ),),),<br/>                    SizedBox(<br/>                      height: 30,<br/>                    ),<br/>                    GestureDetector(<br/>                      <strong class="mh hj">onTap: pickGalleryImage, </strong>//no parenthesis<br/>                      child: Container(<br/>                        width: <br/>                        MediaQuery.of(context).size.width - 200,<br/>                        alignment: Alignment.center,<br/>                        padding:<br/>                        EdgeInsets.symmetric(horizontal: 24,<br/>                                             vertical: 17),<br/>                        decoration: BoxDecoration(<br/>                            color: Colors.blueGrey[600],<br/>                            borderRadius:<br/>                            BorderRadius.circular(15)),<br/>                        child: Text(<br/>                          <strong class="mh hj">'Pick From Gallery',</strong><br/>                          style: TextStyle(color: Colors.white,<br/>                                                  fontSize: 16),<br/>                        ),),),],),),],),),),);}}</span></pre><p id="f0a2" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated"><em class="ka">搞定！现在保存并在模拟器或真实手机上运行它！</em></p><p id="d704" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">自己测试一下；每当从相机胶卷中选择或实时点击一张类似神经网络已经学习过的任何类别的图像时，应用程序都应该输出结果！</p><blockquote class="jv jw jx"><p id="0ecc" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这只是深度学习的一个非常基本的用途。它真的向我们展示了人工神经网络对人类来说是多么大的福气，如果掌握了它，人类就可以实现从未想象过的事情……也许有一天会有飞行服或汽车？</p></blockquote></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h1 id="32e0" class="mn kw hi bd kx mo mp mq lb mr ms mt lf io mu ip lj ir mv is ln iu mw iv lr mx bi translated">调试时间！</h1><blockquote class="jv jw jx"><p id="74bd" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><strong class="kb hj">一些常见的错误(包括我个人遇到的)，以及如何修复:</strong></p></blockquote><ol class=""><li id="87a9" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">‘Lexical or Preprocessor Issue ‘…’ file not found’</strong></code></li><li id="ee24" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">‘IOS Xcode Build error : ‘metal_delegate.h’ file not found’</strong></code></li><li id="b81b" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">‘vector’ file not found</strong></code></li><li id="b912" class="lt lu hi kb b kc mi kf mj lg mk lk ml lo mm ku oh mb mc md bi translated"><code class="du me mf mg mh b"><strong class="kb hj">‘tensorflow/lite/kernels/register.h’ file not found</strong></code></li></ol><p id="4af1" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">在我写这篇文章的时候，这些错误在尝试使用Xcode在iOS设备上签名和构建应用程序时非常常见。</p><blockquote class="jv jw jx"><p id="340a" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><strong class="kb hj">修复:</strong></p></blockquote><ol class=""><li id="1ffd" class="lt lu hi kb b kc kd kf kg lg ny lk nz lo oa ku oh mb mc md bi translated">导航到<code class="du me mf mg mh b">project_file/ios</code>，用任意文本编辑器打开<code class="du me mf mg mh b">podfile.lock</code>，将TensorFlowLiteC的值设置为(2.2.0)，如下所示</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es pa"><img src="../Images/02982b4d7423e83528c59540d964022f.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*06O6UsYxYwyPTDFEtlPOBg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">文字编辑器</figcaption></figure><p id="eda3" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">2.然后启动<em class="ka">终端</em>并键入以下内容:</p><pre class="jf jg jh ji fd om mh on oo aw op bi"><span id="d707" class="kv kw hi mh b fi oq or l os ot">cd project_directory_here/<br/>cd ios/<br/>pod install</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es pb"><img src="../Images/a7f7e501a9c5228b9a72c92ad501939c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDosqwZQU3OiFUXtqXRZHQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">终端输出</figcaption></figure><p id="20cd" class="pw-post-body-paragraph jy jz hi kb b kc kd ij ke kf kg im kh lg kj kk kl lk kn ko kp lo kr ks kt ku hb bi translated">3.最后，进入<code class="du me mf mg mh b">project_file/ios</code>文件夹，在Xcode中启动<code class="du me mf mg mh b">Runner.xcworkspace</code>，然后是<code class="du me mf mg mh b">click Runner &gt; Targets &gt; Runner &gt; Build Settings, search Compile Sources As, change the value to Objective-C++</code></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es pc"><img src="../Images/c950f0203d25680c66a25786d0b6f51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmwBOrvO2HUZieWL2HMxXg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">这应该可以修复没有找到的“矢量”文件</figcaption></figure><blockquote class="jv jw jx"><p id="60a5" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">要修复第四个错误，请从Xcode的errors部分显示的<code class="du me mf mg mh b">TflitePlugin.mm</code>文件中取消对<code class="du me mf mg mh b">//#define CONTRIB_PATH</code>的注释。</p></blockquote></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><blockquote class="jv jw jx"><p id="97e5" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">感谢阅读，我希望你学到了一些东西！任何意见、疑问或建议对我来说都是非常有价值的。</p><p id="20da" class="jy jz ka kb b kc kd ij ke kf kg im kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><a class="ae ju" href="https://github.com/yaashwardhan" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> GitHub </em> </a></p></blockquote></div></div>    
</body>
</html>