<html>
<head>
<title>BigQuery: delta to latest — all history</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery:从增量到最新-所有历史</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-delta-to-latest-all-history-c8f28f889c91?source=collection_archive---------1-----------------------#2020-07-16">https://medium.com/google-cloud/bigquery-delta-to-latest-all-history-c8f28f889c91?source=collection_archive---------1-----------------------#2020-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="41ff" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">挑战</h1><p id="9ed4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">构建在<a class="ae kb" rel="noopener" href="/google-cloud/bigquery-deltas-to-latest-e84999fdb311"> BigQuery: delta to latest </a>之上，而不是进行多次更改并找到我们想要的最新值<strong class="jf hj">来捕捉随时间的更改。</strong></p><p id="054d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">不使用<a class="ae kb" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg" rel="noopener ugc nofollow" target="_blank"> ARRAY_AGG </a>，而是使用<a class="ae kb" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#last_value" rel="noopener ugc nofollow" target="_blank"> LAST_VALUE </a>作为分析函数。</p><h1 id="9d85" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决方案</h1><h2 id="5075" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">测试数据</h2><p id="e97b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们将创建一组名为testing.sparsedata的测试数据。这将有一个唯一的键<strong class="jf hj"> id </strong>，一个时间戳<strong class="jf hj"> ts </strong>，以及包含随机数据或NULL的列<strong class="jf hj"> c1 </strong>到<strong class="jf hj"> c9 </strong>。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1b81" class="kh ig hi la b fi le lf l lg lh">CREATE OR REPLACE TABLE `testing.sparsedata` AS<br/>SELECT<br/>  CAST(FLOOR(RAND()*1000) AS INT64) AS id,<br/>  TIMESTAMP_ADD(<br/>    CURRENT_TIMESTAMP(),<br/>    INTERVAL CAST(FLOOR(RAND()*1000) AS INT64) SECOND) AS ts,<br/>  IF(RAND()&gt;0.75, CAST(RAND() AS STRING), NULL) AS c1,<br/>  IF(RAND()&gt;0.75, CAST(RAND() AS STRING), NULL) AS c2,<br/>  IF(RAND()&gt;0.75, CAST(RAND() AS STRING), NULL) AS c3,<br/>  IF(RAND()&gt;0.75, CAST(RAND() AS STRING), NULL) AS c4,<br/>  IF(RAND()&gt;0.75, CAST(RAND() AS STRING), NULL) AS c5,<br/>  IF(RAND()&gt;0.75,<br/>    CONCAT("id=", CAST(RAND() AS STRING)),<br/>    NULL) AS c6,<br/>  IF(RAND()&gt;0.75,<br/>    CONCAT("id=", CAST(RAND() AS STRING)),<br/>    NULL) AS c7,<br/>  IF(RAND()&gt;0.75,<br/>    CONCAT("id=", CAST(RAND() AS STRING)),<br/>    NULL) AS c8,<br/>  IF(RAND()&gt;0.75,<br/>    CONCAT("id=", CAST(RAND() AS STRING)),<br/>    NULL) AS c9<br/>FROM<br/>  UNNEST(GENERATE_ARRAY(1, 1000000)) AS d</span></pre><h2 id="00a9" class="kh ig hi bd ih ki kj kk il kl km kn ip jo ko kp it js kq kr ix jw ks kt jb ku bi translated">询问</h2><p id="935e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">将该数据转换为一系列记录，其中对于每一列<strong class="jf hj"> c1 </strong>到<strong class="jf hj"> c9 </strong>，它具有<strong class="jf hj">最近的非空数据</strong>可以用LAST_VALUE和IGNORE NULLs分析函数来完成。</p><p id="e970" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在这种情况下，命名窗口也用于简化SQL的编写，但也可能是一种优化，即窗口可以只计算一次。</p><p id="64bb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">查询如下所示:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7329" class="kh ig hi la b fi le lf l lg lh">SELECT<br/>  id,<br/>  ts,<br/>  LAST_VALUE(c1 IGNORE NULLS) OVER (sparse_data) AS c1,<br/>  LAST_VALUE(c2 IGNORE NULLS) OVER (sparse_data) AS c2,<br/>  LAST_VALUE(c3 IGNORE NULLS) OVER (sparse_data) AS c3,<br/>  LAST_VALUE(c4 IGNORE NULLS) OVER (sparse_data) AS c4,<br/>  LAST_VALUE(c5 IGNORE NULLS) OVER (sparse_data) AS c5,<br/>  LAST_VALUE(c6 IGNORE NULLS) OVER (sparse_data) AS c6,<br/>  LAST_VALUE(c7 IGNORE NULLS) OVER (sparse_data) AS c7,<br/>  LAST_VALUE(c8 IGNORE NULLS) OVER (sparse_data) AS c8,<br/>  LAST_VALUE(c9 IGNORE NULLS) OVER (sparse_data) AS c9<br/>FROM<br/>  `testing.sparsedata`<br/>WINDOW sparse_data AS (<br/>  PARTITION BY id<br/>  ORDER BY ts ASC<br/>  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW<br/>)</span></pre><h1 id="ab0d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="df2f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用分析函数可以实现类似的效果，如ARRAY_AGG，包括填充稀疏数据。</p></div></div>    
</body>
</html>