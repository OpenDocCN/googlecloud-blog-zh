<html>
<head>
<title>Compression of data over HTTP on Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Cloud上基于HTTP的数据压缩</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/compression-of-data-over-http-on-google-cloud-9833d183b2ba?source=collection_archive---------0-----------------------#2018-09-12">https://medium.com/google-cloud/compression-of-data-over-http-on-google-cloud-9833d183b2ba?source=collection_archive---------0-----------------------#2018-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e952" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">背景</h1><p id="02bc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">云用户有时会想，是否有比gzip更有效的方法来压缩web上的文本和JSON数据。首先，我们来看看用gzip怎么做。</p><p id="566e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果一个App Engine HTTP客户端发送一个值为gzip的Accept-Encoding头，那么它将压缩返回的内容(<a class="ae kg" href="https://cloud.google.com/appengine/docs/standard/go/how-requests-are-handled#response_compression" rel="noopener ugc nofollow" target="_blank"> documentation </a>)。目前，gzip是App Engine唯一直接支持的选项。这类似于NGINX的开箱即用。HTTP/2用<a class="ae kg" href="https://httpwg.org/specs/rfc7541.html" rel="noopener ugc nofollow" target="_blank"> HPACK </a>替换了gzip，因为使用gzip ( <a class="ae kg" href="https://http2.github.io/faq/#why-hpack" rel="noopener ugc nofollow" target="_blank"> doc </a>)的压缩HTTP流发现了安全漏洞。然而，这只是针对HTTP头。QUIC利用一种类似于HTTP/2的方法来处理报头。</p><p id="b3eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要验证您的服务器是否正在返回gzip内容，请使用Curl命令，如</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0f39" class="kq ig hi km b fi kr ks l kt ku">curl -H "Accept-Encoding: gzip" -I <a class="ae kg" href="http://localhost:8080/test.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/test.json</a></span></pre><p id="3a54" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">假设您的服务器在本地主机上运行。您应该会看到类似这样的输出</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3881" class="kq ig hi km b fi kr ks l kt ku">Content-Encoding: gzip</span></pre><p id="0e9f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这个要点给出了设置Nginx服务器来压缩JSON文件的说明。默认情况下，HTML文件应该被压缩。</p><h1 id="082f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">布罗特利</h1><p id="62fd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kg" href="https://tools.ietf.org/html/rfc7932" rel="noopener ugc nofollow" target="_blank"> Brotli </a> (br)可以提供比gzip大得多的压缩，但压缩效率可能较低(<a class="ae kg" href="https://www.opencpu.org/posts/brotli-benchmarks/" rel="noopener ugc nofollow" target="_blank">简单比较</a>)。因此，它可能比动态创建的应用程序数据更适合经常读取的文件。但是，Brotli也可以控制压缩级别，这可以为您的应用程序提供最佳平衡。Google开源了Brotli ( <a class="ae kg" href="https://github.com/google/brotli" rel="noopener ugc nofollow" target="_blank"> github项目</a>)，列出了更详细的基准。Brotli由<a class="ae kg" href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet" rel="noopener ugc nofollow" target="_blank"> Cronet </a>网络客户端库支持，适合在移动应用中使用。在Cronet中，Brotli默认不启用，但是可以通过调用<a class="ae kg" href="https://chromium.googlesource.com/chromium/src/+/lkgr/components/cronet/android/api/src/org/chromium/net/CronetEngine.java#175" rel="noopener ugc nofollow" target="_blank"> enableBrotli(true) </a>来启用。</p><p id="1554" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Brotli也受到主流浏览器的支持。Mozilla文档给出了正确的HTTP头来使用</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="da3a" class="kq ig hi km b fi kr ks l kt ku">Accept-Encoding: br</span></pre><p id="cd8b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">虽然，GCP并不直接支持Brotli，但Brotli的一个开源Nginx插件(<a class="ae kg" href="https://github.com/google/ngx_brotli" rel="noopener ugc nofollow" target="_blank">这里</a>)可以与Docker镜像(<a class="ae kg" href="https://github.com/fholzer/docker-nginx-brotli" rel="noopener ugc nofollow" target="_blank">这里</a>)一起使用。这对于带有定制容器的Flex和Kubernetes来说应该足够了。在<a class="ae kg" href="https://gist.github.com/alexamies/71f17f878a1efb764e631920ac3b7076" rel="noopener ugc nofollow" target="_blank">本要点</a>中提供了使用和验证的简单说明。在Nginx服务器配置完成后，您应该能够使用以下命令验证它是否返回Brotli压缩数据</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3874" class="kq ig hi km b fi kr ks l kt ku">curl -H "Accept-Encoding: br" -I <a class="ae kg" href="http://localhost:8080/test.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/test.json</a><br/>...<br/>Content-Encoding: br</span></pre></div></div>    
</body>
</html>