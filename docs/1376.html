<html>
<head>
<title>A multi-cluster gRPC architecture on GKE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GKE上的多集群gRPC架构</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-multi-cluster-grpc-architecture-on-gke-365bbd757df?source=collection_archive---------0-----------------------#2020-04-16">https://medium.com/google-cloud/a-multi-cluster-grpc-architecture-on-gke-365bbd757df?source=collection_archive---------0-----------------------#2020-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="090e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章解释了如何在不同地区的许多GKE集群中对gRPC应用程序进行负载平衡，以提高性能和可用性。</p><h1 id="fb20" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">语境</h1><p id="3a6a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><a class="ae kg" href="https://kaggle.com" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的后端团队负责制作<a class="ae kg" href="https://www.kaggle.com/kernels" rel="noopener ugc nofollow" target="_blank"> Kaggle笔记本</a>，一个托管数据科学环境，快速可靠。它同时提供几千台笔记本电脑。</p><p id="5ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去的一年中，该团队一直致力于重新设计整个堆栈。目标是让产品以更好的性能和可靠性保持可伸缩性。</p><p id="89c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的架构由微服务组成，使用<a class="ae kg" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>作为主要的通信机制。他们部署在谷歌Kubernetes引擎上(<a class="ae kg" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> GKE </a>)。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/57daff313b000aaca4de2ed8bc93eabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfNVGJRCkpQe46R-KPI6Tg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">从一个区域性GKE集群(实线)到多集群(虚线)</figcaption></figure><p id="6c81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，我们使用单个GKE集群，但现在我们扩展到在世界许多地区使用多个集群。这项工作将进一步帮助我们的用户获得更好的性能，并使我们的产品具有更好的可用性。</p><p id="8476" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章的其余部分解释了我们如何将我们的主API(调度程序，它根据用户请求调度新的Kaggle笔记本)从单个集群转移到多集群。</p><h1 id="10f6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">单个集群的设置</h1><p id="5242" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将从查看为单个集群设置调度器API所需的几个组件开始:云端点和健康检查。</p><h2 id="0b80" class="kx je hi bd jf ky kz la jj lb lc ld jn iq le lf jr iu lg lh jv iy li lj jz lk bi translated">云端点</h2><p id="23f9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><a class="ae kg" href="https://cloud.google.com/endpoints" rel="noopener ugc nofollow" target="_blank">云端点</a>是一款帮助部署、保护和监控API的产品。</p><p id="6c68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用它主要是因为它的认证特性。它还提供监控、日志记录和配额管理，无需额外设置。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ll"><img src="../Images/9f4bdd00deafd9643542b912d1e8f028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzUjG57v9zB5rhYp4jXqAA.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">云端点和ESP容器</figcaption></figure><p id="e4a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从技术上讲，可扩展服务代理(<a class="ae kg" href="https://cloud.google.com/endpoints/docs/openapi/specify-proxy-startup-options" rel="noopener ugc nofollow" target="_blank"> ESP </a>)容器处理传入的请求，并将经过身份验证的请求转发给主应用程序容器。云端点管理ESP配置。</p><p id="35fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将单集群设置的云端点配置放在一边(我们将在多集群设置中回到这一点)，并将重点放在这个pod的Kubernetes部署配置上。</p><pre class="ki kj kk kl fd lm ln lo lp aw lq bi"><span id="2329" class="kx je hi ln b fi lr ls l lt lu">spec:<br/>  containers:<br/>  - name: esp<br/>    image: gcr.io/endpoints-release/endpoints-runtime:1<br/>    args: [<br/>      "--ssl_port=443",<br/>      "--service=SERVICE_NAME.endpoints.PROJECT_ID.cloud.goog",<br/>      "--rollout_strategy=managed",<br/>      "--backend=grpc://127.0.0.1:8091"<br/>    ]<br/>    ports:<br/>    - containerPort: 443<br/>    volumeMounts:<br/>    - mountPath: /etc/nginx/ssl<br/>      name: nginx-ssl<br/>      readOnly: true<br/>  - name: session-scheduler<br/>    image: gcr.io/PROJECT_ID/session-scheduler:ENV<br/>    ports:<br/>    - containerPort: 8091<br/>  volumes:<br/>  - name: nginx-ssl<br/>    secret:<br/>      secretName: nginx-ssl</span></pre><p id="3d7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个设置中有两个容器:ESP容器和主应用程序容器。ESP容器在<a class="ae kg" href="https://cloud.google.com/endpoints/docs/openapi/enabling-ssl" rel="noopener ugc nofollow" target="_blank"> `ssl_port` </a>上接受请求，然后将经过身份验证的请求转发给主应用程序容器(<code class="du lv lw lx ln b">backend</code>)。该卷包含来自Kubernetes secret的SSL密钥和证书。</p><p id="bebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照本<a class="ae kg" href="https://cloud.google.com/endpoints/docs/grpc/get-started-kubernetes-engine" rel="noopener ugc nofollow" target="_blank">教程</a>为单个集群在GKE上设置gRPC的云端点。对于单个区域集群，选择一个LoadBalancer 类型的<a class="ae kg" href="https://cloud.google.com/kubernetes-engine/docs/how-to/exposing-apps#creating_a_service_of_type_loadbalancer" rel="noopener ugc nofollow" target="_blank">服务。</a></p><h2 id="b7b2" class="kx je hi bd jf ky kz la jj lb lc ld jn iq le lf jr iu lg lh jv iy li lj jz lk bi translated">健康检查</h2><p id="9fc8" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于单集群设置，在让负载平衡器选择这个pod之前，您需要确保应用程序正确地服务于流量。</p><p id="a9d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现这一点，我们首先将<a class="ae kg" href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" rel="noopener ugc nofollow" target="_blank"> gRPC健康检查协议</a>集成到protobuf中，并在我们的应用程序中实现它。</p><p id="c690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，我们修改了云端点配置，将HTTP代码转换为gRPC代码。我们在这里做的关键事情是添加健康API，使用<a class="ae kg" href="https://cloud.google.com/endpoints/docs/grpc-service-config/reference/rpc/google.api#google.api.HttpRule" rel="noopener ugc nofollow" target="_blank"> http规则</a>对该API进行代码转换，并允许对健康检查端点进行未注册的调用。</p><pre class="ki kj kk kl fd lm ln lo lp aw lq bi"><span id="8c2f" class="kx je hi ln b fi lr ls l lt lu">type: google.api.Service<br/>config_version: 3<br/>name: SERVICE_NAME<br/>title: Kaggle Session Scheduler<br/>endpoints:<br/>- name: SERVICE_NAME<br/>  target: IP_ADDRESS<br/>apis:<br/>- name: APPLICATION_API<br/>- name: <strong class="ln hj">grpc.health.v1.Health</strong><br/>usage:<br/>  rules:<br/>  - selector: "*"<br/>    allow_unregistered_calls: false<br/>  - selector: "<strong class="ln hj">grpc.health.v1.Health.Check</strong>"<br/>    allow_unregistered_calls: true<br/>authentication:<br/>  providers:<br/>  - id: customer<br/>    issuer: SERVICE_ACCOUNT<br/>    jwks_uri: <a class="ae kg" href="https://www.googleapis.com/robot/v1/metadata/x509/SERVICE_ACCOUNT" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/robot/v1/metadata/x509/SERVICE_ACCOUNT</a><br/>  rules:<br/>  - selector: "*"<br/>    requirements:<br/>      - provider_id: customer<br/>  - selector: grpc.health.v1.Health.Check<br/>    allow_without_credential: true<br/>http:<br/>  rules:<br/>  - selector: <strong class="ln hj">grpc.health.v1.Health.Check</strong><br/>    get: <strong class="ln hj">/v1/health</strong></span></pre><p id="e802" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们为ESP容器配置了就绪性和活性探测器。为此打开了<code class="du lv lw lx ln b">http_port</code>。</p><pre class="ki kj kk kl fd lm ln lo lp aw lq bi"><span id="c92e" class="kx je hi ln b fi lr ls l lt lu">spec:<br/>  containers:<br/>  - name: esp<br/>    image: gcr.io/endpoints-release/endpoints-runtime:1<br/>    args: [<br/>      "--ssl_port=443",<br/>      "<strong class="ln hj">--http_port=9000</strong>",<br/>      "--service=SERVICE_NAME.endpoints.PROJECT_ID.cloud.goog",<br/>      "--rollout_strategy=managed",<br/>      "--backend=grpc://127.0.0.1:8091"<br/>    ]<br/>    ports:<br/>    - containerPort: 443<br/>    <strong class="ln hj">- containerPort: 9000<br/>    livenessProbe:<br/>      httpGet:<br/>        path: /v1/health<br/>        port: 9000<br/>    readinessProbe:<br/>      httpGet:<br/>        path: /v1/health<br/>        port: 9000</strong><br/>    volumeMounts:<br/>    - mountPath: /etc/nginx/ssl<br/>      name: nginx-ssl<br/>      readOnly: true</span></pre><p id="3ebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种配置，探测器不仅检查ESP容器是否在为流量提供服务，还检查应用程序容器是否在响应。</p><p id="ce02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，探测器还应该检查<code class="du lv lw lx ln b">SERVING</code>状态，或者确保健康检查端点以错误状态响应。</p><h1 id="a2ba" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">多个集群的设置</h1><p id="cc8d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们来看看这篇文章的本质:在许多集群上部署这个应用程序。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ly"><img src="../Images/e1c475e30c5129f15ddde0660c862d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*6elBJawXV3yR1JFSmEnl_A.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">集群故障转移</figcaption></figure><p id="8758" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将改善:</p><ul class=""><li id="f8ba" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">可用性:通过增加总有一个集群/ GCP区域能够满足请求的概率</li><li id="cd90" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated">性能:通过更接近消费者的服务请求</li></ul><h2 id="926d" class="kx je hi bd jf ky kz la jj lb lc ld jn iq le lf jr iu lg lh jv iy li lj jz lk bi translated">Anthos的入口</h2><p id="e26e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">谷歌云最近发布了用于Anthos (测试版)的“<a class="ae kg" href="https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-for-anthos" rel="noopener ugc nofollow" target="_blank">入口”，这是一个用于GKE集群的云托管多集群入口控制器。这为我们提供了一个单一的HTTP负载平衡器，其中不同区域的多个GKE集群作为LB后端。这一切都是通过部署和管理GCP负载平衡器的MultiClusterIngress和MultiClusterService资源来控制的。</a></p><p id="a5ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">团队从设置和注册集群开始，然后在入口配置集群中启用API。配置集群是在全球范围内部署入口构造的集中位置。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mn"><img src="../Images/76f8ba2c50de723454cf567d29b3c0b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mSDxhgl4ekbPOumyLZ84Q.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">配置群集、多群集回归和多群集服务</figcaption></figure><p id="9ef7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个构造是<strong class="ih hj"> MultiClusterIngress </strong>，它定义了要使用的协议终止和全局IP地址。</p><pre class="ki kj kk kl fd lm ln lo lp aw lq bi"><span id="7326" class="kx je hi ln b fi lr ls l lt lu">apiVersion: networking.gke.io/v1beta1<br/>kind: MultiClusterIngress<br/>metadata:<br/>  name: session-scheduler-mci<br/>  annotations:<br/>    networking.gke.io/static-ip: GLOBAL_IP_ADDRESS<br/>spec:<br/>  template:<br/>    spec:<br/>      backend:<br/>        serviceName: session-scheduler-svc<br/>        servicePort: 443<br/>      tls:<br/>      - secretName: session-scheduler-tls</span></pre><p id="3912" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> MultiClusterService </strong>定义了要在Kubernetes集群中创建的服务。重要的部分是:<code class="du lv lw lx ln b">HTTP2</code>应用协议和后端配置的定义。目标端口是电潜泵容器的<code class="du lv lw lx ln b">ssl_port</code>。</p><pre class="ki kj kk kl fd lm ln lo lp aw lq bi"><span id="5a93" class="kx je hi ln b fi lr ls l lt lu">apiVersion: networking.gke.io/v1beta1<br/>kind: MultiClusterService<br/>metadata:<br/>  name: session-scheduler-svc<br/>  annotations:<br/>    beta.cloud.google.com/backend-config: '{"ports": {"ssl":"session-scheduler-svc-backend"}}'<br/>    networking.gke.io/app-protocols: '{"ssl":"HTTP2"}'<br/>spec:<br/>  template:<br/>    spec:<br/>      selector:<br/>        app: session-scheduler<br/>      ports:<br/>      - name: ssl<br/>        protocol: TCP<br/>        port: 443<br/>        targetPort: 443</span></pre><p id="e4a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> BackendConfig </strong>用于定义健康检查端点。注意，我们使用ESP容器的<code class="du lv lw lx ln b">HTTPS</code>端点，它同时服务于gRPC和转换后的HTTP健康端点。</p><pre class="ki kj kk kl fd lm ln lo lp aw lq bi"><span id="7316" class="kx je hi ln b fi lr ls l lt lu">apiVersion: cloud.google.com/v1beta1<br/>kind: BackendConfig<br/>metadata:<br/>  name: session-scheduler-svc-backend<br/>spec:<br/>  healthCheck:<br/>    requestPath: /v1/health<br/>    type: HTTPS</span></pre><p id="727f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在黄金集群中应用这两个构造之后，<a class="ae kg" href="https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-for-anthos#verifying_status" rel="noopener ugc nofollow" target="_blank">检查状态</a>，直到创建了负载平衡器。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mo"><img src="../Images/5306d2703cc31031bcb3f3c2fbc06cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DrST0nBfiYLFgoLt_OAVg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">负载平衡器状态</figcaption></figure><h1 id="4c58" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="8eb8" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在应用程序的早期阶段，在特定区域使用单个GKE集群可能就足够了。但是当您需要提高服务的性能和/或可用性时，您应该考虑扩展到许多集群和区域。</p><p id="6045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您弄清楚gRPC的健康检查策略后，Anthos产品的Ingress使这一步变得非常简单。诀窍是使用ESP容器的<code class="du lv lw lx ln b">ssl_port</code>。</p></div></div>    
</body>
</html>