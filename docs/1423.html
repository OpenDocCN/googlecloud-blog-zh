<html>
<head>
<title>Google Cloud Data Catalog and Tableau integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google云数据目录和Tableau集成</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-data-catalog-and-tableau-integration-204c1d17cc62?source=collection_archive---------0-----------------------#2020-05-13">https://medium.com/google-cloud/google-cloud-data-catalog-and-tableau-integration-204c1d17cc62?source=collection_archive---------0-----------------------#2020-05-13</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="2789" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">利用数据目录发现和注释Tableau资产</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/6bd9a3efbc1abea3a173f0253f034f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7S_BNQ4Z1dHWO5NXEFu9Gw.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">背景照片由<a class="ae jo" href="https://unsplash.com/@laurenmancke?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">劳伦·曼克</a>在<a class="ae jo" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="d69b" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di"> T </span>谷歌云数据目录团队最近宣布<a class="ae jo" href="https://cloud.google.com/blog/products/data-analytics/data-catalog-metadata-management-now-generally-available" rel="noopener ugc nofollow" target="_blank">其产品现已正式发布，并准备接受定制(即用户定义)条目</a>！这一全新功能为集成开辟了空间，现在用户可以利用<a class="ae jo" href="https://towardsdatascience.com/boosting-the-data-governance-journey-with-google-cloud-data-catalog-d67acc3e3ffb" rel="noopener" target="_blank"> Data Catalog众所周知的潜力</a>来管理几乎任何类型的数据资产的元数据。</p><p id="4141" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">为了演示其工作原理，我将在这篇博文中分享将数据目录连接到市场领先的商业智能/数据可视化工具的设计思想和示例代码，包括<a class="ae jo" href="https://www.tableau.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hk"> Tableau </strong> </a>元数据集成。它们来自于参与开发完全可操作的<strong class="jr hk">样本连接器</strong>、<strong class="jr hk">、</strong>的经验，可在<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-bi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上公开获得。</p><blockquote class="ku kv kw"><p id="711c" class="jp jq kx jr b js jt ik ju jv jw in jx ky jz ka kb kz kd ke kf la kh ki kj kk hc bi translated"><strong class="jr hk">免责声明:在本文撰写之时(2020年5月)，谷歌和/或谷歌云不正式支持任何将数据目录连接到非GCP系统的工具。您将在这里发现的仅仅是我作为数据目录早期采用者的经验的结果。</strong></p></blockquote></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="04bf" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">技术要求</h1><p id="e52e" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">让我们从实现集成的最低技术要求开始:</p><ol class=""><li id="62a1" class="mf mg hj jr b js jt jv jw jy mh kc mi kg mj kk mk ml mm mn bi translated">from Tableau:允许对属于托管在给定服务器/实例中的资产的元数据进行读访问；</li><li id="84d2" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mk ml mm mn bi translated">从数据目录:允许用户接收代表Tableau管理的资产的元数据；</li><li id="16fd" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mk ml mm mn bi translated">连接器:<strong class="jr hk">从Tableau实例中抓取</strong>元数据的组件，<strong class="jr hk">准备</strong>适合数据目录的实体模型的信息，<strong class="jr hk">接收</strong>准备好的元数据。</li></ol><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et mt"><img src="../Images/10c32d5c22244587a067ce5a5dbad00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*We2xTniElVXP0ceGzcfhJg.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片1 </strong>。架构概述:集成数据目录和表格</figcaption></figure><p id="b74e" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">由于1和2已经由Tableau和Google Cloud提供，我们的重点是开发一个软件组件来解决第三个问题。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="8773" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">适应不同的概念</h1><p id="5841" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">这种集成的第一步是将业务实体从源系统映射到目标系统。<strong class="jr hk">选择了三种Tableau类型来说明这一点:工作簿、工作表和仪表板</strong>。</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et mu"><img src="../Images/8a4342fc9f34af12949f3bcb87f56027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMp8PcBWnIEfy_PhTuGIqQ.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片二</strong>。数据目录和表格集成:调整实体模型</figcaption></figure><p id="73c1" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我们需要调整这样的类型，以适应更通用的数据目录模型。所有这些类型的Tableau资产都将变成目录中的条目，因为<strong class="jr hk">条目</strong>是那里的一等公民。它们将通过添加到<code class="dv mv mw mx my b">Entry</code>类的新的<code class="dv mv mw mx my b">userSpecifiedType</code>属性来区分，我们将在下面看到。</p><p id="22bc" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">但是Tableau实体的属性比目录条目所能支持的要多得多……在这种情况下，我们可以使用<strong class="jr hk">标签</strong>来注释它们，避免遗漏有意义的信息。标签基于<strong class="jr hk">模板</strong>，这意味着我们将利用三种数据目录主要类型来实现目标。顺便说一句，我想你至少对它们有一个基本的了解。万一你没有，请看一下 <a class="ae jo" rel="noopener" href="/google-cloud/data-catalog-hands-on-guide-a-mental-model-dae7f6dd49e"> <em class="kx">这篇博文</em> </a> <em class="kx">。</em></p><p id="09e3" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">当涉及到实体关联和父/子关系时，有一个缺失的部分。例如，工作簿包含多个表和仪表板；同时，它依赖于数据库表来检索信息。数据目录目前不提供对在自定义类型中构建这种关系的本机支持。同样，标签可以帮助我们绘制地图。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="810e" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">在Tableau REST和元数据API之间做出选择</h1><p id="ce25" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">Tableau提供了不同的方式来访问他们服务器上的内容——其中包括所谓的<strong class="jr hk"> REST </strong>和<strong class="jr hk">元数据</strong>API。鉴于此，我们需要决定哪一个将用于<em class="kx">构建带有数据目录的桥梁</em>。</p><p id="6f41" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">REST API更加成熟，允许用户使用HTTP以编程方式管理和更改Tableau服务器资源。一般来说，它允许我们检索比元数据API更少的信息。</p><p id="5fa7" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><a class="ae jo" href="https://help.tableau.com/v0.0/api/metadata_api/en-us/index.html" rel="noopener ugc nofollow" target="_blank">元数据API </a>更新更强大，因为它允许用户从Tableau资产中读取更全面的元数据集合，包括<strong class="jr hk">血统信息</strong>！是的，它带来了您正在评估的资产和由Tableau或外部系统(如数据库服务器)管理的其他项目之间的关系。</p><p id="0d13" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">它们之间还有一个显著的技术差异:REST API端点(或资源)可以通过标准的HTTP请求访问，例如GET、POST等等。另一方面，元数据API由GraphQL提供支持。</p><blockquote class="mz"><p id="6f47" class="na nb hj bd nc nd ne nf ng nh ni kk dy translated">像REST APIs一样，GraphQL也是通过HTTP服务的。但是，您可以向一个端点发送一个查询，然后对其进行过滤，只返回您请求的内容，而不是向多个端点发送请求以返回感兴趣的数据。GraphQL服务器与一个端点相关联。<a class="ae jo" href="https://help.tableau.com/v0.0/api/metadata_api/en-us/index.html#differences-between-using-graphql-and-rest" rel="noopener ugc nofollow" target="_blank">Tableau元数据API简介</a></p></blockquote><p id="80de" class="pw-post-body-paragraph jp jq hj jr b js nj ik ju jv nk in jx jy nl ka kb kc nm ke kf kg nn ki kj kk hc bi translated">大概你猜到了元数据API更适合我们的需求。你是对的！据我们调查，除了<em class="kx">认证用户</em>和<em class="kx">检索属于给定Tableau服务器</em>的站点列表之外，它提供了我们实现集成所需的99%。所以，事实上，我们两个API都需要…</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="0454" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">连接到Tableau</h1><p id="acb6" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">一旦大致的场景已经呈现，是时候看看一些实际的东西了。本文的代码片段是用Python编写的。</p><p id="44a7" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">在做任何事情之前，我们需要认证，而<strong class="jr hk"> REST API </strong>是以编程方式完成认证的关键。在这种情况下，普通的HTTP请求就足够了:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="no np l"/></div></figure><p id="4fb6" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">上述方法返回一个访问令牌，该令牌必须在后续请求中作为<code class="dv mv mw mx my b">X-Tableau-Auth</code>头提供。</p><blockquote class="ku kv kw"><p id="b654" class="jp jq kx jr b js jt ik ju jv jw in jx ky jz ka kb kz kd ke kf la kh ki kj kk hc bi translated"><strong class="jr hk">旁注</strong>:虽然<a class="ae jo" href="https://github.com/tableau/server-client-python" rel="noopener ugc nofollow" target="_blank">Python客户端是可用的</a>，但是我们决定不依赖它，因为我们与那个API的交互很少。</p></blockquote><p id="43f4" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">将使用类似的方法从<strong class="jr hk">元数据API </strong>中检索信息(顺便说一下，这个API没有客户端库)。下面的片段展示了它是如何工作的:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="no np l"/></div></figure><p id="5272" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">请注意GraphQL是如何简化从相关对象中检索信息的(第5行到第14行)。在这种情况下,<em class="kx">工作簿</em>是主要实体，但是相同的查询可以用于获取其<em class="kx">工作表</em>。输入查询具有特定的格式；响应来自标准JSON。</p><p id="b3e2" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我们将在下一节看到元数据API的更多细节。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="6d3e" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">抓取Tableau元数据</h1><p id="b7e9" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">在编写GraphQL查询时，理解Tableau实体如何相互关联是很有帮助的。我相信一张图片胜过千言万语，所以让我将来自<a class="ae jo" href="https://help.tableau.com/v0.0/api/metadata_api/en-us/reference/" rel="noopener ugc nofollow" target="_blank">元数据API引用</a>的一些信息“转录”到一个图表中:</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et nq"><img src="../Images/b4b662afd06b934ee6ad3f9f8ea6ed1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqTKuZt-CrEYNgGC1OjMSg.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片3 </strong>。属于Tableau元数据模型的类的子集</figcaption></figure><p id="c0ad" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我们可以基于这样一个模型编写一个更复杂的查询:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="no np l"/></div></figure><p id="509c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">上述示例中真正重要的是什么？</p><ul class=""><li id="d99e" class="mf mg hj jr b js jt jv jw jy mh kc mi kg mj kk nr ml mm mn bi translated">第2行，<code class="dv mv mw mx my b">tableauSites</code> : GraphQL允许以基于关系的方式获取资产的元数据。因此，我们可以编写查询来从顶级资产(站点)检索信息，到较低级的资产(如表和数据库表);</li><li id="8228" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated">第6行，<code class="dv mv mw mx my b">workbooks</code>:站点可能有工作簿，如果发生这种情况，这个查询将检索所请求的工作簿的信息；</li><li id="656e" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated">第12行，<code class="dv mv mw mx my b">sheets</code>:同第6行，但引用的是工作簿与其表的关系；</li><li id="1235" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated">第19行，<code class="dv mv mw mx my b">upstreamTables</code>:从概念上讲，这种关系与前面的关系有点不同，工作簿可能依赖于资产来获取数据，但是它们并不拥有这样的资产。<em class="kx">在本文中,“表格”一词是指通常由外部系统拥有/管理的资产，如数据库服务器甚至Microsoft Excel </em>。还请注意<code class="dv mv mw mx my b">upstream</code>前缀——它表示Tableau元数据模型中的<strong class="jr hk">沿袭快捷方式</strong>。沿袭快捷方式从上游的<em class="kx">或下游</em>的<em class="kx">开始，可能指内部或外部资产。</em></li></ul><blockquote class="mz"><p id="423a" class="na nb hj bd nc nd ns nt nu nv nw kk dy translated">例如，您可以使用<code class="dv mv mw mx my b">upstreamTablesConnection</code>来查询数据源使用的表，或者使用<code class="dv mv mw mx my b">downstreamSheetsConnection</code>来查询工作簿使用的表。<a class="ae jo" href="https://help.tableau.com/v0.0/api/metadata_api/en-us/docs/meta_api_model.html#other-objects-related-to-tableau-content-and-assets" rel="noopener ugc nofollow" target="_blank">了解元数据模型</a></p></blockquote><ul class=""><li id="c5ae" class="mf mg hj jr b js nj jv nk jy nx kc ny kg nz kk nr ml mm mn bi translated"><em class="kx">第25行，</em> <code class="dv mv mw mx my b"><em class="kx">dashboards</em></code> <em class="kx">:可惜没有(还没有？)…在撰写本文时(2020年1月)，元数据API不支持提取嵌套在父工作簿中的仪表板。因此，需要一个额外的查询来抓取它们的元数据。</em></li></ul><p id="c281" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">如果以上概念对您来说很清楚，那么您就可以通过查询Tableau元数据API来获取任何类型的元数据了。是时候前进了！</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="37e9" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">准备数据目录的元数据</h1><p id="74bc" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">此时，我们有知识从Tableau中收集我们需要的所有信息。创建条目似乎是将它们转换成数据目录实体的良好起点，因为其他一切都依赖于它们。</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="no np l"/></div></figure><p id="edab" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><em class="kx">以</em> <code class="dv mv mw mx my b"><em class="kx">__</em></code> <em class="kx">开头的方法代表助手类的东西，不在代码片段的范围内。</em></p><p id="f383" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">上面的代码是不言自明的(即使对那些不了解Python的人来说…)，但是有一些要点需要注意:</p><ul class=""><li id="8b76" class="mf mg hj jr b js jt jv jw jy mh kc mi kg mj kk nr ml mm mn bi translated">第5行，<code class="dv mv mw mx my b">entry = types.Entry()</code>:到目前为止，只有Google Cloud的数据资源由Data Catalog管理。更具体地说:在产品第一次发布测试版时，只管理自动同步的条目(指BigQuery和Pub/Sub资产);几个月后，用户能够手动创建引用GCS文件集的条目。从现在开始，我们可以创建任何类型的条目；</li><li id="84f0" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated">第9行，<code class="dv mv mw mx my b">YOUR-ENTRY-GROUP-ID</code>:每个条目必须属于一个条目组，通过一个非常简单的API调用在条目之前创建，我们将在下一节中看到。作为参考，BigQuery和Pub/Sub条目的自动管理组具有<code class="dv mv mw mx my b">@bigquery</code>和<code class="dv mv mw mx my b">@pubsub</code>id。用户定义的条目将属于用户定义的组— <a class="ae jo" href="https://cloud.google.com/data-catalog/docs/how-to/filesets" rel="noopener ugc nofollow" target="_blank">与GCS文件集使用的方法</a>完全相同。因为项目和位置id被添加到条目组id的前面，所以在这一点上可以简单地使用<code class="dv mv mw mx my b">tableau</code>;</li><li id="0e45" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated">第12行，<code class="dv mv mw mx my b">entry.user_specified_system = 'tableau'</code>:所有Tableau相关条目的公共值；</li><li id="f317" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated">第13行，<code class="dv mv mw mx my b">entry.user_specified_type = 'workbook'</code>:用于区分Tableau相关的条目类型。在本讨论的范围内，以下值可用于实现该属性:<code class="dv mv mw mx my b">workbook</code>、<code class="dv mv mw mx my b">sheet</code>和<code class="dv mv mw mx my b">dashboard</code>。</li></ul><p id="70ab" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">正如我在<em class="kx">改编不同的概念</em>一节中提到的，条目的属性只覆盖了一小部分Tableau资产的元数据。但是我们可以利用数据目录标签来避免丢失有价值的信息。首先，让我们来看一个标签模板建议:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="no np l"/></div></figure><p id="0610" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">此模板中的标签可以附加到每个与工作簿相关的条目。通过这样做，我们丰富了Data Catalog中可用的元数据，就好像我们向这样的条目“添加”了两个额外的字段:<code class="dv mv mw mx my b">Site name</code>和<code class="dv mv mw mx my b">Tables used by the workbook</code>。</p><blockquote class="ku kv kw"><p id="82ed" class="jp jq kx jr b js jt ik ju jv jw in jx ky jz ka kb kz kd ke kf la kh ki kj kk hc bi translated"><strong class="jr hk">旁注</strong>:数据目录目前不支持列表作为标记值，所以表名必须连接起来以满足<code class="dv mv mw mx my b"><em class="hj">upstream_tables</em></code>字段。</p></blockquote></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="0a7f" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">元数据摄取</h1><p id="f0e0" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">这是集成过程的最后一个阶段，其中的条目和标记被接收到数据目录中。如前一节所述，每个条目都必须属于一个条目组，所以让我们从创建它开始:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="no np l"/></div></figure><p id="0190" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">然后，我们可以遍历在准备阶段创建的条目，并要求Data Catalog保存这些条目及其标签:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="no np l"/></div></figure><p id="5150" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">一旦接收过程完成，您就可以通过使用数据目录UI来查看新的元数据。键入<code class="dv mv mw mx my b">system=tableau</code>和<em class="kx">搜索</em>:</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et oa"><img src="../Images/b1b5c7d60c3e97f4792c73c8e1362022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nay7ci39yp8_g2RAushDA.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片4 </strong>。使用数据目录用户界面搜索Tableau资产</figcaption></figure><p id="eaef" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">下图显示了样张的条目和标签:</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et ob"><img src="../Images/646b0dafe0ba6035a1360fd7c403403c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HM1IUAYNvpuwkaVKAOrW1A.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片5 </strong>。通过数据目录UI的Tableau表元数据</figcaption></figure><p id="1c59" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><strong class="jr hk">刮-准备-摄取</strong>过程<strong class="jr hk">完成</strong>！</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="4d9c" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">样本连接器</h1><p id="94ba" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">GitHub 上的示例连接器<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-bi" rel="noopener ugc nofollow" target="_blank">涵盖了本文中讨论的所有主题。你可以随便拿，按照说明跑。顺便说一下，欢迎投稿！</a></p><blockquote class="mz"><p id="25b8" class="na nb hj bd nc nd ne nf ng nh ni kk dy translated">它是根据Apache License版许可的，以“原样”为基础发布，没有任何种类的担保或条件，无论是明示的还是暗示的。</p></blockquote><p id="3ad2" class="pw-post-body-paragraph jp jq hj jr b js nj ik ju jv nk in jx jy nl ka kb kc nm ke kf kg nn ki kj kk hc bi translated">与文本一起提供的代码片段基于连接器，但出于可读性的原因进行了简化。您会注意到，实际代码中加入了更多的一致性检查、异常处理，不仅处理创建，还处理条目和标签的更新和删除操作。所需的模板在摄取阶段开始时创建。</p><p id="3160" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">此外，它还分为两个主要部分:<code class="dv mv mw mx my b">datacatalog-connector-commons</code>和<code class="dv mv mw mx my b">datacatalog-connector-tableau</code>。还有其他非GCP系统的示例连接器，如Looker、<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-hive" rel="noopener ugc nofollow" target="_blank"> Hive </a>、<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-rdbms" rel="noopener ugc nofollow" target="_blank"> MySQL、Oracle和其他</a>。它们共享的代码，主要是与摄取阶段相关的类，在<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors" rel="noopener ugc nofollow" target="_blank"><em class="kx">data catalog-connector-commons</em></a>组件中进行管理。理想情况下，通过设计，只有该组件应该与数据目录自定义类型API进行通信。另一方面，所有Tableau通信和特定元数据操作代码驻留在<em class="kx">data catalog-connector-Tableau</em>上。如下图所示，commons组件对外部源系统一无所知:</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et oc"><img src="../Images/c90d4eca2e74b049631f76b9dcec7222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeFAYNmYbFmtznLlhquPTQ.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片6 </strong>。数据目录和Tableau集成组件</figcaption></figure><p id="46bd" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">Tableau允许两种同步策略:<strong class="jr hk">完全</strong>和<strong class="jr hk">增量</strong>。<em class="kx">完全同步</em>发生在属于给定实例的所有资产在单次执行中同步的时候。第一次从该实例接收元数据时，建议这样做。<em class="kx">增量(或部分)同步</em>发生在只有一部分资产由于元数据的改变而被同步的时候。<a class="ae jo" href="https://www.tableau.com/about/blog/2019/10/tableau-webhooks-support" rel="noopener ugc nofollow" target="_blank"> Tableau在2019.4版本中引入了Webhooks支持</a>，这项技术是一个增量同步使能器。</p><p id="a5d7" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">测试表明，从Tableau中抓取1，000个资产，准备它们并将其纳入数据目录，需要大约25分钟。为每个资产生成一个条目和一个<em class="kx">富化</em>标签。<strong class="jr hk">每个条目+标签对需要4次API调用才能完全同步:1次获取条目，1次创建或更新条目，1次获取标签，最后1次创建或更新标签。</strong>数据目录目前不支持批量API操作。</p><p id="7f77" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">就这些了，伙计们！</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h2 id="5497" class="od lj hj bd lk oe of og lo oh oi oj ls jy ok ol lu kc om on lw kg oo op ly oq bi translated">参考</h2><ul class=""><li id="dce4" class="mf mg hj jr b js ma jv mb jy or kc os kg ot kk nr ml mm mn bi translated"><strong class="jr hk">谷歌云数据目录动手指南，心智模型</strong>:<a class="ae jo" rel="noopener" href="/google-cloud/data-catalog-hands-on-guide-a-mental-model-dae7f6dd49e">https://medium . com/Google-Cloud/Data-Catalog-hands-on-guide-a-mental-model-DAE 7 f 6 DD 49 e</a></li><li id="21d8" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated"><strong class="jr hk">Tableau元数据API介绍</strong>:<a class="ae jo" href="https://help.tableau.com/v0.0/api/metadata_api/en-us/index.html" rel="noopener ugc nofollow" target="_blank">https://help . Tableau . com/v 0.0/API/Metadata _ API/en-us/index . html</a></li><li id="4e31" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated"><strong class="jr hk"> Tableau元数据API引用</strong>:<a class="ae jo" href="https://help.tableau.com/v0.0/api/metadata_api/en-us/reference/" rel="noopener ugc nofollow" target="_blank">https://help . Tableau . com/v 0.0/API/Metadata _ API/en-us/Reference/</a></li><li id="4a88" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated"><strong class="jr hk">Tableau REST API</strong>:<a class="ae jo" href="https://help.tableau.com/current/api/rest_api/en-us/REST/rest_api.htm" rel="noopener ugc nofollow" target="_blank">https://help . Tableau . com/current/API/REST _ API/en-us/REST/REST _ API . htm</a></li><li id="c34f" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk nr ml mm mn bi translated"><strong class="jr hk">为Tableau开发者平台创建由Webhooks事件触发的自定义工作流</strong>:<a class="ae jo" href="https://www.tableau.com/about/blog/2019/10/tableau-webhooks-support" rel="noopener ugc nofollow" target="_blank">https://www . Tableau . com/about/blog/2019/10/Tableau-web hooks-support</a></li></ul></div></div>    
</body>
</html>