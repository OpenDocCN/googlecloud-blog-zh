<html>
<head>
<title>Automate Deployments for Google Kubernetes Engine with Cloud Build and Helm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云构建和Helm自动部署Google Kubernetes引擎</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/automate-deployments-for-google-kubernetes-engine-with-cloud-build-and-helm-ec896e5f529a?source=collection_archive---------2-----------------------#2022-09-21">https://medium.com/google-cloud/automate-deployments-for-google-kubernetes-engine-with-cloud-build-and-helm-ec896e5f529a?source=collection_archive---------2-----------------------#2022-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c14d387ec8f7d35cc91aab5118cab67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*twxaKYEKA-df4xqlK1FfXQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="iu iv ge" href="https://medium.com/u/3b9a10f61d50?source=post_page-----ec896e5f529a--------------------------------" rel="noopener" target="_blank"> Devashish Patil </a>设计</figcaption></figure><p id="18d8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Kubernetes非常擅长管理复杂的应用程序。但是，我们人类往往很难理解复杂性。我们在Kubernetes中部署的应用程序可能会变得非常复杂。</p><p id="9609" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一个典型的应用程序可以有多个相互连接的组件，以使一切正常工作。随着复杂性的增加，开发、升级和管理这些应用程序会变得非常困难。</p><p id="11b2" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这就是需要自动化的地方，Helm之类的工具可以为您提供便利。让我们看看如何在Kubernetes应用程序部署过程中实现一些自动化。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="4c06" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">在文章中，我们会了解到以下事情:</strong></p><ul class=""><li id="e4a3" class="kb kc hi iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated">Helm是什么，它解决什么问题，它是如何工作的？</li><li id="f0bc" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">使用云构建创建一个管道，以便在GKE安装helm charts。</li></ul><p id="7a5d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">先决条件:</strong></p><ul class=""><li id="c860" class="kb kc hi iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated">基本了解<a class="ae kp" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank">Kubernetes</a>/<a class="ae kp" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">Google Kubernetes引擎</a></li><li id="4078" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">CICD管道公司</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="c47a" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">设置背景</h1><p id="9003" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">让我们首先理解用普通方法在Kubernetes上部署应用程序的生命周期。</p><p id="f1d6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">首先，我们需要知道我们的应用程序或<a class="ae kp" href="https://microservices.io" rel="noopener ugc nofollow" target="_blank">微服务</a>中有哪些组件。然后我们需要了解在Kubernetes上运行这些组件需要哪些对象。一旦完成，我们将开始为这些组件创建Kubernetes清单文件。</p><p id="0183" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">让我们借助这个示例场景来理解这一点:</strong></p><p id="439f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们有一个简单的WordPress应用程序，需要部署在Kubernetes上。一个WordPress应用程序通常有这些主要组件，一个web服务器，一个数据库，和一个web应用程序的存储层。</p><p id="4fe5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">当我们在Kubernetes上部署这个应用程序时，我们通常需要以下组件:</p><ul class=""><li id="3e48" class="kb kc hi iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated"><a class="ae kp" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj">部署</strong> </a> —要在部署文件中定义的Web服务器和MySQL pod规范。</li><li id="57c2" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><a class="ae kp" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj">服务</strong></a>——一个服务用于MySQL数据库，使其对WordPress web server pods可见，另一个服务用于外部用户访问网站。</li><li id="924e" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><a class="ae kp" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj">持久卷/声明</strong> </a> <strong class="iy hj"> : </strong>一个用于存储数据库表，另一个用于web app静态内容。</li><li id="8b79" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><a class="ae kp" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj">秘密</strong> </a> <strong class="iy hj"> </strong> —用于存储数据库凭证，web服务器pod将使用这些凭证来访问数据库。</li></ul><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/2773b23b2b6e2f0005c8a891c0cd4870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*da98uSZamTzj_pNanE5rtA.png"/></div></div></figure><p id="3e06" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">下一步是为所有这些组件创建清单文件。它看起来就像下图所示的那样。</p><blockquote class="ly lz ma"><p id="3587" class="iw ix mb iy b iz ja jb jc jd je jf jg mc ji jj jk md jm jn jo me jq jr js jt hb bi translated">你可以在Kubernetes <a class="ae kp" href="https://gist.github.com/devashishpatil56/d7a041607d3a2bd1bfc66dbdc14f51e9" rel="noopener ugc nofollow" target="_blank">这里</a>查看一个简单的Wordpress应用程序的示例清单。</p></blockquote><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/06a382491537dffeb94903df961493c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCJtS1EG41_n8GqwpAQuYQ.png"/></div></div></figure><p id="50df" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">问题从这里开始。对于所有这些清单文件，您必须使用以下命令来应用它们:</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="fd50" class="ml kr hi mh b fi mm mn l mo mp">kubectl apply -f /path/to/my-manifest.yaml</span></pre><p id="2872" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果您有一个包含大量Kubernetes对象的大型应用程序，这本身就会变得非常乏味。</p><p id="abaa" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这还没有结束，如果您必须进行更改，更新应用程序，或者在回滚的情况下，您必须编辑特定的文件(您需要事先知道)，并再次进行相同的应用过程。想象一下删除所有这些资源，那将是一场噩梦。</p><p id="1245" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">最重要的是，在所有这些文件上的团队协作会变得非常困难，因为所有这些都发生在您的命令行中，所以没有真正的版本控制。当然，您可以将这些文件放在Git中，但是这里仍然有许多手工工作要做。</p><p id="bf20" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在，想象你需要在不同的环境中创建一个类似的应用程序或相同的应用程序，比如<code class="du mq mr ms mh b">prod</code>、<code class="du mq mr ms mh b">test</code>等，你必须从头开始做和上面一样的事情。</p><p id="3932" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这就是赫尔姆出现的原因。</p><h2 id="9ae5" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated">Helm是如何解决这个问题的？</h2><blockquote class="ng"><p id="ad1f" class="nh ni hi bd nj nk nl nm nn no np jt dx translated">Helm是Kubernetes的包装经理。它还充当Kubernetes的发布管理器。</p></blockquote><p id="d95d" class="pw-post-body-paragraph iw ix hi iy b iz nq jb jc jd nr jf jg jh ns jj jk jl nt jn jo jp nu jr js jt hb bi translated">Helm帮助您管理Kubernetes应用程序，甚至是最复杂的应用程序。它是为了理解这些事情而从头开始构建的。它使用舵图表，让您定义，安装和升级您的Kubernetes应用程序。</p><blockquote class="ly lz ma"><p id="7d17" class="iw ix mb iy b iz ja jb jc jd je jf jg mc ji jj jk md jm jn jo me jq jr js jt hb bi translated">这个我打个比方。假设你想在电脑上安装一个视频游戏。视频游戏通常具有成千上万的图像、音频、音乐、可执行代码等形式的文件。所有这些文件都需要在你的电脑中的特定位置才能运行游戏。</p><p id="f8f7" class="iw ix mb iy b iz ja jb jc jd je jf jg mc ji jj jk md jm jn jo me jq jr js jt hb bi translated">想象一下，如果你应该单独下载所有这些文件，然后把它们放在特定的位置。那将是一场噩梦。但是，幸运的是，我们不必这样做。我们有游戏安装程序。我们只需要指定我们想要保存游戏的位置，安装程序会处理剩下的事情。</p></blockquote><p id="98d2" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Helm为您希望在Kubernetes上运行的应用程序做同样的事情。就像你用apt或yum在Linux上安装应用程序，用Pip安装python库，用npm安装节点包一样，helm同样适用于Kubernetes。</p><p id="e9d0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是这一切是如何运作的呢？首先，我们来了解一下Helm的基本概念。</p><h2 id="c0f2" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated">头盔概念:</h2><p id="b89a" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">一个helm图表包含了创建一个Kubernetes应用程序实例所需的所有信息。</p><p id="3931" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">图表包含模板文件夹中的清单文件、关于图表本身的元数据以及对其他图表的任何依赖(如果有的话)。</p><p id="3cca" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj"> Config </strong> <br/>它包含可配置的信息，与打包的图表一起用于创建可发布的对象。</p><p id="57a7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">它通常是一个<code class="du mq mr ms mh b">values.yaml</code>文件，包含可以在一个地方配置的信息。多个值文件可用于为不同的环境创建不同的配置。</p><p id="1aa8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">发布</strong> <br/>当一个图表，结合config运行时，这个运行的实例被称为一个发布。</p><p id="d76d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">当您在Kubernetes集群中安装一个图表时，您可以称之为一个版本。该版本在安装时会有一个版本，每次升级或回滚时都会更新。</p><h2 id="2b1f" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated">带头盔的快速入门</h2><p id="a569" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">首先在你的电脑上安装头盔。要从头开始创建新的舵图，请在命令行中运行此命令。</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="4d83" class="ml kr hi mh b fi mm mn l mo mp">$ helm create hello-world </span></pre><p id="5750" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这将创建一个名为<code class="du mq mr ms mh b">hello-world</code>的文件夹，它将为您创建一个样板代码，您可以开始编辑它。将目录更改到该文件夹中，您将看到以下结构。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nv"><img src="../Images/d50726cf9fb1148cbe293aa554bc6af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4OEzKSJpq9ql68aEG6udQ.png"/></div></div></figure><p id="d8a9" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">你可以在这里 详细阅读上图中的<a class="ae kp" href="https://helm.sh/docs/topics/charts/" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj">。</strong></a></p><p id="cea4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里的一个重要文件夹是<code class="du mq mr ms mh b">templates/</code>文件夹。如果你正在从头开始写你的清单，你可以开始编辑YAML文件，或者如果你已经有了你的清单，只需从这个文件夹中删除除了<code class="du mq mr ms mh b">_helpers.tpl</code>之外的所有东西，把你的文件放在这里。</p><p id="7c29" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然后你可以编辑你的YAML文件，用Go模板替换可配置的东西，并开始把这些东西放到<code class="du mq mr ms mh b">values.yaml</code>文件中。</p><h2 id="85e0" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated"><strong class="ak">示例</strong></h2><p id="3ba1" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">通常，在为容器指定图像时，您应该这样做:</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="76e6" class="ml kr hi mh b fi mm mn l mo mp">---<br/>spec:<br/>  containers:<br/>  - image: docker.io/hello-world:1.2.3<br/>    name: hello-world</span><span id="2702" class="ml kr hi mh b fi nw mn l mo mp">---</span></pre><p id="9ead" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是，您可以用如下可配置的值替换硬编码的图像名称和标记:</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="f299" class="ml kr hi mh b fi mm mn l mo mp">---<br/>spec:<br/>  containers:<br/>  - image:"<strong class="mh hj">{{ .Values.image.repo }}:{{ .Values.image.tag }}</strong>"<br/>    name: <strong class="mh hj">{{ .Release.Name }}</strong></span><span id="d420" class="ml kr hi mh b fi nw mn l mo mp">---</span></pre><p id="1526" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">并将默认值放在<code class="du mq mr ms mh b">values.yaml</code>文件中，如下所示:</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="ce1d" class="ml kr hi mh b fi mm mn l mo mp">image:<br/>  repo: docker.io/hello-world<br/>  tag: 1.2.3</span></pre><p id="f358" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这只是用Helm进行模板化的一个非常基本的例子。您可以做更多的事情，使您的清单完全模块化和可重用。</p><p id="1e1b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">完成清单后，您可以在这个命令的帮助下将这个图表安装到Kubernetes集群中。</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="8cb0" class="ml kr hi mh b fi mm mn l mo mp">$ helm install hello-world /path/to/hello-world</span></pre><p id="bc34" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果您想将它安装在特定的名称空间中，只需将<code class="du mq mr ms mh b">--namespace &lt;name&gt;</code>放在上述命令的末尾。</p><p id="cde5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">您可以通过此list命令列出所有已安装的helm应用程序:</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="355c" class="ml kr hi mh b fi mm mn l mo mp">$ helm list --namespace &lt;name&gt;</span></pre><p id="d872" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在，假设您的应用程序正在增长，您需要更多的CPU。因此，您更新了pod的CPU请求。首先，您可以通过将CPU和内存请求放入<code class="du mq mr ms mh b">values.yaml</code>文件来使它们可配置。要在实际应用程序中应用这些更改，只需运行以下命令</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="06f8" class="ml kr hi mh b fi mm mn l mo mp">$ helm upgrade hello-world /path/to/hello-world --namespace &lt;name&gt;</span></pre><p id="2282" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这将为您的版本创建一个新的版本。现在，假设您正在升级版本，在某个版本发布后，您发现最新版本存在一些问题，您希望回滚到以前的版本或任何特定的版本。你可以这样做:</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="0e86" class="ml kr hi mh b fi mm mn l mo mp">$ helm rollback hello-world &lt;<strong class="mh hj">revision</strong>&gt; --namespace &lt;name&gt;</span></pre><p id="5f95" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">最后，如果您不再需要您的应用程序，您可以使用以下命令将其全部删除:</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="dabe" class="ml kr hi mh b fi mm mn l mo mp">$ helm uninstall hello-world --namespace &lt;name&gt;</span></pre><blockquote class="ly lz ma"><p id="0d7a" class="iw ix mb iy b iz ja jb jc jd je jf jg mc ji jj jk md jm jn jo me jq jr js jt hb bi translated">你可以访问<strong class="iy hj"> artifacthub.io </strong>获得大量预构建的导航图，这些导航图适用于大多数常见类型的应用程序，如果你不想从头开始创建，可以从那里直接安装。</p></blockquote><p id="6465" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这应该是您与Helm合作的一个良好起点。它将帮助你摆脱大量的重复，让你专注于应用程序本身。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="b8c5" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">云构建</h1><p id="f526" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">现在，您在上一节中使用的所有这些命令仍然是您要在命令行中运行的。为了进一步自动化，我们将使用GCP的云构建来创建一个CD工作流，这将消除使用命令行的需要，并且只要您更新GIT存储库中的图表，一切都将开始同步。</p><p id="b25a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">有许多工具可供CICD使用。比如Jenkins、Gitlab CI、Spinnaker等，以及各大云提供商的。</p><p id="4e14" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在本教程中，我们将重点关注<strong class="iy hj">云构建</strong>，这是谷歌云平台的CICD工具。云构建允许您轻松集成许多GCP服务，并且非常容易设置和配置。</p><p id="0f69" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这是CD流的样子:</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nx"><img src="../Images/0bf967dabe1b5947121cb04a75360b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4do4Ga_bDLjRCNqvhzENmA.png"/></div></div></figure><p id="560f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这些是我们准备好CD渠道所需的步骤:</p><ul class=""><li id="4479" class="kb kc hi iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated">有一个Git存储库来存储舵图</li><li id="0767" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">为Helm构建云构建器</li><li id="6005" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">在云构建中创建触发器</li><li id="6826" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">配置管道</li></ul><h2 id="15fa" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated">创建Git repo</h2><p id="51e0" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">第一步是在GCP创建一个云资源存储库，我们将在那里放置Helm chart。您也可以使用其他版本控制系统，比如GitHub或Bitbucket。提交此报告中的图表目录。</p><h2 id="d9ca" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated">构建云构建器</h2><blockquote class="ng"><p id="564e" class="nh ni hi bd nj nk nl nm nn no np jt dx translated">构建器基本上是容器映像，其中安装了您可以在cloudbuild.yaml文件中指定的语言和工具。</p></blockquote><p id="3274" class="pw-post-body-paragraph iw ix hi iy b iz nq jb jc jd nr jf jg jh ns jj jk jl nt jn jo jp nu jr js jt hb bi translated">要使用任何定制的命令/工具，在我们的例子中是<code class="du mq mr ms mh b">helm</code>，我们需要一个Helm的构建器。</p><p id="b737" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">您可以访问<a class="ae kp" href="https://cloud.google.com/build/docs/cloud-builders" rel="noopener ugc nofollow" target="_blank">此链接</a>查看受支持的构建者、社区贡献的构建者以及如何创建您自己的构建者的列表。</p><p id="9fc2" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在管道中使用Helm builder之前，您需要在自己的GCP环境中构建它。要构建这个，您需要从具有<code class="du mq mr ms mh b">gcloud</code>访问权限的命令行克隆<a class="ae kp" href="https://github.com/GoogleCloudPlatform/cloud-builders-community/tree/master/helm#building-this-builder:~:text=Building%20this%20builder,config%3Dcloudbuild.yaml" rel="noopener ugc nofollow" target="_blank">这个Git repo </a>，在那个目录中打开一个终端，并运行这里提到的这个命令。</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="da4c" class="ml kr hi mh b fi mm mn l mo mp">gcloud builds submit . --config=cloudbuild.yaml</span></pre><p id="2004" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一旦完成，您将能够在这里<code class="du mq mr ms mh b">gcr.io/&lt;<strong class="iy hj">PROJECT_ID</strong>&gt;/helm</code>的容器注册表中看到构建器映像。这意味着您现在可以在您的云构建管道中使用这个构建器。</p><blockquote class="ly lz ma"><p id="ebae" class="iw ix mb iy b iz ja jb jc jd je jf jg mc ji jj jk md jm jn jo me jq jr js jt hb bi translated">注意:这里我们使用<strong class="iy hj"> gcr.io </strong>作为容器映像库，你也可以使用其他的，比如docker.io等</p></blockquote><h2 id="0c74" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated">创建触发器</h2><p id="a7a1" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">现在，我们将在这个存储库上创建一个云构建触发器。这是一个如何指定细节的示例。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/4f6141e427b6193b732b8b17c14839e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UoLNdd0d1U-sYYnVorP9wg.png"/></div></div></figure><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nz"><img src="../Images/a6500a47ccb0da0851827bc24a789690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqlxB-99E2D8z-EiQgledA.png"/></div></div></figure><p id="08d5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">确保向云构建触发器添加一个服务帐户，该帐户具有<code class="du mq mr ms mh b">Kubernetes Engine Developer</code>访问权限。</p><h2 id="e425" class="ml kr hi bd ks mt mu mv kw mw mx my la jh mz na le jl nb nc li jp nd ne lm nf bi translated">配置云构建管道</h2><p id="ca19" class="pw-post-body-paragraph iw ix hi iy b iz lo jb jc jd lp jf jg jh lq jj jk jl lr jn jo jp ls jr js jt hb bi translated">现在，回到您之前创建的舵图表存储库。我们在存储库的<code class="du mq mr ms mh b">main</code>分支上创建了触发器，并将<code class="du mq mr ms mh b">cloudbuild.yaml</code>指定为管道的配置文件。但是我们还没有创建文件，现在我们将创建文件。</p><p id="0575" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在存储库的根位置创建一个名为<code class="du mq mr ms mh b">cloudbuild.yaml</code>的文件。将以下内容添加到文件中并提交。</p><pre class="lu lv lw lx fd mg mh mi mj aw mk bi"><span id="5377" class="ml kr hi mh b fi mm mn l mo mp">steps:</span><span id="2a52" class="ml kr hi mh b fi nw mn l mo mp">- name: 'gcr.io/$PROJECT_ID/helm'</span><span id="26a8" class="ml kr hi mh b fi nw mn l mo mp">  args: ['upgrade', '--install', 'hello-world-app', './hello-world', '--namespace', '<strong class="mh hj">helloworldns</strong>', '--create-namespace']<br/>  <br/>  env:<br/>  - 'CLOUDSDK_COMPUTE_ZONE=<strong class="mh hj">&lt;your-gcp-zone&gt;</strong>'<br/>  - 'CLOUDSDK_CONTAINER_CLUSTER=<strong class="mh hj">&lt;your-cluster-name&gt;</strong>'</span></pre><blockquote class="ly lz ma"><p id="d92e" class="iw ix mb iy b iz ja jb jc jd je jf jg mc ji jj jk md jm jn jo me jq jr js jt hb bi translated">注意:确保舵建造者的图像存在于gcr.io/$PROJECT_ID/helm</p></blockquote><p id="7cd1" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里的工作已经完成，一旦您推动此更改，部署就会开始。这个简单的管道将负责安装或升级您的图表，您只需要管理您的git存储库。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="3513" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">接下来学什么？</h1><ul class=""><li id="f7e3" class="kb kc hi iy b iz lo jd lp jh oa jl ob jp oc jt kg kh ki kj bi translated">您可以在Google Cloud上寻找与基于Kubernetes的应用程序相关的常见CICD模式。这篇文章只是拼图的一部分。一般来说，在容器化应用程序的情况下，很多人遵循将CI和CD管道分开的方法。<br/>用于构建和测试容器映像的应用程序代码和CI管道的一个repo。另一个CD回购，就像我们在这里看到的那样</li><li id="ad11" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">其次，你可以了解一下<a class="ae kp" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> GitOps风格的</a>管道。例如，您可以查看<a class="ae kp" href="https://cloud.google.com/anthos-config-management/docs/config-sync-overview" rel="noopener ugc nofollow" target="_blank">配置同步</a>，它来自Google Cloud自己的GitOps工具。<br/>这些资源将向您展示如何在GKE集群中实现GitOps的端到端流程:<br/> 1。<a class="ae kp" href="https://cloud.google.com/blog/products/containers-kubernetes/gitops-with-oci-artifacts-and-config-sync" rel="noopener ugc nofollow" target="_blank">gitop与OCI工件和配置同步</a> <br/> 2。<a class="ae kp" rel="noopener" href="/google-cloud/ci-gitops-with-helm-github-actions-google-artifact-registry-and-config-sync-b48604191fda">带有Helm的CI/gitop、GitHub操作、工件注册表和配置同步</a> <br/> 3。<a class="ae kp" rel="noopener" href="/google-cloud/ci-gitops-with-helm-github-actions-github-container-registry-and-config-sync-836913e74e79">带有Helm的CI/GitOps、GitHub操作、GitHub容器注册表和配置同步</a> <br/> 4。使用<a class="ae kp" href="https://argoproj.github.io/cd/" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hj"> ArgoCD </strong> </a></li><li id="c99b" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated">你也可以学习替代头盔的工具。例如<code class="du mq mr ms mh b"><a class="ae kp" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank">kustomize</a></code>，它以类似的方式工作，但是我将把学习留给你。</li></ul><h1 id="0b1e" class="kq kr hi bd ks kt od kv kw kx oe kz la lb of ld le lf og lh li lj oh ll lm ln bi translated">参考</h1><ul class=""><li id="79e1" class="kb kc hi iy b iz lo jd lp jh oa jl ob jp oc jt kg kh ki kj bi translated"><a class="ae kp" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵</a></li><li id="eada" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><a class="ae kp" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank">云构建</a></li><li id="c39a" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><a class="ae kp" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a></li><li id="f0e4" class="kb kc hi iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><a class="ae kp" href="https://artifacthub.io/" rel="noopener ugc nofollow" target="_blank">神器中枢</a></li></ul></div></div>    
</body>
</html>