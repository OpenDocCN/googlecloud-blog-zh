<html>
<head>
<title>Local Django on Kubernetes with Minikube</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的当地Django和Minikube</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/local-django-on-kubernetes-with-minikube-89f5ad100378?source=collection_archive---------1-----------------------#2016-12-13">https://medium.com/google-cloud/local-django-on-kubernetes-with-minikube-89f5ad100378?source=collection_archive---------1-----------------------#2016-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8a3ac83012e0b9b59ff27b485c1c325c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fMjeHmaGDI5UIzzvyDuUoQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">迷你库贝</figcaption></figure><p id="159a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">自从我上次在Kubernetes 上写了关于<a class="ae js" rel="noopener" href="/google-cloud/deploying-django-postgres-redis-containers-to-kubernetes-9ee28e7a146"> Django以及Postgres和Redis容器的文章以来，已经过去半年多了，我想更新一下，谈谈去年在Kubernetes生态系统中出现的最令人兴奋的项目之一——</a><a class="ae js" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank">Minikube</a>。</p><p id="b6b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Minikube使得在本地运行Kubernetes集群变得非常非常容易。虽然以前在本地运行Kubernetes有很多选择，但在某种程度上，这个社区正在围绕Minikube凝聚，而且它是Kubernetes Github组织的正式组成部分。</p><p id="ed03" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本教程的所有代码都可以在这个<a class="ae js" href="https://github.com/waprin/kubernetes_django_postgres_redis" rel="noopener ugc nofollow" target="_blank"> Github项目</a>中找到。</p><p id="8423" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是一些关于Minikube入门的其他教程:</p><p id="70f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从Kubernetes文档开始使用Minikube</p><p id="0a4e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" rel="noopener" href="/@claudiopro/getting-started-with-kubernetes-via-minikube-ada8c7a29620#.pukm2rlxz">通过Minikube开始使用Kubernetes</a></p><p id="e736" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="http://thenewstack.io/tutorial-configuring-ultimate-development-environment-kubernetes/" rel="noopener ugc nofollow" target="_blank">为Kubernetes配置终极开发环境</a></p><p id="4c1d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Minikube项目本身通常在自述文件中有关于不同安装方式的最新文档，以及开发团队积极响应的问题跟踪器。</p><p id="0c14" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">除了Minikube之外，项目还有其他一些变化:</p><ul class=""><li id="2c97" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">我开始通过<a class="ae js" href="https://github.com/mattrobenolt/jinja2-cli" rel="noopener ugc nofollow" target="_blank"> jinja cli </a>使用<a class="ae js" href="http://jinja.pocoo.org/docs/dev/" rel="noopener ugc nofollow" target="_blank"> Jinja </a> 2模板来填充任何环境变量，并重构配置中特定于Minikube或容器引擎的部分。</li><li id="3d09" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">我将所有的复制控制器切换到新的<a class="ae js" href="http://kubernetes.io/docs/user-guide/deployments/" rel="noopener ugc nofollow" target="_blank">部署</a>，这与更具声明性的更新系统非常相似</li></ul><p id="c772" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的Django项目使用了一些云特性，比如负载平衡器和卷(通过GCE持久磁盘),您可能想知道它是如何被转换到Minikube的。因此，这篇文章将讨论以下主题:</p><ul class=""><li id="90ef" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">我遇到的小技巧和陷阱</li><li id="d6f3" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">持久卷和持久卷声明</li><li id="04f4" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">Minikube服务与外部负载平衡器</li><li id="8930" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">端口转发及其有用的原因</li><li id="e502" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">使用主机挂载热重装开发中的代码</li></ul><h1 id="1b92" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">Minikube提示</h1><p id="add9" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated">2016年的另一个重大公告是Docker for Mac，这对我们这些不喜欢运行VirtualBox和使用docker-machine的人来说非常棒。尽管默认的Minikube驱动程序仍然是VirtualBox，所以如果您使用Docker for Mac，请确保您指定了xyve驱动程序(xyve是驱动Docker for Mac的管理程序):</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="991d" class="lt ki hi lp b fi lu lv l lw lx">$ minikube start --vm-driver=xhyve</span></pre><p id="dc2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者永久设置为:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="7c1d" class="lt ki hi lp b fi lu lv l lw lx">$ minikube config set vm-driver=xhyve</span></pre><p id="f869" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Minikube需要考虑的另一件事是，它并不总是拥有从私有容器注册中心获取的凭证。如果你使用的是公共DockerHub图片，这没什么大不了的，但是如果你使用的是私有注册表(默认情况下像Google容器注册表)，这就有问题了。有两种解决方案——第一种是将<a class="ae js" href="http://kubernetes.io/docs/user-guide/images/" rel="noopener ugc nofollow" target="_blank"> imagePullSecrets </a>添加到您所有的pod规格中。另一种方法是通过确保imagePullPolicy设置为IfNotPresent来避免Minikube拉取图像。</p><p id="3836" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请记住，默认的imagePullPolicy是IfNotPresent，除非图像被标记为latest，在这种情况下，它总是。没有标签的图像被认为具有最新的标签。所以最好只是给你的图像加标签，并显式设置你的imagePullPolicy。</p><p id="d37b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的示例repo采用了后一种方法，避免了在本地工作时提取图像。为了让Minikube获得它需要的图像，您可以与Minikube共享您的Docker守护进程。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="0455" class="lt ki hi lp b fi lu lv l lw lx">$ eval $(minikube docker-env)</span></pre><p id="f010" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，当你做Docker构建时，你构建的图像将对Minikube可用。</p><p id="92db" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在容器引擎和Minikube之间来回切换时，请确保切换上下文:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="2276" class="lt ki hi lp b fi lu lv l lw lx">$ gcloud container cluster get-credentials mycluster # Container Engine context</span><span id="9ed7" class="lt ki hi lp b fi ly lv l lw lx">$ kubectl config use-context minikube # Minikube context</span></pre><h1 id="c5c7" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">持久卷和持久卷声明</h1><p id="12ff" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated">在最初的项目中，我将一个GCE持久磁盘作为一个卷直接连接到Postgres Pod:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="cb49" class="lt ki hi lp b fi lu lv l lw lx"><strong class="lp hj">volumes</strong>:<br/>- <strong class="lp hj">name</strong>: postgresdata<br/><strong class="lp hj">gcePersistentDisk</strong>:<br/># your disk name here<br/><strong class="lp hj">pdName</strong>: pg-data<br/><strong class="lp hj">fsType</strong>: ext4<br/>- <strong class="lp hj">name</strong>: secrets</span></pre><p id="8587" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">问题是Minikube将无法访问GCE磁盘。当然，这很容易通过我们的Jinja2模板解决。然而，Kubernetes有PersistentVolumes和PersistentVolumeClaims的概念，它们概括了存储的本质，所以我认为这是添加它的好地方。</p><p id="6759" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们没有附加特定的卷，而是附加了一个PersistentVolumeClaim，它只是要求某种存储。当然，声明可以指定他们需要什么样的读/写权限，需要多少存储空间，等等。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="b81f" class="lt ki hi lp b fi lu lv l lw lx"><strong class="lp hj">kind</strong>: PersistentVolumeClaim<br/><strong class="lp hj">apiVersion</strong>: v1<br/><strong class="lp hj">metadata</strong>:<br/><strong class="lp hj">name</strong>: postgres-data<br/><strong class="lp hj">spec</strong>:<br/><strong class="lp hj">accessModes</strong>:<br/>  - ReadWriteOnce<br/><strong class="lp hj">resources</strong>:<br/>  <strong class="lp hj">requests</strong>:<br/>    storage: 5Gi</span></pre><p id="fc60" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后我们可以把PVC贴在豆荚上。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="8a32" class="lt ki hi lp b fi lu lv l lw lx"><strong class="lp hj">volumes:<br/></strong>- <strong class="lp hj">name: </strong>postgresdata<br/><strong class="lp hj">persistentVolumeClaim:<br/>  claimName: </strong>postgres-data</span></pre><p id="e24c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">声明将需要绑定到满足其约束的持久卷。对于容器引擎，我们仍将创建一个GCE磁盘:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="ec3c" class="lt ki hi lp b fi lu lv l lw lx"><strong class="lp hj">apiVersion: </strong>v1<br/><strong class="lp hj">kind: </strong>PersistentVolume<br/><strong class="lp hj">metadata:<br/>  name: </strong>pv0001<br/><strong class="lp hj">spec:<br/>accessModes:<br/></strong>- ReadWriteOnce<br/><strong class="lp hj">capacity:<br/>storage: </strong>5Gi<br/><strong class="lp hj">gcePersistentDisk:<br/>  pdName: </strong>pg-data<br/>  <strong class="lp hj">fsType: </strong>ext4</span></pre><p id="875a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是对于Minikube，我们可以只创建一个本地目录，并使用hostmount作为持久卷。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3db7" class="lt ki hi lp b fi lu lv l lw lx"><strong class="lp hj">apiVersion: </strong>v1<br/><strong class="lp hj">kind: </strong>PersistentVolume<br/><strong class="lp hj">metadata:<br/>name: </strong>pv0001<br/><strong class="lp hj">spec:<br/>accessModes:<br/>  </strong>- ReadWriteOnce<br/><strong class="lp hj">capacity:<br/>  storage: </strong>5Gi<br/><strong class="lp hj">hostPath:<br/>  path: </strong>/data/pv0001/</span></pre><h1 id="3c7e" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">负载平衡器</h1><p id="ada3" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated">我们为web流量提供服务的前端使用了LoadBalancer类型的服务，它在Container Engine上提供了一个Google Compute Engine L7负载平衡器。这为我们运行时提供了一个外部IP:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="ae0e" class="lt ki hi lp b fi lu lv l lw lx">$ kubectl get services</span></pre><p id="14d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这样我们就可以从那里获得服务。显然，Minikube拥有GCE负载平衡器或外部IP是没有意义的。幸运的是，Minikube忽略了负载平衡器，我们仍然可以使用“minikube service”命令来访问我们的服务:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="31e3" class="lt ki hi lp b fi lu lv l lw lx">$ minikube service guestbook</span></pre><p id="1a75" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将在本地端口上打开一个浏览器窗口，显示我们的留言簿服务。</p><h1 id="b2f4" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">端口转发</h1><p id="7878" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated">在开发过程中，能够对代码进行更改并立即在浏览器中反映出来通常很有用。另一方面，Kubernetes期望不可变的图像，所以我们需要做一个Docker构建来更新我们的应用程序。如果我们的代码更改能够立即反映出来，并且能够使用我们真正的Postgres数据库和Redis缓存，那就太好了。</p><p id="dd80" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一种选择是在本地开发Django代码，但仍然通过Minikube使用Minikube Postgres和Redis。Kubernetes有一个port-forward命令，当您想要访问您的Kubernetes服务而不将其作为某种外部服务时，这个命令非常有用。所以如果你做一些像</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="6122" class="lt ki hi lp b fi lu lv l lw lx">$ kubectl port-forward &lt;posgtres-pod&gt; 5432:5432 &amp;</span><span id="c0a8" class="lt ki hi lp b fi ly lv l lw lx">$ kubectl port-forward &lt;redis-pod&gt; 6379:6379 &amp;</span></pre><p id="ff3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么您的localhost Postgres和Redis端口将映射到Minikube端口。你可以从你的Macbook上直接通过<em class="lz"> psql </em>和<em class="lz"> redis-cli </em>与这些服务对话，你的本地Django应用也可以通过localhost与它们对话。一般来说，端口转发对于访问不希望在Kubernetes集群上公开的服务非常有用。</p><h1 id="578b" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">通过主机装载进行热重装</h1><p id="44e3" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated">使用端口转发，您仍然在本地机器上运行Django代码，而不是在Kubernetes集群上运行，这可能不是您想要的，特别是如果您在Docker映像上为前端安装了工作站上不需要的东西。幸运的是，让你的代码热重新加载但仍然在你的Docker容器中运行也很容易。</p><p id="acc5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您所要做的就是创建一个主机挂载来将本地目录挂载到您的容器中。您还需要确保将— reload标志添加到docker文件中的gunicorn命令:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="b6cb" class="lt ki hi lp b fi lu lv l lw lx">gunicorn --reload -b :$PORT mysite.wsgi</span></pre><p id="fed9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们需要挂载主机目录。请记住，在Mac上运行时，通常有两级主机。Macbook本身，然后是VirtualBox或者xhve。因为我使用的是xhyve，所以我的/Users目录是自动挂载的，这也是我进行所有开发的地方。所以我只需要把我保存Django代码的地方挂载到容器期望找到代码的地方，这个地方对我来说是`/ Users/wa prin/code/Django _ postgres _ redis/guest book `,这个地方是/app。所以我最终在我的前端添加了这样的东西。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="469f" class="lt ki hi lp b fi lu lv l lw lx"># in guestbook container </span><span id="600e" class="lt ki hi lp b fi ly lv l lw lx"><strong class="lp hj">volumeMounts</strong>:<br/>- <strong class="lp hj">name</strong>: reload<br/>  <strong class="lp hj">mountPath</strong>: /app<br/><strong class="lp hj">volumes</strong>:<br/>  - <strong class="lp hj">name</strong>: reload<br/>  <strong class="lp hj">hostPath</strong>:<br/><strong class="lp hj">path</strong>: /Users/waprin/code/django_postgres_redis/guestbook</span></pre><p id="5d07" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，每当我对Macbook上的代码进行任何更改，都会反映在容器的目录中，gunicorn会自动热交换新代码。所以我可以在我的Macbook上编码，但是我所有的代码都在Minikube的Linux容器上运行，我所有的Kubernetes服务都是可用的。</p><p id="436e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不幸的是，Linux上没有实现主机文件夹共享，尽管Linux工作站更接近我们运行的Docker映像，所以这可能不是什么大问题。</p><h1 id="2402" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">保持联系</h1><p id="bee1" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated">像往常一样，在我的<a class="ae js" href="https://github.com/waprin/kubernetes_django_postgres_redis" rel="noopener ugc nofollow" target="_blank"> Github repo </a>上提交一个问题，或者在<a class="ae js" href="https://twitter.com/waprin_io" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上提到我。</p><p id="0ea5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你还可以加入Kubernetes <a class="ae js" href="https://kubernetes.slack.com/" rel="noopener ugc nofollow" target="_blank"> Slack </a>上的#minikube频道(在这里获得邀请<a class="ae js" href="http://slack.kubernetes.io/" rel="noopener ugc nofollow" target="_blank">)，以及</a><a class="ae js" href="https://googlecloud-community.slack.com" rel="noopener ugc nofollow" target="_blank"> Google Cloud Slack </a>上的#python频道(在这里获得邀请<a class="ae js" href="https://gcp-slack.appspot.com/" rel="noopener ugc nofollow" target="_blank">)。</a></p></div></div>    
</body>
</html>