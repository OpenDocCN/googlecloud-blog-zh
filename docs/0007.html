<html>
<head>
<title>Basic Rails App with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Docker的基本Rails应用程序</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/basic-rails-app-with-docker-a08eba3c2197?source=collection_archive---------4-----------------------#2015-05-20">https://medium.com/google-cloud/basic-rails-app-with-docker-a08eba3c2197?source=collection_archive---------4-----------------------#2015-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij ik il im in io paragraph-image"><div class="er es if"><img src="../Images/afe4664d43bb0595a035f92417234736.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/0*UBj_9uW_wURADyBR.png"/></div></figure><h1 id="100e" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">为什么是码头工人</h1><p id="4b56" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在过去的一年里，我在Rails社区听到了越来越多关于Docker的讨论。乍一看，Docker有很多让人喜欢的地方。容器可以使多云部署更加容易。容器允许您遵循相同的流程来配置服务器和部署应用程序更新，这将使推送操作系统级安全修复变得更加简单。Docker在云托管领域的广泛采用也意味着厂商锁定的可能性降低。由于所有这些积极因素，给Docker一个尝试似乎是个好主意。</p><p id="0ec2" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">为了试验Docker，我使用rails scaffold编写了一个简单的任务列表应用程序。一旦我让它在开发模式下运行，我就使用docker容器在本地部署它。要在mac上完成这篇文章的其余部分，你需要安装<a class="ae ks" href="http://boot2docker.io/" rel="noopener ugc nofollow" target="_blank"> boot2docker </a>和一些最新版本的rails。我用的是rails 4.2.0。</p><h1 id="7816" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">创建Rails应用程序</h1><p id="5953" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">我首先创建了一个名为“todo”的新rails项目。然后，我使用脚手架添加了一个任务模型。任务有标题、注释、截止日期和完成百分比(用整数表示)。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3d54" class="lc is hi ky b fi ld le l lf lg">$ rails new todo <br/>$ rails g scaffold task title:string notes:string due:datetime completion:integer</span></pre><p id="dd5d" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">根据我过去使用Rails的经验，我知道我想在生产中使用postgres，但在开发和测试中继续使用sqlite。为此，我需要修改gem文件。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="39e1" class="lc is hi ky b fi ld le l lf lg">gem 'rails', '4.2.0'<br/>gem 'sass-rails', '~&gt; 5.0'<br/>gem 'uglifier', '&gt;= 1.3.0'<br/>gem 'coffee-rails', '~&gt; 4.1.0'<br/><br/>gem 'jquery-rails'<br/>gem 'turbolinks'<br/>gem 'jbuilder', '~&gt; 2.0'<br/>gem 'sdoc', '~&gt; 0.4.0', group: :doc<br/><br/>group :production do<br/>  gem 'pg'<br/>end<br/><br/>gem 'capistrano-rails', group: :development<br/><br/>group :development, :test do<br/>  gem 'byebug'<br/>  gem 'web-console', '~&gt; 2.0'<br/>  gem 'spring'<br/>  gem 'sqlite3'<br/>end</span></pre><p id="a8a6" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">我还需要更新database.yml以便在生产中使用postgres。我覆盖了现有的生产配置，以使用postgresql适配器。弄清楚需要如何配置用户名、密码和主机需要做更多的工作。我不太了解如何设置postgres服务器，所以我决定使用来自<a class="ae ks" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>的官方<a class="ae ks" href="https://registry.hub.docker.com/_/postgres/" rel="noopener ugc nofollow" target="_blank"> postgres镜像</a>作为数据库。</p><p id="fe47" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">postgres映像的文档指出，它有POSTGRES_USER和POSTGRES_PASSWORD的环境变量。它还公开端口5432，用于连接到其他应用程序。Docker有一个容器<a class="ae ks" href="https://docs.docker.com/userguide/dockerlinks/" rel="noopener ugc nofollow" target="_blank">链接</a>的概念，它将通过环境变量向web前端公开用户名、密码和连接信息。我使用这些环境变量在database.yml文件中设置用户名、密码和主机。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="fe21" class="lc is hi ky b fi ld le l lf lg">production:<br/>  &lt;&lt;: *default<br/>  adapter: postgresql<br/>  encoding: unicode<br/>  database: todo_production<br/>  username: &lt;%= ENV['PG_ENV_POSTGRES_USER'] %&gt;<br/>  password: &lt;%= ENV['PG_ENV_POSTGRES_PASSWORD'] %&gt;<br/>  host:     &lt;%= ENV['PG_PORT_5432_TCP_ADDR'] %&gt;</span></pre><h1 id="88d2" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">将应用程序归档</h1><p id="2e24" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">就像Rails应用程序有一个gem文件来指定需要什么gem一样，Docker应用程序有一个Docker文件来指定应用程序的设置和配置。</p><p id="bc75" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">我的Dockerfile文件基于现有的<a class="ae ks" href="https://registry.hub.docker.com/u/library/rails/" rel="noopener ugc nofollow" target="_blank">库/rails </a>容器映像。我所做的唯一更改是使用docker <a class="ae ks" href="https://docs.docker.com/reference/builder/#env" rel="noopener ugc nofollow" target="_blank"> ENV </a>命令设置RAILS_ENV，并让容器在启动后调用一个init脚本。这是我最后得到的docker文件:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="6f76" class="lc is hi ky b fi ld le l lf lg">FROM rails:onbuild <br/>ENV RAILS_ENV=production <br/>CMD ["sh", "/usr/src/app/init.sh"]</span></pre><p id="bbe3" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">Docker的一个怪癖是一个Docker文件只能包含一个CMD行。CMD行是安装完成且容器启动并运行后执行的代码行。对于rails应用程序，我需要在启动时做两件事:设置数据库，然后启动rails。我可以把它们串在一个CMD指令中，但是把它们放在shell脚本中更容易。我调用了shell脚本init.sh。</p><p id="f18c" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">init.sh文件位于Dockerfile文件旁边的RAILS_ROOT中。我使用的rails映像将RAILS_ROOT中的所有文件复制到容器中，因此init.sh与应用程序代码一起被复制。下面是init.sh中的代码:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="974a" class="lc is hi ky b fi ld le l lf lg">export SECRET_KEY_BASE=$(bundle exec rake secret) <br/>bundle exec rake db:create db:migrate <br/>bundle exec rails server -b 0.0.0.0</span></pre><p id="94a3" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">这段代码完成了基本的rails启动。它使用rake secret设置SECRET_KEY_BASE。如果我想要一个静态密钥，这也可以在done文件中完成。之后，它创建并迁移数据库(如果需要)，然后使用rails server启动服务器。如果容器图像支持它，您可以在这里使用unicorn、puma或passenger。我计划在另一篇博文中展示如何设置unicorn + nginx。</p><p id="861b" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">至此，我已经拥有了使用docker容器在本地启动我的应用程序所需的所有代码。Docker简洁得令人愉快；为Docker准备好一个基本的rails应用程序需要大约20行修改。</p><h1 id="2a7f" class="ir is hi bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo bi translated">使用Docker在本地部署</h1><p id="9f8e" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">一旦所有的代码都写好了，我需要构建docker文件来创建docker映像。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="cdda" class="lc is hi ky b fi ld le l lf lg">$ docker build -t your_user_name/todo .</span></pre><p id="f8be" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">t标志允许我给docker图像一个名称/标签。惯例是使用用户名或项目名、斜杠，然后是图像名。我把我的命名为托多。的。在命令的末尾告诉docker在当前目录中构建Dockerfile。</p><p id="5b7f" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">一旦rails应用程序的映像构建完成，我就可以开始部署了。首先需要部署数据库，以便它在rails容器启动时运行。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="519a" class="lc is hi ky b fi ld le l lf lg">$ docker run --name db -e POSTGRES_PASSWORD=password -e POSTGRES_USER=rails -d postgres</span></pre><p id="11f2" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">这里有很多关于命令行标志的东西，但是单独来看，它们非常简单。docker运行启动一个容器。—名称数据库命名新的容器数据库。如果您不提供名称，docker将为您生成一个名称。-e用于将环境变量传递给容器。postgres容器的<a class="ae ks" href="https://registry.hub.docker.com/u/library/postgres" rel="noopener ugc nofollow" target="_blank">文档</a>指出，您可以使用POSTGRES_PASSWORD和POSTGRES_USER环境变量将默认的数据库密码和用户名传递到容器中。-d告诉docker以<a class="ae ks" href="https://docs.docker.com/reference/run/#detached-vs-foreground" rel="noopener ugc nofollow" target="_blank">分离模式</a>运行集装箱。最后，postgres是您应该用来启动容器的图像的名称。</p><p id="feee" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">一旦docker run命令完成，数据库容器就开始运行。试试docker ps就知道是这样的。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="8095" class="lc is hi ky b fi ld le l lf lg">$ docker ps</span></pre><p id="258a" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">该命令显示正在运行的容器、它们的状态以及它们已经运行了多长时间。在我的机器上，数据库容器在1秒钟内启动。容器启动很快，一旦图像被下载，一两秒钟是正常的。</p><p id="1f06" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">一旦启动了数据库容器，我就可以启动web容器了。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="850c" class="lc is hi ky b fi ld le l lf lg">$ docker run --name web -d -p 3000:3000 --link db:pg your_user_name/todo</span></pre><p id="d4b6" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">-d和— name是用于启动数据库容器的标志，所以看起来应该很熟悉。your_user_name/todo是用于容器的图像的名称。-p 3000:3000将容器上的端口3000映射到承载容器的机器上的端口3000。这允许我从外部访问运行容器的web服务器。—链接数据库:pg将该容器链接到已经运行的数据库容器。这使得db容器中的所有环境变量在web容器中都可用。它还在web容器中为db容器公开的每个端口创建了一些环境变量。link参数的pg部分告诉docker用pg作为所有这些环境变量的前缀。由link创建的环境变量在database.yml中用于获取用户名、密码和主机。如果您再次查看database.yml，您可以在变量名的开头看到pg前缀。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="6dda" class="lc is hi ky b fi ld le l lf lg">username: &lt;%= ENV['PG_ENV_POSTGRES_USER'] %&gt;<br/>password: &lt;%= ENV['PG_ENV_POSTGRES_PASSWORD'] %&gt;<br/>host:     &lt;%= ENV['PG_PORT_5432_TCP_ADDR'] %&gt;</span></pre><p id="1567" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">一旦容器启动，我就可以访问网站。因为我使用boot2docker，所以我使用boot2docker ip命令来获取docker主机的ip地址。该应用程序运行在端口3000上，应该可以在浏览器中访问。在我看来是这样的:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/0004ba8b2731f323992780acd8f392af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r8sRVDiqOv7sKhaa.png"/></div></div></figure><p id="9b4f" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated">在本系列的后续部分中，我将展示如何使用<a class="ae ks" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> kubernetes </a>来管理更复杂的容器部署。我还将展示如何设置一个持久磁盘并部署到<a class="ae ks" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank"> Google容器引擎</a>。</p><p id="6c7f" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated"><a class="ae ks" href="http://www.thagomizer.com/" rel="noopener ugc nofollow" target="_blank">回去</a></p></div><div class="ab cl lm ln gp im" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="018d" class="pw-post-body-paragraph jp jq hi jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hb bi translated"><em class="ls">原载于2015年5月12日www.thagomizer.com</em><em class="ls">的</em> <a class="ae ks" href="http://www.thagomizer.com/blog/2015/05/12/basic-docker-rails-app.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls">。</em></a></p></div></div>    
</body>
</html>