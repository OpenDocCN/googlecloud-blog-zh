<html>
<head>
<title>Google Cloud Data Catalog and Looker integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google云数据目录和Looker集成</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-data-catalog-and-looker-integration-4ebefdef6a34?source=collection_archive---------0-----------------------#2020-04-30">https://medium.com/google-cloud/google-cloud-data-catalog-and-looker-integration-4ebefdef6a34?source=collection_archive---------0-----------------------#2020-04-30</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="6a9e" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">利用数据目录发现和注释Looker资产</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/b1210c690695de7c8b1705f2f429b545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCCyUqTEdHimqlpqGizyxA.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">背景照片由<a class="ae jo" href="https://unsplash.com/@laurenmancke?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">劳伦·曼克</a>在<a class="ae jo" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="3347" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di"> T </span>谷歌云数据目录团队最近宣布<a class="ae jo" href="https://cloud.google.com/blog/products/data-analytics/data-catalog-metadata-management-now-generally-available" rel="noopener ugc nofollow" target="_blank">其产品现已正式发布，并准备接受定制(即用户定义)条目</a>！这一全新功能为集成开辟了空间，现在用户可以利用<a class="ae jo" href="https://towardsdatascience.com/boosting-the-data-governance-journey-with-google-cloud-data-catalog-d67acc3e3ffb" rel="noopener" target="_blank"> Data Catalog众所周知的潜力</a>来管理几乎任何类型的数据资产的元数据。</p><p id="4141" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">为了演示它是如何工作的，我将在这篇博文中分享将数据目录连接到市场领先的商业智能/数据可视化工具的设计思想和示例代码，包括<a class="ae jo" href="http://looker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hk"> Looker </strong> </a>元数据集成。它们来自参与开发完全可操作的<strong class="jr hk">样本连接器</strong>的经验，可在<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-bi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上公开获得。</p><blockquote class="ku kv kw"><p id="711c" class="jp jq kx jr b js jt ik ju jv jw in jx ky jz ka kb kz kd ke kf la kh ki kj kk hc bi translated"><strong class="jr hk">免责声明:在撰写本文时(2020年4月)，谷歌和/或谷歌云不正式支持任何将数据目录连接到非GCP系统的工具。您将在这里发现的仅仅是我作为数据目录早期采用者的经验的结果。</strong></p></blockquote></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="04bf" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">技术要求</h1><p id="e52e" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">让我们从实现集成的最低技术要求开始:</p><ol class=""><li id="62a1" class="mf mg hj jr b js jt jv jw jy mh kc mi kg mj kk mk ml mm mn bi translated">from Looker:允许对属于托管在给定服务器/实例中的资产的元数据进行读访问；</li><li id="84d2" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mk ml mm mn bi translated">从数据目录:允许用户摄取表示由旁观者管理的资产的元数据；</li><li id="16fd" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mk ml mm mn bi translated">连接器:<strong class="jr hk">从Looker实例中抓取</strong>元数据的组件，<strong class="jr hk">准备</strong>适合数据目录的实体模型的信息，<strong class="jr hk">接收</strong>准备好的元数据。</li></ol><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et mt"><img src="../Images/acbcdd1b3930163375d080d48d8fcc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8tqn7wwgCAA_7_iilwE6A.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片1 </strong>。架构概述:集成数据目录和Looker</figcaption></figure><p id="0607" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">由于1和2已经由Looker和Google Cloud提供，我们的重点是开发一个软件组件来解决第三个问题。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="810e" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">适应不同的概念</h1><p id="5841" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">这种集成的第一步是将业务实体从源系统映射到目标系统。<strong class="jr hk">选择了五种Looker类型来说明这一点:文件夹、Look、仪表板、仪表板元素(又名Tile)和查询</strong>。</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et mu"><img src="../Images/d7c430c3913959f5f5b4da04ebb1cd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Yt0AH1m7K6Iys2P7e2C1w.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片二</strong>。数据目录和Looker集成:调整实体模型</figcaption></figure><p id="d4c2" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我们需要调整这样的类型，以适应更通用的数据目录模型。所有这些类型的Looker资产都将变成目录中的条目，因为<strong class="jr hk">条目</strong>是那里的一等公民。它们将通过添加到<code class="dv mv mw mx my b">Entry</code>类的新的<code class="dv mv mw mx my b">userSpecifiedType</code>属性来区分，我们将在下面看到。</p><p id="22bc" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">但是Looker实体的属性比目录条目所能支持的要多得多…在这种情况下，我们可以使用<strong class="jr hk">标签</strong>来注释它们，避免遗漏有意义的信息。标签基于<strong class="jr hk">模板</strong>，这意味着我们将利用三种数据目录主要类型来实现目标。顺便说一句，我想你至少对它们有一个基本的了解。万一你没有，请看一下 <a class="ae jo" rel="noopener" href="/google-cloud/data-catalog-hands-on-guide-a-mental-model-dae7f6dd49e"> <em class="kx">这篇博文</em> </a> <em class="kx">。</em></p><p id="1bf4" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">当涉及到实体关联和父/子关系时，有一个缺失的部分。例如，文件夹包含多个仪表板和外观；仪表板包含多个磁贴；给定的查询可以向多个外观和图块提供信息。数据目录目前不提供对在自定义类型中构建这种关系的本机支持。同样，标签可以帮助我们绘制地图。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="e10e" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">Looker API和客户端SDK</h1><p id="5a39" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">一旦总体设计决定已经提出，是时候看看一些实际的东西了。Looker拥有丰富的REST API，本文将讨论以下资源:</p><ul class=""><li id="dd67" class="mf mg hj jr b js jt jv jw jy mh kc mi kg mj kk mz ml mm mn bi translated"><a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1/folder" rel="noopener ugc nofollow" target="_blank">文件夹:管理文件夹</a></li><li id="5a8f" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated"><a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1/look" rel="noopener ugc nofollow" target="_blank">外观:运行和管理外观</a></li><li id="b603" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated"><a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1/dashboard" rel="noopener ugc nofollow" target="_blank">仪表板:管理仪表板</a></li><li id="1758" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated"><a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1/query" rel="noopener ugc nofollow" target="_blank">查询:运行和管理查询</a></li></ul><p id="3e49" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">请浏览这些页面，你会清楚地知道我所说的丰富的API是什么意思。您会注意到每项资产都有大量信息。</p><p id="7dce" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">可以通过最流行语言中可用的<a class="ae jo" href="https://github.com/looker-open-source/sdk-codegen" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hk">预建客户端SDK</strong></a>以编程方式访问API，包括<strong class="jr hk"> Python </strong>和<strong class="jr hk"> Javascript </strong>。这里展示的示例连接器和代码片段都是用Python编写的。</p><p id="29c3" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">API客户端需要一个配置文件，其内容在<a class="ae jo" href="https://github.com/looker-open-source/sdk-codegen/blob/master/looker-sample.ini" rel="noopener ugc nofollow" target="_blank"> SDK文档</a>中有描述。一旦有了合适的文件，实例化客户机就像下面这样简单:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="na nb l"/></div></figure><blockquote class="ku kv kw"><p id="5925" class="jp jq kx jr b js jt ik ju jv jw in jx ky jz ka kb kz kd ke kf la kh ki kj kk hc bi translated"><strong class="jr hk">旁注</strong> : <a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1/api-auth" rel="noopener ugc nofollow" target="_blank"> ApiAuth: API认证</a>描述了如何在API中进行认证。该文档提到了登录所需的客户端凭证，必须通过在Looker管理控制台中的用户帐户上创建API3密钥来获得。Looker管理控制台的快捷方式是https://&lt;YOUR-Looker-INSTANCE&gt;/Admin/users/API 3 _ key/&lt;YOUR-USER-ID&gt;。</p></blockquote><p id="1b24" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">客户端可以包装任何API调用。例如，假设您想要检索给定文件夹的信息。API为<a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1/folder#get_folder" rel="noopener ugc nofollow" target="_blank">https://docs . looker . com/reference/API-and-integration/API-reference/v 3.1/folder # get _ folder</a>。要以编程方式执行调用，我们需要:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="na nb l"/></div></figure><p id="e5d9" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">请注意<code class="dv mv mw mx my b">fields</code>参数:它允许我们在响应中指定我们想要的字段，而不是检索API提供的所有信息。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="aa0d" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">抓取Looker元数据</h1><p id="64f7" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">我们已经探索了两种搜集Looker元数据的策略<strong class="jr hk"/>——<strong class="jr hk"/>让我把它们称为<strong class="jr hk">渴望</strong>和<strong class="jr hk">懒惰</strong>。</p><p id="15c9" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><strong class="jr hk"> Eager </strong> scraping允许使用一个API调用从给定类型的所有资产中读取元数据。这对读取<strong class="jr hk">公共资产(通常是用户管理的)元数据</strong>很有用。在读取所有元数据后，连接器遍历这些元数据，并使用属性值来重建对象之间的关系，例如，将仪表板数组追加/嵌套到其父文件夹。</p><p id="6570" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><strong class="jr hk">另一方面，惰性</strong>抓取在处理<strong class="jr hk">特殊(包括系统管理的)</strong>资产的信息时可能有用，例如所谓的<code class="dv mv mw mx my b">lookml</code>文件夹及其子文件夹，它们负责处理<a class="ae jo" href="https://docs.looker.com/data-modeling/learning-lookml/what-is-lookml" rel="noopener ugc nofollow" target="_blank"> LookML </a>内容。它需要一系列后续的API调用来检索嵌套的资产信息。</p><p id="b79d" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">下一张图说明了不同之处。从我们到目前为止所看到的，混合它们是一个很好的实践，因为它们填补了彼此留下的空白。</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et nc"><img src="../Images/090108b4084b0260831f5e7eaabdc5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUTtvCcMnSIpVxkX8HE7SA.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片3 </strong>。渴望与懒惰的Looker元数据抓取</figcaption></figure><p id="820c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">让我补充几句关于实现急切抓取时的编码决策。检索对象列表有两个主要选项:<code class="dv mv mw mx my b">sdk.all_*()</code>和<code class="dv mv mw mx my b">sdk.search_*()</code>。所有* 方法返回<strong class="jr hk">缩写对象</strong>。<em class="kx"> search </em> *方法更加灵活，因为您可以在响应中指定您想要的字段。总而言之:</p><ul class=""><li id="34b9" class="mf mg hj jr b js jt jv jw jy mh kc mi kg mj kk mz ml mm mn bi translated"><code class="dv mv mw mx my b">sdk.all_folders()</code> response并没有包含你实际可能需要的所有字段，所以我建议用<code class="dv mv mw mx my b">sdk.search_folders()</code>来代替。此外，空文件夹不包括在<em class="kx"> all_folders </em>响应中；</li><li id="631a" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated"><code class="dv mv mw mx my b">sdk.all_dashboards()</code> response并没有包含你实际可能需要的所有字段，所以我推荐用<code class="dv mv mw mx my b">sdk.search_dashboards()</code>来代替。请提醒LookML仪表板不包含在<em class="kx"> search_dashboards </em>响应中，需要惰性处理；</li><li id="fadd" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated"><code class="dv mv mw mx my b">sdk.all_looks()</code> response并没有包含你实际可能需要的所有字段，所以我推荐用<code class="dv mv mw mx my b">sdk.search_looks()</code>来代替。</li></ul><p id="d705" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">总之，我们优先考虑渴望的方法，而不是懒惰的方法。Eager意味着更少的API调用和更多的内存处理，因此它更快。Lazy仅用于处理不可急切解决的极端情况:例如，LookML仪表板不包含在<code class="dv mv mw mx my b">sdk.search_dashboards()</code> —急切抓取—响应中，因此它们被延迟处理。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="76d0" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">准备数据目录的元数据</h1><p id="045f" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">此时，我们已经从Looker那里获得了所需的所有信息。是时候将它们转换成数据目录实体了。创建条目似乎是一个很好的起点，因为其他一切都依赖于它们。</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="na nb l"/></div></figure><p id="9d25" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><em class="kx">以</em> <code class="dv mv mw mx my b"><em class="kx">__</em></code> <em class="kx">开头的方法代表助手类的东西，不在代码片段的范围内。</em></p><p id="e79b" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">上面的代码是不言自明的(即使对那些不了解Python的人来说…)，但是有一些要点需要注意:</p><ul class=""><li id="8b76" class="mf mg hj jr b js jt jv jw jy mh kc mi kg mj kk mz ml mm mn bi translated">第5行，<code class="dv mv mw mx my b">entry = types.Entry()</code>:目前为止只有Google Cloud的数据资源是由Data Catalog管理的。更具体地说:在产品第一次发布测试版时，只管理自动同步的条目(指BigQuery和Pub/Sub资产);几个月后，用户能够手动创建引用GCS文件集的条目。从现在开始，我们可以创建任何类型的条目；</li><li id="84f0" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated">第9行，<code class="dv mv mw mx my b">YOUR-ENTRY-GROUP-ID</code>:每个条目必须属于一个条目组，通过一个非常简单的API调用在条目之前创建，我们将在下一节中看到。作为参考，BigQuery和Pub/Sub条目的自动管理组具有<code class="dv mv mw mx my b">@bigquery</code>和<code class="dv mv mw mx my b">@pubsub</code>id。用户定义的条目将属于用户定义的组— <a class="ae jo" href="https://cloud.google.com/data-catalog/docs/how-to/filesets" rel="noopener ugc nofollow" target="_blank">与GCS文件集使用的方法</a>完全相同。因为项目和位置id被添加到条目组id的前面，所以在这一点上可以简单地使用<code class="dv mv mw mx my b">looker</code>;</li><li id="0e45" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated">第12行，<code class="dv mv mw mx my b">entry.user_specified_system = 'looker'</code>:所有Looker相关条目的公共值；</li><li id="f317" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated">第13行，<code class="dv mv mw mx my b">entry.user_specified_type = 'look'</code>:用于区分与Looker相关的条目类型。在本讨论的范围内，以下值可用于实现该属性:<code class="dv mv mw mx my b">dashboard</code>、<code class="dv mv mw mx my b">dashboard_element</code>、<code class="dv mv mw mx my b">folder</code>、<code class="dv mv mw mx my b">look</code>和<code class="dv mv mw mx my b">query</code>。</li></ul><p id="2664" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">正如我在<em class="kx">适应不同的概念</em>一节中提到的，条目的属性只覆盖了一小部分查看者资产的元数据。但是我们可以利用数据目录标签来避免丢失有价值的信息。首先，让我们来看一个标签模板建议:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="na nb l"/></div></figure><p id="5182" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这个模板中的标签可以附加到每个与外观相关的条目上。通过这样做，我们丰富了数据目录中可用的元数据，就好像我们向这些条目“添加”了四个额外的字段:<code class="dv mv mw mx my b">Folder name</code>、<code class="dv mv mw mx my b">Query Id</code>、<code class="dv mv mw mx my b">Data Catalog Entry for the Query</code>和<code class="dv mv mw mx my b">Excel File Url</code>。<em class="kx">文件夹名</em>、<em class="kx">查询id </em>、<em class="kx"> Excel文件</em>是典型的技术元数据。<em class="kx">查询</em>的条目可以通过引用<a class="ae jo" href="http://console.cloud.google.com/datacatalog" rel="noopener ugc nofollow" target="_blank">数据目录的web控制台</a>中相应查询条目的HTML链接来实现。这个链接可以在准备阶段通过一个非常简单的算法生成。</p><p id="6ac1" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">当丰富其他资产类型的元数据时，同样的方法也适用。关于查询有一个有趣的例子:Looker允许我们通过<a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1/query#run_query" rel="noopener ugc nofollow" target="_blank"> Run Query </a>方法获得任何查询的SQL语句(将<code class="dv mv mw mx my b">sql</code>作为<code class="dv mv mw mx my b">result_format</code>参数传递)。所以SQL语句变成了查询相关标记中的一个属性。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="40ff" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">元数据摄取</h1><p id="f0e0" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">这是集成过程的最后一个阶段，其中的条目和标记被接收到数据目录中。如前一节所述，每个条目都必须属于一个条目组，所以让我们从创建它开始:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="na nb l"/></div></figure><p id="e9f1" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">然后，我们可以遍历这些条目，并要求Data Catalog保存它们以及它们的标签:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="na nb l"/></div></figure><p id="c0a0" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">一旦接收过程完成，您就可以通过使用数据目录UI来查看新的元数据。键入<code class="dv mv mw mx my b">system=looker</code>和<em class="kx">搜索</em>:</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et nd"><img src="../Images/7c72ed842c77f42a8492386885a017f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rD8fpHWH-FIr9ZP3p7Rgjw.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片4 </strong>。使用数据目录用户界面搜索外观资产</figcaption></figure><p id="5139" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">下图(截屏经过处理以提高可读性)显示了一个示例查询的条目和标签:</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et ne"><img src="../Images/10c1193a9195024f7b367d3bf1b59789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_p26Sic2SLZQ1M8PKBynA.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片5 </strong>。Looker通过数据目录UI查询元数据</figcaption></figure><p id="8dac" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">并且<strong class="jr hk">刮-准备-摄取</strong>过程<strong class="jr hk">完成</strong>！</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h1 id="78b8" class="li lj hj bd lk ll lm ln lo lp lq lr ls ip lt iq lu is lv it lw iv lx iw ly lz bi translated">样本连接器</h1><p id="94ba" class="pw-post-body-paragraph jp jq hj jr b js ma ik ju jv mb in jx jy mc ka kb kc md ke kf kg me ki kj kk hc bi translated">GitHub 上的示例连接器<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-bi" rel="noopener ugc nofollow" target="_blank">涵盖了本文中讨论的所有主题。你可以随便拿，按照说明跑。顺便说一下，欢迎投稿！</a></p><blockquote class="nf"><p id="25b8" class="ng nh hj bd ni nj nk nl nm nn no kk dy translated">它是根据Apache License版许可的，以“原样”为基础发布，没有任何种类的担保或条件，无论是明示的还是暗示的。</p></blockquote><p id="3ad2" class="pw-post-body-paragraph jp jq hj jr b js np ik ju jv nq in jx jy nr ka kb kc ns ke kf kg nt ki kj kk hc bi translated">与文本一起提供的代码片段基于连接器，但出于可读性的原因进行了简化。您会注意到，实际代码中加入了更多的一致性检查、异常处理，不仅处理创建，还处理条目和标签的更新和删除操作。所需的模板在摄取阶段开始时创建。</p><p id="3160" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">此外，它还分为两个主要部分:<code class="dv mv mw mx my b">datacatalog-connector-commons</code>和<code class="dv mv mw mx my b">datacatalog-connector-looker</code>。还有其他非GCP系统的示例连接器，如Tableau、<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-hive" rel="noopener ugc nofollow" target="_blank"> Hive </a>、<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors-rdbms" rel="noopener ugc nofollow" target="_blank"> MySQL、Oracle和其他</a>。它们共享的代码，主要是与摄取阶段相关的类，在<a class="ae jo" href="https://github.com/GoogleCloudPlatform/datacatalog-connectors" rel="noopener ugc nofollow" target="_blank"><em class="kx">data catalog-connector-commons</em></a>组件中进行管理。理想情况下，通过设计，只有该组件应该与数据目录自定义类型API进行通信。另一方面，所有Looker通信和特定元数据操作代码都驻留在<em class="kx">data catalog-connector-Looker</em>上。如下图所示，commons组件对外部源系统一无所知:</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et nu"><img src="../Images/4981e590e96eda599e027485d6992635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QC0ohAaP3fUgne5c47bOww.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd lk">图片6 </strong>。数据目录和Looker集成组件</figcaption></figure><p id="2706" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">由于Looker目前没有webhooks或类似的技术来潜在地支持增量同步，<strong class="jr hk">属于给定服务器的所有资产在每次执行时都被同步</strong>。</p><p id="5f5f" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">测试表明，从Looker中抓取1，000项资产，准备并将其纳入数据目录需要大约25分钟。为每个资产生成一个条目和一个<em class="kx">富化</em>标签。<strong class="jr hk">每个条目+标签对需要4次API调用才能完全同步:1次获取条目，1次创建或更新条目，1次获取标签，最后1次创建或更新标签。</strong>数据目录目前不支持批量API操作。</p><p id="7f77" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">就这些了，伙计们！</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h2 id="169e" class="nv lj hj bd lk nw nx ny lo nz oa ob ls jy oc od lu kc oe of lw kg og oh ly oi bi translated">参考</h2><ul class=""><li id="dce4" class="mf mg hj jr b js ma jv mb jy oj kc ok kg ol kk mz ml mm mn bi translated"><strong class="jr hk">谷歌云数据目录动手指南，心智模型</strong>:<a class="ae jo" rel="noopener" href="/google-cloud/data-catalog-hands-on-guide-a-mental-model-dae7f6dd49e">https://medium . com/Google-Cloud/Data-Catalog-hands-on-guide-a-mental-model-DAE 7 f 6 DD 49 e</a></li><li id="5e28" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated"><strong class="jr hk"> Looker API 3.1参考</strong>:<strong class="jr hk"/><a class="ae jo" href="https://docs.looker.com/reference/api-and-integration/api-reference/v3.1" rel="noopener ugc nofollow" target="_blank">https://docs . Looker . com/Reference/API-and-integration/API-Reference/v 3.1</a></li><li id="794e" class="mf mg hj jr b js mo jv mp jy mq kc mr kg ms kk mz ml mm mn bi translated"><strong class="jr hk"> Looker客户端SDK Codegen</strong>:【https://github.com/looker-open-source/sdk-codegen T2】</li></ul></div></div>    
</body>
</html>