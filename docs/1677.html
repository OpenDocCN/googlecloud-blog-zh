<html>
<head>
<title>How to make an ML model inference on KFServing from container apps (web, Spark) running on Google Cloud Kubernetes Engine?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Google Cloud Kubernetes引擎上运行的容器app(web，Spark)在KFServing上做出ML模型推断？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0?source=collection_archive---------0-----------------------#2020-11-20">https://medium.com/google-cloud/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0?source=collection_archive---------0-----------------------#2020-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="131d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，您有一个运行在<a class="ae jd" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>平台上的电子商务应用程序和/或大数据应用程序(如Apache Spark )(一个用于自动化部署、扩展和管理容器化应用程序的开源容器编排系统)。现在，您需要在现有的Kubernetes基础架构中使用您已建立的DevOps实践来服务预训练的机器学习模型。本解决方案指南探索了一种自以为是的方法，使用您已建立的DevOps实践在这个Kubernetes基础架构上服务于机器学习(ML)模型。该指南涵盖以下主题:</p><ul class=""><li id="99d0" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">开发一个web应用程序和一个<a class="ae jd" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>应用程序，并在本地开发环境中测试它们。</li><li id="08ae" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">提供一个GKE环境来部署和测试执行ML模型推理的应用程序。</li><li id="c36f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在<a class="ae jd" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">Google Kubernetes Engine</a>(GKE)上托管的<a class="ae jd" href="https://github.com/kubeflow/kfserving" rel="noopener ugc nofollow" target="_blank"> KFServing </a>(无服务器模型推理平台)上部署一个预先训练好的<a class="ae jd" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>(一个端到端ML框架)模型——这是一个在Google Cloud上完全托管的Kubernetes容器编排服务。</li></ul><p id="60a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么<a class="ae jd" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a> (GKE)？</p><p id="4884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GKE是一个全面管理的Kubernetes即服务，它提供集群自动扩展、自动修复、工作负载和网络安全、集成日志记录和监控、内置仪表板、GPU和TPU支持、通过<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/sandbox-pods" rel="noopener ugc nofollow" target="_blank"> GKE沙箱</a>的容器隔离等等。。请查看<a class="ae jd" href="https://cloud.google.com/kubernetes-engine#all-features" rel="noopener ugc nofollow" target="_blank">文档</a>以获取最新功能的详细列表。</p><p id="b8e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么<a class="ae jd" href="https://github.com/kubeflow/kfserving" rel="noopener ugc nofollow" target="_blank"> KFServing </a>？</p><p id="0523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">KFServing使用<a class="ae jd" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">容器</a>作为底层基础设施，支持Kubernetes上的无服务器推理。它抽象了不同的ML框架，如TensorFlow、PyTorch和XGBoost。它支持自动缩放、缩放到零、金丝雀展开、GPU等等。</p><h1 id="6e28" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">开发和部署解决方案的逐步方法</h1><p id="92a8" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您可以继续使用现有的CI/CD基础架构和DevOps实践来构建解决方案。您的Web应用程序和Spark作业可以在同一个Kubernetes集群中对ML模型推理应用程序(运行在KFServing中)进行低延迟调用。)您可以根据自己的性能需求，为web应用程序、spark应用程序和ML模型推理应用程序的底层kubernetes节点选择不同的机器类型。例如，您可以为ML模型推理应用程序使用CPU优化或内存优化的机器类型，为web应用程序使用<a class="ae jd" href="https://cloud.google.com/compute/docs/machine-types#e2_machine_types" rel="noopener ugc nofollow" target="_blank"> E机器类型</a>，为Spark应用程序使用<a class="ae jd" href="https://cloud.google.com/compute/docs/machine-types#n2_machine_types" rel="noopener ugc nofollow" target="_blank"> N2机器类型</a>。</p><p id="9503" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的部署架构是该解决方案的可视化表示:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/02467048a47b564f3d7aab9f622af050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S3nQIQWPcBSphYxh"/></div></div></figure><p id="af42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的序列图显示了web应用程序和ml模型推理端点之间的交互:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/29e164eeb5cbf204bc896e9119abc0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-YnJsYBtGZphPuKj"/></div></div></figure><p id="1695" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的序列图显示了Spark应用程序和ml模型推理端点之间的交互:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/a9bd9c1290f177c4002c88053aa4bade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X2JfKYWnpfkKyQuR"/></div></div></figure><p id="a926" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案使用以下环境:</p><ol class=""><li id="b648" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc lh jk jl jm bi translated">开发环境—Mac(您将使用的命令已经在Mac上测试过。)你可以使用<a class="ae jd" href="https://cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank">谷歌计算引擎</a>(高性能虚拟机)或<a class="ae jd" href="https://cloud.google.com/dataproc" rel="noopener ugc nofollow" target="_blank">谷歌数据处理器</a>(一个托管的Hadoop和Spark集群)</li><li id="dfcf" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated">在本地开发和单元测试所有的容器化应用程序。在GKE进行集成测试。</li><li id="976c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated">使用<a class="ae jd" href="https://cloud.google.com/sdk" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a> (gcloud和gsutil命令行工具)与Google云服务进行交互。</li><li id="4172" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云</a>环境</li></ol><p id="7233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案使用谷歌云的以下付费组件:</p><ul class=""><li id="f71c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae jd" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">谷歌云Kubernetes引擎</a></li><li id="2317" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank">谷歌云存储</a></li><li id="ae04" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">谷歌<a class="ae jd" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">容器注册表</a></li><li id="8c49" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">谷歌云运行</a></li><li id="e0f9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">谷歌<a class="ae jd" href="https://cloud.google.com/logging" rel="noopener ugc nofollow" target="_blank">云日志</a></li></ul><p id="32df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">web应用程序将使用Java，spark应用程序将使用Scala。您将在<a class="ae jd" href="https://github.com/dpanigra/solutions/tree/main/ml_inference" rel="noopener ugc nofollow" target="_blank"> git存储库</a>中找到所有代码、构建文件、命令、输入文件、预训练模型、应用程序war文件和spark应用程序jar文件。</p><p id="e5c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案需要以下步骤:</p><ol class=""><li id="c465" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#746b">确定一个预先训练好的机器学习模型</a></li><li id="1c97" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#d845">在开发环境中检查模型的签名</a></li><li id="ac50" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#c2c3">创建一个输入数据集，用于测试Spark应用程序</a></li><li id="bf81" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#c9d3">在<a class="ae jd" href="https://www.tensorflow.org/tfx/serving/docker" rel="noopener ugc nofollow" target="_blank"> TensorFlow Serving </a>中部署模型</a>，用于开发环境中的模型推理</li><li id="563a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#4b05">在开发环境中开发和测试Web应用</a></li><li id="c107" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0 #d3ff">创建web应用程序的容器，并在开发环境中进行测试。</a>推送到Google <a class="ae jd" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">容器注册表</a></li><li id="26d4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#2c93">在开发环境中开发和测试Spark应用</a></li><li id="1aae" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#ba5f">构建Spark图像并将</a>图像推送到Google <a class="ae jd" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">容器注册表</a></li><li id="ebf9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#8ef0">提供一个谷歌Kubernetes引擎(GKE)集群</a></li><li id="c816" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#c96d">在GKE部署Web应用</a></li><li id="6243" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#f63e">在GKE部署KFServing并测试样本TensorFlow flowers模型</a></li><li id="8486" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#eb9b">在GKE部署rpm模型并测试模型推断</a></li><li id="843d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#9299">测试在GKE上运行的Spark应用程序和Web应用程序</a></li><li id="b8ad" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/@dpani/how-to-make-an-ml-model-inference-on-kfserving-from-container-apps-web-spark-running-on-google-c50ca849c9f0#ff6d">在谷歌云日志中监控GKE的应用日志</a></li><li id="baff" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lh jk jl jm bi translated"><em class="li">在开发环境中安装所有必要的软件</em></li></ol><p id="8cf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参考git repository commands.txt获取完整的说明，包括构建解决方案时将使用的变量和工作目录。</p><h1 id="746b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">识别预训练的机器学习模型</h1><p id="0d63" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">第一步是从您现有的ML Ops渠道中收集一个预先训练好的ML模型。你当然可以使用相同的GKE基础设施来为你所有的机器学习模型训练、测试和验证提供一个集中的开发和操作平台。ML和模型训练通常是资源密集型过程，这使得它难以在本地机器上运行。Kubernetes利用分布式计算来提供所需的额外资源。你可以使用<a class="ae jd" href="https://www.kubeflow.org/docs/about/kubeflow/" rel="noopener ugc nofollow" target="_blank">kube flow</a>(Kubernetes的机器学习工具包)或者你可以根据你的需要有选择地只使用管道框架<a class="ae jd" href="https://www.kubeflow.org/docs/pipelines/overview/pipelines-overview/" rel="noopener ugc nofollow" target="_blank"> Kubeflow Pipelines </a>。对于当前解决方案，您将使用在“<a class="ae jd" rel="noopener" href="/@dpani/how-to-build-an-end-to-end-propensity-to-purchase-solution-using-bigquery-ml-and-kubeflow-pipelines-cd4161f734d9">如何使用BigQuery ML和Kubeflow管道</a>构建端到端购买倾向解决方案”中创建的预训练模型。</p><p id="8eae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里简单介绍一下“<a class="ae jd" rel="noopener" href="/@dpani/how-to-build-an-end-to-end-propensity-to-purchase-solution-using-bigquery-ml-and-kubeflow-pipelines-cd4161f734d9">如何使用BigQuery ML和Kubeflow Pipelines构建端到端购买倾向解决方案</a>”解决方案:购买倾向用例广泛适用于零售、金融等多个垂直行业。该解决方案向您展示了如何使用<a class="ae jd" href="https://cloud.google.com/bigquery-ml/docs" rel="noopener ugc nofollow" target="_blank">Google Cloud big query ML</a>(BQML)<a class="ae jd" href="https://cloud.google.com/ai-platform/prediction/docs" rel="noopener ugc nofollow" target="_blank">Google Cloud AI Platform Prediction</a>和<a class="ae jd" href="https://www.kubeflow.org/docs/pipelines/overview/pipelines-overview/" rel="noopener ugc nofollow" target="_blank"> Kubeflow Pipelines </a> (KFP)构建端到端解决方案(固执己见)，使用<a class="ae jd" href="https://console.cloud.google.com/marketplace/details/obfuscated-ga360-data/obfuscated-ga360-data?filter=solution-type:dataset" rel="noopener ugc nofollow" target="_blank"> Google Analytics数据集</a>来确定<strong class="ih hj">哪些客户有购买倾向</strong>。固执己见的解决方案在开发管道组件时，特别结合了一些<a class="ae jd" href="https://en.wikipedia.org/wiki/Systems_development_life_cycle" rel="noopener ugc nofollow" target="_blank"> SDLC </a>的最佳实践。您可以使用该解决方案通过电子邮件或邮政渠道在离线活动中接触到您的目标客户。当客户在您的网站上浏览您的产品时，您也可以通过当场决策在在线活动中使用它，向客户推荐一些产品或触发个性化电子邮件。</p><p id="b67d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您还没有构建模型，那么您现在就可以这样做，或者您可以使用我们在git存储库中提供的模型。这是一个张量流模型。BQML将模型导出到一个<a class="ae jd" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank"> Google云存储</a>桶中。在本解决方案的剩余部分，您将使用零售倾向模型(rpm)。</p><h1 id="d845" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在开发环境中检查模型的签名</h1><p id="05fa" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在识别模型之后，您需要理解模型的输入和输出参数。您可以从模型开发人员那里收集信息，也可以自己检查模型。在当前解决方案中，您将执行后者。您将使用参数知识在您的应用程序(web应用程序和Spark应用程序)中使用它们，创建适当的输入数据集，并组成json数据有效负载来测试rpm模型推断。</p><p id="8315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本节中，您需要执行以下操作:</p><ul class=""><li id="4311" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">安装saved_model_cli工具来检查TensorFlow rpm模型</li><li id="5a7b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">下载rpm工件</li><li id="8dd9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">检查rpm保存的模型<a class="ae jd" href="https://www.tensorflow.org/tfx/serving/signature_defs" rel="noopener ugc nofollow" target="_blank">签名</a></li></ul><h1 id="f248" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">安装工具以检查张量流模型</h1><p id="47c9" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您可以通过两种方式安装工具saved_model_cli:安装tensorflow包或从源代码构建工具。您将在您的开发环境中执行前者。如果您只想使用该工具而不是tensorflow包，您可以在git repo中找到使用blaze构建的命令。</p><p id="4b0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令将安装saved_model_cli工具:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="548f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是最后一个命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ll"><img src="../Images/c1b9a7e996ceb28c6b93e51d934f10a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4knP8UO6s_CYwsu2ORLWtw.png"/></div></div></figure><p id="eb72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上输出显示您使用的是saved_model_cli版本0.1.0。如果您有不同的版本，应该不会有问题。但是要注意模型导出的结构和格式。</p><h1 id="809d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">从Google云存储中下载rpm工件</h1><p id="4274" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您现在将下载BQML导出到<a class="ae jd" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank">云存储</a>的TensorFlow模型。您已经在之前的解决方案“<a class="ae jd" rel="noopener" href="/@dpani/how-to-build-an-end-to-end-propensity-to-purchase-solution-using-bigquery-ml-and-kubeflow-pipelines-cd4161f734d9">如何使用BigQuery ML和Kubeflow Pipelines </a>构建端到端购买倾向解决方案”中创建了模型。或者，您可以使用git存储库中可用的模型。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="2845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上述gsutil命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lm"><img src="../Images/8d2d76a69d9d9afb8d37e4c43a83addc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLzITXFUGwsgY54a7lQrqQ.png"/></div></div></figure><p id="456f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">强制文件是saved_model.pb、variables.data-0000-of-00001和variable.index。您可以忽略之前为之前的解决方案创建的eval_details.txt和train_detail.txt，以便保留rpm模型的不同版本。稍后您将删除它们。</p><h1 id="c5b9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">检查rpm保存的模型签名定义</h1><p id="d905" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您将使用saved_model_cli工具来理解模型的输入和输出参数(SignatureDef。)</p><p id="1537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令将打印rpm保存模型的签名定义:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="5f2e" class="ls jt hi lo b fi lt lu l lv lw"># prints the inputs and the outputs of the rpm saved model<br/>$PATH_TO_SAVED_MODEL_CLI/saved_model_cli show \<br/>  --dir $HOME/rpm/$RPM_MODEL_VER/ \<br/>  --all</span></pre><p id="c117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上述命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lx"><img src="../Images/d00126a78d31d8458c7b7e2f85d9395e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08-jPISNxg4CAVc3FxQGug.png"/></div></div></figure><p id="5561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rpm模型期望“反弹”和“现场时间”作为输入。该模型然后返回三个输出参数，即“预测购买返回访问”、“购买返回访问预测”和“购买返回访问预测值”。</p><h1 id="c2c3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建用于测试应用程序的输入数据集</h1><p id="a87c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您需要基于rpm模型的SignatureDef创建一个输入数据集，您将使用它来测试Spark应用程序。您将在git存储库中找到样本数据集。稍后，当您准备在开发和GKE环境中测试Spark应用程序时，您将使用该数据集。</p><p id="761b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将创建包含以下信息的文件:</p><ul class=""><li id="4f4f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">fullVisitorId</li></ul><p id="5850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将忽略fullVisitorId列。你可以把它作为一把钥匙，将<a class="ae jd" rel="noopener" href="/@dpani/how-to-build-an-end-to-end-propensity-to-purchase-solution-using-bigquery-ml-and-kubeflow-pipelines-cd4161f734d9">购买倾向预测</a>与客户关系管理(CRM)系统数据(如电子邮件地址)整合起来，使客户拓展更加容易。有关此类整合的示例，请参见<a class="ae jd" href="https://support.google.com/analytics/answer/9250031?hl=en" rel="noopener ugc nofollow" target="_blank"> Salesforce营销云受众整合</a>。本文介绍了如何将Google Analytics 360与Salesforce营销云集成，以便您可以在Salesforce电子邮件和SMS直接营销活动中使用Analytics 360受众。</p><ul class=""><li id="759b" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="li">弹跳</em></li></ul><p id="bae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的rpm模型需要这个作为输入参数。</p><ul class=""><li id="a46d" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="li">现场时间</em></li></ul><p id="de6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的rpm模型需要这个作为输入参数。</p><ul class=""><li id="e8d2" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="li">威尔_买_上_回_访</em></li></ul><p id="6379" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以用这个来比较我们的模型推理是如何执行的。您正在使用一个测试数据集，但是在生产中，您不会事先知道这个值，因为ml模型将为我们预测这个值。模型性能优化超出了当前解决方案指南的范围。</p><p id="97cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令将打印样本数据集:</p><p id="3379" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令将打印rpm保存模型的签名定义:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="7832" class="ls jt hi lo b fi lt lu l lv lw"># Refer to the commands.txt for detailed commands in the “4. input file to test the Spark application” section<br/># peek the input csv file<br/>head -n 3 $HOME/sparkjob/rpm-hdfs-input.csv</span></pre><p id="87f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上述命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lx"><img src="../Images/7f809d78c495e75f8f0b6a968d00bac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mYMjkklJXfBsIxhw0B1u1Q.png"/></div></div></figure><h1 id="c9d3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在TensorFlow中部署模型，用于开发环境中的模型推理</h1><p id="7df4" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您将在TensorFlow Serving (TFServing)中部署rpm模型以获得一个端点。您将使用端点来检查请求/响应是如何工作的，并在开发环境中对应用程序(web应用程序和Spark应用程序)进行单元测试。</p><p id="7d33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"<a class="ae jd" href="https://www.tensorflow.org/tfx/serving/architecture" rel="noopener ugc nofollow" target="_blank"> TensorFlow Serving </a>是一个灵活、高性能的机器学习模型服务系统，专为生产环境而设计。TensorFlow服务可以轻松部署新的算法和实验，同时保持相同的服务器架构和API。TensorFlow服务提供了与TensorFlow模型的现成集成，但可以轻松扩展以服务于其他类型的模型。”</p><p id="1435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始使用TensorFlow服务的最简单方法是使用<a class="ae jd" href="http://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。</p><p id="8200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本节中，您需要执行以下操作:</p><ul class=""><li id="813f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="li">安装/验证对接器</em></li><li id="45c2" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="li">下载TFServing容器</em></li><li id="9f45" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="li">为rpm模型运行TF serving</em></li><li id="acb4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="li">测试转速推断终点</em></li></ul><p id="5e0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将需要Docker来测试rpm模型推断端点和您稍后将要构建的web应用程序容器。</p><p id="1a5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令将帮助您验证和/或安装Docker:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="519f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是docker和docker-image version命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ly"><img src="../Images/fa8b9fa00d0d89fb4c5e9493e868d5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5h0eNrlWdTfBPdIzaqTUPQ.png"/></div></div></figure><p id="f05c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li">下载TFServing容器</em>:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="fadc" class="ls jt hi lo b fi lt lu l lv lw"># pull the image and ensure that the image is now available for you to use<br/>docker pull tensorflow/serving<br/>docker image ls tensorflow/serving</span></pre><p id="7adc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li">为rpm模型运行TFServing】</em></p><p id="54ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TFServing期望保存的模型遵循特定的目录结构语义。您将重新构建您先前下载的rpm模型。您还将删除不必要的文件。然后，您将为rpm模型运行TFServer。您的服务器将监听端口8000。您可以根据您的环境需求公开任何端口。如果您已经决定这样做，请调整命令以指向新端口。</p><p id="c8c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是完成我们刚刚描述的任务的命令:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="deb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是docker process命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lx"><img src="../Images/14260240ff7aff40e9ee73eb914ec899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0og4Snqum1VU3Eg1Iqvmw.png"/></div></div></figure><p id="7b62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您将编写一个POST请求，向模型输入。“反弹”和“现场时间”到服务rmp模型的TFServing容器:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="4272" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是POST请求的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lz"><img src="../Images/03b6f073b130520fa10c0a79fd10887c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwoasRYwSJjcSIxO57fueg.png"/></div></div></figure><p id="f11c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的输出显示，客户将在下次访问网站时购买。您将在“will _ buy _ on _ return _ visit _ values”中看到该值。预测基于阈值0.5。并且概率是0.775(77.5%)，其在“will_buy_on_return_visit_probs”字段中。</p><h1 id="4b05" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在开发环境中开发和测试Web应用程序</h1><p id="ebc4" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">出于演示目的，您将开发一个web应用程序来测试ml模型推断端点，该端点已经作为一个容器运行，并且正在侦听端口8000。关于web app与ML模型推理端点的交互，请参考UML序列图。你将使用Java作为后端，HTML/CSS作为前端。您将把web应用程序导出为ecommerce.war文件。电子商务应用程序将在/ecommerce/ web路径上提供。</p><p id="2554" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，您可以跳过web应用程序的开发，使用git repo中提供的ecommerce.war文件。</p><p id="25af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本节中，您需要执行以下操作:</p><ul class=""><li id="da54" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">安装、配置和测试<a class="ae jd" href="https://tomcat.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Tomcat </a></li><li id="6d1f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">开发和测试web应用程序</li><li id="3b48" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">导出war文件(将其命名为ecommerce.war)</li></ul><h1 id="da63" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">安装、配置和测试tomcat</h1><p id="2677" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">如果您没有Apache Tomcat，请在您的开发机器上安装它。您将在端口8080上运行tomcat。您可以根据需要调整端口。</p><p id="fb06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令来安装和测试tomcat:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="17bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上述命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lx"><img src="../Images/a57f1b9c143d5a2ee696a0cb7731a3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yP_3qjKTkxkOSvJ0TR_P4g.png"/></div></div></figure><h1 id="468d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">开发和测试web应用程序</h1><p id="2977" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在，您将使用git repo中的HTML和Java文件来开发一个web应用程序，使用您最喜欢的IDE或开发工具来构建war文件(ecommerce.war)。我们不会给出如何使用IDE/maven等的说明。要开发和构建磨损文件，这超出了当前解决方案的范围。</p><p id="eeac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将使用表单的以下字段:</p><ul class=""><li id="6734" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">ml推理主机url:这是ML推理主机端点。对于开发环境，它将是TFServing端点。</li><li id="945c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">调用ml推理端点:如果“否”,那么后端Java代码跳过ML推理调用。这提供了一种故障排除机制</li><li id="f2e2" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">反弹(输入特征):这是模型的输入。您之前已经通过检查SigngureDef发现了输入参数。</li><li id="1244" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">现场时间(输入要素):这是模型的输入。您之前已经通过检查SigngureDef发现了输入参数。</li><li id="316b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">提交按钮:将表单发送到服务器。</li></ul><p id="5587" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是HTML index.html页面的一个片段:(完整的代码可以在这里<a class="ae jd" href="https://github.com/dpanigra/solutions/blob/main/ml_inference/webapp_dir/eclipse_dir/WebContent/index.html" rel="noopener ugc nofollow" target="_blank">找到</a>。)</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="85ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是index.html页面的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ma"><img src="../Images/ae4b138892ae671308e020aa2b594ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koPb6VwObKliaRzpvZc27Q.png"/></div></div></figure><p id="4599" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一段Java代码:(完整的代码可以在这里<a class="ae jd" href="https://github.com/dpanigra/solutions/blob/main/ml_inference/webapp_dir/eclipse_dir/src/com/mycos/mlinference/MLRefernceServlet.java" rel="noopener ugc nofollow" target="_blank">找到</a>。)</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="bfa5" class="ls jt hi bd ju mb mc md jy me mf mg kc iq mh mi kg iu mj mk kk iy ml mm ko mn bi translated">下面是后端Java代码的输出:</h2><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mo"><img src="../Images/4de611e072ed2e0f7d8548807898394f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6xfT47IV2imM_AM9GDS0Q.png"/></div></div></figure><p id="c509" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，后端Java应用程序对rpm模型进行了推断，并打印了它的输出。详情请参考顺序图。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mp"><img src="../Images/e5c1f1ad0648f60f0cc857ef93dc3d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qim8UQ-ydHegntF04f-Iew.png"/></div></div></figure><p id="1fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于故障排除的目的，您也可以在html表单字段“调用ml推理端点”中提供“否”(不带引号)，从而跳过ml推理post部分。以下是http帖子的回复截图:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mq"><img src="../Images/41d7a4d011dc0b6c959e71e9b0512b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8vydoRdM2sJIhHEMLFIrA.png"/></div></div></figure><p id="f52e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，后端Java应用跳过了rpm模型推理。当您只想测试Java Servlet时，这在故障排除时非常方便。</p><h1 id="bc0b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">导出war文件</h1><p id="4db6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在您完成应用程序的开发和单元测试之后，导出war文件以便我们继续创建应用程序的容器。或者，您可以使用git存储库中的war文件。</p><p id="91ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参考下面的be命令和说明:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="d3ff" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建web应用程序的容器，并在开发环境中测试它。把它推给谷歌<a class="ae jd" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">集装箱登记处</a></h1><p id="1c1a" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在您已经有了一个. war文件，您将创建一个docker映像，使用该映像运行一个容器，测试容器中的代码，并将该映像推送到容器注册表中。</p><p id="4fae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用以下命令创建包含webapp war的容器并运行映像:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="342a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上述命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mo"><img src="../Images/42e0bbd8d9f7b9e317e0c4553e359706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stC01L_xwdCO_JO8boIf_g.png"/></div></div></figure><p id="4d17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到‘catalina . sh’(Tomcat服务器)正在运行，并且正在监听端口8080。</p><p id="e58a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在您已经启动并运行了容器，您将测试应用程序。您可以使用浏览器或curl之类的常用工具进行测试。我们说明了两种方式。</p><p id="af56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用浏览器测试应用程序:</p><ul class=""><li id="0795" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">启动浏览器进入网站<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/google-cloud/{MY_DOCKER_HOST}:8080/ecommerce/">http://{ MY _ DOCKER _ HOST }:8080/ecommerce/</a></li><li id="101c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在“调用ML推理端点”字段中输入“是”。</li><li id="1e01" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">用ml推理端点填充“ML推理主机url:”字段。</li></ul><p id="26b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将在“开发和测试web应用程序”一节中找到web应用程序的屏幕截图。</p><p id="0480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用curl测试应用程序，请使用以下命令:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="285b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是curl命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mr"><img src="../Images/1b688178f87d84041864cd9c284fef87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MimvUKLw9b6ucaNRG9G-RA.png"/></div></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ms"><img src="../Images/3b55e11e89fe10d6a647744eb5509877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgxLdkIGrlDEQ7wDV9r2Rw.png"/></div></div></figure><p id="43b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的输出显示Java Servlet调用了rpm模型推理。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mo"><img src="../Images/a2c672e19ba2fb42e195f63597c87c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wJNKr9BJj-moVs-pcu8Hg.png"/></div></div></figure><p id="f56a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的输出显示Java Servlet跳过了rpm模型推断。</p><p id="16ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您将把图像推送到Google <a class="ae jd" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">容器注册表</a>。</p><p id="4c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令将webapp映像推送到容器注册表。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="73a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是标签和推送命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mt"><img src="../Images/de38eb46dbb99e42ef209fe1f87eb734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9vE9ScnzoGyTvMUjPfyFA.png"/></div></div></figure><p id="d21e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果是第一次执行该命令，docker push的输出会有所不同。</p><h1 id="2c93" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在开发环境中开发和测试Spark应用程序</h1><p id="ea03" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">出于演示目的，您将开发一个spark应用程序来测试rpm模型推断点，该推断点已经作为一个容器运行，并且正在侦听端口8000。请参考UML序列图，了解scala应用程序与ML推理端点的交互。您将在应用程序中使用Scala。您将把应用程序导出为一个jar文件。您将要使用的工具将把这个jar文件命名为ml inference _ 2.12–1.0 . jar。</p><p id="348c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以跳过scala应用程序的开发，使用git repo中提供的jar文件。</p><p id="00b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本节中，您需要执行以下操作:</p><ul class=""><li id="f660" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">安装并检查Scala的完整性</li><li id="00a3" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">安装和健康检查<a class="ae jd" href="https://www.scala-sbt.org/" rel="noopener ugc nofollow" target="_blank"> sbt </a></li><li id="6c0a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">安装和健全检查火花</li><li id="8fd1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">开发和测试Spark应用程序</li></ul><p id="2574" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的命令安装并检查Scala安装的完整性:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="4ca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Scala编译和运行命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mu"><img src="../Images/3bfbdbd808d19bb33622fe2bce80ccd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Mo-mKimnro5OY0qDiUv6A.png"/></div></div></figure><p id="c6a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令安装并检查sbt安装的完整性:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="1d9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是sbt编译和运行命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mv"><img src="../Images/eff21d905727666fef2ed4817b067cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFx2bHkpizPMMOrwz_DV-Q.png"/></div></div></figure><p id="e18f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您将准备一个spark工作目录，下载额外的jar，创建一个适当的配置文件，复制Google Cloud service account json文件并测试spark-shell。您将让Spark使用Google云存储，而不是本地HDFS来存储应用程序jar文件和输入文件，即您之前创建的csv文件。</p><p id="91b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令，为后续步骤准备Spark:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="12f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令启动spark-shell，快速检查spark安装:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="8460" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是对Spark安装进行快速健全检查的命令及其输出的屏幕截图:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mw"><img src="../Images/2a8d534817e8f1aaf3b4a3cbf15da09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vt1h83omm0HvALJ_Uy8EpA.png"/></div></div></figure><p id="044b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令启动spark-shell来测试spark安装的REPL Scala程序:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="22b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Spark安装的REPL Scala程序的命令及其输出的屏幕截图:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mx"><img src="../Images/ac99f1b7301e4da46047aa4b5ef3b533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SG1UEmRIBs9T1xcCYlyxlA.png"/></div></div></figure><p id="ae62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用以下命令将HelloWorld程序打包到一个jar文件中:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="1465" class="ls jt hi lo b fi lt lu l lv lw"># package the code to a jar and spark-submit to the local master<br/>cd $HOME/sbttest_sanity<br/>sbt package</span></pre><p id="6a4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令，通过spark-submit运行Hello World程序:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="6800" class="ls jt hi lo b fi lt lu l lv lw">cd $HOME/Downloads/spark_dir/spark-3.0.1-bin-hadoop2.7/bin<br/>./spark-submit \<br/>  --class com.mycos.test.HelloWorld \<br/>  --master local[1] \<br/>$HOME/sbttest_sanity/target/scala-2.12/sbttest_sanity_2.12-0.1.0-SNAPSHOT.jar</span></pre><p id="b77d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是spark-submit命令的屏幕截图，通过提交HelloWorld spark作业来测试Spark:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mq"><img src="../Images/1de86622305c15247370e8caa1826fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNWrqazf21Hgn4GC8-oJTw.png"/></div></div></figure><p id="d62a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在您将开发一个scala程序，它将读取包含您之前创建的样本数据的输入文件，并为每个输入记录调用ml推断点。您可以优化程序，在Spark中对数据进行分区，并以批处理模式而不是在线模式提交分区后的数据进行预测。然而，这超出了当前解决方案的范围。</p><p id="09fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">scala程序需要以下参数:</p><ul class=""><li id="7f31" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">ml推理主机url:这是ML推理主机端点。对于开发环境，它将是TFServing端点。</li><li id="7002" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">调用ml推理端点:如果“否”,那么后端Java代码跳过ML推理调用。这提供了一种故障排除机制</li><li id="a423" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">输入文件路径:这是Google云存储中样本数据的完整路径</li></ul><p id="05c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了上述论点之外，星火外壳还期待某些变量。我们稍后将解释它们。</p><p id="40cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将执行以下操作:</p><ul class=""><li id="b4b5" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">开发、编译和打包spark应用程序jar文件</li><li id="8687" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">将jar文件上传到Google云存储桶</li><li id="340c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">将rpm-hdfs-input.csv文件上传到存储桶</li><li id="c4ee" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">测试spark-提交正确的参数</li></ul><p id="2d63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以跳过开发jar文件，使用git repo中可用的文件。</p><p id="a6ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照下面的说明开发、编译和打包scala应用程序:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="6e09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Scala程序的一个片段:(完整的代码可以在<a class="ae jd" href="https://github.com/dpanigra/solutions/blob/main/ml_inference/sparkapp_dir/src/main/scala/RPMMLInference.scala" rel="noopener ugc nofollow" target="_blank">这里</a>找到。)</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="4d7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是sbt文件的一个片段:(完整的代码可以在这里<a class="ae jd" href="https://github.com/dpanigra/solutions/blob/main/ml_inference/sparkapp_dir/read_rpm.sbt" rel="noopener ugc nofollow" target="_blank">找到</a>。)</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ee93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照下面的说明将带有样本数据的输入文件和jar文件上传到Google云存储:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="1ff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照下面的说明在开发环境中测试spark-job:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9b7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">scala作业从Google云存储中读取输入csv，遍历每一行，打印它，并(可选地，取决于“是”或“否”参数)调用ml模型推理端点。</p><p id="9bfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是spark-submit作业的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es my"><img src="../Images/7d90f25cb4d1e0946a1f479243d03f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqIsDAmieDc0PqfXy4qtwA.png"/></div></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mz"><img src="../Images/d71639b6f234fcf6f7b6560219591379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgtSiwNsx2HJRJdKmO3EqQ.png"/></div></div></figure><p id="de6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上输出显示了以下输入rpm数据:</p><ul class=""><li id="372f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">rpm-hdfs-input.csv中的整个数据集</li><li id="af41" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">上述数据集中的每一行</li><li id="ba04" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">“跳过ML推理调用”消息(因为您在参数中传递了“否”)</li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es na"><img src="../Images/22f49df05100a7f232b62f53d0fb4874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTM8s4EN-5oE8BoyvV6g_g.png"/></div></div></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es nb"><img src="../Images/65a8f9349f05ce1a6256e2d8783c1a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAF98pFb76HubSEN_JFNBA.png"/></div></div></figure><p id="7e59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上输出显示了以下输入rpm数据:</p><ul class=""><li id="8aaa" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">rpm-hdfs-input.csv中的整个数据集</li><li id="bb9a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">上述数据集中的每一行</li><li id="16c0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">来自rpm模型推理的预测(因为您在参数中传递了“是”)</li></ul><h1 id="ba5f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">构建Spark图像并将它们推送到谷歌<a class="ae jd" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">容器注册处</a></h1><p id="43b7" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在本节中，您将创建两个spark图像。您将创建一个Spark基本映像和一个Spark映像，它扩展了基本映像，使用Google Cloud Storage Connector和附加的jar文件。您可以用额外的jar创建单个映像，但这可能会给故障排除带来挑战。因此，为了更好地进行单元测试，您将保留两幅图像。</p><p id="2bcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令将创建两个图像，并将它们推送到Google容器注册表:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="8ef0" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">提供Google Kubernetes引擎(GKE)集群</h1><p id="2ee8" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您已经开发并测试了web应用程序和spark应用程序。现在您将在GKE部署它来执行集成测试。</p><p id="08d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将执行以下操作:</p><ul class=""><li id="d947" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">调配GKE集群和特定于工作负载的节点池</li><li id="3c00" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">授予适当的权限</li><li id="e0ae" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">部署web应用程序</li><li id="0661" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">使用注册表中的Spark映像部署和测试Spark作业</li><li id="ebbf" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">部署KFServing并测试样本TensorFlow flowers模型</li><li id="78f7" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">部署rpm模型</li></ul><h1 id="07ad" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">调配GKE集群和节点池</h1><p id="d324" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在，您将为不同的Kubernetes工作负载类型创建一个GKE集群和多个节点池。您可以在命令中更改每个节点池的机器类型，以满足您的需要。您将在“webapp-pool”节点池中部署web应用程序，并在“kfserving-pool”节点池中部署rpm模型。spark作业被部署到默认节点池。</p><p id="216a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在git存储库中找到完整的命令。对于KFServing，您需要<a class="ae jd" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank"> Knative </a>(基于Kubernetes的平台，用于部署和管理现代无服务器工作负载)。由于<a class="ae jd" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">云运行</a>是由谷歌提供的开箱即用的完全管理的无服务器平台，你将使用它作为Knative组件..为了测试部署到KFServing的测试模型的准备情况，您需要一个外部端点，即作为云运行安装的一部分提供给您的istio-ingress。</p><p id="d8d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是执行此操作的命令:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="c7d7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">授予适当的许可</h1><p id="7be2" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您将配置<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">工作负载标识</a>。这是从在GKE运行的应用程序访问Google云服务的推荐方式，因为它提高了安全性和可管理性。Spark作业需要访问存放输入文件和应用程序jar文件的Google存储帐户。</p><p id="1a01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令来设置工作负荷标识:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="070d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">固定和污染节点</h1><p id="ae24" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在，您将固定并污染webapp和kfserving节点，以便应用程序使用您之前在配置GKE时已经创建的所需机器类型。</p><p id="5a5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续下一步之前，您将创建一个名称空间并授予适当的权限。</p><p id="0bb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将运行下面的命令来固定和污染节点:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="d88b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建一个名称空间并测试Spark图像</h1><p id="c0a5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在继续下一步之前，您将创建一个名称空间并授予适当的权限。您还将设置工作负荷标识。</p><p id="5aaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是执行此操作的命令:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="3f2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的开发目的，您已经使用了“集群管理员”角色，但是对于生产，我们建议您遵循最低权限的<a class="ae jd" href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" rel="noopener ugc nofollow" target="_blank">原则。</a></p><p id="bd09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然您已经创建了名称空间，授予了适当的访问权限，并将Spark图像推送到Google容器寄存器，那么您将使用现成的“Pi”示例对它们进行单元测试。</p><p id="b46d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令测试两个图像，但不包括“Pi”示例:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="58a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是spark image create命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mq"><img src="../Images/76d4c768d5bd6667c19f688b94753607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kglq1WRH4VfDIzMs1HTBxw.png"/></div></div></figure><p id="f023" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是容器日志的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mp"><img src="../Images/d83934fb30c08d590b740d67c9d8f3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmsAUhQxu9GiibtW3Jn21Q.png"/></div></div></figure><p id="cbb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的输出显示“Pi大约是3.139155695778479。”对于spark-submit，您将得到类似的输出，一个带有“spark:v3.0.1 ”,另一个带有“spark_gcs:v3.0.1”图像。</p><h1 id="c96d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在GKE部署web应用程序</h1><p id="3171" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您将创建一个名称空间，在集群中部署web应用程序，并公开端口8080。您将使用端口8080从开发环境中的web浏览器访问web应用程序。</p><p id="b32c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将在git存储库中找到webapp.yaml文件。您将需要它来部署它。</p><p id="d8bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是您将用于部署web应用程序的命令:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="f63e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在GKE部署KFServing并测试样本TensorFlow flowers模型</h1><p id="cd0c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在您将部署cert manager，这是KFServing <a class="ae jd" href="https://github.com/kubeflow/kfserving" rel="noopener ugc nofollow" target="_blank"> git资源库中解释的先决条件。</a></p><p id="80f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令部署证书管理器:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="3746" class="ls jt hi lo b fi lt lu l lv lw">cp $GIT_CLONE_HOME_DIR/gke_deploy_dir/cert-manager.yaml .<br/># deploy cert-manager<br/>kubectl apply --validate=false -f $HOME/gke_deployment/cert-manager.yaml</span></pre><p id="4e4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上述命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es nc"><img src="../Images/a1b9940f7d8ec66221a1027e49b19bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwziDrgnNt89upBbbUbkrA.png"/></div></div></figure><p id="8092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将部署v1beta1版本的KFServing。您将使用kfserving.yaml文件的修改版本，可以在集群的git repo中获得。请参考yaml文件，了解在repo中对该文件所做的精确更改。您将为KFServing部署创建一个名称空间，然后部署yaml文件。您将配置工作负载标识。您还将部署KFServing git存储库中可用的<a class="ae jd" href="https://github.com/kubeflow/kfserving/tree/master/docs/samples/tensorflow" rel="noopener ugc nofollow" target="_blank"> TensorFlow flowers </a>示例。在此部署之后，您将能够对部署进行健全性检查。</p><p id="fb9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令来部署示例:</p><p id="63c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的命令和指令就是这样做的:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="14b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是kubectl apply命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lz"><img src="../Images/22a3f63ffe2e4d917ec1d589827d7767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6cbwQpu5niPVG_w6Wk9_g.png"/></div></div></figure><p id="ba68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GKE集群中部署KFServing后，您可以通过运行以下命令对部署进行完整性检查，从KFServing <a class="ae jd" href="https://github.com/kubeflow/kfserving" rel="noopener ugc nofollow" target="_blank"> git存储库</a>中可用的<a class="ae jd" href="https://github.com/kubeflow/kfserving/tree/master/docs/samples/tensorflow" rel="noopener ugc nofollow" target="_blank"> TensorFlow flowers </a>示例进行推断:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="5053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是两个curl命令及其输出的屏幕截图:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lz"><img src="../Images/b1d078427e8e4edfbd73466ce3af9ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SHCzA7Ds6QSKLhMEqgxIQ.png"/></div></div></figure><p id="04c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个curl的输出将“state”显示为“AVAILABLE ”,这意味着模型已经准备好为请求提供服务。第二个命令的输出显示了KFServing返回的“预测”。</p><h1 id="eb9b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在GKE部署rpm模型并测试模型推理</h1><p id="eacc" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您将把之前下载的rpm模型部署到集群中。您将使用。git存储库中可用的yaml文件。您还将测试rpm模型是否准备好接受流量。下面的命令可以做到这一点:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="84af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是上面curl命令的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ma"><img src="../Images/da6082d54ab46144e9acac7d8590147f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlcnzRGbYAJ805b1oM8kCQ.png"/></div></div></figure><h1 id="9299" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在GKE测试Spark应用程序和Web应用程序</h1><p id="5d4f" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您将测试web应用程序，并向GKE提交一个spark作业。您将测试web应用程序和Spark应用程序的端到端集成。它包括从两个应用程序调用ML模型推理。</p><p id="5cde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将从测试Scala应用程序开始，将它提交给GKE的Spark。要进行测试，您需要执行以下操作:</p><ul class=""><li id="877e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">准备一个包含Spark二进制文件的目录，包括spark-submit</li><li id="4bb5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">设置证书、令牌和密码以连接到GKE群集</li><li id="f7fa" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">最后，spark-提交Spark作业</li></ul><p id="c14f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下命令执行上述任务:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="0d97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在“开发和测试Spark应用程序”一节中找到Spark应用程序的输出截图。</p><p id="2e3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用浏览器测试web应用程序:</p><ul class=""><li id="3886" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">启动浏览器进入网站http:// <external_ip> :8080/ecommerce/</external_ip></li><li id="a233" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在“调用ML推理端点”字段中输入“是”。</li><li id="5ed4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">用ml推理端点填充“ML推理主机url:”字段。您已经在以下变量$MLINFER_ENDPOINT_INTERNAL中收集了本地docker主机。</li></ul><p id="5614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是为您提供外部ip的命令:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="2110" class="ls jt hi lo b fi lt lu l lv lw"># gather the external ip<br/>export EXTERNAL_IP=`kubectl get svc -n $WEBAPP_NAMESPACE -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}'`<br/>echo $EXTERNAL_IP</span></pre><p id="c531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将在“开发和测试web应用程序”一节中找到web应用程序的屏幕截图。</p><h1 id="ff6d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在谷歌云日志中监控GKE的应用日志</h1><p id="8458" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">您将在Google Cloud Logging中监控您的所有应用程序日志。您需要找到执行您的作业的容器。</p><p id="a6aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过发出以下命令，您将找到上次运行的容器:</p><pre class="kw kx ky kz fd ln lo lp lq aw lr bi"><span id="284e" class="ls jt hi lo b fi lt lu l lv lw">kubectl logs -f `kubectl get pods -n $SPARK_NAMESPACE \<br/>  --sort-by=.metadata.creationTimestamp | grep driver \<br/>  | tail -1 | awk -F ' ' '{print $1}'` -n $SPARK_NAMESPACE</span></pre><p id="eddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进入谷歌云控制台→ Kubernetes引擎→工作负载→ <spot the="" container="" that="" ran="" job=""> →日志→容器日志</spot></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/5177f24a5092b1c6b2fdc6886947576f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sUJx4QKL0PnqSjH9"/></div></div></figure><h1 id="2048" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">后续步骤</h1><ul class=""><li id="2013" class="je jf hi ih b ii kq im kr iq nd iu ne iy nf jc jj jk jl jm bi translated">注意安全:</li></ul><p id="1931" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li"> —您已经将HTTP endpoint用于web应用程序和spark应用程序。设置和使用SSL。</em></p><p id="4e4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li"> —勾选“</em> <a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/how-to/hardening-your-cluster" rel="noopener ugc nofollow" target="_blank"> <em class="li">加固您集群的安全</em> </a> <em class="li">”。</em></p><p id="a510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li"> —查看</em> <a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/security-overview" rel="noopener ugc nofollow" target="_blank"> <em class="li">安全概述</em> </a> <em class="li">。</em></p><ul class=""><li id="c7c7" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">在Web客户端调用ML推理端点:</li></ul><p id="3a28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用公共入口ip在您的DNS中注册knative提供的服务的主机url。主机值在变量MLINFER_ENDPOINT_EXTERNAL中。公共IP在变量INGRESS_HOST中。</p><ul class=""><li id="54de" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">使用数据分区和批量预测:</li></ul><p id="1eee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您已经遍历了输入数据，并且为每个输入数据行调用了ml推断端点。您已经使用在线预测进行最大似然推断。您可以为Spark作业划分数据。然后，您可以进行批量预测以获得更好的性能。</p><ul class=""><li id="1d08" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">将预测结果写入永久存储器:</li></ul><p id="df67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您已经在spark应用程序的控制台上打印了预测结果。你可以把结果写入永久存储器。</p><ul class=""><li id="f23d" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">部署不同版本的模型并进行A/B测试，以了解新模型的功效:</li></ul><p id="564d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您只部署了rpm模型的一个版本。您可以部署rpm模型的多个版本。您可以通过进行A/B测试来在实际生产中测试它们，以找出哪个模型版本工作得更好。</p><ul class=""><li id="b1b2" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">使用火花算子:</li></ul><p id="7641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于演示目的，您已经使用了Spark的缩小版本。你可能已经在为一个完整的Spark集群运行<a class="ae jd" href="https://github.com/GoogleCloudPlatform/spark-on-k8s-operator" rel="noopener ugc nofollow" target="_blank"> Spark operator </a>。如果没有，那么您可以考虑Spark操作符</p><ul class=""><li id="50cc" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">使用<a class="ae jd" href="https://skaffold.dev/" rel="noopener ugc nofollow" target="_blank"> skaffold </a>:</li></ul><p id="7c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您已经在本地环境中使用docker测试了web应用程序、spark应用程序和rpm模型服务。您可以在GKE直接使用Skaffold测试您的应用程序。“Skaffold处理构建、推动和部署应用程序的工作流程，让您专注于最重要的事情:编写代码。”</p><ul class=""><li id="65b3" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">将文章的资源调配和ci/cd部分合并到您现有的DevOps基础架构中。使用声明性YAML，而不是命令性的kubectl命令</li></ul><p id="0825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您已经执行了shell和gcloud命令来配置GKE基础设施和构建Docker映像。您已经使用kubectl操作来修改集群，例如“kubectl expose deployment”。您可以创建部署和服务YAML，然后使用<a class="ae jd" href="https://github.com/kubernetes-sigs/kustomize/" rel="noopener ugc nofollow" target="_blank"> kustomize </a>通过一个命令非常容易地部署它。我们建议您将这些步骤自动化，并将Infra编写为代码，并将它们合并到您现有的管道基础设施中。</p><ul class=""><li id="b6c0" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">使用gRPC代替HTTP端点:</li></ul><p id="ada2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您已经在解决方案中使用了HTTP，但是为了获得更好的性能，我们建议您使用gRPC。请查看<a class="ae jd" href="https://github.com/kubeflow/kfserving/blob/master/ROADMAP.md" rel="noopener ugc nofollow" target="_blank"> KFServing路线图</a>了解对该功能的支持。</p><h1 id="3ad8" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">摘要</h1><p id="e1cb" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">恭喜你！！！您已经到达了解决方案的末尾。您已经学习了如何通过web应用程序和spark应用程序在KFServing中运行ML模型推理，其中应用程序和KFServing都运行GKE环境。我们希望您喜欢这个全面的解决方案，并希望您可以在您的项目中使用这些知识和代码片段。</p><h1 id="289e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">想要更多吗？</h1><p id="c860" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">请给我留下您的意见和任何建议或更正。</p><p id="a8de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于我:我在谷歌云工作。我帮助我们的客户在谷歌云上构建解决方案。<a class="ae jd" href="https://www.linkedin.com/in/damodarp/" rel="noopener ugc nofollow" target="_blank">这里的</a>是我的linkedin个人资料。</p><h1 id="311c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">感激</h1><p id="28c5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">特别感谢<a class="ae jd" href="https://www.linkedin.com/in/praveen-rajagopalan/" rel="noopener ugc nofollow" target="_blank"> Praveen Rajagopalan </a>共同编写了解决方案的GKE和KFServing部分以及各自的部署和测试命令。感谢我的同事<a class="ae jd" href="https://www.linkedin.com/in/rajeshthallam" rel="noopener ugc nofollow" target="_blank">Rajesh thal am</a>和<a class="ae jd" href="https://www.linkedin.com/in/ameer00/" rel="noopener ugc nofollow" target="_blank"> Ameer Abbas </a>审阅了解决方案。</p></div></div>    
</body>
</html>