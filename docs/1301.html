<html>
<head>
<title>An app modernization story — Part 4 (Serverless Microservices)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用程序现代化故事—第4部分(无服务器微服务)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/an-app-modernization-story-part-4-serverless-microservices-f9acdb0d8370?source=collection_archive---------1-----------------------#2020-02-24">https://medium.com/google-cloud/an-app-modernization-story-part-4-serverless-microservices-f9acdb0d8370?source=collection_archive---------1-----------------------#2020-02-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1c36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在博客系列的第3部分中，我谈到了我们如何转变我们的纯Windows。NET框架app到容器化的多平台。NET Core app。</p><p id="b19e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这消除了我们对Windows的依赖，使我们能够部署到基于Linux的平台，如App Engine (Flex)。另一方面，该应用程序仍然在虚拟机上运行，即使没有人使用它，它也是按秒计费的，部署很慢，最重要的是，它是作为单个单元部署和扩展的单个整体。</p><p id="eff3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在现代化的最后阶段，我想谈谈我们如何将我们的monolith转变为一套具有云运行的无服务器微服务，以及这种转变的好处。</p><h1 id="f5c3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">无服务器云运行</h1><p id="5edf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在2019年初将我们的应用容器化后，我们希望在一个托管/无服务器平台上运行它，主要是为了避免虚拟机定价。然而，<a class="ae jd" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云函数</a>并不支持C#/。NET作为运行时(现在仍然不是)，这束缚了我们的手脚，直到2019年年中。</p><p id="a73d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2019年年中，<a class="ae jd" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> Cloud Run </a>在三藩市的Google Cloud Next大会上宣布，作为一个全新的完全托管的平台来运行无状态容器。我们的应用程序已经是无状态的(所有的状态都在内存中)，并且已经容器化了，所以Cloud Run立即改变了我们的游戏规则。</p><p id="ff40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将我们的代码快速更新到ASP.NET核心3.0之后，我们能够用一个<em class="kh"> gcloud </em>命令将我们的容器部署到云运行。我们在一夜之间用云运行取代了应用引擎:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/af022b63aa3090699cf4884ac26fe55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pEZoYPjGtTTdtg-jG7VXg.png"/></div></div></figure><p id="2a0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能看起来不是一个大的变化，但它有直接的好处:</p><ol class=""><li id="af20" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hj">定价</strong>:我们从基于虚拟机的定价转变为云运行定价，您只需为请求时间付费。对于像我们这样的小型且偶尔连接的应用程序，账单基本上几乎是免费的(Cloud Run有一个免费层)。</li><li id="7252" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">部署时间</strong>:我们的部署时间从App Engine上的5–10分钟减少到了云运行上的3–5秒。这使我们能够更快地迭代。</li><li id="d36c" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">DevEx</strong>:Cloud Run上的开发者体验棒极了！我们在云运行控制面板中很好地显示了指标和日志。我们有一些功能，比如在云上运行的应用引擎的修改和流量分流。</li><li id="ed34" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">基于开源</strong>:知道Cloud Run是基于<a class="ae jd" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank"> Knative </a>，一个开源项目也很好。如果我们想要离开受管理的谷歌云环境，我们可以在Kubernetes运行的任何地方轻松部署相同的应用程序并获得类似的功能。</li></ol><p id="8fda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些几乎不费吹灰之力就赢得了胜利。</p><h1 id="8e99" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">整体问题</h1><p id="c738" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">尽管取得了快速的胜利，但云运行也放大了我们的应用程序的整体性质所导致的问题。我们的应用由三个服务组成:捆绑部署在一起的<strong class="ih hj">阅读器</strong>、<strong class="ih hj">转换器</strong>和<strong class="ih hj"> web前端</strong>。这导致了如下问题:</p><ol class=""><li id="1f1c" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hj">缩放</strong>:我们通常需要1个阅读器和1个转换器，偶尔会缩放web前端。当我们扩展时，我们扩展了所有3个服务，这是不必要的。</li><li id="033c" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">冷启动</strong> : Cloud Run在不使用的时候自动缩小你的容器。这可以节省资金，但在我们的情况下，这是一个问题，因为即使是阅读器也会被缩小。当容器从零开始向上扩展时，阅读器需要一些时间来获取提要并填充内存状态。</li><li id="0512" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">内存状态</strong>:我们所有的状态都在内存中。冷启动后这并不理想。在这个阶段，我们需要更持久的存储。</li><li id="b1dc" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">无法更新单个服务</strong>:我们不得不频繁更新transformer，因为RSS提要格式经常变化，而我们不需要那么频繁地更新reader或web frontend。没有办法挑选要更新的内容。</li></ol><p id="54f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些问题都清楚地表明，我们最终必须将我们的整体分解成独立的服务。</p><h1 id="99ee" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">整块分解</h1><p id="b002" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">理论上，整体分解听起来是个好主意。在现实中，要做到恰当是相当困难的。你需要回答很多问题:</p><ol class=""><li id="2119" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hj">如何打破独石？</strong>理想情况下，你有足够独特的功能来使独特的服务显而易见，但这并不总是一目了然的。即使它是清晰的，你也可能需要做大量的重构来实现它。</li><li id="0a4d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">微服务如何沟通？一旦你用服务间的网络调用替换了monolith内部的函数调用，你需要考虑服务是如何通信的。应该是同步还是异步调用？应该是HTTP还是某种发布/订阅消息？不管怎样，这都比函数调用难。你需要确定这是你想要付出的代价。</strong></li><li id="7359" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><strong class="ih hj">如何在没有耦合的情况下处理持久性？出于多种原因，您希望您的服务尽可能无状态，但是在某些时候，您需要在某个地方保存一些数据。一个容易犯的错误是让多个服务依赖于同一个持久层。这将不是在代码中而是在持久性中耦合微服务，这违背了分解的初衷。</strong></li></ol><p id="4c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有许多其他的考虑，但你得到的想法。整体分解并不像你想象的那么简单。</p><h1 id="adf7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">最终建筑</h1><p id="21c8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最后，这就是我们最终得到的架构:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es li"><img src="../Images/83eb7f08fdcfbe17c7a058286f656699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4YLe9k9T637eT1BI6r2wg.png"/></div></div></figure><p id="901a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这3个独立的服务:阅读器，转换器，网络前端:</p><ul class=""><li id="8b8b" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc lj la lb lc bi translated"><strong class="ih hj"> Reader </strong>是一个内部云运行服务，由云调度程序按照设定的时间表调用。它从一个源列表中获取RSS提要，并将它们作为json存储在云存储中。</li><li id="a100" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc lj la lb lc bi translated"><strong class="ih hj">转换器</strong>是另一个内部云运行服务。一旦Reader将RSS json保存在云存储中，这将触发一条消息到一个Pub/Sub主题，反过来，Pub/Sub调用Converter服务。然后，Converter使用预定义的规则将不同的RSS提要转换为一种通用格式，并保存到Cloud Firestore，这是一个NoSQL数据库，非常适合JSON之类的数据。</li><li id="2324" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc lj la lb lc bi translated"><strong class="ih hj"> Web </strong>是一个公有云运行服务，它只是为保存在Cloud Firestore中的feed数据公开了一个Web API。</li></ul><p id="b344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想仔细看看代码，它已经在GitHub上了:<a class="ae jd" href="https://github.com/meteatamel/amathus" rel="noopener ugc nofollow" target="_blank">https://github.com/meteatamel/amathus</a></p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="83b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的架构几乎解决了我之前概述的所有问题。有三个专注的服务，每次做好一件事。每项服务都可以独立推理、更新和扩展。更新已经不可怕了。这只是对其中一项服务的更新，云运行的修订功能使恢复到以前的代码非常容易。通过Pub/Sub和Firestore的服务之间存在松散的依赖关系。冷启动没有问题，因为Web前端有Firestore支持，启动非常快。</p><p id="1a66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，体系结构比以前复杂得多。有几个移动部分，整体设置不像没有外部依赖的单一云运行服务那样简单。然而，这是我们愿意付出的代价，以使架构更具弹性，更易于更新。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="7654" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就结束了我们的应用程序现代化之旅的4部分博客系列。希望您喜欢阅读我们的旅程，如果您有任何反馈或问题，请随时通过Twitter @ <a class="ae jd" href="https://twitter.com/meteatamel" rel="noopener ugc nofollow" target="_blank"> meteatamel </a>联系我</p></div></div>    
</body>
</html>