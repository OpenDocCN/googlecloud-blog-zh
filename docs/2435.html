<html>
<head>
<title>Deploy machine learning models to the edge server with Cloud Deploy and Cloud Workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过云部署和云工作流将机器学习模型部署到边缘服务器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploy-machine-learning-models-to-the-edge-server-with-cloud-deploy-and-cloud-workflows-cfc1540ef6fc?source=collection_archive---------3-----------------------#2022-10-18">https://medium.com/google-cloud/deploy-machine-learning-models-to-the-edge-server-with-cloud-deploy-and-cloud-workflows-cfc1540ef6fc?source=collection_archive---------3-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="8816" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">背景</h1><p id="e40a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我正在测试我的机器学习模型，这些模型由外部系统导出为容器图像。一旦完成模型训练，它将创建一个配置了服务框架的容器映像，并将映像推送到Google Cloud Artifact Registry。</p><p id="c8a2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了测试模型，我需要:</p><ol class=""><li id="b6ae" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">用最新的图像标记更新我的Kubernetes部署yaml文件。</li><li id="0fbf" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">连接到我的Kubernetes集群。</li><li id="9e22" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">kubectl应用yaml文件。</li></ol><p id="493e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是一个创建工作流来自动运行它的完美用例。</p><h1 id="52ed" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">要求</h1><ul class=""><li id="df97" class="kg kh hi jf b jg jh jk jl jo ku js kv jw kw ka kx km kn ko bi translated">当一个新的容器映像被推送到Artifact Registry时，它会自动触发一个工作流来将容器部署到目标Anthos集群(测试和登台)。</li><li id="aa44" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">该解决方案必须能够处理多个容器映像和服务映射。也就是说，如果我将modelA和modelB推送到注册表中，我希望它们作为ServiceA和ServiceB自动部署到Anthos集群中。</li><li id="641c" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">部署到下一个环境需要我的批准。</li></ul><h1 id="97be" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决方案—云发布/订阅和云构建</h1><p id="77bb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当一个新的容器映像被推送到注册中心时，容器注册中心和工件注册中心都发送<a class="ae ky" href="https://cloud.google.com/container-registry/docs/configuring-notifications" rel="noopener ugc nofollow" target="_blank">通知</a>。下图说明了第一种解决方案架构。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/5e75ad5c1e642f8d3909bb8c3c6ea159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RX9l39Bj9akovNzE"/></div></div></figure><ul class=""><li id="e1ef" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated">当一个新的容器映像被推送到注册表时，它会触发一个通知事件。并且该事件被路由到云发布/订阅主题</li><li id="9bb7" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">由事件触发的云构建管道。它</li><li id="dd39" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">从源代码库中提取Kubernetes清单模板文件。</li><li id="fc3d" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">更新模板文件。</li><li id="771f" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">部署到目标环境。</li></ul><h1 id="f9d3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">挑战</h1><p id="a670" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这种架构面临的主要挑战是</p><ul class=""><li id="8512" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated">它不支持批准。因此，一旦工作流完成，每个版本都将被部署到目标环境中。</li><li id="867d" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">它需要云构建触发器，这就需要Git或云源代码库。在我的例子中，我不需要Git存储库。此外，如果我想遵守资源位置限制，云源存储库只提供一个预览“区域实例”。</li></ul><h1 id="db67" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决方案—云部署和云工作流</h1><p id="193d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">第二种架构如下图所示。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ll"><img src="../Images/384bae3b41bd55adde02a1a8909dd8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uW4u-xp51TG66V-0WDJRgQ.png"/></div></div></figure><p id="9c82" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这个架构中。当一个新的容器映像被推送到注册表时，它</p><ul class=""><li id="0c90" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated">激发通知事件。Eventarc Trigger接收事件并触发云工作流工作流。</li><li id="d374" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">该工作流调用Cloud Deploy API来启动Skaffold清单文件的交付管道</li><li id="9e65" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">Cloud Deploy交付管道呈现Kubernets清单文件，并创建一个发布。</li></ul><p id="3750" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了让端到端的流工作，我</p><ul class=""><li id="7e2e" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated">使用目标环境配置创建Skaffold配置</li><li id="75f5" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">创建交付管道配置</li><li id="06e3" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">将此模型容器的Kubernets清单模板文件上传到云存储桶</li><li id="f310" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">创建一个云工作流工作流，它调用云部署API来启动上面创建的交付管道。在API调用中，我配置了skaffoldConfigUri和skaffoldConfigPath，以便交付管道知道将Skaffold配置拉到哪里。</li><li id="4563" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated">创建一个Eventarc触发器，它监听特定的工件注册容器映像并触发上面创建的云工作流。</li></ul><h1 id="a09a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建云部署交付渠道</h1><ul class=""><li id="e71f" class="kg kh hi jf b jg jh jk jl jo ku js kv jw kw ka kx km kn ko bi translated"><strong class="jf hj">创建一个Skaffold yaml文件</strong></li></ul><p id="7f89" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Skaffold用于呈现不同环境的清单，在我的例子中，我在每个环境中使用相同的模型，所以这个模型很简单。这是我的萨克福德。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lm ln l"/></div></figure><ul class=""><li id="b7fa" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated"><strong class="jf hj">创建交货管道定义文件。</strong></li></ul><p id="1b9b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是您定义管道外观的地方。在我的例子中，我有两个环境，暂存和生产。两者都是Anthos连接的集群。</p><p id="45e7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我还创建了一个服务帐户<code class="du lo lp lq lr b">deploy-service@${GOOGLE_CLOUD_PROJECT}.iam.gserviceaccount.com</code>，并授予它所需的角色。哪些是</p><ul class=""><li id="6548" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated"><strong class="jf hj">roles/event arc . event receiver</strong></li><li id="a165" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated"><strong class="jf hj">角色/工作流.调用者</strong></li><li id="774a" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kx km kn ko bi translated"><strong class="jf hj">角色/事件arc.serviceAgent </strong></li></ul><p id="31ce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面是交付管道的定义。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lm ln l"/></div></figure><ul class=""><li id="5461" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated"><strong class="jf hj">创建一个Kubernetes清单文件</strong></li></ul><p id="315b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这些是kubernetes yaml文件，将由Skaffold呈现，并最终应用于目标集群。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lm ln l"/></div></figure><ul class=""><li id="e52b" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated"><strong class="jf hj">更新模板文件</strong></li></ul><p id="32d5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">每个交付管道都绑定到特定的环境配置。所以我写了一个简单的脚本，当我有一个新版本时更新环境变量。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lm ln l"/></div></figure><ul class=""><li id="87d5" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kx km kn ko bi translated"><strong class="jf hj">创建输送管道</strong></li></ul><pre class="la lb lc ld fd ls lr lt lu aw lv bi"><span id="00ba" class="lw ig hi lr b fi lx ly l lz ma">gcloud deploy apply --file pipeline.yaml --region="${GOOGLE_CLOUD_DEFAULT_REGION}" --project="${GOOGLE_CLOUD_PROJECT}"</span></pre><h1 id="64f4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建云工作流</h1><p id="9a36" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">云工作流是一个HTTP API orchestractor，它还提供了一个HTTP API接口，以便客户端应用程序通过API调用启动工作流。</p><p id="60c0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我的例子中，Cloud Workflows工作流除了调用Cloud Deploy API之外什么也不做。我需要这个，因为Cloud Deploy本身通过<a class="ae ky" href="https://cloud.google.com/deploy/docs/architecture" rel="noopener ugc nofollow" target="_blank"> API调用</a>与外部应用程序或CI解决方案集成。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="eb2a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意，这里我们配置了<code class="du lo lp lq lr b">buildArtifacts</code>来告诉ska ffold<code class="du lo lp lq lr b">inference-model</code>需要用值<code class="du lo lp lq lr b">${image_location}</code>来渲染，这是我们在工作流的<code class="du lo lp lq lr b">decode_message</code>步骤中创建并计算的变量。</p><p id="5b52" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后部署工作流。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">部署云工作流工作流</figcaption></figure><h1 id="e797" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">上传Skaffold配置文件</h1><p id="69b9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了让Cloud deploy能够呈现结果，我们需要告诉它我们的资产在哪里，在我们的工作流中，我们已经配置了<code class="du lo lp lq lr b">skaffoldConfigUri</code>和<code class="du lo lp lq lr b">skaffoldConfigPath </code>。因此，这里我们将资产上传到预先创建的云存储空间。</p><pre class="la lb lc ld fd ls lr lt lu aw lv bi"><span id="4b24" class="lw ig hi lr b fi lx ly l lz ma">tar -czvf skaffold.tar.gz skaffold.yaml viai-model*</span><span id="83a5" class="lw ig hi lr b fi mf ly l lz ma">gsutil cp /skaffold.tar.gz gs://${GOOGLE_CLOUD_PROJECT}_cloudbuild/${PROD_CLUSTER}/”</span></pre><h1 id="59be" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">启用审计日志</h1><p id="aefd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了让Eventarc触发工件注册工作，我们需要启用审计日志。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mg"><img src="../Images/e7a792cfa905505eb91e9647d7de37db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lO8UJ_6OGMSyZzRu"/></div></div></figure><h1 id="556b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建Eventarc触发器</h1><p id="4221" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当新的容器图像被推送到工件注册表时，Eventarc接收该事件并触发事件目标工作流。如果我们有多个容器图像，我们需要一个过滤器来指定哪个容器图像是感兴趣的图像。并且只在到达工件注册处时触发下游工作流。</p><p id="068a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Eventarc有一个“<a class="ae ky" href="https://cloud.google.com/eventarc/docs/path-patterns" rel="noopener ugc nofollow" target="_blank">路径模式</a>，允许您在Eventarc触发器上设置资源过滤器。在我的例子中，我想要监听推到工件注册中心的特定容器图像。假设图像URL是<code class="du lo lp lq lr b">https://us-east1/my-project/my-repository/my-image:tag</code>，路径模式是<code class="du lo lp lq lr b">resourceName=/projects/my-preoject/locations/east-us1/repositories/my-registry/dockerImages/my-Image*</code></p><p id="4c59" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">创建一个Eventarc触发器，在推送容器映像时触发云工作流。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h1 id="8aed" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">测试工作流程</h1><p id="90a0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们有了Evnetarc触发器，它只在所需的容器映像被推送到集群时触发。我有一个触发云部署交付渠道的工作流。</p><p id="ea8b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要测试端到端的场景，只需将新的映像推送到工件注册中心。请注意，必须推送图像以精确匹配您在Eventarc触发路径模式过滤器中指定的URL。</p></div></div>    
</body>
</html>