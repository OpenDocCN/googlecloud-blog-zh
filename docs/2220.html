<html>
<head>
<title>Authentication between microservices: Is it really that hard?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务之间的认证:真的有那么难吗？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/authentication-between-microservices-is-it-really-that-hard-b73785510db4?source=collection_archive---------0-----------------------#2022-06-15">https://medium.com/google-cloud/authentication-between-microservices-is-it-really-that-hard-b73785510db4?source=collection_archive---------0-----------------------#2022-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="86b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微服务架构完全是关于相互调用的服务。但是，如何保证安全，确保只有您自己的服务可以调用您的每个服务呢？你如何认证？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/49bfdbce54565a0d2b1b3e80c927a807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDkL5PrMddq5m8607Hek-Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">信用:伊兰尼特·科彭斯<a class="ae jt" href="https://stocksnap.io/author/ylanitekoppens" rel="noopener ugc nofollow" target="_blank">https://stocksnap.io/author/ylanitekoppens</a></figcaption></figure><p id="2f66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您知道如何使用浏览器应用程序实现这一点:用户输入凭证，浏览器将这些凭证发送给服务，服务发送回一个会话令牌，在一段时间内对用户进行身份验证。但是对于微服务，没有人在循环中输入密码或多因素认证密钥。</p><p id="0d55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我将描述如何做到这一点，重点是运行在Google云平台服务上的服务器，如Cloud Run或Google Kubernetes Engine (GKE)。客户服务可以在GCP、内部或AWS上提供。</p><p id="494e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">促使我写这篇文章的原因是，API网关和云端点是快速发展的技术，具有强大的身份验证功能，但与彼此以及其他竞争服务相比也有局限性。微服务之间实现认证的方式有很多种。我将从最简单但最不安全和最不可维护的开始，逐步升级到推荐的架构。</p><p id="e867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让事情更清楚，我将把重点放在您控制双方的微服务上，但是同样的原则也适用于客户服务在您的组织外部的情况。</p><h1 id="1f64" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">基础知识:头、键和代理</h1><p id="1f2d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">尽管有更简单和更复杂的方法，但是服务间身份验证需要非常仔细的设计。基本轮廓是这样的。</p><ul class=""><li id="318d" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">客户端使用秘密密钥对令牌进行签名</li><li id="0c12" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">传递它的标准格式是<a class="ae jt" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web Token </a></li><li id="fbb5" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">令牌放在HTTP授权头中，如下所示</li></ul><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="589a" class="lq jv hi lm b fi lr ls l lt lu">Authorization: Bearer &lt;JWT&gt;</span></pre><p id="3973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<jwt>是base64编码的令牌。</jwt></p><ul class=""><li id="9bab" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">服务器通过查询服务来验证该令牌。或者，反向代理可以接收请求，并在将请求传递给实际的服务器之前，通过查询服务来验证令牌。</li><li id="eb23" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">在GCP，该服务由平台提供。</li></ul><p id="2953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文将展示实现这一点的多种方法，从简单和不安全开始，直到更完整的解决方案。</p><h1 id="5b96" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">太简单了:自我管理的“API密钥”</h1><p id="0094" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">不了解全套技术的人经常使用的一个基本解决方案类似于人类用户使用用户名和密码登录时所做的事情:将一个秘密字符串，即“API密钥”存储到客户端服务中，作为凭证，然后在服务器端验证它。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="d2b1" class="lq jv hi lm b fi lr ls l lt lu">APIKEY=Microservice1:78eb9a45897f</span></pre><h1 id="dc78" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">限制</h1><p id="f232" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这不安全。</p><p id="c52b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">漏键</strong></p><p id="141b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">钥匙泄漏的方式比你能想象的要多。为了防止这种情况，您不应该将秘密存储在Git或其他源代码控件中——这很容易被意外打开；相反，使用类似谷歌云秘密管理器或Hashicorp Vault的秘密管理器服务。尽管如此，这留下了同样的问题:客户端服务需要存储凭证来访问秘密管理器。</p><p id="5d23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">密钥管理</strong></p><p id="c178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要开发一个服务器端数据库来存储这些密钥，并开发一个层来验证接收到的密钥是否正确。您也不希望密钥从这一层泄漏，所以客户端不应该传递API密钥，而应该传递一个哈希，服务器会根据存储的密钥哈希来检查这个哈希。维持这一切是昂贵的。这也是不安全的，因为你不能投入专业知识和努力去弥补所有可能的漏洞。安全系统应该尽可能留给专家。</p><p id="a4f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">旋转</strong></p><p id="d2f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为泄漏是不可避免的，所以最佳实践是频繁地轮换密钥:创建一个新的密钥，并在一定时间后使旧的密钥失效。这需要在客户端自动建立一个请求新密钥的机制(用旧密钥验证这个请求！).在服务器端，您需要一种机制来按需生成新密钥，并在以后的某个特定日期使旧密钥失效。</p><p id="d672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且这类事情总是比您一开始所想的更复杂:例如，您可能希望在任何时候强制一个键的最大数量的有效版本，因为拥有两个有效版本是轮换的必要部分，但是100个版本是迟早会发生的泄漏。</p><h1 id="efb4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">云提供商服务帐户密钥</h1><p id="8479" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">为什么要自己实现散列、验证、轮换和过期机制呢？一个更好的方法是创建一个服务帐户，然后从Google Cloud Identity and Access Management(IAM)下载一个密钥文件。您可以从<a class="ae jt" href="https://console.cloud.google.com/iam-admin/serviceaccounts" rel="noopener ugc nofollow" target="_blank">服务账户页面</a>创建密钥。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lv"><img src="../Images/ab99da461890277832753ef349492560.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/0*0g-SQ8q89gPDOGi3"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lw"><img src="../Images/45bac360a44bd3249d90a10d5e3c4c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/0*_kHDS1YMP6MQoMn5"/></div></figure><p id="72cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下载JSON，并确保设置到期日期— <a class="ae jt" href="https://cloud.google.com/iam/docs/service-accounts#key-expiry" rel="noopener ugc nofollow" target="_blank">这是谷歌云的一项新功能。</a>JSON是这样的。(别担心，我已经彻底修改了文本😁，再加上我已经把钥匙禁用了！)</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="53b1" class="lq jv hi lm b fi lr ls l lt lu">{<br/>"type": "service_account",<br/>"project_id": "myproject",<br/>"private_key_id": "ded9d97108b…..5cfd179e95e0e1",<br/>"private_key": " — — -BEGIN PRIVATE KEY — — -\nMIIEvKIBADABNBg….QDA6woGjE4Q — — -END PRIVATE KEY — — -\n",<br/>"client_email": "exampleserviceaccount@myproject.iam.gserviceaccount.com",<br/>"client_id": "106482...4210366919",<br/>"auth_uri": "https://accounts.google.com/o/oauth2/auth",<br/>"token_uri": "https://oauth2.googleapis.com/token",<br/>"auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",<br/>"client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/kubeflowpipeline%40joshua-playground.iam.gserviceaccount.com" <br/>}</span></pre><h1 id="5b27" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">限制</h1><p id="d1ad" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">听起来不错，对吧？但是(正如你已经猜到的)，这也不像我们希望的那样安全和方便。</p><p id="cf85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像自制的API密钥一样，服务帐户密钥文件可能会泄漏，因此您需要轮换它。Google帮助您确保密钥会过期，并提供API来调用以获得新的密钥，但是您仍然必须使用这些功能。</p><p id="e5b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后，我们将解释如何通过将服务帐户嵌入到您的客户端应用程序中来避免密钥文件。但是首先，让我们解释一下如何使用服务帐户，是通过密钥文件还是内置的种类。</p><h1 id="5c0e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">应用程序代码中的身份验证</h1><p id="e722" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">为了进行身份验证，客户端服务使用其服务帐户。</p><p id="a40d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过OpenID Connect (OIDC) 来实现这一点<a class="ae jt" href="https://cloud.google.com/endpoints/docs/openapi/service-account-authentication" rel="noopener ugc nofollow" target="_blank">，它传递经过签名的JSON Web令牌(JWT)。这些令牌</a><a class="ae jt" href="https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials" rel="noopener ugc nofollow" target="_blank">只在很短的时间</a>内有效——几个小时，而不是几周——将泄露的风险降至最低。</p><p id="44fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以通过客户端和服务器端的软件库，在你自己的代码层次上做到这一点。</p><ul class=""><li id="3ea2" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">首先，客户端创建并且<a class="ae jt" href="https://developers.google.com/identity/protocols/oauth2/service-account" rel="noopener ugc nofollow" target="_blank">使用软件库</a>和服务账户密钥来签署访问请求JWT令牌。</li><li id="bba6" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">然后，它使用该令牌向Google认证服务器请求一个不同的令牌，即访问令牌。Google认证服务器检查服务帐户是否确实签署了访问请求JWT，然后发送回证明这一事实的访问令牌。</li><li id="aa7c" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">客户端使用这个访问令牌来调用您的微服务。</li><li id="7361" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">您的微服务使用一个软件库来检查访问令牌是否确实经过了Google服务的验证和签名。</li></ul><p id="744e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://developers.google.com/identity/protocols/oauth2#serviceaccount" rel="noopener ugc nofollow" target="_blank">类似于这个流程</a>，除了被调用的服务是你自己的微服务，而不是谷歌API。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/51ea813612c1bd0b6c774ec2a21e19fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TytoVzE4VuVEnwGM"/></div></div></figure><h1 id="f1f0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">限制</h1><p id="76ba" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj">与您的服务器耦合</strong></p><p id="bca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个解决方案涉及到服务器内部的代码。既然你可能有多个需求相同的微服务，那就意味着在多个代码库中维护和保证这个认证层的安全性。</p><p id="bb84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后，我们将展示如何避免将这些代码插入到您的应用程序中。但是首先，让我们看看如何完全停止使用密钥文件。</p><h1 id="5145" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">固定服务帐户:GCP</h1><p id="9331" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果您在GCP部署客户端服务，请不要使用服务帐户密钥。相反，使用内置的给定服务帐户启动服务。</p><p id="5738" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，对于Google计算引擎(GCE)实例，您可以使用</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="38e5" class="lq jv hi lm b fi lr ls l lt lu">gcloud compute instances create [INSTANCE_NAME] --service-account [SERVICE_ACCOUNT_EMAIL]...</span></pre><p id="cbaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指定服务帐户；类似地，对于云运行和其他GCP服务，您的客户端微服务可能会调用其他微服务。</p><p id="4a05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在不用担心泄露关键文件，因为根本没有。相反，<a class="ae jt" href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity" rel="noopener ugc nofollow" target="_blank">元数据服务器</a>生成一个签名的实例令牌来验证服务帐户身份。(并且对元数据服务器的请求从不离开VM正在运行的物理实例。)</p><h1 id="b190" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在Kubernetes</h1><p id="4644" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Kubernetes有自己的服务帐户系统，参与特定于Kubernetes的认证系统。这与GCP IAM层是分开的，因此如果您的客户端服务在Google Kubernetes引擎上，使用<a class="ae jt" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">工作负载身份</a>将GCP IAM服务帐户分配到您的Kubernetes层。Workload Identity透明地拦截和代理从GKE到GCP API的所有调用，并用访问令牌丰富它们。</p><p id="aa37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的客户使用AWS的Elastic Kubernetes服务，您还可以分配一个IAM角色来参与GCP流，如下一节所述。</p><h1 id="13d3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">固定角色:AWS和工作负载身份联盟</h1><p id="19df" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果客户端服务在AWS中，您不能使用GCP服务帐户来启动它，但是可以使用AWS的变体角色来启动它。您用执行角色的<a class="ae jt" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html" rel="noopener ugc nofollow" target="_blank">启动Lambda，或者用角色</a><a class="ae jt" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html" rel="noopener ugc nofollow" target="_blank">启动EC2实例(包装在“实例概要文件”</a>)。)</p><p id="c7df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GCP不能直接信任那个角色，所以你使用<a class="ae jt" href="https://cloud.google.com/iam/docs/workload-identity-federation" rel="noopener ugc nofollow" target="_blank">工作量身份联邦</a> (WIF)来桥接AWS和GCP ( <a class="ae jt" rel="noopener" href="/google-cloud/keyless-api-authentication-launching-gcp-workloads-from-aws-b715b4e6c99a">文章</a>)。</p><p id="df86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，流程如下:</p><ul class=""><li id="7128" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">首先，AWS上的客户机服务使用它的角色来签署一个令牌(令牌1)。</li><li id="a238" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">它使用令牌1请求另一个由AWS IAM签名的令牌(令牌2)。</li><li id="da30" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">它使用令牌2要求GCP·WIF签署一个访问令牌(令牌3)。Google WIF已经被预先配置为信任给定的AWS角色，现在AWS已经证明该请求来自该角色，WIF签署并发回访问令牌(令牌3)。</li><li id="455d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">客户端服务现在使用令牌3，就像基于GCP的客户端服务使用访问令牌一样；流动从这里以同样的方式继续。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/40f96152b5642b2dab297258bfc2abeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uMCIpHboWOAWhgEa"/></div></div></figure><p id="cfe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这看起来很复杂，但是它可以让你避免在互联网上发送那些秘密的和容易泄露的字符串——在这种情况下，发送到另一个云。</p><h1 id="bb1e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">从Google到AWS工作负载的认证</h1><p id="317a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这篇文章主要是关于运行在谷歌上的服务，但是<a class="ae jt" href="http://github.com/doitintl/gtoken" rel="noopener ugc nofollow" target="_blank"> gtoken </a>在这里值得一提。这与工作负载身份联合正好相反:它通过为调用提供一个临时AWS身份来验证GKE工作负载对AWS APIs的查询。</p><h1 id="1298" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">身份验证代理:API网关</h1><p id="da25" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">尽管如此，如前所述，我们受到这样一个事实的限制，即您自己的应用程序代码正在执行最后一步，即验证签名确实来自Google授权的委托人。最好尽可能使用由安全专家创建的经过验证的产品化系统。</p><p id="673e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，看看<a class="ae jt" href="https://cloud.google.com/api-gateway" rel="noopener ugc nofollow" target="_blank"> API网关</a>中一个健壮的、可配置的<a class="ae jt" href="https://cloud.google.com/api-gateway/docs/authenticate-service-account" rel="noopener ugc nofollow" target="_blank">服务到服务认证</a>层，你不必维护它。</p><p id="81ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个代理。它公开了一个公共地址，位于客户端和云运行、云功能和应用引擎上的无服务器服务之间。它处理接收令牌和调用Google服务来验证请求的工作，然后将请求传递到您的无服务器后端。为了保护从API网关到后端的链接，Google插入了一个它控制的特殊头，任何攻击者都无法添加。</p><h1 id="80a0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">限制</h1><p id="a95e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">然而，API Gateway不能与GKE一起工作，因为它与Google管理的无服务器服务所公开的接口紧密集成。</p><h1 id="7d36" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">身份验证代理:云端点</h1><p id="0207" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">那么，如何对GKE进行身份验证，同时保护从身份验证层到后端服务的链接呢？为此，您可以将可扩展服务代理与Google Cloud端点一起使用:API Gateway基于并扩展了一个有点老的服务。</p><p id="6939" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ESP(现在是v2)是一个公开公共地址和验证请求的容器。要将其用于GKE，<a class="ae jt" href="https://cloud.google.com/endpoints/docs/openapi/get-started-kubernetes-engine-espv2" rel="noopener ugc nofollow" target="_blank">将其作为pod </a>部署到您的集群中。(顺便说一下，虽然文档中说只支持较新的VPC本地/IP别名集群，但它也适用于较早的基于路由的集群。)</p><p id="943e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ESPv2和集群中的Kubernetes服务之间的链接也需要得到保护。您可以通过不公开除ESP之外的任何公共地址在集群网络层实现这一点，或者您可以使用更复杂的解决方案，如mutual TLS或<a class="ae jt" href="https://istio.io/latest/docs/concepts/security/" rel="noopener ugc nofollow" target="_blank"> Istio Security </a>。</p><p id="d5a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获得更高的安全性，请将ESPv2部署为sidecar，以便代理和您的应用程序(Kubernetes部署)一起位于pod的安全“localhost”空间中。(虽然这不是ESPv2的主要部署模式，但它在官方Google Cloud GitHub帐户上共享的这个YAML配方中得到支持<a class="ae jt" href="https://github.com/GoogleCloudPlatform/endpoints-samples/blob/master/gke/echo.yaml" rel="noopener ugc nofollow" target="_blank">。)</a></p><h1 id="7756" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论:保护您的微服务！</h1><p id="87df" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">你不能让任何人调用你的API。过去，这可以通过网络边界或云中的VPC来解决。但是现代架构支持跨云帐户、云提供商之间以及与非云系统的集成。即使在VPC中，您也希望另一层安全措施正好针对特定的客户端到服务器的链接:每个端点都必须信任另一个端点。</p><p id="848c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要做到这一点，挑战在于:</p><ul class=""><li id="c097" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">进行身份验证，而不会将敏感文件放在容易泄露的地方。</li><li id="206d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">将身份验证委托给受信任的服务；不要将身份验证与应用层代码结合起来。</li></ul><p id="ebfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我描述了一些实现这一点的方法，逐渐增加了安全性和可维护性，但也需要更多的技术知识。学习这些是非常值得的投资——比成为黑客的受害者要便宜得多！</p><blockquote class="ly lz ma"><p id="6d53" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">我是<a class="ae jt" href="https://doit-intl.com" rel="noopener ugc nofollow" target="_blank"> DoiT International </a>的高级云架构师，在那里我为科技公司提供咨询。我们有一种非常不同寻常的工作文化。在这里阅读我的文章<a class="ae jt" href="https://www.doit-intl.com/why-i-work-at-doit-as-a-cloud-infrastructure-consultant/" rel="noopener ugc nofollow" target="_blank"/>。来和我一起工作吧！请在<a class="ae jt" href="mailto:joshua@doit-intl.com" rel="noopener ugc nofollow" target="_blank">joshua@doit-intl.com</a>给我写信或者直接申请<a class="ae jt" href="https://grnh.se/55e74b343us" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote></div></div>    
</body>
</html>