<html>
<head>
<title>Data Mesh Self Service — Ingestion Pattern from Spanner to BigQuery (Data Store for Mesh)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据网格自助服务—从Spanner到BigQuery的摄取模式(网格的数据存储)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/mesh-self-service-data-ingestion-template-for-moving-data-from-spanner-to-bigquery-data-store-94186c0f13e5?source=collection_archive---------4-----------------------#2022-12-14">https://medium.com/google-cloud/mesh-self-service-data-ingestion-template-for-moving-data-from-spanner-to-bigquery-data-store-94186c0f13e5?source=collection_archive---------4-----------------------#2022-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated"><span class="l je jf jg bm jh ji jj jk jl di">创建和管理数据源的</span>集中一切的方法通常被认为是将其集成到业务分析堆栈中的瓶颈。随着未来技术的进步，跨生态系统摄取、存储、处理和访问更多数据变得更加容易，而无需花费大量成本。</p><p id="17f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种技术进步需要辅之以管理数据的组织方法的相应变化。</p><p id="a826" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据网格是一种高级体系结构，它解决了一切都集中的方法的缺点，从组织的角度来看，这种方法不容易扩展和补充。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/1aef1cbef0ab5bba11290bcfe2cec50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8cENT6yPcq-6z-W6"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">约翰·施诺布里希在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="46f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据网格原理</strong></p><ol class=""><li id="7912" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">分散的面向领域的所有权</li><li id="450d" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">数据作为一种产品</li><li id="7e11" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">自助式数据平台</li><li id="cb03" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">联合治理</li></ol><p id="5e3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本系列的前一部分“使用模板在数据网格中构建数据产品”中，我们讨论了使用模板作为在网格中构建和发布数据产品的自助服务的一个方面。</p><p id="004f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">网格的数据存储</strong></p><p id="12bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序的事务存储可以是任何存储系统，如SQL数据库、NoSQL数据库、文件存储或对象存储。为了将这些数据用于任何分析目的，必须将这些数据接收到适合运行分析工作负载的存储中，例如数据仓库或数据湖。</p><p id="ae20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网状架构中的数据产品构建在适合分析工作负载的数据存储之上。在Google云平台上构建网格时，我们通常使用BigQuery作为网格的数据存储。</p><p id="cbd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本系列的这一部分中，我们将讨论一个这样的场景，并讨论Spanner to BigQuery数据摄取模式以及这种模式的自助服务模板，不同的域可以使用该模板在BigQuery中构建数据产品。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="8661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">摄取模式—扳手转大查询</strong></p><p id="79ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Spanner到BigQuery的数据接收可以通过以下三种方式之一执行:</p><ol class=""><li id="eb5a" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated"><strong class="ih hj">批量模式</strong> — <em class="ky">定期从Spanner到BigQuery之间的数据批量加载</em></li><li id="7565" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated"><strong class="ih hj">流式模式</strong> — <em class="ky">将扳手的变化数据近实时流式传输到big query</em></li><li id="1076" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated"><strong class="ih hj">并联模式</strong> — <em class="ky">批量负载和流式CDC负载的组合</em></li></ol><p id="02f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们探讨一下上述选项的优缺点，并确定将Spanner转化为BigQuery摄取模式的最佳方法。</p><p id="8df8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">批处理模式——从Spanner向BigQuery批量加载数据</strong></p><p id="4ba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将数据从Spanner数据库中的表加载到BigQuery数据集的一种非常简单但效率不高的方法是在一次加载操作中执行数据的完整拷贝批量传输。</p><p id="70fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过对BigQuery使用<a class="ae kc" href="https://cloud.google.com/bigquery/docs/cloud-spanner-federated-queries" rel="noopener ugc nofollow" target="_blank">云扳手联邦查询</a>来实现。它的实施需要两个步骤:</p><ol class=""><li id="714c" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">查询Spanner information_schema视图以读取表模式并在BigQuery中创建一个表。</li><li id="1673" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">使用联邦查询读取扳手表数据，并将其插入BigQuery表中</li></ol><p id="ee2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ky">以下示例返回关于表</em> <code class="du kz la lb lc b"><em class="ky">MyTable</em></code> <em class="ky"> : </em>中的列的信息</p><pre class="jn jo jp jq fd ld lc le bn lf lg bi"><span id="6876" class="lh li hi lc b be lj lk l ll lm">SELECT *<br/>FROM EXTERNAL_QUERY(<br/>  'my-project.us.example-db',<br/>  '''SELECT t.column_name, t.spanner_type, t.is_nullable<br/>    FROM information_schema.columns AS t<br/>    WHERE<br/>      t.table_catalog = ''<br/>      AND t.table_schema = ''<br/>     AND t.table_name = 'MyTable'<br/>    ORDER BY t.ordinal_position<br/>  ''');</span></pre><p id="b6e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ky">下面的示例对名为</em> <code class="du kz la lb lc b"><em class="ky">orders</em></code> <em class="ky">的扳手数据库进行联合查询，并将结果与名为</em> <code class="du kz la lb lc b"><em class="ky">mydataset.customers</em></code> <em class="ky">的BigQuery表连接。</em></p><pre class="jn jo jp jq fd ld lc le bn lf lg bi"><span id="4a87" class="lh li hi lc b be lj lk l ll lm">SELECT c.customer_id, c.name, rq.first_order_date<br/>FROM mydataset.customers AS c<br/>LEFT OUTER JOIN EXTERNAL_QUERY(<br/>  'my-project.us.example-db',<br/>  '''SELECT customer_id, MIN(order_date) AS first_order_date<br/>  FROM orders<br/>  GROUP BY customer_id''') AS rq <br/>  ON rq.customer_id = c.customer_id<br/>GROUP BY c.customer_id, c.name, rq.first_order_date;</span></pre><p id="9b37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法需要通过IaC模板部署以下资源之一:</p><ul class=""><li id="b646" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">具有脚本的云功能，利用BigQuery和外部连接API以及SQL查询进行数据加载</li><li id="425f" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">云与容器化的web应用一起运行，在内部利用BigQuery和外部连接API以及SQL查询进行数据加载</li><li id="c48c" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">用于编排BigQuery和外部连接API以及数据加载任务的Cloud Composer或云工作流</li></ul><p id="0a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的IaC模板将根据从上述选项中选择的服务而变化。</p><p id="2183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="7313" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">每次加载全部数据实现起来非常简单。</li><li id="bc41" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">这种方法对于增量数据标识不依赖于特定的时间戳字段。</li></ul><p id="4cd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="1db2" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">对于Cloud Spanner中的大型表，每次加载完整的数据可能会很慢并且成本很高。</li><li id="ed66" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">在满负荷运行期间，需要暂停对Spanner的写操作；否则，满载期间的写入可能会丢失。</li></ul><p id="febe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">流模式—流扳手CDC到Bigquery </strong></p><p id="d993" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将云Spanner数据提取到BigQuery的另一种方法是从CRUD操作中捕获更改数据，即Spanner数据库中表的插入、更新和删除，并将它们传输到BigQuery表。</p><p id="195a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自扳手的更改数据可以通过使用扳手更改流来捕获。更改流近乎实时地观察和流出云扳手数据库的数据更改—插入、更新和删除。关于扳手更换流程的更多信息可在<a class="ae kc" href="https://cloud.google.com/spanner/docs/change-streams" rel="noopener ugc nofollow" target="_blank">此处</a>探究，以及设置和配置程序。</p><p id="961c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦配置了变更流，数据变更记录就会被变更流捕获。这些数据更改记录可以传输到BigQuery，以便在Spanner和BigQuery表之间加载和同步数据。这可以通过使用数据流与谷歌提供的模板'<a class="ae kc" href="https://cloud.google.com/dataflow/docs/guides/templates/provided-streaming#cloud-spanner-change-streams-to-bigquery" rel="noopener ugc nofollow" target="_blank">云扳手改变流大查询</a>'来实现。</p><p id="e228" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cloud Spanner change streams to BigQuery模板是一个流管道，它将Cloud Spanner数据更改记录进行流式处理，并使用数据流运行器V2将它们写入big query表中。</p><p id="0850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法需要通过IaC模板部署以下所有资源:</p><ul class=""><li id="12bd" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">云扳手实例和数据库，表和扳手通过指定<a class="ae kc" href="https://cloud.google.com/spanner/docs/change-streams/manage#create" rel="noopener ugc nofollow" target="_blank"> DDL查询</a>改变流。</li><li id="c710" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">使用google提供的模板'<a class="ae kc" href="https://cloud.google.com/dataflow/docs/guides/templates/provided-streaming#cloud-spanner-change-streams-to-bigquery" rel="noopener ugc nofollow" target="_blank"> Cloud Spanner将数据流更改为BigQuery </a>'的云数据流作业。</li><li id="451a" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">BigQuery数据集将用作数据流传输作业传输的数据更改记录的目标。这些表将由数据流作业自动创建(在模板中实现)。</li></ul><p id="649a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="fdfa" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">这不需要任何查询联合和外部连接。</li><li id="4f33" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">来自spanner的数据更改记录以近乎实时的方式传输到BigQuery。</li><li id="bc50" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">这种方法与spanner中记录的数量和表的大小无关，并且易于扩展。</li></ul><p id="f97b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="0ecc" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">这将仅捕获从启用扳手更改流的时间点开始的更改。历史数据无法传输到Bigquery。</li></ul><p id="b0bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并行模式—批量加载和流式CDC加载的组合</p><p id="de5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到上述两种方法的优点和缺点，我们可以通过组合这两种方法来消除每个单独方法的缺点，即，组合批处理全加载和流式CDC加载来从Spanner获取数据并加载到BigQuery。这将包括使用联邦查询从Spanner到BigQuery的一次性完整数据加载的并行化。</p><p id="fe62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决缺点:</p><ul class=""><li id="a2a9" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">由于这是一次性负载，而不是重复的全负载，因此它只会产生一次时间和成本，即第一个全负载周期。</li><li id="af59" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">启用与历史加载并行的更改流，历史加载期间的后续写入也将被并行捕获，从而解决了在全加载期间丢失数据记录的问题。</li></ul><p id="8106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于这种方法的IaC模板将包括两个同时发生的子管道，批量满载和流式CDC装载。这实质上是第一种和第二种方法的IaC与一个公共主配置文件的组合。</p><p id="25e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署和执行的顺序如下:</p><ol class=""><li id="749a" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">启用扳手更换流。</li><li id="4178" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">为满负荷部署批处理管道。</li><li id="9f23" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">为CDC负载部署流式管道。一旦配置了数据流作业，CDC加载将会自动启动。</li><li id="1e28" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">启动历史加载的批处理管道(以确保捕获更改并与满负荷并行加载)。</li></ol><p id="0af7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="9880" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated">在BigQuery中只提取新变化并与现有数据合并的有效方法</li><li id="866f" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated">易于复制高吞吐量的大型表(每秒写入大量插入或更新)，复制延迟低到中等；从长远来看接近实时。</li></ul><p id="b612" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">摘要<br/> </strong>在本系列的前一部分中，<a class="ae kc" rel="noopener" href="/google-cloud/build-data-product-in-data-mesh-using-templates-e1bf5a38bf86">使用模板在数据网格中构建数据产品</a>，我们讨论了使用模板作为在网格中构建和发布数据产品的自助服务的一个方面。</p><p id="9428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一部分中，我们讨论了Spanner to BigQuery模式对摄取管道模板的一个这样的需求、不同的数据加载方法以及一些脚本和IaC模板片段，它们可以用作构建mesh摄取功能的基础。</p><p id="16d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本系列博客的后续部分中，我们将讨论更多的摄取管道，例如将数据从云SQL移动到BigQuery，将云存储中的文本文件移动到BigQuery，将Pub/Sub移动到BigQuery和/或将Apache Kafka移动到Bigquery。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="4cff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><ul class=""><li id="0e0d" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ln kj kk kl bi translated"><a class="ae kc" href="https://cloud.google.com/bigquery/docs/cloud-spanner-federated-queries" rel="noopener ugc nofollow" target="_blank">使用联邦查询从BigQuery查询云扳手中的数据</a></li><li id="2a5a" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated"><a class="ae kc" href="https://cloud.google.com/spanner/docs/change-streams" rel="noopener ugc nofollow" target="_blank">扳手更改流—将数据更改流传送到其他应用程序</a></li><li id="5773" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ln kj kk kl bi translated"><a class="ae kc" href="https://cloud.google.com/docs/terraform/best-practices-for-terraform" rel="noopener ugc nofollow" target="_blank">使用Terraform创建IaC模板的指南和建议</a></li></ul></div></div>    
</body>
</html>