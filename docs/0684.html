<html>
<head>
<title>Setting up Google Cloud with Kubernetes, Nginx Ingress and Let’s Encrypt (Certmanager)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes、Nginx Ingress和Let's Encrypt设置Google Cloud(cert manager)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/setting-up-google-cloud-with-kubernetes-nginx-ingress-and-lets-encrypt-certmanager-bf134b7e406e?source=collection_archive---------0-----------------------#2018-07-10">https://medium.com/google-cloud/setting-up-google-cloud-with-kubernetes-nginx-ingress-and-lets-encrypt-certmanager-bf134b7e406e?source=collection_archive---------0-----------------------#2018-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c31c9be4d76cbda4f84f7e9f0bd704fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZKN6SsMTy_gpVY-MFSu_g.jpeg"/></div></div></figure><p id="ad20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将尝试分享我在kubernetes中设置集群的步骤。请注意，我对Google Cloud &amp; Kubernetes的了解仅限于一周的研究，所以我愿意接受改进它的建议。</p><p id="84b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是针对那些刚刚开始探索谷歌云/ Kubernetes的人，并试图巩固一周的(有时令人困惑的)研究</p><p id="0962" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">假想知识</strong>(一周内可习得！；))</p><ul class=""><li id="595c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">kubernetes工作原理的基本概念(pod、部署、服务)</li><li id="5b4b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">谷歌云的基本概念</li></ul><p id="39c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最后会部署什么:</strong></p><ul class=""><li id="0c23" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">单节点kubernetes集群，不支持扩展。</li><li id="f6fc" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">包含应用程序的docker图像(Nginx/Angular2)</li><li id="9634" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">包含api的docker映像(带有mongodb的连接细节)(NodeJS)</li><li id="42e6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">一个docker图像与nginx反向代理谷歌存储</li><li id="ef63" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Nginx入口路由到docker后端</li><li id="68a0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">由加密验证的证书，由入口使用</li></ul><p id="c214" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">未包含:</strong></p><ul class=""><li id="6d95" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">实际的docker图像，这个指南更多的是作为如何设置这个“架构”的指南。</li></ul><h2 id="1a6e" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">设置GCloud CLI(如果可用，请跳过)</h2><p id="5758" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">有关如何设置Google Cloud CLI，请参见附录。从这一点出发，假设您有一个工作的gcloud，登录并指向您的项目/计算区域</p><h1 id="b83b" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">创建集群</h1><p id="22bc" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated"><code class="du lt lu lv lw b">gcloud container clusters create &lt;cluster_name&gt; --num-nodes=1</code></p><p id="e245" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一步将为您创建一个具有一个节点(一台计算引擎机器)的集群，所有的pods服务都将在该集群上运行。</p><p id="82d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lt lu lv lw b">gcloud container clusters get-credentials &lt;cluster_name&gt;</code></p><p id="2d03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个命令配置<strong class="is hj"> kubectl </strong>，它是与kubernetes交互的cli工具，针对我们刚刚创建的集群工作</p><h1 id="d45d" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">创建名称空间(可选)</h1><p id="c925" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">出于我们的目的，名称空间旨在将环境相互分离。例如，我们将在同一个集群/节点上运行测试/QA环境。这将使pod和服务相互隔离。</p><p id="4acd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lt lu lv lw b">kubectl create namespace &lt;name&gt;</code></p><p id="81e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个集群在刚创建时通常有两个名称空间，<strong class="is hj">默认</strong>和<strong class="is hj"> kube-system </strong>，如果不在命令中指定名称空间，您的资源将会在<strong class="is hj">默认</strong>名称空间中结束。<strong class="is hj"> kube-system </strong>是为kubernetes服务保留的。</p><h1 id="02ed" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">设置舵，安装舵杆</h1><p id="90cf" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">Helm可以被描述为kubernetes的一个包管理器，您将使用这个工具安装nginx-ingress和certmanager。它作为客户机/服务器架构运行，helm是您使用的cli工具，tiller是服务器(我们稍后将在集群上安装)。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="5048" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>create serviceaccount --namespace kube-system tiller<br/><em class="mj">kubectl </em>create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller</span><span id="5ccc" class="kc kd hi lw b fi mk mg l mh mi"><em class="mj">helm </em>init --service-account tiller</span><span id="755a" class="kc kd hi lw b fi mk mg l mh mi"><em class="mj">kubectl </em>patch deploy --namespace kube-system tiller-deploy -p '{"spec":{"template":{"spec":{"serviceAccount":"tiller"}}}}'</span><span id="2771" class="kc kd hi lw b fi mk mg l mh mi"><em class="mj">helm </em>init --service-account tiller --upgrade</span></pre><p id="892d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们不确定是否需要补丁。但是它将在kube-system名称空间中创建一个服务帐户，创建必要的rolebindings，并用这个帐户初始化helm。</p><p id="d810" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关这些步骤的更多详细信息，请参考<a class="ae ml" href="https://cloud.google.com/solutions/continuous-integration-helm-concourse" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/solutions/continuous-integration-helm-concourse</a>。</p><h1 id="eeb1" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">部署应用docker</h1><p id="89e8" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">在此步骤之前，我们已经在注册表中提供了图像。对于我们的应用程序来说，这是一个nginx，它公开了端口80并服务于angular 2构建。</p><p id="cae3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个在启动nginx之前运行的脚本，它替换了源代码中的api和静态主机变量</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="53d9" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">echo </em>"Configuring environment variable"<br/><em class="mj">sed </em>-i -e 's#SET_API_HOST_VARIABLE#'"$API_HOST"'#g' /www/main.*.js<br/><em class="mj">sed </em>-i -e 's#SET_STATIC_HOST#'"$STATIC_HOST"'#g'  /www/main.*.js</span></pre><p id="c3bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这确保了我们有一个通用的docker映像构建，但是我们仍然可以在部署之后使用环境变量来调整主机。</p><p id="8591" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也是我们在kubernetes中做的第一步，为我们的应用程序创建一个<strong class="is hj">配置图</strong>。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="041c" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>create configmap AppNameConfig --from-literal API_HOST=http://api-host --from-literal STATIC_HOST=$STATIC_HOST</span></pre><p id="4dd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在我们的应用程序kubernetes清单文件中使用这个configmap，以指定要注入的环境变量，以及它需要从哪里获取值，在本例中是map。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="f048" class="kc kd hi lw b fi mf mg l mh mi"><strong class="lw hj">apiVersion: </strong>apps/v1beta2<br/><strong class="lw hj">kind: </strong>Deployment<br/><strong class="lw hj">metadata:<br/>  name: </strong>AppName<br/><strong class="lw hj">spec:<br/>  replicas: </strong>1<br/>  <strong class="lw hj">selector:<br/>    matchLabels:<br/>      app: </strong>AppName<br/>  <strong class="lw hj">strategy:<br/>    rollingUpdate:<br/>      maxSurge: </strong>1<br/>      <strong class="lw hj">maxUnavailable: </strong>1<br/>    <strong class="lw hj">type: </strong>RollingUpdate<br/>  <strong class="lw hj">template:<br/>    metadata:<br/>      labels:<br/>        app: </strong>AppName<br/>    <strong class="lw hj">spec:<br/>      containers:<br/>      </strong>- <strong class="lw hj">env:<br/>        </strong>- <strong class="lw hj">name: </strong>API_HOST<br/>          <strong class="lw hj">valueFrom:<br/>            configMapKeyRef:<br/>              key: </strong>API_HOST<br/>              <strong class="lw hj">name: </strong>AppNameConfig<br/>        - <strong class="lw hj">name: </strong>STATIC_HOST<br/>          <strong class="lw hj">valueFrom:<br/>            configMapKeyRef:<br/>              key: </strong>STATIC_HOST<br/>              <strong class="lw hj">name: </strong>AppNameConfig<br/>        <strong class="lw hj">name: </strong>AppName<br/>        <strong class="lw hj">image: </strong>AppDockerImageName<br/>        <strong class="lw hj">ports:<br/>        </strong>- <strong class="lw hj">containerPort: </strong>80</span></pre><p id="6b84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此清单适用于:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="4ec7" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>apply -f AppManifest.yml</span></pre><p id="af64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将在kubernetes上创建部署，这将启动包含运行您的映像的容器的pod。</p><p id="68af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，无法从外部访问该部署。为了让我们的负载平衡器工作，我们需要将其公开为一个集群ip服务。这只是确保这个部署有一个集群ip。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="a42a" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>expose deployment AppName</span></pre><h1 id="f044" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">部署API docker</h1><p id="b163" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这个的流程和app docker完全一样。除了我们需要一个mongo连接。这最好存储在kubernetes secret中，这样它们就不像放在configmap中那样可见。</p><p id="9e8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个秘密:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="29ad" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>create secret generic ApiMongoSecret --from-literal MONGO_HOST="&lt;host&gt;" --from-literal MONGO_REPLICA_SET="&lt;replica&gt;" --from-literal MONGO_GET_VARIABLES="&lt;variables&gt;"</span></pre><p id="6867" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像以前一样创建配置图:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="96ae" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>create configmap ApiConfigMap --from-literal API_HOST=http://apihost --from-literal STATIC_HOST=http://statichost --from-literal APP_HOST=http://apphost</span></pre><p id="b175" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">manifest文件略有不同，因为它现在也需要注入环境变量，但是用秘密的内容填充它们。(我只包含了每种方法的一个例子)。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="7386" class="kc kd hi lw b fi mf mg l mh mi"><strong class="lw hj">apiVersion: </strong>apps/v1beta2<br/><strong class="lw hj">kind: </strong>Deployment<br/><strong class="lw hj">metadata:<br/>  name: </strong>ApiName<br/><strong class="lw hj">spec:<br/>  replicas: </strong>1<br/>  <strong class="lw hj">selector:<br/>    matchLabels:<br/>      app: </strong>ApiName<br/>  <strong class="lw hj">strategy:<br/>    rollingUpdate:<br/>      maxSurge: </strong>1<br/>      <strong class="lw hj">maxUnavailable: </strong>1<br/>    <strong class="lw hj">type: </strong>RollingUpdate<br/>  <strong class="lw hj">template:<br/>    metadata:<br/>      labels:<br/>        app: </strong>ApiName<br/>    <strong class="lw hj">spec:<br/>      containers:<br/>      </strong>- <strong class="lw hj">env:<br/>        </strong>- <strong class="lw hj">name: </strong>API_HOST<br/>          <strong class="lw hj">valueFrom:<br/>            configMapKeyRef:<br/>              key: </strong>API_HOST<br/>              <strong class="lw hj">name: </strong>ApiConfigMap<br/>        - <strong class="lw hj">name: </strong>MONGO_HOST<br/>          <strong class="lw hj">valueFrom:<br/>            secretKeyRef:<br/>              key: </strong>MONGO_HOST<br/>              <strong class="lw hj">name: </strong>ApiMongoSecret<br/>        <strong class="lw hj">name: </strong>ApiName<br/>        <strong class="lw hj">image: </strong>ApiDockerImageName<br/>        <strong class="lw hj">livenessProbe:<br/>          failureThreshold: </strong>3<br/>          <strong class="lw hj">httpGet:<br/>            path: </strong>/customendpoint<br/>            <strong class="lw hj">port: </strong>6000<br/>            <strong class="lw hj">scheme: </strong>HTTP<br/>          <strong class="lw hj">initialDelaySeconds: </strong>60<br/>          <strong class="lw hj">periodSeconds: </strong>60<br/>          <strong class="lw hj">successThreshold: </strong>1<br/>          <strong class="lw hj">timeoutSeconds: </strong>2<br/>        <strong class="lw hj">readinessProbe:<br/>          failureThreshold: </strong>3<br/>          <strong class="lw hj">httpGet:<br/>            path: </strong>/customendpoint<br/>            <strong class="lw hj">port: </strong>6000<br/>            <strong class="lw hj">scheme: </strong>HTTP<br/>          <strong class="lw hj">initialDelaySeconds: </strong>60<br/>          <strong class="lw hj">periodSeconds: </strong>60<br/>          <strong class="lw hj">successThreshold: </strong>1<br/>          <strong class="lw hj">timeoutSeconds: </strong>2<br/>        <strong class="lw hj">ports:<br/>        </strong>- <strong class="lw hj">containerPort: </strong>6000</span></pre><p id="7de1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，这个清单还有一个livenessProbe和readinessProbe配置。默认情况下，ingress将查询后端的“/”，并期望得到200的结果，以了解实例是否“正常”。因为在我们的例子中，我们没有任何来自/用于api的服务，我们在这里覆盖这个检查。</p><p id="23f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">据我所知，这也将是部署将用来了解pod是否处于错误状态的端点，以便它可以停止和重新启动它们。</p><p id="6aa0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和以前一样，应用清单文件并将其公开为集群ip服务:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="f817" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>apply -f ApiManifest.yml<br/><em class="mj">kubectl </em>expose deployment ApiName</span></pre><h1 id="92be" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">创建Google存储反向代理</h1><p id="e641" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">同样，部署这个代理的步骤是相同的。这可能也可以配置一个入口，但是我们没有时间研究这个。我们的docker是一个nginx，配置如下:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="a8cf" class="kc kd hi lw b fi mf mg l mh mi">user  nginx;<br/>worker_processes  2;<br/><br/>error_log  /var/log/nginx/error.log warn;<br/>pid        /var/run/nginx.pid;<br/><br/>load_module /usr/lib/nginx/modules/ngx_http_perl_module.so;<br/><br/>env GS_BUCKET;<br/>env INDEX;<br/><br/>events {<br/>    worker_connections  10240;<br/>}<br/><br/><br/>http {<br/>    include       /etc/nginx/mime.types;<br/>    default_type  application/octet-stream;<br/><br/>    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '<br/>                      '$status $body_bytes_sent "$http_referer" '<br/>                      '"$http_user_agent" "$http_x_forwarded_for"';<br/><br/>    access_log  /var/log/nginx/access.log  main;<br/><br/>    sendfile        on;<br/><br/>    keepalive_timeout  65;<br/><br/>    resolver                   8.8.8.8 valid=300s ipv6=off;<br/>    resolver_timeout           10s;<br/><br/>    upstream gs {<br/>        server                   storage.googleapis.com:443;<br/>        keepalive                128;<br/>    }<br/><br/>    perl_set $bucket_name 'sub { return $ENV{"GS_BUCKET"}; }';<br/>    perl_set $index_name  'sub { return $ENV{"INDEX"} || "index.html"; }';<br/><br/>     gzip on;<br/>      gzip_static on;<br/>      gzip_disable "msie6";<br/>      gzip_vary on;<br/>      gzip_proxied any;<br/>      gzip_comp_level 6;<br/>      gzip_buffers 16 8k;<br/>      gzip_http_version 1.0;<br/>      gzip_min_length 256;<br/>      gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/vnd.ms-fontobject application/x-font-ttf font/opentype image/svg+xml image/x-icon application/octet-stream;<br/><br/>    server_tokens off;<br/><br/>    server {<br/>        if ( $request_method !~ "GET|HEAD" ) {<br/>            return 405;<br/>        }<br/><br/><br/>        location ~ /(.*) {<br/>            set $query $1;<br/>            proxy_set_header    Host storage.googleapis.com;<br/>            proxy_pass          https://gs/$bucket_name/$query;<br/>            proxy_http_version  1.1;<br/>            proxy_set_header    Connection "";<br/><br/>            proxy_intercept_errors on;<br/>            proxy_hide_header       alt-svc;<br/>            proxy_hide_header       X-GUploader-UploadID;<br/>            proxy_hide_header       alternate-protocol;<br/>            proxy_hide_header       x-goog-hash;<br/>            proxy_hide_header       x-goog-generation;<br/>            proxy_hide_header       x-goog-metageneration;<br/>            proxy_hide_header       x-goog-stored-content-encoding;<br/>            proxy_hide_header       x-goog-stored-content-length;<br/>            proxy_hide_header       x-goog-storage-class;<br/>            proxy_hide_header       x-xss-protection;<br/>            proxy_hide_header       accept-ranges;<br/>            proxy_hide_header       Set-Cookie;<br/>            proxy_ignore_headers    Set-Cookie;<br/>        }<br/>    }<br/>}</span></pre><p id="c7db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的环境变量需要指定我们将代理哪个桶。同样，这保持了图像的一般性。</p><p id="e189" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创建配置图:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="0157" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>create configmap StorageProxyConfigMap --from-literal GS_BUCKET=&lt;NameOfTheStorageBucket&gt;</span></pre><p id="c8b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将启动部署的清单文件:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="acee" class="kc kd hi lw b fi mf mg l mh mi"><strong class="lw hj">apiVersion: </strong>apps/v1beta2<br/><strong class="lw hj">kind: </strong>Deployment<br/><strong class="lw hj">metadata:<br/>  name: </strong>StorageProxyName<br/><strong class="lw hj">spec:<br/>  replicas: </strong>1<br/>  <strong class="lw hj">selector:<br/>    matchLabels:<br/>      app: </strong>StorageProxyName<br/>  <strong class="lw hj">strategy:<br/>    rollingUpdate:<br/>      maxSurge: </strong>1<br/>      <strong class="lw hj">maxUnavailable: </strong>1<br/>    <strong class="lw hj">type: </strong>RollingUpdate<br/>  <strong class="lw hj">template:<br/>    metadata:<br/>      labels:<br/>        app: </strong>StorageProxyName<br/>    <strong class="lw hj">spec:<br/>      containers:<br/>      </strong>- <strong class="lw hj">env:<br/>        </strong>- <strong class="lw hj">name: </strong>GS_BUCKET<br/>          <strong class="lw hj">valueFrom:<br/>            configMapKeyRef:<br/>              key: </strong>GS_BUCKET<br/>              <strong class="lw hj">name: </strong>StorageProxyConfigMap<br/>        <strong class="lw hj">name: </strong>StorageProxyName<br/>        <strong class="lw hj">image: </strong>StorageProxyImageName<br/>        <strong class="lw hj">ports:<br/>        </strong>- <strong class="lw hj">containerPort: </strong>80</span></pre><p id="61c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">告诉kubernetes该怎么做:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="d5a2" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>apply -f StorageProxyManifest.yml<br/><em class="mj">kubectl </em>expose deployment StorageProxyName</span></pre><h1 id="d7dc" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">安装Nginx入口</h1><p id="8111" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">此时，我们有三个映像在它们的容器/pod/部署中运行，它们都作为服务公开，但是它们还不能从外部访问。为此，我们将安装一个入口负载平衡器。</p><p id="7533" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Ingress也分两部分运行，通过安装它，您设置了“nginx-ingress-controller”部署，它运行实际的nginx。</p><p id="ea10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，您可以创建入口资源，这些资源由控制器获取并配置nginx。</p><p id="802c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(默认情况下，gcloud为此提供了自己的控制器，但我们选择了nginx，因为我们可以更好地匹配现有的nginx配置。)</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="258f" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">helm </em>install --name nginx-ingress stable/nginx-ingress --set rbac.create=true<br/><em class="mj">kubectl </em>apply -f /tmp/manifests-generated/ingress-resource.yml</span></pre><p id="8fdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mj"> (RBAC选项用于基于角色的访问控制，我们没有进一步探讨)。</em></p><p id="e2c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建两个控制器，nginx-ingress-controller和nginx-ingress-default-backend，所有不匹配的URL都将路由到这两个控制器。</p><p id="5a1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了配置入口，我们创建以下资源:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="9f21" class="kc kd hi lw b fi mf mg l mh mi"><strong class="lw hj">apiVersion: </strong>extensions/v1beta1<br/><strong class="lw hj">kind: </strong>Ingress<br/><strong class="lw hj">metadata:<br/>  annotations:<br/>    ingress.kubernetes.io/ssl-redirect: </strong>"true"<br/>    <strong class="lw hj">kubernetes.io/ingress.class: </strong>nginx<br/>    <strong class="lw hj">nginx.ingress.kubernetes.io/force-ssl-redirect: </strong>"true"<br/>    <strong class="lw hj">nginx.ingress.kubernetes.io/rewrite-target: </strong>/<br/>  <strong class="lw hj">name: </strong>IngressName<br/><strong class="lw hj">spec:<br/>  rules:<br/>  </strong>- <strong class="lw hj">host: </strong>sub.host.com<br/>    <strong class="lw hj">http:<br/>      paths:<br/>      </strong>- <strong class="lw hj">backend:<br/>          serviceName: </strong>AppServiceName<br/>          <strong class="lw hj">servicePort: </strong>80<br/>        <strong class="lw hj">path: </strong>/<br/>      - <strong class="lw hj">backend:<br/>          serviceName: </strong>ApiServiceName<br/>          <strong class="lw hj">servicePort: </strong>6000<br/>        <strong class="lw hj">path: </strong>/api/<br/>      - <strong class="lw hj">backend:<br/>          serviceName: </strong>StorageProxyServiceName<br/>          <strong class="lw hj">servicePort: </strong>80<br/>        <strong class="lw hj">path: </strong>/static/<br/>  <strong class="lw hj">tls:<br/>  </strong>- <strong class="lw hj">hosts:<br/>    </strong>- sub.host.com<br/>    <strong class="lw hj">secretName: </strong>NameOfCertificateSecret</span></pre><p id="12ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此配置将/定向到应用程序，将请求/api/定向到api，将/static/定向到存储代理。重写目标注释将确保/api/ &amp; /static/不被发送到它们的后端，因此对于调用/api/todos/list，api后端将接收它作为/todos/list。</p><p id="16e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们在这里还通过指定从哪个秘密中检索证书细节来配置SSL。这是我们在设置证书管理器时配置的。基本上，入口期望从这个secretname得到一个有效的证书，否则你将得到一个假的自签名证书。</p><p id="a118" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另请注意，虽然该入口现在有一个外部IP，但该IP不是静态的，为此，必须将其提升为静态IP。这可以通过谷歌云控制台(VPC网络-&gt;外部IP -&gt;变短暂为静态，或通过控制台:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="45de" class="kc kd hi lw b fi mf mg l mh mi">IP_ADDRESS=<strong class="lw hj">$</strong><em class="mj">(kubectl describe service nginx-ingress-controller --namespace=$NAMESPACE | grep 'LoadBalancer Ingress' | rev | cut -d: -f1 | rev | xargs)<br/></em><br/><em class="mj">gcloud </em>compute addresses create NameOfStaticIp --addresses $IP_ADDRESS --region europe-west1</span></pre><p id="6312" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此命令将查找入口负载平衡器的IP地址(注意，对我们有效，因为我们只有一个，里程可能会有所不同:-))</p><p id="cf9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们将其提升为静态IP。</p><h1 id="ef3c" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">安装证书管理器和证书</h1><p id="7aae" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">到目前为止，我们有一个负载平衡器，它有一个外部IP，将请求路由到不同的后端，此时，您可以将DNS指向您的IP。</p><p id="0c6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用helm安装证书管理器:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="f5ab" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">helm </em>install stable/cert-manager</span></pre><p id="2655" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个颁发者(提供证书的实例，在我们的例子中，让我们加密):</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="46e2" class="kc kd hi lw b fi mf mg l mh mi"><strong class="lw hj">apiVersion: </strong>certmanager.k8s.io/v1alpha1<br/><strong class="lw hj">kind: </strong>Issuer<br/><strong class="lw hj">metadata:<br/>  name: </strong>NameForIssuer<br/><strong class="lw hj">spec:<br/>  acme:<br/>    </strong><em class="mj"># The ACME server URL<br/>    </em><strong class="lw hj">server: </strong>https://acme-v02.api.letsencrypt.org/directory<br/>    <em class="mj"># Email address used for ACME registration<br/>    </em><strong class="lw hj">email: </strong>"yourmail@domain.com"<br/>    <em class="mj"># Name of a secret used to store the ACME account private key<br/>    </em><strong class="lw hj">privateKeySecretRef:<br/>      name: </strong>IssuerPrivateKeyName<br/>    <em class="mj"># Enable the HTTP-01 challenge provider<br/>    </em><strong class="lw hj">http01: </strong>{}</span></pre><p id="042e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建证书:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="de05" class="kc kd hi lw b fi mf mg l mh mi"><strong class="lw hj">apiVersion: </strong>certmanager.k8s.io/v1alpha1<br/><strong class="lw hj">kind: </strong>Certificate<br/><strong class="lw hj">metadata:<br/>  name: </strong>CertificateName<br/><strong class="lw hj">spec:<br/>  secretName: </strong>NameOfCertificateSecret<br/>  <strong class="lw hj">commonName: </strong>sub.host.com<br/>  <strong class="lw hj">dnsNames:<br/>  </strong>- sub.host.com<br/>  <strong class="lw hj">issuerRef:<br/>    name: </strong>NameForIssuer<br/>    <strong class="lw hj">kind: </strong>Issuer<br/>  <strong class="lw hj">acme:<br/>    config:<br/>    </strong>- <strong class="lw hj">http01:<br/>        ingressClass: </strong>nginx<br/>      <strong class="lw hj">domains:<br/>      </strong>- sub.host.com</span></pre><p id="097c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，应用它们:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="e23c" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">kubectl </em>apply -f issuer.yml<br/><em class="mj">kubectl </em>apply -f certificate.yml</span></pre><p id="1cf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦应用了这些资源，cert-manager就会发现证书需要验证。它将创建一个新的入口来托管ACME challenge，它还将启动一个执行加密请求的pod。</p><p id="f23b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦验证完成，它将在secret中存储详细信息(我们之前也在入口中使用了它)。</p><p id="7f45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">验证可能会有一些延迟，但通常情况下，几分钟后，您应该能够访问您的主机，并看到它是安全的！</p><p id="89c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>发现一些关于设置证书管理器的混乱信息。我认为可以通过两种方式来设置。如上所述，您可以手动创建颁发者/证书，并让cert-manager完成它的工作。</p><p id="0b7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个是用注释配置入口，这样cert-manager就可以获取注释。在我们的配置中，这不需要特定的注释。</p><h1 id="77a4" class="lc kd hi bd ke ld le lf ki lg lh li km lj lk ll kp lm ln lo ks lp lq lr kv ls bi translated">附录</h1><h2 id="d732" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">设置GCloud CLI</h2><p id="c8c7" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这里有两个选项，谷歌云外壳，或者从你最喜欢的本地终端。或者，您可以用docker包装gcloud命令:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="874a" class="kc kd hi lw b fi mf mg l mh mi"><strong class="lw hj">FROM </strong>google<strong class="lw hj">/</strong>cloud-sdk:latest<br/><strong class="lw hj">RUN </strong>curl <strong class="lw hj">-</strong>o get_helm.sh https:<strong class="lw hj">//</strong>raw.githubusercontent.com<strong class="lw hj">/</strong>kubernetes<strong class="lw hj">/</strong>helm<strong class="lw hj">/</strong>master<strong class="lw hj">/</strong>scripts<strong class="lw hj">/</strong>get<br/><strong class="lw hj">RUN </strong>chmod <strong class="lw hj">+</strong>x get_helm.sh<br/><strong class="lw hj">RUN </strong>.<strong class="lw hj">/</strong>get_helm.sh</span></pre><p id="e347" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Helm可以被描述为kubernetes的一个包管理器，您将使用这个工具安装nginx-ingress和certmanager。它作为客户机/服务器架构运行，helm是您使用的cli工具，tiller是服务器(我们稍后将在集群上安装)。</p><p id="7bc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果从这个docker创建一个容器，并运行该容器，那么登录会话应该是持久的。在这种情况下，卷是在主机/docker之间共享的脚本文件夹，因此我们可以添加文件/脚本以在云上运行。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="8221" class="kc kd hi lw b fi mf mg l mh mi"><em class="mj">docker </em>create -v <strong class="lw hj">$</strong><em class="mj">(pwd)</em>/scripts:/scripts -w="/scripts" \<br/> --name=&lt;container-name&gt; -it gcloud-platform:latest /bin/bash</span><span id="03c7" class="kc kd hi lw b fi mk mg l mh mi"><em class="mj">docker </em>start -ia &lt;container-name&gt;</span></pre><p id="36a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照您喜欢的风格安装gcloud后，您可以使用以下方式登录:</p><p id="b574" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lt lu lv lw b">gcloud auth login --brief</code></p><p id="6d11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它应该向您显示一个令牌的链接，您必须在终端中复制该令牌。登录后，使用<br/> <code class="du lt lu lv lw b">gcloud config set project &lt;PROJECT_ID&gt;</code>设置您的项目ID和计算区域</p><p id="ab0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lt lu lv lw b">gcloud config set compute/zone &lt;ZONE&gt;</code></p></div></div>    
</body>
</html>