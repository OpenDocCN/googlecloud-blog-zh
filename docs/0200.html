<html>
<head>
<title>Updating Google Kubernetes Engine VM scopes with zero downtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">零停机更新Google Kubernetes引擎虚拟机范围</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/updating-google-container-engine-vm-scopes-with-zero-downtime-50bff87e5f80?source=collection_archive---------0-----------------------#2017-02-01">https://medium.com/google-cloud/updating-google-container-engine-vm-scopes-with-zero-downtime-50bff87e5f80?source=collection_archive---------0-----------------------#2017-02-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e8a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我经常在谷歌云平台Slack上闲逛，这是一个学习和讨论GCP的好社区。这是我见过很多人遇到的一种常见情况:</p><p id="2c1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">“我想用云SQL / Datastore / PubSub /等。从我的豆荚在Kubernetes引擎运行。我想使用自动虚拟机凭据，但我的虚拟机没有正确的范围或权限，我无法更改它！我该如何解决这个问题？”</em></p><p id="063a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有谷歌计算引擎虚拟机都带有内置的OAuth2服务帐户，可用于自动认证各种GCP服务。您可以通过给帐户分配不同的“范围”来选取此服务帐户有权访问的服务。</p><p id="6669" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，您可以赋予服务帐户“devstorage.read_only”范围，这样它只能从Google云存储中读取数据。您可以给另一个服务帐户“devstorage.read_write ”,这样它就可以读写数据。一个帐户可以有任意组合的范围，因此您可以给它完成工作所需的确切权限。你可以在这里找到所有谷歌搜索范围<a class="ae jd" href="https://developers.google.com/identity/protocols/googlescopes" rel="noopener ugc nofollow" target="_blank">的列表</a>。</p><p id="3e90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个服务帐户通常被称为“<a class="ae jd" href="https://developers.google.com/identity/protocols/application-default-credentials" rel="noopener ugc nofollow" target="_blank">应用程序默认凭证</a></p><h1 id="d739" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">应用程序默认凭据的问题</h1><p id="381e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">̶o̶n̶c̶e̶̶y̶o̶u̶̶c̶r̶e̶a̶t̶e̶̶t̶h̶e̶̶i̶n̶s̶t̶a̶n̶c̶e̶,̶̶y̶o̶u̶̶c̶a̶n̶'̶t̶̶c̶h̶a̶n̶g̶e̶̶t̶h̶e̶̶s̶c̶o̶p̶e̶s̶！̶̶t̶h̶e̶r̶e̶̶i̶s̶̶n̶o̶̶w̶a̶y̶̶t̶o̶̶f̶l̶i̶p̶̶o̶u̶t̶̶t̶h̶e̶̶a̶p̶p̶l̶i̶c̶a̶t̶i̶o̶n̶̶d̶e̶f̶a̶u̶l̶t̶̶c̶r̶e̶d̶e̶n̶t̶i̶a̶l̶s̶̶w̶i̶t̶h̶̶a̶n̶o̶t̶h̶e̶r̶̶o̶n̶e̶.̶(情况不再如此，<a class="ae jd" href="https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#changeserviceaccountandscopes" rel="noopener ugc nofollow" target="_blank">计算引擎现在支持在运行实例上改变范围</a>。但是，我仍然建议遵循这个指南。如果虚拟机崩溃并重新运行，或者您更改了群集大小，新虚拟机将不会有更新的范围)</p><p id="1572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种解决方案:</p><ol class=""><li id="6eb9" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=tSnzoW4RlaQ" rel="noopener ugc nofollow" target="_blank">创建一个具有正确作用域的服务帐户</a>，并在应用程序中直接使用它<em class="je">而不是使用应用程序默认凭证</em>。</li><li id="f848" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">创建一个具有正确作用域的新实例，并移动所有内容。</li></ol><p id="306e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一种方法肯定更健壮，因为如果需要的话，每个pod可以有自己的服务帐户，但是有额外的开销，迫使您管理这些帐户。我不会在这篇文章中讨论这种方法，但是如果你想要更多的控制，这是一个很好的选择。</p><p id="7df0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种方法意味着您不必进行任何代码更改或管理帐户，但在新虚拟机启动时，您有停机的风险。</p><p id="c1c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用谷歌Kubernetes引擎，如果你遵循一些简单的步骤，你可以避免这种停机时间。我们来看看吧！</p><h1 id="931e" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">初始设置</h1><p id="a112" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在这篇博文中，我们将在Google Kubernetes引擎上运行一个小型的3节点Kubernetes集群，该集群运行一个由部署支持的服务。该部署将有6个副本。</p><p id="3b0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是节点:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f59c" class="lf jg hi lb b fi lg lh l li lj">$ kubectl get nodes<br/>NAME                                      STATUS  AGE<br/>gke-cluster-1-default-pool-7d6b79ce-0s6z  Ready   2m<br/>gke-cluster-1-default-pool-7d6b79ce-9kkm  Ready   2m<br/>gke-cluster-1-default-pool-7d6b79ce-j6ch  Ready   2m</span></pre><p id="7726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是窗格(根据屏幕进行了修改):</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="76c1" class="lf jg hi lb b fi lg lh l li lj">$ kubectl get pods -o wide<br/>NAME                        NODE<br/>hello-1959708372-25x63      gke-cluster-1-default-pool-7d6b79ce-0s6z<br/>hello-1959708372-c13v2      gke-cluster-1-default-pool-7d6b79ce-9kkm hello-1959708372-fdx7z      gke-cluster-1-default-pool-7d6b79ce-j6ch hello-1959708372-n510f      gke-cluster-1-default-pool-7d6b79ce-0s6z hello-1959708372-xhz0h      gke-cluster-1-default-pool-7d6b79ce-9kkm hello-1959708372-zdmvb      gke-cluster-1-default-pool-7d6b79ce-0s6z</span></pre><p id="45f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到这些单元分布在各个节点上。</p><h1 id="f6a2" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">灾难来袭！</h1><p id="1850" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">哦不不。节点没有正确的权限！</p><p id="140f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先要做的是创建具有正确权限的新节点。为此，您可以创建一个与旧池大小相同的新节点池。这个新的节点池将与旧的节点池并排放置，可以在其上安排新的单元。</p><p id="720b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您的代码需要“devstorage.read_write”和“pubsub”范围。</p><p id="6c82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建新的节点池，请运行以下命令:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2522" class="lf jg hi lb b fi lg lh l li lj">$ gcloud container node-pools create adjust-scope \<br/>   --cluster &lt;YOUR_CLUSTER_NAME&gt; --zone &lt;YOUR_ZONE&gt; \<br/>   --num-nodes 3 \<br/>   --scopes https://www.googleapis.com/auth/devstorage.read_write,https://www.googleapis.com/auth/pubsub</span></pre><p id="8830" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和往常一样，您可以定制这个命令来满足您的需求。</p><p id="732f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您检查节点，您会注意到还有三个节点使用了新的池名称:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2ee5" class="lf jg hi lb b fi lg lh l li lj">$ kubectl get nodes<br/>NAME                                        STATUS  AGE<br/>gke-cluster-1-adjust-scope-9ca78aa9–5gmk    Ready   9m<br/>gke-cluster-1-adjust-scope-9ca78aa9–5w6w    Ready   9m<br/>gke-cluster-1-adjust-scope-9ca78aa9-v88c    Ready   9m<br/>gke-cluster-1-default-pool-7d6b79ce-0s6z    Ready   3h<br/>gke-cluster-1-default-pool-7d6b79ce-9kkm    Ready   3h<br/>gke-cluster-1-default-pool-7d6b79ce-j6ch    Ready   3h</span></pre><p id="f65c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，豆荚还在老节点上！</p><h1 id="ede2" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">该排水了</h1><p id="d0f7" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">此时，我们可以简单地删除旧的节点池。Kubernetes将检测到pod不再运行，并将它们重新安排到新的节点。</p><p id="3540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这会给应用程序带来一些停机时间，因为Kubernetes需要时间来检测新主机上的节点停止运行并启动容器。这可能只有几秒或几分钟，但这可能是不可接受的！</p><p id="f09d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更好的方法是一次从旧节点中删除一个pod，然后从集群中删除该节点。幸运的是，kubernetes有一个内置的命令来做到这一点。</p><p id="2b6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一，<a class="ae jd" href="https://kubernetes.io/docs/user-guide/kubectl/kubectl_cordon/" rel="noopener ugc nofollow" target="_blank">警戒线</a>各个旧节点。这将阻止新的pod被安排到它们上面。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8088" class="lf jg hi lb b fi lg lh l li lj">$ kubectl cordon &lt;NODE_NAME&gt;</span></pre><p id="ada4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，<a class="ae jd" href="https://kubernetes.io/docs/user-guide/kubectl/kubectl_drain/" rel="noopener ugc nofollow" target="_blank">漏</a>各节点。这将删除该节点上的所有窗格。</p><blockquote class="lk ll lm"><p id="4463" class="if ig je ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">警告:确保你的pod由副本集、部署、状态集或类似的东西管理。独立舱不会被重新安排！</p></blockquote><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="576f" class="lf jg hi lb b fi lg lh l li lj">$ kubectl drain &lt;NODE_NAME&gt; --force</span></pre><p id="e278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">清空一个节点后，确保新的单元已经启动并运行，然后再继续下一个节点。</p><p id="0f4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成后，您可以看到所有的pod都在新节点上运行！</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2c11" class="lf jg hi lb b fi lg lh l li lj">$ kubectl get pods -o wide<br/>NAME                        NODE<br/>hello-1959708372-neu42      gke-cluster-1-adjust-scope-9ca78aa9–5gmk<br/>hello-1959708372-vvjd8      gke-cluster-1-adjust-scope-9ca78aa9-v88c hello-1959708372-cn28s      gke-cluster-1-adjust-scope-9ca78aa9–5gmk hello-1959708372-cm9sd      gke-cluster-1-adjust-scope-9ca78aa9–5w6w hello-1959708372-d92jh      gke-cluster-1-adjust-scope-9ca78aa9-v88c hello-1959708372-b039s      gke-cluster-1-adjust-scope-9ca78aa9–5w6w</span></pre><h1 id="021f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">删除旧池</h1><p id="eebd" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">现在所有的pod都已安全地重新安排，是时候删除旧池了。</p><p id="f7a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将“默认池”替换为您要删除的池。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f255" class="lf jg hi lb b fi lg lh l li lj">$ gcloud container node-pools delete default-pool \<br/>   --cluster &lt;YOUR_CLUSTER_NAME&gt; --zone &lt;YOUR_ZONE&gt;</span></pre><p id="d5ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！您已经用新的作用域更新了您的集群，并且零停机！</p></div></div>    
</body>
</html>