<html>
<head>
<title>Get a single one CSV file with BigQuery export</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BigQuery导出获得单个CSV文件</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/get-a-single-one-csv-file-with-bigquery-export-956d2a147886?source=collection_archive---------0-----------------------#2021-12-17">https://medium.com/google-cloud/get-a-single-one-csv-file-with-bigquery-export-956d2a147886?source=collection_archive---------0-----------------------#2021-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8bac0c386c08031d949f7b63ddaba6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nl5A2oLqSxQaTnI9UPE1fw.png"/></div></div></figure><p id="a1ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">分布式计算</strong>是大规模处理<strong class="is hj">大数据</strong>的关键。所有数据处理系统都使用<strong class="is hj">虚拟机集群</strong> : Hadoop、Dataflow，当然还有BigQuery。<br/>几十或几百个进程可以<strong class="is hj">同时运行</strong>和<strong class="is hj">执行并行操作</strong>以加速进程。</p><p id="94b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements#export_data_statement" rel="noopener ugc nofollow" target="_blank"> BigQuery导出语句</a>是一个很好的例子:使用一条SQL语句，您可以<strong class="is hj">产生数百个槽</strong> <em class="jp">(即VM的片)</em>来从BigQuery导出数据。但是因为<strong class="is hj">导出是由数百个插槽并行</strong>执行的，所以<strong class="is hj">导出会生成数百个文件</strong>。</p><p id="b028" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经描述了<a class="ae jo" rel="noopener" href="/google-cloud/merge-clean-transform-your-csvs-easily-with-bigquery-3a73c0c26d57">如何利用BigQuery来处理、合并、清理CSV文件</a>以及作为输出的几个CSV文件<strong class="is hj">的权衡</strong>；<br/>或<a class="ae jo" rel="noopener" href="/google-cloud/replicate-data-from-bigquery-to-cloud-sql-2b23a08c52b1">如何从BigQuery导出数据并加载到云SQL </a>中，通过BigQuery对所有导出的CSV文件进行<strong class="is hj">迭代。<a class="ae jo" href="https://github.com/guillaumeblaquiere/workflow-bq-to-cloudsql/issues/1" rel="noopener ugc nofollow" target="_blank">我的GitHub repositor </a> y上有一个关于<strong class="is hj">伟大优化提议的问题:</strong></strong></p><blockquote class="jq jr js"><p id="6928" class="iq ir jp is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">与其把很多小文件导入到Cloud SQL中，为什么不把所有文件合并，在Cloud SQL中只导入一个？</p></blockquote><blockquote class="jw"><p id="0e9b" class="jx jy hi bd jz ka kb kc kd ke kf jn dx translated">如何在一个CSV文件中从BigQuery导出数据？</p></blockquote><p id="d68e" class="pw-post-body-paragraph iq ir hi is b it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj kk jl jm jn hb bi translated">让我们解决这个挑战</p><h1 id="e5d4" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">云存储合成功能</h1><p id="3090" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">云存储<strong class="is hj">存储任何类型的二进制对象</strong> (Blob)。当BigQuery执行导出时，<strong class="is hj">云存储用于存储那些导出的文件</strong>。</p><p id="3064" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云存储对于存储blob来说<strong class="is hj">非常高效(也很实惠)，但是它的<strong class="is hj">处理能力是有限的</strong>:</strong></p><ul class=""><li id="f971" class="lo lp hi is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw bi translated">可以用<a class="ae jo" href="https://cloud.google.com/storage/docs/transcoding" rel="noopener ugc nofollow" target="_blank">转码功能</a>提供纯格式的gzip文件</li><li id="9790" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated">可以对对象实施<a class="ae jo" href="https://cloud.google.com/storage/docs/lifecycle" rel="noopener ugc nofollow" target="_blank">生命周期</a></li><li id="7855" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated"><a class="ae jo" href="https://cloud.google.com/storage/docs/composing-objects" rel="noopener ugc nofollow" target="_blank">能在一个</a>中合成几个文件吗</li></ul><p id="5395" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">大致就这些！</em></p><p id="75c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最新的要点,<strong class="is hj">并不广为人知，因为它不能通过控制台</strong>获得。它允许你将<strong class="is hj"> <em class="jp">(追加)</em>多达32个文件组成一个单一的</strong>。</p><p id="4857" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这个特性被<strong class="is hj">限制为每个API调用</strong>32个文件，当你有数百个文件时，你需要<strong class="is hj">循环那个命令</strong>。</p><blockquote class="jw"><p id="6436" class="jx jy hi bd jz ka mc md me mf mg jn dx translated">如何自动循环合成上百个文件？</p></blockquote><h1 id="428d" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw mh ky kz la mi lc ld le mj lg lh li bi translated">云工作流解决方案</h1><p id="4ae4" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated"><a class="ae jo" href="https://cloud.google.com/workflows/docs" rel="noopener ugc nofollow" target="_blank">云工作流</a>允许<strong class="is hj">通过YAML文件声明一系列API调用</strong>，对流程进行控制(<a class="ae jo" href="https://cloud.google.com/workflows/docs/reference/syntax/iteration" rel="noopener ugc nofollow" target="_blank">迭代</a>、<a class="ae jo" href="https://cloud.google.com/workflows/docs/reference/syntax/conditions" rel="noopener ugc nofollow" target="_blank">条件</a>、<a class="ae jo" href="https://cloud.google.com/workflows/docs/reference/syntax/retrying" rel="noopener ugc nofollow" target="_blank">重试</a>、…)。</p><p id="c78a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此一个<strong class="is hj">工作流是完美的</strong>通过BigQuery浏览所有导出的文件并<strong class="is hj">将它们附加到一个单独的</strong> CSV文件中。</p><p id="7efa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来定义工作流！</p><h1 id="e1c7" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">BigQuery导出调用</h1><p id="2f63" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">第一步是用导出语句查询big query<strong class="is hj">。使用的格式是CSV，因为通过附加文件</strong> <em class="jp">(无头文件)</em>很容易合并CSV。</p><p id="7485" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://cloud.google.com/workflows/docs/reference/googleapis/bigquery/v2/jobs/query" rel="noopener ugc nofollow" target="_blank"> BigQuery作业查询连接器</a>用于执行该查询。<br/> <em class="jp">运行工作流的服务帐户必须对要查询的数据拥有“BigQuery数据查看者”角色，并对项目拥有“BigQuery作业用户”角色，才能运行查询作业。</em></p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="e916" class="mt km hi mp b fi mu mv l mw mx">- export-query:<br/>    call: googleapis.bigquery.v2.jobs.query<br/>    args:<br/>      projectId: ${projectid}<br/>      body:<br/>        query: ${"EXPORT DATA OPTIONS( uri='gs://" + bucket + "/" + prefix + "*.csv', format='CSV', overwrite=true,header=false) AS " + query}<br/>        useLegacySql: false</span></pre><p id="862f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp"/><code class="du my mz na mp b"><em class="jp">header=false</em></code><em class="jp">很重要，避免在每个文件中添加头，然后在追加文件时发出。</em></p><h1 id="4ffe" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">云存储管理</h1><p id="6b33" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">云存储是该工作流程的核心服务。使用了许多不同的API和功能。</p><p id="40a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">在该部分中，运行工作流的服务帐户必须拥有存储对象Admin(查看者+创建者)，才能执行以下操作。</em></p><h2 id="bcf8" class="mt km hi bd kn nb nc nd kr ne nf ng kv jb nh ni kz jf nj nk ld jj nl nm lh nn bi translated">输出文件</h2><p id="2b7a" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">作为输出，我<strong class="is hj">想要一个包含所有导出数据的新文件</strong>。我不想更改BigQuery生成的文件，以保持BigQuery过程的完整性，并在出现问题时重新运行compose操作。</p><p id="0e31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我们的想法是<strong class="is hj">创建一个初始文件，所有其他的CSV将被附加到这个文件中</strong>。<br/> <em class="jp">目前(2021年12月)连接器有问题，团队正在处理。因此，我直接使用</em> <a class="ae jo" href="https://cloud.google.com/storage/docs/json_api/v1/objects/insert" rel="noopener ugc nofollow" target="_blank"> <em class="jp">云存储JSON API</em></a></p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="5edb" class="mt km hi mp b fi mu mv l mw mx">- create-final-file:<br/>    call: http.post<br/>    args:<br/>      url: ${"https://storage.googleapis.com/upload/storage/v1/b/" + bucket + "/o?name=" + finalFileName + "&amp;uploadType=media"}<br/>      auth:<br/>        type: OAuth2<br/>      body:</span></pre><p id="b9a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">该文件可以为空(my case，</em> <code class="du my mz na mp b"><em class="jp">body:</em></code> <em class="jp">为空)，但是如果您的用例中需要一个标题，您可以手动添加一个标题。</em></p><h2 id="501d" class="mt km hi bd kn nb nc nd kr ne nf ng kv jb nh ni kz jf nj nk ld jj nl nm lh nn bi translated">列出文件</h2><p id="ab43" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">云存储的另一个用途是文件列表<strong class="is hj">获取所有导出的文件</strong>。好消息是BigQuery导出语句<strong class="is hj">需要一个云存储文件前缀</strong>来存储导出的文件。<br/>云存储<strong class="is hj">只能过滤文件前缀</strong>。</p><p id="2507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只需重用同一个就行了！</p><p id="9288" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们使用<a class="ae jo" href="https://cloud.google.com/workflows/docs/reference/googleapis/storage/v1/objects/list" rel="noopener ugc nofollow" target="_blank">云存储对象列表连接器</a></p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="4277" class="mt km hi mp b fi mu mv l mw mx">- list-files:<br/>    call: googleapis.storage.v1.objects.list<br/>    args:<br/>      bucket: ${bucket}<br/>      pageToken: ${pagetoken}<br/>      prefix: ${prefix}<br/>      maxResults: 62<br/>    result: listResult</span></pre><p id="6ca1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">我将在优化部分</em>讨论 <code class="du my mz na mp b"><em class="jp">maxResults</em></code> <em class="jp">和</em> <code class="du my mz na mp b"><em class="jp">pageToken</em></code> <em class="jp">参数</em></p><h2 id="4207" class="mt km hi bd kn nb nc nd kr ne nf ng kv jb nh ni kz jf nj nk ld jj nl nm lh nn bi translated">遍历文件</h2><p id="cb06" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">现在我们已经列出了所有文件，我们<strong class="is hj">需要迭代它们</strong>，当我们<strong class="is hj">累积了32个文件</strong>(合成限制)，或者<strong class="is hj">到达文件列表的末尾</strong>时，我们可以<strong class="is hj">运行云存储合成操作。</strong></p><p id="e93e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迭代基于云存储列表对象返回的文件列表。我们<strong class="is hj">在一个列表</strong>中追加文件名，当<strong class="is hj">列表达到32个元素时，一个组合操作被触发</strong>。</p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="3070" class="mt km hi mp b fi mu mv l mw mx">- init-iter:<br/>    assign:<br/>      - finalFileFormatted:<br/>          name: ${finalFileName}<br/>      - fileList:<br/>          - ${finalFileFormatted}<br/>- process-files:<br/>    for:<br/>      value: file<br/>      in: ${listResult.items}<br/>      steps:<br/>        - concat-file:<br/>            assign:<br/>              - fileFormatted:<br/>                  name: ${file.name}<br/>              - fileList: ${list.concat(fileList, fileFormatted)}<br/>        - test-concat:<br/>            switch:<br/>              - condition: ${len(fileList) == 32} <br/>                steps:<br/>                  - compose-files:<br/>                      call: compose_file<br/>                      args:<br/>                        fileList: ${fileList}<br/>                        projectid: ${projectid}<br/>                        bucket: ${bucket}<br/>                        finalFileName: ${finalFileName}<br/>                      next: init-for-iter<br/>                  - init-for-iter:<br/>                      assign:<br/>                        - fileList:<br/>                            - ${finalFileFormatted}<br/>- finish-compose: <em class="jp"># Process the latest files in the fileList buffer<br/>    </em>switch:<br/>      - condition: ${len(fileList) &gt; 1} <em class="jp"># If there is more than the finalFileName in the list<br/>        </em>steps:<br/>          - last-compose-files:<br/>              call: compose_file<br/>              args:<br/>                fileList: ${fileList}<br/>                projectid: ${projectid}<br/>                bucket: ${bucket}<br/>                finalFileName: ${finalFileName}</span></pre><p id="95a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">列表不是空的，第一个文件是期望的输出文件，所有其他文件都附加到它后面。</em></p><h2 id="e10a" class="mt km hi bd kn nb nc nd kr ne nf ng kv jb nh ni kz jf nj nk ld jj nl nm lh nn bi translated">撰写最终文件</h2><p id="170f" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">最后也是最重要的<strong class="is hj">，作曲操作</strong>。这里，我们是使用连接器的<strong class="is hj">并将所有文件</strong>附加到<code class="du my mz na mp b">destinationObject</code>中。</p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="52cb" class="mt km hi mp b fi mu mv l mw mx">- compose:<br/>    call: googleapis.storage.v1.objects.compose<br/>    args:<br/>      destinationBucket: ${bucket}<br/>      destinationObject: ${text.replace_all(finalFileName,"/","%2F")}<br/>      userProject: ${projectid}<br/>      body:<br/>        sourceObjects: ${fileList}</span></pre><p id="bb30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，<code class="du my mz na mp b">destinationObject</code>是“特殊的”。我们必须转换它以避免不兼容的字符。这里的<code class="du my mz na mp b">/</code>被替换为<code class="du my mz na mp b">%2F</code>，URL编码的等价物。<strong class="is hj">您可以使用类似的替换来执行带有空格字符的</strong>或<code class="du my mz na mp b">&lt;&gt;</code>。该团队正在开发新的编码功能来自动完成这项工作。</p><h1 id="f542" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">部署并运行它</h1><p id="ae1a" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">您可以在我的<a class="ae jo" href="https://github.com/guillaumeblaquiere/workflow-bq-export-to-one-csv" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的代码，并按照<code class="du my mz na mp b">README.md</code>文件中的说明来部署和运行工作流。</p><h2 id="0fd6" class="mt km hi bd kn nb nc nd kr ne nf ng kv jb nh ni kz jf nj nk ld jj nl nm lh nn bi translated">问题和优化</h2><p id="fe7f" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">在工作流YAML定义中，我包含了一些优化和问题修复。</p></div><div class="ab cl no np gp nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="hb hc hd he hf"><p id="a5af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，<strong class="is hj">当BigQuery导出结束和compose操作之间的过程太快</strong>时，<strong class="is hj">云存储上找不到文件</strong> <em class="jp">(我不知道为什么)</em>。我添加了一个1秒的睡眠计时器来解决这个延迟问题</p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="ddef" class="mt km hi mp b fi mu mv l mw mx">- waitForGCS: <em class="jp"># fix latency issue with Cloud Storage<br/>    </em>call: sys.sleep<br/>    args:<br/>      seconds: 1</span></pre></div><div class="ab cl no np gp nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="hb hc hd he hf"><p id="9d98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后为了<strong class="is hj">优化(即最小化)对Compose API </strong>的调用数量，我以31的倍数列出了对象。<br/>为什么31？<br/>因为<strong class="is hj">限制是32个文件组成</strong>，我们必须<strong class="is hj">考虑最终输出文件</strong>。因此<strong class="is hj">只有31个新文件要与最终输出文件</strong>合成。</p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="7889" class="mt km hi mp b fi mu mv l mw mx">- list-files:<br/>    call: googleapis.storage.v1.objects.list<br/>    args:<br/>      bucket: ${bucket}<br/>      pageToken: ${pagetoken}<br/>      prefix: ${prefix}<br/>      maxResults: 62</span></pre><p id="aa34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是为什么是62？不是93，124或者更多？<strong class="is hj">来了一个工作流程的限制</strong>。变量大小有一个<a class="ae jo" href="https://cloud.google.com/workflows/quotas#resource_limits" rel="noopener ugc nofollow" target="_blank">限制。今天<strong class="is hj">是64kb，很快就是256Kb </strong>，但是你不能在一个变量中存储太多的结果而不破坏你的执行。</a></p></div><div class="ab cl no np gp nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="hb hc hd he hf"><p id="3982" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最新的问题是<strong class="is hj">防止过多的迭代深度</strong>。如果递归调用一个子工作流，可以得到<a class="ae jo" href="https://cloud.google.com/workflows/docs/reference/syntax/error-types" rel="noopener ugc nofollow" target="_blank">一个执行</a> <code class="du my mz na mp b"><a class="ae jo" href="https://cloud.google.com/workflows/docs/reference/syntax/error-types" rel="noopener ugc nofollow" target="_blank">RecursionError</a></code>。<br/>解决方案是<strong class="is hj">在子工作流本身之外执行检查和迭代</strong>并<strong class="is hj">再次调用它</strong>直到递归结束<em class="jp">(仍要处理的页面)</em></p><pre class="mk ml mm mn fd mo mp mq mr aw ms bi"><span id="35df" class="mt km hi mp b fi mu mv l mw mx">- composefiles:<br/>    call: list_and_compose_file<br/>    args:<br/>      pagetoken: ${listResult.nextPageToken}<br/>      bucket: ${bucket}<br/>      prefix: ${prefix}<br/>      projectid: ${projectid}<br/>      finalFileName: ${finalFileName}<br/>    result: listResult<br/>- missing-files: <em class="jp"># Non recursive loop, to prevent depth errors<br/>    </em>switch:<br/>      - condition: ${"nextPageToken" in listResult}<br/>        next: composefiles</span></pre><h1 id="2bd6" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">组合、优化、创新</h1><p id="3abc" class="pw-post-body-paragraph iq ir hi is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hb bi translated">云工作流<strong class="is hj">是一个很好的工具，可以轻松编排API调用</strong>。您可以组合产品，而无需部署代码、编写应用程序或设置复杂的架构。你<strong class="is hj">可以解决以前需要花费更多努力才能实现的挑战</strong>。</p><p id="6710" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该产品尚未完善，一些开发者功能仍在路线图中，但<strong class="is hj">已经提供了优雅的解决方案，</strong> it <strong class="is hj">发展非常快</strong>并且<strong class="is hj">已经普遍可用(GA) </strong>。试试吧！</p></div></div>    
</body>
</html>