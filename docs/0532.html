<html>
<head>
<title>Stackdriver Error Reporting: part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Stackdriver错误报告:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/stackdriver-error-reporting-8e86be630533?source=collection_archive---------1-----------------------#2018-03-08">https://medium.com/google-cloud/stackdriver-error-reporting-8e86be630533?source=collection_archive---------1-----------------------#2018-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="601f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">带Golang和Kubernetes发动机的进一步探险</h2></div><p id="6fc2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的同事建议我写一个关于Stackdriver错误报告的博客。他拿Golang库逗我(没错！)而我决定部署到Kubernetes引擎(woop！).</p><p id="6860" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以… Stackdriver错误报告三方:本地，Docker和Kubernetes引擎。</p><h2 id="ed6b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">设置</h2><p id="0b5c" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我假设你有一个Kubernetes发动机'婴儿'集群…继续前进，前进<a class="ae kt" href="https://cloud.google.com/kubernetes-engine/docs/concepts/multi-zone-and-regional-clusters#regional" rel="noopener ugc nofollow" target="_blank">地区</a>。您可以在3个区域中运行1个节点。我建议抓住机会，探索Kubernetes发动机在这一引人注目的配置。而且，一个小时左右的时间，费用并不贵。</p><h2 id="2f47" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">堆栈驱动程序错误报告</h2><div class="ku kv ez fb kw kx"><a href="https://cloud.google.com/error-reporting/" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hj fi z dy lc ea eb ld ed ef hh bi translated">Stackdriver错误报告|谷歌云平台</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">Stackdriver错误报告基于云服务的堆栈跟踪来统计和汇总来自云服务的崩溃。</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">cloud.google.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll lm kx"/></div></div></a></div><p id="ad85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Go(lang)的文档包括部署到Kubernetes引擎<a class="ae kt" href="https://cloud.google.com/error-reporting/docs/setup/go#kubernetes_engine" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/error-reporting/docs/setup/Go # Kubernetes _ Engine</a></p><p id="4925" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Google提供的示例确实如其所言，但是让我们稍微调整一下。我们实际上只需要一个<code class="du ln lo lp lq b">error</code>,所以让我们创建一个，然后定期触发它，这样我们就可以在Stackdriver中捕获大量信息。代码如下:</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="44e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对Google提供的示例的唯一更改是第18行使用环境变量(<code class="du ln lo lp lq b">GOOGLE_PROJECT_ID</code>)来表示当前项目，以及第36–47行，其中一个无限循环每5秒触发一个go例程(可以随意修改这个计时),这会产生一个错误(当然是静态的),但是…</p><p id="86f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使用Stackdriver错误报告，我们必须在项目中启用该服务。假设你使用环境变量<code class="du ln lo lp lq b">GOOGLE_PROJECT_ID</code>来反映你的谷歌云平台项目ID，你可以:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="1741" class="jt ju hi lq b fi mc md l me mf">gcloud services enable clouderrorreporting.googleapis.com \<br/>--project=${GOOGLE_PROJECT_ID}</span></pre><p id="66ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和往常一样，我建议您使用<a class="ae kt" href="https://cloud.google.com/docs/authentication/production" rel="noopener ugc nofollow" target="_blank">应用默认凭证</a>(ADC)来验证您的代码，这样我们就可以在本地、Dockerized和Kubernetes上运行它，而无需更改。</p><h2 id="f55f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">1.使用用户凭据的本地</h2><p id="c07e" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">要在本地运行上述代码:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="ce00" class="jt ju hi lq b fi mc md l me mf">GOOGLE_PROJECT_ID=[[YOUR-PROJECT-ID]]<br/>DIR=[[YOUR-WORKING-DIRECTORY]]<br/>mkdir -p ${HOME}/tmp/${DIR}/go</span><span id="edee" class="jt ju hi lq b fi mg md l me mf">export GOPATH=${HOME}/tmp/${DIR}/go<br/>export PATH=$PATH:$GOPATH/bin</span><span id="e23d" class="jt ju hi lq b fi mg md l me mf">go get -u cloud.google.com/go/errorreporting</span><span id="628d" class="jt ju hi lq b fi mg md l me mf">wget --output-document ${HOME}/tmp/${DIR}/go/src/main.go <a class="ae kt" href="https://gist.githubusercontent.com/DazWilkin/fb372dff70fdcfc34179ef83383f67ff/raw/6c7daf9c5c1f7385bc88940cc5135cec086bb4d9/main.go" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/DazWilkin/fb372dff70fdcfc34179ef83383f67ff/raw/6c7daf9c5c1f7385bc88940cc5135cec086bb4d9/main.go</a></span><span id="1e87" class="jt ju hi lq b fi mg md l me mf">go run ${HOME}/tmp/${DIR}/go/src/main.go</span></pre><p id="38a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只要您已经使用ADC进行了身份验证，并且正确设置了<code class="du ln lo lp lq b">GOOGLE_CLOUD_PROJECT</code>，您应该会看到:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="dd82" class="jt ju hi lq b fi mc md l me mf">2018/03/07 16:23:09 [Error] pod: []; node: []; ip: []<br/>2018/03/07 16:23:14 [Error] pod: []; node: []; ip: []<br/>2018/03/07 16:23:19 [Error] pod: []; node: []; ip: []</span></pre><p id="ea0e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想更加勤奋，我们可以用下面的方式给<code class="du ln lo lp lq b">pod</code>、<code class="du ln lo lp lq b">node</code>和<code class="du ln lo lp lq b">ip</code>赋值:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="9e24" class="jt ju hi lq b fi mc md l me mf">POD_NAME="N" POD_NODE="X" POD_IP="0.0.0.0" go run main.go</span></pre><p id="1217" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后您应该会看到:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="7878" class="jt ju hi lq b fi mc md l me mf">2018/03/07 16:25:23 [Error] pod: [N]; node: [X]; ip: [0.0.0.0]<br/>2018/03/07 16:25:28 [Error] pod: [N]; node: [X]; ip: [0.0.0.0]<br/>2018/03/07 16:25:33 [Error] pod: [N]; node: [X]; ip: [0.0.0.0]</span></pre><p id="9734" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止一切顺利！</p><h2 id="83f6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">2.本地使用服务帐户凭据</h2><p id="58e6" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">通常最好对ADC使用服务帐户凭证，而不是(我们在上面所做的)使用用户凭证。要使用服务帐户，我们必须首先创建一个帐户，为它生成一个密钥，然后使用IAM为它分配适当的权限。所有上述内容可通过以下方式实现:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="bbc4" class="jt ju hi lq b fi mc md l me mf">ROBOT=[[YOUR-ROBOT-NAME]]   # gke-error-reporting<br/>EMAIL=${GOOGLE_PROJECT_ID}.iam.gserviceaccount.com</span><span id="35f1" class="jt ju hi lq b fi mg md l me mf">gcloud iam service-accounts create $ROBOT \<br/>--display-name=$ROBOT \<br/>--project=${GOOGLE_PROJECT_ID}</span><span id="5647" class="jt ju hi lq b fi mg md l me mf">gcloud iam service-accounts keys create ./key.json \<br/>--iam-account=${ROBOT}@${EMAIL} \<br/>--project=${GOOGLE_PROJECT_ID}</span><span id="79d5" class="jt ju hi lq b fi mg md l me mf">gcloud projects add-iam-policy-binding ${GOOGLE_PROJECT_ID} \<br/>--member=serviceAccount:${ROBOT}@${EMAIL} \<br/>--role=roles/errorreporting.user</span><span id="552f" class="jt ju hi lq b fi mg md l me mf">gcloud projects add-iam-policy-binding ${GOOGLE_PROJECT_ID} \<br/>--member=serviceAccount:${ROBOT}@${EMAIL} \<br/>--role=roles/errorreporting.writer</span></pre><blockquote class="mh mi mj"><p id="30ee" class="ix iy mk iz b ja jb ij jc jd je im jf ml jh ji jj mm jl jm jn mn jp jq jr js hb bi translated">为了简单起见，我将假设您要么<code class="du ln lo lp lq b">cd ${HOME}/tmp/${DIR}/go/src</code>要么只在那个目录中创建确保文件。</p></blockquote><p id="7e55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用服务帐户而不是使用凭据，</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="036f" class="jt ju hi lq b fi mc md l me mf">GOOGLE_APPLICATION_CREDENTIALS=./key.json</span></pre><p id="fdb6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并重新运行Golang:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="d63c" class="jt ju hi lq b fi mc md l me mf">go run main.go</span></pre><p id="6dfc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！</p><h2 id="45e0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">3.使用服务帐户凭据的Docker</h2><p id="519b" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这里有一个Dockerfile文件:</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="51a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Golang的一个(众多)令人惊叹的特性是，该工具使得生成简洁、静态的二进制文件(以及为您的Raspberry Pis、Omega2s等进行交叉编译)变得非常简单。—稍后更详细)。为了节省几百MB，我喜欢构建一个静态二进制文件并使用<code class="du ln lo lp lq b">SCRATCH</code>映像。要使用它，你需要为<code class="du ln lo lp lq b">amd64</code>做如下事情:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="c07d" class="jt ju hi lq b fi mc md l me mf">CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .</span></pre><p id="f280" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还需要将<code class="du ln lo lp lq b">ca-certificates.crt</code>复制到您的工作目录中，这个文件通常位于<code class="du ln lo lp lq b">/etc/ssl/certs</code>中，因此:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="b6a0" class="jt ju hi lq b fi mc md l me mf">cp /etc/ssl/certs/ca-certificates.crt ${HOME}/tmp/${DIR}/go/src</span></pre><p id="2243" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您现在可以构建Docker映像，让我们使用我最喜欢的Google容器注册中心(GCR)为我们托管它(靠近Kubernetes引擎):</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="4118" class="jt ju hi lq b fi mc md l me mf">CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .</span><span id="a648" class="jt ju hi lq b fi mg md l me mf">docker build --tag=gcr.io/${GOOGLE_PROJECT_ID}/go-errrep .<br/>gcloud docker -- push gcr.io/${GOOGLE_PROJECT_ID}/go-errrep</span></pre><p id="1a10" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，我们现在可以使用Docker和服务帐户运行示例了。在下面的命令中，我伪造了一个值<code class="du ln lo lp lq b">POD_NAME</code>,以确认错误包括以下内容:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="f032" class="jt ju hi lq b fi mc md l me mf">docker run \<br/>--env=GOOGLE_APPLICATION_CREDENTIALS=/key.json \<br/>--env=GOOGLE_PROJECT_ID=${GOOGLE_PROJECT_ID} \<br/>--env=POD_NAME=hoops \<br/>--volume=$PWD/key.json:/key.json \<br/>gcr.io/${PROJECT}/go-errrep</span></pre><p id="e641" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和以前一样，您应该会看到类似于:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="7bff" class="jt ju hi lq b fi mc md l me mf">2018/03/08 01:01:49 [Error] pod: [hoops]; node: []; ip: []<br/>2018/03/08 01:01:54 [Error] pod: [hoops]; node: []; ip: []<br/>2018/03/08 01:01:59 [Error] pod: [hoops]; node: []; ip: []</span></pre><h2 id="b2b4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">4.库伯内特斯国王</h2><p id="6394" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">好吧…我们有一个明显的工作码头工人的形象。希望你有一个集群在云中咕噜咕噜地叫着准备工作。我们有一个具有适当身份验证的服务帐户，您还记得我们启用了Stackdriver错误报告服务。让我们部署到库伯内特。</p><p id="acd0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一个优雅的解决方案可以让在Kubernetes上运行的Pods访问服务帐户。我们必须首先将服务帐户的密钥作为秘密上传到Kubernetes集群:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="fb8b" class="jt ju hi lq b fi mc md l me mf">kubectl create secret generic error-reporting-key \<br/>--from-file=key.json=${HOME}/tmp/${DIR}/go/src/key.json</span></pre><p id="f78d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，为了我们的部署，我们将会把这个密匙作为一个文件映射到Pod中。这类似于我们在Docker下本地运行解决方案时执行的<code class="du ln lo lp lq b">--volume=$PWD/key.json:/key.json</code>步骤。</p><p id="b75e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个部署文件供您使用:</p><figure class="lr ls lt lu fd lv"><div class="bz dy l di"><div class="lw lx l"/></div></figure><blockquote class="mh mi mj"><p id="03a4" class="ix iy mk iz b ja jb ij jc jd je im jf ml jh ji jj mm jl jm jn mn jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>请将第19行和第27行中的值<code class="du ln lo lp lq b">${GOOGLE_PROJECT_ID}</code>替换为您的Google云平台项目ID的实际值。</p></blockquote><p id="af0d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第13–16行创建了一个名为<code class="du ln lo lp lq b">google-cloud-key</code>的卷，其中包含了被转换成名为<code class="du ln lo lp lq b">error-reporting-key</code>的Kubernetes秘密的<code class="du ln lo lp lq b">key.json</code>文件。然后将该卷安装到<code class="du ln lo lp lq b">/var/secrets/google</code>下第20–22行的Pod中。然后通过一个名为<code class="du ln lo lp lq b">GOOGLE_APPLCIATION_CREDENTIALS</code>的环境变量显式引用该文件。您应该还记得，这是我们在本地使用Docker时引用键时使用的环境变量。</p><p id="46e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个相当复杂的过程，但这是一个解决问题的强有力的方法，或者安全地向Kubernetes Pods呈现服务帐户密钥。</p><p id="96e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们在这里时，第28–39行利用Kubernetes的<a class="ae kt" href="https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/" rel="noopener ugc nofollow" target="_blank">向下API </a>向我们的pod中的容器提供关于它们的配置的细节。您可能会觉得这是实现这一点的一种迂回方式，但它代表了一种最佳实践，正如您在本地运行容器时看到的那样，允许我们保持容器与Kubernetes的解耦。</p><p id="eef7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们将其部署到您的集群中:</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="3bf8" class="jt ju hi lq b fi mc md l me mf">kubectl apply --filename=deployment.yaml</span></pre><p id="d147" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用的是Kubernetes用户界面:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es mo"><img src="../Images/6a1a2f8667bdb59cdf3ad292cd9eeddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcjGhSn9YJ4SBDjalCDBNw.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">部署“错误报告”</figcaption></figure><p id="2382" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且，如果您选择pod并检查其日志:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es mo"><img src="../Images/0d0c14b3d7b119244c0538e16e995e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wyrdApvyTjAd7uq0Ew9LQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">Pod“错误报告”日志</figcaption></figure><p id="3149" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谷歌云控制台为Kubernetes引擎提供了越来越具有可比性的UI:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es my"><img src="../Images/1fe1760b59dfd88b0aeb3fe4a444f5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-iuFD7zxOt76kPZt2wAiQ.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">云控制台“错误报告”</figcaption></figure><p id="4fa7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，你可能会问…..那又怎样？所有这些Stackdriver错误报告的优点到底提供了什么？</p><h2 id="1677" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">返回堆栈驱动程序错误报告</h2><p id="1f1e" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们得到这个:</p><p id="1812" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">https://console.cloud.google.com/errors?project=${ GOOGLE _ PROJECT _ ID }</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es mz"><img src="../Images/8b7d29ccca523da515017ef645c29120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaAiJM-H19kautBdF2RaiA.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">堆栈驱动程序错误报告</figcaption></figure><p id="9455" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有这个:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es na"><img src="../Images/7d28487069d6297276e17c9e489d3a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vy14GHeNQE4i7fo10WMfiQ.png"/></div></div></figure><p id="7488" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开其中一个样品:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es nb"><img src="../Images/978bbd642a0f4c7ffd5a2d0c845f0122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjVN9W7PIIWZ8l2ne_dkyA.png"/></div></div></figure><p id="1e99" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可能会点击扩展示例中的<code class="du ln lo lp lq b">main.go</code>链接，并发现:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="er es nc"><img src="../Images/04f83ae9a88cc46c6948b263953e6ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mb1T38KBP2UdIwV1RIx13Q.png"/></div></div></figure><h2 id="3248" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结论</h2><p id="186e" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Stackdriver错误报告是一个强大的服务。希望这篇文章能帮助你理解如何从Golang应用程序中访问错误报告。为了演示这一点，我们创建了一个简单的Golang示例，它会重复生成错误。我们在本地部署了这个示例(1 );(2)本地下Docker(3)使用Kubernetes发动机。</p><p id="debd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了完整起见，第四个额外的方法是，在Docker下本地运行时，可以引用您的用户凭证(而不是服务帐户):</p><pre class="lr ls lt lu fd ly lq lz ma aw mb bi"><span id="9996" class="jt ju hi lq b fi mc md l me mf">docker run \<br/>--env=GOOGLE_PROJECT_ID=${GOOGLE_PROJECT_ID} \<br/>--volume=${HOME}/.config/gcloud:/.config/gcloud \<br/>gcr.io/${GOOGLE_PROJECT_ID}/go-errrep</span></pre><p id="186f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随时欢迎反馈！</p><p id="aeb5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样。</p></div></div>    
</body>
</html>