<html>
<head>
<title>Managing Secrets with KMS and Google Cloudbuild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用KMS和谷歌云构建管理秘密</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/managing-secrets-with-kms-and-google-cloudbuild-d3cc6b8a8f83?source=collection_archive---------1-----------------------#2019-02-04">https://medium.com/google-cloud/managing-secrets-with-kms-and-google-cloudbuild-d3cc6b8a8f83?source=collection_archive---------1-----------------------#2019-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4284362d6d6403d8e56c2daf57c7465a.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*le5m2CQcSIUsIpiru-m_mQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:谷歌云</figcaption></figure><p id="e8ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文旨在帮助开发人员在将应用程序部署到Google Application Engine时管理他们的秘密，期望如下:</p><ul class=""><li id="1939" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Github存储库(在我们的例子中是Typescript express应用程序)</li><li id="dcac" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">可以使用Docker在本地构建和运行应用程序</li><li id="64b3" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">谷歌云开发账户</li></ul></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="5b21" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">设置</h1><ul class=""><li id="2789" class="jo jp hi is b it lh ix li jb lj jf lk jj ll jn jt ju jv jw bi translated">按照上一篇文章中<a class="ae lm" rel="noopener" href="/coinmonks/continuous-integration-with-google-application-engine-and-travis-d822b751fb47">的描述设置你的谷歌云账户。</a></li><li id="4180" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">克隆回购</li></ul><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="4f31" class="lw kk hi ls b fi lx ly l lz ma">git clone <a class="ae lm" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:cipherzzz/ts-cloudbuild-secrets-example.git</span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="5068" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">使用谷歌KMS进行秘密管理</h1><p id="7258" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">Google Cloud有一个密钥管理系统或KMS的概念，可以通过gcloud作为命令行工具使用，并集成到cloudbuild工具中。我们将使用它来加密密码和敏感字段等秘密，并在构建时将解密后的值作为环境变量提供给docker容器。</p><h1 id="8462" class="kj kk hi bd kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg bi translated">钥匙圈/钥匙</h1><p id="c8fb" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">我们真的应该只需要一个密匙环，每个实例(集成、测试和生产)都有自己的密匙环。</p><p id="c278" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检查kms api是否已启用—<a class="ae lm" href="https://console.developers.google.com/apis/library/cloudkms.googleapis.com" rel="noopener ugc nofollow" target="_blank">https://console . developers . Google . com/APIs/library/cloud kms . Google APIs . com</a></p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="f0e5" class="lw kk hi ls b fi lx ly l lz ma"># If we do not have a keyring<br/>gcloud kms keyrings create vmi-integration-secrets --location global</span><span id="6dd9" class="lw kk hi ls b fi mj ly l lz ma"># If we already had a keyring or just created one, take a look at what keys are on it<br/>gcloud kms keys list --location global --keyring vmi-integration-secrets</span><span id="8716" class="lw kk hi ls b fi mj ly l lz ma"># To add a key - one per application<br/>gcloud kms keys create vertigo-js-node-api --location global --keyring vmi-integration-secrets --purpose encryption</span><span id="b61f" class="lw kk hi ls b fi mj ly l lz ma"># Verify that your keyring has the keys you expect<br/>gcloud kms keys list --location global --keyring vmi-integration-secrets</span></pre><p id="1c86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">密匙环和密匙将用于在cloudbuild过程中加密和解密值。当您的应用程序在云中发生变化时，您可以添加和删除密钥。如果你还有其他问题，这篇文章很棒——<a class="ae lm" href="https://cloud.google.com/kms/docs/quickstart" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/kms/docs/quickstart</a></p><h1 id="2221" class="kj kk hi bd kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg bi translated">加密秘密</h1><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="8e20" class="lw kk hi ls b fi lx ly l lz ma"># Create a local file with the secret<br/>echo "MyRedisPassword1234" &gt; redis_pw.txt</span><span id="27ff" class="lw kk hi ls b fi mj ly l lz ma"># To encrypt a secret using KMS<br/>gcloud kms encrypt \<br/>  --plaintext-file=redis_pw.txt \<br/>  --ciphertext-file=redis_pw.enc.txt \<br/>  --location=global \<br/>  --keyring=vmi-integration-secrets \<br/>  --key=vertigo-js-node-api</span><span id="09c5" class="lw kk hi ls b fi mj ly l lz ma"># Encode the binary encoded secret as base64 string<br/>base64 redis_pw.enc.txt -w 0 &gt; redis_pw.enc.64.txt</span></pre><p id="3fbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将使用上一步中获得的字符串放入您的cloudbuild文件，如下一节所述。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="62b2" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">解密秘密</h1><p id="b42f" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">我们最终想要的是一种方法来解密我们的编码秘密的base64值，并将其作为env变量注入到我们的应用程序中。有多种方法可以做到这一点，但使用cloudbuild只有一种方法。</p><h1 id="3670" class="kj kk hi bd kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg bi translated">云构建</h1><p id="809f" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">为了让cloudbuild解密我们的值，它必须是base64编码的，并表示为如下秘密(为了清楚起见，我包括了整个cloudbuild):</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="0233" class="lw kk hi ls b fi lx ly l lz ma">steps:  </span><span id="f612" class="lw kk hi ls b fi mj ly l lz ma"># Building image<br/># Note: You need a shell to resolve environment variables with $$<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  entrypoint: 'bash'<br/>  args: [ <br/>          '-c',<br/>          'docker build -t gcr.io/$PROJECT_ID/appengine/ts-cloudbuild-secrets-example:latest -f Dockerfile --build-arg REDIS_PASS=$$REDIS_PW .' <br/>        ]<br/>  secretEnv: ['REDIS_PW']     </span><span id="7df8" class="lw kk hi ls b fi mj ly l lz ma"># Push Images       <br/>- name: 'gcr.io/cloud-builders/docker'<br/>  args: ['push', 'gcr.io/$PROJECT_ID/appengine/ts-cloudbuild-secrets-example:latest'] <br/>  </span><span id="0eed" class="lw kk hi ls b fi mj ly l lz ma"># Deploy to GAE<br/>- name: 'gcr.io/cloud-builders/gcloud'<br/>  args: <br/>  - 'app'<br/>  - 'deploy'<br/>  - 'app.yaml'<br/>  - '--image-url'<br/>  - 'gcr.io/$PROJECT_ID/appengine/ts-cloudbuild-secrets-example:latest'<br/></span><span id="fcef" class="lw kk hi ls b fi mj ly l lz ma">secrets:<br/>- kmsKeyName: projects/vmi-integration/locations/global/keyRings/vmi-integration-secrets/cryptoKeys/vertigo-js-node-api<br/>  secretEnv:<br/>    REDIS_PW: CiQAkmpYKP7L1ELHIrdvp/J43k1w6EN/l4wgVZnBMMhbEr/dFxYSPQBMN3wJgwxNRTNmNpaif4rSOSHKy7gHTamaxsxo3la2qCLJfVSHz8jUA4jERssiMZAeKhHvfp5LBTDvjxk=</span></pre><p id="c04c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意底部的<code class="du mk ml mm ls b">secrets:</code>部分。这为我们的cloudbuild提供了要解密的秘密、用于解密的密钥以及我们可以用来引用它的env变量。</p><p id="587a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在cloudbuild中回到docker build指令。注意我们是如何声明<code class="du mk ml mm ls b">secretEnv</code>属性以及期望的<code class="du mk ml mm ls b">REDIS_PW</code>键的。这告诉cloudbuild，我们希望将解密的值传递到这个构建步骤中，而不是加密的base64值。还要注意，为了使用<code class="du mk ml mm ls b">$$REDIS_PW</code>语法，我们必须在<code class="du mk ml mm ls b">bash</code> shell中手动运行命令。</p><h1 id="98ce" class="kj kk hi bd kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg bi translated">Dockerfile文件</h1><p id="c654" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">我们将<code class="du mk ml mm ls b">--build-arg REDIS_PASS=$$REDIS_PW</code>从我们的cloudbuild传入我们的docker build指令。我们需要告诉我们的<code class="du mk ml mm ls b">Dockerfile</code>这个参数，以便它接受它的值。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="8e7b" class="lw kk hi ls b fi lx ly l lz ma">FROM node:8 as native-build<br/>COPY . .<br/>RUN npm install<br/>RUN npm run build</span><span id="7ef1" class="lw kk hi ls b fi mj ly l lz ma">FROM node:carbon-alpine</span><span id="c585" class="lw kk hi ls b fi mj ly l lz ma">ARG REDIS_PASS<br/>ENV REDIS_PW=${REDIS_PASS}</span><span id="93c3" class="lw kk hi ls b fi mj ly l lz ma">WORKDIR /home/node/app<br/>COPY --from=native-build /dist dist/<br/>COPY --from=native-build /package.json .<br/>COPY --from=native-build /node_modules node_modules/</span><span id="b951" class="lw kk hi ls b fi mj ly l lz ma">EXPOSE 8080</span><span id="1971" class="lw kk hi ls b fi mj ly l lz ma">USER node<br/>CMD ["npm", "start"]</span></pre><p id="1f02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意<code class="du mk ml mm ls b">Dockerfile</code>中的<code class="du mk ml mm ls b">ARG REDIS_PASS</code>——这使我们能够处理cloudbuild给出的值。还要注意<code class="du mk ml mm ls b">ENV REDIS_PW=${REDIS_PASS}</code>——这将设置<code class="du mk ml mm ls b">REDIS_PW</code> env值，该值将被放入docker容器中。每当我们运行构建的映像时，<code class="du mk ml mm ls b">REDIS_PW</code> env变量就会出现并被填充。</p><h1 id="6ef9" class="kj kk hi bd kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg bi translated">以打字打的文件</h1><p id="ee2d" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">我们通过引用<code class="du mk ml mm ls b">process.env.REDIS_PW</code>变量来访问应用程序中的解密变量。请注意，在这种情况下，我们只是检查值，但是您也可以轻松地连接到带有密码的服务器。参见<code class="du mk ml mm ls b">src/logic.ts</code></p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="2160" class="lw kk hi ls b fi lx ly l lz ma">export function checkSecret(): Payload {<br/>    let message = process.env.REDIS_PW==='MyRedisPassword1234'?"Secret Correct":"Secret Wrong";<br/>    return { message }<br/>}</span></pre></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="a867" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">部署</h1><p id="2f51" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">遵循<a class="ae lm" href="https://cloud.google.com/cloud-build/docs/build-debug-locally" rel="noopener ugc nofollow" target="_blank"> cloudbuild-local安装说明</a>以让您的gcloud sdk、docker和本地构建环境工作。</p><p id="9458" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从项目的根目录运行以下代码，<code class="du mk ml mm ls b">cloudbuild-local</code>工具将执行cloudbuild并部署应用程序。</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="1c97" class="lw kk hi ls b fi lx ly l lz ma">cloud-build-local --config=cloudbuild.yaml --dryrun=false .</span></pre><p id="4a7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">访问<code class="du mk ml mm ls b">https://&lt;service-url&gt;/secret</code>查看解密是否成功。您应该会看到类似这样的内容- <code class="du mk ml mm ls b">{"message":"Secret Correct"}</code></p></div></div>    
</body>
</html>