<html>
<head>
<title>Cache reuse across DoFn’s in Beam</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Beam中跨DoFn的缓存重用</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cache-reuse-across-dofns-in-beam-a34a926db848?source=collection_archive---------1-----------------------#2021-01-25">https://medium.com/google-cloud/cache-reuse-across-dofns-in-beam-a34a926db848?source=collection_archive---------1-----------------------#2021-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="489e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Beam </a>是一个开源的统一模型，用于定义批处理和流数据并行处理管道。管道可以用各种特定语言(Java、Python等)的SDK编写，并且可以在任何兼容beam的运行程序(Dataflow、Flink、Spark等)上执行</p><p id="cef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博文中，我们将讨论以下主题:</p><ol class=""><li id="6c3a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">DoFn的生命周期</li><li id="a7c0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">缓存数据以便跨DoFn实例重用</li><li id="b7ea" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">说明以下概念的示例:<br/> a)通过从外部源(例如:云存储)加载数据来构建内存缓存<br/> b)跨DoFn实例重用缓存的对象。<br/> c)通过外部触发器刷新缓存。</li></ol><h2 id="ba0e" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated"><strong class="ak"> DoFn生命周期</strong></h2><p id="89d1" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Dofn是用户定义的函数，与ParDo transform一起使用，为每个输入元素调用该函数以发出零个或多个元素。束是作为单个故障单元处理的元素(即记录/消息)的集合。集合成束的划分是任意的，由跑步者选择。例如，在数据流的情况下，流运行者可能更喜欢处理和提交小束以实现低延迟，而批处理运行者更喜欢处理较大束以达到更高的吞吐量。</p><p id="460d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个<a class="ae jd" href="https://beam.apache.org/releases/pydoc/2.27.0/apache_beam.transforms.core.html?highlight=start_bundle#apache_beam.transforms.core.DoFn" rel="noopener ugc nofollow" target="_blank"> DoFn类</a>都有一个为每个元素调用的process方法和下面显示的额外可选方法来处理初始化和终结任务。</p><ul class=""><li id="9578" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">设置-在创建实例后调用。初始化瞬时内存资源的好地方，比如网络连接、解析配置文件等</li><li id="34c2" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">start_bundle —在处理每个包之前调用。某些runnerss为每个bundle创建一个DoFn实例，而其他runner跨bundle重用同一个DoFn。可用于初始化用于整个包的任何状态。</li><li id="c0e5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">finish_bundle —在处理每个包之后调用</li><li id="639d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">teardown在实例被丢弃并用于任何清理之前调用</li></ul><p id="648f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，整个流程如下:</p><ul class=""><li id="a9b9" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">设置</li><li id="9250" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">重复处理包:<br/> * StartBundle <br/> *重复处理元素<br/> * FinishBundle</li><li id="5704" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">拆卸</li></ul><h2 id="81e1" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated"><strong class="ak">共享缓存</strong></h2><p id="ca66" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">有些场景需要跨DoFn实例重用共享的内存数据，以提高空间和访问效率。其中一些包括:</p><ul class=""><li id="2984" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">用于局部推理的机器学习模型</li><li id="d31d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">查找从云存储、BigQuery等外部来源加载的数据。</li></ul><p id="1e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，beam允许开发人员使用各种<a class="ae jd" href="https://beam.apache.org/documentation/sdks/java/" rel="noopener ugc nofollow" target="_blank">支持的SDK</a>来编写管道，最流行的选择是Java和Python。</p><p id="ea9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Java SDK中，每个工作线程启动一个带有多线程的JVM实例(由内核数量和作业类型决定，即批处理还是流处理)。每个线程通过为每个包创建一个DoFn实例或者跨多个数据包重用相同的实例来执行多个数据包。共享缓存可以通过单例实例来实现。</p><p id="5527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python中，由于<a class="ae jd" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a>的限制，并行性是通过多个进程实现的。每个工作者在每个内核上启动一个进程(具有多个线程),并在每个线程上执行一个或多个调用一个或多个DoFn实例的包。</p><p id="a81a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于运行者可能会回收每个包的DoFn实例，并且在不同的线程上并行运行多个这样的实例，我们如何确保缓存数据的单一副本在所有这些线程之间共享呢？您知道吗，Beam 2.24引入了一个<a class="ae jd" href="https://beam.apache.org/releases/pydoc/current/apache_beam.utils.shared.html" rel="noopener ugc nofollow" target="_blank">共享</a>类来解决完全相同的挑战，并允许您管理由多个线程共享的对象的单个实例。让我们通过为一家模拟零售公司构建一个流数据丰富管道来演示这个特性。</p><h2 id="7580" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated"><strong class="ak">示例:用于流丰富的共享缓存</strong></h2><p id="a43c" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">对管道的要求是:</p><ul class=""><li id="6fdd" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">从实时消息服务中连续读取销售事件</li><li id="c913" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">从持久性存储中加载查找数据，如客户详细信息、产品详细信息。</li><li id="15ec" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">通过将查找标识符(例如:customerid、productid)与查找详细信息相关联，用附加信息丰富事件。</li><li id="9d71" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">每隔x分钟将缓冲的丰富事件写入永久存储器。</li></ul><p id="c231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，除了以下挑战，没有什么新奇的:</p><ul class=""><li id="28cf" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">由于查找数据仅每x小时更改一次，是否可以缓存和共享数据以提高管道性能？</li><li id="de7b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">如何通知管道在新的查找数据到达时立即刷新缓存？</li></ul><p id="db08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kt">缓慢变化的查找数据<br/> </em> </strong>在深入管道设计之前，我们需要了解数据的性质和形状。在我们的示例中，查找数据存储在Google云存储中(也可以使用BigQuery ),路径格式如下:</p><p id="1422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GS://bucket/prefix/yyyy/mm/DD/customers/{ file 1…N }。JSON<br/>GS://bucket/prefix/yyyy/mm/DD/products/{ file 1…N }。json</p><p id="2c97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每天，一个单独的管道生成最新的查找数据，并向Pub/Sub发送包含最新基本路径的消息(例如gs://bucket/prefix/yyyy/mm/dd)。</p><p id="a97c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kt">模式<br/> </em> </strong>让我们检查销售事件的模式和相应的查找数据。客户和产品查找数据模式类似，包含分布在不同文件中的键值对。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5deb" class="js jt hi kz b fi ld le l lf lg"><strong class="kz hj">Sales Event</strong>: <em class="kt">{"Txid":1,"timestamp": "2020-05-02 19:08:24.796892",  "customerid": 100, "productcode": "P023", "qty": 1, "sales": 97.65 }</em></span><span id="1ede" class="js jt hi kz b fi lh le l lf lg"><strong class="kz hj"><em class="kt">customers Lookup data</em></strong><em class="kt">:  {"key":100, "value": {“name”: “john”, “tier”, “premium” }</em></span><span id="ec02" class="js jt hi kz b fi lh le l lf lg"><strong class="kz hj"><em class="kt">products Lookup data</em></strong><em class="kt">:  {"key":"P023", "value": {“sku”: “chair”, “category”, “furniture” }</em></span><span id="017d" class="js jt hi kz b fi lh le l lf lg"><strong class="kz hj">Enriched Event (i.e Output)</strong>: <em class="kt">{"Txid":1, "timestamp": "2020-05-02 19:08:24.796892",  "customerid": 100, "productcode": "P023", "qty": 1, "sales": 97.65,  "customertier": "premium”, "productcategory": "furniture" }</em></span></pre><p id="7055" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kt">流水线设计<br/> </em> </strong>我们的流水线有两个输入一个输出:</p><ul class=""><li id="9b03" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">从Google Cloud发布/订阅订阅中读取销售事件作为主要输入</li><li id="43a5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">从不同的Google Cloud发布/订阅订阅中读取查找数据的基本路径作为辅助输入。在Beam中，侧输入是不可变的p集合，可用作ParDo变换的附加输入。然后，跑步者将侧面输入广播给所有工人。关于边输入的一个重要注意事项是，它们应该足够小以适合内存。</li><li id="5b17" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">最终丰富的输出被写入Google云存储。</li></ul><p id="6b3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一步一步地浏览管道代码:</p><p id="c408" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤1:读取输入</strong></p><figure class="ku kv kw kx fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><ol class=""><li id="5e6c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">销售事件从销售发布/订阅订阅中读取，并被分配到持续时间为15分钟的<br/>固定窗口</li><li id="2070" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">从辅助输入发布/订阅订阅中读取辅助输入基本文件路径。<br/>尽管在长窗口间隔上投射侧面输入，但是由于数据驱动触发，侧面输入立即得到处理。</li></ol><blockquote class="ll lm ln"><p id="94a6" class="if ig kt ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated">注意侧面输入在窗口结束时过期，并且<br/>主输入将被阻塞，直到新的侧面输入到达或整个<br/>侧面输入窗口持续时间已经过去，以最早者为准。为了避免这种情况，<br/>确保在每个侧面<br/>输入窗口到期时通过最新的侧面输入基本路径。</p></blockquote><p id="e444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤2:创建共享缓存并丰富事件</strong></p><figure class="ku kv kw kx fd li"><div class="bz dy l di"><div class="lj lk l"/></div></figure><ol class=""><li id="604f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">创建一个共享句柄，它封装了对共享资源的单例实例的弱引用，并在构建DoFn实例时传递它。</li><li id="dd27" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在执行过程中，随着每个事件的发生，DoFn也将接收最新的侧面输入基本路径。</li><li id="4208" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在流程方法内部，共享句柄用于获取侧面输入数据，其工作方式如下所示:</li></ol><ul class=""><li id="ff6a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">在初始调用的情况下，由于数据不可用，使用load_sindeput方法从外部源加载数据。在这个例子中，对于每一个侧输入类型(即客户、产品),数据从Google云存储中读取，并加载到一个多级字典中，该字典具有指示侧输入类型的顶级关键字和值，该值表示将KV对与相应的查找数据相匹配的字典。</li></ul><blockquote class="ll lm ln"><p id="4257" class="if ig kt ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated">这里要注意的重要一点是，共享句柄需要对缓存对象的弱引用，但是list和dict等几个内置类型不直接支持<a class="ae jd" href="https://docs.python.org/3/library/weakref.html" rel="noopener ugc nofollow" target="_blank">弱引用</a>。这可以通过创建一个内置类型的子类来解决。</p></blockquote><ul class=""><li id="6db4" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">在后续调用中，使用相同的缓存对象，而不是从外部源加载。</li><li id="9cc1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">如果您注意到除了实际的查找数据之外，我们还创建了一个元数据键来保存基本路径。如果基路径发生变化，则通过将新的基路径作为标记传递给acquire方法来刷新缓存。</li></ul><p id="e556" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步:将丰富的事件写入谷歌云存储</strong></p><figure class="ku kv kw kx fd li er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/4d66cb0cdb618375d78c618a494f010f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*caL1v6f_Hj3aZ_w5"/></div></div></figure><p id="61d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">管道DAG如下所示:</p><figure class="ku kv kw kx fd li er es paragraph-image"><div class="er es ly"><img src="../Images/1d09edaf1f30a865674d05bfd871b58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*OU3YoRoy9LQ8XJMOnhMPiA.png"/></div></figure><h1 id="c8d1" class="lz jt hi bd ju ma mb mc jy md me mf kc mg mh mi kf mj mk ml ki mm mn mo kl mp bi translated">结论</h1><p id="b024" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">感谢阅读，特别感谢<a class="mq mr ge" href="https://medium.com/u/6800d4802d9a?source=post_page-----a34a926db848--------------------------------" rel="noopener" target="_blank"> Pablo Estrada </a>审阅本文。在这篇博文中，我们总结了DoFn生命周期，如何构建跨线程共享的缓存，以及通过外部触发器刷新缓存的方法。关于beam和其他有趣图案的更多信息，请参考beam <a class="ae jd" href="https://beam.apache.org/documentation/patterns/overview/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div></div>    
</body>
</html>