<html>
<head>
<title>How to properly play Wordle using Dataflow and BigQuery.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何正确使用数据流和BigQuery播放Wordle？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-properly-play-wordle-using-dataflow-and-bigquery-825d2f4099ac?source=collection_archive---------0-----------------------#2022-02-01">https://medium.com/google-cloud/how-to-properly-play-wordle-using-dataflow-and-bigquery-825d2f4099ac?source=collection_archive---------0-----------------------#2022-02-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5791bfb14bf32db19062a3c712f6fe86.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*weAMF7PC8NPpYckdZh-LFw.png"/></div></div></figure><p id="3c54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">编辑</em> </strong>:我正好在2022年梁峰会的时候讲过这个。下面是<a class="ae jp" href="https://www.youtube.com/watch?v=uDdcL7wCXB0" rel="noopener ugc nofollow" target="_blank">的演讲</a>，与文章基本相同，但做了一些额外的优化。如果你想检查代码，它在<a class="ae jp" href="https://github.com/InigoSJ/beam-summit/blob/main/2022/wordle.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><p id="d0a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你过去几周一直在社交媒体上，你可能知道什么是<strong class="is hj"> Wordle </strong>。如果没有，请允许我解释为什么这些随机的人在Twitter和Whatsapp上分享奇怪的盒子。</p><p id="521f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Wordle </strong>是一个游戏，你有6次机会猜测一个5个字母的单词，你尝试的每个单词都会告诉你最后一个单词中的字母(黄色)以及它们是否在正确的位置(绿色)。例如，如果最后一个单词是"<em class="jo"> hello </em>"并且您尝试将"<em class="jo">放在</em>下面"，则子字符串"<em class="jo"> el </em>"将是绿色的(因为它们在正确的位置)，而"<em class="jo"> o </em>"将是黄色的(因为它在最后一个单词中，但是在错误的位置)。</p><p id="1377" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和朋友聊天时，我想出了一个提高胜率的策略。我的想法是从包含最常见字母的3个单词开始，然后用它们来猜最后一个单词。不出所料，我的朋友说我的策略很愚蠢，最好用每个新单词给你带来的知识去猜测。尽管我很固执，但我决定证明他们是错的，有志者事竟成，那就是使用我最喜欢的大数据工具，<strong class="is hj">云数据流</strong>和<strong class="is hj">大查询</strong>。</p><p id="1468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有其他文章讨论最佳起始词(他们通常指向“<em class="jo"> soare </em>”)，甚至是使用代码的解决方案查找器，由编码人员和语言学家共同完成。我在这里的目标是找到可以使用的最佳单词集，不管最后的单词是什么，并且会给你(平均)最好的结果。请注意，这种方法并不试图最小化回合，而是最大化胜率。</p><p id="75ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的自然问题是，三个单词的哪个组合是最好的？这可能看起来是一个简单的问题，但是考虑到组合的数量是巨大的，计算实际的最佳组合并不是那么简单。Wordle字典包含大约10，000个单词，所以如果我们天真地想要测试每一种可能性，我们会得到10种组合，我们需要比这更聪明。</p><h1 id="fab5" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">优化和设计</strong></h1><p id="16eb" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们可以进行一些优化:</p><ol class=""><li id="c7b6" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">我们不想要有字母交集的两个单词的组合，我们已经使用前一个收集了关于那个字母的信息。</li><li id="c667" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">因为单词之间没有交集，所以不管你按什么顺序玩，最终结果都是一样的(后面会有更多的介绍)。因为我们组合了3个单词，所以我们有3个！可能的组合，我们只关心其中的一种。因此，我们可以将组合总数减少6倍。</li><li id="69af" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">我们可以使用类似于(1)的逻辑，取出有重复字母的单词。没错，结尾的单词可能有重复的字母，但同样，我们的目标是用3个单词收集尽可能多的信息，不管最终目标是什么。</li></ol><p id="c38f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一次优化将我们从10个组合减少到略少于8个10⁹组合(作为参考，大约230 GB)。应用第二次优化也将组合减少到预期的13亿个单词(前一步的六分之一)。最后，去掉有重复字母的单词，并把它们组合起来，得到不到6500万个组合，即1.8 GB的数据。我们在西班牙语中说，“大脑比肌肉好”。</p><p id="db43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，这很好，但是我是如何组合的，最好的单词是什么？这是一个高度并行化的任务，所以Apache Beam和T2数据流非常适合。鉴于我容易出错，而且这是一项繁重的任务，我将把它分成多个<strong class="is hj">数据流</strong>作业。这不仅有助于我避免因设置检查点而犯的错误，还使本文和代码更具可读性。当然，这可以通过单个管道来实现，但这里我只介绍单个管道。一旦有了结果，我们就使用<strong class="is hj"> BigQuery </strong>进行评估。</p><p id="8465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我分成的任务是:</p><ol class=""><li id="1b69" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">过滤掉有重复字母的单词。</li><li id="43a7" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">把单词互相组合，先是只有两个，然后是三个。如前所述，我只在没有交集的情况下进行合并，然后对单词进行去重。</li><li id="f84e" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">对照可能的答案检查单词组合，数出黄色和绿色。</li><li id="0c0b" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">使用<strong class="is hj"> BigQuery </strong>存储并评估结果。</li></ol><h2 id="852d" class="lh jr hi bd js li lj lk jw ll lm ln ka jb lo lp ke jf lq lr ki jj ls lt km lu bi translated"><strong class="ak">删除有重复字母的单词</strong></h2><p id="4295" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">过滤掉单词相当容易，数据量相当小，任务也不重，所以这可以用一个标准的Python脚本来完成，不需要<strong class="is hj"> Beam </strong>也不需要<strong class="is hj">数据流</strong>。为了保持一致性，我使用<em class="jo"> DirectRunner </em>用<strong class="is hj"> Apache </strong> <strong class="is hj"> Beam </strong>做了这个，下面是方法:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="2414" class="lh jr hi ma b fi me mf l mg mh">def single_letter(word):<br/>    for i, l in enumerate(word):<br/>        if l in word[i + 1:]:<br/>            return False<br/>    return True</span><span id="10c0" class="lh jr hi ma b fi mi mf l mg mh">(p | ReadFromText(f"gs://{bucket}/allowed.txt")<br/>   | Filter(single_letter)<br/>   | WriteToText(f"gs://{bucket}/no-repeated", <br/>                 file_name_suffix=".txt",<br/>                 shard_name_template='',<br/>                 num_shards=1)<br/>)</span></pre><p id="ce9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">过滤排列</strong></p><p id="5dc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，我们有了需要互相组合的单词，然后去掉互相排列的单词(例如，“<em class="jo"> hello，world</em>”=“<em class="jo">world，hello </em>”)。为此，我们将使用<em class="jo">p transform</em><a class="ae jp" href="https://beam.apache.org/releases/pydoc/current/apache_beam.transforms.util.html?#apache_beam.transforms.util.Distinct" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Distinct</strong></a>，但是我们需要拥有相同的元素，因此我们将在运行<strong class="is hj">Distinct</strong><em class="jo">p transform</em>之前对单词进行排序，以便相同的两个单词输出相同的组合，而不管顺序如何。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="2a78" class="lh jr hi ma b fi me mf l mg mh">def combine_words_dedup(main, side_words, size=3):<br/>    def _leter_intersection(word1, word2):<br/>        for l in word1:<br/>            if l in word2:<br/>                return True<br/>        return False<br/>    <br/>    for side in side_words:<br/>        intersection = _leter_intersection(main, side)<br/>        if not intersection:<br/>            if size == 2 and main &gt; side:<br/>                yield f"{side},{main}"<br/>            else:<br/>                yield f"{main},{side}"</span><span id="9f10" class="lh jr hi ma b fi mi mf l mg mh">{..}</span><span id="d0e2" class="lh jr hi ma b fi mi mf l mg mh">side_words = p |  "Side Words" &gt;&gt; ReadFromText(f"gs://{bucket}/no-repeated.txt")</span><span id="ecbb" class="lh jr hi ma b fi mi mf l mg mh">words = (p | "Main Words" &gt;&gt; ReadFromText(f"gs://{bucket}/no-repeated.txt")<br/>           | "Combine words" &gt;&gt; FlatMap(combine_words_dedup, <br/>                          side_words=beam.pvalue.AsList(side_words), <br/>                          size=2)<br/>           | Distinct()<br/>           | WriteToText(f"gs://{bucket}/two-words", file_name_suffix=".txt")<br/>        )</span></pre><p id="e55e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于两个单词的组合，我们可以如上所示将它们就地排序，对于三个单词的组合，我们需要拆分然后排序，因为新加入的单词可能在排序后位于中间(即，"<em class="jo"> hello，world </em> " + " <em class="jo"> green </em>"应该是"<em class="jo"> hello，green，world </em>"而不是"<em class="jo"> hello，world，green </em>")。因此，我们需要在我们的管道中添加一个步骤，即<strong class="is hj">排序:</strong></p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="2012" class="lh jr hi ma b fi me mf l mg mh">words = (p | "Main Words" &gt;&gt; ReadFromText(f"gs://{bucket}/two-words*")<br/>           | "Combine words" &gt;&gt;  FlatMap(combine_words_dedup, <br/>                                         side_words=beam.pvalue.AsList(side_words))<br/>           | "Sort" &gt;&gt; Map(lambda x: ",".join(sorted(x.split(",")))) # Only used for size three words<br/>           | Distinct()<br/>           | WriteToText(f"gs://{bucket}/three-words", file_name_suffix=".txt")<br/>        )</span></pre><p id="5f08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">对比可能的答案</strong></p><p id="eb08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，现在我们有了两个和三个单词的组合，没有重复的字母，也没有可能排列的重复，现在是时候实际计算这些组合有多好了。</p><p id="fc18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们正在将这些组合与Wordle 可能的最终答案进行比较，这比6300个组合的2300个最终单词多一点，这意味着我们必须进行大约1.45 * 10次比较。我很高兴我在用数据流做这件事。</p><p id="8dd7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要一种方法来评分，所以我只是简单地计算每个组合在可能的答案中有多少个黄色和绿色，然后我会将它存储到BQ中，并在那里进行计算。这就是我正在使用的函数(它依赖于没有重复字母的事实)。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="deda" class="lh jr hi ma b fi me mf l mg mh">class WordleRow(DoFn):<br/>    def process(self, words, answers, num_words=None):<br/>        words_letters = [list(w) for w in words.split(",")]<br/>        greens, yellows, total = 0, 0, 0<br/>        for answer in answers:<br/>            total += 1<br/>            for word_letters in words_letters:<br/>                for i, el in enumerate(word_letters):<br/>                    if el == answer[i]:<br/>                        greens += 1<br/>                    elif el in answer:<br/>                        yellows += 1 <br/>        yield self._format_result(words, yellows, greens, total, num_words)<br/>    <br/>    def _format_result(self, words, yellows, greens, total, num_words):<br/>        <br/>        if not num_words:<br/>            num_words = len(words.split(","))<br/>        <br/>        d = {<br/>            "words": words, <br/>            "yellows": yellows, <br/>            "greens": greens, <br/>            "total": total,<br/>            "yellows_avg": yellows / total,<br/>            "greens_avg": greens / total,<br/>            "amount_words": num_words<br/>        }<br/>        return d</span></pre><p id="1d4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，我还存储了每个组合的总字数以及平均值，只是为了完整。</p><p id="90e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的管道如下所示:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="b277" class="lh jr hi ma b fi me mf l mg mh">answers = (p | "Answers" &gt;&gt; ReadFromText(f"gs://{bucket}/answers.txt")<br/>                      | Map(list))</span><span id="7d5c" class="lh jr hi ma b fi mi mf l mg mh">words = (p | "Combinations" &gt;&gt; ReadFromText(f"gs://{bucket}/three-words*")<br/>           | ParDo(WordleRow(), answers=beam.pvalue.AsList(answers), num_words=3)<br/>           | WriteToBigQuery(<br/>               table,<br/>               schema=schema,<br/>               write_disposition=BigQueryDisposition.WRITE_APPEND,<br/>               create_disposition=BigQueryDisposition.CREATE_IF_NEEDED<br/>           )</span></pre><p id="4bee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我对这两个词的组合和最初过滤的词做了同样的处理，所以我们在BigQuery中也有这些信息。稍后您将会看到为什么这很方便。</p><p id="7a76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">计算分数</strong></p><p id="8612" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在有一个包含所有组合结果的表，但是我们仍然需要找出哪些组合更好。</p><p id="a911" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这并不像你想的那样是一个直截了当的问题，因为我们如何给这个组合打分呢？很明显，绿色字母应该比黄色字母更有价值，但是价值多少呢？这是不变的还是绿色信在早期更有价值？</p><p id="d091" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了回答这个问题，我确实检查了数据本身，并与一些人进行了交谈(包括我的朋友，他们不喜欢我的策略，认为这是大材小用)。前三个单词的组合得到大约2.3 <em class="jo">黄色</em>和1.5 <em class="jo">绿色</em>，所以我不能高估绿色字母。有两个<em class="jo">黄色</em>和两个绿色使得最终的单词非常明显，添加一个<em class="jo">绿色</em>或<em class="jo">黄色</em>在这一点上没有什么区别。所以我决定将绿色的<em class="jo">值为1.75，黄色的<em class="jo">值为1。</em></em></p><p id="c52a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，第一次尝试得到两个果岭和第三次不一样。我也想知道我应该按照什么顺序来玩单词的组合。因此，我使用绿色的1.75值来选择前50个单词，并生成可能是该组合一部分的两个单词，然后再次运行查询，根据这些单词进行过滤。在这种情况下，我把<em class="jo">果岭</em>的价值定为2.25，因为早点有<em class="jo">果岭</em>显然更好。</p><p id="e248" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">能够快速进行这些计算是我选择<strong class="is hj"> BigQuery </strong>来存储结果的主要原因。我知道我需要调查数据，并有一些额外的上下文来找出最佳的可能组合，<strong class="is hj"> BigQuery </strong>是正确的选择。</p><p id="8f83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是inigo，“<em class="jo">你还是没有告诉我们最佳组合</em>”，你可能在想。嗯，你可能是对的，我没有，原因是我想解释我是如何得到这个答案的，因为“最好”的定义并不像有些人希望的那样清楚，但是不要再等了，它来了:</p><p id="7d44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最佳组合是(按此顺序):<strong class="is hj"> PRATE，SOILY，DUNCH </strong></p><p id="83ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理由是这样的:使用三个词的组合，“神奇组合”排名第14位，得分(<em class="jo">1.75<em class="jo">绿色</em>)为<em class="jo"> 5.01 </em>，平均<em class="jo"> 1.49 </em> <em class="jo">绿色</em>和<em class="jo"> 2.4黄色</em>。排名第一的是“<em class="jo"> dhole，pricy，saunt”</em>，得分为<em class="jo"> 2.365 </em> <em class="jo"> yellows </em>，<em class="jo"> 1.53 greens </em>和<em class="jo"> 5.04 </em>加权，这是一个非常非常小的改进，但当衡量由这两个单词组成的两个单词组合时，“<em class="jo"> prate，soily”</em>则好得多(少0.4的加权得分</em></p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/3248a657963648d56ade7dc9b2ba0ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*CzoVGhl2U5jG2sLACIa0rw.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">使用权重1.75表示绿色的前16个单词</figcaption></figure><p id="1fd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">拥有一个强有力的两个单词的组合会给你很大的优势，你甚至不需要第三个单词。"<em class="jo"> prate，soily </em>"使用绿色的权重<em class="jo"> 2.25 </em>排名第六，这是第二个使用更多绿色的组合，但当使用3字组合顶部的单词时，它是最好的。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/b9d2df26ce90a7a8ad1460404e55fcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*e7g4LrICS-lhnxf6FrIi2Q.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">从前3个单词组合中生成的前10个双单词组合</figcaption></figure><p id="259b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们只需要检查“prate”是否比“soily”更好，事实就是如此。</p><p id="42ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于完整性和好奇心，这里有一些其他指标的琐事:</p><ul class=""><li id="aa88" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn mp kz la lb bi translated"><strong class="is hj">大多数绿色:</strong></li></ul><p id="256b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> (3个字)布兰特、库德、席利</em>与<em class="jo"> 1.5632 </em>果岭</p><p id="6449" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(2个字)<em class="jo">膜，固体</em>带<em class="jo"> 1.205 </em></p><p id="fa36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">(单字)塞恩</em>带<em class="jo"> 0.666 </em></p><ul class=""><li id="dc91" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn mp kz la lb bi translated"><strong class="is hj">最黄:</strong></li></ul><p id="f132" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> (3个单词)estro，unhip，yclad </em>带<em class="jo"> 3.382黄色</em></p><p id="dacc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(二字)<em class="jo">雌鹿，旋覆花</em>同<em class="jo"> 2.652 </em></p><p id="ada6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">(单字)estro </em>带<em class="jo"> 1.486 </em></p><ul class=""><li id="4e47" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn mp kz la lb bi translated"><strong class="is hj">最佳加权:</strong></li></ul><p id="8662" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(3个字，1.75值)<em class="jo"> dhole，pricy，saunt </em>用5.046</p><p id="f868" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(2个单词，2.25个值)<em class="jo"> clint，soare </em>为4.465</p><p id="fc4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(单字，2.75值)<em class="jo">等于</em>等于2.923</p><ul class=""><li id="2663" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn mp kz la lb bi translated"><strong class="is hj">最佳黄色+绿色:</strong></li></ul><p id="b690" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(3个单词)<em class="jo"> dhole，pricy，saunt</em>3.897(此处有许多平局，使用绿色作为平局决胜符)，<em class="jo"> dunch，prate，soily </em>得到相同的和，但绿色更少</p><p id="023c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">两个字)【irone，索特</em>3.05(同样，很多领带)</p><p id="13d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(单字)<em class="jo">用1.789烘烤</em></p><p id="73ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会注意到“<em class="jo"> clint，soare </em>”有一个很强的两个词的组合和最佳加权的单个词(“<em class="jo"> soare </em>”)，但在检查三个词的组合时，这两个词的最佳组合(“<em class="jo"> soare，clint，humpy </em>”)排名在第400位以上。如果你的目标是减少回合数，这可能是一个不错的组合。</p><h1 id="1c5d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">注意事项及其他改进</strong></h1><p id="84a9" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">当然，所有这些计算都依赖于我做的一些假设，比如组合不应该有重复的字母，以及我对绿色和黄色的权重。</p><p id="8a96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，英语中可能有一些细微差别，使得一些字母比其他字母更有价值，例如，在西班牙语中，如果你得到一个"<em class="jo"> Q" </em>，你知道后面会有一个"<em class="jo"> U </em>"。从理论上讲，这应该已经通过平均计算出来了，但可能会有异常值。</p><p id="35d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的假设可能导致结果不是最优的，但是我提供的答案应该是最优的一个很好的近似值。</p><p id="8575" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如前所述，可以做许多改进来使管道运行得更快，以及用单个管道代替多个管道。可以做的最大改进之一是计算单个单词的绿色和黄色，然后通过简单地将没有交集的值相加来进行组合，这将避免多次计算单个单词的分数。我一开始没有这样做的原因是这样会使代码更难阅读，设计背后的原因更难理解。此外，这一改进将为我节省大约30分钟左右的等待时间，这是我并不真正关心的。</p><p id="0828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，有些人可能会认为，只要没有交集，计算最上面的单个单词并按顺序进行组合会返回最佳的单词组合。不幸的是，这不是真的，这种方法输出的单词远远超出了前100个组合。</p><h1 id="0d3f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">学习</strong></h1><p id="2c23" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在进行这些计算时，我想“陷入”天真方法会遇到的大多数问题(除了允许单词交叉)，所以我确实运行了所有没有改进的组合(重复数据删除和过滤有重复单词的单词)，只是为了知道我节省了多少时间。我的估计是，一个天真的方法将需要大约100倍以上(和100倍以上的成本)。</p><p id="9fda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很明显，在处理这类问题时，有时我们需要后退一步，利用我们对数据的了解来构建我们的代码。</p><p id="e7a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章的“坏处”是它破坏了我玩<strong class="is hj"> Wordle </strong>的乐趣。我一直在反复检查这种方法是否有效，并且我已经平均进行了大约4轮来得到正确的答案，我认为这是非常好的(再次注意，本文的目标是帮助获得正确的单词，而不管需要进行多少轮)</p><p id="59ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(剧透警报)</p><p id="51c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，你可以用今天的<strong class="is hj">单词:</strong>来测试我的策略</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/d8dce4f968501c73c49d68231c7eea16.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*HYOoRNMrWtySaQsRSZi_eQ.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">文字227 4/6</figcaption></figure><p id="3809" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你学到了一些东西，快乐Wordling！</p></div></div>    
</body>
</html>