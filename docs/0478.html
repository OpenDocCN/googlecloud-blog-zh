<html>
<head>
<title>Sharded Mongodb in Kubernetes StatefulSets on GKE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GKE的Kubernetes StatefulSets中的分片Mongodb</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/sharded-mongodb-in-kubernetes-statefulsets-on-gke-ba08c7c0c0b0?source=collection_archive---------1-----------------------#2018-01-02">https://medium.com/google-cloud/sharded-mongodb-in-kubernetes-statefulsets-on-gke-ba08c7c0c0b0?source=collection_archive---------1-----------------------#2018-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6e31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">最初出版。</em></p><p id="cace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi je translated"><span class="l jf jg jh bm ji jj jk jl jm di"> D </span> aemon博客:<a class="ae jn" href="https://sunnykrgupta.github.io/sharded-mongodb-in-kubernetes-statefulsets-on-gke.html" rel="noopener ugc nofollow" target="_blank">https://sunnykrgupta . github . io/sharded-MongoDB-in-kubernetes-stateful sets-on-gke . html</a></p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/42ea7a87f7e46344e1195af8a18db176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u_M0HV4Zf1gUUlbI.png"/></div></div></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="27bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博客将展示如何在Google Kubernetes引擎上设置分片的MongoDB集群。我们将使用kubernetes StatefulSets特性来部署mongodb容器。</p><p id="24b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续演示之前，我们需要了解一些概念。</p><h1 id="95dc" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset" rel="noopener ugc nofollow" target="_blank">状态集</a></h1><p id="ccc1" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">StatefulSets就像一个部署，它管理pod并保证这些pod的顺序和唯一性。它为他们的每一个豆荚保持一个粘性的身份。它有助于部署需要持久性、唯一网络标识符(DNS、主机名等)的应用程序，并且是有状态应用程序的手段。如果pod被终止或删除，如果由persistentvolumes管理，卷数据将保持不变。</p><h1 id="8d83" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/storage/storage-classes/#gce" rel="noopener ugc nofollow" target="_blank">存储类</a></h1><p id="1889" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">StorageClass有助于管理人员描述Kubernetes提供的存储“类别”。每个存储类都有不同的provisioner(gcepersistindisk、AWSElasticBlockStore、AzureDisk等),用于确定使用哪个卷插件来配置存储。</p><h1 id="b33e" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持续卷</a></h1><p id="69ad" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">持久卷(PV)是群集中由管理员调配的一块存储。PV是可供任何Pod使用的资源。任何Pod都可以通过PersistentVolumeClaims (PVC)来声明这些卷，并最终在声明被删除时被释放。</p><h1 id="af51" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">无头服务</a></h1><p id="fe8a" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">无头服务用于配置具有由服务定义的相同选择器的pod的DNS。它通常不用于负载平衡目的。每个配置了标签选择器的无头服务有助于为在状态集中运行的pod定义唯一的网络标识符。</p><p id="bef2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始演示吧。请切换到您的终端并按照说明进行操作。</p><blockquote class="lk ll lm"><p id="71ae" class="if ig jd ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">N <!-- -->注意:这个设置与&lt; = mongo 3.2兼容。</p></blockquote><h1 id="b54c" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">1.先决条件</h1><p id="1b75" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">确保您的主机Linux系统上已经满足以下依赖关系:</p><ol class=""><li id="0472" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">GCP的云客户端命令行工具<a class="ae jn" href="https://cloud.google.com/sdk/docs/quickstarts" rel="noopener ugc nofollow" target="_blank"> gcloud </a></li><li id="d837" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">gcloud认证到一个项目来管理容器引擎。</li><li id="48ce" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">安装Kubernetes命令工具(“kubectl”)，</li><li id="3cfd" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">配置kubernetes身份验证凭证。</li></ol></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="15e3" class="kh ki hi bd kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le bi translated">2.创建命名空间、存储类、Google计算磁盘和持久卷。</h1><p id="4dd0" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我们的Mongodb设置如下:</p><ul class=""><li id="545b" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc mj lw lx ly bi translated">1x配置服务器(k8s部署类型:“StatefulSet”)</li><li id="ceed" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated">2x分片，每个分片是包含1x副本的副本集(k8s部署类型:“StatefulSet”)</li><li id="e84b" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated">2台Mongos路由器(k8s部署类型:“部署”)</li></ul><p id="9197" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个kubernetes名称空间，并将所有上述资源部署在我们定义的名称空间中。我们将定义statefulset容器将使用的磁盘。磁盘将通过StorageClass和PersistentVolume中定义的API安装在运行mongodb服务器的pods上。</p><h2 id="955b" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">2.1创建名称空间</h2><p id="9f99" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">创建一个名为<code class="du my mz na nb b">namespace.yaml</code>的文件，并用您的句柄名称或任何其他名称替换<code class="du my mz na nb b">NAMESPACE_ID</code>。我将用<code class="du my mz na nb b">daemonsl</code>创建一个名称空间。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="ae52" class="mk ki hi nb b fi ng nh l ni nj">#namespace.yaml<br/>apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: NAMESPACE_ID<br/></span><span id="2167" class="mk ki hi nb b fi nk nh l ni nj">#To apply resources to kubernetes, run<br/>sed -e "s/NAMESPACE_ID/daemonsl/g" namespace.yaml &gt; tmp-namespace.yaml<br/>kubectl apply -f tmp-namespace.yaml</span><span id="51d4" class="mk ki hi nb b fi nk nh l ni nj">#To verify namespaces<br/>kubectl get ns</span></pre><h2 id="4c27" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">2.2创建存储类</h2><p id="c663" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">创建一个文件为<code class="du my mz na nb b">gce-ssd-storageclass.yaml</code>。我们将我们的存储类名称定义为<code class="du my mz na nb b"><strong class="ih hj">fast</strong></code>，并使用GCE持久性磁盘作为我们的provisioner，并使用<code class="du my mz na nb b">type: pd-ssd</code>来允许将SSD磁盘类型分配给请求者(即这里的statefulset容器)。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="8e3f" class="mk ki hi nb b fi ng nh l ni nj">#gce-ssd-storageclass.yaml<br/>kind: StorageClass<br/>apiVersion: storage.k8s.io/v1<br/>metadata:<br/>  name: fast<br/>provisioner: kubernetes.io/gce-pd<br/>parameters:<br/>  type: pd-ssd</span><span id="2025" class="mk ki hi nb b fi nk nh l ni nj">#To apply resources to kubernetes, run<br/>kubectl apply -f gce-ssd-storageclass.yaml</span><span id="96fa" class="mk ki hi nb b fi nk nh l ni nj">#To verify storageclass<br/>kubectl get sc</span></pre><h2 id="e0f1" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">2.3创建GCE SSD磁盘</h2><p id="b7e4" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我们将创建一些磁盘供mongodb statefulset容器使用。我们订购了两个<code class="du my mz na nb b">10GB</code>盘和一个<code class="du my mz na nb b">5GB</code>类型的<code class="du my mz na nb b">SSD</code>盘。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="5d62" class="mk ki hi nb b fi ng nh l ni nj">#For MainDB servers<br/>gcloud compute disks create --size 10GB --type pd-ssd pd-ssd-disk-k8s-mongodb-daemonsl-10g-1<br/>gcloud compute disks create --size 10GB --type pd-ssd pd-ssd-disk-k8s-mongodb-daemonsl-10g-2</span><span id="0024" class="mk ki hi nb b fi nk nh l ni nj">#For Config servers<br/>gcloud compute disks create --size 5GB --type pd-ssd pd-ssd-disk-k8s-mongodb-daemonsl-5g-1</span></pre><h2 id="ff60" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">2.4创建持久卷</h2><p id="c79f" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">创建一个文件名为<code class="du my mz na nb b">ext4-gce-ssd-persistentvolume.yaml</code>的文件。我们将我们的持久卷存储容量<code class="du my mz na nb b">10GB</code>定义为由<code class="du my mz na nb b">maindb</code> pod限定，将<code class="du my mz na nb b">5GB</code>定义为由<code class="du my mz na nb b">configdb</code> pod限定。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="8157" class="mk ki hi nb b fi ng nh l ni nj">#ext4-gce-ssd-persistentvolume.yaml<br/>apiVersion: "v1"<br/>kind: "PersistentVolume"<br/>metadata:<br/>  name: data-volume-k8s-mongodb-daemonsl-SIZEg-INSTANCE<br/>spec:<br/>  capacity:<br/>      storage: SIZEGi<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  persistentVolumeReclaimPolicy: Retain<br/>  storageClassName: fast<br/>  gcePersistentDisk:<br/>    fsType: ext4<br/>    pdName: pd-ssd-disk-k8s-mongodb-daemonsl-SIZEg-INSTANCE</span></pre><p id="aaa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上述模板，按以下顺序修改和应用:</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="2af7" class="mk ki hi nb b fi ng nh l ni nj">#Replace 'SIZE' with 10 and 'INSTANCE' with 1,<br/><strong class="nb hj"># Ex: data-volume-k8s-mongodb-daemonsl-10g-1, storage: 10Gi,<br/></strong>sed -e "s/INSTANCE/1/g; s/SIZE/10/g" ext4-gce-ssd-persistentvolume.yaml &gt; tmp-ext4-gce-ssd-persistentvolume.yaml<br/><strong class="nb hj">kubectl apply -f tmp-ext4-gce-ssd-persistentvolume.yaml</strong></span><span id="e9e9" class="mk ki hi nb b fi nk nh l ni nj"><strong class="nb hj">#Replace 'SIZE' with 10 and 'INSTANCE' with 2<br/></strong>sed -e "s/INSTANCE/2/g; s/SIZE/10/g" ext4-gce-ssd-persistentvolume.yaml &gt; tmp-ext4-gce-ssd-persistentvolume.yaml<br/><strong class="nb hj">kubectl apply -f tmp-ext4-gce-ssd-persistentvolume.yaml</strong></span><span id="2af4" class="mk ki hi nb b fi nk nh l ni nj"><strong class="nb hj">#Replace 'SIZE' with 5 and 'INSTANCE' with 1<br/></strong>sed -e "s/INSTANCE/1/g; s/SIZE/5/g" ext4-gce-ssd-persistentvolume.yaml &gt; tmp-ext4-gce-ssd-persistentvolume.yaml<br/><strong class="nb hj">kubectl apply -f tmp-ext4-gce-ssd-persistentvolume.yaml</strong></span><span id="8b90" class="mk ki hi nb b fi nk nh l ni nj">#To verify PersistentVolume creation,<br/>kubectl get pv</span></pre><p id="a7bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经准备好<strong class="ih hj">存储类、命名空间、磁盘</strong>和<strong class="ih hj">持久卷</strong>作为statefulset容器的资源。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="027e" class="kh ki hi bd kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le bi translated">3.StatefulSet容器和Mongos部署。</h1><h2 id="b7d4" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">3.1 Statefulset ConfigDB</h2><p id="4f16" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">创建一个文件为<code class="du my mz na nb b">mongodb-configdb-service-stateful.yaml</code>并复制以下模板。将<code class="du my mz na nb b">NAMESPACE_ID</code>替换为<code class="du my mz na nb b">daemonsl</code>，或者您定义的任何名称，将<code class="du my mz na nb b">DB_DISK</code>替换为<code class="du my mz na nb b">5Gi</code>。</p><p id="c87b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用clusterIP <code class="du my mz na nb b">None</code>创建了一个无头服务，选择器为<code class="du my mz na nb b">role: mongodb-configdb</code>监听端口<code class="du my mz na nb b">27019</code>。我们已经用mongodb参数和volumeClaimTemplates定义了statefulset定义。这里，<code class="du my mz na nb b">VolumeClaimTemplates</code>正在向<code class="du my mz na nb b">storage capacity 5GB</code>请求存储类<code class="du my mz na nb b">fast</code>。这个volumeClaimTemplates将这个请求注册到storageclass，storageclass在<code class="du my mz na nb b">PersistentVolume (PV)</code>之前完成这个请求，并在<code class="du my mz na nb b">PersistentVolumeClaims (PVC)</code>中注册声明。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="bbbd" class="mk ki hi nb b fi ng nh l ni nj">#mongodb-configdb-service-stateful.yaml<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongodb-configdb-headless-service<br/>  namespace: NAMESPACE_ID<br/>  labels:<br/>    name: mongodb-configdb<br/>spec:<br/>  ports:<br/>  - port: 27019<br/>    targetPort: 27019<br/>  clusterIP: None<br/>  selector:<br/>    role: mongodb-configdb<br/>---<br/>apiVersion: apps/v1beta2  #change this version based on master version<br/>kind: StatefulSet<br/>metadata:<br/>  name: mongodb-configdb<br/>  namespace: NAMESPACE_ID<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      role: mongodb-configdb # has to match .spec.template.metadata.labels<br/>  serviceName: mongodb-configdb-headless-service<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        role: mongodb-configdb<br/>        tier: configdb<br/>    spec:<br/>      affinity:<br/>        podAntiAffinity:<br/>          preferredDuringSchedulingIgnoredDuringExecution:<br/>          - weight: 100<br/>            podAffinityTerm:<br/>              labelSelector:<br/>                matchExpressions:<br/>                - key: tier<br/>                  operator: In<br/>                  values:<br/>                  - configdb<br/>              topologyKey: kubernetes.io/hostname<br/>      terminationGracePeriodSeconds: 10<br/>      containers:<br/>        - name: mongodb-configdb-container<br/>          image: mongo<br/>          command:<br/>            - "mongod"<br/>            - "--port"<br/>            - "27019"<br/>            - "--dbpath"<br/>            - "/mongo-disk"<br/>            - "--bind_ip"<br/>            - "0.0.0.0"<br/>            - "--configsvr"<br/>          resources:<br/>            requests:<br/>              cpu: 50m<br/>              memory: 100Mi<br/>          ports:<br/>            - containerPort: 27019<br/>          volumeMounts:<br/>            - name: mongodb-configdb-persistent-storage-claim<br/>              mountPath: /mongo-disk<br/>  volumeClaimTemplates:<br/>  - metadata:<br/>      name: mongodb-configdb-persistent-storage-claim<br/>      annotations:<br/>        volume.beta.kubernetes.io/storage-class: "fast"<br/>    spec:<br/>      accessModes: [ "ReadWriteOnce" ]<br/>      resources:<br/>        requests:<br/>          storage: DB_DISK</span></pre><p id="77b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，通过kubectl应用资源~</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="b540" class="mk ki hi nb b fi ng nh l ni nj"><strong class="nb hj">sed -e "s/NAMESPACE_ID/daemonsl/g; s/DB_DISK/5Gi/g" </strong> mongodb-configdb-service-stateful.yaml &gt; tmp-mongodb-configdb-service-stateful.yaml<br/><strong class="nb hj">kubectl apply -f tmp-mongodb-configdb-service-stateful.yaml</strong></span></pre><h2 id="e891" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">3.2 Statefulset mainDB</h2><p id="5454" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">创建一个名为<code class="du my mz na nb b">mongodb-maindb-service-stateful.yaml</code>的文件，复制下面的模板。将<code class="du my mz na nb b">NAMESPACE_ID</code>替换为<code class="du my mz na nb b">daemonsl</code>或您定义的任何名称，将<code class="du my mz na nb b">DB_DISK</code>替换为<code class="du my mz na nb b">10Gi</code>，将<code class="du my mz na nb b">shardX</code> &amp; <code class="du my mz na nb b">ShardX</code>替换为<code class="du my mz na nb b">1</code>，然后将<code class="du my mz na nb b">2</code>应用两次模板，以创建两个不同的statefulsets配置。在kubernetes中部署之后，我们将运行两个名为<code class="du my mz na nb b">mongodb-shard1</code>和<code class="du my mz na nb b">mongodb-shard2</code>的状态集</p><p id="96d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们再次创建了headless服务和请求存储容量为10GB的storageclass <code class="du my mz na nb b">fast</code>的<code class="du my mz na nb b">VolumeClaimTemplates</code>。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="1537" class="mk ki hi nb b fi ng nh l ni nj">#mongodb-maindb-service-stateful.yaml<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongodb-shardX-headless-service<br/>  namespace: NAMESPACE_ID<br/>  labels:<br/>    name: mongodb-shardX<br/>spec:<br/>  ports:<br/>  - port: 27017<br/>    targetPort: 27017<br/>  clusterIP: None<br/>  selector:<br/>    role: mongodb-shardX<br/>---<br/>apiVersion: apps/v1beta2<br/>kind: StatefulSet<br/>metadata:<br/>  name: mongodb-shardX<br/>  namespace: NAMESPACE_ID<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      role: mongodb-shardX # has to match .spec.template.metadata.labels<br/>  serviceName: mongodb-shardX-headless-service<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        role: mongodb-shardX<br/>        tier: maindb<br/>        replicaset: ShardX<br/>    spec:<br/>      affinity:<br/>        podAntiAffinity:<br/>          preferredDuringSchedulingIgnoredDuringExecution:<br/>          - weight: 100<br/>            podAffinityTerm:<br/>              labelSelector:<br/>                matchExpressions:<br/>                - key: replicaset<br/>                  operator: In<br/>                  values:<br/>                  - ShardX<br/>              topologyKey: kubernetes.io/hostname<br/>      terminationGracePeriodSeconds: 10<br/>      containers:<br/>        - name: mongodb-shardX-container<br/>          image: mongo<br/>          command:<br/>            - "mongod"<br/>            - "--port"<br/>            - "27017"<br/>            - "--bind_ip"<br/>            - "0.0.0.0"<br/>            - "--replSet"<br/>            - "ShardX"<br/>            - "--dbpath"<br/>            - "/mongo-disk"<br/>          resources:<br/>            requests:<br/>              cpu: 50m<br/>              memory: 100Mi<br/>          ports:<br/>            - containerPort: 27017<br/>          volumeMounts:<br/>            - name: mongo-shardX-persistent-storage-claim<br/>              mountPath: /mongo-disk<br/>  volumeClaimTemplates:<br/>  - metadata:<br/>      name: mongo-shardX-persistent-storage-claim<br/>      annotations:<br/>        volume.beta.kubernetes.io/storage-class: "fast"<br/>    spec:<br/>      accessModes: [ "ReadWriteOnce" ]<br/>      resources:<br/>        requests:<br/>          storage: DB_DISK</span></pre><p id="f71d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过kubectl应用资源~</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="8c38" class="mk ki hi nb b fi ng nh l ni nj">#replace 'shardX' &amp; 'ShardX' with shard1 &amp; Shard1.<br/><strong class="nb hj">sed -e "s/shardX/shard1/g; s/ShardX/Shard1/g; s/NAMESPACE_ID/daemonsl/g; s/DB_DISK/10Gi/g"</strong> mongodb-maindb-service-stateful.yaml &gt; tmp-mongodb-maindb-service-stateful.yaml<br/><strong class="nb hj">kubectl apply -f tmp-mongodb-maindb-service-stateful.yaml</strong></span><span id="dd51" class="mk ki hi nb b fi nk nh l ni nj">#replace 'shardX' &amp; 'ShardX' with shard2 &amp; Shard2. <br/><strong class="nb hj">sed -e "s/shardX/shard2/g; s/ShardX/Shard2/g; s/NAMESPACE_ID/daemonsl/g; s/DB_DISK/10Gi/g"</strong> mongodb-maindb-service-stateful.yaml &gt; tmp-mongodb-maindb-service-stateful.yaml<br/><strong class="nb hj">kubectl apply -f tmp-mongodb-maindb-service-stateful.yaml</strong></span><span id="1ef4" class="mk ki hi nb b fi nk nh l ni nj">#run command to see Pods &amp; Services spinning up<br/>kubectl get svc,po --namespace=daemonsl</span></pre><p id="4652" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们已经完成了与headless服务一起运行的statefulsets容器，并安装了满足Pods要求的SSD卷。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="4bc3" class="mk ki hi nb b fi ng nh l ni nj">kubectl get persistentvolumes</span><span id="a824" class="mk ki hi nb b fi nk nh l ni nj"># Get persistent volume claims<br/>kubectl get persistentvolumeclaims --namespace=daemonsl</span></pre><h2 id="3c11" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">3.3 Mongos部署</h2><p id="5a14" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">我们已经启动并运行了configdb和maindb pods。我们将启动mongos服务器来建立一个分片集群。用<code class="du my mz na nb b">daemonsl</code>替换<code class="du my mz na nb b">NAMESPACE_ID</code>，或者任何你定义的名字。</p><p id="0f1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经使用带有configdb pod的唯一网络标识符的<code class="du my mz na nb b">--configdb</code>标志在mongos中配置了配置服务器信息。statefulset pods的DNS遵循惯例<code class="du my mz na nb b">&lt;POD_NAME&gt;.&lt;SERVICE_NAME&gt;.&lt;NAMESPACE&gt;.svc.&lt;CLUSTER_DOMAIN&gt;</code>。</p><p id="6807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考:</strong><a class="ae jn" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/stateful set/# stable-network-id</a></p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="6e5b" class="mk ki hi nb b fi ng nh l ni nj">apiVersion: apps/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: mongos<br/>  <strong class="nb hj">namespace</strong>: NAMESPACE_ID<br/>spec:<br/>  replicas: 2<br/>  template:<br/>    metadata:<br/>      labels:<br/>        role: mongos<br/>        tier: routers<br/>    spec:<br/>      affinity:<br/>        podAntiAffinity:<br/>          preferredDuringSchedulingIgnoredDuringExecution:<br/>          - weight: 100<br/>            podAffinityTerm:<br/>              labelSelector:<br/>                matchExpressions:<br/>                - key: tier<br/>                  operator: In<br/>                  values:<br/>                  - routers<br/>              topologyKey: kubernetes.io/hostname<br/>      terminationGracePeriodSeconds: 10<br/>      containers:<br/>        - name: mongos-container<br/>          image: mongo<br/>          command:<br/>            - "mongos"<br/>            - "--port"<br/>            - "27017"<br/>            - "--bind_ip"<br/>            - "0.0.0.0"<br/>            - "--configdb"<br/>            - "mongodb-configdb-0.mongodb-configdb-headless-service.daemonsl.svc.cluster.local:27019"<br/>          resources:<br/>            requests:<br/>              cpu: 50m<br/>              memory: 100Mi<br/>          ports:<br/>            - containerPort: 27017</span></pre><p id="b3ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过kubectl应用资源~</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="a202" class="mk ki hi nb b fi ng nh l ni nj"><strong class="nb hj">sed -e "s/NAMESPACE_ID/daemonsl/g"</strong> mongodb-mongos-deployment-service.yaml &gt; tmp-mongodb-mongos-deployment-service.yaml<br/><strong class="nb hj">kubectl apply -f tmp-mongodb-mongos-deployment-service.yaml</strong></span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="76d3" class="kh ki hi bd kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le bi translated">4.配置分片</h1><p id="40f7" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">现在，我们已经启动并运行了<code class="du my mz na nb b">mongos, configdb</code>和<code class="du my mz na nb b">maindb</code>。我们需要在MainDB服务器中创建Replicaset，我们打算将它做成shard。我们将运行<code class="du my mz na nb b">rs.initiate()</code>命令来制作<code class="du my mz na nb b">PRIMARY</code>副本。因为我们在每个碎片中都有一个副本成员。我们将在每个<code class="du my mz na nb b">maindb</code>舱中运行初始化命令。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="e6e6" class="mk ki hi nb b fi ng nh l ni nj"><strong class="nb hj">echo</strong> "Replicaset Init mongodb-shard1-0 "<br/><strong class="nb hj">kubectl exec</strong> --namespace=daemonsl mongodb-shard1-0 -c mongodb-shard1-container -- mongo --port 27017 --eval "rs.initiate({_id: \"Shard1\", version: 1, <strong class="nb hj">members: [ {_id: 0, host: \"mongodb-shard1-0.mongodb-shard1-headless-service.daemonsl.svc.cluster.local:27017\"} ]</strong> });"<br/></span><span id="d0ee" class="mk ki hi nb b fi nk nh l ni nj"><strong class="nb hj">echo</strong> "Replicaset Init mongodb-shard2-0 "  <br/><strong class="nb hj">kubectl exec</strong> --namespace=daemonsl mongodb-shard2-0 -c mongodb-shard2-container -- mongo --port 27017 --eval "rs.initiate({_id: <strong class="nb hj">\"</strong>Shard2<strong class="nb hj">\"</strong>, version: 1,<strong class="nb hj"> members: [ {_id: 0, host: \"mongodb-shard2-0.mongodb-shard2-headless-service.daemonsl.svc.cluster.local:27017\"} ]</strong> });"</span></pre><p id="4617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将使这两个pod成为各自复制集的主要。您甚至可以通过运行<code class="du my mz na nb b">rs.status()</code>命令进入容器来验证复制集的状态。</p><p id="dbe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在正在向mongos服务器添加碎片。我们将在任何一个mongos舱里听从指挥。Mongos服务器是无状态的应用程序，它们将配置保存在configdb服务器中，我们通过在statefulset容器下声明它们来使它们成为有状态的应用程序。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="72e0" class="mk ki hi nb b fi ng nh l ni nj"><strong class="nb hj">echo</strong> "Adding Shard 1 : Shard1 "<br/><strong class="nb hj">kubectl</strong> <strong class="nb hj">exec</strong> <strong class="nb hj">--namespace</strong>=<strong class="nb hj">daemonsl</strong> $(<strong class="nb hj">kubectl</strong> <strong class="nb hj">get</strong> <strong class="nb hj">pod</strong> <strong class="nb hj">-l</strong> "tier=routers" <strong class="nb hj">-o</strong> <strong class="nb hj">jsonpath</strong>='{.items[0].metadata.name}' <strong class="nb hj">--namespace</strong>=<strong class="nb hj">daemonsl</strong> ) <strong class="nb hj">-c</strong> <strong class="nb hj">mongos-container</strong> <strong class="nb hj">--</strong> <strong class="nb hj">mongo</strong> <strong class="nb hj">--port</strong> <strong class="nb hj">27017</strong> <strong class="nb hj">--eval</strong> "sh.addShard(\"Shard1/mongodb-shard1-0.mongodb-shard1-headless-service.daemonsl.svc.cluster.local:27017\");"</span><span id="16a1" class="mk ki hi nb b fi nk nh l ni nj"><strong class="nb hj">echo</strong> "Adding Shard 2 : Shard2 "<br/><strong class="nb hj">kubectl</strong> <strong class="nb hj">exec</strong> <strong class="nb hj">--namespace</strong>=<strong class="nb hj">daemonsl</strong> $(<strong class="nb hj">kubectl</strong> <strong class="nb hj">get</strong> <strong class="nb hj">pod</strong> <strong class="nb hj">-l</strong> "tier=routers" <strong class="nb hj">-o</strong> <strong class="nb hj">jsonpath</strong>='{.items[0].metadata.name}' <strong class="nb hj">--namespace</strong>=<strong class="nb hj">daemonsl</strong> ) <strong class="nb hj">-c</strong> <strong class="nb hj">mongos-container</strong> <strong class="nb hj">--</strong> <strong class="nb hj">mongo</strong> <strong class="nb hj">--port</strong> <strong class="nb hj">27017</strong> <strong class="nb hj">--eval</strong> "sh.addShard(\"Shard2/mongodb-shard2-0.mongodb-shard2-headless-service.daemonsl.svc.cluster.local:27017\");"</span></pre><p id="9965" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以进入一个mongos容器来验证集群的分片状态。上述所有步骤都可以自动在集群中创建任意数量的分片，因此支持由GKE支持的有状态应用程序的概念非常简单。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h2 id="db4b" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">测试分片</h2><p id="8dfb" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">要测试分片集群是否正常工作，请连接到运行第一个“mongos”路由器的容器，然后使用Mongo Shell进行身份验证，在特定数据库和集合上启用分片，向该集合添加一些测试数据，然后查看分片集群和集合的状态:</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="7ae0" class="mk ki hi nb b fi ng nh l ni nj">$ kubectl exec -it <strong class="nb hj">$(</strong>kubectl get pod -l "tier=routers" -o jsonpath='{.items[0].metadata.name}'<strong class="nb hj">)</strong> -c mongos-container bash<br/>$ mongo<br/>&gt; sh.enableSharding("&lt;Database_name&gt;");<br/>&gt; sh.status();<br/>&gt; use admin<br/>&gt; db.admin.runCommand("getShardMap")</span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h2 id="6fa8" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">摧毁和清理库伯内特的环境</h2><p id="bf87" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated"><strong class="ih hj">重要提示:</strong>这一步是必需的，以确保您不会因为不再需要的环境而被Google Cloud持续收费。</p><p id="ae39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下脚本来取消部署MongoDB服务&amp; StatefulSets/Deployments以及相关的Kubernetes资源，然后删除GCE磁盘。该脚本可从存储库中获得。</p><pre class="jp jq jr js fd nc nb nd ne aw nf bi"><span id="12d1" class="mk ki hi nb b fi ng nh l ni nj">$ sh teardown.sh   <em class="jd">#To delete all resources provisioned above</em></span></pre></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="27de" class="kh ki hi bd kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le bi translated">本演示中涉及的因素</h1><ul class=""><li id="d16c" class="lq lr hi ih b ii lf im lg iq nl iu nm iy nn jc mj lw lx ly bi translated">在Google Kubernetes引擎上部署MongoDB</li><li id="9a4a" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated">使用Kubernetes StatefulSets和PersistentVolumeClaims来确保回收容器时数据不会丢失</li><li id="4f2c" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated">正确配置MongoDB分片集群以实现可伸缩性，每个分片都是副本集以实现完全弹性</li><li id="c231" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated">控制Mongod副本的反关联性以避免单点故障</li></ul></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="b2a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Github参考</strong>:<a class="ae jn" href="https://github.com/sunnykrGupta/gke-mongodb-shards" rel="noopener ugc nofollow" target="_blank">https://github.com/sunnykrGupta/gke-mongodb-shards</a></p><p id="eafd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">鸣谢:</strong>本博客基于<a class="ae jn" href="https://twitter.com/TheDonester" rel="noopener ugc nofollow" target="_blank">保罗·多恩</a>的作品</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h2 id="9607" class="mk ki hi bd kj ml mm mn kn mo mp mq kr iq mr ms kv iu mt mu kz iy mv mw ld mx bi translated">必须按顺序阅读以下资源:</h2><ul class=""><li id="6d72" class="lq lr hi ih b ii lf im lg iq nl iu nm iy nn jc mj lw lx ly bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/stateful set</a></li><li id="8c6d" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/services-networking/service/# headless-services</a></li><li id="3774" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/stateful set/# stable-network-id</a></li><li id="9af8" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/storage/storage-classes/#gce" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/storage/storage-classes/# GCE</a></li><li id="54e0" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated"><a class="ae jn" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/storage/persistent-volumes/</a></li><li id="6734" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated"><a class="ae jn" href="http://blog.kubernetes.io/2017/03/dynamic-provisioning-and-storage-classes-kubernetes.html" rel="noopener ugc nofollow" target="_blank">http://blog . kubernetes . io/2017/03/dynamic-provisioning-and-storage-classes-kubernetes . html</a></li><li id="79fa" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mj lw lx ly bi translated"><a class="ae jn" href="http://blog.kubernetes.io/2017/03/advanced-scheduling-in-kubernetes.html" rel="noopener ugc nofollow" target="_blank">http://blog . kubernetes . io/2017/03/advanced-scheduling-in-kubernetes . html</a></li></ul></div></div>    
</body>
</html>