<html>
<head>
<title>Implement a Semaphore using Google Cloud Spanner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google Cloud Spanner实现信号量</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/implement-a-semaphore-using-google-cloud-spanner-b229ca3d1de5?source=collection_archive---------0-----------------------#2022-05-01">https://medium.com/google-cloud/implement-a-semaphore-using-google-cloud-spanner-b229ca3d1de5?source=collection_archive---------0-----------------------#2022-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/22018368e4e3cd6f987d5e2c6201a3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkGN78a3aoRHHQNumePRMw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com/s/photos/train-signal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@dylanveasey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迪伦·维塞</a>的旗语照片</figcaption></figure><p id="59d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于某些工作负载，您必须考虑如果云区域“停止运行”会发生什么。有各种可能导致这种情况的错误场景。当你有一个无状态的API工作负载时，你通常可以决定在多个地区托管你的应用，并使用谷歌云的全球<a class="ae iu" href="https://cloud.google.com/load-balancing" rel="noopener ugc nofollow" target="_blank">云负载平衡</a>来引导流量。但是当您有消息处理工作负载时，这可能更具挑战性。尤其是当您必须考虑跨多个地区订购或一次性处理保证时。在这种情况下，您可能希望只有一个处理器实例处理一个数据分区。</p><p id="c13b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用分布式信号量或锁可能很有用。另一种选择可能是采用共识算法，如<a class="ae iu" href="https://en.wikipedia.org/wiki/Raft_(algorithm)" rel="noopener ugc nofollow" target="_blank"> Raft </a>或<a class="ae iu" href="https://en.wikipedia.org/wiki/Paxos_(computer_science)" rel="noopener ugc nofollow" target="_blank"> Paxos </a>。总的想法是，我们有一个简单的机制来通知哪个处理器实例当前应该处理消息，信号量是一个简单的解决方案。当然还有像<a class="ae iu" href="https://dzone.com/articles/distributed-lock-using" rel="noopener ugc nofollow" target="_blank"> Zookeeper </a>或<a class="ae iu" href="https://github.com/etcd-io/etcd/blob/main/etcdctl/README.md#lock-options-lockname-command-arg1-arg2-" rel="noopener ugc nofollow" target="_blank"> Etcd </a>这样的工具提供分布式锁。甚至Cassandra也使用<a class="ae iu" href="https://www.datastax.com/blog/lightweight-transactions-cassandra-20" rel="noopener ugc nofollow" target="_blank">轻量级事务</a>来提供领导者选举。这类工具的挑战通常是你需要考虑在3个区域托管，以保证法定人数，并避免在<a class="ae iu" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" rel="noopener ugc nofollow" target="_blank">网络分区</a>的情况下分裂大脑。</p><p id="2632" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我个人尽量避免托管基础设施服务，因为我想专注于为客户创造价值的代码。因此，我试图找到一个解决方案，如何在谷歌云中创建信号量，这将在多个地区工作。Google Cloud的一般策略是区域性地托管大多数服务，以限制错误域，只有少数例外。其中一个例外是<a class="ae iu" href="https://cloud.google.com/spanner" rel="noopener ugc nofollow" target="_blank"> Google Cloud Spanner </a>，这是一个全球性的、符合ACID的、高可用性的数据库服务。它通过<a class="ae iu" href="https://cloud.google.com/spanner/docs/true-time-external-consistency#external_consistency" rel="noopener ugc nofollow" target="_blank">外部一致性</a>提供多区域甚至全球可用性。</p><p id="dfdd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着我们可以用它来创建我们的信号量。想法是，我们将依赖两个SQL查询和一个简单的表布局</p><p id="f7b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个表有3列，<code class="du jt ju jv jw b">anchor</code>我们信号量的Id，<code class="du jt ju jv jw b">service_id</code>持有信号量的当前领导者的名字，<code class="du jt ju jv jw b">last_seen</code>领导者最后一次更新信号量行的时间戳。</p><p id="1e55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个查询由系统中的每个服务定期执行。它会尝试在我们的<code class="du jt ju jv jw b">LeaderElection</code>中更新首领的<code class="du jt ju jv jw b">service_id</code>和<code class="du jt ju jv jw b">last_seen_active</code>。这些字段只能由当前作为领导者的服务来更新，或者如果自从任何服务上次更新领导者以来达到了超时。Cloud Spanner的强大一致性，将确保所有服务接收到相同的<code class="du jt ju jv jw b">service_id</code>提供给所有服务。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="aa8b" class="kf kg hi jw b fi kh ki l kj kk">UPDATE LeaderElection <br/>SET service_id = @serviceId, last_seen_active = CURRENT_TIMESTAMP()<br/>WHERE anchor = 1 <br/>AND ( (service_id != @serviceId AND last_seen_active &lt; TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL @timeout SECOND) )<br/>OR (service_id = @serviceId))</span></pre><p id="7bc8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个查询允许我们查询当前的领导者。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0270" class="kf kg hi jw b fi kh ki l kj kk">SELECT service_id, last_seen_active <br/>FROM LeaderElection <br/>WHERE anchor = 1 <br/>AND last_seen_active &gt;= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL @timeout SECOND)</span></pre><p id="d96b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这个简单的设置，我们可以依靠Spanner为我们提供一致可靠的信号量。下面是一个完整的例子，用Go写的:</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用Go编写的带云扳手的信号量</figcaption></figure><p id="a844" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该工具提供三种模式:</p><ol class=""><li id="4f0c" class="kn ko hi ix b iy iz jc jd jg kp jk kq jo kr js ks kt ku kv bi translated">用<code class="du jt ju jv jw b">go run main.go init projects/&lt;project_id&gt;/instances/&lt;spanner_instance&gt;/databases/&lt;db&gt;</code>初始化数据库</li><li id="2a69" class="kn ko hi ix b iy kw jc kx jg ky jk kz jo la js ks kt ku kv bi translated">用<code class="du jt ju jv jw b">go run main.go participate projects/&lt;project_id&gt;/instances/&lt;spanner_instance&gt;/databases/&lt;db&gt; &lt;service_id&gt;</code>参与信号量这将尝试每秒更新一次信号量</li><li id="8d06" class="kn ko hi ix b iy kw jc kx jg ky jk kz jo la js ks kt ku kv bi translated">获取持有信号量的当前领导者<code class="du jt ju jv jw b">go run main.go get projects/&lt;project_id&gt;/instances/&lt;spanner_instance&gt;/databases/&lt;db&gt;</code></li></ol><p id="d3da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以简单地在同一台机器的多个shell实例中运行命令2和3，看看信号量是如何变化的。</p><p id="edfc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使其正常工作，超时时间应该至少是服务尝试更新信号量时间的两倍。(如果你想知道为什么:<a class="ae iu" href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem" rel="noopener ugc nofollow" target="_blank">奈奎斯特-香农采样定理</a>)</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/eabc5284ef28fbc87eaa1f33a3c73834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*rFKeTKlUERMNkdo5pRXzNw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">示例中的控制台输出示例</figcaption></figure><p id="5315" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这为我们提供了一种简单而可靠的方法来拥有一个分布式信号量，而不需要我们自己在多个区域托管基础设施。</p></div></div>    
</body>
</html>