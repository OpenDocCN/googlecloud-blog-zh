<html>
<head>
<title>Helm Chart for Fabric (for Kubernetes)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">织物舵图(适用于Kubernetes)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/helm-chart-for-fabric-for-kubernetes-80408b9a3fb6?source=collection_archive---------2-----------------------#2018-08-31">https://medium.com/google-cloud/helm-chart-for-fabric-for-kubernetes-80408b9a3fb6?source=collection_archive---------2-----------------------#2018-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="47d5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">失败-成功</h2></div><p id="87e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在尝试为Hyperledger Fabric(用于Kubernetes)创建舵图部署时令人失望的失败总结。这一系列短篇故事的目的是记录成就，描述局限性，并且——希望——提供一个连贯的工作总结，作为该项目的文档。</p><p id="f585" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然跨多个主机部署Fabric很复杂，但我认为我所面临的大部分挑战是试图将Fabric塞进一个舵图中；我想我在赫尔姆更有挑战性。我非常感谢IBM的雅科夫和加里，他们在面料方面耐心而有益的指导。谢谢你们俩！</p><h2 id="a1f3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">该建议</h2><p id="578d" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我(强烈)认为Hyperledger Fabric项目应该致力于为Fabric开发一个工作舵图解决方案。Fabric是一个复杂的解决方案，在其频繁的发布之间会有很大的变化。核心开发团队最了解如何配置和部署解决方案，并且最能够使部署解决方案与核心产品保持同步。</p><p id="52fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于Helm已经成为Kubernetes应用程序的事实上的部署工具，我认为Fabric团队最适合确定Helm的限制并|或调整Fabric以适应这些限制。</p><h2 id="2059" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">成功</h2><p id="924c" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">很管用；-)</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/19f4d4fba2d848212af4bfd77176a18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fdAbTAdlNCrOVW8AlGdpA.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">2个双对等组织</figcaption></figure><p id="270b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="b140" class="jt ju hi lk b fi lo lp l lq lr">peer chaincode query \<br/>--channelID=${CHANNEL_NAME} \<br/>--name=${NAME} \<br/>--ctor='{"Args":[<strong class="lk hj">"query","a"</strong>]}'<br/><strong class="lk hj">100</strong></span><span id="fc9a" class="jt ju hi lk b fi ls lp l lq lr">peer chaincode invoke \<br/>--orderer=${RELEASE_NAME}-hyperledger-fabric-orderer:7050 \<br/>--cafile=/.../example.com/orderers/orderer.example.com/... \<br/>--channelID=${CHANNEL_NAME} \<br/>--name=${NAME} \<br/>--ctor='{"Args":[<strong class="lk hj">"invoke","a","b","10"</strong>]}'<br/>2018-08-31 22:58:56.724 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 </span><span id="63d2" class="jt ju hi lk b fi ls lp l lq lr">peer chaincode query \<br/>--channelID=${CHANNEL_NAME} \<br/>--name=${NAME} \<br/>--ctor='{"Args":[<strong class="lk hj">"query","a"</strong>]}'<br/><strong class="lk hj">90</strong></span></pre><h2 id="820f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">突出的问题</h2><p id="4484" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">不幸的是，要让链代码实例化工作需要人工干预:-(</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="1ece" class="jt ju hi lk b fi lo lp l lq lr">peer chaincode list --channelID=${CHANNEL_NAME} --installed<br/>Get installed chaincodes on peer:<br/><strong class="lk hj">Name: duvall, Version: 1.0</strong>, Path: github.com/chaincode/example02/go/, Id: 4ed73815477c6da1a5e8fba4ff00d77cc740e12b2dd001246de4a53e0dc08c03</span></pre><p id="ab9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实例化链代码，对等体使用docker-in-docker创建链代码部署的docker映像，然后实例化它:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="4f21" class="jt ju hi lk b fi lo lp l lq lr">docker images --format="{{.Repository}}" | awk '!/gcr.io/'</span><span id="9bc6" class="jt ju hi lk b fi ls lp l lq lr">dev-org1-peer0-duvall-1.0-2c49d7...</span></pre><blockquote class="lt lu lv"><p id="177e" class="ix iy lw iz b ja jb ij jc jd je im jf lx jh ji jj ly jl jm jn lz jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>镜像名称由网络名称(<code class="du ma mb mc lk b">dev</code>)、对等名称(<code class="du ma mb mc lk b">org1-peer0</code>)、链代码名称(<code class="du ma mb mc lk b">duvall</code>)和版本(<code class="du ma mb mc lk b">1.0</code>)组成</p></blockquote><p id="d2dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过监视此映像的Docker事件，我们可以检测到容器是何时从映像创建的，以及容器是何时启动的:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="226a" class="jt ju hi lk b fi lo lp l lq lr">docker events --filter=name=dev-org1-peer0-duvall-1.0-2c49d7...</span></pre><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="0002" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:事件输出包括长容器ID ( <code class="du ma mb mc lk b">3e1b22…</code>)</p><p id="615a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在容器死亡之前，我们可以拿到它的日志:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="5d7b" class="jt ju hi lk b fi lo lp l lq lr">docker logs 3e1b22...</span></pre><p id="26bd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这产生了:</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="aa54" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出现这个问题是因为容器是在Docker引擎的上下文中运行的，而不是在Kubernetes中。因为Docker引擎无法寻址对等体，所以回叫对等体的尝试失败。</p><h2 id="ae95" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">黑客#1:编辑节点的主机文件</h2><p id="e434" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">该同事在<code class="du ma mb mc lk b">10.121.1.224</code>可用于此次部署:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mf"><img src="../Images/22b5cf88eac0a317b7d2f3e038032575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*uMKZ7PqdrZwosS4pmi5d6A.png"/></div></figure><blockquote class="lt lu lv"><p id="c0ee" class="ix iy lw iz b ja jb ij jc jd je im jf lx jh ji jj ly jl jm jn lz jp jq jr js hb bi translated">该地址对应于代表对等体的Kubernetes服务的集群IP地址。</p></blockquote><p id="9ffb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正在编辑节点的(！)<code class="du ma mb mc lk b">/etc/hosts</code>允许Docker引擎正确寻址对等体:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="1543" class="jt ju hi lk b fi lo lp l lq lr">more /etc/hosts<br/>127.0.0.1 localhost<br/>::1  localhost</span><span id="2e5c" class="jt ju hi lk b fi ls lp l lq lr">169.254.169.254 metadata.google.internal metadata<br/><strong class="lk hj">10.121.1.224 x-hyperledger-fabric-org1-peer0</strong></span></pre><p id="e866" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我们重新运行实例化，它将工作:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="8470" class="jt ju hi lk b fi lo lp l lq lr">peer chaincode list --channelID=$CHANNEL_NAME --instantiated<br/>Get instantiated chaincodes on channel channel:<br/>Name: duvall, Version: 1.0, Path: github.com/chaincode/example02/go/, Escc: escc, Vscc: vscc</span></pre><p id="0ea5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，我们可以使用容器的日志来验证:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="6453" class="jt ju hi lk b fi lo lp l lq lr">docker logs 7e1a1e40e68b78653eb85103d0af03502820147ded1fa9288f70bf796b87ee37<br/>2018-08-31 21:52:43.825 UTC [shim] SetupChaincodeLogging -&gt; INFO 001 Chaincode (build level: 1.2.0) starting up ...<br/>ex02 Init<br/><strong class="lk hj">Aval = 100, Bval = 200</strong></span></pre><p id="1a3c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不清楚如何最好地适当、动态地确保每个节点(复数)Docker引擎能够正确地引用当时可能正在其上运行的对等节点(复数)。</p><p id="48cb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦实例化，为了调用链代码上的方法，对等体需要能够访问订购者:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="c0a6" class="jt ju hi lk b fi lo lp l lq lr">peer chaincode query \<br/>--channelID=${CHANNEL_NAME} \<br/>--name=${NAME} \<br/>--ctor='{"Args":["query","a"]}'<br/><strong class="lk hj">100</strong></span><span id="b1eb" class="jt ju hi lk b fi ls lp l lq lr">peer chaincode invoke \<br/>--orderer=${RELEASE_NAME}-hyperledger-fabric-orderer:7050 \<br/>--cafile=/.../example.com/orderers/orderer.example.com/... \<br/>--channelID=${CHANNEL_NAME} \<br/>--name=${NAME} \<br/>--ctor='{"Args":<strong class="lk hj">["invoke","a","b","10"]</strong>}'<br/>2018-08-31 22:58:56.724 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 </span><span id="87f5" class="jt ju hi lk b fi ls lp l lq lr">peer chaincode query \<br/>--channelID=${CHANNEL_NAME} \<br/>--name=${NAME} \<br/>--ctor='{"Args":["query","a"]}'<br/><strong class="lk hj">90</strong></span></pre><p id="092d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">容器的日志:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="b853" class="jt ju hi lk b fi lo lp l lq lr">docker logs 7e1a1e...<br/>2018-08-31 21:52:43.825 UTC [shim] SetupChaincodeLogging -&gt; INFO 001 Chaincode (build level: 1.2.0) starting up ...<br/>ex02 Init<br/>Aval = <strong class="lk hj">100</strong>, Bval = 200<br/>ex02 Invoke<br/>Query Response:{<strong class="lk hj">"Name":"a","Amount":"100"</strong>}<br/>ex02 Invoke<br/>Aval = <strong class="lk hj">90</strong>, Bval = 210<br/>ex02 Invoke<br/>Query Response:{<strong class="lk hj">"Name":"a","Amount":"90"</strong>}</span></pre><p id="1d0d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一切都好。</p><h2 id="531d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">黑客# 2:orderer.example.com</h2><p id="0076" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">只不过它需要第二次破解。</p><p id="c474" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个问题是为网络定义的命名的结果，用<code class="du ma mb mc lk b">crypto-config.yaml</code>和<code class="du ma mb mc lk b">configtx.yaml</code>以及在集群中适当反映这一点的(我的)复杂性来表示。</p><p id="913e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当(我的)掌舵图导致订购方的服务可用，例如<code class="du ma mb mc lk b">x-hyperledger-fabric-orderer</code> ( <code class="du ma mb mc lk b">[release-name]-[chart-name]-orderer</code>)或完全合格的<code class="du ma mb mc lk b">x-hyperledger-fabric-orderer.andromeda.svc.cluster.local</code>时，同级如何正确称呼订购方？</p><p id="50e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个hacky解决方案采用<a class="ae mg" href="https://coredns.io/" rel="noopener ugc nofollow" target="_blank"> CoreDNS </a>来提供<code class="du ma mb mc lk b">example.com</code>作为<a class="ae mg" href="https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#configure-stub-domain-and-upstream-dns-servers" rel="noopener ugc nofollow" target="_blank">存根域</a>(补充Kubernetes的集群上DNS解析)。我的解决方案是过度设计的(见下面的替代方案)，但它为我提供了一个学习和使用CoreDNS以及与Kubernetes结合使用的机会。所以良好的学习体验和CoreDNS是一个甜蜜的产物。</p><p id="0ded" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种模式下，一个对等体试图解析<code class="du ma mb mc lk b">orderer.example.com</code>的请求被发送到CoreDNS，CoreDNS由Kubernetes服务列表编程，以将<code class="du ma mb mc lk b">orderer</code>解析到正确的IP地址。</p><p id="b9ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在这里记录了这种方法<a class="ae mg" rel="noopener" href="/google-cloud/coredns-afaa732aa35e">并且不会重复它。</a></p><p id="0ff1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个(也更容易)的解决方案是使用Kubernetes的<code class="du ma mb mc lk b">hostAliases</code> ( <a class="ae mg" href="https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/#adding-additional-entries-with-hostaliases" rel="noopener ugc nofollow" target="_blank"> link </a>)。这些被定义为kubelet(？)编程Pod(不是节点的)<code class="du ma mb mc lk b">/etc/hosts</code>文件。</p><p id="b16f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个清单示例:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="97a0" class="jt ju hi lk b fi lo lp l lq lr">hostAliases:<br/>- ip: "10.121.11.131"<br/>  hostnames:<br/>  - "orderer.example.com"</span></pre><p id="3187" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是Pod的<code class="du ma mb mc lk b">/etc/hosts</code>:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="f7fa" class="jt ju hi lk b fi lo lp l lq lr">more /etc/hosts<br/># Kubernetes-managed hosts file.<br/>127.0.0.1 localhost<br/>::1 localhost ip6-localhost ip6-loopback<br/>fe00::0 ip6-localnet<br/>fe00::0 ip6-mcastprefix<br/>fe00::1 ip6-allnodes<br/>fe00::2 ip6-allrouters<br/>10.56.0.9 x-hyperledger-fabric-org1-peer0-85874fd45c-nvrdc</span><span id="fd64" class="jt ju hi lk b fi ls lp l lq lr"># Entries added by HostAliases.<br/><strong class="lk hj">10.121.11.131 orderer.example.com</strong></span></pre><blockquote class="lt lu lv"><p id="2f90" class="ix iy lw iz b ja jb ij jc jd je im jf lx jh ji jj ly jl jm jn lz jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>增加了<code class="du ma mb mc lk b">orderer.example.com</code>和一个有用的系统提供的注释，解释它为什么在那里。</p></blockquote><p id="a691" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种方法中，对等体需要配置订购者的IP，我需要使用Helm ( <code class="du ma mb mc lk b">;-(</code>)来解决这个问题。</p><h2 id="45ba" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">实施</h2><p id="fa3c" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">下周初，我将简要总结我的编程笔记，并在这里引用这些笔记。希望我的旅程总结能给其他人提供一些指导，让他们知道如何前进和避免陷阱。希望我的错误能从其他人那里得到反馈，帮助我提高和克服我所面临的一些挑战。</p><h2 id="746c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结论</h2><p id="549b" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我将这个故事的副标题定为“失败-成功”,因为虽然我能够将Fabric部署到Kubernetes集群，但我无法开发一个掌舵图来(a)支持我想要的动态性；(b)提供了端到端的工作部署。</p><p id="97ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我的经理正确解释的那样，最好是快速失败，虽然我无法完成这个项目令人失望，但希望这个和相关的故事能帮助其他人，也许它能在Fabric项目中找到共识，为Fabric开发一个掌舵图(或其他Kubernetes部署)。</p><p id="2c4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">暂时就这样了。</p></div></div>    
</body>
</html>