<html>
<head>
<title>Impossible read and write isolation phenomena with Cloud Spanner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云扳手不可能出现读写隔离现象</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/impossible-read-and-write-isolation-phenomena-with-cloud-spanner-8aee06bb6e70?source=collection_archive---------0-----------------------#2019-02-20">https://medium.com/google-cloud/impossible-read-and-write-isolation-phenomena-with-cloud-spanner-8aee06bb6e70?source=collection_archive---------0-----------------------#2019-02-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f1d8cfbf9f7573fea84b1e4c0ed07f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*8jNIWEgs-v8ELuwWroYRsQ.png"/></div></figure><h1 id="3985" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="4b49" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Cloud Spanner通过<a class="ae ki" href="https://cloud.google.com/spanner/docs/true-time-external-consistency#external_consistency" rel="noopener ugc nofollow" target="_blank">外部一致性</a>提供最严格的并发控制。这保证了多个事务同时运行，而没有不一致的可能性。</p><p id="92c1" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在本文中，我将演示以下6种事务隔离现象是如何在Cloud Spanner中不被允许的。</p><ol class=""><li id="7a3b" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated">脏读</li><li id="3e59" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">丢失的更新</li><li id="baa9" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">不可重复读取</li><li id="3dda" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">幻像读取</li><li id="2907" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">读取偏斜</li><li id="9626" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">写入偏斜</li></ol><h1 id="86ce" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">测试工具</h1><p id="255c" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我们将使用名为<a class="ae ki" href="https://github.com/yfuruyama/spanner-cli" rel="noopener ugc nofollow" target="_blank">的交互式CLI工具spanner-cli </a>来运行多个事务。使用spanner-cli，我们可以交互式地运行任意SQL语句，类似于使用mysql命令。</p><p id="6a1d" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">你可以在https://github.com/yfuruyama/spanner-cli<a class="ae ki" href="https://github.com/yfuruyama/spanner-cli" rel="noopener ugc nofollow" target="_blank">的GitHub上找到源代码</a></p><div class="lc ld ez fb le lf"><a href="https://github.com/yfuruyama/spanner-cli" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">yfuruyama/spanner-cli</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">扳手-cli，云扳手命令行界面。- yfuruyama/spanner-cli</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt ik lf"/></div></div></a></div><ol class=""><li id="7d19" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated">为我们的测试准备数据库:</li></ol><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="eb2c" class="md in hi lz b fi me mf l mg mh">$ spanner-cli -p $PROJECT -i $INSTANCE -d $DATABASE</span></pre><p id="f9e1" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">2.在您的CLI会话中复制并粘贴以下DML和DDL。</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="0c73" class="md in hi lz b fi me mf l mg mh">CREATE TABLE Accounts (<br/>  UserId INT64 NOT NULL,<br/>  Balance INT64 NOT NULL,<br/>  Type STRING(16) NOT NULL<br/>) PRIMARY KEY (UserId);<br/> <br/>CREATE TABLE Counters (<br/>  Id INT64 NOT NULL,<br/>  Value Int64 NOT NULL<br/>) PRIMARY KEY (Id);<br/>  <br/>INSERT INTO Accounts (UserId, Balance, Type) VALUES (1, 1000, 'Checking'), (2, 1000, 'Checking'), (3, 1000, 'Checking');</span><span id="af0d" class="md in hi lz b fi mi mf l mg mh">INSERT INTO Counters (Id, Value) VALUES (1, 0);</span></pre><p id="2bda" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们打开两个终端控制台，用spanner-cli连接到我们的云Spanner数据库。</p><h1 id="3d5e" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">1.脏读</h1><p id="3756" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">首先，我们将演示在Cloud Spanner中不允许脏读。脏读发生在一个事务可以读取正在被另一个事务修改的未提交记录的情况下。这可能发生在允许READ UNCOMMITTED隔离级别的关系数据库中。</p><p id="1325" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在下面的例子中，我们展示了当tx1将<em class="mj">余额</em>更改为2000时，tx2只能读取原始值1000，直到tx1提交。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/35d8178fe5e03f149d0b23d77b0ae444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYWzeWJ1StiDeDP9nNfOYQ.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/1d24d503ab0dfa1f16e0c2e62a479c4e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/1d 24d 503 ab 0 DFA 1 f 16 E0 C2 e 62 a 479 c4e</a></figcaption></figure><p id="fd15" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在Cloud Spanner中，使用DML(插入/更新/删除)语句执行的所有突变都在服务器端进行<a class="ae ki" href="https://cloud.google.com/spanner/docs/dml-best-practices#dml-and-mutation" rel="noopener ugc nofollow" target="_blank">缓冲，这些突变不会应用于记录，除非它们被提交。</a></p><h1 id="6cce" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">2.丢失的更新</h1><p id="c0dd" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">更新丢失描述了一个事务中的修改被另一个事务覆盖的情况，这导致原始修改消失。</p><p id="dd5a" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们以递增计数器为例。</p><ol class=""><li id="c779" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated">获取计数器的<em class="mj">当前值</em></li><li id="76af" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">用<em class="mj">当前值+ 1 </em>更新计数器</li></ol><p id="5c30" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">如果两个事务相继执行上述操作，我们预计最终结果为<em class="mj"> old_counter_value </em> +2。然而，如果操作#1在两个事务中同时发生，并且两个事务都成功提交，则最终结果将是<em class="mj"> old_counter_value </em> +1，因为最后提交的事务获胜。</p><p id="3c6e" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们检查丢失的更新不会发生在云扳手。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mt"><img src="../Images/d633fdc9dc8dac36fec9f12d9de4ab6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AcZWwfJfQPKp-VFMMOzivw.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/a2fef5cfabf7f94b8c4869943783242d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/a2 Fe F5 CFA BF 7 f 94 b 8 c 4869943783242d</a></figcaption></figure><p id="ea34" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">您可以看到tx1能够成功提交，但是tx2在提交时被中止。这是因为此时调用了名为<a class="ae ki" href="https://stackoverflow.com/questions/32794142/what-is-the-difference-between-wait-die-and-wound-wait" rel="noopener ugc nofollow" target="_blank">wind-wait</a>的死锁预防机制，该机制中止了较新的事务，并让较旧的事务成功。</p><p id="ed7e" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在读写事务期间，Cloud Spanner试图获取要读取的记录上的共享读锁，并试图在更新(写入)期间获取记录上的独占锁。为了获得该记录的排他锁，不允许任何其他事务持有共享锁。如果一个事务已经获得了记录上的共享锁，而另一个事务需要同一记录上的独占锁，则Cloud Spanner会比较事务时间戳并中止较新的事务，以将独占锁授予较旧的事务。</p><p id="33be" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在上面的示例中，虽然tx1和tx2都有一个记录上的共享锁，但是由于tx1已经在之前运行了SELECT语句(在获取事务年龄时间戳的时候)，Cloud Spanner中止tx2以获取tx1的独占锁。</p><p id="8a32" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在一些RDBMS中，比如MySQL，通常通过用<a class="ae ki" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html" rel="noopener ugc nofollow" target="_blank">锁读</a> ( <em class="mj"> SELECT FOR UPDATE </em>)显式锁定记录来防止更新丢失。</p><p id="00c6" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">注意:中止的事务会在所有Google维护的客户端库中自动重试(例如<a class="ae ki" href="https://godoc.org/cloud.google.com/go/spanner#hdr-Aborted_transactions" rel="noopener ugc nofollow" target="_blank"> Go客户端</a>。如果在Cloud Spanner事务中进行非Spanner操作，让整个函数幂等以确保不会出现副作用是一个很好的实践。</p><h1 id="f619" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">3.不可重复读取</h1><p id="3fc8" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">当在一个事务中对同一条记录的重复读取导致从数据库返回不同的值时，就会发生不可重复读取。这可能发生在允许READ COMMITTED隔离级别的关系数据库中。</p><p id="37f6" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们检查一下在Cloud Spanner中不可重复的读取不会发生。在本演示中，tx1尝试多次读取记录，tx2在多次读取过程中向记录写入新值。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mu"><img src="../Images/8e0330fd824ff18aa0543705ecd2e899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nH2bCxIf2oBIDpCS"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/3a5668cc1322dc5ed2f1ee5f59d07dcd" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/3a 5668 cc 1322 DC 5 ed 2 f1 ee 5 f 59d 07 DCD</a></figcaption></figure><p id="f687" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">在上面的场景中，由于tx1在tx2获得排他锁之前已经获得了记录上的共享锁，所以tx2必须等待获得排他锁，直到tx1释放共享锁。因此，tx2一直被阻塞，直到tx1提交或中止事务。</p><p id="59a6" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">这就是<a class="ae ki" href="https://cloud.google.com/spanner/docs/transactions#read-only_transactions" rel="noopener ugc nofollow" target="_blank">只读事务</a>发挥作用的地方。在只读事务中，只允许使用SELECT语句，这些语句不会阻塞读写事务，因为它们不获取任何锁。</p><p id="a7a3" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们看看如果tx1使用只读事务会发生什么。您可以使用BEGIN RO语句在spanner-cli中运行只读事务。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mv"><img src="../Images/728b3ab3bba5932c4768f2a91ca326a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBP5jxlsDCZ_GoqIQmenFQ.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/2ec4e05c7ed54aae787cbbc52fdd8271" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/2 EC 4 e 05 c 7 ed 54 aae 787 cbbc 52 FDD 8271</a></figcaption></figure><p id="47dc" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">如您所见，tx1在tx2更新记录之前和之后都读取了相同的值。没有发生不可重复的读取。</p><p id="cf64" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">只读事务通过第一个SELECT语句的执行时间戳获得一致的数据库视图。所有后续查询都将在事务时间戳读取数据。这是通过<a class="ae ki" href="https://cloud.google.com/spanner/docs/true-time-external-consistency" rel="noopener ugc nofollow" target="_blank"> TrueTime </a>和Cloud Spanner使用仅附加存储实现的，这允许对过去进行一致的查看。</p><h1 id="af29" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">4.幻像读取</h1><p id="1f60" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">幻像读取描述了当另一个事务插入符合读取查询的新记录时，事务中重复读取的结果集发生变化的情况。</p><p id="5972" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">假设有三条记录(<em class="mj"> UserID=1~3) </em>，一个事务正在重复执行查询SELECT * FROM Accounts，其中UserID&gt;= 1&amp;&amp;UserID&lt;= 10。在这种情况下，如果另一个事务插入一个新记录(<em class="mj"> UserId=4) </em>，它将导致第一个事务读取一个新的<em class="mj">幻影</em>记录。</p><p id="c327" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们看看云扳手是如何不允许幻影读取的。首先，让我们看看如果使用读写事务会发生什么。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mw"><img src="../Images/3870d8adecc501b5443770119cc71898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfFcpFQik5L1TiV3ipx9fQ.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/cba2b942c89fc00d228511a01d3336d1" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/CBA 2b 942 c 89 fc00 d 228511 a 01d 3336d 1</a></figcaption></figure><p id="43d7" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">与不可重复读取的情况类似，tx2在提交时阻塞。这表明不仅满足WHERE条件的<em class="mj"> UserID=1~3 </em>之间的记录，而且<em class="mj"> UserId=4~10 </em>之间的记录都包含在共享锁中。这类似于MySQL中的<a class="ae ki" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks" rel="noopener ugc nofollow" target="_blank">间隙锁</a>机制。</p><p id="c316" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">如果tx1使用只读事务，tx2可以成功提交，并且tx1中不会发生幻像读取。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mx"><img src="../Images/8016e1c26a69e668709f9a48808298ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89voa0rIUSVTGIsd4kbTWQ.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/3ac84e0c5d2a3a7a02cf8738b24e35ca" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/3 AC 84 E0 C5 D2 a3 a 7 a 02 cf 8738 b 24 e 35 ca</a></figcaption></figure><h1 id="3092" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">5.读取偏斜</h1><p id="382f" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">读取偏斜是指一个事务正在读取多条记录，而同时另一个事务更新了其中一条记录，这将导致不可序列化的事务，因为第二个事务交叉在第一个事务中。</p><p id="0423" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">这类似于不可重复读取，但相反，读取偏斜指的是在读取多个不同记录时交叉多个事务的冲突。</p><p id="c9c1" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们想象以下场景。我们有两个账户，两个账户都有1000英镑的余额。有两个事务正在运行，其中一个事务读取两个账户的<em class="mj">余额</em>，另一个事务以交错的方式更新它们。在这种情况下，如果执行SELECT语句的事务获得第一个帐户的<em class="mj"> Balance=1000 </em>，而获得第二个帐户的<em class="mj"> Balance=1500 </em>，则认为是不一致的读取。</p><p id="201d" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们检查一下在Cloud Spanner中没有发生读偏斜。以下示例显示了tx1读取<em class="mj"> UserId=1 </em>和<em class="mj"> UserId=2 </em>的记录，而tx2更新这两个记录的情况。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/288ab208bd65b57c745c8320feb25902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gh8iWesljC0_bw8Qj3R_1A.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/68b8f166ffba273c665482832cf9fc2e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/68 b8f 166 ffba 273 c 665482832 cf 9 fc 2 e</a></figcaption></figure><p id="5913" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">如您所见，tx1获得了一致的读取，而不受tx2的影响。请注意，tx1使用了一个只读事务来阻止tx2中的更新。</p><h1 id="8898" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">6.写入偏斜</h1><p id="c6c1" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">当两个事务并发运行，并在读取相同记录时尝试更新不同记录时，会发生写入偏斜，从而导致不一致的写入。</p><p id="2771" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">例如，假设<em class="mj">账户</em>表有一定的规则:最多只有一条记录有<em class="mj">类型=保存</em>。根据该规则，如果两个事务同时执行以下操作，</p><ol class=""><li id="cea2" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh kt ku kv kw bi translated">通过选择COUNT(*)FROM Accounts WHERE type = " Saving "检查当前的储蓄账户数；</li><li id="d751" class="ko kp hi jm b jn kx jr ky jv kz jz la kd lb kh kt ku kv kw bi translated">如果储蓄账户的数量为零，则将其中一个记录更改为储蓄账户。</li></ol><p id="2599" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">那么这两个交易就有可能同时执行，结果两个账户就变成了储蓄账户。这违反了规则。</p><p id="0a4e" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们检查一下，在上面的场景中，Cloud Spanner中没有发生写偏斜。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es my"><img src="../Images/d88cfd2250a3b60de6a11b743c4ff242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZgaKltFVj10KyO1iJUf_CA.png"/></div></div><figcaption class="mp mq et er es mr ms bd b be z dx translated"><a class="ae ki" href="https://gist.github.com/yfuruyama/4516fe4c9b94c1ceae34f8332dc4f5cd" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yfuruyama/4516 Fe 4c 9 b 94 C1 ceae 34 f 8332 DC 4 F5 CD</a></figcaption></figure><p id="33dd" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">如您所见，当tx1成功提交时，tx2在提交阶段被中止。出现这种情况的原因是tx1试图获取独占锁，但该记录的共享锁已被tx2获取，因此Cloud Spanner中止tx2为tx1获取独占锁。因此，只有一个事务可以成功提交。</p><h1 id="8512" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">摘要</h1><p id="44e0" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">正如所见，Cloud Spanner不允许任何上述隔离现象，因为它只提供了具有外部一致性的最高级别的事务隔离。</p><ul class=""><li id="8310" class="ko kp hi jm b jn kj jr kk jv kq jz kr kd ks kh mz ku kv kw bi translated">感谢<a class="ae ki" rel="noopener" href="/@hostirosti"> @hostirosti </a>帮我写这篇文章！</li></ul></div></div>    
</body>
</html>