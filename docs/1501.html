<html>
<head>
<title>Cloud Spanner Change Watcher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云扳手变化观察器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-spanner-change-watcher-b77ca036459c?source=collection_archive---------0-----------------------#2020-07-08">https://medium.com/google-cloud/cloud-spanner-change-watcher-b77ca036459c?source=collection_archive---------0-----------------------#2020-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2e7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/spanner" rel="noopener ugc nofollow" target="_blank"> Google Cloud Spanner </a>是一个全面管理、可扩展的关系数据库服务，用于区域和全球应用数据。它是第一个可扩展的、企业级的、全球分布的、高度一致的数据库服务，专为云构建，将关系数据库结构的优势与非关系水平扩展相结合。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/16400067b46aef8a444b688bcf1f44a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*t7MKxLVba5Nji_NOIKVrKw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">谷歌云扳手</figcaption></figure><p id="38c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多个应用程序和服务可以同时与同一个Cloud Spanner数据库交互，常见的模式是一个服务基于某些事件触发其他服务，比如在数据库中插入或更新记录。本文描述了开源的<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/tree/master/google-cloud-spanner-change-watcher" rel="noopener ugc nofollow" target="_blank"> spanner-change-watcher </a>库，它可以作为Java应用程序的进程内服务来监控和发布云spanner数据库中的数据更改事件。</p><p id="2f9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开源库还包含了<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/tree/master/google-cloud-spanner-change-publisher" rel="noopener ugc nofollow" target="_blank"> spanner-change-publisher </a>服务，它可以作为一个独立的应用程序运行，将从云spanner数据库发布对一个或多个Pubsub主题的更改。关于这项服务的介绍可以在<a class="ae jd" rel="noopener" href="/@knutolavloite/cloud-spanner-change-publisher-7fbee48f66f8">这里</a>找到。</p><h1 id="2109" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">先决条件和限制</h1><ul class=""><li id="1005" class="ko kp hi ih b ii kq im kr iq ks iu kt iy ku jc kv kw kx ky bi translated">扳手变化监视器使用<a class="ae jd" href="https://cloud.google.com/spanner/docs/commit-timestamp" rel="noopener ugc nofollow" target="_blank">提交时间戳</a>来确定行何时被更新。使用这个库只能监视包含具有上次更新提交时间戳的列的表。这个专栏的名字可以自由选择。</li><li id="cf50" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">该库只能检测插入和更新，因为它依赖行的提交时间戳值来检测更改。要检测删除，您应该通过在行上设置deleted标志来实现逻辑删除，而不是实际删除它。如果在带有一个或多个标记为ON DELETE CASCADE的子表的父表上执行删除，那么子表也需要相应地更新，以便由观察器选取。单独的后台任务可以使用该标志来检测稍后应该删除哪些行。</li><li id="ffd5" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">该库通过轮询被监视的表来监视数据库的变化。轮询间隔默认为一秒钟，可以进行配置。如果在小于轮询间隔的时间范围内对同一行有多次更改，库可能只报告最后一次更改。</li></ul><h1 id="84e4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">成分</h1><p id="7172" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">扳手更换观察器项目包含三个主要组件:</p><ul class=""><li id="6ebd" class="ko kp hi ih b ii ij im in iq lh iu li iy lj jc kv kw kx ky bi translated">Spanner Change Watcher:一个Java后台服务，将监视云Spanner数据库的一个、一些或所有表的变化，并将这些变化作为进程内事件发布到应用程序。这个库可以集成到需要通知数据更新的现有Java应用程序中。本文将重点讨论这个组件。</li><li id="20d0" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">Spanner Change Publisher:一个独立的应用程序，它将观察云Spanner数据库的一个、一些或所有表的变化，并将这些变化以JSON或Avro格式发布到Pubsub。可以将应用程序配置为将所有更改发布到一个主题，或者可以将更改发布到每个表的单独主题。参见<a class="ae jd" rel="noopener" href="/@knutolavloite/cloud-spanner-change-publisher-7fbee48f66f8">这篇文章</a>了解扳手更换发布器组件的更多信息。</li><li id="6a51" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">Spanner Change Archiver:一个示例应用程序，使用Spanner Change Publisher将更改事件发布到Pubsub主题，这将再次触发Google Cloud函数，将更改写入Google云存储。</li></ul><h1 id="b8b4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">扳手更换监视器</h1><p id="fc08" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">扳手变化观察器是一个进程内后台服务，可以包含在现有的Java应用程序中。它将观察一组云扳手表的变化，并通过回调通知应用程序检测到的任何变化。</p><p id="e1ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个简单的回调示例，它将更新行的内容打印到控制台。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">扳手更换观察器—回拨样本</figcaption></figure><p id="debc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spanner Change Watcher允许您为单个表、多组表或整个数据库创建观察器。可以为每个观察器分配一个或多个回调，这些回调将在检测到更改时接收通知，包括新数据和更改的提交时间戳。</p><p id="7347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对一个表的更改保证按照提交时间戳的顺序传递给回调，并且库保证在任何给定的时间，对于一个表，最多有一个回调是活动的。当监视多个表时，这些表被并行轮询，并且不能保证对不同表的回调的顺序。这意味着对<code class="du lm ln lo lp b">TABLE1</code>的改变的回调可能在对<code class="du lm ln lo lp b">TABLE2</code>的回调之前被调用，即使对<code class="du lm ln lo lp b">TABLE2</code>的改变发生在对<code class="du lm ln lo lp b">TABLE1</code>的改变之前。</p><h2 id="56e7" class="lq jr hi bd js lr ls lt jw lu lv lw ka iq lx ly ke iu lz ma ki iy mb mc km md bi translated">看着一张桌子</h2><p id="2183" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">单个表的观察器实现接口<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/SpannerTableChangeWatcher.java" rel="noopener ugc nofollow" target="_blank">SpannerTableChangeWatcher</a>。目前，这个接口的唯一实现是<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/SpannerTableTailer.java" rel="noopener ugc nofollow" target="_blank"> SpannerTableTailer </a>，它以固定的时间间隔轮询被监控的表。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">创建一个SpannerTableTailer</figcaption></figure><h2 id="f674" class="lq jr hi bd js lr ls lt jw lu lv lw ka iq lx ly ke iu lz ma ki iy mb mc km md bi translated">观察整个数据库</h2><p id="0c8a" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">整个数据库或数据库中一组表的观察器实现了接口<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/SpannerDatabaseChangeWatcher.java" rel="noopener ugc nofollow" target="_blank">SpannerDatabaseChangeWatcher</a>。目前，这个接口的唯一实现是<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/SpannerDatabaseTailer.java" rel="noopener ugc nofollow" target="_blank">spannerdatabasetiler</a>，它以固定的时间间隔轮询每个被监控的表。这些表相互独立地被并行轮询。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">创建SpannerDatabaseTailer</figcaption></figure><p id="59e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在创建<code class="du lm ln lo lp b">SpannerDatabaseTailer</code>时使用选项<code class="du lm ln lo lp b">allTables()</code>将自动创建一个观察器，该观察器将观察所有具有提交时间戳列的表<em class="me">。没有commit timestamp列的所有表都将被忽略，并且不需要从要监视的表集中显式排除。</em></p><p id="b112" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以将某些表排除在监视范围之外。使用选项<code class="du lm ln lo lp b">allTables().except(String...)</code>将特定的表排除在监视范围之外。</p><h1 id="ce60" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">教程:示例应用程序</h1><p id="207f" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">现在，我们将通过一步一步的指南来创建一个简单的应用程序，该应用程序将观察两个表的更改并将所有更改写入控制台。完整的<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/samples/spanner-change-watcher-samples/src/main/java/com/google/cloud/spanner/watcher/sample/SimpleChangeWatcherSample.java" rel="noopener ugc nofollow" target="_blank">示例应用程序可以在这里找到</a>。</p><h2 id="c664" class="lq jr hi bd js lr ls lt jw lu lv lw ka iq lx ly ke iu lz ma ki iy mb mc km md bi translated">数据模型</h2><p id="8e9d" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">此示例假设数据库中存在以下表。如果它们还不存在，提供的示例应用程序将自动为您创建它们。</p><p id="ae2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个表都包含一个时间戳类型的LastUpdateTime列，选项为allow_commit_timestamp=true。这意味着Cloud Spanner可以使用更新行的事务的提交时间戳自动设置列。扳手变化监视器只能监视具有这种列的表。可以自由选择列名，库将自动检测使用哪一列。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">样本数据模型</figcaption></figure><h2 id="2c44" class="lq jr hi bd js lr ls lt jw lu lv lw ka iq lx ly ke iu lz ma ki iy mb mc km md bi translated">属国</h2><p id="c965" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">扳手变化监视器是你的项目中需要的一个依赖项。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">扳手变化观察者相关性</figcaption></figure><h2 id="2ced" class="lq jr hi bd js lr ls lt jw lu lv lw ka iq lx ly ke iu lz ma ki iy mb mc km md bi translated">创建扳手更换观察者</h2><p id="c823" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">随着Google-cloud-spanner-change-watcher添加到您的项目中，您现在可以创建一个变更观察器了。对于这个例子，我们将为整个数据库创建一个观察器。该观察器将自动包括数据库中所有具有提交时间戳列的表。所有没有提交时间戳列的表都将被忽略。</p><p id="25d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以设置一组特定的表来监视，或者设置监视程序来监视除了一组特定的表之外的所有表。参见<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/SpannerDatabaseTailer.java" rel="noopener ugc nofollow" target="_blank"> SpannerDatabaseTailer的文档。Builder </a>了解更多信息。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">为所有表创建数据库监视器</figcaption></figure><p id="fbfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以向观察器添加一个或多个<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/8948e6df61dc8d39474bbdf34d285d3c8e5b229e/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/SpannerTableChangeWatcher.java#L37" rel="noopener ugc nofollow" target="_blank">回调</a>，以接收检测到的所有更改的通知。本例中的回调只是打印已经更新到控制台的行的新内容。</p><h2 id="5500" class="lq jr hi bd js lr ls lt jw lu lv lw ka iq lx ly ke iu lz ma ki iy mb mc km md bi translated">写入更改</h2><p id="a25b" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">写入扳手数据库的所有更改现在也将由观察器打印到控制台。示例应用程序将5位歌手和5张专辑写入数据库。重要的是，向Cloud Spanner写入数据的应用程序也用当前事务的提交时间戳填充提交时间戳列。使用变异对象时使用<code class="du lm ln lo lp b">Value.COMMIT_TIMESTAMP</code>占位符值，通过DML写入数据时使用<code class="du lm ln lo lp b">PENDING_COMMIT_TIMESTAMP()</code>函数。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">使用价值。COMMIT_TIMESTAMP在使用变异对象时写入提交时间戳</figcaption></figure><h2 id="c19b" class="lq jr hi bd js lr ls lt jw lu lv lw ka iq lx ly ke iu lz ma ki iy mb mc km md bi translated">运行示例应用程序</h2><p id="d853" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">要执行示例应用程序，请按照下列步骤操作:</p><ol class=""><li id="3b04" class="ko kp hi ih b ii ij im in iq lh iu li iy lj jc mf kw kx ky bi translated"><a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher" rel="noopener ugc nofollow" target="_blank">从GitHub </a>克隆项目。</li><li id="1571" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc mf kw kx ky bi translated">导航到<code class="du lm ln lo lp b">spanner-change-watcher/samples/spanner-change-watcher-samples</code>文件夹。</li><li id="2967" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc mf kw kx ky bi translated">通过执行<code class="du lm ln lo lp b">mvn clean package</code>创建一个. jar。</li><li id="bfe3" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc mf kw kx ky bi translated">执行以下命令，其中<code class="du lm ln lo lp b">&lt;instance-id&gt;</code>和<code class="du lm ln lo lp b">&lt;database-id&gt;</code>必须用实际值代替。该实例必须已经存在，如果数据库尚不存在，将自动创建该数据库。</li></ol><pre class="jf jg jh ji fd mg lp mh mi aw mj bi"><span id="f9be" class="lq jr hi lp b fi mk ml l mm mn">java -cp target/spanner-change-watcher-samples.jar \<br/>com.google.cloud.spanner.watcher.sample.SimpleChangeWatcherSample \<br/>&lt;instance-id&gt; &lt;database-id&gt;</span></pre><p id="04c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例应用程序将启动，控制台的输出应该如下所示。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">抽样输出</figcaption></figure><p id="fd02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您通过任何其他应用程序在数据库中插入或更新更多数据，例如Google Cloud Spanner web界面或gcloud util，观察器也会打印出这些更改。</p><h1 id="be77" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">更多样本</h1><p id="bfe5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">关于如何使用spanner-change-watcher的更多示例可在<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/samples/spanner-change-watcher-samples/src/main/java/com/google/cloud/spanner/watcher/sample/Samples.java" rel="noopener ugc nofollow" target="_blank">spanner-change-watcher-samples/samples . Java</a>文件中找到，示例用于:</p><ul class=""><li id="6828" class="ko kp hi ih b ii ij im in iq lh iu li iy lj jc kv kw kx ky bi translated">错误处理</li><li id="fc3d" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">配置轮询间隔</li><li id="eebc" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">使用自定义提交时间戳存储库</li><li id="a456" class="ko kp hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">使用<a class="ae jd" href="https://cloud.google.com/spanner/docs/whitepapers/optimizing-schema-design#anti-pattern_timestamp_ordering" rel="noopener ugc nofollow" target="_blank">分片</a>允许对提交时间戳列进行索引，以优化轮询</li></ul></div></div>    
</body>
</html>