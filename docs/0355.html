<html>
<head>
<title>How I containerised my resume API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何封装我的简历API</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-i-containerised-my-resume-api-91bb2d2f92f4?source=collection_archive---------0-----------------------#2017-08-10">https://medium.com/google-cloud/how-i-containerised-my-resume-api-91bb2d2f92f4?source=collection_archive---------0-----------------------#2017-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="029f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…或者<strong class="ih hj">(这个)在谷歌云平台上运行Docker和Kubernetes的白痴指南</strong></p><p id="13ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我目前正在寻找有趣的新机会，并且对api特别感兴趣，几周前我为自己的简历创建了一个API，并在这里写道:<a class="ae jd" rel="noopener" href="/@mariomenti/everything-is-an-api-including-me-and-my-cv-674ea433f283">https://medium . com/@ Mario menti/everything-is-a-API-including-me-and-my-CV-674 ea 433 f 283</a></p><p id="fcb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从那以后，我花了一些时间研究微服务和容器(即Kubernetes和Docker)，因为我觉得我想更熟悉其中的一些概念。尽管我几乎不知道自己在做什么，但和以往一样，我认为描述我如何将我的单片API转移到独立的微服务中会很有趣，所有这些服务都运行在<a class="ae jd" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae jd" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>上。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/41e894fef42f72e393f3d2f9b99e7dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJgd0o-njVcG9mC94e3RcQ.jpeg"/></div></div></figure><p id="144f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我开始写这篇文章时，我对容器的概念完全陌生，所以这将有望作为一个有用的白痴指南/类似情况下的人的起点——但同时，我几乎肯定以一种不太理想的(如果不是完全丑陋甚至错误的)方式做事情，所以如果任何专家阅读了这篇文章并感到恶心，请发表评论并让我知道我错在哪里！</p><p id="bff4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我为什么要这么做？问得好——在我的特殊情况下，可能没有那么多原因，因为我的CV API几乎没有在负荷下呻吟(如果是的话，我就没有时间写这样的文章了！).但是想象一下这是一个生产级的API:目前，所有的东西，API的每个端点以及加载简历数据和API令牌的代码都包含在一个Go程序中。<br/>如果一个端点需要更改，这意味着重新编译和重新部署整个东西。比方说，有一个API端点(例如向我发送电子邮件或SMS消息的“/contact”端点)突然变得非常流行，API开始陷入困境，为了在现有设置中进行扩展，我必须增加运行API的整个计算引擎实例的容量。<br/>相比之下，在容器化的世界中，因为每个API端点都作为自己的微服务运行，所以我将能够独立地扩展“/contact”端点，同时保持API的所有其他方面不变。<br/>所以你突然对你的应用程序的不同部分有了更细粒度的控制。<br/>类似地，如果一个API端点需要更新，它可以独立于API的其余部分进行部署，而不会有任何停机时间。此外，Kubernetes具有自我修复功能，因此，如果运行某个应用程序的所谓pod出现故障，Kubernetes会自动替换它们。</p><p id="85f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，废话不多说，前提条件(我正在使用Ubuntu Linux笔记本电脑，细节可能会因您使用的操作系统而异，所以我链接到相当通用的文档):</p><ul class=""><li id="6064" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">安装<a class="ae jd" href="https://docs.docker.com/engine/installation/" rel="noopener ugc nofollow" target="_blank">对接器</a></li><li id="ab42" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">安装<a class="ae jd" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>，它允许您在Kubernetes上部署和管理应用程序</li><li id="6d8f" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">在<a class="ae jd" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>上拥有/获得一个账户(我们使用GCP的<a class="ae jd" href="https://cloud.google.com/container-engine/docs/" rel="noopener ugc nofollow" target="_blank">容器引擎</a>来运行我们的Kubernetes应用)</li><li id="77db" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">安装<a class="ae jd" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK，</a>或者使用<a class="ae jd" href="https://cloud.google.com/shell/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Shell </a></li></ul><p id="bb3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吗？很好。首先要做的是创建一个Kubernetes集群来运行我们的应用程序。这里我使用默认设置，创建一个3机集群:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="6780" class="kk kl hi kg b fi km kn l ko kp">$ gcloud container clusters create marioapi-cluster</span></pre><p id="ce52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将需要几分钟时间——创建集群后，通过键入以下内容，使用您的Google帐户验证Google Cloud SDK:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="fdb1" class="kk kl hi kg b fi km kn l ko kp">$ gcloud auth application-default login</span></pre><p id="bf49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们后退一步，看看我现有的API设置，以及我们希望如何将其转换为一组微服务。它非常简单，包含以下几个部分:</p><ul class=""><li id="6f9a" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">一个读取我的JSON格式简历的功能</li><li id="7ab4" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">该函数读取包含有效API令牌数据的JSON文件，并检查传递给API端点的令牌的有效性</li><li id="67cc" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">处理不同API端点的gorilla/mux处理程序:</li></ul><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="92c8" class="kk kl hi kg b fi km kn l ko kp">r.HandleFunc("/full", api.FullCVHandler).Methods("GET")<br/>r.HandleFunc("/summary", api.SummaryHandler).Methods("GET")<br/>r.HandleFunc("/contact", api.ContactHandler).Methods("GET")<br/>r.HandleFunc("/contact", api.ContactPostHandler).Methods("POST")<br/>r.HandleFunc("/experience", api.ExperienceHandler).Methods("GET")<br/>r.HandleFunc("/experience/{id}", api.ExperienceIdHandler).Methods("GET")<br/>r.HandleFunc("/projects", api.ProjectsHandler).Methods("GET")<br/>r.HandleFunc("/projects/{id}", api.ProjectsIdHandler).Methods("GET")<br/>r.HandleFunc("/tags", api.TagsHandler).Methods("GET")<br/>r.HandleFunc("/tags/{tag}", api.TagsTagHandler).Methods("GET")</span></pre><p id="1fd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些都包含在one Go程序文件中。因此，为了区分开来，我要做的是创建这些独立的微服务:</p><ul class=""><li id="8ba6" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">一个简历服务器，它加载我的简历并以JSON格式提供，</li><li id="4668" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">令牌服务器，它加载有效的API令牌定义，并根据客户端在API调用中发送的内容检查它们，</li><li id="d770" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">每个API端点(例如完整端点、汇总端点、接触端点等)的单独微服务。),</li><li id="d786" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">最后是nginx (web服务器)服务，它处理负载平衡并将请求传递给相关的内部服务。</li></ul><p id="5a07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先看看简历服务器。这是一个简单的(也是不现实的)问题——一个“真正的”API当然会有某种类型的数据存储/数据库，但是出于演示的目的，我只是从一个JSON文件中读取我的简历/CV数据。</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="3a66" class="kk kl hi kg b fi km kn l ko kp">package main<br/><br/>import (<br/>        "fmt"<br/>        "io/ioutil"<br/>        "log"<br/>        "net/http"<br/>)<br/><br/>func LoadResume() string {<br/><br/>        file, e := ioutil.ReadFile("/resume.json")<br/>        if e != nil {<br/>                return "{}"<br/>        }<br/>        return string(file)<br/>}<br/><br/>func serve(w http.ResponseWriter, r *http.Request) {<br/>        fmt.Fprintf(w, LoadResume())<br/>}<br/><br/>func main() {<br/>        http.HandleFunc("/", serve)<br/>        err := http.ListenAndServe(":80", nil)<br/>        if err != nil {<br/>                log.Fatal("ListenAndServe: ", err)<br/>        }<br/>}</span></pre><p id="6cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们接下来需要为此创建一个docker容器，这样我们就可以将它上传到Kubernetes。同样，Dockerfile文件本身也很简单:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="c96f" class="kk kl hi kg b fi km kn l ko kp">FROM golang:1.6-onbuild<br/>COPY resume.json /</span></pre><p id="a848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…COPY行确保我们将resume.json文件复制到容器中，以便pod应用程序可以读取它。像这样构建docker容器:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="098a" class="kk kl hi kg b fi km kn l ko kp">$ docker build -t gcr.io/&lt;YOUR-GOOGLE-CLOUD-CLOUD-PROJECT&gt;/resume-server:1.0 .</span></pre><p id="d142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过键入…来获得应该用来代替<your-google-cloud-project>的值</your-google-cloud-project></p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="ecc7" class="kk kl hi kg b fi km kn l ko kp">$ gcloud config get-value project</span></pre><p id="b1a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当你在这里的任何例子中看到<your-google-cloud-project>时，用你实际的Google Cloud项目名称替换。一旦docker容器构建完成，我们需要将其推送到Google Cloud:</your-google-cloud-project></p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="55df" class="kk kl hi kg b fi km kn l ko kp">$ gcloud docker -- push gcr.io/&lt;YOUR-GOOGLE-CLOUD-CLOUD-PROJECT&gt;/resume-server:1.0</span></pre><p id="124e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们希望将应用程序部署到Kubernetes。为此，我们为应用程序创建了一个deployment.yaml文件:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="a7dd" class="kk kl hi kg b fi km kn l ko kp">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: resumeserver<br/>spec:<br/>  replicas: 2<br/>  template:<br/>    metadata:<br/>      labels:<br/>        name: resumeserver-pods<br/>    spec:<br/>      containers:<br/>      - image: gcr.io/&lt;YOUR-GOOGLE-CLOUD-CLOUD-PROJECT&gt;/resume-server:1.0<br/>        name: resumeserver-container<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 80<br/>          name: http-server</span></pre><p id="a33c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，我们希望始终运行2个resumeserver实例，但是如果我们希望容错能力更强，我们可以指定更多的副本。正如我上面提到的，Kubernetes将确保至少有X一直在运行，并根据需要重新启动它们。</p><p id="d65e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署应用程序:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="1755" class="kk kl hi kg b fi km kn l ko kp">$ kubectl apply -f deployment.yaml</span></pre><p id="652f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在Kubernetes中创建了2个正在运行的pod，您可以通过这些命令查看详细信息——第一个命令列出了您的集群上的部署，第二个命令列出了pod(正如我们指定的，有2个pod正在为我们的resumeserver部署运行)。</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="c697" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get deployments<br/>NAME           DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>resumeserver   2         2         2            2           2m<br/>$ kubectl get pods<br/>NAME                            READY     STATUS    RESTARTS   AGE<br/>resumeserver-3871548837-8tf9w   1/1       Running   0          1m<br/>resumeserver-3871548837-ks0lk   1/1       Running   0          2m</span></pre><p id="6625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止还不错，但是为了能够与这些正在运行的pod通信，我们需要创建一个命名服务。为此，我们使用这个服务。</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="f70a" class="kk kl hi kg b fi km kn l ko kp">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: resumeserver<br/>spec:<br/>  ports:<br/>    - port: 80<br/>      targetPort: 80<br/>      protocol: TCP<br/>  selector:<br/>    name: resumeserver-pods</span></pre><p id="f145" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这定义了一个名为“resumeserver”的服务，它包括所有运行名称为“resumeserver-pods”的pod(我们在上面的deployment.yaml文件中指定了这一点)。要创建服务，请运行…</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="bd98" class="kk kl hi kg b fi km kn l ko kp">$ kubectl create -f service.yaml</span></pre><p id="2de8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以检查并查看我们的服务是否正在运行:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="1e03" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get svc<br/>NAME           CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br/>kubernetes     10.23.240.1     &lt;none&gt;        443/TCP   13m<br/>resumeserver   10.23.243.143   &lt;none&gt;        80/TCP    33s</span></pre><p id="85fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到resumeserver就在那里，并且已经分配了一个内部IP地址。好的一面是Kubernetes有一个内置的DNS服务(更多内容见下文)，所以从现在开始，当我们想从我们集群中的不同pod连接到它时，我们将能够通过名称来引用我们的resumeserver服务。</p><p id="117d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，我们现在已经启动并运行了简历服务器部分，设置令牌服务器也非常类似，所以我不会在这里赘述，但是<a class="ae jd" href="https://github.com/mmenti/marioapi-k8s-demo" rel="noopener ugc nofollow" target="_blank">所有的文件都在Github </a>上。本质上，对于我们想要创建的每个服务，我们遵循以下步骤:</p><ul class=""><li id="28eb" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">创建docker容器</li><li id="d4e2" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">将容器推送到谷歌云</li><li id="8187" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">运行/应用部署</li><li id="f373" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">创建服务</li></ul><p id="e26c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，按照上述步骤创建令牌服务器后，我们会看到resumeserver和令牌服务器都在我们的群集上运行:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="0505" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get svc<br/>NAME           CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br/>kubernetes     10.23.240.1     &lt;none&gt;        443/TCP   30m<br/>resumeserver   10.23.243.143   &lt;none&gt;        80/TCP    17m<br/>tokenserver    10.23.244.115   &lt;none&gt;        80/TCP    7s</span></pre><p id="df98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们创建一个API端点。最简单的是“/full”端点，它基本上只是以JSON格式返回整个简历/CV。其他一些端点稍微复杂一些(但不多，这是一个非常简单的演示:)</p><p id="5a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您查看<a class="ae jd" href="https://github.com/mmenti/marioapi-k8s-demo/blob/master/full/full.go" rel="noopener ugc nofollow" target="_blank"> full.go </a>，可以看到我们指的是令牌服务器和resumeserver:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="39e0" class="kk kl hi kg b fi km kn l ko kp">func LoadResume() (resumeData Resume, loadedOk bool) {<br/><br/>        var res Resume<br/><br/>        rsp, err := http.Get("http://resumeserver")<br/>        if err != nil {<br/>                return res, false<br/>        }<br/>        defer rsp.Body.Close()<br/>        bodyByte, err := ioutil.ReadAll(rsp.Body)<br/>        if err != nil {<br/>                return res, false<br/>        }<br/><br/>        err = json.Unmarshal(bodyByte, &amp;resumeData)<br/>        if err != nil {<br/>                return res, false<br/>        }<br/>        return resumeData, true<br/><br/>}</span><span id="4a11" class="kk kl hi kg b fi kq kn l ko kp">func serve(w http.ResponseWriter, r *http.Request) {<br/><br/>        // check token, load resume, return relevant part(s)<br/>        token := r.FormValue("token")<br/>        rsp, err := http.Get("http://tokenserver?token=" + token)<br/>        if err != nil {<br/>                WriteApiError(w, 110, "Error checking token from token server")<br/>                return<br/>        }<br/>        defer rsp.Body.Close()<br/>        bodyBytes, err := ioutil.ReadAll(rsp.Body)<br/>[...]</span></pre><p id="4f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们创建了名为“resumeserver”和“tokenserver”的服务，所以我们现在可以使用它们的名称(例如“http://resumeserver”)来访问它们— Kubernetes的内部DNS服务会处理这些问题。注意这只是内部的，这些舱不能从外部世界的任何地方访问(我们也不希望它们被访问)，只能从我们集群中的其他舱访问。在这个演示中，我们通过http访问它们，但是如果它们是(比如)redis或mySql服务器而不是HTTP服务器，它将以几乎相同的方式工作。</p><p id="0c16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建完整端点服务，我们再次经历相同的步骤:</p><ul class=""><li id="e775" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">创建docker容器:</li></ul><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="d453" class="kk kl hi kg b fi km kn l ko kp">$ docker build -t gcr.io/&lt;YOUR-GOOGLE-CLOUD-CLOUD-PROJECT&gt;/full-endpoint:1.0 .</span></pre><ul class=""><li id="d7af" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">将容器推送到Google Cloud:</li></ul><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="0736" class="kk kl hi kg b fi km kn l ko kp">$ gcloud docker -- push gcr.io/&lt;YOUR-GOOGLE-CLOUD-CLOUD-PROJECT&gt;/full-endpoint:1.0</span></pre><ul class=""><li id="2380" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">创建/应用部署:</li></ul><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="1294" class="kk kl hi kg b fi km kn l ko kp">$ kubectl apply -f deployment.yaml</span></pre><ul class=""><li id="9973" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">创建服务:</li></ul><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="d70b" class="kk kl hi kg b fi km kn l ko kp">$ kubectl create -f service.yam</span></pre><p id="ac3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成后，我们可以在服务列表中看到新的端点(完整端点):</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="df68" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get svc<br/>NAME            CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br/>full-endpoint   10.23.241.128   &lt;none&gt;        80/TCP    37s<br/>kubernetes      10.23.240.1     &lt;none&gt;        443/TCP   45m<br/>resumeserver    10.23.243.143   &lt;none&gt;        80/TCP    33m<br/>tokenserver     10.23.244.115   &lt;none&gt;        80/TCP    15m</span></pre><p id="e68d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个API端点的详细代码略有不同(您可以在<a class="ae jd" href="https://github.com/mmenti/marioapi-k8s-demo" rel="noopener ugc nofollow" target="_blank"> Github </a>中看到所有文件)，但我们对每个端点都经历了完全相同的过程，直到我们的集群包含每个API端点的服务:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="dc7b" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get svc<br/>NAME                  CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br/>contact-endpoint      10.23.244.122   &lt;none&gt;        80/TCP    4m<br/>experience-endpoint   10.23.252.142   &lt;none&gt;        80/TCP    2m<br/>full-endpoint         10.23.241.128   &lt;none&gt;        80/TCP    14m<br/>kubernetes            10.23.240.1     &lt;none&gt;        443/TCP   59m<br/>projects-endpoint     10.23.244.164   &lt;none&gt;        80/TCP    1m<br/>resumeserver          10.23.243.143   &lt;none&gt;        80/TCP    46m<br/>summary-endpoint      10.23.249.134   &lt;none&gt;        80/TCP    8m<br/>tags-endpoint         10.23.246.242   &lt;none&gt;        80/TCP    7s<br/>tokenserver           10.23.244.115   &lt;none&gt;        80/TCP    29m</span></pre><p id="406d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以检查我们的部署和pod(在resumeserver服务之后，我只指定了每个服务1个副本，但这当然可以根据需要进行扩展):</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="8a03" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get deployments<br/>NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>contact-endpoint      1         1         1            1           5m<br/>experience-endpoint   1         1         1            1           3m<br/>full-endpoint         1         1         1            1           15m<br/>projects-endpoint     1         1         1            1           2m<br/>resumeserver          2         2         2            2           56m<br/>summary-endpoint      1         1         1            1           9m<br/>tags-endpoint         1         1         1            1           1m<br/>tokenserver           1         1         1            1           30m</span><span id="14ed" class="kk kl hi kg b fi kq kn l ko kp">$ kubectl get pods       <br/>NAME                                   READY     STATUS    RESTARTS   AGE<br/>contact-endpoint-3271379398-6614g      1/1       Running   0          5m<br/>experience-endpoint-4000525602-3qsw6   1/1       Running   0          3m<br/>full-endpoint-960439747-wrch5          1/1       Running   0          15m<br/>projects-endpoint-1973496552-q1p38     1/1       Running   0          2m<br/>resumeserver-3871548837-8tf9w          1/1       Running   0          54m<br/>resumeserver-3871548837-ks0lk          1/1       Running   0          56m<br/>summary-endpoint-4173081044-2lf30      1/1       Running   0          8m<br/>tags-endpoint-3958056375-vtpdv         1/1       Running   0          1m<br/>tokenserver-4152829013-12w2j           1/1       Running   0          30m</span></pre><p id="fbf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">嘘…想知道一个秘密吗？</strong>在我们进入最后一部分(实际上是将所有这些服务公开给外界)之前，让我们来看看“/contact”端点。这个比其他的更有趣(TBH没有说太多)，因为它包含了一些通过Twilio发送SMS消息和通过SendGrid发送电子邮件的代码。你说没那么有趣——但这里有趣的部分是弄清楚我们如何最好地将像API密钥这样的“秘密”信息传递到Kubernetes上的一个容器，而暴露这些机密数据的风险最小。幸运的是，Kubernetes有一个关于<a class="ae jd" href="https://kubernetes.io/docs/concepts/configuration/secret/#creating-a-secret-using-kubectl-create-secret" rel="noopener ugc nofollow" target="_blank">秘密的概念，</a>让这个变得非常容易和安全。</p><p id="3102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将秘密信息传递给Kubernets pod/deployment，我们首先创建一个包含我们的机密API信息的秘密。这是我的秘密:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="8843" class="kk kl hi kg b fi km kn l ko kp">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: contact-secrets<br/>type: Opaque<br/>data:<br/>  twiliosid: &lt;base64-encoded version of your string&gt;<br/>  twiliotoken: &lt;base64-encoded version of your string&gt;<br/>  twiliourl: &lt;base64-encoded version of your string&gt;<br/>  twilionumber: &lt;base64-encoded version of your string&gt;<br/>  alertnumber: &lt;base64-encoded version of your string&gt;<br/>  sendgridkey: &lt;base64-encoded version of your string&gt;</span></pre><p id="ce9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们通过运行以下命令来创建秘密:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="3ffd" class="kk kl hi kg b fi km kn l ko kp">$ kubectl create -f ./secrets.yaml</span></pre><p id="e85a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jq">(显然不要以任何方式公开secrets.yaml文件，例如，通过签入源代码控制或类似方式……)</em></p><p id="ba00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们为contact-endpoint服务创建部署时，我们可以引用我们命名为“contact-secret”的秘密，并将这些值作为环境变量传递:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="6f68" class="kk kl hi kg b fi km kn l ko kp">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: contact-endpoint<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        name: contact-endpoint-pods<br/>    spec:<br/>      containers:<br/>      - image: gcr.io/airy-cortex-166611/contact-endpoint:1.0<br/>        name: contact-endpoint-container<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 80<br/>          name: http-server<br/>        env:<br/>        - name: TWILIO_SID<br/>          valueFrom:<br/>           secretKeyRef:<br/>            name: contact-secrets<br/>            key: twiliosid<br/>        - name: TWILIO_TOKEN<br/>          valueFrom:<br/>           secretKeyRef:<br/>            name: contact-secrets<br/>            key: twiliotoken<br/>        - name: TWILIO_URL<br/>          valueFrom:<br/>           secretKeyRef:<br/>            name: contact-secrets<br/>            key: twiliourl<br/>        - name: TWILIO_NUMBER<br/>          valueFrom:<br/>           secretKeyRef:<br/>            name: contact-secrets<br/>            key: twilionumber<br/>        - name: ALERT_NUMBER<br/>          valueFrom:<br/>           secretKeyRef:<br/>            name: contact-secrets<br/>            key: alertnumber<br/>        - name: SENDGRID_KEY<br/>          valueFrom:<br/>           secretKeyRef:<br/>            name: contact-secrets<br/>            key: sendgridkey</span></pre><p id="c3ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们刚刚部署的pod中的contacts.go程序中，我们可以轻松获得这些环境值:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="2ae5" class="kk kl hi kg b fi km kn l ko kp">var (<br/>        // twilio (for SMS) and SendGrid (for email) config<br/>        twilioSid    string = os.Getenv("TWILIO_SID")<br/>        twilioToken  string = os.Getenv("TWILIO_TOKEN")<br/>        twilioUrl    string = os.Getenv("TWILIO_URL")<br/>        twilioNumber string = os.Getenv("TWILIO_NUMBER")<br/>        alertNumber  string = os.Getenv("ALERT_NUMBER")<br/>        sendGridKey  string = os.Getenv("SENDGRID_KEY")<br/>)</span></pre><p id="8801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很棒，对吧？；)</p><p id="c709" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在到了最后一部分——我们运行了所有这些服务，但是没有任何东西可以访问它们。因此，我们需要的是向外界公开的东西，能够处理我们的API请求，并将它们传递给相关的服务进行处理。输入nginx(当然)。</p><p id="a640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，这非常简单——我们只需创建一个定制的nginx.conf，然后创建一个使用它的docker容器。nginx.conf的内容如下所示:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="28e1" class="kk kl hi kg b fi km kn l ko kp">resolver 10.23.240.10 valid=5s;<br/><br/>upstream summary-endpoint {<br/>    server summary-endpoint.default.svc.cluster.local;<br/>}<br/>upstream full-endpoint {<br/>    server full-endpoint.default.svc.cluster.local;<br/>}<br/>upstream projects-endpoint {<br/>    server projects-endpoint.default.svc.cluster.local;<br/>}<br/>upstream experience-endpoint {<br/>    server experience-endpoint.default.svc.cluster.local;<br/>}<br/>upstream tags-endpoint {<br/>    server tags-endpoint.default.svc.cluster.local;<br/>}<br/>upstream contact-endpoint {<br/>    server contact-endpoint.default.svc.cluster.local;<br/>}<br/><br/>server {<br/>    listen 80;<br/><br/>    root /usr/share/nginx/html;<br/><br/>    location / {<br/>        index  index.html index.htm;<br/>    }<br/><br/>    location /summary/ {<br/>        proxy_pass http://summary-endpoint/;<br/>    }<br/>    location /full/ {<br/>        proxy_pass http://full-endpoint/;<br/>    }<br/>    location /projects/ {<br/>        proxy_pass http://projects-endpoint/;<br/>    }<br/>    location /experience/ {<br/>        proxy_pass http://experience-endpoint/;<br/>    }<br/>    location /tags/ {<br/>        proxy_pass http://tags-endpoint/;<br/>    }<br/>    location /contact/ {<br/>        proxy_pass http://contact-endpoint/;<br/>    }<br/>    location = /summary {<br/>        proxy_pass http://summary-endpoint/;<br/>    }<br/>    location = /full {<br/>        proxy_pass http://full-endpoint/;<br/>    }<br/>    location = /projects {<br/>        proxy_pass http://projects-endpoint/;<br/>    }<br/>    location = /experience {<br/>        proxy_pass http://experience-endpoint/;<br/>    }<br/>    location = /tags {<br/>        proxy_pass http://tags-endpoint/;<br/>    }<br/>    location = /contact {<br/>        proxy_pass http://contact-endpoint/;<br/>    }<br/><br/>}<br/></span></pre><p id="1cc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一行，我们指定要使用的DNS解析器—在您的情况下，这可能是一个不同的值，要获得您应该使用的值，请运行:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="3bbb" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get services kube-dns --namespace=kube-system</span></pre><p id="fd5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">剩下的就不言自明了——每个服务都有自己的服务名，所以我们只需将不同位置的请求代理给不同的服务。</p><p id="2c30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建容器的Dockerfile文件:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="3ca2" class="kk kl hi kg b fi km kn l ko kp">FROM nginx<br/>RUN rm /etc/nginx/conf.d/default.conf<br/>COPY nginx.conf /etc/nginx/conf.d/default.conf</span></pre><p id="3c75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们构建并推动我们的容器:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="9bda" class="kk kl hi kg b fi km kn l ko kp">$ docker build -t gcr.io/&lt;YOUR-GOOGLE-CLOUD-CLOUD-PROJECT&gt;/my-nginx:1.0 .<br/>$ gcloud docker -- push gcr.io/&lt;YOUR-GOOGLE-CLOUD-CLOUD-PROJECT&gt;my-nginx:1.0</span></pre><p id="9528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们创建部署(这也与上面的服务非常相似，我想您已经开始看到一种模式了)，然后创建服务。这就是我们之前创建的服务的一个不同之处:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="90f7" class="kk kl hi kg b fi km kn l ko kp">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: nginx<br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>    - port: 80<br/>      targetPort: 80<br/>      protocol: TCP<br/>      name: http<br/>  selector:<br/>    name: nginx-pods</span></pre><p id="b7e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与之前的服务定义不同，这里我们将类型指定为“负载平衡器”。这将为服务提供一个外部IP地址。因此，在运行“kubectl create -f service.yaml”之后，您应该会看到如下内容:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="5ae5" class="kk kl hi kg b fi km kn l ko kp">$ kubectl get svc<br/>NAME                  CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE<br/>contact-endpoint      10.23.244.122   &lt;none&gt;          80/TCP         48m<br/>experience-endpoint   10.23.252.142   &lt;none&gt;          80/TCP         46m<br/>full-endpoint         10.23.241.128   &lt;none&gt;          80/TCP         58m<br/>kubernetes            10.23.240.1     &lt;none&gt;          443/TCP        1h<br/>nginx                 10.23.252.234   35.189.117.234   80:30543/TCP   1m<br/>projects-endpoint     10.23.244.164   &lt;none&gt;          80/TCP         45m<br/>resumeserver          10.23.243.143   &lt;none&gt;          80/TCP         1h<br/>summary-endpoint      10.23.249.134   &lt;none&gt;          80/TCP         53m<br/>tags-endpoint         10.23.246.242   &lt;none&gt;          80/TCP         44m<br/>tokenserver           10.23.244.115   &lt;none&gt;          80/TCP         1h</span></pre><p id="3c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jq">(外部IP地址可能需要一段时间才会出现，如果显示“&lt;待定&gt;”，只需重新运行命令，直到可以看到外部IP地址。)</em></p><p id="f631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的nginx服务有了一个外部IP地址，我们准备向API发出一些请求…例如，调用/tags/golang端点:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="5a21" class="kk kl hi kg b fi km kn l ko kp">$ curl http://35.189.117.234/tags/golang?token=public<br/>{"Projects":[{"id":1,"name":"Gigfinder bot (Facebook Messenger bot)","summary":"Wondering when and where your favourite band is playing live next? Or just want to see what gigs are on tonight in your city? Message me and I'll tell you!","url":"https://www.facebook.com/gigfinderbot/","tags":["songkick","facebook","golang","supervisord","nginx","amazon","simpledb","redis"]},{"id":2,"name":"Songkick Alert bot (Facebook Messenger bot)","summary":"Say hello to the Songkick Alerts bot on Facebook Messenger to set up your Songkick alerts. Once set up and activated, the bot will send you instant notifications on Messenger for any newly announced shows by the Songkick artists you're tracking.","url":"https://www.facebook.com/songkickalerts/","tags":["songkick","last.fm","facebook","golang","supervisord","nginx","amazon","simpledb"]},{"id":4,"name":"Slack gig attendance bot (Slack integration)","summary":"A Slack bot that checks users' Songkick event attendance and automatically shares these to a Slack channel of your choice. As an example, we have a specific #gig Slack channel where notifications of the shows/gigs that users are planning to go to are being posted as soon as a user marks their attendance on Songkick. Includes artist images retrieved via the last.fm API.","url":"https://github.com/mmenti/songslack","tags":["songkick","slack","last.fm","golang","supervisord","nginx","simpledb"]},{"id":5,"name":"Slack Gigfinder bot (Slack bot)","summary":"Directly search for upcoming shows of an artist from within Slack, powered by the Songkick API.","url":"http://blog.songkick.com/2015/11/09/slack-magic/","tags":["songkick","slack","golang","supervisord","nginx"]}],"Experience":[{"id":1,"name":"Awne","dates":"2016 - 2017","location":"London, UK","job_title":"Technical co-founder","summary":"Technical co-founder (with two others) of Awne, a personal relationship assistant.  Built a platform and API that lets us create content and deliver that content to users from one unified back-end to multiple potential delivery channels (messaging, bots, web, apps etc).\n Developed a Facebook Messenger bot to ask users daily questions, record user answers, and deliver tips and updates into their personal Awne home.\n Created prototypes/ proof-of-concepts for delivering Awne content (and collecting user data) via different channels (e.g. messaging, SMS, web, Amazon Alexa) via the same API-powered back-end/platform.\n Both API/platform and Messenger bots built using golang, running through supervisord and nginx.","tags":["golang","api","redis","wit.ai","awne","facebook","supervisord","nginx","mysql","amazonec2","amazonrds"]}]</span></pre><p id="ca49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发布到/contact端点以向我发送电子邮件:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="bf1e" class="kk kl hi kg b fi km kn l ko kp">$ curl -X POST -F 'channel=email' -F 'message=test email message dude!!' -F "from=test@test.net" -F "token=public" http://35.189.117.234/contact/ <br/>{"success_code":202,"success_text":"Email successfully sent, thanks so much!"}</span></pre><p id="c098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！(我觉得。)我们的API现在已经完全容器化了，耶！</p><p id="d19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦一切都在运行，并且您想要扩大或缩小某个特定的微服务，只需运行kubectl scale命令即可:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="f819" class="kk kl hi kg b fi km kn l ko kp">$ kubectl scale deployment contact-endpoint --replicas=5</span></pre><p id="2da3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建运行/contact API端点的pod的5个副本。缩小是一样的，只是用一个更小的数字替换5(如果指定replicas=0，将没有pods运行应用程序)。</p><p id="2918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您甚至可以根据CPU需求自动扩展部署:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="1e87" class="kk kl hi kg b fi km kn l ko kp">$ kubectl autoscale deployment contact-endpoint --min=1 --max=5 <br/>--cpu-percent=80</span></pre><p id="4b2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要更新服务，无需任何停机，只需对您的程序、内容和/或Dockerfile进行更改，然后完成构建docker容器的步骤，将其推送到Google Cloud，并使用新容器应用deployment.yaml(无需对服务做任何事情)。这将使用新版本替换部署中正在运行的pod。</p><p id="9d31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在更新部署时出错，可以快速回滚到给定部署的前一版本:</p><pre class="jf jg jh ji fd kf kg kh ki aw kj bi"><span id="2f79" class="kk kl hi kg b fi km kn l ko kp">$ kubectl rollout undo deployment/nginx</span></pre><p id="2776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，你可以用Kubernetes部署做更多的事情，我只是触及了表面——如果你想了解更多，请参见这里的文档:<a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/concepts/workloads/controllers/deployment/</a>。</p><p id="953c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哎哟，这已经变成了一个有点像怪物的帖子——如果你还和我在一起，我希望它在给出Docker和Kubernetes中的一些概念的实际演练中证明是有用的。正如我之前说过的，我对这个很陌生，所以毫无疑问这里有一些错误——如果你发现了什么，请告诉我，我会更新帖子的！</p></div></div>    
</body>
</html>