<html>
<head>
<title>Firebase: Asynchronous Operations with Admin Java SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase:使用管理Java SDK的异步操作</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/firebase-asynchronous-operations-with-admin-java-sdk-82ca9b4f6022?source=collection_archive---------0-----------------------#2017-12-05">https://medium.com/google-cloud/firebase-asynchronous-operations-with-admin-java-sdk-82ca9b4f6022?source=collection_archive---------0-----------------------#2017-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/a183d23ca190768be82fdd3909d89379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsTFAbVFzABN3G7P_onIQA.jpeg"/></div></div></figure><div class=""/><p id="fdf4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://firebase.google.com/docs/admin/setup" rel="noopener ugc nofollow" target="_blank"> Firebase Admin Java SDK </a>的版本<a class="ae jo" href="https://firebase.google.com/support/release-notes/admin/java#5.4.0" rel="noopener ugc nofollow" target="_blank"> 5.4.0 </a>对SDK处理线程和异步操作的方式进行了重大改进。在这些变化中，<code class="du jp jq jr js b"><a class="ae jo" href="https://firebase.google.com/docs/reference/admin/java/reference/com/google/firebase/tasks/Task" rel="noopener ugc nofollow" target="_blank">Task</a></code>界面的弃用和<code class="du jp jq jr js b"><a class="ae jo" href="https://googleapis.github.io/api-common-java/1.1.0/apidocs/com/google/api/core/ApiFuture.html" rel="noopener ugc nofollow" target="_blank">ApiFuture</a></code>界面的引入可能是最值得注意的。这些变化跨越了Admin Java SDK公开的多个API，并对开发人员如何使用SDK编写代码产生了显著的影响。这篇文章讨论了这些变化背后的基本原理，并解释了如何将Java应用程序从Tasks迁移到ApiFutures。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="8b27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Admin Java SDK中的大多数公共API方法都是异步的。也就是说，调用方不会在方法上受阻。SDK只是将方法体的执行提交给一个工作线程池，然后立即返回给调用者一个表示提交操作的对象。直到SDK的5.4.0版本，这个返回的对象是一个<code class="du jp jq jr js b">Task&lt;T&gt;</code>的实例，其中通用类型参数<code class="du jp jq jr js b">T</code>表示异步操作产生的结果的类型。例如，<a class="ae jo" href="https://firebase.google.com/docs/auth/admin/create-custom-tokens" rel="noopener ugc nofollow" target="_blank">创建定制jwt</a>的<code class="du jp jq jr js b">FirebaseAuth.createCustomToken()</code>方法将返回一个<code class="du jp jq jr js b">Task&lt;String&gt;</code>。</p><p id="b59e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">Task</code>接口支持注册在底层异步操作完成时触发的回调。它还有助于延续——即链接多个异步操作，这样一个操作产生的结果可以通过管道传递给另一个操作。</p><p id="61d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Admin Java SDK的5.4.0版本不赞成使用<code class="du jp jq jr js b">Task</code>接口，以及所有返回<code class="du jp jq jr js b">Task&lt;T&gt;</code>的公共API方法。SDK现在推荐使用新引入的返回<code class="du jp jq jr js b">ApiFuture&lt;T&gt;</code>的<code class="du jp jq jr js b">*Async()</code>方法。例如，代替<code class="du jp jq jr js b">FirebaseAuth.createCustomToken()</code>，开发人员现在被建议使用<code class="du jp jq jr js b">FirebaseAuth.createCustomTokenAsync()</code>方法，它返回一个<code class="du jp jq jr js b">ApiFuture&lt;String&gt;</code>。SDK中的所有其他公共方法都引入了类似的替换。这些新方法在功能上等同于它们不推荐使用的对应方法。也就是说，它们还将方法执行提交给一个工作线程池，并立即返回。但是表示异步操作的返回对象属于不同的类型。</p><p id="df0c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在架构上，<code class="du jp jq jr js b">Task</code>和<code class="du jp jq jr js b">ApiFuture</code>接口代表了两种不同风格的异步编程。因此，他们看起来很不一样。然而，它们可以用来实现相同的用例，因此从一个用例迁移到另一个用例通常是微不足道的，我们很快就会看到。</p><h2 id="9bbb" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">为什么不推荐<code class="du jp jq jr js b">Task interface</code>？</h2><p id="790d" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">此举有两个主要原因:</p><ol class=""><li id="1a07" class="la lb ht is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">大多数服务器端Java库——包括<a class="ae jo" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>提供的库——使用Java的内置<code class="du jp jq jr js b"><a class="ae jo" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank">Future</a></code>接口(或其子接口)公开异步操作。我们希望Admin Java SDK看起来更像那些库，这样服务器端的Java开发人员会有宾至如归的感觉。我们还想在同一个应用程序中混合使用Firebase和GCP库时，提供一致的开发人员体验。</li><li id="c332" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">在Admin Java SDK的早期，<code class="du jp jq jr js b">Task</code>接口和相关的实用程序是从<a class="ae jo" href="https://developers.google.com/android/reference/com/google/android/gms/tasks/Task" rel="noopener ugc nofollow" target="_blank">Android Google Mobile Services(GMS)API</a>中派生出来的。将这些代码与Android GMS保持同步，并且维护它们变得很麻烦。</li></ol><p id="94ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为Android API的界面应该不会让你感到惊讶。这个API提倡的<em class="lo">基于回调的</em>编程风格在Android这样的客户端平台上很流行。客户端应用程序通常依赖于图形用户界面(GUI)。因此，他们被期望具有高度的交互性和响应性。想象一个有按钮的移动应用程序，点击按钮就可以进行一些计算，结果显示在屏幕上。<code class="du jp jq jr js b">Task</code>是实现这个用例的完美抽象。当点击按钮时，应用程序可以启动一个<code class="du jp jq jr js b">Task</code>，GUI更新逻辑可以作为对那个<code class="du jp jq jr js b">Task</code>的回调来实现。这样，接收用户输入的GUI工作线程永远不会被阻塞，GUI始终保持响应。</p><p id="6665" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相比之下，大多数服务器端应用程序不必是交互式的。它们通常没有GUI，而是为大规模的机器对机器交互而设计的。因此，服务器端Java应用程序倾向于优先考虑规模和减少端到端请求延迟，而不是GUI体验。在这种情况下，开发人员通常需要的是简单的<a class="ae jo" href="https://en.wikipedia.org/wiki/Fork%E2%80%93join_model" rel="noopener ugc nofollow" target="_blank"> <em class="lo"> fork-join </em> </a>风格的异步编程。这是一个程序在并行线程中分叉一组潜在的昂贵操作的地方，如果需要的话，以后再加入它们。这个<code class="du jp jq jr js b">Future</code>界面非常棒。</p><p id="8cac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这些复杂性，很明显为什么基于Futures的API更适合管理Java SDK。然而，我们也不想完全放弃回调。在许多事件驱动和反应式系统中，回调是必须的(即使在服务器端)。因此，我们没有选择内置的<code class="du jp jq jr js b">Future</code>接口，而是从<a class="ae jo" href="https://github.com/googleapis/api-common-java" rel="noopener ugc nofollow" target="_blank"> Google API Common </a>项目中选择了一个更丰富的子接口——T6。ApiFutures提供了两个世界的最佳选择。它们源自Java的同一个内置<code class="du jp jq jr js b">Future</code>接口，但也支持添加回调。此外，几个GCP库也采用了ApiFutures，这就更有理由在Firebase Admin Java SDK中使用相同的接口。</p><h2 id="f703" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">从任务迁移到ApiFutures</h2><p id="aa4b" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">下面是一组代码示例，演示了如何将Java代码从任务迁移到ApiFutures。每个示例展示了任务的某个特性，以及使用ApiFutures的等价代码。如果您有任何使用任务的代码，那么您很可能会大量使用回调。因此，让我们从演示如何向<code class="du jp jq jr js b">ApiFuture</code>添加回调开始。</p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单1:向任务和ApiFuture添加回调</figcaption></figure><p id="e9a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个例子有几个值得注意的地方:</p><ol class=""><li id="eb89" class="la lb ht is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">任务接口直接公开添加回调的方法(如<code class="du jp jq jr js b">addOnSuccessListener()</code>和<code class="du jp jq jr js b">addOnFailureListener()</code>)。但是要给<code class="du jp jq jr js b">ApiFuture</code>添加回调，必须使用<code class="du jp jq jr js b"><a class="ae jo" href="https://googleapis.github.io/api-common-java/1.1.0/apidocs/com/google/api/core/ApiFutures.html" rel="noopener ugc nofollow" target="_blank">ApiFutures</a></code>助手类中的静态<code class="du jp jq jr js b">addCallback()</code>方法。</li><li id="b626" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated"><code class="du jp jq jr js b">Task</code>接口便于添加单独的回调来处理成功、失败和完成事件。另一方面,<code class="du jp jq jr js b">ApiFuture</code>有一个不太灵活的API来添加回调，从某种意义上说，它只支持一种类型的回调——<code class="du jp jq jr js b"><a class="ae jo" href="https://googleapis.github.io/api-common-java/1.1.0/apidocs/com/google/api/core/ApiFutureCallback.html" rel="noopener ugc nofollow" target="_blank">ApiFutureCallback</a></code>,它处理成功和失败事件。</li><li id="8e70" class="la lb ht is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">在这两个API接口中，对于可以添加的回调的数量没有限制，并且对于回调执行时的顺序也没有保证。</li></ol><p id="57ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好奇的开发人员可能想知道清单1中添加的<code class="du jp jq jr js b">ApiFutureCallback</code>在哪一个线程上执行。如果在调用<code class="du jp jq jr js b">addCallback()</code>时底层异步操作还没有完成，回调将在异步操作完成时在同一线程上运行。如果操作已经完成，回调会立即在调用<code class="du jp jq jr js b">addCallback()</code>的线程上运行。当回调简单而短暂时，这种行为已经足够好了。如果你的回调是昂贵的，或者如果你希望在这方面有更多可预测的语义，你应该使用接受一个<code class="du jp jq jr js b"><a class="ae jo" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html" rel="noopener ugc nofollow" target="_blank">Executor</a></code>作为第三个参数的<code class="du jp jq jr js b">ApiFutures.addCallback()</code>覆盖。<em class="lo"> [ </em> <strong class="is hu"> <em class="lo">注意:</em> </strong> <em class="lo">此覆盖仅在Google API Common的1.2.0版本之后可用，而最新的Admin SDK (5.5.0)随1.1.0版本一起提供。在这个问题解决之前，必须手动升级Google API Common才能使用新方法。】</em></p><p id="9c9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来我们将讨论如何迁移<code class="du jp jq jr js b">Task</code>延续。continuation转换异步操作的输出，并将聚合计算(异步操作+转换)公开为新的<code class="du jp jq jr js b">Task</code>。这个动作的递归特性有效地实现了异步操作序列的链接。清单2显示了将由<code class="du jp jq jr js b">Task&lt;String&gt;</code>产生的字符串转换成字符串列表的延续。产生的聚合计算由<code class="du jp jq jr js b">Task&lt;List&lt;String&gt;&gt;</code>的实例表示。</p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单2:任务和ApiFutures的延续</figcaption></figure><p id="995e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，<code class="du jp jq jr js b"><a class="ae jo" href="https://googleapis.github.io/api-common-java/1.1.0/apidocs/com/google/api/core/ApiFunction.html" rel="noopener ugc nofollow" target="_blank">ApiFunction</a></code>接口扮演了现在已经废弃的<code class="du jp jq jr js b"><a class="ae jo" href="https://firebase.google.com/docs/reference/admin/java/reference/com/google/firebase/tasks/Continuation" rel="noopener ugc nofollow" target="_blank">Continuation</a></code>接口的角色。<code class="du jp jq jr js b">ApiFutures.transform()</code>助手方法将产生的聚合计算作为<code class="du jp jq jr js b">ApiFuture&lt;List&lt;String&gt;&gt;</code>的实例公开。还有一个<code class="du jp jq jr js b"><a class="ae jo" href="https://googleapis.github.io/api-common-java/1.1.0/apidocs/com/google/api/core/ApiAsyncFunction.html" rel="noopener ugc nofollow" target="_blank">ApiAsyncFunction</a></code>接口和一个<code class="du jp jq jr js b">ApiFutures.transformAsync()</code>助手方法，用于转换本身需要进行异步调用的情况。</p><p id="6d85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">清单3演示了如何在ApiFutures中包装值和异常。使用Admin SDK的开发人员几乎没有理由使用它，因为SDK已经提供了返回ApiFutures的方法。这里提到它是为了完整性。</p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单3:包装值和异常</figcaption></figure><p id="dfbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在向立即<code class="du jp jq jr js b">ApiFuture</code>添加回调或转换时要小心。它们将总是在<code class="du jp jq jr js b">addCallback()</code>或<code class="du jp jq jr js b">transform()</code>方法的调用线程上执行。如果这不是所期望的行为，那么在调用那些帮助器方法时应该指定一个显式的<code class="du jp jq jr js b">Executor</code>。</p><p id="8537" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">清单4展示了如何等待异步操作完成。<code class="du jp jq jr js b">Tasks</code>助手类需要等待一个<code class="du jp jq jr js b">Task</code>。但是对于一个<code class="du jp jq jr js b">ApiFuture</code>来说就相当琐碎了。</p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单4:等待任务和ApiFutures</figcaption></figure><p id="9bb7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时我们想创建一个不完整的异步操作，稍后再完成它。当您希望将任意代码块表示为异步操作时，这通常很有用。对于任务，这是通过使用<code class="du jp jq jr js b"><a class="ae jo" href="https://firebase.google.com/docs/reference/admin/java/reference/com/google/firebase/tasks/TaskCompletionSource" rel="noopener ugc nofollow" target="_blank">TaskCompletionSource</a></code>实现的。清单5中的最后一个代码示例展示了如何用一个<code class="du jp jq jr js b">ApiFuture</code>替换一个<code class="du jp jq jr js b">TaskCompletionSource</code>。</p><figure class="lp lq lr ls fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单5:不完整的异步操作</figcaption></figure><h2 id="90b3" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku bi translated">结论</h2><p id="40cb" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">自从Java Admin SDK的5.4.0版本发布以来，我已经看到了一些关于<code class="du jp jq jr js b">ApiFuture</code>接口的更多细节和例子的询问。我希望这篇文章能解决这些问题，同时缓解从T1到T2移民的紧张局势。我还邀请Firebase Java社区来看看新添加的<code class="du jp jq jr js b"><a class="ae jo" href="https://firebase.google.com/docs/reference/admin/java/reference/com/google/firebase/ThreadManager" rel="noopener ugc nofollow" target="_blank">ThreadManager</a></code>接口，它支持为Admin SDK配置线程池和线程工厂。它对SDK如何调度和执行异步操作提供了更好的控制。</p><p id="08d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">展望未来，我们可以期待Admin SDK中围绕<code class="du jp jq jr js b">ApiFuture</code>支持的更多特性、稳定性和文档。Firebase还使管理SDK APIs与各种GCP库的无缝混合和匹配变得更加容易(已经支持<a class="ae jo" href="https://cloud.google.com/storage/" rel="noopener ugc nofollow" target="_blank">谷歌云存储</a>和<a class="ae jo" href="http://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank">谷歌云Firestore </a>)。如果你正在关注<a class="ae jo" href="https://github.com/firebase/firebase-admin-java/issues/55" rel="noopener ugc nofollow" target="_blank"> Java Admin SDK GitHub repo </a>，你可能已经看到了从SDK中公开一组阻塞API的努力。在评论和GitHub上分享你的想法。让我们知道您如何使用Java Admin SDK，以及如何进一步改善开发人员的体验。</p></div></div>    
</body>
</html>