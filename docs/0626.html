<html>
<head>
<title>Dockerfile Go HEALTHCHECKs &amp; K8s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dockerfile Go健康检查和K8s</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/dockerfile-go-healthchecks-k8s-9a87d5c5b4cb?source=collection_archive---------1-----------------------#2018-05-30">https://medium.com/google-cloud/dockerfile-go-healthchecks-k8s-9a87d5c5b4cb?source=collection_archive---------1-----------------------#2018-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6073" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新2018–05–30</strong>:修正了各种错误。抱歉。</p><p id="b326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到最近，我在探索谷歌Trillian和这个项目在Kubernetes和本地使用Docker Compose运行Trillian时，才遇到Docker的HEALTHCHECK。</p><p id="7d4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在探索最小化容器图像大小的方法时，我碰到了Docker的HEALTHCHECK需要在容器中有一些东西来执行healthcheck，通常是<code class="du je jf jg jh b">curl</code>。</p><p id="2838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最小容器中，没有<code class="du je jf jg jh b">curl</code>。</p><blockquote class="ji jj jk"><p id="2eae" class="if ig jl ih b ii ij ik il im in io ip jm ir is it jn iv iw ix jo iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong> : <code class="du je jf jg jh b">curl</code>很优秀。这不是批评<code class="du je jf jg jh b">curl</code>。这是对容器图像膨胀的批评。</p></blockquote><p id="881e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聪明的人以前考虑过这个问题，这个故事总结了他们的工作和解决方案。下面是埃尔顿·斯通汉姆的“<a class="ae jd" href="https://blog.sixeyed.com/docker-healthchecks-why-not-to-use-curl-or-iwr/" rel="noopener ugc nofollow" target="_blank">为什么不用</a> <code class="du je jf jg jh b"><a class="ae jd" href="https://blog.sixeyed.com/docker-healthchecks-why-not-to-use-curl-or-iwr/" rel="noopener ugc nofollow" target="_blank">curl</a></code> <a class="ae jd" href="https://blog.sixeyed.com/docker-healthchecks-why-not-to-use-curl-or-iwr/" rel="noopener ugc nofollow" target="_blank">或者</a> <code class="du je jf jg jh b"><a class="ae jd" href="https://blog.sixeyed.com/docker-healthchecks-why-not-to-use-curl-or-iwr/" rel="noopener ugc nofollow" target="_blank">iwr</a></code>”</p><p id="bec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我以前讨论过最小容器图像的好处。在这种情况下，Trillian是用Golang编写的，这提供了使用<code class="du je jf jg jh b"><a class="ae jd" href="https://hub.docker.com/_/scratch/" rel="noopener ugc nofollow" target="_blank">scratch</a></code>容器的机会，或者——在这种情况下——我想我会尝试Google的<code class="du je jf jg jh b"><a class="ae jd" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">distroless</a></code>图像。这些图片和busybox和alpine不包括<code class="du je jf jg jh b">curl</code>。</p><p id="8230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个带有运行状况检查的Dockerfile文件示例:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="4543" class="jx jy hi jh b fi jz ka l kb kc">ENV HTTP_PORT=8091</span><span id="8905" class="jx jy hi jh b fi kd ka l kb kc">HEALTHCHECK --interval=5m --timeout=3s \<br/>  CMD curl -f <a class="ae jd" href="http://localhost:$HTTP_PORT/debug/vars" rel="noopener ugc nofollow" target="_blank">http://localhost:$HTTP_PORT/debug/vars</a> || exit 1</span></pre><p id="63fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这取决于<code class="du je jf jg jh b">curl</code>，但是对于<code class="du je jf jg jh b">curl</code>的需求是微不足道的。<code class="du je jf jg jh b">curl</code>用于使HTTP GET。许多工作(间隔、超时、响应处理)都内置在Dockerfile的HEALTHCHECK功能中。</p><h2 id="3886" class="jx jy hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">Golang健康检查</h2><p id="17ff" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">所以，如果我们能用更简单的东西(最好是Golang)来代替<code class="du je jf jg jh b">curl</code>的通用功能，我们就成功了。</p><p id="02da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见Soluto的<a class="ae jd" href="https://github.com/Soluto/golang-docker-healthcheck-example" rel="noopener ugc nofollow" target="_blank">golang-docker-health check-example</a>。</p><p id="d630" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没错。</p><p id="21e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在充分肯定他们的同时，我对他们的解决方案做了一点小小的调整:</p><figure class="jp jq jr js fd lc"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="cb03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以由此创建一个静态二进制文件，并将其合并到Docker映像中。这是针对Linux AMD64的:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="dd84" class="jx jy hi jh b fi jz ka l kb kc">CGO_ENABLED=0 \<br/>GOOS=linux \<br/>GOARCH=amd64 \<br/>go build -a -tags netgo  healthcheck.go</span></pre><p id="6caf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，在发行版的情况下，有一个方便的模式结合了Docker的多阶段构建。</p><h2 id="40e1" class="jx jy hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">多阶段构建</h2><p id="f4ff" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated"><strong class="ih hj">在</strong>之前:这个Dockerfile生成一个1.2GB的图像(需要<code class="du je jf jg jh b">curl</code>)。</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="feff" class="jx jy hi jh b fi jz ka l kb kc">FROM golang:1.10</span><span id="a7ea" class="jx jy hi jh b fi kd ka l kb kc">ENV HTTP_PORT=8091</span><span id="23ae" class="jx jy hi jh b fi kd ka l kb kc">ADD . /go/src/github.com/google/trillian<br/>WORKDIR /go/src/github.com/google/trillian</span><span id="997b" class="jx jy hi jh b fi kd ka l kb kc">RUN go get ./server/trillian_log_server</span><span id="ec13" class="jx jy hi jh b fi kd ka l kb kc">ENTRYPOINT ["/go/bin/trillian_log_server"]</span><span id="b6f4" class="jx jy hi jh b fi kd ka l kb kc">HEALTHCHECK --interval=5m --timeout=3s \<br/>  CMD curl -f <a class="ae jd" href="http://localhost:$HTTP_PORT/debug/vars" rel="noopener ugc nofollow" target="_blank">http://localhost:$HTTP_PORT/debug/vars</a> || exit 1</span></pre><p id="1535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转换为多阶段，以便我们先构建，然后将二进制文件复制到运行时映像中。我们也必须在这里修复健康检查，因为<code class="du je jf jg jh b">curl</code>要和<code class="du je jf jg jh b">distroless.</code>说再见了</p><p id="d8aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后<strong class="ih hj">:这个docker文件生成一个45MB的镜像(并转储<code class="du je jf jg jh b">curl</code>)</strong></p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="1680" class="jx jy hi jh b fi jz ka l kb kc">FROM golang:1.10 as build</span><span id="b4ab" class="jx jy hi jh b fi kd ka l kb kc">ADD . /go/src/github.com/google/trillian<br/>WORKDIR /go/src/github.com/google/trillian</span><span id="a98c" class="jx jy hi jh b fi kd ka l kb kc">RUN go get ./server/trillian_log_server<br/>RUN go get ./healthcheck</span><span id="92c1" class="jx jy hi jh b fi kd ka l kb kc">FROM gcr.io/distroless/base as runtime</span><span id="966c" class="jx jy hi jh b fi kd ka l kb kc">COPY --from=build /go/bin/trillian_log_server /<br/>COPY --from=build /go/bin/healthcheck /</span><span id="0ae1" class="jx jy hi jh b fi kd ka l kb kc">ENTRYPOINT ["/trillian_log_server"]</span><span id="0fdd" class="jx jy hi jh b fi kd ka l kb kc">HEALTHCHECK \<br/>  --interval=5m \<br/>  --timeout=3s \<br/>  CMD ["/healthcheck","<a class="ae jd" href="http://localhost:$HTTP_PORT/debug/vars" rel="noopener ugc nofollow" target="_blank">http://localhost:8091/debug/vars</a>"]</span></pre><p id="6a7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，让我们来看看这个:</p><p id="b960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要一种从一个步骤引用另一个步骤的方法，而<code class="du je jf jg jh b">as [name]</code>就是我们如何做的。我们将构建步骤称为… <code class="du je jf jg jh b">build</code>:</p><p id="ebb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">FROM golang:1.10 <strong class="ih hj">as build</strong></code></p><p id="06a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我作弊，把Golang <code class="du je jf jg jh b">healthcheck</code>直接加到了Trillian repo的克隆里。这意味着<code class="du je jf jg jh b">healthcheck</code>现在是由<code class="du je jf jg jh b">ADD</code>命令添加的<code class="du je jf jg jh b">Trillian</code>树的一部分，这意味着我可以这样做来构建它，在本例中是<code class="du je jf jg jh b">trillian_log_server</code>:</p><p id="32ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">RUN go get ./healthcheck</code></p><p id="3c59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好，然后我们进入<code class="du je jf jg jh b">distroless</code>容器。即使它没有被使用，它也被命名为<code class="du je jf jg jh b">runtime</code>:</p><p id="090b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">FROM gcr.io/distroless/base as runtime</code></p><blockquote class="ji jj jk"><p id="6f48" class="if ig jl ih b ii ij ik il im in io ip jm ir is it jn iv iw ix jo iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>在<code class="du je jf jg jh b">distroless</code>下有很多运行时的图像，在这里查看列表<a class="ae jd" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">。有了Golang，我们不需要太多，所以我们可以使用发行版的基本映像。</a></p></blockquote><p id="2679" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要使用<code class="du je jf jg jh b">build</code>参考。我们需要将二进制文件从<code class="du je jf jg jh b">build</code>映像复制到<code class="du je jf jg jh b">runtime</code>映像中。对此我们使用<code class="du je jf jg jh b">COPY — from-build</code>。每个二进制文件一个。服务器和运行状况检查:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="4e31" class="jx jy hi jh b fi jz ka l kb kc"><strong class="jh hj">COPY --from=build</strong> /go/bin/trillian_log_server /<br/><strong class="jh hj">COPY --from=build</strong> /go/bin/healthcheck /</span></pre><p id="9ff3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是(而且我不明白这是为什么——有人吗？)在这个版本中不能使用环境变量(<code class="du je jf jg jh b">${HTTP_PORT}</code>)。出于某种原因，它就是不工作:-(。Docker在图像中的环境变量映射*总是*具有挑战性。</p><p id="a461" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为容器定义入口点，以运行服务器。</p><p id="1fe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用显式端口映射来定义我们的健康检查:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="e4cd" class="jx jy hi jh b fi jz ka l kb kc">HEALTHCHECK \<br/>  --interval=5m \<br/>  --timeout=3s \<br/>  CMD [<strong class="jh hj">"/healthcheck"</strong>,"<a class="ae jd" href="http://localhost:$HTTP_PORT/debug/vars" rel="noopener ugc nofollow" target="_blank">http://localhost:8091/debug/vars</a>"]</span></pre><p id="e751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">健康检查现在指向Golang二进制文件(<code class="du je jf jg jh b">/healthcheck</code>)和我们指定的端点(<code class="du je jf jg jh b">/debug/vars</code>),最重要的是，没有额外的依赖或工具。两个小Golang二进制文件。</p><p id="92dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们要在本地部署这样一个容器，Docker的CLI将用健康检查的状态来丰富例如容器列表:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="0c2c" class="jx jy hi jh b fi jz ka l kb kc">docker container ls<br/>CONTAINER ID        COMMAND               STATUS<br/><strong class="jh hj">1c64</strong>d39fbb9a        /trillian_log_server  Up 15 seconds (healthy)</span></pre><p id="9d8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以列举运行状况检查:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="7cc8" class="jx jy hi jh b fi jz ka l kb kc">docker inspect --format='{{json .State.Health}}' <strong class="jh hj">1c64</strong> \<br/>| jq .<br/>{<br/>  "Status": "healthy",<br/>  "FailingStreak": 0,<br/>  "Log": [<br/>    {<br/>      "Start": "2018-05-30T00:00:00.000000000-07:00",<br/>      "End": "2018-05-30T00:00:00.000000000-07:00",<br/>      "ExitCode": 0,<br/>      "Output": "<a class="ae jd" href="http://localhost:8080/healthz\n" rel="noopener ugc nofollow" target="_blank">http://localhost:</a><a class="ae jd" href="http://localhost:$HTTP_PORT/debug/vars" rel="noopener ugc nofollow" target="_blank">8091/debug/vars</a>"<br/>    },<br/>    {<br/>      "Start": "2018-05-30T00:00:00.000000000-07:00",<br/>      "End": "2018-05-30T00:00:00.000000000-07:00",<br/>      "ExitCode": 0,<br/>      "Output": "<a class="ae jd" href="http://localhost:8080/healthz\n" rel="noopener ugc nofollow" target="_blank">http://localhost:</a><a class="ae jd" href="http://localhost:$HTTP_PORT/debug/vars" rel="noopener ugc nofollow" target="_blank">8091/debug/vars</a>"<br/>    }<br/>  ]<br/>}</span></pre><p id="22ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了Trillian，这个映像可以部署到Kubernetes。您可以获取它的Pod(名称)，将其转发到端口并测试healthcheck端点:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="435e" class="jx jy hi jh b fi jz ka l kb kc">kubectl get pods</span><span id="5719" class="jx jy hi jh b fi kd ka l kb kc">NAME                                             READY     STATUS<br/>trillian-etcd-cluster-9hfhkxxcsf                 1/1       Running<br/>trillian-etcd-cluster-gbz4mfqgvr                 1/1       Running<br/>trillian-etcd-cluster-z268b5z9h2                 1/1       Running<br/>trillian-etcd-operator-5bfd8fc6db-s9r2b          1/1       Running<br/>trillian-logserver-deployment-546d8bd546-7l77l   2/2       Running<br/>trillian-logserver-deployment-546d8bd546-g8gdw   2/2       Running<br/>trillian-logserver-deployment-546d8bd546-pnlfr   2/2       Running<br/>trillian-logserver-deployment-546d8bd546-z6n74   2/2       Running<br/>trillian-logsigner-deployment-5548878bbd-knlvr   2/2       Running<br/>trillian-logsigner-deployment-5548878bbd-xfph8   2/2       Running</span></pre><p id="e646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任意抓取<code class="du je jf jg jh b">trillian-logserver-deployment-546d8bd546-pnlfr</code>:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="ff09" class="jx jy hi jh b fi jz ka l kb kc">kubectl port-forward \<br/>trillian-logserver-deployment-546d8bd546-pnlfr \<br/>8091:8091</span><span id="2e76" class="jx jy hi jh b fi kd ka l kb kc">Forwarding from 127.0.0.1:8091 -&gt; 8091<br/>Forwarding from [::1]:8091 -&gt; 8091</span></pre><p id="61ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="3b52" class="jx jy hi jh b fi jz ka l kb kc">curl localhost:8091/debug/vars</span><span id="9feb" class="jx jy hi jh b fi kd ka l kb kc">ok</span></pre><h2 id="d9e8" class="jx jy hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">超级网络</h2><p id="1d4f" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">这让我们想到了第二个建议，当使用Docker和Kubernetes时，这个建议变得更加一致。</p><blockquote class="ji jj jk"><p id="b811" class="if ig jl ih b ii ij ik il im in io ip jm ir is it jn iv iw ix jo iz ja jb jc hb bi translated"><strong class="ih hj">题外话</strong> : Kubernetes提供<a class="ae jd" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="noopener ugc nofollow" target="_blank">活跃度和就绪性探测</a>。这些适用于容器级别。豆荚聚合容器。因此，pod可以针对每个容器进行特定的活性和就绪性探测。活性对应于健康检查(容器是否在运行),而就绪性——顾名思义——是确定容器是否准备好接受流量；容器中的服务器可以启动并暴露端点(活跃度)，但是在它准备好接受流量(准备就绪)之前可能需要额外的时间。</p></blockquote><p id="2504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes活跃度探测器经常模仿Docker健康检查并使用<code class="du je jf jg jh b">curl</code>，例如:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="2633" class="jx jy hi jh b fi jz ka l kb kc">livenessProbe:<br/>  exec:<br/>    command:<br/>    - <strong class="jh hj">curl</strong><br/>    - --fail<br/>    - http://localhost:8091/debug/vars<br/>  failureThreshold: 3<br/>  periodSeconds: 30</span></pre><p id="4034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，我们已经转储了<code class="du je jf jg jh b">curl</code>，所以我们也不能在这里使用它。</p><p id="e9ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用我们的Golang <code class="du je jf jg jh b">/healthcheck</code>代替<code class="du je jf jg jh b">curl</code>，但是我们不需要这样做。Kubernetes的开发人员意识到大多数健康检查都是简单的HTTP GETs，所以…我们可以这样做:</p><pre class="jp jq jr js fd jt jh ju jv aw jw bi"><span id="a4bf" class="jx jy hi jh b fi jz ka l kb kc">livenessProbe:<br/>  <strong class="jh hj">httpGet</strong>:<br/>    path: /debug/vars<br/>    port: 8091<br/>  failureThreshold: 3<br/>  periodSeconds: 30<br/>  timeoutSeconds: 5</span></pre><h2 id="4c76" class="jx jy hi bd ke kf kg kh ki kj kk kl km iq kn ko kp iu kq kr ks iy kt ku kv kw bi translated">结论</h2><p id="79a4" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">最小化容器图像范围(以及大小)是一件好事。做好一件事是一个好原则，因为它的推论是，如果你做太多事情，你会做得最差。在容器映像中，太多的东西意味着更多的失败机会，更多的软件污染，更多的能源浪费，*而且*特别重要的是:更多的安全问题。</p><p id="7976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使我们的容器映像中唯一无关的工具是<code class="du je jf jg jh b">curl</code>，每次<code class="du je jf jg jh b">curl</code>被修补，我们都需要重新构建使用它的每个容器映像。</p><p id="8a3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从您的容器映像中排除可能有一天会用到的装满二进制文件的车库有很多好处，但是，有时也需要一个有用的工具。这篇文章提供了一种简单的方法来取代作为健康检查工具的<code class="du je jf jg jh b">curl</code>。</p><p id="09fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随时欢迎反馈。</p><p id="f533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p></div></div>    
</body>
</html>