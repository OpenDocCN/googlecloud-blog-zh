<html>
<head>
<title>Using Google Cloud Emulators in Integration Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在集成测试中使用Google Cloud模拟器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-google-cloud-emulators-for-integration-tests-7812890ebe0d?source=collection_archive---------0-----------------------#2017-06-16">https://medium.com/google-cloud/using-google-cloud-emulators-for-integration-tests-7812890ebe0d?source=collection_archive---------0-----------------------#2017-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2814" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章更像是关于如何使用Google Datastore模拟器和Google Pub/Sub模拟器进行测试的教程。以及如何通过为每个仿真器使用Docker容器来并行运行多个测试。</p><p id="e908" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> TLDR:完整的工作代码片段可以在</strong> <a class="ae jd" href="https://github.com/fkorotkov/snippets/blob/master/testcontainers/gcloud/datastore/src/test/kotlin/com/fkorotkov/snippets/testcontainers/gcloud/TestDatastore.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里</strong> </a> <strong class="ih hj">找到。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/50611336327d05a4ff45f96c750a557d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-2PICR4-0jQ6tpzX7mvmEg.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">运行集成测试时的“docker ps”</figcaption></figure><h2 id="1904" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">动机</h2><p id="5564" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我不太喜欢嘲笑周围的事物。或者在单元测试和生产中有不同的实现。对于在最关键的时刻会有一些不同行为的单元测试，使用内存中的DB有什么意义呢！？再加上维护测试和生产两个实现的开销。我个人无法对我在这样的测试后部署的代码有100%的信心。我想在尽可能类似于生产的环境中测试我的应用程序。</p><p id="2fa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近我真的很喜欢谷歌云平台。目前，我正在构建由大量用<a class="ae jd" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>编写的微服务组成的东西，这些微服务使用<a class="ae jd" href="http://www.grpc.io/" rel="noopener ugc nofollow" target="_blank"> GRPC </a>进行通信。所有内部服务都位于Kubernetes内部，唯一的外部服务是一些GCP产品，如数据存储和发布/订阅。</p><p id="b410" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果测试内部服务之间的通信，我可以使用GRPC的进程内通道，这是另一个帖子的好主题。在我的测试中，我遇到了一个为数据存储、发布/订阅和Blobstore等服务使用什么的问题。</p><h2 id="1442" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">履行</h2><p id="e529" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">一开始，我只是在终端标签中运行模拟器，命令如下:</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="20c2" class="ju jv hi kv b fi kz la l lb lc">gcloud beta emulators datastore start --no-legacy \<br/>  --project unit-testing-project-name \<br/>  --consistency=1</span></pre><p id="4513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我甚至发现没有很好地记录将仿真器重置为干净状态的<code class="du ld le lf kv b">http://localhost:&lt;port&gt;/reset</code>端点。我在每次测试之前都调用它，以确保在运行测试之前模拟器是干净的。它对于数据存储模拟器工作得很好，但是发布/订阅模拟器并不可靠，有时会出现错误。随着测试数量的增加，情况变得越来越糟。运行测试时，发布/订阅模拟器出错越来越频繁。另一个问题是我受限于顺序运行测试。没有办法在测试之间共享模拟器！唯一的方法是用不同的<code class="du ld le lf kv b">--host-port</code>标志运行模拟器的多个实例。</p><p id="5704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约在那个时候，我了解到一个叫做<a class="ae jd" href="https://github.com/testcontainers/testcontainers-java" rel="noopener ugc nofollow" target="_blank">测试容器</a>的令人敬畏的项目。想法很简单:提供干净的API在测试中使用Docker容器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lg"><img src="../Images/86a75e06373379d8c132d1dabf7dacdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjXzaw15-2QPs5dHRW9fmg.png"/></div></div></figure><p id="d062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想为什么不使用它，只是开始新的容器，为每个测试提供必要的模拟器！？是的，它会慢一些，但是它被证明是更可靠的，尤其是对于发布/订阅模拟器。我相信从长远来看，它会扩展得更好。我还把这个项目分成了60多个分项目。通过并行执行和梯度缓存<code class="du ld le lf kv b">test</code>任务，它不会对本地工作流产生太大影响。</p><p id="c0d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了开始在测试中使用模拟器，我们首先需要一个包含Google Cloud SDK的容器:</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="92ee" class="ju jv hi kv b fi kz la l lb lc">class GoogleCloudContainer : <br/>  GenericContainer&lt;GoogleCloudContainer&gt;("google/cloud-sdk:latest")</span></pre><p id="b43a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们简单地在一个伴生对象上定义一个字段(根据Kotlin基本上是一个静态字段),用于我们想要在其中使用容器的测试类:</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="9e05" class="ju jv hi kv b fi kz la l lb lc">val projectName = "testing"<br/>val emulatorPort = 8888</span><span id="8af4" class="ju jv hi kv b fi lh la l lb lc">@ClassRule @JvmField<br/>public val datastoreContainer: GoogleCloudContainer =<br/>  GoogleCloudContainer()<br/>    .withExposedPorts(emulatorPort)<br/>    .withCommand("/bin/sh", "-c",<br/>      """<br/>      gcloud beta emulators datastore start --no-legacy \<br/>        --project $projectName \<br/>        --host-port=0.0.0.0:$emulatorPort \<br/>        --consistency=1<br/>    """)</span></pre><p id="80fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>使用<code class="du ld le lf kv b">localhost</code>代替<code class="du ld le lf kv b">--host-port</code>不起作用。</p><p id="ec1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！现在可以构建数据存储服务来使用正在运行容器:</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="480f" class="ju jv hi kv b fi kz la l lb lc">val datastoreService: Datastore by <em class="li">lazy </em><strong class="kv hj">{<br/>  </strong>val host = datastoreContainer.<em class="li">containerIpAddress<br/>  </em>val port = datastoreContainer.getMappedPort(emulatorPort)<br/><br/>  DatastoreOptions.newBuilder()<br/>    .setProjectId(projectName)<br/>    .setHost("$host:$port")<br/>    .setCredentials(NoCredentials.getInstance())<br/>    .build()<br/>    .<em class="li">service<br/></em><strong class="kv hj">}</strong></span></pre><p id="144e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这么简单！数据存储的完整代码片段可以在<a class="ae jd" href="https://github.com/fkorotkov/snippets/blob/master/testcontainers/gcloud/datastore/src/test/kotlin/com/fkorotkov/snippets/testcontainers/gcloud/TestDatastore.kt" rel="noopener ugc nofollow" target="_blank">这里</a>找到。发布/订阅片段也可在<a class="ae jd" href="https://github.com/fkorotkov/snippets/blob/master/testcontainers/gcloud/pubsub/src/test/kotlin/com/fkorotkov/snippets/testcontainers/gcloud/TestPubSub.kt" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h2 id="5d8c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">自动杀死过期容器</h2><p id="aa2e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">使用测试容器需要注意的一点是，如果你调试了一个测试并终止了一个JVM，那么容器就不会被清理。谢天谢地，测试容器用<code class="du ld le lf kv b">org.testcontainers=true</code>标记所有容器。我简单地向Gradle添加了一个清理任务，以便在运行测试之前删除任何容器:</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="bf57" class="ju jv hi kv b fi kz la l lb lc">task stopTestContainers(type: Exec) {<br/>  executable "sh"<br/>  args "-c", 'docker ps -q -f "label=org.testcontainers=true" ' +<br/>    '| xargs docker rm -f'<br/>}<br/><br/>test.dependsOn stopTestContainers</span></pre><h2 id="3222" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">结论</h2><p id="81a0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">测试容器对于在测试中进行生产非常有用。事实证明他们非常可靠。试试看！</p></div></div>    
</body>
</html>