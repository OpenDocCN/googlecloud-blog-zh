<html>
<head>
<title>Running a MEAN stack on Google Cloud Platform with Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes在Google云平台上运行平均堆栈</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/running-a-mean-stack-on-google-cloud-platform-with-kubernetes-149ca81c2b5d?source=collection_archive---------0-----------------------#2015-07-29">https://medium.com/google-cloud/running-a-mean-stack-on-google-cloud-platform-with-kubernetes-149ca81c2b5d?source=collection_archive---------0-----------------------#2015-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/d9b91c182e85c83f4f56a457c8c41dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ad9SgPvu1AM-I3YL3h0rxA.png"/></div></div></figure><p id="2b08" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在我最近的一篇文章中，我谈到了用T2的Docker容器运行一个普通的堆栈。</p><p id="d175" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">手动部署容器很好，但是相当脆弱和笨拙。如果应用崩溃了会怎么样？app怎么更新？回滚？</p><p id="999c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">这篇文章将对容器世界进行更深入的探讨。我假设你已经阅读/完成了第一部分</strong>  <strong class="ja hj">。有很多内容，但如果你只是浏览一下，所有步骤应该只需要15分钟左右！</strong></p><p id="2a01" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">幸运的是，我们可以使用一个名为<a class="ae jw" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的系统来管理集群环境中的容器。更好的是，Google有一个名为<a class="ae jw" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank"> Google Container Engine </a>的Kubernetes托管版本，因此您可以在几分钟内启动并运行。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="aae3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">背景:</h2><p id="08c6" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">在谷歌，很少有人真正登录生产机器来执行更新。有了数百万台服务器，你可以看到这是如何变得不可能的。手动登录服务器也为人为错误留下了空间。</p><p id="8320" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">相反，我们使用一个叫做<a class="ae jw" href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43438.pdf" rel="noopener ugc nofollow" target="_blank"> Borg </a>的系统来为我们进行管理。</p><p id="2ef9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">简而言之，你告诉博格运行X份你的工作，博格就会去做。乔布斯死了？博格将开始一个新的。健康检查失败？博格会停止这项工作并开始一项新的工作。</p><p id="517e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们吸取了Borg的经验教训，并开发了一个名为Kubernetes的开源项目。Kubernetes允许您管理一个机器集群，并在其上运行容器。相当酷的东西，它刚刚达到1.0版本！</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="4779" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">使用Kubernetes的基础</h2><p id="14f4" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">在我们开始讨论之前，了解一下Kubernetes的一些基本知识是很重要的。</p><ul class=""><li id="00fc" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated"><strong class="ja hj">容器:</strong>这些是Docker、rtk、AppC或者任何你正在运行的容器。你可以把这些想象成亚原子粒子。一切都是由它们组成的，但你很少(如果有的话)与它们直接互动。</li><li id="7e35" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated"><strong class="ja hj">豆荚:</strong>豆荚是库伯内特斯的基本成分。它们是一组容器，被安排在一起，一起生活，一起死亡。</li></ul><p id="3f89" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为什么您想要一组容器，而不仅仅是一个容器？假设您有一个日志处理器、一个网络服务器和一个数据库。如果您不能使用pod，那么您必须将日志处理器捆绑在web服务器和数据库容器中，并且每次更新其中一个时，您都必须更新另一个。有了pod，您可以为web服务器和数据库重用相同的日志处理器。</p><ul class=""><li id="e060" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated"><strong class="ja hj">复制控制器:</strong>这是Kubernetes的管理组件，非常酷。您给它一套pod，告诉它“我想要三份拷贝”，它会在您的集群上创建这些拷贝。它会尽最大努力保持这些副本始终运行，所以如果一个崩溃了，它就会启动另一个。</li><li id="dca9" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated"><strong class="ja hj">服务:</strong>这是复制控制器的另一面。服务是一组pod的单一联系点。例如，假设您有一个复制控制器，它创建了一个web服务器窗格的四个副本。一项服务将把流量分成四份。服务是“永久的”，而它们背后的吊舱可以来去自如，所以使用服务是一个好主意。</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="3eac" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">第1步:创建容器</h2><p id="fc85" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">在我之前的文章中，我使用现成的容器来保持简单。</p><p id="aa08" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我有一个库存MongoDB容器和一个库存Node.js容器。Mongo容器在没有任何修改的情况下运行良好。然而，我不得不手动输入Node容器来提取和运行代码。显然，这在Kubernetes的土地上并不理想，因为你不应该登录你的服务器！</p><p id="cd86" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">相反，您必须构建一个自定义容器，其中已经包含代码并自动运行。</p><p id="96cb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为此，您需要使用更多的Docker。确保在本教程的剩余部分安装了最新版本。</p><p id="b2b3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">获取代码:</strong></p><p id="92e0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">开始之前，让我们运行一些代码。您可以在您的个人机器上或云中的Linux虚拟机上继续。我建议使用Linux或Linux虚拟机；在Mac和Windows上运行Docker不在本教程的范围内。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="20d8" class="jx jy hi lm b fi lq lr l ls lt">$ git clone <a class="ae jw" href="https://github.com/ijason/NodeJS-Sample-App.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ijason/NodeJS-Sample-App.git</a> app<br/>$ mv app/EmployeeDB/* app/<br/>$ sed -i -- 's/localhost/mongo/g' ./app/app.js</span></pre><p id="2fa7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这是我们之前运行的同一个示例应用程序。第二行只是将EmployeeDB子文件夹中的所有内容移到应用程序文件夹中，以便于访问。第三行再次用<em class="lu"> mongo </em>代理替换了硬编码的<em class="lu"> localhost </em>。</p><p id="8edc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">打造码头工人形象:</strong></p><p id="bda8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">首先，您需要一个<em class="lu">文件</em>。这基本上是Docker用来构建容器图像的指令列表。</p><p id="1187" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">以下是网络服务器的文件目录:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="1179" class="jx jy hi lm b fi lq lr l ls lt">FROM node:0.10.40</span><span id="a272" class="jx jy hi lm b fi lv lr l ls lt">RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY ./app/ ./<br/>RUN npm install</span><span id="1f30" class="jx jy hi lm b fi lv lr l ls lt">CMD ["node", "app.js"]</span></pre><p id="a6dc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Dockerfiles非常不言自明，这个非常简单。</p><p id="5af9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">首先，它使用官方的Node.js图像作为基础图像。</p><p id="5dae" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">然后，它创建一个文件夹来存储代码，将代码复制到该目录中，并使用npm安装依赖项。</p><p id="f215" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">最后，它指定了容器启动时应该运行的命令Docker，也就是启动应用程序。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="c266" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">第2步:构建我们的容器</h2><p id="d917" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">现在，该目录应该如下所示:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="60af" class="jx jy hi lm b fi lq lr l ls lt">$ ls<br/>Dockerfile app</span></pre><p id="7134" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">让我们建造。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="0788" class="jx jy hi lm b fi lq lr l ls lt">$ docker build -t myapp .</span></pre><p id="7bcf" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这将为你的应用程序建立一个新的Docker映像。这可能需要几分钟时间，因为它正在下载和构建所有内容。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="da5b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">补充说明:</strong>在图像名称前面放一个用户id是一个好习惯，例如:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="b265" class="jx jy hi lm b fi lq lr l ls lt">$ docker build -t my-user-id/myapp .</span></pre><p id="c25e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">但在本教程中，我将忽略这种做法。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="bbb7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">完成后，进行测试:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="9510" class="jx jy hi lm b fi lq lr l ls lt">$ docker run myapp</span></pre><p id="848d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">此时，您应该有一个运行在http://localhost:3000上的服务器(如果您在Mac或Windows上，这就不会那么简单了)。由于没有数据库运行，网站会出错，但我们知道它是有效的！</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lw"><img src="../Images/dbbc790b93b9c8e875f5f6ffc8fb53ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRFOLDCPqMAdAFNcXF37lQ.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="acf7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">第三步:推动我们的容器</h2><p id="75af" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">现在你有了一个定制的Docker映像，你必须从云中访问它。</p><p id="b8f0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">由于我们将通过谷歌容器引擎使用图像，推送图像的最佳地点是<a class="ae jw" href="https://cloud.google.com/tools/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册中心</a>。容器注册表建立在<a class="ae jw" href="https://cloud.google.com/storage/" rel="noopener ugc nofollow" target="_blank">谷歌云存储</a>之上，所以你可以从容器引擎获得可扩展存储和快速访问的优势。</p><p id="ae2c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">首先，确保你已经安装了最新版本的<a class="ae jw" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank">Google Cloud SDK</a>。</p><p id="a199" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae jw" href="https://dl.google.com/dl/cloudsdk/release/GoogleCloudSDKInstaller.exe" rel="noopener ugc nofollow" target="_blank"> Windows用户点击此处。</a></p><p id="5339" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">对于Linux/Mac:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="420d" class="jx jy hi lm b fi lq lr l ls lt">$ curl https://sdk.cloud.google.com | bash</span></pre><p id="c25c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">然后，确保您<strong class="ja hj">登录并更新</strong>。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="e798" class="jx jy hi lm b fi lq lr l ls lt">$ gcloud auth login<br/>$ gcloud components update</span></pre><p id="5efc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在你可以推集装箱了。我们需要我们的谷歌云项目ID(我们在<a class="ae jw" href="http://blog.sandeepdinesh.com/2015/07/running-mean-web-application-in-docker.html" rel="noopener ugc nofollow" target="_blank">第一部分</a>做了一个)。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="f4ff" class="jx jy hi lm b fi lq lr l ls lt">$ docker tag myapp gcr.io/&lt;YOUR-PROJECT-ID&gt;/myapp<br/>$ gcloud docker -- push gcr.io/&lt;YOUR-PROJECT-ID&gt;/myapp</span></pre><p id="e5e8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">过一段时间，就结束了。您可以检查控制台，以查看容器是否已被推高。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lx"><img src="../Images/5af6218b6a74227a41be99c94cdc30b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pPbPM1luitKstXl130SQA.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="0fda" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">步骤4:创建集群</h2><p id="969e" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">现在您有了自定义容器，让我们创建一个集群来运行它。</p><p id="bb66" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">目前，一个集群可以小到一台机器，大到100台机器。您可以选择任何想要的机器类型，因此您可以拥有一个包含单个f1-micro实例、100个n1-standard-32实例(3，200个内核！)，以及介于两者之间的任何东西。</p><p id="dc9e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在本教程中，我将使用以下内容:</p><ul class=""><li id="87ac" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated">创建一个名为"<strong class="ja hj">均值-聚类</strong>的聚类</li><li id="431c" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated">给它一个大小为<strong class="ja hj"> 2 </strong>的节点</li><li id="9e29" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated">机器类型将为“<strong class="ja hj">n1-标准-1 </strong></li><li id="d94d" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated">区域将是"<strong class="ja hj">美国中部-1f </strong>"(使用靠近您的区域)</li></ul><p id="a7af" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">创建该集群有两种方法。你挑吧。</p><ul class=""><li id="9c88" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated">命令行:</li></ul><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="24d7" class="jx jy hi lm b fi lq lr l ls lt">$ gcloud container \<br/>  --project "temporal-loop-94520" \<br/>  clusters create "mean-cluster" \<br/>  --zone "us-central1-f" \<br/>  --machine-type "n1-standard-1" \<br/>  --num-nodes "2" \<br/>  --network "default"</span></pre><ul class=""><li id="4e94" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated">图形用户界面:</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ly"><img src="../Images/9bdca1c760f5a78e8c16712663be348d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufWrbMCVNjEUmftU0xQHaA.png"/></div></div></figure><p id="a1b8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">几分钟后，您应该会在控制台中看到这个。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lz"><img src="../Images/29650dc6c142befcc7b63ec3eb60cfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_FfHR6o2p9WFRuQdbSAiQw.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="4951" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">步骤5:创建数据库服务</h2><p id="d2f8" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">需要创造三样东西:</p><ul class=""><li id="6a93" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated">存储数据的持久磁盘(pod是短暂的，所以我们不应该在本地保存数据)</li><li id="727a" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated">运行MongoDB的复制控制器</li><li id="9842" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated">映射到复制控制器服务</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="6b33" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要创建磁盘，请运行以下命令:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="1c4a" class="jx jy hi lm b fi lq lr l ls lt">$ gcloud compute disks create \<br/>  --project "temporal-loop-94520" \<br/>  --zone "us-central1-f" \<br/>  --size 200GB \<br/>  mongo-disk</span></pre><p id="b616" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">非常简单，只需选择与您的集群相同的区域以及适合您的应用程序的磁盘大小。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="fae9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在，我们需要创建一个<strong class="ja hj">复制控制器</strong>来运行数据库。我使用的是复制控制器，而不是Pod，因为如果一个独立的Pod死掉了，它不会自动重启。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="0049" class="jx jy hi lm b fi lq lr l ls lt"># db-controller.yml<br/>apiVersion: v1<br/>kind: ReplicationController<br/>metadata:<br/>  labels:<br/>    name: mongo<br/>  name: mongo-controller<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        name: mongo<br/>    spec:<br/>      containers:<br/>      - image: mongo<br/>        name: mongo<br/>        ports:<br/>        - name: mongo<br/>          containerPort: 27017<br/>          hostPort: 27017<br/>        volumeMounts:<br/>            - name: mongo-persistent-storage<br/>              mountPath: /data/db<br/>      volumes:<br/>        - name: mongo-persistent-storage<br/>          gcePersistentDisk:<br/>            pdName: mongo-disk<br/>            fsType: ext4</span></pre><p id="7230" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">很简单的东西。我们调用控制器<em class="lu"> mongo-controller，</em>指定一个副本，<em class="lu">T5】并打开适当的端口。图像是<em class="lu"> mongo </em>，这是现成的MongoDB图像。</em></p><p id="a521" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">volumes部分创建供Kubernetes使用的卷。有一个特定于Google容器引擎的gcePersistentDisk部分，它将我们制作的磁盘映射到Kubernetes卷中，我们将该卷挂载到/data/db目录中(如MongoDB Docker文档中所述)</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="2634" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在我们有了控制器，让我们创建<strong class="ja hj">服务</strong></p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="bcce" class="jx jy hi lm b fi lq lr l ls lt">#db-service.yml<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    name: mongo<br/>  name: mongo<br/>spec:<br/>  ports:<br/>    - port: 27017<br/>      targetPort: 27017<br/>  selector:<br/>    name: mongo</span></pre><p id="944e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">同样，非常简单的东西。我们“选择”要服务的mongo控制器，打开端口，并调用服务<em class="lu"> mongo </em>。</p><p id="2ff7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这就像我在上一篇文章中使用Docker的“link”命令行选项一样。我们没有连接到<em class="lu"> localhost </em>，而是连接到<em class="lu"> mongo，</em>Kubernetes将流量重定向到mongo服务！</p><p id="c86a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">此时，本地目录如下所示</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="8d6c" class="jx jy hi lm b fi lq lr l ls lt">$ ls<br/>Dockerfile app db-controller.yml db-service.yml</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="3e56" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">步骤6:运行数据库</h2><p id="f9be" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">首先，让我们“登录”到集群</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="2649" class="jx jy hi lm b fi lq lr l ls lt">$ gcloud container clusters get-credentials mean-cluster</span></pre><p id="ad65" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在创建控制器。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="de94" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl create -f db-controller.yml</span></pre><p id="faf2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">还有服务。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="ffa8" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl create -f db-service.yml</span></pre><p id="af1f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">kubectl是Kubernetes命令行工具(随Google Cloud SDK自动安装)。我们只是在创建文件中指定的资源。</p><p id="fcd4" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">此时，数据库正在加速运转！您可以使用以下命令检查进度:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="1ed1" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl get pods</span></pre><p id="cb10" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">一旦你看到mongo pod处于运行状态，我们就可以开始了！</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="202a" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl get pods<br/>NAME                    READY  REASON   RESTARTS AGE<br/>mongo-controller-xxxx   1/1    Running  0        3m</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="0ba3" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">步骤7:创建Web服务器</h2><p id="ecfa" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">现在数据库正在运行，让我们启动web服务器。</p><p id="c82d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们需要两样东西:</p><ul class=""><li id="ce42" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated">用于加速和减速web服务器盒的复制控制器</li><li id="551c" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated">向互联网展示我们网站的服务</li></ul><p id="7978" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">让我们看看<strong class="ja hj">复制控制器</strong>的配置</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="8383" class="jx jy hi lm b fi lq lr l ls lt"># web-controller.yml<br/>apiVersion: v1<br/>kind: ReplicationController<br/>metadata:<br/>  labels:<br/>    name: web<br/>  name: web-controller<br/>spec:<br/>  replicas: 2<br/>  template:<br/>    metadata:<br/>      labels:<br/>        name: web<br/>    spec:<br/>      containers:<br/>      - image: gcr.io/&lt;YOUR-PROJECT-ID&gt;/myapp<br/>        name: web<br/>        ports:<br/>        - containerPort: 3000<br/>          name: http-server</span></pre><p id="25e8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里，我们创建一个名为<em class="lu"> web控制器</em>的控制器，并告诉它创建两个副本。你要求的复制品？你可能会注意到<em class="lu">模板</em>部分看起来就像一个Pod配置，这是因为它确实如此。我们正在使用自定义Node.js容器创建一个Pod，并公开端口3000。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="9127" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在为<strong class="ja hj">服务</strong></p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="0675" class="jx jy hi lm b fi lq lr l ls lt"># web-service.yml<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: web<br/>  labels:<br/>    name: web<br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>    - port: 80<br/>      targetPort: 3000<br/>      protocol: TCP<br/>  selector:<br/>    name: web</span></pre><p id="45d6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">注意这里的两件事:</p><ul class=""><li id="7a24" class="kx ky hi ja b jb jc jf jg jj kz jn la jr lb jv lc ld le lf bi translated">型号为<em class="lu">负载平衡器</em>。这是一个很酷的功能，将使谷歌云平台为这项服务自动创建一个外部网络负载平衡器！</li><li id="b149" class="kx ky hi ja b jb lg jf lh jj li jn lj jr lk jv lc ld le lf bi translated">我们将外部端口80映射到内部端口3000，这样我们就可以在不干扰防火墙的情况下提供HTTP流量。</li></ul><p id="89d5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">此时，本地目录如下所示</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="f245" class="jx jy hi lm b fi lq lr l ls lt">$ ls<br/>Dockerfile app db-pod.yml db-service.yml web-service.yml<br/>web-controller.yml</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="e07c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">步骤8:运行Web服务器</h2><p id="dec0" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">创建控制器。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="1559" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl create -f web-controller.yml</span></pre><p id="9fa4" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">还有服务。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="7657" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl create -f web-service.yml</span></pre><p id="cf4c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">并检查状态。</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="6a00" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl get pods</span></pre><p id="a50d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">一旦您看到web pods处于运行状态，我们就可以开始了！</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="dd80" class="jx jy hi lm b fi lq lr l ls lt">$ kubectl get pods<br/>NAME                   READY     REASON    RESTARTS   AGE<br/>mongo-controller-xxxx  1/1       Running   0          4m<br/>web-controller-xxxx    1/1       Running   0          1m<br/>web-controller-xxxx    1/1       Running   0          1m</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="77ac" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">步骤9:访问应用程序</h2><p id="6cf6" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">此时，一切都已启动并运行。架构看起来像这样:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ma"><img src="../Images/72a5f49ef29c596337f08731d900a1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*3UUOn92G9q14-Q6OLRH9ZA.png"/></div></figure><p id="ed49" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">默认情况下，负载平衡器上的端口80应该是打开的。为了找到我们的应用程序的IP地址，运行以下命令:</p><pre class="in io ip iq fd ll lm ln lo aw lp bi"><span id="2fff" class="jx jy hi lm b fi lq lr l ls lt">$ gcloud compute forwarding-rules list<br/>NAME     REGION        IP_ADDRESS       IP_PROTOCOL TARGET<br/>abcdef   us-central1   104.197.XXX.XXX  TCP         us-xxxx</span></pre><p id="3596" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果你去的IP地址列出，你应该看到应用程序启动和运行！</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mb"><img src="../Images/8a4a72e1c28b1ffa8c4e4e7127db684c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uu5QoEjA_8gCpT5g1o3-zA.png"/></div></div></figure><p id="0bc9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">数据库工作正常！</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mc"><img src="../Images/85ea619fa35d80606e341b3bcbd708fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LalMViEhUgX2XQnY91NmXA.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="f199" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr bi translated">最后的想法</h2><p id="9977" class="pw-post-body-paragraph iy iz hi ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hb bi translated">通过使用Container Engine和Kubernetes，我们有了一个非常健壮的、基于容器的MEAN stack在生产中运行。</p><p id="ecd9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在我的下一篇文章中，我将介绍如何设置MongoDB副本集。这对于生产中的运行非常重要。</p><p id="a115" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">希望我可以发布更多关于Kubernetes高级主题的帖子，比如更改集群大小和Node.js web服务器副本的数量，在同一个集群上使用不同的环境(dev、staging、prod ),以及进行滚动更新。</p></div></div>    
</body>
</html>