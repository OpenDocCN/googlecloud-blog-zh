<html>
<head>
<title>Clustering Akka in Kubernetes with Statefulset and Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Statefulset和Deployment对Kubernetes中的Akka进行聚类</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/clustering-akka-in-kubernetes-with-statefulset-and-deployment-459c0e05f2ea?source=collection_archive---------0-----------------------#2017-03-07">https://medium.com/google-cloud/clustering-akka-in-kubernetes-with-statefulset-and-deployment-459c0e05f2ea?source=collection_archive---------0-----------------------#2017-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="de11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在JFokus 2017上发言，继续看到人们对<a class="ae jd" href="http://akka.io/" rel="noopener ugc nofollow" target="_blank"> Akka </a>的浓厚兴趣。我也想了解更多。在JFokus speakers unconference期间，我有机会见到了来自Akka团队的<a class="ae jd" href="https://twitter.com/apnylle" rel="noopener ugc nofollow" target="_blank">约翰·安德烈</a>，以及使用Akka和<a class="ae jd" href="https://www.lightbend.com/lagom" rel="noopener ugc nofollow" target="_blank"> Lagom </a>的<a class="ae jd" href="https://twitter.com/gotoOla" rel="noopener ugc nofollow" target="_blank">奥拉·彼得森</a>。我趁机向他们两个学习了Akka。</p><p id="4ad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了基础知识之外，我还对集群多个Akka节点以及在Kubernetes中如何工作非常感兴趣。一天晚饭后，约翰、奥拉和我坐在一起，开始着手这项工作。最后，我能够在Kubernetes建立一个Akka集群。你可以在GitHub上找到示例代码和配置:<a class="ae jd" href="https://github.com/saturnism/akka-kubernetes-example" rel="noopener ugc nofollow" target="_blank">https://github.com/saturnism/akka-kubernetes-example</a></p><p id="c727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章抓住了我学到的东西。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><h1 id="cc3c" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">Akka聚类基础</h1><p id="629a" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">Akka集群节点需要向种子节点注册自己，以便发现其他节点。种子节点需要是一组稳定有序的节点(至少1个，但2个或更多用于冗余)。每个新的Akka节点将尝试向列表中的第一个种子节点注册。如果种子节点顺序经常改变，那么创建裂脑集群的可能性很小。一旦群集了一组稳定的种子节点，并且随着更多的Akka节点加入群集，任何其他Akka节点都可以使用Cluster(System)通过任何Akka节点以编程方式加入。加入()。</p><p id="0b19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，Akka节点地址(例如，Akka . TCP://cluster @ seed-node-1:2551)必须使用外部可寻址的主机名/IP。例如，如果一个Akka节点的IP地址为10.100.0.23，主机名为akka-23，并且它将自己注册为Akka . TCP://cluster @ 10 . 100 . 0 . 23:2551，那么您将无法将其寻址为Akka . TCP://cluster @ Akka-23:2551。同样，如果Akka节点将其自身注册为Akka . TCP://cluster @ Akka-23:2551，那么您也不能将其地址指定为Akka . TCP://cluster @ 10 . 100 . 0 . 23:2551。</p><p id="7614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您在容器系统中部署并期望在主机上公开Akka时，这会造成一些困难，因为容器IP不同于主机IP。在这种情况下，您需要使用主机名和端口配置来指定可从其他节点寻址的组合。然后，使用bind-hostname和bind-port指定本地/内部主机名和端口。例如:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="4bb3" class="kt jm hi kp b fi ku kv l kw kx">akka {<br/>  actor {<br/>    provider = "cluster"<br/>  }<br/>  remote {<br/>    netty.tcp {<br/>      hostname = 192.168.0.1         # machine IP<br/>      port = 32551                   # machine port<br/>      bind-hostname = 10.100.0.23    # container IP<br/>      bind-port = 2551               # container port<br/>    }<br/>  }<br/>}</span></pre><p id="dae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，有了Kubernetes的网络架构，事情就简单多了。每个Akka节点都有自己的IP地址，任何其他Akka节点都可以访问该地址，即使Akka节点容器运行在不同的机器上。在Kubernetes中，您不需要处理主机/容器IP/端口映射。</p><h1 id="ef46" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">如何在Kubernetes中创建一个Akka集群？</h1><p id="d02a" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我最初认为我可以采用我用来集群Infinispan (JGroup)和Hazelcast的相同方法。但是考虑到上面的限制，在Kubernetes中创建一个可伸缩的Akka集群可能更具挑战性。我将研究几个选项和我的解决方案。</p><h2 id="4752" class="kt jm hi bd jn ky kz la jr lb lc ld jv iq le lf jz iu lg lh kd iy li lj kh lk bi translated">无头服务和DNS发现</h2><p id="4121" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">Kubernetes中有几个使用<a class="ae jd" href="https://kubernetes.io/docs/user-guide/services/#headless-services" rel="noopener ugc nofollow" target="_blank">无头服务</a>的Akka集群示例:</p><div class="ll lm ez fb ln lo"><a href="http://charithe.github.io/akka-cluster-on-kubernetes.html" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">Kubernetes上的Akka集群-清醒电梦</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">运行Akka集群应用程序的挑战之一是发现其他节点所需的引导步骤…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">charithe.github.io</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc md lo"/></div></div></a></div><div class="ll lm ez fb ln lo"><a href="https://github.com/vyshane/klusterd/blob/master/deployment/manifests/klusterd-peers-svc.yaml" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">vyshane/klusterd</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">使用Kubernetes的klusterd - Akka聚类:一个示例项目</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">github.com</p></div></div><div class="lx l"><div class="me l lz ma mb lx mc md lo"/></div></div></a></div><p id="7c5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些示例使用<a class="ae jd" href="https://kubernetes.io/docs/user-guide/services/#headless-services" rel="noopener ugc nofollow" target="_blank">无头服务</a>来创建DNS名称条目，例如akka-peers。所有Akka节点将能够使用这个DNS名称条目(或Kubernetes API)来获得集群中所有其他Akka节点的IP地址列表。所有发现的IP地址都可以用作种子节点。但还是要小心。默认情况下，Kubernetes headless服务将返回循环DNS条目。每当您引用akka-peers DNS名称时，您将收到不同顺序的同一组IP地址:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="c29d" class="kt jm hi kp b fi ku kv l kw kx">root@akka-peer-ki9f:/# dig +search akka-peer<br/>...<br/>;; ANSWER SECTION:<br/>akka-peer.default.svc.cluster.local. 24 IN A 10.44.3.16<br/>akka-peer.default.svc.cluster.local. 24 IN A 10.44.2.7<br/>akka-peer.default.svc.cluster.local. 24 IN A 10.44.0.13<br/>akka-peer.default.svc.cluster.local. 24 IN A 10.44.3.11<br/>...</span><span id="cb38" class="kt jm hi kp b fi mf kv l kw kx">root@akka-peer-ki9f:/# dig +search akka-peer<br/>...<br/>;; ANSWER SECTION:<br/>akka-peer.default.svc.cluster.local. 26 IN A 10.44.2.7<br/>akka-peer.default.svc.cluster.local. 26 IN A 10.44.0.13<br/>akka-peer.default.svc.cluster.local. 26 IN A 10.44.3.11<br/>akka-peer.default.svc.cluster.local. 26 IN A 10.44.2.8<br/>akka-peer.default.svc.cluster.local. 26 IN A 10.44.1.18</span></pre><p id="2015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这对于确定Akka种子节点可能不起作用。此外，如果Akka群集中有1，000个Akka节点，初始种子节点列表可能由所有1，000个条目组成，而您实际上只需要其中的几个条目。</p><p id="38e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Klusterd的工作方式是先对IP列表进行排序，然后只取前5个(见<a class="ae jd" href="https://github.com/vyshane/klusterd/blob/master/klusterd/build.sbt" rel="noopener ugc nofollow" target="_blank"> Klusterd的启动脚本</a>)。但是，随着IP地址的来来去去，排序后的集合可能会随着时间慢慢改变。只要原始的引导实例仍然存在，这可能是好的。</p><h2 id="193c" class="kt jm hi bd jn ky kz la jr lb lc ld jv iq le lf jz iu lg lh kd iy li lj kh lk bi translated">状态集</h2><p id="5bdd" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">考虑到需要一个稳定有序的种子节点列表，我最初的想法是用<a class="ae jd" href="https://kubernetes.io/docs/concepts/abstractions/controllers/statefulsets/" rel="noopener ugc nofollow" target="_blank">statefullset</a>部署整个Akka集群。这将允许每个Akka节点有一个连续和稳定的DNS名称。例如，第一个akka节点将有一个稳定的DNS名称akka-0，第二个Akka节点将是akka-1，依此类推。然后，我总是可以使用前两三个节点作为种子节点。我还可以通过增加副本的数量来进行横向扩展。</p><p id="1fd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，状态集是按顺序缩放的，而不是并行缩放的。当我将一个Statefulset从一个Akka节点扩展到五个Akka节点时，它将启动akka-1，等待它成功启动，然后启动akka-2，等待，启动akka-3，…并重复，直到完成。这并不理想，因为启动数百个Akka节点可能需要一段时间。</p><blockquote class="mg mh mi"><p id="8d28" class="if ig mj ih b ii ij ik il im in io ip mk ir is it ml iv iw ix mm iz ja jb jc hb bi translated">注8/10/2017:本文是为Kubernetes 1.6编写的。从Kubernetes 1.7开始，StatefulSet可以并行启动<a class="ae jd" href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#parallel-pod-management" rel="noopener ugc nofollow" target="_blank">多个实例</a>。我还没有测试过，但是如果你使用Kubernetes 1.7，它可能是比下面描述的混合解决方案更好的选择。</p></blockquote><h2 id="30a0" class="kt jm hi bd jn ky kz la jr lb lc ld jv iq le lf jz iu lg lh kd iy li lj kh lk bi translated">混合解决方案</h2><p id="c6d0" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我最后的想法是同时使用Kubernetes的Statefulset和Deployment。我可以对种子节点使用Statefulset，对工作节点使用Deployment。通过这种方式，我可以为种子节点维护稳定有序的DNS名称，同时在随部署扩展时，我还能并行启动多个Akka节点。</p><p id="8270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整的例子在我的GitHub上:</p><div class="ll lm ez fb ln lo"><a href="https://github.com/saturnism/akka-kubernetes-example" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">农神主义/阿卡-库伯内特斯-示例</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">在GitHub上创建一个帐户，为akka-kubernetes-example开发做出贡献。</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">github.com</p></div></div><div class="lx l"><div class="mn l lz ma mb lx mc md lo"/></div></div></a></div><p id="3581" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了对种子节点使用Statefulset，我首先创建了一个无头服务。资源定义看起来像常规服务，但clusterIP设置为None:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="6950" class="kt jm hi kp b fi ku kv l kw kx">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: akka-seed<br/>spec:<br/>  ports:<br/>  - port: 2551<br/>    protocol: TCP<br/>    targetPort: 2551<br/>  selector:<br/>    run: akka-seed<br/>  clusterIP: None</span></pre><p id="dd6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Statefulset中的每个Akka种子节点实例都可以通过DNS作为＄{ SEED _ NODE _ NAME }进行寻址。阿卡种子。</p><p id="dfcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我创建一组有状态的种子节点:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="2d91" class="kt jm hi kp b fi ku kv l kw kx">apiVersion: apps/v1beta1<br/>kind: StatefulSet<br/>metadata:<br/>  labels:<br/>    run: akka-seed<br/>  name: akka-seed<br/>spec:<br/>  serviceName: akka-seed<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      run: akka-seed<br/>  template:<br/>    metadata:<br/>      labels:<br/>        run: akka-seed<br/>    spec:<br/>      containers:<br/>      - name: akka-seed<br/>        image: saturnism/akka-cluster-example<br/>        env:<br/>        - name: POD_NAME<br/>          valueFrom:<br/>            fieldRef:<br/>              fieldPath: metadata.name<br/>        - name: SEED_NODES<br/>          value: akka-seed-0.akka-seed,akka-seed-1.akka-seed<br/>        command: ["/bin/sh", "-c", "HOST_NAME=${POD_NAME}.akka-seed java -jar /app/app.jar"]<br/>        livenessProbe:<br/>          tcpSocket:<br/>            port: 2551<br/>        ports:<br/>        - containerPort: 2551<br/>          protocol: TCP</span></pre><p id="6e19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，每个种子节点将具有稳定的名称(例如，akka-seed-0、akka-seed-1等)。这个名字被称为Kubernetes豆荚的名字。我使用了<a class="ae jd" href="https://kubernetes.io/docs/user-guide/downward-api/" rel="noopener ugc nofollow" target="_blank">Kubernetes download API</a>将Pod名称公开为环境变量，然后用它来构造可寻址的DNS名称，比如akka-seed-0.akka-seed。</p><p id="5fbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于SEED_NODE，我可以简单地给它每个种子节点的稳定DNS名称。</p><p id="3bf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要部署Akka种子节点:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="3db7" class="kt jm hi kp b fi ku kv l kw kx">$ kubectl apply -f akka-seeds.yaml</span></pre><p id="f361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看依次产生的阿卡种子:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="04a2" class="kt jm hi kp b fi ku kv l kw kx">$ kubectl get pods<br/>NAME                          READY     STATUS    RESTARTS   AGE<br/>akka-seed-0                   1/1       Running   0          15h<br/>akka-seed-1                   1/1       Running   0          15h</span></pre><p id="5e2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我可以使用Deployment来部署工作节点。它还使用向下API将Pod IP地址分配为Akka节点的主机名。</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="5982" class="kt jm hi kp b fi ku kv l kw kx">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  ...<br/>spec:<br/>  ...<br/>  template:<br/>    ...<br/>    spec:<br/>      containers:<br/>      - name: akka-worker<br/>        image: saturnism/akka-cluster-example<br/>        env:<br/>        - name: SEED_NODES<br/>          value: akka-seed-0.akka-seed,akka-seed-1.akka-seed<br/>        - name: HOST_NAME<br/>          valueFrom:<br/>            fieldRef:<br/>              apiVersion: v1<br/>              fieldPath: status.podIP<br/>        image: saturnism/akka-cluster-example<br/>        ...</span></pre><p id="1d5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署后，您可以验证所有节点都已启动并正在运行:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="b4a1" class="kt jm hi kp b fi ku kv l kw kx">$ kubectl get pods<br/>NAME                           READY     STATUS    RESTARTS   AGE<br/>akka-seed-0                    1/1       Running   0          8s<br/>akka-seed-1                    1/1       Running   0          6s<br/>akka-worker-2263404214-8c266   1/1       Running   0          8s<br/>akka-worker-2263404214-9ws3k   1/1       Running   0          8s<br/>akka-worker-2263404214-f2tp3   1/1       Running   0          8s<br/>akka-worker-2263404214-lkvz3   1/1       Running   0          8s</span></pre><p id="35c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过检查任何Akka节点的日志来验证节点是否已经加入集群。例如，要跟踪第一个种子节点的日志:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="f7ff" class="kt jm hi kp b fi ku kv l kw kx">$ kubect logs -f akka-seed-0<br/>[INFO] [02/12/2017 15:36:53.568] [main] [akka.remote.Remoting] Starting remoting<br/>[INFO] [02/12/2017 15:36:53.707] [main] [akka.remote.Remoting] Remoting started; listening on addresses :[akka.tcp://ClusterSystem@akka-seed-0.akka-seed:2551]<br/>...<br/>[INFO] [02/12/2017 15:37:05.101] [ClusterSystem-akka.actor.default-dispatcher-16] [akka.cluster.Cluster(akka://ClusterSystem)] Cluster Node [akka.tcp://ClusterSystem@akka-seed-0.akka-seed:2551] - Node [akka.tcp://ClusterSystem@akka-seed-1.akka-seed:2551] is JOINING, roles []<br/>[INFO] [02/12/2017 15:37:06.854] [ClusterSystem-akka.actor.default-dispatcher-16] [akka://ClusterSystem/user/$a] Member is Up: Member(address = akka.tcp://ClusterSystem@10.44.2.10:2551, status = Up)<br/>...</span></pre><p id="427b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要取消部署所有内容，只需删除服务、状态集和部署。或者，一步到位:</p><pre class="je jf jg jh fd ko kp kq kr aw ks bi"><span id="05aa" class="kt jm hi kp b fi ku kv l kw kx">$ kubectl delete -f kubernetes/</span></pre><h1 id="a763" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">试试看！</h1><p id="43e3" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">你可以在GitHub上找到代码和配置。您可以在任何Kubernetes 1.5集群中尝试这样做。启动多节点集群最简单的方法之一是在<a class="ae jd" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank"> Google Container Engine </a>上，但是从一个节点开始使用<a class="ae jd" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"> Minikube </a>对于本地开发来说非常好。</p><p id="e461" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别感谢<a class="ae jd" href="https://twitter.com/apnylle" rel="noopener ugc nofollow" target="_blank">约翰</a>和<a class="ae jd" href="https://twitter.com/gotoOla" rel="noopener ugc nofollow" target="_blank">奥拉</a>帮助学习Akka和评论这篇文章。</p></div></div>    
</body>
</html>