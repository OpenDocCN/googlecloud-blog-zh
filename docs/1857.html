<html>
<head>
<title>How Does Google Sheets work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Sheets是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/system-designing-google-sheet-bdf12321b99c?source=collection_archive---------0-----------------------#2021-04-17">https://medium.com/google-cloud/system-designing-google-sheet-bdf12321b99c?source=collection_archive---------0-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/30b14c98928fc591666b4f46ce64eb5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnnANWWiXHWLjXchVOaCQw.jpeg"/></div></div></figure><p id="c601" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都用过Google Sheets，但从未想过它在协同编辑中是如何有效工作的。设计表单并不像设计一个谷歌文档那样简单，要考虑到表单提供的众多高级功能，而由于它提供的众多功能，这些功能要复杂得多，所以这篇博客关注于谷歌表单的<strong class="is hj">高级设计，是为所有层次的有经验的人写的。</strong></p><p id="6ab5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开始设计之前，你应该问自己的问题是:</p><blockquote class="jp jq jr"><p id="8fa3" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">问题1: </strong> <em class="hi"> </em>如果我必须从头重新创建一个类似Google Sheets的东西，你更喜欢哪个数据库:关系数据库还是非关系数据库？这些哪个会更有效<em class="hi">。</em></p><p id="91c2" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">回答:</strong> <em class="hi">如果你正在考虑一个大规模的应用程序，那么是的，你应该选择NOSQL，因为在NOSQL中存储行/列数据和连续的CRUD操作比在RDBMS中具有更高的可伸缩性。</em></p><p id="5773" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">问题2: </strong>我们的设计主要需要关注哪些板材操作？</p><p id="932d" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">答</strong> : <em class="hi">在我们的案例中，我们关注的是sheet上的基本CRUD操作，包括协同编辑。</em></p></blockquote><p id="50de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">协作编辑通俗地说就是多个用户同时贡献/共享同一个资源。但是实现起来并不容易，因为在为大量用户设计的过程中，我们需要考虑许多因素。</p><blockquote class="jp jq jr"><p id="8620" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">问题3: </em> </strong>我们目前在服务多少个请求？</p><p id="d1e6" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">答:</em> </strong> <em class="hi">我们目前专注于数据库设计，首先处理基本功能，然后相应地进行扩展。</em></p></blockquote><p id="b5b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你的脑海中肯定会浮现出更多的问题:</p><ol class=""><li id="06da" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">考虑到一致性问题，我们将如何实现协作编辑功能？</li><li id="d5b9" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">工作表允许自动保存功能吗？</li></ol><p id="5169" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回答完这些问题后，现在让我们开始着手数据库设计。</p><h1 id="4d5c" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">数据库设计</strong></h1><p id="40d6" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">现在让我们深入设计，先谈谈数据库的设计和使用。</p><p id="0bf9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，作为一个Google Sheet，我们广泛地讨论了行和列，这比实现google docs的数据库要困难得多。</p><p id="5550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个示例，它可能是开发人员在考虑关系设计时首先想到的几个想法之一。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/63575105fbd3eae9c05799c1f2b24b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ytykLzdYm6Q4DfTczGaJyw.png"/></div></div></figure><p id="a21d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个设计是一个高度相关的设计，我们在构建最初的几个解决方案时可以很容易地使用它。但是这么多持续更新，这样有效率吗？这对于获取数据有好处吗？答案是一个<strong class="is hj">大不</strong>。</p><p id="e92a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为引入数据表的列值表会对表连接产生巨大的性能开销。假设我们达到了数据表中行数的上限，假设是<em class="jo"> 10 </em>，每一行有<em class="jo"> 100 </em>列。要获取整个数据手册，我们必须阅读:</p><p id="1701" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jo">10 * 10 = 1000 * 100 =10⁵</em></strong></p><p id="3da9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设这个表被100个不同的用户访问，每次我们查询服务器获取这个表时，负载恰好是</p><p id="c500" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo"> 10⁵ * 10 = 10⁷ </em> </strong></p><p id="3395" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在有人会说，我们将从缓存中获取它，而不是直接从服务器中获取。所以答案是缓存的内存是有限的，在缓存中存储多个表的整个表数据最终不是一个好主意。</p><p id="6ec3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有人会说，我会提出一个更动态的数据库设计，只在需要时用下面的设计动态地创建行和列。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/ce8d0cb8132b4675d53ce28544ceddae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnMlLBBDPFKbUkTxaTOQzw.png"/></div></div></figure><p id="34b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">表格中的新单元格只有在不存在的情况下才会形成。但是现在让我们用上面的值来计算一下。</p><p id="a915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo"> 10(行)* 10(列)= 10⁵单元格总数。</em>T15】</strong></p><p id="1407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，当更新整行的更新请求到来时，我们需要进行<strong class="is hj"> <em class="jo"> 100 </em> </strong>更新查询来更新整行，并且如果我们在中间添加一行，我们需要用新的<strong class="is hj"> rowID </strong>来更新下面所有的行，这将导致数据库上非常沉重的负载，并且在获取数据和对响应分页方面不可伸缩。</p><p id="81cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看NoSQL的设计，可以比上述更有效。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/2a6569c4f34ef3553a338da1ba309586.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*WCCk4h2DhzKruyA1.png"/></div></figure><p id="4bd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<strong class="is hj"> sheetID </strong>表示包含该行的工作表。<strong class="is hj"> rowNo </strong>表示该行的顺序号。而<strong class="is hj">行JSON </strong>代表行数据的JSON。行数据如下所示:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/bbdda6b88aa41677c8f17c67df290fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0A79kz_GWRTxgwEmb_d7g.png"/></div></div></figure><p id="4db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我提到的将数据表列值作为行表本身中的JSON的方法，在更新行数据时省去了麻烦。</p><p id="e27d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在上面的数据模型有两大缺陷。如果到目前为止你还没有得到，暂停一分钟，然后再回来。</p><ol class=""><li id="ec83" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">如果我们在数据表中添加一行，我们的行表需要更新所有后续行的rowNo。这可能是一个巨大的数据库写问题，需要更新相当多的记录，因为只是在中间添加一行。</li><li id="96c8" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">如果我们在数据表中添加一列，我们所有的行都需要更新，以便在每行的<strong class="is hj"> raw JSON </strong>中包含额外的空白数据表列。</li></ol><p id="4742" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以<strong class="is hj">数据结构和算法</strong>的形式来考虑它，并问自己在这种情况下哪种数据结构最有效。</p><p id="9bfb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题:<strong class="is hj">将数据/行</strong>前移，并在现有工作表中添加一条新记录。</p><p id="ca34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案:哪个DS在移位记录时性能最好？</p><p id="7dfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们使用<strong class="is hj"> <em class="jo">链表</em> </strong>会怎么样？哦，天啊，你想的方向是对的。我们有唯一的rowID，让我们把它们作为LinkedList节点，当我们知道下一行是哪一行时，我们就知道序列是如何进行的。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/b1df471c6bac8f1d3b5da69e3e48ef3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*7shJQkHG60gmv7jV-M_oyg.png"/></div></figure><p id="8b5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着我们只需要改变下一个指针，我们在单个更新请求中就完成了，我们不再需要将整个数据一个接一个地向左/向右移动。</p><p id="0ed5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在某种程度上，我的第一个数据模型被证明是一个非常糟糕的设计。我通过在行表中用<strong class="is hj"> rowID </strong>替换<strong class="is hj"> rowNo </strong>来修复它。并在rows表中引入一个新列，即<strong class="is hj">pre rowid</strong>，它包含前一行的ID。因此，在某种程度上，当数据表中添加新行时，我们只在rows表中创建一个新行。并更新表中的一行以更改先前的行标识符。这是更新的行表的简化版本，如下所示。这种方法也不是没有缺陷，但为了简洁起见，让我们继续进行。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/c54d39e06ee6818e69a8f9c305818d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/0*9bwB2dxZr_rhvYIC.png"/></div></figure><p id="fc99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">原始JSON </strong>也存在类似的问题。类似地，我们可以通过引入存储在<strong class="is hj">原始JSON </strong>的每个对象中的<strong class="is hj"> prevColumnID </strong>来解决这个问题。大概是这样的:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/711bb9434f750c6f966aed7394524598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8YH1ppP3kGifbP-dn8yQQ.png"/></div></div></figure><p id="a616" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样我们就解决了新行和新列的问题。但是我们肯定需要数据库中的另一个表来包含数据表列元数据。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h2 id="9921" class="mc kk hi bd kl md me mf kp mg mh mi kt jb mj mk kx jf ml mm lb jj mn mo lf mp bi translated">现在我们已经准备好了数据库，我们可以在火上存储数据。</h2><h1 id="4787" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">协同编辑</strong></h1><p id="a4ba" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">构建可相互编辑的文档不是一件容易的事情。我们面临几个问题。</p><ol class=""><li id="144b" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">并发性:这意味着多个计算同时发生。不管我们喜欢与否，It在现代编程中无处不在:网络中的多台计算机。在一台计算机上运行多个应用程序。一台计算机中的多个处理器(今天，通常在一个芯片上有多个处理器内核)</li><li id="bb62" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated"><strong class="is hj">延迟:</strong>由于我们使用互联网访问可相互编辑的文档，因此可能会有延迟问题，甚至可能导致并发。</li></ol><p id="6dcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于并发，首先想到的是什么— <strong class="is hj">锁</strong>。</p><p id="aa48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在这种情况下他们真的能拯救我们吗？没有，从来没有。</p><p id="2ea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多个用户同时编辑同一个文档，我们需要实现一个基于turn-based的锁架构，这种架构效率不高，也不容易实现。所以锁不可能总是并发问题的最佳选择。让我们从现在开始记住这一点，当我们听到并发这个词时，不要总是跳到这个方法上:P</p><p id="4bf7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要一个无锁架构。嗯，我们有什么方法可以做到这一点？</p><blockquote class="jp jq jr"><p id="cde4" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">基于行更新进行同步？</p><p id="a18d" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">基于单元更新的同步？</p></blockquote><p id="3353" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，有三种主要的方法可以做到这一点。</p><ol class=""><li id="4ade" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated"><strong class="is hj"> <em class="jo">差分同步</em></strong>——就像一个git差分</li></ol><p id="e461" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is hj"> <em class="jo">事件同步</em></strong>——每当用户更新任何东西的时候。</p><p id="237c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.<strong class="is hj"> <em class="jo">行同步</em></strong>——每当一行被更新时，以及更新完成后。</p><p id="cb77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用什么？谷歌和其他大型竞争对手用什么？</p><p id="e042" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，你猜对了，是第二种，基于事件的同步。但在技术界，这叫<strong class="is hj"> OT(运营转型)。</strong></p><p id="985c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mq translated">OO<strong class="is hj">操作转换</strong> ( <strong class="is hj"> OT </strong>)是一种在高级<a class="ae mz" href="https://en.wikipedia.org/wiki/Collaborative_software" rel="noopener ugc nofollow" target="_blank">协同软件</a>系统中支持一系列协同功能的技术。OT最初是为了纯文本文档协同编辑中的一致性维护和<a class="ae mz" href="https://en.wikipedia.org/wiki/Concurrency_control" rel="noopener ugc nofollow" target="_blank">并发控制</a>而发明的。它的应用扩展到包括组撤销、锁定、冲突解决、操作通知和压缩、应用共享。</p><p id="8da2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">会单独写博客深入讲解<strong class="is hj">运营转型</strong>。</p><h1 id="2d92" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">高层设计</strong></h1><p id="3e5a" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">现在让我们来谈谈我的设计在高层次上会是什么样子。</p><p id="fec6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在很高的层面上，我建议如下。这太简单了，功能较少，不包括操作事务设计流程。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/2ec9ae49af9740d282b15ed5a01b4e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wV0_UUIMvQhxxXMvU7zzWg.jpeg"/></div></div></figure><p id="af54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">建筑的卫星视图</em></p><p id="44a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们使用<strong class="is hj">分布式系统方法和水平扩展</strong>来提高<strong class="is hj">可用性和运营效率</strong>。</p><p id="aaa6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">进一步挑战</em> </strong> <em class="jo"> : </em>我们永远不知道浏览器的哪个更新命令会被哪个服务器选中。一种解决方案可以是使用数据流技术(例如Kafka ),该技术将支持相同数据表的命令发送到同一数据处理器服务器。因此，我们现在可以扩大卡夫卡集群。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="b145" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">系统设计有很多内容，而且每一部分都有问题。</p><p id="8b16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，与不同的人讨论并尽你所能获得最佳解决方案总是一个好方法，而这又会让其他人产生疑问。</p><p id="51a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这是谷歌工作表设计的一部分。事情远不止如此。</strong></p><p id="efae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">干杯！！:)</strong></p></div></div>    
</body>
</html>