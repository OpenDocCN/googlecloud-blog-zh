<html>
<head>
<title>GCP Pub/Sub ordering and Apache NiFi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP公共/订阅订购和Apache NiFi</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/gcp-pub-sub-ordering-and-apache-nifi-5e1ac9a14752?source=collection_archive---------0-----------------------#2020-01-19">https://medium.com/google-cloud/gcp-pub-sub-ordering-and-apache-nifi-5e1ac9a14752?source=collection_archive---------0-----------------------#2020-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/079b80668ae4d5be75573719b4f1dcbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bl10YwB12HSNQMPPw6osWQ.png"/></div></div></figure><p id="6812" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>本文发表于GCP Pub/Sub的一个名为<a class="ae jo" href="https://cloud.google.com/pubsub/docs/ordering" rel="noopener ugc nofollow" target="_blank"> <em class="jp">订购消息</em> </a>的功能可用之前。请将GCP发布/订阅的本机特性视为优先于本文中先于新功能的概念。</p><p id="03c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GCP发布/订阅不保证消息排序。这意味着，如果单个发布者发布了消息#1、#2和#3的序列，则不能保证它们被单个订阅者以该顺序接收。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jq"><img src="../Images/4b31c58b6ab60afbc02e7ddebdc12fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*VPtKrmPANTDOHIi0wkGqOg.png"/></div></div></figure><p id="f048" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于某些用例，这可能是一个严重的问题。例如，如果按顺序发布的逻辑消息是:</p><ul class=""><li id="5b4b" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">开户</li><li id="daed" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">在账户上存100美元</li><li id="5e25" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">从账户上转账50美元</li></ul><p id="4d25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么处理的顺序可能非常重要。不按顺序执行前面的消息很容易导致不正确的结果。</p><p id="cef2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache NiFi是一个处理和分发数据的开源平台。我们不会在这里讨论Apache NiFi的细节，但是在其他地方可以找到很多关于它的优秀文献。我们要看的是如何使用Apache NiFi为GCP发布/订阅提供消息排序。</p><p id="6b26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache NiFi有一个GCP订户处理器(<a class="ae jo" href="https://nifi.apache.org/docs/nifi-docs/components/org.apache.nifi/nifi-gcp-nar/1.10.0/org.apache.nifi.processors.gcp.pubsub.ConsumeGCPubSub/index.html" rel="noopener ugc nofollow" target="_blank"> ConsumeGCPubSub </a>)，可以用作流文件的源(流文件是数据的单位……想想GCP发布/订阅消息)。我们需要确保消息按顺序处理。实现这一点的一种方法是使用NiFi提供的名为<a class="ae jo" href="https://nifi.apache.org/docs/nifi-docs/components/org.apache.nifi/nifi-standard-nar/1.10.0/org.apache.nifi.processors.standard.EnforceOrder/index.html" rel="noopener ugc nofollow" target="_blank"> EnforceOrder </a>的处理器。这个处理器有两个与提供给它的流文件相关的重要概念。</p><p id="a443" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，每个流文件都应该有一个序列号属性。正是这个属性用于定义所需的排序。</p><blockquote class="kj kk kl"><p id="6be0" class="iq ir jp is b it iu iv iw ix iy iz ja km jc jd je kn jg jh ji ko jk jl jm jn hb bi translated">注意:这里出现的一个问题是，当每条消息都有一个发布时间戳时，为什么我们还需要一个序列号。我们不能按时间顺序排列信息吗？要了解为什么这不起作用，请考虑一条时间戳为2:00:00的消息。我们确定没有一条消息可能随后到达，时间戳为1:59:59吗？如果下一条消息的时间戳是2:05:00呢？我们确定没有遗漏2:03:00的信息吗？</p></blockquote><p id="b439" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设EnforceOrder最初期望序列ID为1的消息。如果具有该id的消息到达，它将被传递。EnforceOrder是有状态的。它知道它所期待的消息序列ID。当它找到一个匹配的消息时，它不仅传递该消息，而且还增加预期的序列号…在本例中，我们现在将寻找序列ID为2的消息。如果看到的下一条消息的序列ID为3，EnforceOrder就会意识到有问题。它现在会将这个消息路由到<em class="jp">等待</em>连接，并继续处理下一个输入消息。如果它看到的下一条消息的序列ID为2，它将传递该消息，并将有状态的期望的下一条消息递增为3。最终，被路由到<em class="jp"> wait </em>的消息将被重新处理，我们将发出正确的有序序列。</p><p id="a0e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与EnforceOrder相关的第二个概念是，并非所有流文件都需要相对于彼此排序，而是可以相对于分组排序。如果我们设想可以有多个同时处理的订单，那么我们发现我们只需要维护每个分组的订单，而不是作为一个整体。</p><p id="5854" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将这些想法映射到EnforceOrder处理器的属性，我们发现序列ID将作为传入流文件上的一个属性来查找，其名称在“Order Attribute”属性中提供。形成序列的流文件分组作为“分组标识符”属性中的表达式提供。这通常是一个表达式，其计算结果为在流文件中找到的属性。</p><p id="b5f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的示例中，我们将假设一个流文件包含以下属性:</p><ul class=""><li id="d14c" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated"><code class="du kp kq kr ks b">seqNum</code> —从1开始的整数值序列号。</li><li id="5f88" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated"><code class="du kp kq kr ks b">groupId</code> —同一组中的流文件共有的字符串值。</li></ul><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/7fe26b463fb6262868a5562aeee47fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0M96Ou4T3WUWCRPSi0nUg.png"/></div></div></figure><p id="4904" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更详细地研究一下EnforceOrder，以了解它是如何工作的，以及如何用它来解决我们的问题。如果我们查看EnforceOrder处理器的默认属性，我们会发现以下内容:</p><figure class="jr js jt ju fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/96c15b60e07a7c54df290646cea06247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXuoU4-R3WqS2UhNx2Bcrg.png"/></div></div></figure><p id="c5a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还会发现处理器有以下输出连接:</p><ul class=""><li id="dadb" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">成功</li><li id="181e" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">失败</li><li id="7c08" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">等待</li><li id="c96d" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">跳过</li><li id="7342" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">赶上</li></ul><p id="6c39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总体目标是让流文件通过<em class="jp">成功</em>连接以正确的顺序到达和输出。为了了解这是如何发生的，让我们检查一系列消息。第一个到达的消息是groupId为XYZ，seqNum为1的消息。EnforceOrder将查看groupId，并意识到它过去没有看到过这样一组消息。它现在将维护该组的状态，并将初始期望顺序设置为1。将检查传入消息的seqNum，发现它为1。这确实是下一个(在我们的例子中是第一个)预期消息，并将通过<em class="jp">成功</em>传递。下一个预期的seqNum将从1递增到2，这意味着我们预期的下一条消息的值应该是2。现在我们假设下一条消息的groupId为XYZ，seqNum为2。EnforceOrder识别出这是以前见过的groupId，并将预期的seqNum (2)与包含在消息(2)中的当前seqNum进行比较，并再次让它通过<em class="jp">成功</em>连接。下一个预期的seqNum从2递增到3。现在让我们来看一个失序消息。假设下一条消息的groupId为XYZ，seqNum为4。EnforceOrder发现我们有一个已知的groupId (XYZ ),并希望消息的seqNum为3。它发现seqNum是4，因此它到达得太早了(失序)。消息被发送到<em class="jp">等待</em>连接，并且EnforceOrder的状态保持不变。假设<em class="jp"> wait </em>连接返回到EnforceOrder，以便将来可以再次处理该消息。花点时间看看流程图，看看<em class="jp"> wait </em>确实被路由回EnforceOrder。继续以这种方式处理消息，接收到的消息被发送到<em class="jp"> wait </em>，下一个预期的消息被传递到<em class="jp"> success </em>，并且EnforceOrder下一个序列号的状态被递增。提前接收并发送到<em class="jp"> wait </em>的消息将在未来重新检查。</p><p id="bf9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是EnforceOrder的核心，但还有我们尚未讨论的其他可能性，我们现在将研究这些可能性。</p><p id="4726" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重复消息是指不止一次收到的消息。考虑清楚这一点，我们将认识到重复消息是seqNum等于我们已经看到的值的消息。这相当于seqNum小于我们下一个期望的序列号。例如，如果我们正在等待序列号为4的消息，而收到序列号为2的消息，这意味着我们之前已经处理了序列号为2的消息。在这种情况下，EnforceOrder将重复消息路由到跳过的<em class="jp">连接。</em></p><p id="3cdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们接收到消息1、2和4，而<em class="jp">从来没有</em>接收到消息3，这种不连续的消息序列会怎么样？这可能是一个问题，因为我们将永远维护message 4并无缘无故地锁定资源。这就是<em class="jp">等待超时</em>属性发挥作用的地方。这是一个可配置的时间间隔，用于定义等待(早期接收)消息应该保持多长时间。如果该消息在该间隔后仍然存在，则它被路由到<em class="jp">超越</em>连接。</p><p id="395e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还看到EnforceOrder维护每个groupId的状态。由于我们不知道一个组中有多少条消息，也没有最后一条消息的迹象，这似乎意味着组的状态将继续累积。这就是可以使用EnforceOrder的<em class="jp">非活动超时</em>配置属性的地方。这指定了导致EnforceOrder忽略消息组的时间间隔。该属性被定义为在给定组中看到的最后一条消息之后的时间间隔。例如，如果在12:00看到组XYZ的5号消息，并且我们定义了10分钟的非活动超时，那么在12:10我们可以声明我们将不再看到属于该组的消息，并且可以忘记我们正在维护的状态。</p><p id="c6a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于GCP发布/订阅，我们可以将发布消息的属性映射到与groupId和seqNum对应的属性，以提供EnforceOrder所需的数据。</p></div></div>    
</body>
</html>