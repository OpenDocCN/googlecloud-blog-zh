<html>
<head>
<title>A handy local dev tip that works great with Google’s PHP Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个方便的本地开发技巧，非常适合Google的PHP图像</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-handy-local-dev-tip-that-works-great-with-googles-php-image-76d4acd2d789?source=collection_archive---------2-----------------------#2019-07-24">https://medium.com/google-cloud/a-handy-local-dev-tip-that-works-great-with-googles-php-image-76d4acd2d789?source=collection_archive---------2-----------------------#2019-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我强调一下…如果您因为文件权限而在使用docker卷进行本地开发时遇到问题，这实际上可能会对您有所帮助！因此，我将尽可能保持说明的通用性，这样您就可以使用任何技术组合来完成这项工作。</p><h1 id="7621" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">设置Docker容器</h1><p id="c1c7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在我的例子中，创建以下docker文件很简单:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="296b" class="kp je hi kl b fi kq kr l ks kt">FROM gcr.io/google-appengine/php:latest</span></pre><blockquote class="ku kv kw"><p id="7f7a" class="if ig kx ih b ii ij ik il im in io ip ky ir is it kz iv iw ix la iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>对任何docker映像使用:latest标签都不是好的做法，因为可能会发布新版本的容器，这会破坏未来的构建或部署。如果您计划将Docker容器部署到生产环境中，您应该使用大头针标签。</p></blockquote><p id="af0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个映像所做的是将does文件所在目录中的任何内容复制到容器的/app目录中。然后检查/app中的composer.json文件，查看指定的php版本(如果有的话),然后使用nginx作为反向代理，在supervisord下运行一个php-fpm实例。</p><p id="b8ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的特定设置中，您可能只需要一个用mod_php启动apache2的容器。无论您的设置是什么，您都需要知道下一步将运行php的进程是apache2还是php-fpm。</p><h1 id="c9a9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">找到关于docker图像的更多信息</h1><p id="54a6" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们有了docker文件，我们想运行它，然后跳到容器内部看看发生了什么:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="cc46" class="kp je hi kl b fi kq kr l ks kt">$ docker build -t myapp .<br/>...<br/>$ docker run -v "/${PWD#*/}":/app myapp<br/>2413fb3709b05939f04cf2e92f7d0897fc2596f9ad0b8a9ea855c7bfebaae892</span><span id="899b" class="kp je hi kl b fi lb kr l ks kt">$ docker ps<br/>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                 NAMES<br/>2413fb3709b0        myapp               "docker-entrypoint.s…"   5 seconds ago         Up 5 seconds                                  kicking_tyrant</span><span id="893e" class="kp je hi kl b fi lb kr l ks kt">$ docker exec -it kicking_tyrant bash<br/>root@2413fb3709b0:/app# top<br/>top - 10:53:54 up  5:21,  0 users,  load average: 0.05, 0.02, 0.00<br/>Tasks:   9 total,   1 running,   8 sleeping,   0 stopped,   0 zombie<br/>%Cpu(s):  0.7 us,  0.7 sy,  0.0 ni, 98.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br/>KiB Mem :  4037124 total,   206692 free,  1885512 used,  1944920 buff/cache<br/>KiB Swap:        0 total,        0 free,        0 used.  1807612 avail Mem</span><span id="c115" class="kp je hi kl b fi lb kr l ks kt">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND       <br/>    1 root      20   0   55736  17820   6820 S   0.0  0.4   0:00.19 supervisord   <br/>   23 root      20   0  366168  22488  18208 S   0.0  0.6   0:00.06 php-fpm       <br/>   24 root      20   0  172780  14548  11560 S   0.0  0.4   0:00.03 nginx         <br/>   25 www-data  20   0  174168   6660   2356 S   0.0  0.2   0:00.00 nginx         <br/>   26 www-data  20   0  174168   6660   2356 S   0.0  0.2   0:00.00 nginx         <br/>   27 www-data  20   0  366168   7416   3132 S   0.0  0.2   0:00.00 php-fpm       <br/>   28 www-data  20   0  366168   7416   3132 S   0.0  0.2   0:00.00 php-fpm       <br/>   29 root      20   0   18240   3244   2796 S   0.0  0.1   0:00.02 bash          <br/>   38 root      20   0   36628   3040   2620 R   0.0  0.1   0:00.00 top</span></pre><p id="f1f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里需要注意的重要一点是，php-fpm和nginx一样是作为www-data运行的。如果这是一个不同的设置，您可能会看到php-fpm + apache或只是apache2(或httpd2)。</p><p id="0a8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道了它是在哪个用户上运行的，我们需要确定www-data的用户id是什么，让我们看看我们在主机上的用户id是什么:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="7d68" class="kp je hi kl b fi kq kr l ks kt">root@2413fb3709b0:/app# id -u www-data<br/>33</span><span id="4327" class="kp je hi kl b fi lb kr l ks kt">root@2413fb3709b0:/app# exit<br/>$ id -u<br/>1000</span></pre><p id="a59a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道了容器用于www-data用户的默认用户id。现在我们可以回到docker文件，并修改它，以包括一些额外的好处，为我们的黑客准备。</p><h1 id="19bd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">为我们的档案增添美好</h1><p id="02af" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们在docker文件中添加两条简单的语句，如下所示:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="2a1e" class="kp je hi kl b fi kq kr l ks kt">FROM gcr.io/google-appengine/php:latest</span><span id="4a5a" class="kp je hi kl b fi lb kr l ks kt">ARG WWW_DATA_UID=33<br/>RUN usermod -u $WWW_DATA_UID www-data &amp;&amp; groupmod -g $WWW_DATA_UID www-data</span></pre><p id="c5aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的作用是在docker映像构建过程中查找名为WWW_DATA_UID的构建参数，然后将www-data的用户ID和组id更改为WWW_DATA_UID的值。如果我们不指定任何东西，它使用我们发现图像附带的默认值(33)，所以它是生产安全的(tm)。</p><h1 id="1258" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">这里是奇迹发生的地方</h1><p id="cb92" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们拼图的最后一块是在本地构建docker文件时添加一些额外的优点。让我们使用上面的运行示例，但修改为传入WWW_DATA_UID构建参数:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d12e" class="kp je hi kl b fi kq kr l ks kt">$ docker build -t myapp --build-arg WWW_DATA_UID=$(id -u) .<br/>...<br/>$ docker run -v "/${PWD#*/}":/app myapp<br/>2413fb3709b05939f04cf2e92f7d0897fc2596f9ad0b8a9ea855c7bfebaae892</span></pre><p id="b337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧啊。如果我们现在看一下容器内部，我们会看到www-data的用户id已经更改，因此容器外部文件的用户id与容器内部文件的用户id相匹配(让我们假设容器第二次仍具有相同的名称):</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="104d" class="kp je hi kl b fi kq kr l ks kt">$ docker exec -it kicking_tyrant bash<br/>root@2413fb3709b0:/app# id -u www-data<br/>1000</span></pre><h1 id="1a0e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加分！</h1><p id="015e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这就是它的全部，但是如果你使用的图像和我在例子中使用的完全一样，<a class="ae lc" href="https://link.medium.com/1P1gHRgaAY" rel="noopener">看一下我以前的文章</a>，这将帮助你避免讨厌的(你不能写这个文件)错误，因为docker图像试图锁定所有的文件。</p><p id="d47f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在下面评论，让我知道这是如何为你工作的！</p></div></div>    
</body>
</html>