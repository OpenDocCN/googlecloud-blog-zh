<html>
<head>
<title>Using Dataflow in Clojure to process Google’s huge new WikiReading dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Clojure中的数据流来处理Google的新维基阅读数据集</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-dataflow-in-clojure-to-process-googles-huge-new-wikireading-dataset-832af367539c?source=collection_archive---------0-----------------------#2017-02-26">https://medium.com/google-cloud/using-dataflow-in-clojure-to-process-googles-huge-new-wikireading-dataset-832af367539c?source=collection_archive---------0-----------------------#2017-02-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="74f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">昨天，我在探索新的WikiReading数据集，并通过简化对象的结构——基本上删除了一些非规范化的字段——成功地将208GB的未压缩JSON压缩到50GB。我使用了一个简单的命令行工具:<a class="ae jd" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>。但这些文件还是太大了，无法在我的笔记本电脑上用Clojure REPL软件下载。</p><p id="7ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我想从1880万个(文档、属性、值)三元组转移到大约470万个文档的映射，每个文档与一组(属性、值)元组相关联。这将再次大幅减小尺寸。</p><p id="1346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从技术上讲，我可以用jq来做，但是没有好的方法来并行操作，不像我们昨天做的映射(每一行都是一个单独的JSON对象，转换它只依赖于那一行)。要用jq对所有数据进行“分组”,我们必须将整个数据结构读入内存，然后在单个内核中处理它。我不得不在云计算上建立一个特殊的超高内存实例，而且仍然需要很长时间来处理。</p><p id="99f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能是对<a class="ae jd" href="https://cloud.google.com/dataflow/" rel="noopener ugc nofollow" target="_blank">云数据流</a>的一个很好的利用。有一个很棒的库叫做<a class="ae jd" href="https://github.com/ngrunwald/datasplash" rel="noopener ugc nofollow" target="_blank"> datasplash </a>，它包含了数据流的1.x SDK。尽管Google已经开始推荐Apache Beam，但我还是使用了它，因为clj-Beam<a class="ae jd" href="https://github.com/teddziuba/beam-clj" rel="noopener ugc nofollow" target="_blank">就是不存在:当我试图运行最基本的例子时，它由于神秘的互操作问题而失败了。此外，这个API远不如datasplash的高。</a></p><p id="a889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我试图创建的管道非常简单:</p><ul class=""><li id="73c9" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">读取给定子集(训练/验证/测试)的所有JSON文件，将它们转换成一个大的Clojure映射集合(带有键文档、属性、值)</li><li id="8309" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">按文档分组</li><li id="eca1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">为每个子集写入一个JSON文件</li></ul><p id="f8b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与我在过去几天里用Dataflow所做的相比，它很简单——线性的，只有几个步骤。看看datasplash的例子中一些更丰富的管道。</p><p id="49b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个被大量评论的要点:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="9706" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是这样运行的:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="be35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是它运行时在监控界面中的样子:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/aead971e34fe4fa1ef2a7a9626f1a076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Co00-hIElw2W6tQBIWy3kg.png"/></div></div></figure><p id="63d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是花了多长时间:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es kg"><img src="../Images/36281e234441e1556c19530b8238185c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1y3cfhHJrdKeDEl8g5duA.png"/></div></div></figure><p id="fc74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是云存储的输出结果:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es kh"><img src="../Images/d330a35109ecc54ba47d65db129f21aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lN-DWLtQp7IQina7C9enRQ.png"/></div></div></figure><p id="14d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经从208GB → 50GB → 6.8GB，而没有丢失复制论文结果所需的任何信息。好吧！我甚至可以在我的笔记本电脑上玩这个数据集。</p><p id="53b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不用写太多代码就能看到一堆电脑为你跳舞，这是一种满足感。数据流负责分布式计算的所有实现细节。我写的代码看起来类似于我为在单个内核、单个机器上运行而写的代码——主要区别是我使用了datasplash的map、group-by和I/O函数，而不是Clojure的内置函数。</p><p id="951e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我真希望管道的构建是基于组装数据结构(就像在<a class="ae jd" href="http://www.onyxplatform.org/" rel="noopener ugc nofollow" target="_blank"> Onyx </a>中)而不是改变管道对象。事实上，我会使用Onyx，只不过我必须自己完成所有的开发工作，并了解什么是Apache Zookeeper。也许改天吧！或者也许有一天Onyx会像Dataflow一样拥有自己的全托管服务。</p><p id="f382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，我现在更接近于能够快速迭代我对维基阅读的探索。向前！</p></div></div>    
</body>
</html>