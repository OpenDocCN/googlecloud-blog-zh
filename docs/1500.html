<html>
<head>
<title>Firebase hosting and Cloud Run cache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase托管和云运行缓存</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/firebase-hosting-and-cloud-run-cache-38afa6bd4beb?source=collection_archive---------0-----------------------#2020-07-07">https://medium.com/google-cloud/firebase-hosting-and-cloud-run-cache-38afa6bd4beb?source=collection_archive---------0-----------------------#2020-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/28aac16a50df498e93d1664c27bd3455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0R4eQoT6SwXZTlGuaL9n-w.png"/></div></div></figure><p id="9906" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用Firebase托管来托管一个网站。在已部署的站点中，我们可以指定一些或所有所需的URL路径可以定向到云运行进行处理。这允许我们通过运行在容器中的应用程序生成动态的服务器端呈现内容。Firebase托管也与谷歌的内容交付网络(CDN)有着内在的联系，以提供高效的边缘缓存。当一个浏览器请求到达Google时，CDN会被查询以确定内容是否可以从边缘提供。如果在缓存中不可用，那么请求将被路由到Firebase进行处理。CDN的使用可以显著降低延迟并提高整体性能。</p><p id="b216" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了静态内容之外，默认情况下，服务器端生成的内容也会被缓存。这可能正是你想要的，但也可能是不可取的。想象一个简单的服务器端呈现页面，它生成带有当前日期/时间的内容。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="af05" class="jx jy hi jt b fi jz ka l kb kc">It is now 10:51pm.</span></pre><p id="8533" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在服务器端代码中，这可以使用以下代码生成:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7a80" class="jx jy hi jt b fi jz ka l kb kc">res.send(`It is now ${new Date().toString()}`);</span></pre><p id="3f96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">浏览器第一次请求页面时，在CDN中找不到它，云运行代码执行来构建HTML。然后，内容将被缓存在CDN中，后续调用将从缓存中返回它。这意味着数据不会改变，我们将停留在单个响应上，时间不会更新。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es kd"><img src="../Images/bb611f685f406c6297778abb20284029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/0*XE6lvEMpbmS7A3wB"/></div></figure><ol class=""><li id="02cf" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated">浏览器请求到达CDN，没有缓存任何内容。然后，该请求被发送到Firebase主机，该主机路由到云运行以生成内容。</li><li id="a750" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">响应被写入CDN进行缓存。</li><li id="3a00" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">稍后浏览器对同一URL的请求直接由CDN提供。未向云运行发出任何请求。</li></ol><p id="7027" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个强大的技术来控制如何管理缓存。当来自云运行的HTTP响应被返回时，它可以包括附加的HTTP头。一个这样的标题被称为“高速缓存控制”。浏览器和Google CDN都认可返回的值。您应该参考关于缓存控制的文档以获得完整的细节。我们可以用来配置与CDN的响应交互的一些值包括:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="99f0" class="jx jy hi jt b fi jz ka l kb kc">Cache-Control: no-store</span></pre><p id="0fa5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个声明说数据不应该被缓存。具体来说，当它从云运行返回时，它不会被CDN缓存。这意味着对云运行生成的数据的每个请求都将导致云运行逻辑被重新执行，以构建新的当前响应。</p><p id="8bae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们希望利用CDN缓存，我们可以指定:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1d7e" class="jx jy hi jt b fi jz ka l kb kc">Cache-Control: public,s-maxage=30</span></pre><p id="b71c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“s-maxage”属性定义了存储缓存值的持续时间(秒)。经过此时间间隔后，缓存的值将被丢弃。</p><p id="7769" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个HTTP头可以从您实现的云运行容器实现中返回。因为您可以用任何语言实现这些容器，所以您可以选择recipe来显式地设置特定于语言的实现中的头部。例如，在NodeJS中，我们可以编写:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="77ba" class="jx jy hi jt b fi jz ka l kb kc">res.set('Cache-Control', 'no-store');<br/>res.send('… My generated HTML …');</span></pre><p id="93ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种显式编码方法并不是我们控制CDN和云运行交互的唯一方式。当我们为Firebase hosting部署解决方案时，我们提供一个名为firebase.json的配置文件。Firebase hosting的一个特性是能够根据URL模式匹配在传入请求或传出响应中注入标头。使用这个特性，我们可以指定从云运行容器调用返回的“Cache-Control”HTTP头的值，而不必在我们的实现逻辑中显式编码Cache-Control。</p><p id="3331" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个名为“/mycontent”的URL路径。现在让我们假设我们希望这个页面通过云运行在服务器端呈现，而不是缓存。我们如何做到这一点？</p><p id="67b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以实现一个NodeJS应用程序来监听这个URL:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0f95" class="jx jy hi jt b fi jz ka l kb kc">app.get('/mycontent', (req, res) =&gt; {<br/>  res.send(`<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;p&gt;Hello from Cloud Run (/mycontent): ${new Date().toString()}&lt;/p&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;<br/>`);<br/>});</span></pre><p id="f4a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，它不包含任何显式缓存控件。当我们将它部署到云运行时，我们给它一个逻辑服务名。在我们的例子中，我们称之为“mycontent”。在Firebase托管firebase.json配置文件中，我们现在可以提供从所需路径到云运行服务的映射。我们还将指定要返回的“Cache-Control”头:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6235" class="jx jy hi jt b fi jz ka l kb kc">{<br/>  "hosting": {<br/>    "rewrites": [{<br/>      "source": "/mycontent",<br/>      "run": {<br/>        "serviceId": "mycontent",<br/>        "region": "us-central1"<br/>      }<br/>    }]<br/>    "headers": [{<br/>      "source": "/mycontent",<br/>      "headers": [{<br/>        "key": "Cache-Control",<br/>        "value": "no-store"<br/>      }]<br/>    }]<br/>  }<br/>}</span></pre><p id="ecdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解释上述内容的方法是，对于从“/mycontent”接收的请求，将请求传递给部署在“us-central1”中的名为“mycontent”的云运行服务。此外，对于来自逻辑路径“/mycontent”的任何响应，将“Cache-Control”头的值设置为“no-store”。</p><p id="1bb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于这个故事的更多视频可以在这里找到:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="e80c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考资料:</p><ul class=""><li id="0ba7" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ku kk kl km bi translated"><a class="ae kv" href="https://firebase.google.com/docs/hosting/manage-cache" rel="noopener ugc nofollow" target="_blank">管理缓存行为</a></li><li id="ab79" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn ku kk kl km bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank"> MDN —缓存控制</a></li><li id="0c40" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn ku kk kl km bi translated">博客:<a class="ae kv" href="https://cloud.google.com/blog/products/networking/enabling-hybrid-deployments-with-cloud-cdn-and-load-balancing" rel="noopener ugc nofollow" target="_blank">通过云CDN和负载平衡实现混合部署</a>2020–07</li></ul></div></div>    
</body>
</html>