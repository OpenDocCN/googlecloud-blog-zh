<html>
<head>
<title>Using Firestore database to access your Cloud Storage metadata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Firestore数据库访问您的云存储元数据</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-firestore-database-to-access-your-cloud-storage-metadata-c4d1886e8885?source=collection_archive---------2-----------------------#2022-06-26">https://medium.com/google-cloud/using-firestore-database-to-access-your-cloud-storage-metadata-c4d1886e8885?source=collection_archive---------2-----------------------#2022-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d4e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">云存储对象有关联的元数据，这些元数据保存对象的键值对。元数据有两种类型。固定键元数据，如<em class="jd">内容类型</em>、<em class="jd">内容编码</em>和<a class="ae je" href="https://cloud.google.com/storage/docs/metadata#mutable" rel="noopener ugc nofollow" target="_blank">更多</a>。我们可以设置它的值，比如"<em class="jd"> Content-Type=image/jpeg" </em></p><p id="de58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们也可以使用<a class="ae je" href="https://cloud.google.com/storage/docs/metadata#custom-metadata" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">自定义元数据</strong> </a>。使用自定义元数据，我们可以设置自己的键值对。例如，如果我们正在处理像图像这样的媒体内容，我们可以定义像"<em class="jd">类别=运动"</em>或"<em class="jd">类别=动物</em>"这样的元数据。如果我们处理发票，也许我们可以使用像“<em class="jd">发票标识</em>”、“<em class="jd">客户标识</em>”或“<em class="jd">账单周期</em>”这样的元数据。</p><p id="ddaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过控制台、命令行、REST APIs或代码来访问我们的对象元数据。这样，我们可以看到特定对象的元数据。但是，如果我们希望看到所有具有元数据值的文档，该怎么办呢？例如，给我某个客户id的所有发票？</p><p id="45ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是数据库发挥作用的地方。在这篇博客中，我们将看到Firestore是如何很好地适合访问和查询我们的自定义元数据。</p><h2 id="6040" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">为什么选择Firestore？</h2><p id="b1cd" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">Firestore是一个全面管理的、可扩展的、无服务器的文档数据库。对于这个用例，它的一些特性非常有用:</p><ul class=""><li id="3b8c" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated"><strong class="ih hj">无模式</strong>。我们不知道将使用什么元数据结构。如果需要，我们需要为对象添加新的属性，或者为不同的文档添加不同的值。</li><li id="459a" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">轻松查询</strong>。默认情况下，Firestore具有自动索引功能，因此可以确保良好的性能。</li><li id="4c44" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">无服务器全托管</strong>。我们不想在管理、调整和扩展上花费时间和精力。</li><li id="b01a" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated">无缝<strong class="ih hj">谷歌云谷歌云服务集成</strong>。我们不仅会使用Firestore，还会使用云存储、云功能和数据库访问服务，如Cloud Run或GKE。</li><li id="670b" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">性价比</strong>。Firestore有一个慷慨的<a class="ae je" href="https://cloud.google.com/firestore/pricing" rel="noopener ugc nofollow" target="_blank">免费层</a>可用，这足以让我们从开发环境的定制元数据数据库开始。</li></ul><h2 id="10f4" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">它是如何工作的？</h2><p id="c6d0" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">我们不仅要注意接收新文档，还要保持同步，因此当文档被修改时还要更新自定义元数据值，或者当对象从云存储中删除时从Firestore中删除文档。</p><p id="3dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下视频展示了该解决方案的实际应用。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><h2 id="12ad" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">体系结构</h2><p id="be33" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">我们将使用这些谷歌云组件:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es la"><img src="../Images/36f26dcb256d73118e4b82d952037d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wfIymJwGTc_USRN2"/></div></div></figure><ul class=""><li id="3a25" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated"><strong class="ih hj">云存储</strong>。我们将使用一个存储桶作为对象的存储库。这些对象将在Firestore中保存它们的自定义元数据</li><li id="edae" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">云功能</strong>。我们将触发云功能来更新Firestore的云存储事件，因此每次添加、删除、修改或归档对象时，我们都会与Firestore同步。</li><li id="969e" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj"> Firestore </strong>。用于保存和查询对象的自定义元数据值的数据库。</li></ul><h2 id="9bfc" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">解决方案部署</h2><p id="02e3" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">完整的解决方案代码可以在<a class="ae je" href="https://github.com/mahurtado/StorageCustomMetadataFirestore" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到。</p><p id="17bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用云外壳来部署解决方案。首先，我们将设置一些环境变量:</p><pre class="kt ku kv kw fd lh li lj lk aw ll bi"><span id="f48c" class="jf jg hi li b fi lm ln l lo lp">REGION=europe-west3<br/>BUCKET_NAME=`gcloud config list — format ‘value(core.project)’`<br/>COLLECTION=content</span></pre><p id="c149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此示例中，我们将在区域<em class="jd"> europe-west3 </em>上进行部署，并将使用“<em class="jd"> content </em>”作为Firestore中的集合名称。我们将创建一个与项目同名的存储桶。对所有这些都使用你自己的价值观。</p><p id="aa36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，在本机模式下创建Firestore数据库。如果出现提示，接受启用API<em class="jd">appengine.googleapis.com</em>。</p><pre class="kt ku kv kw fd lh li lj lk aw ll bi"><span id="8076" class="jf jg hi li b fi lm ln l lo lp">gcloud app create — region=$REGION<br/>gcloud firestore databases create — region=$REGION</span></pre><p id="3baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在同一地区创建一个云存储桶:</p><pre class="kt ku kv kw fd lh li lj lk aw ll bi"><span id="c9de" class="jf jg hi li b fi lm ln l lo lp">gsutil mb -l $REGION gs://$BUCKET_NAME</span></pre><p id="19f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将从<a class="ae je" href="https://github.com/mahurtado/StorageCustomMetadataFirestore" rel="noopener ugc nofollow" target="_blank">这个</a>回购的代码中创建云函数。首先，下载代码并构建:</p><pre class="kt ku kv kw fd lh li lj lk aw ll bi"><span id="9cb5" class="jf jg hi li b fi lm ln l lo lp">git clone <a class="ae je" href="https://github.com/mahurtado/StorageCustomMetadataFirestore" rel="noopener ugc nofollow" target="_blank">https://github.com/mahurtado/StorageCustomMetadataFirestore</a><br/>cd StorageCustomMetadataFirestore/CustomMetadataFirestoreCF<br/>mvn package</span></pre><p id="2f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是部署云功能。请注意，我们将为每个事件部署一个函数:</p><ul class=""><li id="ad95" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated"><strong class="ih hj">对象完成</strong>(Google . storage . Object . Finalize)。在桶中创建新对象时发送。</li><li id="e091" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">对象删除</strong>(Google . storage . Object . Delete)。删除对象时发送。</li><li id="e79f" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">对象存档</strong>(Google . storage . Object . Archive)。当对象的实时版本被存档或删除时发送。</li><li id="83a1" class="kf kg hi ih b ii ko im kp iq kq iu kr iy ks jc kk kl km kn bi translated"><strong class="ih hj">对象元数据更新</strong>(Google . storage . Object . Metadata Update)当现有对象的元数据发生变化时发送。</li></ul><pre class="kt ku kv kw fd lh li lj lk aw ll bi"><span id="4b30" class="jf jg hi li b fi lm ln l lo lp">gcloud services enable cloudbuild.googleapis.com<br/> <br/>gcloud functions deploy content-gcs-insert \<br/> — set-env-vars COLLECTION=$COLLECTION \<br/> — region $REGION \<br/> — entry-point com.manolo.content.InsertFile \<br/> — runtime java11 \<br/> — memory 512MB \<br/> — trigger-resource $GOOGLE_CLOUD_PROJECT \<br/> — trigger-event google.storage.object.finalize \<br/> — source=target/deployment<br/> <br/>gcloud functions deploy content-gcs-delete \<br/> — set-env-vars COLLECTION=$COLLECTION \<br/> — region $REGION \<br/> — entry-point com.manolo.content.InsertFile \<br/> — runtime java11 \<br/> — memory 512MB \<br/> — trigger-resource $GOOGLE_CLOUD_PROJECT \<br/> — trigger-event google.storage.object.delete \<br/> — source=target/deployment<br/> <br/>gcloud functions deploy content-gcs-metadata-update \<br/> — set-env-vars COLLECTION=$COLLECTION \<br/> — region $REGION \<br/> — entry-point com.manolo.content.InsertFile \<br/> — runtime java11 \<br/> — memory 512MB \<br/> — trigger-resource $GOOGLE_CLOUD_PROJECT \<br/> — trigger-event google.storage.object.metadataUpdate \<br/> — source=target/deployment<br/> <br/>gcloud functions deploy content-gcs-metadata-archive \<br/> — set-env-vars COLLECTION=$COLLECTION \<br/> — region $REGION \<br/> — entry-point com.manolo.content.InsertFile \<br/> — runtime java11 \<br/> — memory 512MB \<br/> — trigger-resource $GOOGLE_CLOUD_PROJECT \<br/> — trigger-event google.storage.object.archive \<br/> — source=target/deployment</span></pre><p id="2e61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在运行我们的功能之前，我们需要让他们访问Firestore和云存储:</p><pre class="kt ku kv kw fd lh li lj lk aw ll bi"><span id="efac" class="jf jg hi li b fi lm ln l lo lp">gcloud projects add-iam-policy-binding ${GOOGLE_CLOUD_PROJECT} \ --member=serviceAccount:${<a class="ae je" href="mailto:GOOGLE_CLOUD_PROJECT}&lt;a href=" rel="noopener ugc nofollow" target="_blank">@appspot</a>.gserviceaccount.com”&gt;GOOGLE_CLOUD_PROJECT}<a class="ae je" href="http://twitter.com/appspot" rel="noopener ugc nofollow" target="_blank">@appspot</a>.gserviceaccount.com \<br/> --role=roles/storage.objectAdmin<br/> <br/>gcloud projects add-iam-policy-binding ${GOOGLE_CLOUD_PROJECT} \ --member=serviceAccount:${<a class="ae je" href="mailto:GOOGLE_CLOUD_PROJECT}&lt;a href=" rel="noopener ugc nofollow" target="_blank">@appspot</a>.gserviceaccount.com”&gt;GOOGLE_CLOUD_PROJECT}<a class="ae je" href="http://twitter.com/appspot" rel="noopener ugc nofollow" target="_blank">@appspot</a>.gserviceaccount.com \<br/> --role=roles/datastore.user</span></pre><p id="bb1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为检查点，在云控制台&gt; IAM中搜索:查找服务帐户[ <em class="jd">您的项目name]@appspot.gserviceaccount.com</em>。它应该是这样的:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lq"><img src="../Images/17b7c8b02df474895b5e3ede0c04df07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n0krJle43UT7uXeU"/></div></div></figure><p id="0ab1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以看到部署的云功能:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lr"><img src="../Images/a3d09a078e33cff7fcdce4e5e8cdb36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fRCSt3GUrkYa71uU"/></div></div></figure><h2 id="eab5" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">测试</h2><p id="9909" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">至此，解决方案已经就绪。上传到您的存储桶的任何对象都将启动云功能，并将您的自定义元数据保存在Firestore中。</p><p id="34f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用控制台上传文件，如视频所示，或者使用命令行。使用自定义元数据关键字“<em class="jd"> key1 </em>”和值“<em class="jd"> value1 </em>”创建对象的示例如下所示:</p><pre class="kt ku kv kw fd lh li lj lk aw ll bi"><span id="04f4" class="jf jg hi li b fi lm ln l lo lp">gsutil -h “x-goog-meta-key1:value1” cp [path_to_your_file] gs://$GOOGLE_CLOUD_PROJECT</span></pre><p id="3b28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用控制台访问Firestore并查看您的元数据！</p><h2 id="85d4" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">看一看代码</h2><p id="3da9" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">最后，让我们看看用于云功能的Java代码(完整源代码<a class="ae je" href="https://github.com/mahurtado/StorageCustomMetadataFirestore/blob/main/CustomMetadataFirestoreCF/src/main/java/com/manolo/content/InsertFile.java" rel="noopener ugc nofollow" target="_blank">在这里</a>)。接收事件时要运行的代码是方法"<em class="jd"> accept </em>"</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ls kz l"/></div></figure><p id="959b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，我们将对所有事件使用相同的代码，并将根据事件类型确定要执行的方法。注意我们是如何为对象创建和对象更新调用<em class="jd">dofinalize</em>方法的。</p><p id="e69e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<strong class="ih hj"> logEvent </strong>调用，它将为每个事件保存一个日志跟踪。考虑将其注释为大吞吐量场景。</p><p id="9944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们为对象删除和归档调用方法<em class="jd"> doDelete </em>。</p><p id="caa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当创建或修改对象时，执行以下代码:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ls kz l"/></div></figure><p id="32c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先用自定义元数据构造一个文档，并将其写入Firestore。更新的管理方式与插入相同。</p><p id="4c1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为文档密钥，我们使用完整的对象云存储名称，但我们必须用不同的名称来更改<strong class="ih hj">路径分隔符</strong>，比如“::”，因为Firestore不支持将其作为文档密钥的一部分。</p><p id="de0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一段代码显示了如何管理文档删除:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ls kz l"/></div></figure><h2 id="b1be" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">关于无序处理</h2><p id="94c5" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">存储事件建立在发布/订阅消息的基础上。这意味着至少一次交付，因此我们必须处理给定事件执行多次的机会，如<a class="ae je" href="https://cloud.google.com/functions/docs/calling/storage#event_types" rel="noopener ugc nofollow" target="_blank">公共文档</a>中所述。</p><p id="c565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了管理这一点，我们实现了<a class="ae je" href="https://cloud.google.com/firestore/docs/samples/firestore-transaction-document-update-conditional" rel="noopener ugc nofollow" target="_blank">条件写入</a>，使用<strong class="ih hj">_更新的</strong>字段来避免重复和无序写入。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ls kz l"/></div></figure><h2 id="d04e" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">结论</h2><p id="aa08" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">借助该解决方案，我们可以访问云存储对象的自定义元数据，包括使用Firestore功能的直接访问或复杂查询。</p></div></div>    
</body>
</html>