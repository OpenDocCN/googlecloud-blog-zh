<html>
<head>
<title>Adding Social Login to your .NET App Engine Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将社交登录添加到您的。NET App引擎应用程序</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/adding-social-login-to-your-net-app-engine-application-9b7f4149eb73?source=collection_archive---------0-----------------------#2017-06-20">https://medium.com/google-cloud/adding-social-login-to-your-net-app-engine-application-9b7f4149eb73?source=collection_archive---------0-----------------------#2017-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="5ba2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">这个帖子现在已经过时了！</h1><p id="1018" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">请看我的<a class="ae kb" rel="noopener" href="/@SurferJeff/adding-social-login-to-your-asp-net-core-2-1-google-cloud-platform-application-1baae89f1dc8">新帖</a>，它演示了将社交登录添加到ASP.NET核心<em class="kc"> 2.1 </em>应用中。这篇旧文章展示了老ASP.NET核心1.1应用程序的相同之处</p><p id="3ec2" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">用户厌倦了为他们访问的每个网站创建新的登录名和密码。2013年，<a class="ae kb" href="http://www.webhostingbuzz.com/blog/2013/03/21/whos-sharing-what/" rel="noopener ugc nofollow" target="_blank">的一项调查</a>发现，86%的人表示他们被在网站上创建新账户的需求所困扰。这个数字今天可能变得更大了。就我个人而言，我在我的密码管理器中记录了超过100次登录和密码。</p><p id="5d74" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">根据<a class="ae kb" href="http://www.webhostingbuzz.com/blog/2013/03/21/whos-sharing-what/" rel="noopener ugc nofollow" target="_blank">调查</a>显示，77%的用户倾向于一个更好的解决方案，即允许用户使用他们最喜欢的社交账户登录，无论是脸书、推特还是谷歌。对于用户来说，社交登录消除了使用你网站的障碍。<a class="ae kb" href="https://developers.facebook.com/case-studies/saavn" rel="noopener ugc nofollow" target="_blank"> Saavn发现使用脸书登录的听众参与度提高了65%</a>。<a class="ae kb" href="https://developers.facebook.com/case-studies/skyscanner" rel="noopener ugc nofollow" target="_blank"> Skyscanner在交互方面也有令人印象深刻的改进。</a></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/a1099db0de8480791bd0ac0f70e112af.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/0*foKza0NE16KWSp0O."/></div></figure><p id="7ac5" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">好消息是微软已经提供了。NET程序员使用库来简化将社交登录集成到他们的。NET MVC核心web应用程序。他们还提供了优秀的文档，描述如何为所有流行的提供商添加社交登录。我按照这些文档中的说明，迅速将社交登录添加到我的。NET core web app。我按下F5在我的开发机器上运行应用程序，点击<strong class="jf hj">用脸书</strong>登录，它就工作了！耶！</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es kq"><img src="../Images/afe04c4da8f61abf80a9407a4ec17cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/0*9VRDMFBp_cUna_a2."/></div></figure><p id="6bf5" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">然后我试着将它部署到Google App Engine，看到了一条错误消息:</p><pre class="kj kk kl km fd kr ks kt ku aw kv bi"><span id="0109" class="kw ig hi ks b fi kx ky l kz la">Unhandled Exception: System.ArgumentException: The ‘ClientId’ option must be provided.</span><span id="fc57" class="kw ig hi ks b fi lb ky l kz la">at Microsoft.AspNetCore.Authentication.Facebook.FacebookMiddleware..ctor(RequestDelegate next, IDataProtectionProvides`1 sharedOptions, IOptions`1 options)</span></pre><p id="c781" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">结果是，我需要对我的MVC Web应用程序做一些调整，以使社交登录在App Engine上运行时工作。事实上，这些调整对于运行任何。App Engine上的NET core MVC应用。我在下面描述了这些问题及其解决方案。</p><h1 id="866d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">App Engine不知道我的脸书AppSecret。</h1><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lc"><img src="../Images/3a5cbfc1ae2d38b231fc58d2da3710b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/0*VyhtPCDmFHC5-Woe."/></div></figure><p id="d6f1" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">为了让用户能够登录脸书，我创建了一个脸书应用程序，如微软的<a class="ae kb" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/facebook-logins" rel="noopener ugc nofollow" target="_blank">文档</a>中所述。脸书给了我一个AppSecret，这是一个秘密字符串，当我想验证一个用户时，我会将它传递给脸书。当我在我的开发机器上运行程序时，我使用dotnet的<a class="ae kb" href="https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets" rel="noopener ugc nofollow" target="_blank"> Secret Manager工具</a>存储了这个秘密，如下所示:</p><p id="0b23" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated"><code class="du ld le lf ks b">dotnet user-secrets set Authentication:Facebook:AppSecret &lt;app-secret&gt;</code></p><p id="74d4" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">当然，dotnet命令将秘密存储在我的开发机器上，当我的应用程序运行在App Engine上时，它无法访问我的开发机器。当我在App Engine上运行应用程序时，上面的异常报错了，因为我向<code class="du ld le lf ks b">app.UseFacebookAuthentication()</code>传递了一个空的脸书ClientId。我需要一种安全的方式将AppSecret分发到我的应用引擎实例。我可以把它保存在我的appsettings.json中，但是我的AppSecret会被签入git，并最终在<a class="ae kb" href="https://github.com/" rel="noopener ugc nofollow" target="_blank">github.com</a>上被所有人看到。我的AppSecret将立即变成非秘密！</p><p id="320e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated"><a class="ae kb" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata" rel="noopener ugc nofollow" target="_blank">元数据</a>来救援了！Google App Engine和Compute Engine允许您将键值对存储在元数据中，这是安全的，可以由App Engine实例读取。我用如下命令设置元数据:</p><p id="9579" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated"><code class="du ld le lf ks b">gcloud compute project-info add-metadata — metadata=$key=$value</code></p><p id="97e8" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">实际上，我<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth/Upload-UserSecrets.ps1" rel="noopener ugc nofollow" target="_blank">写了一个脚本</a>将所有相关的用户机密复制到元数据中。然后，我<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth/Services/MetadataConfigurationSource.cs" rel="noopener ugc nofollow" target="_blank">写了</a>一个ConfigurationProvider，它在App Engine上运行时读取元数据。</p><p id="4887" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">新法规解决了这个问题。我成功部署到应用引擎，但是当我访问我的应用主页时，我看到一个错误:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lg"><img src="../Images/2c6b6739f2fb2b5c593c433aebf7a580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/0*vZH0zZtreap94-Mh."/></div></figure><h1 id="dce0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">应用引擎和HTTPS</h1><p id="a026" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">社交登录提供商需要HTTPS连接来防止各种攻击。为了强制浏览器通过HTTPS连接到我的应用程序，我在<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth/Startup.cs" rel="noopener ugc nofollow" target="_blank"> Startup.cs </a>中添加了以下三行代码:</p><pre class="kj kk kl km fd kr ks kt ku aw kv bi"><span id="22a3" class="kw ig hi ks b fi kx ky l kz la">var rewriteOptions = new RewriteOptions();<br/>rewriteOptions.AddRedirectToHttps(302, 44393);<br/>app.UseRewriter(rewriteOptions);</span></pre><p id="92cf" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">这在本地运行时工作正常，但当我部署到App Engine时失败了，因为App Engine负载平衡器侦听HTTPS的默认端口443。因此，我更改了代码，将HTTP请求重定向到端口号443，重新编译并部署了我的应用程序，然后看到:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lh"><img src="../Images/e04a0b74b1b9712009cdbd45adb62057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*EdrBUM6ydzGUEdzU."/></div></figure><p id="0b71" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">这是怎么回事？</p><p id="8f09" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated"><strong class="jf hj"> App Engine让HTTPS看起来像HTTP </strong>。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es li"><img src="../Images/556599ad2149b0bd51931902f51b10b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*JsUMhTnqc3rqkMoQ."/></div></figure><p id="ccf1" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">当我在浏览器中输入<a class="ae kb" href="https://my-app.appspot.com/" rel="noopener ugc nofollow" target="_blank">https://my-app.appspot.com/</a>时，我的应用程序看到一个具有以下属性的请求:</p><pre class="kj kk kl km fd kr ks kt ku aw kv bi"><span id="cc4b" class="kw ig hi ks b fi kx ky l kz la">Scheme: http<br/>X-Forwarded-Proto: https</span></pre><p id="53bd" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">如谷歌的<a class="ae kb" href="https://cloud.google.com/appengine/docs/flexible/dotnet/how-requests-are-handled" rel="noopener ugc nofollow" target="_blank">应用引擎文档</a>所述:</p><blockquote class="lj lk ll"><p id="2173" class="jd je kc jf b jg kd ji jj jk ke jm jn lm kf jq jr ln kg ju jv lo kh jy jz ka hb bi translated">Google Cloud负载平衡器终止所有https连接，然后通过http将流量转发给App Engine实例。例如，如果用户通过<a class="ae kb" href="https://[MY-PROJECT-ID].appspot.com," rel="noopener ugc nofollow" target="_blank">https://[MY-PROJECT-ID]. appspot . com请求访问您的站点，</a>X-Forwarded-Proto头值是https。</p></blockquote><p id="6c3e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">当我的应用程序收到一个HTTPS请求时，重写器并不认为它是HTTPS。相反，它看到了<code class="du ld le lf ks b">Scheme: http</code>，并决定仍然需要将请求重定向到HTTPS。因此，它将请求重定向到它所请求的完全相同的url，导致重定向的无限循环。我需要让重写者明白传入的请求实际上是HTTPS。</p><p id="e361" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">感谢构建AspNetCore的优秀开发人员，他们提供了一种以自定义方式重写传入请求的方法。为了重写传入的请求，我<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth/Services/RewriteHttpsOnAppEngine.cs" rel="noopener ugc nofollow" target="_blank">实现了</a>一个微软。检查X-Forwarded-Proto的AspNetCore.Rewrite.IRule。当X-Forwarded-Proto设置为https时，我的IRule将方案重置为https。</p><pre class="kj kk kl km fd kr ks kt ku aw kv bi"><span id="89b4" class="kw ig hi ks b fi kx ky l kz la">string proto = request.Headers[“X-Forwarded-Proto”]<br/>  .FirstOrDefault();<br/>if (proto == “https”) {<br/>  request.IsHttps = true;<br/>  request.Scheme = “https”;<br/>  return true;</span></pre><p id="4d67" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">有了这个新的IRule，我把我的应用程序重新部署到App Engine，HTTPS开始工作了。耶。我用脸书点击<strong class="jf hj">登录，看到这个错误页面:</strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lp"><img src="../Images/b970a89fd61a4848f862b09cb745002d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ueHO3vfIlbIJRfIN."/></div></figure><h1 id="c595" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">显示错误信息。</h1><p id="e4a9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正如你在上面看到的，错误页面隐藏了所有重要的细节。为了调试这个问题，我需要查看详细信息。我不想将开发模式应用程序部署到App Engine，因为那会有暴露我的秘密的风险。所以，我增加了对谷歌的依赖。Cloud.Diagnostics.AspNetCore并在我的<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth/Startup.cs" rel="noopener ugc nofollow" target="_blank"> StartUp.cs </a>中添加了一条语句:</p><pre class="kj kk kl km fd kr ks kt ku aw kv bi"><span id="6c65" class="kw ig hi ks b fi kx ky l kz la">services.AddGoogleExceptionLogging(projectId,<br/>  Configuration[“GoogleErrorReporting:ServiceName”],<br/>  Configuration[“GoogleErrorReporting:Version”]);</span></pre><p id="7a18" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">然后，我可以在谷歌云控制台中看到完整的错误消息:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/8f051c533469d92c078260774e20cb66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3F42aYHv6SxT4ao6."/></div></div></figure><p id="3b15" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">微软。AspNetCore.Dataprotection试图解密某些内容，但找不到密钥。这是怎么回事？</p><h1 id="3683" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">AspNetCore的默认<a class="ae kb" href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.aspnetcore.dataprotection.dataprotectionprovider" rel="noopener ugc nofollow" target="_blank"> DataProtectionProvider </a>不能跨多个web服务器实例工作。</h1><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es li"><img src="../Images/56480fe8a656473d181bc5da8d2e53ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*bagcf0MYMoBaGaoq."/></div></figure><p id="7882" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">像微软这样的社交登录中间件。AspNetCore . authentic ation . Facebook需要加密。同样，AspNetCore在预见这种需求方面做得很好，它提供了一个标准接口IDataProtectionProvider来提供加密。但是，问题是默认的IDataProtectionProvider在web服务器上本地存储加密密钥。然而，在App Engine上，总是有多个web服务器，并且每个web服务器都有不同的密钥。此外,(通过设计)预测一个请求将被路由到哪个web服务器是不可能的。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es lv"><img src="../Images/0962191d6360f313b4fece9e255de823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*KQf2oZreJuuQTYU6MUuX5A.png"/></div></figure><p id="5307" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">这在以下情况下会成为一个问题:</p><ol class=""><li id="1aee" class="lw lx hi jf b jg kd jk ke jo ly js lz jw ma ka mb mc md me bi translated">一个请求被路由到Web服务器1，Web服务器1用一个用密钥加密的新cookie进行响应。</li><li id="ee33" class="lw lx hi jf b jg mf jk mg jo mh js mi jw mj ka mb mc md me bi translated">带有加密cookie的后续请求被路由到Web服务器2，Web服务器2试图用密钥解密cookie，但没有A密钥。</li></ol><p id="d146" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">幸运的是，谷歌创造了<a class="ae kb" href="https://cloud.google.com/kms/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=2017-q1-cloud-na-kms-freetrial-en&amp;dclid=CIrJ-pKXw9QCFY8oaQodinQNsA" rel="noopener ugc nofollow" target="_blank">云密钥管理服务</a>来解决这类问题。所以我<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth/Services/KmsDataProtectionProvider.cs" rel="noopener ugc nofollow" target="_blank">实现了</a>我自己的IDataProtectionProvider，它使用谷歌KMS来管理密钥。</p><p id="6916" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">我将我的应用程序重新部署到应用引擎，再次点击<strong class="jf hj">用脸书</strong>登录，我看到成功了！</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es mk"><img src="../Images/225277745e637bf69bb8fe3fcbc6fb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/0*WExjnyjaQiRLKl6m."/></div></figure><h1 id="d103" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="0ea5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了让我的应用程序在谷歌应用引擎上正常工作，我花了一些功夫，但结果是一个应用程序能够保守秘密，并随着负载的增加自动扩展。相当不错。感谢AspNetCore精心设计的界面和功能，以及Google精心设计的服务，不需要任何黑客攻击！只需做一点工作就能让事情协调起来。</p><p id="47dc" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">Google的Cloud Tools for Visual Studio团队正在努力将所有这些解决方案构建成一个新的库和一个新的项目模板。当它发布时，您将能够在Visual Studio中选择一个新的<strong class="jf hj"> App Engine Flex MVC项目</strong>，并享受所有这些集成，而无需额外的工作。</p><p id="c113" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">在那之前，你可以自己构建并运行<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/tree/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth" rel="noopener ugc nofollow" target="_blank">我的项目</a>！请随意浏览我们<a class="ae kb" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/tree/895dc320212a56d558845a1ec6508424aae9c3bc/appengine/flexible/SocialAuth" rel="noopener ugc nofollow" target="_blank"> github资源库</a>中的完整代码，并在该资源库中记录问题。</p></div></div>    
</body>
</html>