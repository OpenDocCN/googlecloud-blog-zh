<html>
<head>
<title>From Zero to Hero — run parse-server on Google Cloud Platform Part 1— Run parse-server and MongoDB locally with docker-compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到英雄—在Google云平台上运行parse-server第1部分—使用docker-compose在本地运行parse-server和MongoDB</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/from-zero-to-hero-run-parse-server-on-google-cloud-platform-part-1-run-parse-server-and-mongodb-63a5f89f670d?source=collection_archive---------0-----------------------#2017-05-17">https://medium.com/google-cloud/from-zero-to-hero-run-parse-server-on-google-cloud-platform-part-1-run-parse-server-and-mongodb-63a5f89f670d?source=collection_archive---------0-----------------------#2017-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文是关于如何在GCP容器引擎上运行解析服务器的系列博客的第1部分。在你开始阅读这篇博客之前，请参考该系列的第0部分，即<a class="ae jd" rel="noopener" href="/@ran.hassid/from-zero-to-hero-run-parse-server-on-google-cloud-platform-part-0-introduction-54e7725c7ba0">引言</a>部分。</p><p id="ca92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一部分中，我将展示如何通过docker compose在本地机器上运行parse-server + MongoDB容器。如果你已经熟悉Docker或parse-server，请随意跳过理论部分。</p><h1 id="c093" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Docker和Docker Compose(理论)</h1><p id="57ac" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们将使用docker，特别是我们将使用docker compose在本地机器上运行应用程序。Docker是最流行的软件容器平台，允许开发者在“类似生产的环境”中运行他们的应用和解决方案。Docker与<strong class="ih hj">容器</strong>一起工作，每个容器都包含运行软件所需的所有东西，不像虚拟机那样与完整的操作系统紧密相关。</p><p id="23e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将应用容器化的基本步骤是:</p><ol class=""><li id="cd9c" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">创建docker文件docker文件包含依赖项、卷、工作目录和需要由docker工具在构建时执行的命令。</li><li id="1148" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Docker build——build命令将访问您的docker文件，并开始逐行运行其中的命令，因此docker文件中命令的顺序非常重要。结果将是一个docker图像，其中包含运行应用程序所需的所有代码、设置和资源</li><li id="084e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">docker run——<strong class="ih hj">docker run</strong>命令将检查您想要运行的图像，从该图像创建一个容器并最终运行它。</li></ol><p id="c25f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Dockerhub </strong></p><p id="0fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了docker，你可以运行多个可以互相对话(链接)的容器(有人说“微服务”？)由于软件世界中最大的生态系统之一，通常你甚至不需要自己构建这样的映像，你只需从<a class="ae jd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">docker hub</strong></a><strong class="ih hj"/>下载它们即可，这是一个拥有成千上万docker映像的注册表(或存储库)。所以，在你自己创建一个图像之前，检查一下这个图像是否已经存在。</p><p id="aca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Docker撰写</strong></p><p id="6bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker Compose是一个允许你在一个命令中构建和运行多个容器化Docker应用程序的工具。为了使用这个工具，您首先需要创建一些<strong class="ih hj"> yml </strong>文件，其中包含您想要运行的所有图像、它们的配置以及它们之间的关系。在我们的例子中，我们将使用包含两个图像的docker-compose:</p><ol class=""><li id="caf9" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">我们将自己构建的解析服务器映像</li><li id="7773" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">MongoDB图像，这将是我们的应用程序的持久性。该图像将从dockerhub中提取。</li></ol><p id="fa33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解析服务器映像将<strong class="ih hj">链接</strong>到MongoDB映像。通过将这两个映像链接在一起，我们告诉docker解析服务器容器需要与MongoDB容器“对话”。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="7044" class="je jf hi bd jg jh lc jj jk jl ld jn jo jp le jr js jt lf jv jw jx lg jz ka kb bi translated">解析服务器(理论上)</h1><p id="5ccc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">parse-server是一个开源的BaaS(后端即服务)解决方案，最初由parse.com团队开发。parse.com的目的是让开发者专注于构建客户端应用程序(无论是在iOS/Android/Web还是其他平台)，他们的平台将负责服务器端(后端)部分。parse.com很快成为构建此类应用的最受欢迎的平台，这也是他们被脸书收购的原因。收购两年后，脸书认为parse.com服务不是他们战略的一部分，他们决定关闭这项服务。他们通知成千上万的客户迁移他们的数据，要么自己托管，要么寻找其他解决方案。</p><p id="0884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个故事中最棒的是<a class="ae jd" href="https://github.com/parse-community/parse-server" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">解析服务器</strong> </a>开源。parse.com团队决定将他们的解决方案开源，并将其命名为parse-server。起初，他们非常积极地参与，并通过帮助客户将他们的parse.com应用迁移到parse-server来为客户提供非常好的支持，但现在他们不再活跃了。</p><p id="9ab4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">parse-server 100%用NodeJS编写，使用MongoDB作为主数据库。parse-server负责与后端开发相关的所有事情，以便让开发人员专注于构建前端应用程序。parse-server非常稳定，有很好的文档记录，并由社区中的一些开发人员维护(我就是其中之一:)。<br/>列出parse-server的所有特性将花费我几个小时的时间，因此我将只关注最重要的特性:</p><ol class=""><li id="74a0" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">自动创建客户端类——这个特性允许您直接从客户端创建解析对象，因此开发人员甚至不需要在MongoDB中创建相关的集合。当您想要创建一个新对象时，只需通过一个客户端SDK来创建它。这也与向集合添加/移除属性以及在它们之间创建关系相关。<br/> BTW！由于安全问题，一些开发人员并不真正喜欢这个特性，所以在parse-server中，如果你愿意，你可以很容易地关闭这个特性。</li><li id="7d24" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">用户管理— parse-server提供了非常强大的用户管理系统。有了这个功能，你可以:登录用户，注册新用户，登录用户和链接他们与第三方提供一样:facebook，谷歌，github，instegram，twitter和更多。</li><li id="3940" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">ACL——ACL代表访问控制列表。解析使用ACL来保护对象不被不允许的用户读取/修改。</li><li id="77e8" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">插件基础架构——parse-server中的大多数功能都是通过插件构建的，因此如果您有一些当前解决方案无法满足的需求，您可以(可能)创建一个适配器来替换默认的适配器。例如:假设您希望允许您的用户使用<strong class="ih hj"> snapchat </strong>登录，您可以轻松创建<strong class="ih hj">身份验证适配器</strong>，实现所有相关代码，提供一些配置，然后将其添加到解析服务器配置对象中，从现在开始，您的用户也可以使用他们的<strong class="ih hj"> snapchat </strong>帐户登录。</li><li id="d9cd" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">地理点—使用parse-server，您可以轻松创建地理字段来存储用户/企业在世界上的位置。此外，通过GeoQuery，您可以执行高级查询，如:显示距离我当前位置100英里以外的用户列表等。</li><li id="fb29" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">推送通知—使用parse-server，您可以通过平台SDK轻松地向一个或多个用户发送推送通知。它的工作原理是为每个用户设备创建一个安装对象，这样每次安装都会存储设备令牌和有关用户设备的更多细节。</li><li id="10b4" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">实时查询——实时查询允许您在<strong class="ih hj">实时</strong>订阅数据库中的变化。如果您熟悉其他解决方案，如<strong class="ih hj"> RethinkDB </strong>或<strong class="ih hj"> Firebase实时数据库</strong>，那么您也会很容易理解这个概念。在live query中，您可以订阅MongoDB中的更改，然后解析服务器会在对象发生更改时实时通知您。在我的应用程序中，我使用这个功能来了解我朋友的状态(当他们在线/离线时)。实时查询基于WebSocket，工作速度非常快。如果您的应用程序需要大规模工作，您可以将解析实时查询服务器与发布/订阅解决方案集成在一起。目前只有Redis pub/sub，RabbitMQ和GCP pub/sub可用，所以如果你有其他喜欢的pub/sub解决方案，你可以简单地创建一个适配器并使用它。</li><li id="5da5" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">客户端SDK/Rest API——解析服务器客户端SDK可用于最流行的编程语言:iOS、Android、JS/NodeJS、PHP、. NET. Unity等等。在部分客户端SDK中，您可以使用<strong class="ih hj">本地数据存储</strong>，它为您提供自动同步功能，并允许您创建离线优先应用程序。如果您不喜欢SDK的parse-server REST API也是可用的。</li><li id="3b6d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">云代码函数和钩子— <strong class="ih hj">云函数</strong>允许您编写自己的定制逻辑，并在parse-server上运行它们。云函数是用NodeJS编写的，可以简单也可以复杂，唯一需要理解的是云函数是无状态的:你发送一个请求，解析服务器处理这个请求并返回一个响应。<br/> <strong class="ih hj">钩子</strong>允许你写一些代码，这些代码将被平台触发以响应一些普通的事件，比如:保存前、保存后、删除前、删除后，所以如果你想在数据库中保存用户之前运行一些定制的逻辑，只需在用户对象上创建一个保存前钩子。</li></ol><p id="6324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我上面提到的，这些只是parse-server功能的一部分。您可以在<a class="ae jd" href="http://docs.parseplatform.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">官方文档网站</strong> </a>中了解更多其他功能，如:电子邮件集成、日志记录、文件存储支持、媒体文件等</p><h1 id="b8bf" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">诺杰斯和NPM(理论上)</h1><p id="6a6b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">节点包管理器是一个非常强大的工具，它允许NodeJS开发人员通过向他们的项目添加<strong class="ih hj">现成的</strong> NodeJS模块来重用代码。您可以添加数百万个模块来帮助您加速开发，并将TCD(开发总成本)降低一半以上。此外，npm还是一个依赖项管理器，这意味着当您向项目中添加一个npm模块时，它会自动添加该模块所依赖的所有其他模块。</p><h1 id="1c3e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">MongoDB(理论)</h1><p id="2afc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">parse-server使用MongoDB作为持久层，因此您创建、更新、删除和读取的所有数据都将持久存储到MongoDB中。MongoDB是一个非常强大和最受欢迎的NoSQL数据库。MongoDB将数据存储在二进制文档JSON对象(又名DocumentDB)中。<br/> MongoDB非常快，易于扩展，无模式，易于使用。就像我上面提到的，parse-serve最大的特性之一是动态创建/生成集合的能力，这是因为MongoDB允许这样做。</p><p id="7062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意！MongoDB是一个非常强大的数据库，但它并不适合任何用例。由于MongoDB是NoSQL，它不支持事务，并且在部分应用程序中事务是强制的，因为使用事务可以确保数据始终一致，并且可以运行多个相互依赖的查询，并将它们包装在一个事务中，这是MongoDB无法做到的。</p><h1 id="d274" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">先决条件安装</h1><h2 id="4afd" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">码头工人</h2><p id="e1b5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们首先需要安装的是Docker，它将在您的机器上安装docker CLI和docker-compose工具。幸运的是，docker团队为Mac和Windows创建了一个惊人的安装程序，只需点击一个按钮就可以安装。</p><p id="bcf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在您的本地机器上安装docker，请访问docker商店上的<a class="ae jd" href="https://store.docker.com/editions/community/docker-ce-desktop-mac?tab=description" rel="noopener ugc nofollow" target="_blank">下载页面，点击Get Docker CE for Mac (Stable)按钮，并按照Docker商店网站上的说明进行操作。该安装程序将在您的本地机器上安装docker工具箱和docker CLI。</a></p><p id="c7d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装docker后，你会在你的mac状态栏上看到流行的docker whale。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es lv"><img src="../Images/95c28747dcd0aedef65e85ad60d82f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*sWonym0B9EQIhPADJYoPTA.png"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">从码头商店拿的</figcaption></figure><p id="125d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查一切正常的另一种方法是打开mac终端并运行docker命令，如果您看到以下内容:</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mh"><img src="../Images/44f527a1a1f6e2a5960383cafbba7c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dP2z6LcZpkhAIKClEJZasg.png"/></div></div></figure><p id="f553" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着你的机器上安装了docker。</p><h2 id="4b38" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">Node.js +节点包管理器(npm)</h2><p id="5a79" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">下载npm + NodeJS最好的地方是Node.js官网。进入<a class="ae jd" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js下载页面</a>，点击<strong class="ih hj"> v7.10.0当前绿色按钮</strong>，下载Node.js安装程序，执行安装程序在您的机器上安装Node.js。</p><p id="fd84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查Node.js + npm是否已成功安装在您的计算机上，您可以打开终端并执行以下命令:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="0bfa" class="lh jf hi mn b fi mr ms l mt mu">npm -v</span></pre><p id="ea39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">键入此命令后，您应该会看到安装在您的计算机上的npm版本。</p><h2 id="0b88" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">MongoDB</h2><p id="f09e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">下载和安装MongoDB最好的地方是从<a class="ae jd" href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" rel="noopener ugc nofollow" target="_blank"> MongoDB官方网站</a>。有两种方式安装它:手动或使用家酿，我推荐通过<strong class="ih hj">家酿</strong>安装，因为它更容易和直观。</p><p id="244d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查MongoDB是否安装在您的本地机器上，请打开终端并执行以下命令:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="b027" class="lh jf hi mn b fi mr ms l mt mu">mongod</span></pre><p id="4e42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在输入这个命令之后，您应该看到MongoDB正在启动并等待默认端口27017上的连接。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mv"><img src="../Images/36179c3e913e804186494cde61496687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pi-9SpOH6MAr1Yxmt_00GQ.png"/></div></div></figure><p id="9a40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在所有的东西都已经安装在本地机器上了，您可以进入下一个阶段，创建、运行和测试您的parse-server Node.js应用程序。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="656d" class="je jf hi bd jg jh lc jj jk jl ld jn jo jp le jr js jt lf jv jw jx lg jz ka kb bi translated"><strong class="ak">创建您的解析服务器应用程序(实用)</strong></h1><h2 id="5ed5" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">设置</h2><p id="8c00" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">打开终端，导航到您通常存储所有开发项目的位置，并创建一个名为<strong class="ih hj"> myFirstParseServerApp </strong>的新文件夹</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="d116" class="lh jf hi mn b fi mr ms l mt mu">mkdir myFirstParseServerApp</span></pre><p id="0013" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航到您刚刚创建的文件夹，并在其中创建另一个文件夹，将其命名为<strong class="ih hj"> app </strong>，最后导航到app文件夹。</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="c61a" class="lh jf hi mn b fi mr ms l mt mu">cd myFirstParseServerApp/<br/>mkdir app<br/>cd app/</span></pre><p id="30b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在app文件夹中运行<strong class="ih hj"> npm init </strong>来初始化一个新的Node.js应用程序。运行此命令时，npm CLI会提示您有关应用程序名称、默认页面等问题。请填写相关细节，如应用程序名称、描述、作者姓名和许可证，然后继续。在我的例子中，它看起来如下:</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mw"><img src="../Images/388a1218f13f79b634729fcf63d0a345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*u7r1xFhQfAuoF6Pk7VTpYw.png"/></div></div></figure><p id="53a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行npm init命令后，您将只看到项目的<strong class="ih hj"> app </strong>文件夹中的一个文件，文件名是<strong class="ih hj"> package.json </strong>。</p><p id="c449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">package.json是描述Node.js应用程序的文件。该文件包含应用程序的名称、描述、作者、版本等。为了亲眼看看这个文件的样子，你可以用任何编辑器打开它。我个人使用的是<a class="ae jd" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>，这是一个非常棒的用户友好的编辑器，可以很好地处理Node.js应用程序。我这边package.json的内容是:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="194f" class="lh jf hi mn b fi mr ms l mt mu">{<br/>"name": "myfirstparseserverapp",<br/>"version": "1.0.0",<br/>"description": "My first parse-server application",<br/>"main": "index.js",<br/>"scripts": {<br/>"test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>},<br/>"keywords": [<br/>"parse-server"<br/>],<br/>"author": "Ran Hassid",<br/>"license": "MIT"<br/>}</span></pre><p id="1561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你这边应该是一样的，除了作者的名字。</p><h2 id="2b5f" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">将解析服务器添加为依赖项</h2><p id="2b2d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们要做的下一件事是将解析服务器模块添加到我们的应用程序中。正如我前面提到的，解析服务器模块托管在<a class="ae jd" href="https://www.npmjs.com/package/parse-server" rel="noopener ugc nofollow" target="_blank">npmjs.org</a>上。这允许您运行非常简单的命令，以便将其添加到您的项目中，所以让我们这样做。<br/>在终端中，导航到<strong class="ih hj"> app </strong>文件夹，运行以下命令:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="675b" class="lh jf hi mn b fi mr ms l mt mu">npm install parse-server --save</span></pre><p id="914c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行此命令后，npm将在npm存储库中查找parse-server，并将它安装到您的项目中。<strong class="ih hj">标志(— save) </strong>告诉npm也创建一个依赖项，并将其添加到package.json文件中。您还会注意到，npm将安装parse-server所依赖的所有模块。</p><p id="599f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装完成后，去检查你的<strong class="ih hj"> package.json </strong>文件，你会看到一个新的<strong class="ih hj"> dependencies </strong>部分已经被添加。我们目前唯一的依赖是在解析服务器模块中。现在你可能会问自己，我需要的源代码在哪里？为了回答这个问题，你需要去你的<strong class="ih hj">应用</strong>文件夹，寻找<strong class="ih hj">节点模块</strong>库。</p><p id="9165" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请注意！node_modules包含解析服务器库以及所有的解析服务器依赖项，所以你会在它下面看到很多文件夹。请<strong class="ih hj">不要更改</strong>这些模块中的任何代码，因为下次运行npm install命令时，您的所有更改都将被<strong class="ih hj">覆盖。node_modules文件夹也必须被您的源代码控制忽略(如果您使用git，您需要将。gitignore文件)，因为它们必须在安装或部署时添加。</strong></strong></p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es mx"><img src="../Images/7504857743d3432b616b48288059c43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*qkCNfJ02XNEwZrPj2dU5BA.png"/></div></figure><p id="f19c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，创建一个npm启动脚本，它将允许我们只通过运行<strong class="ih hj"> npm start </strong>命令来运行解析服务器。要创建启动脚本，请添加以下内容:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="3383" class="lh jf hi mn b fi mr ms l mt mu">"start" : "node ./node_modules/.bin/parse-server"</span></pre><p id="871d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在package.json文件中的<strong class="ih hj">脚本</strong>下。添加启动脚本后，package.json应该如下所示:</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es my"><img src="../Images/1f7c97c80e9d32cb5787170ecab867fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*kgTXJW4PHD_DA3_L2veHnw.png"/></div></figure><p id="9c0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，通过在终端中执行以下命令，尝试在您的本地机器上运行parse-server(请确保您指向了<strong class="ih hj"> app </strong>文件夹):</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="0fa6" class="lh jf hi mn b fi mr ms l mt mu">npm start </span></pre><p id="f2e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会立即注意到你的应用程序无法运行，因为它缺少<strong class="ih hj"> appId </strong>和<strong class="ih hj">万能钥匙</strong>。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es mz"><img src="../Images/948024a22b83a71ae7345938bca03433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*WJWj7-_vKpRTGF60vn0pyQ.png"/></div></figure><p id="4158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">必须将<strong class="ih hj"> appId </strong>添加到发送到解析服务器的任何请求中。建议创建一些复杂base64字符串作为appId。主密钥<strong class="ih hj">也应该是base64字符串，使用主密钥解析服务器将允许你作为管理员<strong class="ih hj">运行任何api调用。主密钥必须只有您<strong class="ih hj">知道</strong>，appId必须只有您的应用程序知道。</strong></strong></p><p id="848d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您有两个选项可以将这两个变量传递给parse-server:</p><ol class=""><li id="a3fb" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">环境变量——node . js服务器可在运行时访问的变量，存储在<strong class="ih hj">process . ENV . { NAME _ OF _ THE _ ENV _ VARIABLE }</strong>对象下。</li><li id="c878" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">配置文件—将由解析服务器在运行时解析的JSON配置文件。</li></ol><p id="3540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我建议使用第二个选项(配置文件)。原因是，当您使用parse-server时，您会立即注意到，除了appId和masterKey之外，您还需要为您需要的不同功能添加越来越多的配置，使用第一个选项将很难理解哪些变量已设置，哪些变量未设置，实际上您只能在运行时理解它，而在第二个选项中，您可以在设计时(在运行parse-server之前)理解它，这非常重要。</p><p id="7e2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建parse-server config.json文件</strong></p><p id="488e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到你的<strong class="ih hj"> app </strong>文件夹，在它下面新建一个<strong class="ih hj"> config </strong>文件夹。在config文件夹下创建一个新的<strong class="ih hj"> config.json </strong>文件，该文件将包含运行解析服务器实例所需的所有配置。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es na"><img src="../Images/70fa5e9f34065d6da9ea15c395a2a168.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*5swF1NFkRZCRe7AaGoOCrQ.png"/></div></figure><p id="af31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开config.json文件，将以下内容粘贴到其中:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="e3de" class="lh jf hi mn b fi mr ms l mt mu">{<br/>"databaseURI": "mongodb://localhost:27017/my-db",<br/>"appId": "0742vWqaHDnW5VkvbTogyh2O9UbdXDlAe19XOPd2Tc",<br/>"masterKey": "La7U4b8Hxdsu2kwcV6ou08JWGlCdCETjkyR9H8DIXw",<br/>"serverURL": "http://localhost:1337/parse",<br/>"cloud": "./cloud/main.js",<br/>"mountPath": "/parse",<br/>"port": 1337<br/>}</span></pre><p id="4e11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> databaseURI — </strong>就像我上面提到的，parse-server使用mongoDB来持久化数据，所以databaseURI是MongoDB所在的连接字符串。因为目前我们在本地机器上运行它，所以我们指向本地主机和运行MongoDB的默认端口(27017)。</p><p id="74e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> appId </strong> —客户端在发送给解析服务器的任何请求中需要发送的应用程序密钥。<br/> <strong class="ih hj">万能钥匙</strong> —允许你以<strong class="ih hj">管理员</strong>身份运行api调用的钥匙，请只留给你自己。<br/> <strong class="ih hj"> serverURL </strong> —解析服务器api的端点。您将在这个端点前面运行您的api请求。<br/> <strong class="ih hj">云</strong> —就像我上面提到的，parse-server的功能之一是运行云代码函数和服务器端钩子的能力，所以这个参数将包含这些函数和钩子的源代码的路径。<br/> <strong class="ih hj">挂载路径</strong> —解析服务器的挂载路径。默认为/parse <br/> <strong class="ih hj">端口</strong>—parse-server运行的端口。默认值为1337</p><p id="ff66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，创建包含定制云代码函数和服务器端钩子的源代码的文件:</p><p id="39b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的应用文件夹下创建一个新文件夹，命名为<strong class="ih hj"> cloud </strong>。在云文件夹下新建一个文件，命名为<strong class="ih hj"> main.js </strong>。main.js文件现在可以是空的。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es nb"><img src="../Images/bddbf8ab90c354f1f7f45bba8c14b5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*76ZaF2iEa2abNMN_w1IZig.png"/></div></figure><h2 id="8ff3" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated"><strong class="ak">在本地运行解析服务器</strong></h2><p id="a7b0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在是时候再次运行我们的解析服务器实例了。转到终端，运行之前运行的命令，但这次发送config.json文件。</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="ee4d" class="lh jf hi mn b fi mr ms l mt mu">npm start -- config/config.json</span></pre><p id="34f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您会注意到，现在解析服务器正在运行并监听端口1337</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es nc"><img src="../Images/42379e328efb807afdd94a94337c64b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1ddDMU5FTX_kkFvt6lGmA.png"/></div></div></figure><p id="e7e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">故障排除</strong>:如果由于某种原因，您看到一些与mongoDB相关的错误，请确保安装了MongoDB，并行打开一个新的终端窗口，运行<strong class="ih hj"> mongod </strong>命令，然后再次运行您的解析服务器。</p><h2 id="e2f7" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">在本地测试解析服务器</h2><p id="7f89" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">测试解析服务器实例(从我的POV)的最佳方式是使用REST客户端工具。我个人用<a class="ae jd" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank">邮差</a>很直观。</p><p id="7ab1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您尝试对以下端点运行GET请求:<a class="ae jd" href="http://localhost:1337/parse/classes/user" rel="noopener ugc nofollow" target="_blank">http://localhost:1337/parse/classes/user</a>以获取解析服务器中的用户列表，您会立即注意到响应是</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="3717" class="lh jf hi mn b fi mr ms l mt mu">{"error":"unauthorized"}</span></pre><p id="7efc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原因是缺少一个api密钥。api键需要添加到<strong class="ih hj">请求头</strong>中，因此在发送请求之前，确保api键也添加到请求头中。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es nd"><img src="../Images/8359127b923e9d1f06b2430cb727ee87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4ZjIpa0cXX_Zj_pHDWbBw.png"/></div></div></figure><p id="b27c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次运行请求后，您应该会收到200响应和一个空的结果集</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="62d3" class="lh jf hi mn b fi mr ms l mt mu">{<br/>  "results": []<br/>}</span></pre><p id="2e8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您得到空结果的原因是因为数据库中没有用户。</p><p id="d98e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建一个新用户，我们需要对同一个URL运行POST请求，并在请求有效负载中传递必需的字段。必填字段有:<strong class="ih hj">用户名、密码、电子邮件。</strong></p><p id="bf3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了必填字段，我们还可以发送更多字段。这里的好处是您可以发送任意多的字段，因为MongoDB是无模式的，所以您不需要提前创建模式。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es ne"><img src="../Images/470c01daab0f13b6a93302528b961406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLUoieaX2LcUGBuwvLFfAw.png"/></div></div></figure><p id="d453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对此请求的响应将是:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="a343" class="lh jf hi mn b fi mr ms l mt mu">{<br/>  "objectId": "9XL661CuBK",<br/>  "createdAt": "2017-05-16T05:55:37.092Z"<br/>}</span></pre><p id="5eb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">parse-server将自动为您生成用户objectId以及该对象的创建日期。</p><p id="14b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们运行与获取数据库中的用户列表相同的GET请求。执行GET请求后，您应该得到以下响应:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="9138" class="lh jf hi mn b fi mr ms l mt mu">{<br/>  "results": [<br/>    {<br/>      "objectId": "9XL661CuBK",<br/>      "username": "ranhsd",<br/>      "password": "init1234",<br/>      "email": "<a class="ae jd" href="mailto:ran@example.com" rel="noopener ugc nofollow" target="_blank">ran@example.com</a>",<br/>      "firstName": "Ran",<br/>      "lastName": "Hassid",<br/>      "createdAt": "2017-05-16T05:55:37.092Z",<br/>      "updatedAt": "2017-05-16T05:55:37.092Z"<br/>    }<br/>  ]<br/>}</span></pre><p id="c991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请注意！</strong>我敢肯定，你可能会想，不先登录服务，怎么可能获得用户列表。原因是默认情况下，解析服务器只希望获得一个api键。api密匙问题在于它不够安全，因为任何知道如何嗅探网络请求的人都可以轻易地“窃取”您的api密匙。</p><p id="4db1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解析-服务器通过ACL和类级别的权限解决这个问题。我不会在本系列中讨论这个主题，但是ACL允许您定义哪些用户/角色可以创建/更新/删除/读取哪些对象。你可以在<a class="ae jd" href="http://docs.parseplatform.org/parse-server/guide/#class-level-permissions" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae jd" href="http://docs.parseplatform.org/rest/guide/#security" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多</p><h2 id="342c" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">带有docker的容器化解析服务器</h2><p id="ae9e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在本地机器上运行和测试parse-server之后，是时候以正确的方式运行它了。</p><p id="1329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> app </strong>文件夹下新建一个文件，命名为Dockerfile。该文件包含一些在构建/运行docker映像时将被执行命令。</p><p id="8ebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个文件的内容是:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="404c" class="lh jf hi mn b fi mr ms l mt mu">FROM node:boron<br/>RUN mkdir -p /parse-server<br/>WORKDIR /parse-server<br/>COPY . /parse-server<br/>RUN npm install<br/>EXPOSE 1337<br/>CMD ["npm","start"]</span></pre><p id="a24c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来解释一下:</p><p id="e464" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> FROM node:boron </strong> —这告诉docker我们正在运行Node.js应用程序，我们需要<a class="ae jd" href="https://hub.docker.com/_/node/" rel="noopener ugc nofollow" target="_blank">节点运行时</a>作为依赖项。因此，在为我们的应用程序创建映像之前，docker将检查节点映像是否可用，如果不可用，它将从dockerhub下载它，然后它将创建我们的映像。<br/> <strong class="ih hj">运行mkdir -p /parse-server </strong> —在docker镜像中创建parse-server目录<br/><strong class="ih hj">WORKDIR</strong><strong class="ih hj">/parse-server</strong>—设置我们刚刚创建的文件夹的工作目录<br/> <strong class="ih hj">副本。/parse-server </strong> —将应用程序中的所有文件复制到映像工作目录中<br/> <strong class="ih hj">运行npm安装</strong> —运行npm安装命令(在映像上)以安装所有依赖项<br/> <strong class="ih hj">暴露1337 </strong> —暴露1337端口，以便从外部访问它<br/> <strong class="ih hj"> CMD ["npm "，" start"] </strong> —运行npm start以启动解析服务器</p><p id="79ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建docker文件后，我们可以运行一个非常简单的命令，从我们的解析服务器应用程序构建docker图像。为了测试它，请打开终端，导航到应用程序文件夹并执行以下命令:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="42bf" class="lh jf hi mn b fi mr ms l mt mu">docker build -t my-parse-app .</span></pre><p id="243a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行该命令后，您会注意到docker cli将解析docker文件并逐行运行这些命令。最“繁重”的命令<strong class="ih hj"> npm install </strong>，该命令与我们之前在机器上运行的命令相同，但这次它在映像上运行。为了验证构建命令是否有效，请运行以下命令:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="bd01" class="lh jf hi mn b fi mr ms l mt mu">docker images</span></pre><p id="fa97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并检查两个图像(node和my-parse-app)是否都列在那里。</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es nf"><img src="../Images/d3ea5e3120616841be2322f7a04ba273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*QUTixF60MCngCe9_NiCcfw.png"/></div></figure><p id="b0a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们的解析服务器应用程序依赖于mongoDB，我们现在需要运行一个mongoDB容器，然后运行我们的解析服务器容器并将mongoDB链接到其中。我们可以这样做，首先构建一个mongoDB映像，通过docker run命令运行它，然后运行我们刚刚用link flag构建的解析服务器映像。听起来很复杂，对吧？这就是<strong class="ih hj"> docker-compose </strong>前来救援的地方。</p><h2 id="d923" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">设置docker-撰写</h2><p id="e393" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">docker-compose允许我们组合多个图像，一起构建和运行它们。我们唯一需要做的就是创建一个列出所有服务的文件。使用docker-compose，我们还可以:</p><ul class=""><li id="9786" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc ng kn ko kp bi translated">使用定制命令运行我们的图像(使用config.json运行parse-server需要这些命令)</li><li id="1e87" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc ng kn ko kp bi translated">挂载磁盘卷(例如，用于mongoDB文件、云代码文件等。)</li><li id="6603" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc ng kn ko kp bi translated">轻松地将多个容器链接在一起</li><li id="6c38" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc ng kn ko kp bi translated">设置环境变量</li><li id="0461" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc ng kn ko kp bi translated">还有更多…</li></ul><p id="21cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在项目的根文件夹下创建一个新文件，命名为:<strong class="ih hj"> docker-compose.yml </strong>。这个文件将列出我们希望用docker构建和运行的所有服务。</p><p id="8bd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于Medium <a class="ae jd" href="https://help.medium.com/hc/en-us/articles/226935407-How-can-I-indent-text-" rel="noopener">缺乏对文本缩进</a>的支持，并且yml文件需要缩进，请从<a class="ae jd" href="https://gist.github.com/ranhsd/76498d90bf5c8f2d30f742abcfd438d6" rel="noopener ugc nofollow" target="_blank">这里</a>下载或者自己输入(不推荐)</p><figure class="lw lx ly lz fd ma"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="f0ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">yml文件的一大优点是“对人友好”。您几乎可以立即从该文件中了解到，我们在其中列出了以下服务:</p><ol class=""><li id="9658" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">应用</strong> —与<strong class="ih hj"> mongo </strong>服务链接的解析服务器应用。请注意，运行容器的名称是:my-parse-app</li><li id="7cc1" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj"> mongo </strong> — MongoDB数据库使用dockerhub中的公共MongoDB映像</li><li id="4816" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj"> mongodata </strong> —由mongo服务挂载并创建磁盘卷，所有mongo数据将保存在该磁盘卷中。</li></ol><p id="7a89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建此文件后，您的项目结构应该如下所示:</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div class="er es nj"><img src="../Images/11bb8aefd6ec3ef64c3c301c89cea1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*gGwEPUozZTvNkMa1Ynqu6w.png"/></div></figure><p id="2e84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意<strong class="ih hj"> docker-compose.yml </strong>位于根文件夹(myFirstParseServerApp)下，而不是App文件夹下。</p><p id="3d26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要做的最后一件事是修改我们的<strong class="ih hj"> config.json </strong>文件，特别是<strong class="ih hj"> databaseURI </strong>的值。</p><p id="e4e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">替换:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="e8ed" class="lh jf hi mn b fi mr ms l mt mu">mongodb://localhost:27017/my-db</span></pre><p id="3cad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="aca0" class="lh jf hi mn b fi mr ms l mt mu">mongodb://mongo:27017/my-db</span></pre><p id="d280" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原因是，当我们用docker运行我们的应用程序时，mongoDB映像在另一个容器中运行，所以我们需要提供容器服务名称，而不是localhost，在我们的例子中，这个名称叫做<strong class="ih hj"> mongo </strong></p><p id="3f6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请注意！</strong>如果你想以两种方式运行你的应用程序(通过docker和本地),你可以简单地复制并粘贴你的config.json文件，更改它的名称(如config-local.json)并在本地运行时使用它。</p><h2 id="01bf" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">运行您的应用</h2><p id="b6d1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">剩下要做的最后一件事是运行和测试应用程序。这次我们将通过docker-compose运行该应用程序。为了使用docker-compose运行您的应用程序，请打开终端，导航到您的项目根库(myFirstParseServerApp)并执行以下命令:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="ec26" class="lh jf hi mn b fi mr ms l mt mu">docker-compose up</span></pre><p id="2406" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行此命令后，docker将:</p><ul class=""><li id="54b3" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc ng kn ko kp bi translated">下载/重复使用相关图像</li><li id="7d4b" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc ng kn ko kp bi translated">构建您的解析服务器节点。JS应用程序，方法是执行Dockerfile中的所有命令</li><li id="9b17" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc ng kn ko kp bi translated">创建node、my-parse-app和mongo映像并运行它们。</li></ul><p id="c141" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了知道哪些容器<strong class="ih hj">当前正在您的机器上运行</strong>,请执行以下命令:</p><pre class="lw lx ly lz fd mm mn mo mp aw mq bi"><span id="6f07" class="lh jf hi mn b fi mr ms l mt mu">docker ps</span></pre><p id="3fd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行此命令后，您应该会看到类似这样的内容:</p><figure class="lw lx ly lz fd ma er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es nk"><img src="../Images/40262c650c59466bdc743228cafd4aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7pK8ACAbnv66qoLG8Rp2Q.png"/></div></div></figure><p id="0216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是测试一切是否如预期那样工作的时候了。要测试它，请打开POSTMAN并运行与您之前运行的完全相同的请求，如果您得到相同的结果，这意味着一切正常。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="f946" class="je jf hi bd jg jh lc jj jk jl ld jn jo jp le jr js jt lf jv jw jx lg jz ka kb bi translated"><strong class="ak">第一部分概要</strong></h1><p id="171b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在，在容器中的本地机器上一切运行良好之后，你就可以开始本系列的第二部分了，在那里我将解释如何在google容器引擎上部署和运行相同的服务。</p></div></div>    
</body>
</html>