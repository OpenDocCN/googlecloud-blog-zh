<html>
<head>
<title>How to Restore Neo4j Backups on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes上恢复Neo4j备份</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-restore-neo4j-backups-on-kubernetes-and-gke-6841aa1e3961?source=collection_archive---------0-----------------------#2018-11-28">https://medium.com/google-cloud/how-to-restore-neo4j-backups-on-kubernetes-and-gke-6841aa1e3961?source=collection_archive---------0-----------------------#2018-11-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="92cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是它的姐妹，<a class="ae jd" rel="noopener" href="/neo4j/how-to-backup-neo4j-running-in-kubernetes-3697761f229a">如何备份运行在Kubernetes </a>的Neo4j。因此，如果您首先在寻找创建备份集的资源，那就从这里开始吧。</p><p id="77c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">维护一个在Kubernetes上运行的Neo4j集群通常意味着要有一个备份时间表，以防出现问题。所以那件事现在出了问题。你将如何恢复？这篇文章将带你一步一步地去做。</p><p id="8352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你之前没有尝试过Neo4j，你可以<a class="ae jd" href="https://github.com/neo4j-contrib/neo4j-helm" rel="noopener ugc nofollow" target="_blank">用Neo4j舵轮图</a>启动它。这应该适用于大多数Kubernetes发行版，但是我们将以GKE为例。</p><h1 id="a0f6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">方法</h1><p id="f7e7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了在Neo4j中恢复备份，我们使用标准的<a class="ae jd" href="https://neo4j.com/docs/operations-manual/current/backup/restore-backup/" rel="noopener ugc nofollow" target="_blank"> neo4j-admin restore </a>工具，只是在Kubernetes环境中，我们是在一个容器内完成的。通常，备份集存储为. tar.gz文件或原始目录。在进行备份时，neo4j-admin工具将其写入文件目录，但人们通常会压缩这些文件集并将其上传到云存储。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/670aab2e4ae5c6ed4380f84e2b180596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fr7TixdOAlwWqM-tPsjY-Q.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">使用initContainer将数据恢复到Neo4j</figcaption></figure><p id="e72a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用带有neo4j-admin工具的专用Docker容器作为kubernetes中的pods的initContainer。init容器的任务很简单:</p><ul class=""><li id="df8a" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">将数据驱动器安装到Neo4j希望找到其数据的位置(<code class="du lg lh li lj b">/data</code>)</li><li id="74da" class="kx ky hi ih b ii lk im ll iq lm iu ln iy lo jc lc ld le lf bi translated">从google云存储中下载备份集，如果需要的话，将其解压缩</li><li id="b75f" class="kx ky hi ih b ii lk im ll iq lm iu ln iy lo jc lc ld le lf bi translated">使用neo4j-admin将图形数据库恢复到<code class="du lg lh li lj b">/data</code></li></ul><p id="88fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这种方式，当Neo4j docker容器启动时，<a class="ae jd" href="https://neo4j.com/docs/operations-manual/current/installation/docker/" rel="noopener ugc nofollow" target="_blank">它会在预期的地方找到它的图形数据库</a>，并且Neo4j容器本身保持不变。</p><p id="e952" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我实现的方法假设备份集存储在Google Storage上，但是通过一些简单的修改，该脚本可以在任何云存储提供商上运行。</p><h1 id="e0bb" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">还原容器</h1><p id="c58d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">本节描述的代码和更多文档可以在Neo4j舵图的<a class="ae jd" href="https://github.com/neo4j-contrib/neo4j-helm/blob/master/tools/restore/README-RESTORE.md" rel="noopener ugc nofollow" target="_blank">工具/恢复目录中找到。</a></p><p id="0773" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它需要几个环境变量作为参数:</p><ul class=""><li id="f5eb" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated"><code class="du lg lh li lj b">GOOGLE_APPLICATION_CREDENTIALS</code> —可以找到JSON服务密钥的磁盘上文件的路径，允许访问备份集。</li><li id="4e74" class="kx ky hi ih b ii lk im ll iq lm iu ln iy lo jc lc ld le lf bi translated"><code class="du lg lh li lj b">BUCKET</code> —备份集的google存储桶位置，可以包含路径。例如，<code class="du lg lh li lj b">gs://my-bucket/graph-cluster/</code></li><li id="b484" class="kx ky hi ih b ii lk im ll iq lm iu ln iy lo jc lc ld le lf bi translated"><code class="du lg lh li lj b">DATABASE</code> —要恢复的数据库的逗号分隔列表，例如<code class="du lg lh li lj b">neo4j,system</code>。恢复容器将在存储桶中寻找带有日期戳的备份</li><li id="8d70" class="kx ky hi ih b ii lk im ll iq lm iu ln iy lo jc lc ld le lf bi translated"><code class="du lg lh li lj b">TIMESTAMP</code> —可选。如果您不提供这个，恢复容器将寻找最新的备份，它将被命名为<code class="du lg lh li lj b">gs://my-bucket/graph-cluster/DATABASENAME-latest.tar.gz</code> —这是备份文章中描述的备份容器创建的格式。</li></ul><p id="c4ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是全部要求。您可以在恢复容器的自述文件中了解一些可选参数。它们允许您控制一些行为，例如在压缩集中的何处找到备份，以及如果找到了，是否强制覆盖现有的数据库。</p><h1 id="3802" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">配置恢复容器</h1><p id="971e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了实现initContainer功能，我们需要两部分:initContainer规范本身和一个额外的共享卷。您可以在<a class="ae jd" href="https://github.com/neo4j-contrib/neo4j-helm/blob/master/deployment-scenarios/single-instance-restore.yaml" rel="noopener ugc nofollow" target="_blank">这个部署场景中看到一个完整的示例，它从备份</a>中恢复一个单实例Neo4j机器。通过将该部署场景作为一组参数传递给helm chart安装流程，它可以使用正确的bucket &amp;凭证工作。</p><p id="6251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">初始化容器</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lp"><img src="../Images/cb9791ca6feebcaad7d90811dec8f56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tlf_PyrcLDiyfPVt6Uuxw.png"/></div></div></figure><p id="6eeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您正在您的环境中运行，您将希望自己构建恢复容器，并将这里的<code class="du lg lh li lj b">image</code>引用更改为您选择的容器注册表。这样做的目的是创建恢复容器，将Neo4j容器的/数据装入其自身(这允许它操作Neo4j使用的持久卷)，然后指定一些环境变量来配置恢复过程。</p><p id="94cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">服务账户密钥</strong></p><p id="604c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里非常重要的一点是<code class="du lg lh li lj b">/auth</code>映射。这就是我们将google应用程序凭证放入恢复容器的方式。应用程序凭证本身是一个<a class="ae jd" href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys" rel="noopener ugc nofollow" target="_blank">生成的谷歌云服务密钥</a>，我们以JSON的形式下载了它。当然，在创建服务密钥时，我们必须授予它从存储备份集的存储桶中读取的权限。我们将创建一个包含auth密钥的kubernetes secret，如下所示:</p><pre class="ki kj kk kl fd lq lj lr ls aw lt bi"><span id="e8d6" class="lu jf hi lj b fi lv lw l lx ly">MY_SERVICE_ACCOUNT_KEY=$HOME/.google/my-service-key.json</span><span id="c598" class="lu jf hi lj b fi lz lw l lx ly">kubectl create secret generic restore-service-key \<br/>   --from-file=credentials.json=$MY_SERVICE_ACCOUNT_KEY</span></pre><p id="61ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这创建了一个名为“restore-service-key”的kubernetes秘密，您将看到它被安装到restore容器内的<code class="du lg lh li lj b">/auth</code>。当我们挂载它的时候，这个驱动看起来会有一个名为<code class="du lg lh li lj b">credentials.json</code>的文件，里面有我们本地密钥的内容。最后需要做的是将这个秘密作为一个卷添加到核心容器中，就像这样:</p><pre class="ki kj kk kl fd lq lj lr ls aw lt bi"><span id="f758" class="lu jf hi lj b fi lv lw l lx ly">volumes:<br/>  - name: "restore-service-key"<br/>    secret:<br/>      secretName: "restore-service-key"</span></pre><p id="3ad2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个卷，当initContainer将这个秘密挂载到/auth时，它就可以看到服务密钥的内容，从而保护对备份集的访问。</p><h1 id="5d08" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">运行还原容器</h1><p id="b620" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有了initContainer，您的Neo4j集群现在可以在多种意义上进行自我修复——如果一个pod崩溃或死亡，它当然会由Kubernetes重新启动，initContainer会将它恢复到您指定的最后一个备份。</p><p id="dde9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个好的维护程序的一部分，你可以在Google Storage上的一个已知位置有一个“最新的备份”，并且总是将initContainer指向那个最新的备份集。如果发生崩溃，节点将立即恢复运行，并提供您期望的数据。</p><p id="5b85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文中描述的备份容器已经提供了“最新备份”功能。每次你做备份的时候，它只是上传一个有时间戳的备份，和一个“最新”的指针。因此，对于还原容器要定位的最新备份集，总是有一个稳定的URL。</p><h1 id="b2ef" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">恢复注意事项</h1><p id="3f8a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj"> Neo4j因果集群</strong></p><p id="fcc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署Neo4j一种常见方式是在容器初始化时从上次备份中恢复。这对于集群来说是个好消息，因为它可以最大限度地减少节点启动时的追赶。最后一次备份和集群其余部分之间的任何差异都将通过补充来提供。</p><p id="4177" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Neo4j的单节点安装</strong></p><p id="57ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于单个节点，<strong class="ih hj"> <em class="ma">在这里照顾</em> </strong>。如果某个节点崩溃，而您自动从备份中恢复，并强制覆盖磁盘上以前的内容，您将丢失数据库在上次备份和崩溃发生之间捕获的所有数据。因此，对于Neo4j的单节点实例，您应该在需要时手动执行恢复，或者应该保持非常有规律的备份计划，以最大限度地减少这种数据丢失。如果数据丢失在任何情况下都是不可接受的，就不要对单节点部署进行自动恢复。</p><p id="19d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">授权文件</strong></p><p id="ea5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">从Neo4j 3.4和3.5系列</strong>开始，数据备份不包括集群的授权信息。也就是说，与图形关联的用户名/密码不包括在备份中，因此在您恢复时也不会恢复。这是需要注意的事情；当启动一个集群时，通常你需要提供启动认证信息和单独的配置。如果您创建了用户、组和角色，您可能希望单独获取auth文件的副本，以便在集群启动时可以恢复它们。</p><p id="af2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">从Neo4j 4.0开始</strong> —有一个包含相同信息的系统数据库。注意您正在备份的内容:如果您希望您的细粒度权限、用户和密码随身携带，您必须备份/恢复系统数据库。</p><p id="d2ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，用户可以<a class="ae jd" href="https://neo4j.com/docs/operations-manual/current/security/authentication-authorization/ldap-integration/" rel="noopener ugc nofollow" target="_blank">配置他们的系统使用LDAP提供者</a>，在这种情况下，不需要备份任何身份验证信息。</p></div></div>    
</body>
</html>