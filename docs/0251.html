<html>
<head>
<title>Running Workloads in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中运行工作负载</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/running-workloads-in-kubernetes-86194d133593?source=collection_archive---------0-----------------------#2017-04-08">https://medium.com/google-cloud/running-workloads-in-kubernetes-86194d133593?source=collection_archive---------0-----------------------#2017-04-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5c687a4e90a566ac1d56c8c0e84cc709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Pf1OiWyywWNKG_NMyt6ZA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">柏林KubeCon Europe 2017</figcaption></figure><p id="3e20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">本帖基于我在2017年</em> <a class="ae jt" href="http://events.linuxfoundation.org/events/cloudnativecon-and-kubecon-europe" rel="noopener ugc nofollow" target="_blank"> <em class="js"> KubeCon欧洲</em> </a> <em class="js">的演讲。本讲的</em> <a class="ae jt" href="https://www.youtube.com/watch?v=spHPCc82ACs&amp;list=PLj6h78yzYM2PAavlbv0iZkod4IVh_iGqV&amp;index=79" rel="noopener ugc nofollow" target="_blank"> <em class="js">录音</em></a><em class="js"/><a class="ae jt" href="https://speakerdeck.com/janetkuo/kubecon-europe-2017-running-workloads-in-kubernetes" rel="noopener ugc nofollow" target="_blank"><em class="js">幻灯片</em></a><em class="js"/><a class="ae jt" href="https://github.com/JanetKuo/k8s-demos" rel="noopener ugc nofollow" target="_blank"><em class="js">演示</em> </a> <em class="js">一应俱全。在这次演讲中，我概述了Kubernetes中的内置控制器。目标受众是Kubernetes初学者。</em></p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我的KubeCon演讲幻灯片:在Kubernetes中运行工作负载</figcaption></figure><p id="2930" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi ka translated">你可能还记得，上个月发生的AWS故障<a class="ae jt" href="https://techcrunch.com/2017/02/28/amazon-aws-s3-outage-is-breaking-things-for-a-lot-of-websites-and-apps/" rel="noopener ugc nofollow" target="_blank">导致许多流行网站和应用程序</a>瘫痪。事件发生后，<a class="ae jt" href="https://twitter.com/robertjscott" rel="noopener ugc nofollow" target="_blank">Spire软件架构副总裁Rob Scott </a>分享了Spire <a class="ae jt" rel="noopener" href="/spire-labs/mitigating-an-aws-instance-failure-with-the-magic-of-kubernetes-128a44d44c14">如何借助Kubernetes </a>的魔力缓解AWS宕机的故事。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kj jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">软件架构副总裁Rob Scott描述了Kubernetes如何从AWS故障中恢复</figcaption></figure><p id="e8bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kubernetes是一个容器化应用模式的平台。这些模式使得应用程序更容易部署、管理、扩展和从故障中恢复——这就是神奇之处。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="3347" class="kr ks hi bd kt ku kv kw kx ky kz la lb jf lc ld le jj lf lg lh jn li lj lk ll bi translated">Kubernetes集群中有什么？</h2><p id="ba4a" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">这是一个简化的Kubernetes集群:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/169030334428ac213535b8b6bcbceafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmwvGTEMIbf0q5OjRbTQpA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">简化的Kubernetes集群</figcaption></figure><p id="276d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个<a class="ae jt" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" rel="noopener ugc nofollow" target="_blank"> <em class="js"> pod </em> </a>是您在Kubernetes中创建或部署的最小和最简单的单元。一个单独的pod通常有一个，有时是几个紧密耦合的容器，以及它们共享的资源。一个pod代表Kubernetes中一个应用程序的单个实例。</p><p id="7f9d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">控制器</em>是Kubernetes中更高层次的抽象。每个控制器代表一个应用程序模式。控制器(上图中的红色方块)为特定的应用程序模式管理pod的副本。因此，您不需要直接创建pod。相反，您创建控制器来以模式运行应用程序。</p><p id="0c5d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个<a class="ae jt" href="https://kubernetes.io/docs/concepts/nodes/node/" rel="noopener ugc nofollow" target="_blank"> <em class="js">节点</em> </a>是一个物理机或者虚拟机。<em class="js">主节点</em>做出关于集群的全局决策，而<em class="js">工作节点</em>维护pod并为它们提供运行环境。控制器在主节点上运行，并管理在工作节点上运行的pod。</p><p id="5673" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我将讨论Kubernetes中的4种通用模式:无状态、有状态、守护进程和批处理。同样，每个模式由一个控制器表示。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="6991" class="kr ks hi bd kt ku kv kw kx ky kz la lb jf lc ld le jj lf lg lh jn li lj lk ll bi translated">无状态模式:部署</h2><p id="8988" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated"><em class="js">无状态</em>意味着您不需要在工作负载中保持状态(持久数据)。无状态模式的控制器称为<a class="ae jt" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> <em class="js">部署</em> </a>。如果您想要管理和扩展无状态工作负载，比如您的web应用程序、移动后端或API服务器，部署就是您的控制器。</p><p id="6808" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">部署倾向于可用性，而不是一致性。部署通过创建同一个pod的多个副本来提供可用性。这些豆荚是一次性的——如果它们变得不健康，部署只会产生新的替代品。此外，您可以以可控的速度更新部署，而不会出现服务中断。当像AWS中断这样的事件发生时，您的工作负载会自动恢复。</p><ul class=""><li id="8502" class="ls lt hi iw b ix iy jb jc jf lu jj lv jn lw jr lx ly lz ma bi translated">具体例子:<a class="ae jt" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> nginx </a>，<a class="ae jt" href="http://tomcat.apache.org/" rel="noopener ugc nofollow" target="_blank"> Tomcat </a></li></ul><p id="40e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面是部署和滚动更新无状态应用程序的演示。在这个演示中，我使用Kubernetes CLI工具<code class="du mb mc md me b">kubectl</code>与集群进行交互。<code class="du mb mc md me b">kubectl</code>向控制器发出异步请求，告诉控制器期望的状态是什么，控制器会让它这样做。我还在演示中创建了<a class="ae jt" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> <em class="js">服务</em> </a>。服务前端应用。你不直接和pod对话，而是和服务对话。服务对正常pod的流量进行负载平衡，以便当任何pod变得不正常或被终止时，您的服务仍然可用。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mf jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">部署和滚动更新无状态应用程序的演示</figcaption></figure><h2 id="eca7" class="kr ks hi bd kt ku kv kw kx ky kz la lb jf lc ld le jj lf lg lh jn li lj lk ll bi translated">状态模式:状态集</h2><p id="0745" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">对于无状态应用程序，扩展和恢复很容易。但是，有些应用程序需要存储数据，如数据库、缓存和消息队列。如果你正在运行分布式有状态工作负载，比如Zookeeper，你的每个有状态pod都需要一个更强的身份概念。</p><p id="0b8d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">部署创建的pod在被终止和重新创建后不会有相同的身份，它们也没有唯一的持久存储。因此，我们需要另一个用于有状态模式的控制器:<a class="ae jt" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"><em class="js"/></a>。与部署不同，StatefulSet选择<em class="js">一致性</em>而不是可用性。StatefulSet还管理多个pod，但与部署不同，StatefulSet的每个pod都有稳定、唯一且有粘性的身份和存储。也就是说，每个豆荚都是相似的，只是略有不同。使用StatefulSet，您可以按顺序部署、缩放和删除pod。这更安全，并且使您更容易对有状态应用程序进行推理。</p><ul class=""><li id="1244" class="ls lt hi iw b ix iy jb jc jf lu jj lv jn lw jr lx ly lz ma bi translated">具体例子:<a class="ae jt" href="https://zookeeper.apache.org/" rel="noopener ugc nofollow" target="_blank"> Zookeeper </a>，<a class="ae jt" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>，<a class="ae jt" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a></li></ul><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mf jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用StatefulSet运行Zookeeper集群的演示</figcaption></figure><h2 id="fcc2" class="kr ks hi bd kt ku kv kw kx ky kz la lb jf lc ld le jj lf lg lh jn li lj lk ll bi translated">守护模式:DaemonSet</h2><p id="54df" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">有时，您希望在节点上运行类似守护进程的工作负载，例如运行日志收集守护进程或节点监视守护进程。在这种情况下，您使用<a class="ae jt" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank"> <em class="js"> DaemonSet </em> </a>。</p><p id="036e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">DaemonSet确保每个节点运行一个pod的副本。如果您添加或删除节点，将自动在这些节点上创建或删除窗格。如果您只想在某些节点上运行守护程序，请使用节点标签来控制它—在节点上放置一些标签，并告诉DaemonSet“嘿，只在具有这些标签的节点上运行DaemonSet pods”</p><ul class=""><li id="dea2" class="ls lt hi iw b ix iy jb jc jf lu jj lv jn lw jr lx ly lz ma bi translated">具体例子:<a class="ae jt" href="http://www.fluentd.org/" rel="noopener ugc nofollow" target="_blank"> fluentd </a>，<a class="ae jt" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"> linkerd </a></li></ul><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mf jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用DaemonSet在每个节点上运行一个pod的演示</figcaption></figure><h2 id="c7ed" class="kr ks hi bd kt ku kv kw kx ky kz la lb jf lc ld le jj lf lg lh jn li lj lk ll bi translated">批处理模式:作业</h2><p id="324d" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">您可能还需要在集群中运行批处理工作负载。批量工作负载的控制器称为<a class="ae jt" href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/" rel="noopener ugc nofollow" target="_blank"> <em class="js">作业</em> </a>。</p><p id="312b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">作业创建多个并行运行的pod。您可以指定此作业中需要完成的pod数量。作业是为并行处理独立但相关的工作项目而设计的。这可以是要发送的电子邮件，也可以是要渲染的帧。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mf jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作业完成后并行运行pod的演示</figcaption></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="e33b" class="kr ks hi bd kt ku kv kw kx ky kz la lb jf lc ld le jj lf lg lh jn li lj lk ll bi translated">摘要</h2><p id="70af" class="pw-post-body-paragraph iu iv hi iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">所以这些是Kubernetes中唯一支持的模式，对吗？不要！它们只是Kubernetes支持的最常见、最通用的模式。总而言之:</p><ul class=""><li id="7c36" class="ls lt hi iw b ix iy jb jc jf lu jj lv jn lw jr lx ly lz ma bi translated">无状态模式:使用提供可用性的部署，以便轻松扩展和恢复</li><li id="4491" class="ls lt hi iw b ix mg jb mh jf mi jj mj jn mk jr lx ly lz ma bi translated">有状态模式:使用StatefulSet实现一致性，给每个pod一个惟一的、有粘性的身份和存储，并按顺序部署、伸缩和终止</li><li id="6f94" class="ls lt hi iw b ix mg jb mh jf mi jj mj jn mk jr lx ly lz ma bi translated">守护模式:使用DaemonSet，默认情况下，它在每个节点上运行一个pod，也可以使用节点标签进行定制</li><li id="4e49" class="ls lt hi iw b ix mg jb mh jf mi jj mj jn mk jr lx ly lz ma bi translated">批处理模式:使用作业并行运行多个pod，并运行它们直到完成</li></ul><p id="b82f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，你可能有一个问题是“这听起来很棒，但是我从哪里开始呢？有没有让我将工作负载转移到Kubernetes的例子或工具？”</p><p id="e9b0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是啊！有很多很棒的工具供你开始，其中之一就是<a class="ae jt" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>。Helm是Kubernetes包经理。有了Helm，你可以下载并安装<a class="ae jt" href="https://kubeapps.com/" rel="noopener ugc nofollow" target="_blank"> helm charts </a>，这是经过策划的Kubernetes-native应用程序，你可以从那里开始。</p><p id="fa20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可能会问的另一个问题是“如果我需要在Kubernetes中运行其他模式怎么办？我怎么定制？”</p><p id="d536" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kubernetes是可扩展的。它提供了所有基本的原语，所以你可以写你自己的控制器，或者使用别人写的控制器。比如<a class="ae jt" href="https://github.com/upmc-enterprises/elasticsearch-operator" rel="noopener ugc nofollow" target="_blank">弹性搜索算子</a>和<a class="ae jt" href="https://github.com/coreos/etcd-operator" rel="noopener ugc nofollow" target="_blank"> etcd算子</a>。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="441e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kubernetes是开放的。它对建议和反馈是开放的。您可以向<a class="ae jt" href="https://github.com/kubernetes/kubernetes/" rel="noopener ugc nofollow" target="_blank"> Kubernetes GitHub repo </a>发送补丁或提交错误报告，或者在<a class="ae jt" href="http://slack.k8s.io/" rel="noopener ugc nofollow" target="_blank"> Slack </a>上与我们聊天。也可以在Twitter <a class="ae jt" href="https://twitter.com/kubernetesio" rel="noopener ugc nofollow" target="_blank"> @kubernetesio </a>关注最新的Kubernetes新闻。如果你有问题或想跟进，也欢迎你在Twitter上找到<a class="ae jt" href="https://twitter.com/janet_kuo" rel="noopener ugc nofollow" target="_blank"> me </a>。</p><p id="3f3e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">希望你喜欢这个帖子！</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><blockquote class="ml mm mn"><p id="6ff9" class="iu iv js iw b ix iy iz ja jb jc jd je mo jg jh ji mp jk jl jm mq jo jp jq jr hb bi translated">1.<a class="ae jt" href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/CAP_theorem</a></p></blockquote></div></div>    
</body>
</html>