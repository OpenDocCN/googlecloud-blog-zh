<html>
<head>
<title>Hello World on GCP ML Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP ML引擎上的Hello World</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/hello-world-on-gcp-ml-engine-cc09f506361c?source=collection_archive---------0-----------------------#2018-06-16">https://medium.com/google-cloud/hello-world-on-gcp-ml-engine-cc09f506361c?source=collection_archive---------0-----------------------#2018-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0733" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从零到Web请求的编码</h2></div><p id="0eed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在做我的MushroomBot项目时，我发现没有太多关于如何使用谷歌云平台ML引擎的文档。我认为这是因为TensorFlow可以做很多事情，大多数例子都有大约500行长，非常具有T2风格。为了证明某事的价值，你通常从最简单可行的例子开始。在这篇文章中，我将尝试类似的策略来关注构建模块，而不是一个花哨的TensorFlow程序。</p><h2 id="b98c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">什么是ML引擎？</h2><p id="e4ce" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">从我的理解来说，ML Engine是一套帮助你在Google云平台上训练和部署机器学习模型的工具。如果平台像宣传的那样简单，我们应该最终验证下面的陈述。</p><blockquote class="kt ku kv"><p id="e525" class="ix iy kw iz b ja jb ij jc jd je im jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">关注模型，而不是运营</p></blockquote><p id="d7fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为最好的用例是<a class="ae la" href="https://cloud.google.com/ml-engine/docs/tensorflow/deploying-models" rel="noopener ugc nofollow" target="_blank">部署</a>一个机器学习模型的想法。这使得机器学习成为一个更有利于开发的过程，尤其是当模型不是有趣的部分时。我们算法的生命周期是我们将在本文中关注的。</p><h2 id="5360" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">你从哪里开始？</h2><p id="c96d" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">首先，我们需要找到一些好的文档。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lb"><img src="../Images/38e16e15469ef8a10efa0480806feafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4Mc_dyQBMp8NuGAL1lQag.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">“开发培训应用程序是一个复杂的过程，在很大程度上超出了本文档的范围”</figcaption></figure><p id="5965" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不认为开发培训应用程序超出了本文的范围。我认为开发一个<strong class="iz hj">高效的</strong>或<strong class="iz hj">有用的</strong>算法超出了本文的范围。我知道<em class="kw">真正的</em> TensorFlow应用程序需要对框架如何工作有深刻的理解，但至少给我们<em class="kw">一些东西</em>作为开始。与其抱怨，我们可以(讽刺地)按照这一页的其余部分来继续。</p><p id="a082" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从样本目录开始，我们可以看一看<a class="ae la" href="https://github.com/GoogleCloudPlatform/cloudml-samples/tree/master/census/tensorflowcore/trainer" rel="noopener ugc nofollow" target="_blank">普查示例</a>。在这里，我们看到总共800行代码和三个文件(blah)。首先要做的是尝试并理解这种模式。为什么有三个文件？每个文件的重要性是什么？</p><h2 id="0979" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">项目结构</h2><p id="fac1" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">文档中隐藏着一些关于<a class="ae la" href="https://cloud.google.com/ml-engine/docs/tensorflow/packaging-trainer#recommended_project_structure" rel="noopener ugc nofollow" target="_blank">项目结构</a>的段落。那一页上的图片非常有用，我们将从它开始。</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="7025" class="jt ju hi ls b fi lw lx l ly lz">$ tree .<br/>.<br/>├── setup.py<br/>└── trainer<br/>    ├── __init__.py<br/>    ├── model.py<br/>    ├── task.py<br/>    └── util.py</span></pre><p id="9f15" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我复制了他们的示例<code class="du ma mb mc ls b">setup.py</code>文件，并添加了一个Makefile来为所有有用的命令构建一个单一的事实来源。下面是这些文件的有用的片段。</p><blockquote class="kt ku kv"><p id="5fa0" class="ix iy kw iz b ja jb ij jc jd je im jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated"><code class="du ma mb mc ls b">task.py</code>包含管理工作的训练器逻辑。</p><p id="0234" class="ix iy kw iz b ja jb ij jc jd je im jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated"><code class="du ma mb mc ls b">model.py</code>包含TensorFlow图形代码——模型的逻辑。</p><p id="fa39" class="ix iy kw iz b ja jb ij jc jd je im jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated"><code class="du ma mb mc ls b">util.py</code>如果有的话，包含运行训练器的代码。</p></blockquote><p id="0915" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这些描述很有帮助，但我仍然不理解每个文件的输入和输出。这些需要命令行参数吗？它们是被直接调用还是被其他模块调用？</p><p id="0f25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这里找到一些关于如何在本地运行训练器的命令<a class="ae la" href="https://cloud.google.com/ml-engine/docs/tensorflow/getting-started-training-prediction#develop_and_validate_your_trainer_locally" rel="noopener ugc nofollow" target="_blank">。将这一行添加到我的Makefile中，我们有以下内容:</a></p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="67d5" class="jt ju hi ls b fi lw lx l ly lz">MODEL_DIR=./output<br/>TRAIN_DATA=./train<br/>EVAL_DATA=./eval</span><span id="a5d9" class="jt ju hi ls b fi md lx l ly lz">train_local:<br/> gcloud ml-engine local train \<br/>    --module-name trainer.task \<br/>    --package-path trainer/ \<br/>    --job-dir ${MODEL_DIR} \<br/>    -- \<br/>    --train-files ${TRAIN_DATA} \<br/>    --eval-files ${EVAL_DATA} \<br/>    --train-steps 1000 \<br/>    --eval-steps 100</span></pre><p id="695e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和以下目录结构:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="9f0b" class="jt ju hi ls b fi lw lx l ly lz">$ tree .<br/>.<br/>├── Makefile<br/>├── eval<br/>├── output<br/>├── setup.py<br/>├── train<br/>└── trainer<br/>    ├── __init__.py<br/>    ├── model.py<br/>    ├── task.py<br/>    └── util.py</span></pre><p id="0a75" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ma mb mc ls b">eval</code>和<code class="du ma mb mc ls b">train</code>中的文件格式很可能取决于我们的算法，所以我们很快就需要一个可用的例子。</p><p id="5ec8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行trian_local命令，我们得到以下结果:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="7864" class="jt ju hi ls b fi lw lx l ly lz">$ make train_local<br/>gcloud ml-engine local train \<br/>    --module-name trainer.task \<br/>    --package-path trainer/ \<br/>    --job-dir ./output \<br/>    -- \<br/>    --train-files ./train \<br/>    --eval-files ./eval \<br/>    --train-steps 1000 \<br/>    --eval-steps 100</span></pre><p id="b79a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，我们可以看到发生了一些事情，因为我们的一个文件已经被编译:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="759d" class="jt ju hi ls b fi lw lx l ly lz">$ find .<br/>.<br/>./eval<br/>./Makefile<br/>./output<br/>./setup.py<br/>./train<br/>./trainer<br/>./trainer/__init__.py<br/>./trainer/__init__.pyc &lt;----------------------<br/>./trainer/model.py<br/>./trainer/task.py<br/>./trainer/util.py</span></pre><p id="e524" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，很明显，我们可以在这个训练步骤中加入任何东西，而当地的教练似乎并不关心是否完成了任何事情。</p><h2 id="f079" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">(几乎)写一些代码</h2><p id="8c6a" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><a class="ae la" href="https://cloud.google.com/ml-engine/docs/tensorflow/getting-started-training-prediction#run_a_simple_tensorflow_python_program" rel="noopener ugc nofollow" target="_blank">同一本指南</a>确实展示了一个准系统TensorFlow程序。然而，指南并没有告诉我们在哪里写代码或者哪个文件应该做什么。指南的其余部分似乎在云中做了一堆很酷的东西，但我们这些普通人仍然停留在起点。</p><p id="c17d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们试图得到一个服务于web请求的模型时，也许我们可以从那里逆向工作。<a class="ae la" href="https://cloud.google.com/ml-engine/docs/tensorflow/deploying-models" rel="noopener ugc nofollow" target="_blank">部署模型文档</a>非常清楚地描述了它想要什么:<code class="du ma mb mc ls b">SavedModel</code>。太好了！假设WebRequest需要调用我们的TensorFlow程序，也许我们需要构造这些文件来获取一个非常具体的数据对象。</p><p id="83bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些文档中的大部分引用了“服务功能”,这与我们的直觉一致，但对合同没有帮助。根据本文档<a class="ae la" href="https://www.tensorflow.org/programmers_guide/saved_model#prepare_serving_inputs" rel="noopener ugc nofollow" target="_blank">和</a>，有关于函数命名的建议，但似乎没有什么是必需的。</p><p id="f2b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然没有在任何地方引用，但是在CloudML样本存储库中确实存在一个<code class="du ma mb mc ls b">cloudml-template</code>目录<a class="ae la" href="https://github.com/GoogleCloudPlatform/cloudml-samples/tree/master/cloudml-template" rel="noopener ugc nofollow" target="_blank">。我们将关注于<code class="du ma mb mc ls b">/template</code>目录，因为它包含Python包结构。我们正在用Makefile替换<code class="du ma mb mc ls b">/scripts</code>目录(并且可能从那里复制一些例子)。</a></p><p id="f2bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du ma mb mc ls b">task.py</code>中，我们终于可以看到一个Python程序的“开始”了。</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="a134" class="jt ju hi ls b fi lw lx l ly lz">if __name__ == '__main__':<br/>    main()</span></pre><p id="1f0d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过查看<code class="du ma mb mc ls b">main</code>函数，我们可以看到这个模块可以被多次调用。</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="282f" class="jt ju hi ls b fi lw lx l ly lz"># If job_dir_reuse is False then remove the job_dir if it exists<br/>print("Resume training:", HYPER_PARAMS.reuse_job_dir)</span></pre><p id="92bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进一步研究，我们可以发现一个<code class="du ma mb mc ls b">RunConfig</code>函数，它似乎</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="e011" class="jt ju hi ls b fi lw lx l ly lz">run_config = tf.estimator.RunConfig(<br/>  tf_random_seed=19830610,<br/>  log_step_count_steps=1000,<br/>  save_checkpoints_secs=120,<br/>  keep_checkpoint_max=3,<br/>  model_dir=model_dir )</span></pre><p id="8c27" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数取我们之前定义为<code class="du ma mb mc ls b">model_dir = HYPER_PARAMS.job_dir</code>的<code class="du ma mb mc ls b">model_dir</code>。令人困惑的是，我们已经将<code class="du ma mb mc ls b">job_dir</code>设置为等于<code class="du ma mb mc ls b">MODEL_DIR</code>。啊！</p><p id="89f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du ma mb mc ls b">run_config</code>被创建之后，它被传递给另一个函数来运行“实验”另一个函数<code class="du ma mb mc ls b">run_experiment</code>，是我们需要在我们的存储库中维护的另一个函数(尽管我假设所有ML引擎用户都遵循一个模式)。<code class="du ma mb mc ls b">run_experiment</code>函数将几个概念联系在一起。它从<a class="ae la" href="https://www.tensorflow.org/api_docs/python/tf/data" rel="noopener ugc nofollow" target="_blank">tensor flow数据/数据集包</a>开始，使用估算器包构建一些模型<a class="ae la" href="https://www.tensorflow.org/api_docs/python/tf/estimator" rel="noopener ugc nofollow" target="_blank">，并使用以下公式对变量求和:</a></p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="253f" class="jt ju hi ls b fi lw lx l ly lz"># train and evaluate<br/>tf.estimator.train_and_evaluate(<br/>  estimator,<br/>  train_spec,<br/>  eval_spec )</span></pre><p id="c798" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总结一下:</p><ul class=""><li id="4070" class="me mf hi iz b ja jb jd je jg mg jk mh jo mi js mj mk ml mm bi translated"><code class="du ma mb mc ls b">input.py</code>应该利用<code class="du ma mb mc ls b">tf.data</code>包将复杂的数据源转换成TensorFlow可以理解的东西</li><li id="5f81" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated"><code class="du ma mb mc ls b">task.py</code>应该使用<code class="du ma mb mc ls b">tf.estimator</code>包中的<strong class="iz hj">函数</strong>来运行你的模型。考虑与所用模型类型无关的函数。</li><li id="2356" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated"><code class="du ma mb mc ls b">model.py</code>应该从<code class="du ma mb mc ls b">tf.estimator</code>包中返回<strong class="iz hj">类</strong>。想起类似<code class="du ma mb mc ls b"><a class="ae la" href="https://www.tensorflow.org/api_docs/python/tf/estimator/LinearClassifier" rel="noopener ugc nofollow" target="_blank">LinearClassifier</a></code><a class="ae la" href="https://www.tensorflow.org/api_docs/python/tf/estimator/LinearClassifier" rel="noopener ugc nofollow" target="_blank">的东西。</a></li></ul><p id="5fea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，我们之前试图恢复的“服务功能”发生了什么变化呢？这是从哪里产生的？</p><p id="83ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为服务功能被视为输入类型，所以在<code class="du ma mb mc ls b">input.py</code>中定义了一个<code class="du ma mb mc ls b">json_serving_input_fn</code>。这个函数被传递给上面提到的<code class="du ma mb mc ls b">run_experiment</code>函数中的<code class="du ma mb mc ls b">FinalExporter</code>。</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="5863" class="jt ju hi ls b fi lw lx l ly lz">exporter = tf.estimator.FinalExporter(<br/>  'estimator',<br/>  input.SERVING_FUNCTIONS[HYPER_PARAMS.export_format],<br/>  as_text=False )</span></pre><p id="829e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该导出器被传递给一个<code class="du ma mb mc ls b">tf.estimator.EvalSpec</code>，该导出器随后被传递给<code class="du ma mb mc ls b">run_experiment</code>函数末尾的最后一个<code class="du ma mb mc ls b">train_and_evaluate</code>函数。</p><p id="ccfe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总而言之，如果您想了解如何构建TensorFlow包，我建议从<code class="du ma mb mc ls b">run_experiment</code>函数向后看，看看依赖关系的“树”是如何工作的。</p><h2 id="64db" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">向后工作</h2><p id="f101" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">尽管我们知道<code class="du ma mb mc ls b">input.py</code>实际上是我们数据的“起点”,但让我们把注意力集中在我们训练过程的主干上(即<code class="du ma mb mc ls b">main</code>和<code class="du ma mb mc ls b">train_experiment</code>功能)。</p><p id="f471" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然有点傻，但我打算从下面的<code class="du ma mb mc ls b">model.py</code>开始:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="1898" class="jt ju hi ls b fi lw lx l ly lz">import tensorflow as tf</span><span id="cdf2" class="jt ju hi ls b fi md lx l ly lz">def main():<br/>    tf.estimator.train_and_evaluate(<br/>        estimator,<br/>        train_spec,<br/>        eval_spec<br/>    )</span><span id="ed42" class="jt ju hi ls b fi md lx l ly lz">if __name__ == '__main__':<br/>    main()</span></pre><p id="9fba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行后，<code class="du ma mb mc ls b">make test_local</code>可以看到我们少了TensorFlow包。我已经更新了我的<code class="du ma mb mc ls b">setup.py</code>中的<code class="du ma mb mc ls b">REQUIRED_PACKAGES</code>，以反映在cloudml-samples存储库中定义的<a class="ae la" href="https://github.com/GoogleCloudPlatform/cloudml-samples/blob/master/cloudml-template/template/setup.py" rel="noopener ugc nofollow" target="_blank">。这并没有改变任何行为，因为<code class="du ma mb mc ls b">ml-engine local train</code>任务没有安装你的包。我真的不喜欢挖掘他们的源代码，但我会想象这个命令基本上只是以某种方式运行Python(暗示我们可能必须设置一个virtualenv或类似的)。</a></p><p id="fa7f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">经过一番摸索，我得出了以下修改后的Makefile:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="9ca3" class="jt ju hi ls b fi lw lx l ly lz">VIRTUALENV_DIR=./env<br/>PIP=${VIRTUALENV_DIR}/bin/pip<br/>ACTIVATE=source ${VIRTUALENV_DIR}/bin/activate</span><span id="f468" class="jt ju hi ls b fi md lx l ly lz"># Python + Environment</span><span id="cbb7" class="jt ju hi ls b fi md lx l ly lz">virtualenv:<br/>  virtualenv ${VIRTUALENV_DIR}</span><span id="ccc7" class="jt ju hi ls b fi md lx l ly lz">install: virtualenv<br/>  ${PIP} install --editable .</span><span id="c438" class="jt ju hi ls b fi md lx l ly lz"># TensorFlow</span><span id="f35d" class="jt ju hi ls b fi md lx l ly lz">MODEL_DIR=./output<br/>TRAIN_DATA=./train<br/>EVAL_DATA=./eval</span><span id="0166" class="jt ju hi ls b fi md lx l ly lz">TRAINER_PACKAGE=trainer<br/>TRAINER_MAIN=${TRAINER_PACKAGE}.task</span><span id="1df2" class="jt ju hi ls b fi md lx l ly lz">train_local:<br/>  bash -c '${ACTIVATE} &amp;&amp; gcloud ml-engine local train \<br/>    --module-name ${TRAINER_MAIN} \<br/>    --package-path ${TRAINER_PACKAGE} \<br/>    --job-dir ${MODEL_DIR} \<br/>    -- \<br/>    --train-files ${TRAIN_DATA} \<br/>    --eval-files ${EVAL_DATA} \<br/>    --train-steps 1000 \<br/>    --eval-steps 100'</span></pre><p id="6b44" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，没有使用virtualenv和Makefiles的好方法，所以我将<code class="du ma mb mc ls b">gcloud ml-engine</code>命令包装在<code class="du ma mb mc ls b">bash -c ''</code>中，这样我们就可以利用当前环境的Python环境，而不是依赖于用户的安装包。我想我们可以使用一些Docker hacks来获得一个跨所有开发机器的标准环境，这可能会将virtualenv/python的复杂性转移到跨主机操作系统的标准环境中。</p><p id="1685" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用<code class="du ma mb mc ls b">pip install --editable .</code>，我们可以在“编辑”模式下安装当前包，并将我们的依赖关系集中在<code class="du ma mb mc ls b">setup.py</code>文件中，而不是在<a class="ae la" href="https://cloud.google.com/ml-engine/docs/tensorflow/getting-started-training-prediction" rel="noopener ugc nofollow" target="_blank">入门指南</a>中偶尔提到的<code class="du ma mb mc ls b">requirements.txt</code>。我发现任何对<code class="du ma mb mc ls b">requirements.txt</code>的引用都令人困惑，因为推荐的包结构是使用<code class="du ma mb mc ls b">setup.py</code>,然而《入门指南》并没有提到将我们的包安装为可编辑的。</p><p id="a4e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更新Makefile后，<code class="du ma mb mc ls b">train_local</code>产生了我们所期望的<code class="du ma mb mc ls b">NameError: global name estimator is not defined</code>。</p><h2 id="6161" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">估计器、优化器、操作</h2><p id="1c1c" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">现在，您应该开始复制cloudml-sample程序的一部分了。在这一点上有相当多的代码，所以我将在后面用一个突出显示组件的图表来覆盖最终结果。</p><p id="04f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我尝试创建自己的估算器，发现了以下情况:</p><ul class=""><li id="f11f" class="me mf hi iz b ja jb jd je jg mg jk mh jo mi js mj mk ml mm bi translated">要创建一个<code class="du ma mb mc ls b">Estimator</code>，你需要和<code class="du ma mb mc ls b">EstimatorSpec</code>。这个<code class="du ma mb mc ls b">EstimatorSpec</code>需要一个<code class="du ma mb mc ls b">training_op</code>(想想TensorFlow会话图的一部分)。这个<code class="du ma mb mc ls b">training_op</code>将执行一些数学计算<em class="kw">并且</em>更新<code class="du ma mb mc ls b">global_step</code>变量(从<code class="du ma mb mc ls b">tf.train.get_global_step()</code>返回)。通常情况下，像<code class="du ma mb mc ls b">tf.train.GradientDescentOptimizer</code>一样，通过调用预先创建的<code class="du ma mb mc ls b">Optimizers</code>函数<code class="du ma mb mc ls b">minimize</code>来生成<code class="du ma mb mc ls b">training_op</code>。虽然创建一个新的<code class="du ma mb mc ls b">Optimizer</code>可能和创建一个子类一样简单，但是你仍然会遇到关于<code class="du ma mb mc ls b">Operations</code>的问题。</li><li id="860b" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated"><a class="ae la" href="https://www.tensorflow.org/extend/adding_an_op" rel="noopener ugc nofollow" target="_blank">在TensorFlow中创建新的</a> <code class="du ma mb mc ls b"><a class="ae la" href="https://www.tensorflow.org/extend/adding_an_op" rel="noopener ugc nofollow" target="_blank">Operation</a></code>需要编译C++代码，创建Python包装器。这意味着当我们试图创建一个不需要训练的“模型”时，我们不能轻易<strong class="iz hj">创造一些虚假的<code class="du ma mb mc ls b">training_op</code>。</strong></li><li id="537d" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated"><code class="du ma mb mc ls b">tf.estimator.TrainSpec</code>和<code class="du ma mb mc ls b">tf.estimator.EvalSpec</code>都需要它们各自的<code class="du ma mb mc ls b">step</code>参数大于零。</li></ul><p id="99af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想创建一个<code class="du ma mb mc ls b">Estimator</code>，你需要一个带渐变的图形。我不相信这意味着你需要一个带渐变的图来部署到ML引擎，但是你可能根本不能使用<code class="du ma mb mc ls b">gcloud ml-engine local train</code>命令。</p><h2 id="7de3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">构建最小图</h2><p id="5ddc" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">可以通过预先创建的优化器构建和使用的最简单的图形是什么？</p><p id="6036" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为MNIST的例子是一个好的开始。我们可以删除层和调整数字，直到我们最终得到更小的东西。</p><p id="d8d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">经过长时间的调查，我得出了下面的图表:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="9b1b" class="jt ju hi ls b fi lw lx l ly lz">input_layer = tf.constant([[1.0]])<br/>dense = tf.layers.dense(inputs=input_layer, units=1,<br/>  activation=tf.nn.relu)<br/>dropout = tf.layers.dropout(inputs=dense, rate=0.4,<br/>  training=mode == tf.estimator.ModeKeys.TRAIN)<br/>logits = tf.layers.dense(inputs=dropout, units=2)</span></pre><p id="ba05" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不知道这个图是做什么的，但它似乎足以编译没有梯度警告。</p><h2 id="3e34" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">导出图表</h2><p id="1fbf" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">一旦您摆脱了梯度警告，您可能会发现自己处于导出图表的位置。导出图表需要两件东西:<code class="du ma mb mc ls b">config</code>和<code class="du ma mb mc ls b">export_outputs</code>。</p><p id="3ad0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您最终向您的<code class="du ma mb mc ls b">EvalSpec</code>传递了一个<code class="du ma mb mc ls b">FinalExporter</code>，那么当您的模型以Eval模式运行时，您将能够导出您的函数。<code class="du ma mb mc ls b">FinalExporter</code>依赖于必须返回一个<code class="du ma mb mc ls b">ServingInputReceiver</code>的函数。虽然缺乏确凿的例子，但在文档中<a class="ae la" href="https://www.tensorflow.org/api_docs/python/tf/estimator/export/ServingInputReceiver" rel="noopener ugc nofollow" target="_blank">有<em class="kw">的一些</em>信息。</a></p><p id="7252" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使是导出器，如果你不把包含一个<code class="du ma mb mc ls b">model_dir</code>的<a class="ae la" href="https://www.tensorflow.org/api_docs/python/tf/estimator/RunConfig" rel="noopener ugc nofollow" target="_blank">配置</a>传递给你的<code class="du ma mb mc ls b">Estimator</code>，你实际上也不会保存一个图。</p><h2 id="3db2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">为导出的图形提供服务</h2><p id="95d4" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">首先，你需要一个桶来放你的训练和评估数据。我们的数据是随机生成的，所以我们不需要担心这一步。但是，您需要一个铲斗来完成以下工作:</p><ul class=""><li id="955c" class="me mf hi iz b ja jb jd je jg mg jk mh jo mi js mj mk ml mm bi translated">CLI上传您的软件包</li><li id="ed36" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated">ML引擎输出完成的模型</li></ul><p id="8067" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要提交我们的作业，我们需要将以下内容添加到Makefile中。</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="1c89" class="jt ju hi ls b fi lw lx l ly lz">JOB_NAME=${BUCKET_NAME}_2<br/>BUCKET_JOB_DIR=gs://${BUCKET_NAME}/${JOB_NAME}<br/>REGION=us-central1<br/>RUNTIME_VERSION=1.5</span><span id="15b4" class="jt ju hi ls b fi md lx l ly lz">train_job:<br/> gcloud ml-engine jobs submit training ${JOB_NAME} \<br/>    --job-dir ${BUCKET_JOB_DIR} \<br/>    --runtime-version ${RUNTIME_VERSION} \<br/>    --module-name ${TRAINER_MAIN} \<br/>    --package-path ${TRAINER_PACKAGE} \<br/>    --region ${REGION} \<br/>    -- \<br/>    --train-files ${TRAIN_DATA} \<br/>    --eval-files ${EVAL_DATA}</span></pre><p id="a0e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将作业提交给ML引擎后，您应该会看到作业在大约5分钟内完成。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ms"><img src="../Images/f23a8266c6e014730cf69ba4d4729f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKxkYhD2SJ0k_aLg19Jk0w.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">5分31秒~ 2分钱</figcaption></figure><p id="ad52" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我对一份培训工作的成本做了一个快速分析，我认为每份工作的最低成本接近2美分。您可以通读<a class="ae la" href="https://cloud.google.com/ml-engine/docs/pricing" rel="noopener ugc nofollow" target="_blank">定价页面</a>了解更多信息。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es mt"><img src="../Images/79eb9fbf64c3c0cd33b806b88712523b.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*cV0C9tA_Zyte_UUKnP79ww.png"/></div></figure><p id="55fb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行作业后，您可以在一个有趣的路径下找到上传到bucket中的模块:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="cb77" class="jt ju hi ls b fi lw lx l ly lz">gs://${BUCKET}/${JOB_NAME}/packages/3c8688e2846d9cda3337beb86f8cb0926fc7ecd136180758f70ea06fe25898b8</span></pre><p id="8679" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个目录中，您将找到您的Python模块。下载该模块时，我们可以看到以下内容:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="88fb" class="jt ju hi ls b fi lw lx l ly lz">$ tree hello-world-0.1<br/>hello-world-0.1<br/>├── PKG-INFO<br/>├── setup.cfg<br/>├── setup.py<br/>└── trainer<br/>    ├── __init__.py<br/>    ├── input.py<br/>    ├── model.py<br/>    ├── task.py<br/>    └── util.py</span><span id="2b12" class="jt ju hi ls b fi md lx l ly lz">1 directory, 8 files</span></pre><p id="95e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么导出的模型在哪里？无处可寻…</p><p id="9bfd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，我决定向前看，看看事情会变得多糟糕。首先，我尝试从这个目录创建一个模型(<code class="du ma mb mc ls b">gcloud ml-engine models create</code>和<code class="du ma mb mc ls b">gcloud ml-engine versions create</code>)。如果您尝试提交包含python文件的bucket，您将得到以下内容:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="489d" class="jt ju hi ls b fi lw lx l ly lz">ERROR: (gcloud.ml-engine.versions.create)<br/>FAILED_PRECONDITION:<br/>Field: version.deployment_uri<br/>Error: Deployment directory gs://XYZ/ is expected to contain exactly one of:<br/>  [saved_model.pb, saved_model.pbtxt].</span></pre><p id="4d02" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本地运行ML Engine trainer之后，我确认我正在导出<code class="du ma mb mc ls b">output</code>目录中的所有内容，并且实际上正在创建一个<code class="du ma mb mc ls b">saved_model.pb</code>文件(<code class="du ma mb mc ls b">export/${FINAL_EXPORTER_NAME}/${TIMESTAMP}/saved_model.pb</code>)。</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="9079" class="jt ju hi ls b fi lw lx l ly lz">output<br/>├── checkpoint<br/>├── eval_estimator-eval<br/>│   └── events.out.tfevents.1528682282.genslerj.machine<br/>├── events.out.tfevents.1528682281.genslerj.machine<br/>├── export<br/>│   └── estimator<br/>│       └── 1528682283<br/>│           ├── saved_model.pb<br/>│           └── variables<br/>│               ├── variables.data-00000-of-00001<br/>│               └── variables.index<br/>├── graph.pbtxt<br/>├── model.ckpt-1.data-00000-of-00001<br/>├── model.ckpt-1.index<br/>├── model.ckpt-1.meta<br/>├── model.ckpt-100.data-00000-of-00001<br/>├── model.ckpt-100.index<br/>└── model.ckpt-100.meta</span><span id="1654" class="jt ju hi ls b fi md lx l ly lz">5 directories, 13 files</span></pre><p id="cfa0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这些知识，我回去检查了cloudml-sample代码库和<code class="du ma mb mc ls b">gcloud</code> CLI工具。现在，我们已经忽略命令行参数很长时间了。最后，我们来到<a class="ae la" href="https://github.com/GoogleCloudPlatform/cloudml-samples/blob/4686bb124f8fa55d9f2dd7a37a2bd8f990ae87b9/cloudml-template/template/trainer/task.py#L209-L213" rel="noopener ugc nofollow" target="_blank">我们的模型需要的一个参数</a>，即<code class="du ma mb mc ls b">--job-dir</code>参数。</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="dff0" class="jt ju hi ls b fi lw lx l ly lz">--job-dir=JOB_DIR<br/>  A Google Cloud Storage path in which to store training outputs and other data needed for training.</span><span id="f074" class="jt ju hi ls b fi md lx l ly lz">  This path will be passed to your TensorFlow program as --job_dir command-line arg. The benefit of specifying this field is that Cloud ML Engine will validate the path for use in training.</span><span id="7cca" class="jt ju hi ls b fi md lx l ly lz">  If packages must be uploaded and --staging-bucket is not provided, this path will be used instead.</span></pre><p id="ae8f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这样！</p><figure class="lc ld le lf fd lg er es paragraph-image"><div class="er es mu"><img src="../Images/3de64cce3ad6ab7a6bac3fb6e60f16ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*wJqCQfxGYSAS8f7h3WuRRw.png"/></div></figure><p id="1cb6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建托管模型版本后，我们可以调用<code class="du ma mb mc ls b">ml-engine predict</code>调出API。JSON输入将对应于您的JSON服务函数。这是我的服务功能:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="6fe4" class="jt ju hi ls b fi lw lx l ly lz">def json_serving_function():<br/>    inputs = {<br/>        'one': tf.constant([1]),<br/>        'zero': tf.constant([0])<br/>    }</span><span id="5845" class="jt ju hi ls b fi md lx l ly lz">return tf.estimator.export.ServingInputReceiver(<br/>        features={<br/>            'one': tf.constant([1]),<br/>            'zero': tf.constant([0])<br/>        },<br/>        receiver_tensors=inputs,<br/>        # receiver_tensors_alternatives=inputs<br/>    )</span></pre><p id="d208" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其对应于以下输入示例:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="9a21" class="jt ju hi ls b fi lw lx l ly lz">{"one": 42, "zero": 100}<br/>{"one": 0, "zero": 100}<br/>{"one": 100, "zero": 0}</span></pre><p id="b73d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试API，我们得到以下结果:</p><pre class="lc ld le lf fd lr ls lt lu aw lv bi"><span id="f05f" class="jt ju hi ls b fi lw lx l ly lz">$ make test_model_version<br/>gcloud ml-engine predict \<br/>   --model helloworld_model \<br/>   --version v1 \<br/>   --json-instances ./json_instances.jsonl<br/>OUTPUT<br/>1.0</span></pre><p id="4033" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我不确定是否发生了什么，但我认为我已经足够详细地帮助开始实验了(比如将<code class="du ma mb mc ls b">receiver_tensors</code>匹配到你的模型的输入)。</p><h2 id="35cd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">张量流“知识”依赖图</h2><p id="94dc" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">最后，我们可以把所有的概念拼凑成一个可管理的图表。我认为这将是从头到尾描述如何使用ML Engine的一个好方法(比本文少一些技巧)。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mv"><img src="../Images/cc40c16d7362d41fff6bae61ba31d453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2nE606LnABkWfZ3K8PY0Q.jpeg"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">颜色代表分组信息</figcaption></figure><p id="bf93" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我遗漏了<code class="du ma mb mc ls b">train</code>和<code class="du ma mb mc ls b">eval</code>目录。我认为这些可能是可选的，因为对<code class="du ma mb mc ls b">tf.data.Dataset</code>的任何依赖都可能在运行时提取数据(不确定这是否是一个好主意，但理论上是可能的)。</p><p id="1163" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我必须推荐一条使用ML引擎的途径，它可能是如下:</p><ol class=""><li id="41a2" class="me mf hi iz b ja jb jd je jg mg jk mh jo mi js mw mk ml mm bi translated">从<code class="du ma mb mc ls b">model.py</code>开始。这些概念中的大部分是其余包装代码的核心。因为您将需要一个梯度操作，您将希望为您的用例开发直觉。</li><li id="b8d6" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi translated">继续前往<code class="du ma mb mc ls b">input.py</code>。从<code class="du ma mb mc ls b">Dataset</code>包开始，在那里进行筛选。您可以构建大量的代码来读取数据，所以请认真对待这一部分。您还将看到如何托管您的API(服务功能)。这可能会指出您希望如何将数据组织到您的网络中，并且您可能会在<code class="du ma mb mc ls b">model.py</code>中修改代码。尽管你还不能将这项工作与第一部分联系起来，但你可能最终会发现一些“整合”的问题。</li><li id="96dc" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi translated">最后可以用<code class="du ma mb mc ls b">task.py</code>把这些都拼凑起来。虽然不是必需的，但我认为您最终会摆弄<code class="du ma mb mc ls b">train</code>和<code class="du ma mb mc ls b">eval</code>步骤参数。</li><li id="d799" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi translated">用<a class="ae la" href="https://cloud.google.com/ml-engine/docs/tensorflow/hyperparameter-tuning-overview" rel="noopener ugc nofollow" target="_blank">超参数调谐</a>和<a class="ae la" href="https://www.tensorflow.org/deploy/distributed" rel="noopener ugc nofollow" target="_blank">分布式训练</a>全力以赴。</li><li id="68f9" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi">…</li><li id="1818" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi translated">利润！</li></ol><h2 id="3c34" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">包扎</h2><p id="341b" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">总的来说，这整个经历有点令人沮丧，但我对模式的出现感到非常兴奋。我认为GCP ML引擎令人惊讶地容易使用和灵活，因为我能够解决这个问题，而且我不是数据科学家或研究生/博士生。请继续关注我的具体用例以及它们最终如何工作的更多信息。干杯，感谢您的阅读！</p><div class="mx my ez fb mz na"><a href="https://github.com/jgensler8/gcp-minimal-ml-engine-project" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">jgensler 8/GCP-minimal-ml-engine-project</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">在GitHub上创建一个帐户，为gcp-minimal-ml-engine项目的开发做出贡献。</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ll na"/></div></div></a></div></div></div>    
</body>
</html>