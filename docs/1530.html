<html>
<head>
<title>Spanner’s SQL Story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扳手的SQL故事</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/spanners-sql-story-79bda8bb632d?source=collection_archive---------0-----------------------#2020-07-22">https://medium.com/google-cloud/spanners-sql-story-79bda8bb632d?source=collection_archive---------0-----------------------#2020-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9e40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spanner是Google不久前启动的一个分布式数据库，用于为自己的工作负载构建一个高度可用和高度一致的数据库。Spanner最初是作为一个键/值而构建的，它的形状与今天完全不同，它有不同的目标。从一开始，它就具有事务处理能力、外部一致性，并且能够透明地进行故障转移。随着时间的推移，Spanner采用了强类型模式和其他一些关系数据库特性。在过去的几年里，它增加了SQL支持*。今天，我们正在同时改进SQL方言和关系数据库特性。有时会混淆Spanner是否支持SQL。简单的回答是肯定的。长的回答就是这篇文章。</p><h2 id="1861" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">早年</h2><p id="c72e" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Spanner最初是为内部工作负载而构建的，没有人能够看到Google将启动云业务并将Spanner外部化。如果你不太了解谷歌，我们的内部堆栈经常被认为是一个不同的宇宙。在谷歌，包括存储和数据库服务在内的所有系统都提供自己专有的API和客户端。当你加入Google的时候，你打算使用你最喜欢的ORM库吗？不幸的是，这是不可能的。我们的基础设施服务提供了自己的Stubby/gRPC API和客户端库。如果您关心API熟悉度，这是一个小缺点，但它是一个强大的优势，因为我们可以提供更具表达力的API来表示我们基础架构的差异化功能。</p><p id="a0a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同的特性在通用API中通常表现不佳。一种尺寸不适合所有人。通用API只能针对通用特性。分布式数据库已经与传统的关系数据库有了很大的不同。我将在本文中给出两个例子来说明显式API是如何发挥作用的。</p><p id="06a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分布式系统失败的方式不同，也更频繁。为了处理这个问题，分布式系统实现了重试机制。当我们无法提交事务时，扳手客户端透明地重试事务。这使得我们不必向用户暴露每个临时故障。我们透明地用正确的退避策略重试。</p><p id="4c7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的代码片段中，您会看到一些Go代码开始一个新的读写事务。它提供了一个可以查询和操作数据的函数。当出现中止或冲突时，它会自动重试该功能。<a class="ae kd" href="https://godoc.org/cloud.google.com/go/spanner#Client.ReadWriteTransaction" rel="noopener ugc nofollow" target="_blank"> ReadWriteTransaction </a>记录了这种行为，并记录了该函数重试应该是安全的(例如，告诉开发人员不要持有应用程序状态)。这允许我们向用户传达分布式数据库的独特现实。我们还可以提供像自动重试这样的功能，这在传统ORM中很难实现。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="7d0f" class="jd je hi kj b fi kn ko l kp kq">import "cloud.google.com/go/spanner"</span><span id="4ba7" class="jd je hi kj b fi kr ko l kp kq">_, err := client.ReadWriteTransaction(ctx, func(ctx context.Context, txn *spanner.ReadWriteTransaction) error {<br/>    // User code here.<br/>})</span></pre><p id="c6cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个例子是隔离级别。Spanner实现的隔离级别优于SQL标准中描述的最严格的隔离级别(serializable)。Spanner不允许您为读/写事务选择任何不太严格的东西。但是对于多区域设置和只读事务，提供最强的隔离并不总是可行的。光速考验着我们的极限。对于不介意稍微陈旧的数据的用户，Spanner能够提供陈旧的读取。陈旧读取允许用户读取区域副本中可用的版本。他们可以设定自己能容忍的陈旧程度。例如，下面的事务最多可以容忍10秒。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="d134" class="jd je hi kj b fi kn ko l kp kq">import "cloud.google.com/go/spanner"</span><span id="c000" class="jd je hi kj b fi kr ko l kp kq">client.ReadOnlyTransaction().<br/>    WithTimestampBound(spanner.MaxStaleness(10*time.Second)).<br/>    Query(ctx, query)</span></pre><p id="88c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">陈旧API允许我们明确表达快照隔离如何工作，以及如果副本非常过时，Spanner如何获取最新数据。它还使我们能够强调多区域复制是一个多么困难的问题，即使有Spanner这样的数据库，您也可以考虑在多区域设置中为了更好的延迟特性而牺牲一致性。</p><h2 id="e95e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">子一代</h2><p id="9141" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><a class="ae kd" href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41344.pdf" rel="noopener ugc nofollow" target="_blank"> F1 </a>是在Spanner中实现SQL支持的第一步的原始实验。F1是Google的一个分布式数据库，建立在Spanner之上。与扳手不同，它支持:</p><ul class=""><li id="15f7" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">分布式SQL查询</li><li id="0f25" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">事务一致的辅助索引</li><li id="256d" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">改变历史和潮流</li></ul><p id="4ca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它在Spanner之上的一个协调层中实现了这些特性，并将所有其他功能交给了Spanner。</p><p id="c297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">F1的建立是为了支持我们的广告产品。鉴于广告业务的性质和我们广告产品的复杂性，能够编写和运行复杂的查询是至关重要的。F1使Spanner更容易被业务逻辑繁重的系统使用。</p><h2 id="6b04" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">云扳手</h2><p id="4812" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">很快，谷歌云为我们的外部客户推出了Spanner。当它第一次发布时，它只支持SQL查询数据。它缺少INSERT、UPDATE和DELETE语句。</p><p id="2589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">鉴于当时它还没有一个完整的SQL数据库，它也缺乏对<a class="ae kd" href="https://cloud.google.com/spanner/docs/jdbc-drivers" rel="noopener ugc nofollow" target="_blank">【JDBC】</a>、<a class="ae kd" href="https://github.com/rakyll/go-sql-driver-spanner" rel="noopener ugc nofollow" target="_blank">数据库/sql </a>和类似的驱动支持。当Cloud Spanner <a class="ae kd" href="https://cloud.google.com/spanner/docs/release-notes#October_10_2018" rel="noopener ugc nofollow" target="_blank">实现了</a>一种支持插入、更新和删除的数据操作语言(DML)时，驱动程序支持成为可能。</p><p id="ecf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，Cloud Spanner同时支持DDLs(针对模式)和DMLs(针对数据)。Cloud Spanner使用了Google使用的一种SQL方言。这种方言的原生解析器和分析器ZetaSQL 不久前已经开源了。到今天为止，Cloud Spanner还提供了一个查询分析工具。</p><figure class="ke kf kg kh fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lg"><img src="../Images/e86ed50e578186677ac47958d76f444b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ysDhwpJtBopIRRF9m4xfw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">来自Spanner的查询分析器的查询分析示例。</figcaption></figure><h2 id="0f6a" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">下一个？</h2><p id="11dd" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">当前的挑战源于我们的SQL方言中存在的差异。这是我们正在积极努力改进的一个领域。不仅仅是我们不希望我们的用户处理一种新的SQL风格，目前的情况也减缓了我们在ORM集成方面的工作。一些ORM框架在生成查询时硬编码SQL，并且给驱动程序很少的灵活性来覆盖行为。为了避免任何不一致，我们正在努力消除与流行方言的差异。</p><p id="9f55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方言差异并不是影响我们SQL支持的唯一问题。另一个明显的差距是缺少一些常见的传统数据库特性。Spanner从不支持像默认值或自动生成的id这样的特性。当我们在改善方言差异时，同时解决这些显著的差距总是在我们的考虑范围之内。</p><p id="5ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">—</p><p id="a501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(*)关于Spanner的查询工作的初始工作发表为<a class="ae kd" href="https://research.google/pubs/pub46103/" rel="noopener ugc nofollow" target="_blank"> Spanner:成为SQL系统</a>。</p></div></div>    
</body>
</html>