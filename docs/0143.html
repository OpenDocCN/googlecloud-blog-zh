<html>
<head>
<title>CI with Wercker, Google Container Registry and Kubernetes: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Wercker、Google Container Registry和Kubernetes进行CI:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/ci-with-wercker-google-container-registry-and-kubernetes-part-2-26155551227c?source=collection_archive---------0-----------------------#2016-09-02">https://medium.com/google-cloud/ci-with-wercker-google-container-registry-and-kubernetes-part-2-26155551227c?source=collection_archive---------0-----------------------#2016-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d599" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推到集装箱登记处</h1></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="c882" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Google容器注册表是docker图片的私有注册表。我们希望在wercker中构建完图像后将它们推送到那里，这样当我们想要使用它们时(例如，当我们在Kubernetes中运行它们时)就可以轻松地提取它们。</p><p id="7f76" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我们使用wercker的内部步骤之一<em class="kj"> internal/docker-push创建一个推送管道。</em></p><p id="c6ce" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">注意:您需要在您的google cloud项目上创建一个服务帐户，以便wercker可以使用它将您的图像上传到注册表。下载创建服务帐户后得到的密钥，<em class="kj">删除所有换行符</em>(如果密钥中有换行符，docker推送步骤将失败，并出现一个奇怪的错误)，然后将其放入一个环境变量中(本例中为GCR_JSON_KEY_FILE)</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="acc5" class="kt ig hi kp b fi ku kv l kw kx">push:<br/>  steps:<br/>    - internal/docker-push:<br/>      registry: <a class="ae ki" href="https://gcr.io" rel="noopener ugc nofollow" target="_blank">https://gcr.io</a><br/>      username: _json_key<br/>      password: $GCR_JSON_KEY_FILE<br/>      repository: gcr.io/$GCR_PROJECT_NAME/$WERCKER_GIT_REPOSITORY</span></pre><p id="d2ff" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">然而，这本身对我们的目的不起作用，原因如下:</p><ul class=""><li id="d93e" class="ky kz hi jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">正在推送的图像没有标记，每次推送时都会自动标记为“最新”,因此获取特定版本将会很困难。您可以使用提交散列从<a class="ae ki" href="http://gcr.io" rel="noopener ugc nofollow" target="_blank"> gcr </a>中提取图像，但是我更喜欢用我的package.json的版本号来标记主构建</li><li id="18ec" class="ky kz hi jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">没有指定运行容器的命令，所以它不会启动</li></ul><p id="7b75" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我们可以通过将管道改为以下形式来解决这两个问题:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="978e" class="kt ig hi kp b fi ku kv l kw kx">push:<br/>  steps:<br/>    - script:<br/>      name: export version to tag the image with<br/>      code: |<br/>        [ "$WERCKER_GIT_BRANCH" = "master" ] \<br/>        &amp;&amp; export PACKAGE_VERSION=$(node -p -e "require('./package.json').version") \<br/>        || export PACKAGE_VERSION=development<br/>    - internal/docker-push:<br/>      registry: <a class="ae ki" href="https://gcr.io" rel="noopener ugc nofollow" target="_blank">https://gcr.io</a><br/>      username: _json_key<br/>      password: $GCR_JSON_KEY_FILE<br/>      repository: gcr.io/$GCR_PROJECT_NAME/$WERCKER_GIT_REPOSITORY<br/>      tag: $PACKAGE_VERSION<br/>      working-dir: $WERCKER_SOURCE_DIR<br/>      cmd: npm start</span></pre><p id="6c96" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">脚本步骤检查分支是否是主分支，并将package.json的' version '属性作为环境变量导出。</p><p id="c4b5" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">对接推进步骤现在有一个<em class="kj">标签</em>、<em class="kj">工作方向</em>和<em class="kj">命令</em>。默认情况下,<em class="kj"> cmd </em>属性在根文件夹<em class="kj"> / </em>中执行，因此我必须将working-dir属性添加到步骤中以使其工作(该属性尚未记录在worker的文档中，但它可以工作)。</p><p id="edf1" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">现在，您可以打开wercker的UI，在构建管道之后添加管道:</p><figure class="kk kl km kn fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lm"><img src="../Images/ae354596f62f67d3f49bb6fd414c8b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g72quhfPYsc35JpyymAO2w.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">相同的步骤，不同的环境变量:D</figcaption></figure><p id="952e" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">接下来，我们将添加一个管道，以便在构建和推送成功时将我们的应用程序部署到Kubernetes，这将是本系列的第3部分。</p></div></div>    
</body>
</html>