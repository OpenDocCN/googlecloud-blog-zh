<html>
<head>
<title>Google Cloud Run with KNative CLI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用KNative CLI运行Google Cloud</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-run-with-knative-cli-4299d94110d5?source=collection_archive---------1-----------------------#2022-03-21">https://medium.com/google-cloud/google-cloud-run-with-knative-cli-4299d94110d5?source=collection_archive---------1-----------------------#2022-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2a4967771e1e3aef6621d753129c31f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFYSdPydqsr-6eVibkKjtw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">从<a class="ae iu" href="https://www.thw-viernheim.de/berichte/archiv/2011/neuer-adapter-ermoeglicht-wasserversorgung-ueber-aggregate.html" rel="noopener ugc nofollow" target="_blank">THW·维恩海姆</a>到Gardena的三相电流</figcaption></figure><p id="38e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所知，Google Cloud Run正在实现KNative API，并且基本上以托管服务的形式提供KNative。<a class="ae iu" href="https://twitter.com/ahmetb" rel="noopener ugc nofollow" target="_blank"> Ahmet </a>就此写了一篇很棒的<a class="ae iu" href="https://ahmet.im/blog/cloud-run-is-a-knative/" rel="noopener ugc nofollow" target="_blank">博客文章</a>，并对云运行API偏离KNative API的地方给出了很好的见解。今天我想向你们展示这在现实中意味着什么。通常，当使用Cloud Run时，您会使用Google提供的gcloud SDK工具，但您也可以轻松使用KNative 的<a class="ae iu" href="https://knative.dev/docs/install/client/" rel="noopener ugc nofollow" target="_blank"> kn CLI。</a></p><p id="10be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，您必须设置Kubernetes配置(<code class="du jt ju jv jw b">˜/.kube/config</code>)以指向云运行API:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="f5f7" class="kf kg hi jw b fi kh ki l kj kk">apiVersion: v1<br/>clusters:<br/>- cluster:<br/>    server: <a class="ae iu" href="https://us-central1-run.googleapis.com:443" rel="noopener ugc nofollow" target="_blank">https://us-central1-run.googleapis.com:443</a><br/>  name: cloudrun<br/>contexts:<br/>- context:<br/>    cluster: cloudrun<br/>    user: cloudrun<br/>  name: cloudrun<br/>current-context: cloudrun<br/>kind: Config<br/>preferences: {}<br/>users:<br/>- name: cloudrun<br/>  user:<br/>    exec:<br/>      apiVersion: client.authentication.k8s.io/v1beta1<br/>      args: null<br/>      command: gke-gcloud-auth-plugin<br/>      env: null<br/>      installHint: Install gke-gcloud-auth-plugin for use with kubectl by following<br/>        go/gke-kubectl-exec-auth<br/>      interactiveMode: IfAvailable<br/>      provideClusterInfo: true</span></pre><p id="a9f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的配置使用<a class="ae iu" href="https://cloud.google.com/blog/products/containers-kubernetes/kubectl-auth-changes-in-gke" rel="noopener ugc nofollow" target="_blank">gke-g Cloud-auth-plugin</a>credential helper来针对云运行API进行身份验证。需要注意的是，你必须选择一个区域端点。在Cloud Run API中，k8s名称空间相当于一个GCP项目，因此要与API交互，您需要提供一个项目id或项目编号，并带有参数<code class="du jt ju jv jw b">-n</code>，因为没有<code class="du jt ju jv jw b">default</code>。下面是一个使用kn列出服务的示例:</p><p id="bb90" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">kn service list -n &lt;gcp_project_id&gt;</code></p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/300df9e3456e166b8c1ae66a4f3b069a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivUpe9-qXZi5Yw4VmkuL7g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">查询可用服务时的控制台输出示例</figcaption></figure><h1 id="4e41" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用Kubectl</h1><p id="dfed" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我问自己,<code class="du jt ju jv jw b">kn</code>管用吗,<code class="du jt ju jv jw b">kubectl</code>也管用吗？遗憾的是，云运行API缺少Kubernetes API中的一些发现端点，而这些端点本来就允许这样做。所以你在调用<code class="du jt ju jv jw b">kube get all</code>时会得到一些错误。但是我通过为云运行创建一个简单的<a class="ae iu" href="https://github.com/cgrotz/blog-examples/tree/main/cloudrun-kubernetes-compatibility-layer" rel="noopener ugc nofollow" target="_blank"> K8S API兼容层</a>来实现其中的一些端点，尝试了各种可能。由于你下面没有一个羽翼丰满的K8S，所以有一些限制，但这可以让你和<code class="du jt ju jv jw b">kubectl</code>一起使用Cloud Run。要使用它，部署示例兼容性层并修改上面的配置以指向您的云运行服务。</p><p id="b28a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">遗憾的是，Cloud Run API在响应负载中使用项目编号，这意味着如果您使用名称空间的项目id而不是项目编号，您将从kubectl获得一条错误消息。列出GCP项目中部署的服务的示例如下:</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/8c4cf28eaa0e3306fc2a0ead593a1e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1Ngr4BANgIn1i6LnNMnCw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">运行kubectl get service -n <project_number/></figcaption></figure><p id="0693" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要部署新的云运行服务，您可以简单地调用<code class="du jt ju jv jw b">kubectl apply --validate=false -f &lt;yaml&gt;</code>，但是由于兼容层目前不提供Knative的swagger/OpenAPI规范，您必须禁用验证。</p><p id="cc96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还测试了Helm的兼容性层，但由于Helm默认使用基于秘密的<a class="ae iu" href="https://helm.sh/docs/topics/advanced/#storage-backends" rel="noopener ugc nofollow" target="_blank">存储后端</a>作为其部署状态。如果你想让它运行或者扩展兼容层来实现一个简单的secrets API，你可以选择一个SQL存储后端，例如一个GCP Secret Manager后端。</p></div></div>    
</body>
</html>