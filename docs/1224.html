<html>
<head>
<title>Java Logging on Cloud Run with Stackdriver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Stackdriver在云上运行Java日志记录</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/java-logging-on-cloud-run-with-stackdriver-9786d6fdbe17?source=collection_archive---------0-----------------------#2019-12-14">https://medium.com/google-cloud/java-logging-on-cloud-run-with-stackdriver-9786d6fdbe17?source=collection_archive---------0-----------------------#2019-12-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/063d198e84e0bf6cf54e2ad6e1a87ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEfbRzDQZV2H2Vcd2FVqKQ.png"/></div></div></figure><p id="05fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在微服务时代，充分的日志记录和跟踪对于监控和调试您的服务更加重要。当使用容器时，由于容器的灵活性和短暂性，增加了一层复杂性。用户必须考虑如何通过安装永久卷来“从容器中”获取信息。不管怎样，你很幸运！与其他谷歌云平台(GCP)计算产品类似，<a class="ae jo" href="https://cloud.google.com/logging/docs/agent/" rel="noopener ugc nofollow" target="_blank"> Stackdriver日志代理</a>内置在云运行环境中，因此您的日志会自动通过管道传输并整合到<a class="ae jo" href="http://console.cloud.google.com/logs" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>中。</p><p id="f2bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博客文章将介绍云运行的Java日志记录，尽管这些概念可以应用于谷歌应用引擎(GAE)。我们将讨论不同的日志类型在Stackdriver中的外观和相关的产品错误报告，以及如何使用跟踪id升级日志。</p><p id="94f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从头开始。写入标准输出和标准错误的任何日志都将显示在您的Stackdriver日志中，但没有任何附加信息或功能。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1d3e" class="jy jz hi ju b fi ka kb l kc kd">System.out.println(“This log was made with System.out.println”);<br/>System.err.println(“This log was made with System.err.println”);</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/49389c60529ebcff7e8624fb77a76b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v6a_XH9XqUUuJs3b"/></div></div></figure><p id="654c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这与您在使用java.util.logging、log4j2或slf4j等框架时获得的功能相同，无需任何额外的配置。有了所有这些框架，我们可以从一些基本的日志提示开始:</p><ol class=""><li id="4170" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated">设置日志消息的严重性。设置严重性可以帮助您过滤日志，直观地查找日志条目，以及设置指标和警报。</li><li id="aaed" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">添加清晰可行的错误消息。当你试着调试的时候，不要恨你自己。</li><li id="548e" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">添加堆栈跟踪(作为Throwable)。任何关于错误来源的额外信息都比没有好！</li></ol><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="c894" class="jy jz hi ju b fi ka kb l kc kd">utilLogger.log(<br/>    Level.INFO, “Error report INFO with java.util.logging”, e);<br/>utilLogger.log(<br/>    Level.SEVERE, “Error report ERROR with java.util.logging”, e);</span><span id="8b69" class="jy jz hi ju b fi kt kb l kc kd">slf4jLogger.info(“Error report INFO with Logback”, e);<br/>slf4jLogger.error(“Error report ERROR with Logback”, e);</span></pre><p id="0960" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传递throwable意味着您获得了Stackdriver错误报告的好处！错误报告汇总并显示您正在运行的云服务中产生的错误，以便提供实时异常监控和警报。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/c6b3b18d7243f4147edb8b74c597abf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_BojCVJuGiB4PFXY"/></div></div></figure><p id="a234" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于App Engine，Google提供了额外的库支持，使用Logback appender和JUL ( <code class="du kv kw kx ju b">java.uti.logging</code>)处理程序将<a class="ae jo" href="https://cloud.google.com/logging/docs/setup/java" rel="noopener ugc nofollow" target="_blank">日志记录到Stackdriver </a>。这样可以正确解析日志级别，并添加额外的配置，如严重性阈值、日志名称和增强器。GAE上的<a class="ae jo" href="https://github.com/GoogleCloudPlatform/java-docs-samples/tree/master/logging/logback" rel="noopener ugc nofollow" target="_blank">默认配置</a>会在Stackdriver控制台中产生这些日志:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/2687f06843d624bdaf3bfdd20f82fefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DPn5DHVmHmqBC45K"/></div></div></figure><p id="ccb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">遗憾的是，Cloud Run与App Engine的<a class="ae jo" href="https://cloud.google.com/appengine/docs/standard/java11/runtime" rel="noopener ugc nofollow" target="_blank">运行时环境</a>略有不同；因此，这些集成不能开箱即用。通过使用<a class="ae jo" href="http://logback.qos.ch/" rel="noopener ugc nofollow" target="_blank"> Logback </a>升级到JSON格式的日志，您可以很容易地重新获得这个功能，这意味着您可以继续使用它的本机接口，Java (SLF4J)的简单日志门面。</p><p id="7d51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您的登录配置必须附加到控制台。这里我们使用了追加器<code class="du kv kw kx ju b">ch.qos.logback.core.ConsoleAppender</code>。然后使用编码器<code class="du kv kw kx ju b"><a class="ae jo" href="https://github.com/logstash/logstash-logback-encoder" rel="noopener ugc nofollow" target="_blank">net.logstash.logback.encoder.LogstashEncode</a></code>允许转换成JSON格式。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9f34" class="jy jz hi ju b fi ka kb l kc kd">&lt;<strong class="ju hj">configuration</strong>&gt;<br/>  &lt;<strong class="ju hj">appender</strong> name="jsonConsoleAppender"<br/>      class="ch.qos.logback.core.ConsoleAppender"&gt;<br/>    &lt;<strong class="ju hj">encoder</strong> class="net.logstash.logback.encoder.LogstashEncoder"&gt;<br/>      &lt;<strong class="ju hj">fieldNames</strong>&gt;<br/>        &lt;<strong class="ju hj">timestamp</strong>&gt;[ignore]&lt;/<strong class="ju hj">timestamp</strong>&gt;<br/>        &lt;<strong class="ju hj">version</strong>&gt;[ignore]&lt;/<strong class="ju hj">version</strong>&gt;<br/>        &lt;<strong class="ju hj">logger</strong>&gt;[ignore]&lt;/<strong class="ju hj">logger</strong>&gt;<br/>        &lt;<strong class="ju hj">thread</strong>&gt;[ignore]&lt;/<strong class="ju hj">thread</strong>&gt;<br/>        &lt;<strong class="ju hj">levelValue</strong>&gt;[ignore]&lt;/<strong class="ju hj">levelValue</strong>&gt;<br/>      &lt;/<strong class="ju hj">fieldNames</strong>&gt;<br/>    &lt;/<strong class="ju hj">encoder</strong>&gt;<br/>  &lt;/<strong class="ju hj">appender</strong>&gt;<br/>  &lt;<strong class="ju hj">root</strong> level="INFO"&gt;<br/>    &lt;<strong class="ju hj">appender-ref</strong> ref="jsonConsoleAppender"/&gt;<br/>  &lt;/<strong class="ju hj">root</strong>&gt;<br/>&lt;/<strong class="ju hj">configuration</strong>&gt;</span></pre><p id="b014" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此配置忽略了不需要的额外默认字段。所需的依赖关系有:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="ee9a" class="jy jz hi ju b fi ka kb l kc kd">&lt;<strong class="ju hj">dependency</strong>&gt;<br/>  &lt;<strong class="ju hj">groupId</strong>&gt;net.logstash.logback&lt;/<strong class="ju hj">groupId</strong>&gt;<br/>  &lt;<strong class="ju hj">artifactId</strong>&gt;logstash-logback-encoder&lt;/<strong class="ju hj">artifactId</strong>&gt;<br/>  &lt;<strong class="ju hj">version</strong>&gt;5.2&lt;/<strong class="ju hj">version</strong>&gt;<br/>&lt;/<strong class="ju hj">dependency</strong>&gt;<br/>&lt;<strong class="ju hj">dependency</strong>&gt;<br/>  &lt;<strong class="ju hj">groupId</strong>&gt;ch.qos.logback&lt;/<strong class="ju hj">groupId</strong>&gt;<br/>  &lt;<strong class="ju hj">artifactId</strong>&gt;logback-classic&lt;/<strong class="ju hj">artifactId</strong>&gt;<br/>  &lt;<strong class="ju hj">version</strong>&gt;1.2.3&lt;/<strong class="ju hj">version</strong>&gt;<br/>&lt;/<strong class="ju hj">dependency</strong>&gt;</span></pre><p id="3085" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用JSON作为日志格式还允许进行结构化日志记录，这意味着您可以向日志中添加更多可读/可解析的信息，以便进行调试。传统的方法是使用所有主要日志框架提供的映射诊断上下文(MDC)。为了让Stackdriver解析日志级别，我们必须将其添加为severity字段。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="ab75" class="jy jz hi ju b fi ka kb l kc kd">MDC.put(“severity”, “ERROR”);<br/>logger.error(“Logging ERROR with Logback”);<br/>MDC.remove(“severity”);</span></pre><p id="0f5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du kv kw kx ju b">logstash-logback-encoder</code>库允许特定于事件的定制字段，这意味着我们可以将键值<code class="du kv kw kx ju b"><a class="ae jo" href="https://github.com/logstash/logstash-logback-encoder/blob/logstash-logback-encoder-5.2/src/main/java/net/logstash/logback/argument/StructuredArguments.java" rel="noopener ugc nofollow" target="_blank">StructuredArguments</a></code>添加到我们的JSON日志中。这使得添加多个特定于日志的字段变得更加容易和简洁。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="30a4" class="jy jz hi ju b fi ka kb l kc kd">logger.info(“Logging INFO with Logback”,<br/>            kv(“severity”, “NOTICE”),<br/>            kv(“component”, “arbitrary-property”));</span></pre><p id="1cd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du kv kw kx ju b">StructuredArguments</code>或<code class="du kv kw kx ju b">MDC</code>，我们还可以使用特定的JSON字段<code class="du kv kw kx ju b">logging.googleapis.com/trace</code>将跟踪Id附加到日志中。了解关于结构化有效载荷的特殊字段的更多信息。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="6167" class="jy jz hi ju b fi ka kb l kc kd">String traceHeader = req.headers("x-cloud-trace-context");<br/>String trace = traceHeader.split("/")[0];<br/>logger.info("Logging with trace Id",<br/>           kv(“severity”, “DEBUG”),<br/>           kv(“logging.googleapis.com/trace”,<br/>           String.format(“projects/%s/traces/%s”, project, trace)));</span></pre><p id="192d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Stackdriver日志查看器中，由同一跟踪关联的日志可以以“父子”格式查看:当您单击请求日志条目左侧的三角形图标时，与该请求相关的容器日志会嵌套在请求日志下显示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/aafada21953b8d127d935dd749fdc42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmS_mUwIgNBuk7XJ3pQRzQ.png"/></div></div></figure><p id="319c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Logback也是Spring Boot应用程序的默认日志配置，使用带有<a class="ae jo" href="https://github.com/spring-cloud/spring-cloud-gcp/blob/master/spring-cloud-gcp-logging/src/main/resources/org/springframework/cloud/gcp/logging/logback-json-appender.xml" rel="noopener ugc nofollow" target="_blank"> JSON appender </a>的日志启动器可以很容易地与GCP集成。使用这个appender资源，没有必要在日志消息中指定严重性。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f518" class="jy jz hi ju b fi ka kb l kc kd">&lt;<strong class="ju hj">configuration</strong>&gt;<br/>  &lt;<strong class="ju hj">include</strong> resource=<br/> "org/springframework/cloud/gcp/logging/logback-json-appender.xml"/&gt;<br/>   &lt;<strong class="ju hj">root</strong> level=”INFO”&gt;<br/>       &lt;<strong class="ju hj">appender-ref</strong> ref="CONSOLE_JSON"/&gt;<br/>   &lt;/<strong class="ju hj">root</strong>&gt;<br/>&lt;/<strong class="ju hj">configuration</strong>&gt;</span></pre><p id="ffb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要把日志记录留到最后一刻！Stackdriver为您提供了一个集中的系统来访问您在GCP服务中的所有日志。通过在JSON中构建日志并添加上下文元数据以简化故障排除，充分利用日志和Stackdriver。</p><p id="42a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下一步</strong></p><ul class=""><li id="c850" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn la kl km kn bi translated">查看关于云运行上的<a class="ae jo" href="https://cloud.google.com/run/docs/logging" rel="noopener ugc nofollow" target="_blank">日志记录和查看日志</a>的官方文档。</li><li id="2bd6" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn la kl km kn bi translated">了解更多关于在Stackdriver中<a class="ae jo" href="https://cloud.google.com/logging/docs/logs-based-metrics/charts-and-alerts" rel="noopener ugc nofollow" target="_blank">创建图表和警报</a>的信息。</li><li id="6d8d" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn la kl km kn bi translated">遵循关于云运行服务的<a class="ae jo" href="https://cloud.google.com/run/docs/tutorials/local-troubleshooting" rel="noopener ugc nofollow" target="_blank">本地故障排除的教程。</a></li></ul></div></div>    
</body>
</html>