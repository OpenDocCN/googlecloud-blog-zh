<html>
<head>
<title>How to alert on SLOs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提醒SLO</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-alert-on-slos-2a5ce8c4e7dd?source=collection_archive---------0-----------------------#2020-09-28">https://medium.com/google-cloud/how-to-alert-on-slos-2a5ce8c4e7dd?source=collection_archive---------0-----------------------#2020-09-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="03e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我花了相当多的时间来研究在服务监控中定义和配置SLO。最近，我收到了许多关于接下来会发生什么的问题-一旦配置了SLO，人们想知道如何使用警报来通知潜在的、即将发生的和正在发生的SLO违规。服务监控提供了SLO错误预算消耗<a class="ae jd" href="https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/alerting-on-budget-burn-rate" rel="noopener ugc nofollow" target="_blank">警报</a>来实现这一点，但是使用这些警报并不总是直观的。我开始尝试这些方法，并记录下我一路上的发现。让我们看看会发生什么！</p><h1 id="ba3c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">理论上…</h1><p id="4d69" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">SRE工作手册有整整一章<a class="ae jd" href="https://landing.google.com/sre/workbook/chapters/alerting-on-slos/" rel="noopener ugc nofollow" target="_blank">专门讲述SLO警报。我不认为我需要在这里重复它，但有两类考虑是非常重要的:</a></p><ul class=""><li id="9304" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">您的警报和您的服务经历的SLO事件的数量之间有什么关系？</li></ul><p id="fed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> — Precision </strong>是您的真实阳性率——您的警报中有多少会真正表明您需要了解的事件？</p><p id="9c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> —回想一下</strong>是你的“敏感度”——你的事件中有多少部分实际上会引发警报？</p><ul class=""><li id="4e63" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">警报和触发它的事件之间有什么关系？</li></ul><p id="6c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> —检测时间</strong>是事件开始和警报触发之间的时间</p><p id="52eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> —复位时间</strong>是事件结束和报警复位之间的时间</p><p id="4c29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以想象，您的SLO本身和您配置的警报会影响所有这些。不可能优化所有这些(将精度和召回率提高到100%，将检测时间和重置时间设置为零)而不淹没在警报中，其中大部分是不可操作的。同时，等到超出错误预算时才发出警报是不现实的，提前通知是必要的，以便能够采取适当的措施来确保服务保持在每日/每周/每月的错误预算内。提醒<strong class="ih hj">错误预算消耗</strong>，而不是提醒你的服务是否在某个特定的短时间内位于SLO境内，才是达到目的的方法。</p><p id="5df9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一个显而易见的问题是，在触发警报之前，应该消耗多少误差预算？SRE工作手册第<a class="ae jd" href="https://landing.google.com/sre/workbook/chapters/alerting-on-slos/" rel="noopener ugc nofollow" target="_blank">章</a>中推荐的最先进的方法是使用多窗口、多燃烧速率警报(见第6节)。但是首先，我非常喜欢按照“1小时内2%烧伤和6小时内5%烧伤”的建议，使用不同烧伤率的两个独立警报的想法。</p><p id="ef7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，这也是难点，您如何确定准确的烧钱速率和警报窗口，以达到所需的精确度和重置时间，同时将服务的运营开销(响应不需要的警报)降至最低？书中写道:</p><blockquote class="kq kr ks"><p id="5701" class="if ig kt ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">“对于基于燃烧速率的警报，警报触发所需的时间为:</p><p id="1954" class="if ig kt ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">触发时间= (1-SLO) /错误率*警报窗口大小*燃烧率</p><p id="51f0" class="if ig kt ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">触发警报时消耗的错误预算为:</p><p id="f976" class="if ig kt ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">消耗的预算=燃烧速率*警报窗口大小/周期”</p></blockquote><p id="9f5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子来阐明这一点。假设您在一个滚动的28天窗口内拥有99.9%的可用性SLO。如果您在上一个小时内消耗了1%的错误预算，则需要发出警报。这意味着，如果过去一小时内的错误率大于目标预算* (1-SLO) *(期间/窗口)，则需要触发警报。</p><p id="b654" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，Service Monitoring不允许您指定错误率—相反，您必须提供<a class="ae jd" href="https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/alerting-on-budget-burn-rate" rel="noopener ugc nofollow" target="_blank">烧损率阈值</a>。烧钱速率是服务消耗错误预算的速率。如果烧损率为1.0，则在SLO评估期结束时，您将完全消耗100%的错误预算。如果烧损率为2.0，则在期末时，您将消耗200%的错误预算(或在评估期间的中途消耗了所有错误预算)，依此类推。使用上面的等式来计算燃烧速率，我们得到</p><p id="1d27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b"><em class="kt">burn rate = budget consumed * period / alerting window</em></code></p><p id="1c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的示例中:</p><ul class=""><li id="7438" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">SLO = 99.9%，或. 999</li><li id="1043" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">警报窗口大小= 1小时</li><li id="b1b4" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">消耗的预算= 1%或. 01</li><li id="df74" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">周期= 28天或672小时</li></ul><p id="1400" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着</p><p id="cde0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">burn rate = .01 * 672 / 1= 6.72</code></p><p id="6a39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将我们的警报配置为具有60分钟的回看周期和6.72的烧损率阈值，那么我们可以基于我们的服务体验的错误率来计算我们获得警报的速度。例如，如果我们的错误率上升到1%<code class="du kx ky kz la b">time to fire = (1-.999) / .01 * 1 * 672 = 67.2 hours</code>，这几乎是3天—这是召回率低的警报！</p><p id="a806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们希望提高召回率并在1小时内发出正确的警报，我们使用<code class="du kx ky kz la b">1 = (1-.999) / .01 * 1 * burn rate</code>计算燃烧速率，这意味着<code class="du kx ky kz la b">burn rate = 10</code>。确认— <code class="du kx ky kz la b">time to fire = (1-.999) / .01 * 1 * 6.72 = 1</code>！我们的警报将在一小时内发出。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="c520" class="je jf hi bd jg jh ln jj jk jl lo jn jo jp lp jr js jt lq jv jw jx lr jz ka kb bi translated">实际上……</h1><p id="8d27" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我希望了解如何使用Service Monitoring来实现一种更简单的方法(如第5节中所述)—按照“1小时内2%燃烧和6小时内5%燃烧”的建议，使用不同的燃烧速率发出两个单独的警报。</p><h1 id="a40a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">设置</h1><h1 id="7012" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">服务业和SLO</h1><p id="57b5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，我需要一个简单的应用程序，无需重新部署代码就可以精确控制它的错误率。你可以在这里看到服务<a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/blob/master/slo-alerting-demo/log-based/app-logging.js" rel="noopener ugc nofollow" target="_blank">的代码。这是一个非常基本的Node.js Express应用程序，它为每个请求和失败写日志条目。然后，我配置了基于日志的指标来计算这两者。我使用UI配置了一个服务:</a></p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es ls"><img src="../Images/f5d6a27eb8b66a8ee3c778f901024612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kf3kTES0i4ejh9Hr"/></div></div></figure><p id="7836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我需要定义SLO。因为我的服务对“好的”和“坏的”过滤器使用了两种不同的标准，所以我不知道如何在UI中创建这样的SLO。因此，我需要使用API——API调用如下:</p><figure class="lt lu lv lw fd lx"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="af21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就创造了“连续28天95%的可用性”的SLO。这是在用户界面中:</p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/c609c308876043417b07457e067e0c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GyqJVz7Dp8FhC4T1"/></div></div></figure><h1 id="fd70" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">故障注入</h1><p id="ee15" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">接下来，我需要将期望的错误率注入到服务中，以便能够验证增加错误率会导致错误预算消耗并触发警报。经过一些内部讨论，我确定了几个选项:</p><ul class=""><li id="0721" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">使用Istio的<a class="ae jd" href="https://istio.io/latest/docs/tasks/traffic-management/fault-injection/" rel="noopener ugc nofollow" target="_blank">故障注入</a>功能</li><li id="700e" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">让我的应用程序读取可由<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/configmap" rel="noopener ugc nofollow" target="_blank"> ConfigMap </a>管理的环境变量</li></ul><p id="3dcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我决定用后者。你可以在这里看到我的代码<a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/blob/master/slo-alerting-demo/log-based/app-logging.js" rel="noopener ugc nofollow" target="_blank"/>；要点是，我使用Node的<code class="du kx ky kz la b">process.ENV.&lt;variable name&gt;</code>让我的代码在服务请求时读取变量。变量本身的值是在ConfigMap中设置的——我按照这些<a class="ae jd" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" rel="noopener ugc nofollow" target="_blank">指令</a>从一个基本的。属性文件。我发现的另一个复杂情况是，pod只会在启动时读取环境变量的值——所以当我想更改值时，我需要删除它并让部署重新创建它。</p><h1 id="b61a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">警报</h1><p id="4213" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最后，我准备好设置我的提醒。如前所述，我想测试两个警报:</p><ul class=""><li id="442b" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">2%误差预算在1小时内完成</li><li id="4b50" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">5%的误差预算在6小时内完成</li></ul><p id="e94a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如“理论”部分所述，服务监控需要两个错误预算烧录警报输入—回看持续时间和烧录速率阈值:</p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/34947cb98681f8c371b6edfe6ad05c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tal2aKnaWn-gKig-"/></div></div></figure><p id="7633" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我知道我想要监视一个小时内的误差预算消耗，所以回顾持续时间是一个简单的决定——我将其设置为60分钟。然而，我需要计算我的燃烧率阈值。我已经展示了我是如何计算“1小时内1%的”烧伤示例的。这一次，我的输入如下:</p><ul class=""><li id="c695" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">警报窗口大小= 1小时</li><li id="f22b" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">消耗的预算= 2%或0.02</li><li id="52f3" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">周期= 28天或672小时</li></ul><p id="87ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算燃烧速率，我使用了</p><p id="a1ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">burn rate = budget consumed * period / alerting window = .02 * 672 / 1 = 13.44</code></p><p id="c92a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的警报策略预期的刻录率阈值:</p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/9068e486545119f48d57969e10464687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nqHkbL0yol3VhNPW"/></div></div></figure><p id="957a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我需要计算“6小时内消耗5%的错误预算”警报的消耗率阈值。这一次:</p><ul class=""><li id="4d26" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">警报窗口大小= 6小时</li><li id="ff0e" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">消耗的预算= 5%或0.05</li><li id="e487" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">周期= 28天或672小时</li></ul><p id="4777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着</p><p id="8e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">burn rate = budget consumed * period / alerting window = .05 * 672 / 6 = 6.72 :</code></p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/1b0985767c5370160daab02dd66ae016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fbiMx77jyiVrxV6h"/></div></div></figure><p id="4f27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我的两个警报都准备好了。我准备在服务中引入错误并测试警报。</p><h1 id="e5b8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">测试警报</h1><p id="3963" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我需要回答的第一个问题是——在合理的时间范围内触发警报的错误率应该是多少？如上所述:</p><p id="23fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">time to fire = (1-SLO) / error ratio * alerting window size * burn rate</code></p><p id="d401" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使得</p><p id="5f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kx ky kz la b">error ratio = (1 — SLO) * alerting window size * burn rate / time to fire</code></p><p id="5901" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于第一个警报，我的值如下:</p><ul class=""><li id="746d" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">期望点火时间= 1小时</li><li id="df08" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">SLO = 95%或0.95</li><li id="7365" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">警报窗口大小= 1小时</li><li id="5a91" class="kh ki hi ih b ii lb im lc iq ld iu le iy lf jc km kn ko kp bi translated">燃烧率= 13.44</li></ul><p id="1733" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我的错误率至少需要达到0.672，或者67.2%——这相当高了！我用该值重新创建了configmap，并删除了由部署自动重新创建的pod。几乎立刻，我发现我的SLI减少了:</p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/b7b5fee145e28440f8e1744ed3073fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cte5WS2wFku47ivi"/></div></div></figure><p id="6aa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我把我的SLO设置得比我预期的要高，所以服务已经超出了误差预算，但是直接的下降仍然完全在我的预料之中。我的服务也没有运行整整一个月，所以我认为警报的触发会比我的计算快得多，因为此时我实际上还没有积累足够的错误预算，烧2%根本不需要时间。</p><p id="ad12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">果不其然，我很快就看到错误预算消耗率超过了阈值:</p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/f7dc01c5421146c17cfb811915e0a03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7pNyjCUhXi9jesvK"/></div></div></figure><p id="23cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并生成警报:</p><figure class="lt lu lv lw fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mh"><img src="../Images/a4b891639c44d9b4ddfd5a65ac9b530f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nUdqe8ZyiGbHJEUH"/></div></div></figure></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="3871" class="je jf hi bd jg jh ln jj jk jl lo jn jo jp lp jr js jt lq jv jw jx lr jz ka kb bi translated">正在总结…</h1><p id="d06e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我真的很高兴我花时间弄明白了这一点，并记录了我的旅程，我希望这对你有所帮助。特别是，我发现在产品文档中没有太多关于什么是错误预算消耗率的信息，需要挖掘才能真正理解计算错误预算消耗率的数学方法。然而，我非常喜欢这种在SLO上设置警报的方法。感谢你的阅读，请告诉我你的想法！</p></div></div>    
</body>
</html>