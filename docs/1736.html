<html>
<head>
<title>Scripting with Github Octokit in Google Cloud Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google Cloud Build中使用Github Octokit编写脚本</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/scripting-with-github-octokit-in-google-cloud-build-583f9fe421fe?source=collection_archive---------2-----------------------#2020-12-30">https://medium.com/google-cloud/scripting-with-github-octokit-in-google-cloud-build-583f9fe421fe?source=collection_archive---------2-----------------------#2020-12-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d4e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不久前，我写了如何通过谷歌云构建在拉式请求中发布<a class="ae jd" rel="noopener" href="/google-cloud/terraform-plan-in-pull-requests-with-gcp-cloud-build-603790a2b734"> Terraform计划。如果你在寻找最简单的方式在PR中发表评论，这仍然是首选方式。</a></p><div class="jf jg ez fb jh ji"><a rel="noopener follow" target="_blank" href="/google-cloud/terraform-plan-in-pull-requests-with-gcp-cloud-build-603790a2b734"><div class="jj ab dw"><div class="jk ab jl cl cj jm"><h2 class="bd hj fi z dy jn ea eb jo ed ef hh bi translated">使用GCP云构建的拉式请求中的平台计划</h2><div class="jp l"><h3 class="bd b fi z dy jn ea eb jo ed ef dx translated">运行terraform计划，并通过Google Cloud Build向您的Github Pull请求提交评论</h3></div><div class="jq l"><p class="bd b fp z dy jn ea eb jo ed ef dx translated">medium.com</p></div></div><div class="jr l"><div class="js l jt ju jv jr jw jx ji"/></div></div></a></div><p id="469f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是说实话。在组织内部使用个人访问令牌？我敢打赌，在你点击“生成”按钮3秒钟后，你会有一个可怕的安全官员跟着你。</p><p id="4614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案:<strong class="ih hj">一个私人Github App </strong>。使用Github应用程序会带来很多亮点:</p><ul class=""><li id="030e" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated">每个<a class="ae jd" href="https://docs.github.com/en/free-pro-team@latest/rest/reference" rel="noopener ugc nofollow" target="_blank"> API </a>的权限都是细粒度的。例如，你只能允许应用程序的<em class="je">拉请求</em>API，而不是给它完全的<code class="du kh ki kj kk b">repo</code>访问权限</li><li id="cc27" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">你可以通过官方支持的<a class="ae jd" href="https://octokit.github.io/rest.js/v18/" rel="noopener ugc nofollow" target="_blank"> Octokit </a>直接使用API</li><li id="fcb0" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">您可以选择应用程序应该可以访问哪些存储库</li><li id="d5e5" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">Github应用程序通过一个. pem证书来保护，Octokit创建短期令牌(security++)</li></ul><p id="16a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有一点:<strong class="ih hj">你可以用JavaScript </strong>来编写这个构建器的脚本！</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/55dbef29876c1479911de6acf43214c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDjk2aLoHKYZU36BU6JRmw.png"/></div></div></figure><h1 id="bf5a" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装构建器</h1><p id="45ca" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated"><strong class="ih hj">编辑</strong>:投稿已经合并。更新了以下安装步骤(<a class="ae jd" href="https://github.com/GoogleCloudPlatform/cloud-builders-community/pull/472" rel="noopener ugc nofollow" target="_blank"> PR#472 </a>):</p><pre class="kr ks kt ku fd me kk mf mg aw mh bi"><span id="9105" class="mi lc hi kk b fi mj mk l ml mm">git clone https://github.com/GoogleCloudPlatform/cloud-builders-community.git<br/>cd cloud-builders-community/octokit<br/>gcloud builds submit --config=cloudbuild.yaml .</span></pre><h1 id="3b21" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">要求</h1><p id="566f" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">在我们继续之前，请确保您具备以下条件:</p><ul class=""><li id="3997" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated">Github应用程序(个人或组织内)。使用<a class="ae jd" href="https://docs.github.com/en/free-pro-team@latest/developers/apps/creating-a-github-app" rel="noopener ugc nofollow" target="_blank">正式文件</a>创建新的正式文件</li><li id="3ed1" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">为Github应用程序生成的证书。<a class="ae jd" href="https://docs.github.com/en/free-pro-team@latest/developers/apps/authenticating-with-github-apps" rel="noopener ugc nofollow" target="_blank">砸碎Github里的一些按钮</a></li><li id="8f6b" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">在Github应用程序中选择访问您的工作存储库(否则您将无法访问它)</li></ul><h1 id="3302" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在GCP境内保护证书</h1><p id="4fa4" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">首先，一旦你生成了<em class="je">。pem </em>文件，打开你的秘密管理器，创建一个新的秘密。使用<em class="je">上传文件</em>功能或打开文件并将其内容复制到<em class="je">秘密值中。</em>其他一切都可以保持默认，除非你想调整它。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es mn"><img src="../Images/43f9405d2011f6669d2b4651a8dd9f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZqKrdzC2bJ0a5fn1OkspQ.png"/></div></div><figcaption class="mo mp et er es mq mr bd b be z dx translated">在秘密管理器中创建秘密</figcaption></figure><h1 id="c877" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">准备构建器</h1><p id="a922" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">设置非常简单。构建器<strong class="ih hj">自动认证你提供的Github App </strong>。你需要:</p><ul class=""><li id="5d31" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated"><strong class="ih hj"> App ID </strong> —转到Github App的<em class="je">常规</em>标签，你会在<em class="je">关于</em>部分下看到ID</li><li id="cdb2" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated"><strong class="ih hj">安装ID </strong> —打开您的用户或组织的设置(无论您在哪里安装了Github App)，<em class="je">已安装Github App&gt;“配置”(在您的App上)。</em> <strong class="ih hj"> <em class="je"> </em> </strong>安装ID可以作为您浏览器URL的最后一个路由段找到</li></ul><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ms"><img src="../Images/65c99244f6d68761233edadf8801bbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpuOfEXthsN8liQWvZW-GA.png"/></div></div><figcaption class="mo mp et er es mq mr bd b be z dx translated">在配置过程中，可以在浏览器URL中找到安装ID</figcaption></figure><p id="5d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多用例需要涵盖，从直接从Github获得更多元数据到在一次构建中创建自定义检查。您可能想要报告<strong class="ih hj">对运行在一个构建中的不同类型的测试或模块的粒度检查</strong>。</p><p id="8c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">现在的云构建不支持默认创建自定义构建</em> <em class="je">摘要</em>，所以您的默认构建摘要很可能如下所示:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es mt"><img src="../Images/0694d429e865f7239c4e9326ccec453b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*yfSmwKfpqYWmUcg3Vqq_yw.png"/></div><figcaption class="mo mp et er es mq mr bd b be z dx translated">Github中的云构建摘要</figcaption></figure><p id="5d5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们用<code class="du kh ki kj kk b">terraform apply</code>做一个我们自己的</strong>(如果你想知道，Github CLI没有办法做到这一点)。</p><h1 id="4b88" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">编写Octokit构建器的脚本</h1><p id="8bf5" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">在乐趣开始之前，<strong class="ih hj">请阅读此</strong>:</p><p id="7c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt;构建器使用<strong class="ih hj"> eval() </strong>来运行您的脚本。确保您没有运行公共PRs的构建器，也没有使用不可信的来源</p><p id="69ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kh ki kj kk b">cloudbuild.yaml</code>将如下图所示。第一步应用terraform(例如，当合并到master中时，或者在手动调用时)。第二步是将这张支票发送给Github，并使其在摘要中可用。</p><pre class="kr ks kt ku fd me kk mf mg aw mh bi"><span id="e270" class="mi lc hi kk b fi mj mk l ml mm">steps:<br/>  - name: 'gcr.io/$PROJECT_ID/terraform'<br/>    entrypoint: 'bash'<br/>    args: [<br/>        '-c',<br/>        'terraform init &amp;&amp; terraform apply -auto-approve -no-color | tee apply.txt'<br/>    ]<br/>  - name: 'gcr.io/$PROJECT_ID/octokit'<br/>    env:<br/>      - "APP_ID=&lt;app-id&gt;"<br/>      - "INSTALLATION_ID=&lt;installation-id&gt;"<br/>      - "INSTALLATION_PK=sm://&lt;link-to-your-secret&gt;"<br/>    args:<br/>      - |-<br/>        const applyContent = fs.readFileSync('./apply.txt', 'utf-8', 'r+');<br/><br/>        await octokit.checks.create({<br/>          owner: '$_GITHUB_USER',<br/>          repo: '$REPO_NAME',<br/>          name: 'terraform-apply',<br/>          head_sha: '$COMMIT_SHA',<br/>          conclusion: 'success',<br/>          output: {<br/>            title: 'terraform apply',<br/>            summary: `\`\`\`\n$${applyContent}\n\`\`\``<br/>          }<br/>        });<br/>substitutions:<br/>  _GITHUB_USER: &lt;your-user-or-org&gt;</span></pre><p id="4f78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">讲道理的评论:</strong></p><ul class=""><li id="676a" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated">该脚本在一个<code class="du kh ki kj kk b">async</code>函数中执行，所以您想在承诺上使用<code class="du kh ki kj kk b">await</code>。(如果您不这样做，该步骤可能会退出，不会执行您的承诺)</li><li id="3f8e" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">您可以直接使用<code class="du kh ki kj kk b">fs</code>模块(已经包含了)并将<code class="du kh ki kj kk b">octokit</code>作为一个初始化的、经过验证的<a class="ae jd" href="https://octokit.github.io/rest.js/v18#usage" rel="noopener ugc nofollow" target="_blank"> Octokit/rest </a>对象</li><li id="64b2" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">如果需要，您可以从Node.js核心库中<code class="du kh ki kj kk b">require</code>任何东西</li></ul><p id="2e35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一旦您将配置</strong>提交到您的存储库中并调用它。您将很快在存储库中看到您的提交的构建，其摘要如下图所示:</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/3633c24bccae9e4c21acd9e209d77d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8z-eQuG5o8GbGXD8IhReMQ.png"/></div></div><figcaption class="mo mp et er es mq mr bd b be z dx translated">构建通过后的Github构建摘要</figcaption></figure><h1 id="ec95" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用文件进行最小化设置</h1><p id="707c" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">如果您不喜欢内联脚本，您可以使用这个代码片段从一个文件运行您的脚本。<strong class="ih hj">构建器检查文件存在的第一个参数</strong>。</p><p id="a085" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法在两种主要情况下是最好的:</p><ul class=""><li id="9093" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated">该脚本很大，您不希望它膨胀构建脚本</li><li id="9ec2" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">您想要多次重复相同的脚本</li></ul><p id="5950" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用<code class="du kh ki kj kk b">env</code>变量对该脚本进行参数化。</p><p id="5f59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je"> &gt;你不能把任何标志或者进一步的参数传入脚本</em>。</p><pre class="kr ks kt ku fd me kk mf mg aw mh bi"><span id="5e28" class="mi lc hi kk b fi mj mk l ml mm">steps:<br/>  - name: 'gcr.io/$PROJECT_ID/octokit'<br/>    env:<br/>      - "APP_ID=&lt;app-id&gt;"<br/>      - "INSTALLATION_ID=&lt;installation-id&gt;"<br/>      - "INSTALLATION_PK=sm://&lt;link-to-your-secret&gt;"<br/>    args:<br/>      - script.js</span></pre><h1 id="87ae" class="lb lc hi bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">奖励:在PRs上运行地形计划</h1><p id="4a19" class="pw-post-body-paragraph if ig hi ih b ii lz ik il im ma io ip iq mb is it iu mc iw ix iy md ja jb jc hb bi translated">如果你来自我之前的关于Github CLI builder的文章，我会留下一个片段，使用Octokit的方法创建一个新的PR评论。请记住:</p><ul class=""><li id="aeaa" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated">确保你正在运行<code class="du kh ki kj kk b">gcr.io/$PROJECT_ID/octokit</code></li><li id="7fa2" class="jy jz hi ih b ii kl im km iq kn iu ko iy kp jc kd ke kf kg bi translated">添加必要的<code class="du kh ki kj kk b">env</code>变量</li></ul><pre class="kr ks kt ku fd me kk mf mg aw mh bi"><span id="6354" class="mi lc hi kk b fi mj mk l ml mm">const planContent = fs.readFileSync('./plan.txt', 'utf-8', 'r+');<br/><br/>await octokit.pulls.createReview({<br/>  owner: '$_GITHUB_USER',<br/>  repo: '$REPO_NAME',<br/>  pull_number: '$_PR_NUMBER',<br/>  event: 'COMMENT',<br/>  body: `&lt;details&gt;<br/>    &lt;summary&gt;Terraform Plan Results&lt;/summary&gt;<br/><br/>  \`\`\`<br/>  $${planContent}<br/>  \`\`\`<br/>  &lt;/details&gt;`<br/>});</span></pre></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="a566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">就是这样，乡亲们！</strong>在云构建中享受全新的Github脚本体验。</p><p id="30a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PS:是的，builder可以用在任何容器-原生CI中(甚至Jenkins)。你只需要找到安全注射<em class="je">的方法。来自Github的pem </em>文件。</p><p id="16c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有任何问题，打我的推特给我</p></div></div>    
</body>
</html>