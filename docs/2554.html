<html>
<head>
<title>Knative Build(Deprecated) → Tekton Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Knative Build(已弃用)→ Tekton管道</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/knative-build-deprecated-tekton-pipelines-34de021178ee?source=collection_archive---------1-----------------------#2022-11-25">https://medium.com/google-cloud/knative-build-deprecated-tekton-pipelines-34de021178ee?source=collection_archive---------1-----------------------#2022-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4aae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在0.8.0版本中，Knative宣布放弃构建组件，转而支持<a class="ae jd" href="https://github.com/tektoncd/pipeline" rel="noopener ugc nofollow" target="_blank"> Tekton管道</a>。随着这一宣布，Tekton Pipelines成为了<a class="ae jd" href="https://github.com/knative/build" rel="noopener ugc nofollow" target="_blank"> Knative Build </a>的技术继承者。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/d5de04aab7f282b15516f737c357d81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8oqZCpgXC4X1Ex4qMTpHA.png"/></div></div></figure><p id="a21e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Knative安装文档(<a class="ae jd" href="https://knative.dev/docs/install/" rel="noopener ugc nofollow" target="_blank">https://knative.dev/docs/install/</a>)也只包括Knative Serving和Eventing，没有提到Build。没有解释为什么Knative Build被弃用，也没有任何关于替代的指导。经过一些研究，我能够找到更多关于弃用的信息，以及我想在这篇文章中分享的迁移路径。</p><p id="d150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GitHub有一个问题(<a class="ae jd" href="https://github.com/knative/build/issues/614" rel="noopener ugc nofollow" target="_blank">https://github.com/knative/build/issues/614</a>)有更多关于弃用原因的细节。反对Knative Build的理由是，为服务构建和推送图像不应该是Knative的核心职责之一，而是由能够在Kubernetes中构建图像的任何项目来分担。</p><p id="520a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">tek ton Pipeline(<a class="ae jd" href="https://github.com/tektoncd/pipeline" rel="noopener ugc nofollow" target="_blank">https://github.com/tektoncd/pipeline</a>)项目源自Knative项目(was <code class="du jq jr js jt b">knative/build-pipeline</code>)，正在增强Knative的构建功能，在Knative奠定的基础之上提供高级CI/CD特性。</p><h1 id="9cb3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是Tekton管道？</h1><p id="6b21" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Tekton Pipelines是一个Kubernetes扩展，它安装并运行在您的Kubernetes集群上。它定义了一组Kubernetes <a class="ae jd" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">定制资源</a>作为构建块，您可以从这些构建块组装CI/CD管道。一旦安装完毕，Tekton管道就可以通过Kubernetes CLI (kubectl)和API调用使用，就像pod和其他资源一样。Tekton是开源的，是<a class="ae jd" href="https://cd.foundation/" rel="noopener ugc nofollow" target="_blank"> CD Foundation </a>的一部分，这是一个<a class="ae jd" href="https://www.linuxfoundation.org/projects/" rel="noopener ugc nofollow" target="_blank"> Linux Foundation </a>项目。</p><p id="f61f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://github.com/tektoncd/pipeline" rel="noopener ugc nofollow" target="_blank"> Tekton Pipelines </a>中，您可以创建简单的一次性任务或更复杂的CI/CD管道。Tekton管道有4个主要原语:</p><ul class=""><li id="bd68" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated"><a class="ae jd" href="https://github.com/tektoncd/pipeline/blob/master/docs/tasks.md" rel="noopener ugc nofollow" target="_blank">任务</a>定义了需要执行一个或多个步骤的工作。</li><li id="fe4b" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jd" href="https://github.com/tektoncd/pipeline/blob/master/docs/resources.md" rel="noopener ugc nofollow" target="_blank"> PipelineResources </a>定义了可以传入和传出任务的工件。</li><li id="542d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jd" href="https://github.com/tektoncd/pipeline/blob/master/docs/taskruns.md" rel="noopener ugc nofollow" target="_blank"> TaskRun </a>使用提供的资源运行您定义的任务。</li><li id="fed2" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jd" href="https://github.com/tektoncd/pipeline/blob/master/docs/pipelines.md" rel="noopener ugc nofollow" target="_blank"> Pipeline </a>定义了按顺序执行的任务列表。</li></ul><p id="d3ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用Tekton管道之前，您需要将其安装在您的Kubernetes集群中。详细的<a class="ae jd" href="https://github.com/tektoncd/pipeline/blob/master/docs/install.md" rel="noopener ugc nofollow" target="_blank">说明</a>在这里，但是很简单:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="7ba5" class="lp jv hi jt b be lq lr l ls lt">kubectl apply -f https://storage.googleapis.com/tekton-releases/latest/release.yaml</span></pre><p id="84e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装后，您可以检查Tekton pods:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="74b7" class="lp jv hi jt b be lq lr l ls lt">kubectl get pods -n tekton-pipelines</span></pre><pre class="lu ll jt lv lw aw lx bi"><span id="a59c" class="ly jv hi jt b fi lz ma l mb lt">NAME                                           READY   STATUS<br/>tekton-pipelines-controller-78c6b3b9f6-9p879   1/1     Running<br/>tekton-pipelines-webhook-7634d5bcc8-pf6x9      1/1     Running</span></pre><h1 id="b7bc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">从Knative Build迁移</h1><p id="1b68" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Tekton实体基于Knative Build的实体，但提供了额外的灵活性和可重用性。简而言之，这些是Knative Build构造的Tekton等价物:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mc"><img src="../Images/cb222178d2f64ebc07208055775d14e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONIHCrgYUh-g1EtVyhMqqg.png"/></div></div></figure><p id="15fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关于从Knative Build迁移到Tekton的基本文档。</p><p id="c7eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，<a class="ae jd" href="https://github.com/tektoncd/catalog" rel="noopener ugc nofollow" target="_blank"> Tekton目录</a>旨在提供一个可重用任务的目录，类似于Knative BuildTemplate repository以前所做的。</p><h1 id="c5c6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用Kaniko构建容器图像</h1><p id="9da8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们看看如何使用Tekton管道构建一个图像并将其推送到Google容器注册中心(GCR)。</p><p id="4a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kaniko是一个在容器或Kubernetes集群中从docker文件构建容器映像的工具。</p><p id="8d4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kaniko不依赖Docker守护进程，完全在用户空间中执行Docker文件中的每个命令。这使得在不能轻松或安全地运行Docker守护进程的环境中构建容器映像成为可能，比如标准的Kubernetes集群。</p><p id="f9bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kaniko的本意是作为一个形象来经营。这使得它成为Tekton的完美工具。此任务也可用于Tekton链，以证明和签名图像。</p><p id="65f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" href="https://hub.tekton.dev/" rel="noopener ugc nofollow" target="_blank">社区中心</a>中的<a class="ae jd" href="https://hub.tekton.dev/tekton/task/kaniko" rel="noopener ugc nofollow" target="_blank"> Kaniko </a>任务构建图像。</p><ol class=""><li id="60c0" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc md ld le lf bi translated">将图像参考添加到<code class="du jq jr js jt b">pipeline.yaml</code>中的<code class="du jq jr js jt b">params</code>部分:</li></ol><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="61d8" class="lp jv hi jt b be lq lr l ls lt">params:  <br/>- name: image-reference   <br/>  type: string</span></pre><p id="0d90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该参数用于添加与容器注册表相对应的标记，您将把图像推送到该注册表中。</p><p id="ef89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.在同一个<code class="du jq jr js jt b">pipeline.yaml</code>文件中创建新的<code class="du jq jr js jt b">build-push</code>任务:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="81eb" class="lp jv hi jt b be lq lr l ls lt">tasks:<br/>...<br/>  - name: build-push<br/>    runAfter: ["fetch-source"]<br/>    taskRef:<br/>      name: kaniko<br/>    workspaces:<br/>    - name: source<br/>      workspace: shared-data<br/>    params:<br/>    - name: IMAGE<br/>      value: $(params.image-reference)</span></pre><p id="2e11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个新任务是指<code class="du jq jr js jt b">kaniko</code>，它将从<a class="ae jd" href="https://hub.tekton.dev/" rel="noopener ugc nofollow" target="_blank">社区中心</a>安装。一个任务有它自己的一组<code class="du jq jr js jt b">workspaces</code>和<code class="du jq jr js jt b">params</code>从在流水线级定义的参数和工作空间传递下来。在这种情况下，工作空间<code class="du jq jr js jt b">source</code>和<code class="du jq jr js jt b">IMAGE</code>的值。</p><p id="5dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.实例化<code class="du jq jr js jt b">build-push</code>任务。将<code class="du jq jr js jt b">image-reference</code>的值添加到<code class="du jq jr js jt b">pipelinerun.yaml</code>中的<code class="du jq jr js jt b">params</code>部分:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="986a" class="lp jv hi jt b be lq lr l ls lt">params:<br/>- name: image-reference<br/>  value: container.registry.com/sublocation/my_app:version</span></pre><p id="196d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用您的注册表的实际标签替换<code class="du jq jr js jt b">container.registry.com/sublocation/my_app:version</code>。您可以设置一个本地注册表用于测试目的。</p><h1 id="b452" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">容器注册认证</h1><p id="5ed4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在大多数情况下，要将映像推送到容器注册中心，您必须首先提供身份验证凭证。</p><ol class=""><li id="e5b6" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc md ld le lf bi translated">使用Docker credential helper设置身份验证，并为您的注册表生成Docker配置文件<code class="du jq jr js jt b">~/.docker/config.json</code>。</li><li id="4e95" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc md ld le lf bi translated">参考GCR ( <a class="ae jd" href="https://cloud.google.com/artifact-registry/docs/docker/authentication" rel="noopener ugc nofollow" target="_blank">谷歌神器注册表</a>)。</li><li id="bff9" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc md ld le lf bi translated">用您的凭证创建一个<a class="ae jd" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes秘密</a>、<code class="du jq jr js jt b">docker-credentials.yaml</code>:</li></ol><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="8f98" class="lp jv hi jt b be lq lr l ls lt">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: docker-credentials<br/>data:<br/>  config.json: efuJAmF1...</span></pre><p id="f3e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jq jr js jt b">config.json</code>的值是base64编码的<code class="du jq jr js jt b">~/.docker/config.json</code>文件。您可以使用以下命令获取该数据:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="1aec" class="lp jv hi jt b be lq lr l ls lt">cat ~/.docker/config.json | base64 -w0</span></pre><p id="3ea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.更新<code class="du jq jr js jt b">pipeline.yaml</code>并添加一个工作空间来挂载凭证目录:</p><p id="1863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在管道级别:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="c25a" class="lp jv hi jt b be lq lr l ls lt">workspaces:<br/>- name: docker-credentials</span></pre><p id="1acd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而在<code class="du jq jr js jt b">build-push</code>任务下:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="da10" class="lp jv hi jt b be lq lr l ls lt">workspaces:<br/>- name: dockerconfig<br/>  workspace: docker-credentials</span></pre><p id="5d56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.通过在<code class="du jq jr js jt b">workspaces</code>下添加一个新条目，在您的<code class="du jq jr js jt b">pipelinerun.yaml</code>文件中实例化新的<code class="du jq jr js jt b">docker-credentials</code>工作空间:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="7f38" class="lp jv hi jt b be lq lr l ls lt">- name: docker-credentials<br/>  secret:<br/>    secretName: docker-credentials</span></pre><h1 id="06e7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">运行您的管道</h1><p id="7274" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">您已经准备好安装任务并运行管道。</p><ol class=""><li id="f7c2" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc md ld le lf bi translated">安装<code class="du jq jr js jt b">git-clone</code>和<code class="du jq jr js jt b">kaniko</code>任务:</li></ol><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="5890" class="lp jv hi jt b be lq lr l ls lt">tkn hub install task git-clone tkn hub install task kaniko</span></pre><p id="a5d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.应用你的Docker凭证的秘密。</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="12f6" class="lp jv hi jt b be lq lr l ls lt">kubectl apply -f docker-credentials.yaml</span></pre><p id="1c91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.应用管道:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="b8ed" class="lp jv hi jt b be lq lr l ls lt">kubectl apply -f pipeline.yaml</span></pre><p id="648c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.创建管道管路:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="4f70" class="lp jv hi jt b be lq lr l ls lt">kubectl create -f pipelinerun.yaml</span></pre><p id="f6c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将每次创建一个具有唯一名称的PipelineRun:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="d9e6" class="lp jv hi jt b be lq lr l ls lt">pipelinerun.tekton.dev/clone-build-push-run-4kgjr created</span></pre><p id="c882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.使用上一步输出中的PipelineRun名称来监视管道执行:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="ca20" class="lp jv hi jt b be lq lr l ls lt">tkn pipelinerun logs  clone-build-push-run-4kgjr -f</span></pre><p id="a412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几秒钟后，输出确认映像已成功构建并推送:</p><pre class="jf jg jh ji fd ll jt lm bn ln lo bi"><span id="b4cd" class="lp jv hi jt b be lq lr l mb lt">[build-push : build-and-push] INFO[0012] Taking snapshot of full filesystem...        <br/>[build-push : build-and-push] INFO[0013] Pushing image to us-east1-docker.pkg.dev/tekton-tests/tektonstuff/docsy:v1 <br/>[build-push : build-and-push] INFO[0029] Pushed image to 1 destinations               <br/><br/>[build-push : write-url] <strong class="jt hj">us-east1-docker.pkg.dev/my-tekton-tests/tekton-samples/docsy:v1</strong></span></pre><p id="94a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如需完整代码示例，请参考此<a class="ae jd" href="https://tekton.dev/docs/how-to-guides/kaniko-build-push/#full-code-samples" rel="noopener ugc nofollow" target="_blank">https://tek ton . dev/docs/how-to-guides/kaniko-build-push/# full-code-samples</a></p><p id="ca97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇博文为您提供了从Knative Build过渡到Tekton Pipelines所需的基础知识。</p></div></div>    
</body>
</html>