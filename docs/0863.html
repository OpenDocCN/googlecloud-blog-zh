<html>
<head>
<title>OpenCensus Importer (sic.)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCensus导入程序(原文如此。)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/opencensus-importer-sic-68855d74c3b5?source=collection_archive---------0-----------------------#2018-12-21">https://medium.com/google-cloud/opencensus-importer-sic-68855d74c3b5?source=collection_archive---------0-----------------------#2018-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1d4a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我有了新的小狗</h2></div><blockquote class="ix iy iz"><p id="6e6a" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj">TL；DR </strong> OpenCensus提供了应用程序源和监控解决方案接收器之间的单向代理。OpenCensus导入程序提供了返回路径。</p></blockquote><p id="136f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我的日子是遛狗、写代码、吃饭和睡觉的快乐结合。这就减少了写博客的时间。我仍然缺乏带走我的故事但不给予太多回报的中等不对称。在我决定是否去其他地方之前，我会在这里写作——尽管不那么频繁。</p><p id="e326" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我的兴趣之一是谷歌的开源<a class="ae ka" href="http://opencensus.io" rel="noopener ugc nofollow" target="_blank"> OpenCensus </a>项目。我想我对监控解决方案感兴趣，因为我喜欢测量“事物”。使用像OpenCensus这样的解决方案，可以让产生数据的东西(您的应用程序)以一种不可知的监控方式来产生数据。编写一次您的监控代码，并且确信，当DevOps想要监控它时，他们将能够使用他们首选的监控系统来这样做；Prometheus、Datadog、Stackdriver (AWS|Google)、AWS和Azure的自主开发的解决方案都受到支持，并且正在添加更多解决方案。</p><p id="c7b8" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">谷歌的<a class="ae ka" href="http://github.com/google/trillian" rel="noopener ugc nofollow" target="_blank">万亿</a>项目支持普罗米修斯。在试图为Trillian<a class="ae ka" href="https://github.com/google/trillian" rel="noopener ugc nofollow" target="_blank">编写(需要更新:</a><a class="ae ka" href="https://gist.github.com/DazWilkin/cb0592ff63fbb4fed1c473e7aeb5a3a5" rel="noopener ugc nofollow" target="_blank">链接</a>)open census解决方案时，我无法通过Trillian的特定监控测试。这是因为，Trillian的监控界面假定能够读取测量值并打开Census Exporters(！)不允许从监控系统读取数值。</p><p id="7127" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">而且，由于OpenCensus是一个支持任意导出器的可插拔解决方案，每个服务也需要一个读取值的解决方案。</p><p id="9c63" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我的用处？)解决方案是考虑OpenCensus Importers(原文如此。)并反映导出器的接口，以查看读取值是否实用和有用:</p><p id="9272" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><a class="ae ka" href="https://github.com/DazWilkin/opencensus-testing" rel="noopener ugc nofollow" target="_blank">https://github.com/DazWilkin/opencensus-testing</a></p><h2 id="8b37" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">工作</h2><p id="c122" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">OpenCensus涵盖统计|监测和追踪。下文仅涉及统计|监控功能。</p><p id="913b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">OpenCensus的命名是精确而独特的。总之，至少有一个出口商已注册，例如Stackdriver。然后定义多个度量。这些要么是整型，要么是浮点型。每个度量可以与一个或多个视图相关联。视图表示发送给导出器的数据。这是我测试中代码的快照:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8540" class="kb kc hi lg b fi lk ll l lm ln">sd, err := stackdriver.<strong class="lg hj">NewExporter</strong>(stackdriver.Options{<br/>  MetricPrefix: "test2",<br/>})<br/>if err != nil {<br/>  glog.Fatal(err)<br/>}<br/><br/>defer sd.Flush()</span><span id="47c4" class="kb kc hi lg b fi lo ll l lm ln">view.<strong class="lg hj">RegisterExporter</strong>(sd)</span><span id="0707" class="kb kc hi lg b fi lo ll l lm ln">view.SetReportingPeriod(60 * time.Second)</span><span id="3f84" class="kb kc hi lg b fi lo ll l lm ln">prefix := "181221"<br/>separator := "_"<br/>name := "counter0"</span><span id="52c9" class="kb kc hi lg b fi lo ll l lm ln">prefixedName := prefix + separator + name<br/>measure := <strong class="lg hj">stats.Float64</strong>(prefixedName, "Testing", "1")</span><span id="e08b" class="kb kc hi lg b fi lo ll l lm ln">...</span><span id="7f13" class="kb kc hi lg b fi lo ll l lm ln">v := <strong class="lg hj">&amp;view.View</strong>{<br/>  Name:        prefixedName,<br/>  Measure:     measure,<br/>  Description: "Testing",<br/>  Aggregation: view.Sum(),<br/>  TagKeys:     tagKeys,<br/> }<br/>if err := view.<strong class="lg hj">Register</strong>(v); err != nil {<br/>  glog.Fatal(err)<br/>}</span></pre><p id="8ff2" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在下面的测试用例(代码)中，我使用了一个名为<code class="du lp lq lr lg b">counter0</code>的float64度量。和一个同名的视图(尽管为了清楚起见，我可能应该给它起一个不同的名字)。该视图通过对值求和来聚合使用该度量进行的度量。要使用测量进行测量:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="c1ec" class="kb kc hi lg b fi lk ll l lm ln">stats.Record(ctx, measure.M(val))</span></pre><blockquote class="ix iy iz"><p id="9713" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong>就像森林中倒下的树木一样，如果没有视图来表示和导出它们，度量就不会被听到(被丢弃)。</p></blockquote><p id="5723" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">下面是从上面的“度量”中读取值的导入器代码:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="85c0" class="kb kc hi lg b fi lk ll l lm ln">sdIn, err := importer_stackdriver.<strong class="lg hj">NewImporter</strong>(stackdriver.Options{<br/>  MetricPrefix: "test2",<br/> })</span><span id="ee48" class="kb kc hi lg b fi lo ll l lm ln">importer_view.<strong class="lg hj">RegisterImporter</strong>(sdIn)</span><span id="f51b" class="kb kc hi lg b fi lo ll l lm ln">iv := &amp;<strong class="lg hj">view.View</strong>{<br/>  Name:       prefixedName,<br/>  LabelNames: labelNames,<br/>}<br/>if err := view.<strong class="lg hj">Register</strong>(iv); err != nil {<br/>  glog.Fatal(err)<br/>}</span></pre><blockquote class="ix iy iz"><p id="bc60" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jd hj"> NB </strong>进口商使用视图而非度量，因为出口商视图是监控系统的接口。</p></blockquote><p id="9734" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">希望您能看到导出器|写入器和导入器|读取器代码之间的对称性。</p><p id="3c1e" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">下面是测试代码:</p><figure class="lb lc ld le fd ls"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="9ddd" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">对我的包命名表示歉意。</p><p id="3b22" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">该规范要求:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="174a" class="kb kc hi lg b fi lk ll l lm ln">export PROJECT=[[YOUR-PROJECT]]<br/>export GOOGLE_APPLICATION_CREDENTIALS=[[YOUR-SERVICE-ACCOUNT-KEY]]</span></pre><p id="59c1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><code class="du lp lq lr lg b">PROJECT</code>与您的Stackdriver工作区相关联。服务账户必须有<code class="du lp lq lr lg b">roles/monitoring.viewer</code>和<code class="du lp lq lr lg b">roles/monitoring.metricWriter</code>或<code class="du lp lq lr lg b">roles.monitoring.editor</code>。</p><p id="f08d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">您可以使用以下配置在Visual Studio代码中进行调试:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2a0f" class="kb kc hi lg b fi lk ll l lm ln">{<br/>  "name": "[[YOUR-PROJECT]]",<br/>  "type": "go",<br/>  "request": "launch",<br/>  "mode": "auto",<br/>  "program": "${fileDirname}",<br/>  "env": {<br/>    "GOOGLE_APPLICATION_CREDENTIALS":"[[YOUR-SERVICE-ACCOUNT-KEY",<br/>    "PROJECT":"[[YOUR-PROJECT]]"<br/>  },<br/>  "args": []<br/>}</span></pre><p id="a905" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">顺便说一下，一个隐藏的优点是，您也可以在Visual Studio代码中运行测试，但是您需要一种方法在用户或(最好)工作区设置中指定上述内容:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="763e" class="kb kc hi lg b fi lk ll l lm ln">{<br/>  "go.testEnvVars": {<br/>    "GOOGLE_APPLICATION_CREDENTIALS":"[[YOUR-SERVICE-ACCOUNT-KEY]]",<br/>    "PROJECT":"[[YOUR-PROJECT]]"<br/>  }<br/>}</span></pre><h2 id="cf8f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">结论</h2><p id="c2e2" class="pw-post-body-paragraph ja jb hi jd b je kw ij jg jh kx im jj jx ky jm jn jy kz jq jr jz la ju jv jw hb bi translated">这是测试的结果。该测试使用Stackdriver作为导出器来创建OpenCensus度量和视图(Sum)。测试运行10分钟。每10秒钟，记录一次随机浮动64。每隔30秒，Stackdriver将被轮询一次，以获取最新的值。因为OpenCensus对记录的测量值求和，所以编写器输出随机值和累计值。这个总数可以与Stackdriver的值进行比较:</p><figure class="lb lc ld le fd ls"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="47ef" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">您可以在上面看到，在Stackdriver开始报告收到测量值之前有一个小的延迟。我已经编辑了输出来分隔读数。对于每个读取值，您可以找到写入总数命中它的位置。我添加了“←”来帮助您识别匹配项。</p><p id="2065" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这是使用Google APIs Explorer提取的时间序列。您可以在这里看到重复的读取值:</p><figure class="lb lc ld le fd ls er es paragraph-image"><div class="er es lv"><img src="../Images/a061ec0bd8c2ea38112daf69a19470e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*dACCdABwVncgJHnPugKhsw.png"/></div></figure><p id="1cae" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这是Stackdriver指标。我无法解释这个图表是如何表示上面显示的数据的(我会做出解释:</p><figure class="lb lc ld le fd ls er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/d5775d223a93da1a6e1ae01927dcf32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1N72BwZRCw2ttsh49uSqg.png"/></div></div></figure><p id="c3e4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">现在，我必须去遛狗了。</p><p id="d580" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated"><strong class="jd hj">更新时间:2012年12月28日</strong></p><p id="29ad" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">我添加了一个Datadog导入器。</p><p id="5ed3" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">GitHub repo上的<a class="ae ka" href="https://github.com/dazwilkin/opencensus-testing/" rel="noopener ugc nofollow" target="_blank">自述文件</a>中更详细地描述了Stackdriver和Datadog的实现及其示例。</p><h2 id="af89" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jx km kn ko jy kp kq kr jz ks kt ku kv bi translated">弗雷迪</h2><figure class="lb lc ld le fd ls er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es md"><img src="../Images/875ef167b12c587a1b81099e666c2604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEsDtK4s_lwiNs3YsATSGA.jpeg"/></div></div></figure></div></div>    
</body>
</html>