<html>
<head>
<title>Polling using Task Queues on App Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用应用程序引擎上的任务队列进行轮询</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-do-polling-using-google-task-queues-7fe44421fd3a?source=collection_archive---------1-----------------------#2018-07-08">https://medium.com/google-cloud/how-to-do-polling-using-google-task-queues-7fe44421fd3a?source=collection_archive---------1-----------------------#2018-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d19c573bf84a2be83c3a6f28db131756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBq5xHY6b7uPJayZOCFqHw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">通过<a class="ae iu" href="https://blog.cloud-elements.com/webhooks-vs-polling-youre-better-than-this" rel="noopener ugc nofollow" target="_blank"> Webhooks vs轮询</a></figcaption></figure><p id="285d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">轮询是从产生一系列事件和更新的数据源获取数据的最传统的方式。我不是一个大粉丝，它有许多缺点——我宁愿通过webhooks推送数据——但有时这是不可避免的，也是唯一可用的选择。</p><p id="4fd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一篇简短的文章，展示了在App Engine上运行的应用程序上使用任务队列实现轮询的一种方法。</p><p id="9faf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个想法非常简单:任务链。下面的例子使用Python运行时的<a class="ae iu" href="https://cloud.google.com/appengine/articles/deferred" rel="noopener ugc nofollow" target="_blank">延迟库</a>来实现它:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="5361" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码片段非常简单，我会尽量详细解释。一切从<strong class="ix hj">start _ polling</strong>(1–3)开始。它基本上获取当前状态(被监视的资源/实体)并使用<strong class="ix hj"> deferred.defer </strong>函数将新任务排队。该函数将创建一个新任务，该任务将由<strong class="ix hj"> poll_for_changes </strong>根据单独的请求进行处理。状态对象将被序列化，它必须是可选择的。</p><p id="ebb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“轮询循环”在<strong class="ix hj">poll _ for _ changes</strong>(5–12)函数中实现。它获取新状态(再次使用<strong class="ix hj"> get_state </strong>)，将其与给定状态进行比较，验证其是否发生变化。如果是肯定的，它通知相关方。然后，在检查它是否应该继续轮询之后，它将一个新任务排入队列。秘密在于<strong class="ix hj"> _countdown </strong>参数，该参数以秒为单位指定任务运行的时间。在本例中，我们每15秒检查一次状态变化，直到<strong class="ix hj"> should_keep_polling </strong>返回true。</p><p id="c2b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！希望这个例子对其他人有用。</p><p id="9f86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">重要提示:</strong>请注意，长时间的轮询会显著增加您的实例时间，从而增加您的成本。明智地使用它。</p></div></div>    
</body>
</html>