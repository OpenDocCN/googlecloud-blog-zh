<html>
<head>
<title>Google Trillian for Noobs (1a)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Trillian for Noobs (1a)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-trillian-for-noobs-1a-c87a78e5e585?source=collection_archive---------1-----------------------#2019-07-03">https://medium.com/google-cloud/google-trillian-for-noobs-1a-c87a78e5e585?source=collection_archive---------1-----------------------#2019-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dc97" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">失踪手册系列</h2></div><p id="8caf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上周，我记录了我所希望的最简单的崔莉恩人格。这是一个临时的帖子，因为我意识到我的示例中遗漏了一些重要的功能，一个包含证明:一些指定数据是透明日志的一部分的有效的无可争议的证据。</p><h2 id="d02a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">设置</h2><p id="30aa" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">您将需要我在之前的帖子中描述的数据库和Trillian服务器。</p><h2 id="cdca" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">基本++人格</h2><p id="d06e" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">这次，请克隆<code class="du ku kv kw kx b">inclusion-proof</code>:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="90b0" class="ju jv hi kx b fi lg lh l li lj">git clone \<br/>--single-branch \<br/>--branch=inclusion-proof \<br/><a class="ae jt" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:DazWilkin/simple-trillian-log-1.git</span></pre><p id="1743" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="b15f" class="ju jv hi kx b fi lg lh l li lj">GO111MODULES=on \<br/><strong class="kx hj">GOPROXY=</strong><a class="ae jt" href="https://proxy.golang.org" rel="noopener ugc nofollow" target="_blank"><strong class="kx hj">https://proxy.golang.org</strong></a> \<br/>go run github.com/DazWilkin/simple-trillian-log-1 \<br/>--tlog_endpoint=:8090 \<br/>--tlog_id=${LOGID}</span></pre><blockquote class="lk ll lm"><p id="a5fa" class="ix iy ln iz b ja jb ij jc jd je im jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">非常有趣的是，Go团队正在评估Go模块的模块镜像。镜像不仅打算为下载提供一个快速代理，而且它利用了<code class="du ku kv kw kx b">go.sum</code>的散列来提供包的可验证性。非常非常有趣的是，这个解是一个Trillian人格；-)</p></blockquote><p id="442a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该会看到类似于以下内容的输出:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="bb88" class="ju jv hi kx b fi lg lh l li lj">[main] Entered<br/>[main] Establishing connection w/ Trillian Log Server [:8090]<br/>[main] Creating new Trillian Log Client<br/>[main] Creating Server using LogID [5201727448936460865]<br/>[server] Creating<br/>[main] Creating a 'Thing' and something 'Extra'<br/>[thing:new] Creating: [2019-07-03T13:01:34-07:00] Thing<br/>[extra:new] Creating: Extra<br/>[main] Submitting it for inclusion in the Trillian Log<br/>[main] Awaiting Inclusion (Proof) in the Trillian Log<br/>[main] Retrieving it from the Trillian Log<br/>[main:get] Entered<br/>[server:get] Entered<br/>[thing:marshal] Marshaling: [2019-07-03T13:01:34-07:00] Thing<br/>[server:get] hash: 0800eb65...<br/>[main:wait] Entered<br/>[server:wait] Entered<br/>[main:put] Entered<br/>[server:put] Entered<br/>[thing:marshal] Marshaling: [2019-07-03T13:01:34-07:00] Thing<br/>[extra:marshal] Marshaling: Extra<br/>[server:wait] Root hash: 68f7634b...<br/>[main:get] Status:ok<br/>[main:get] Done<br/>[thing:marshal] Marshaling: [2019-07-03T13:01:34-07:00] Thing<br/><strong class="kx hj">[main:wait]</strong> rpc error: code = NotFound desc = No leaf found for hash: 0800eb65... in tree size 39<br/>[main:wait] Status:<br/>[main:wait] Sleeping<br/>[main:put] Status:ok<br/>[main:put] Done<br/>[server:wait] Entered<br/>[server:wait] Root hash: 6c7a5673...<br/>[thing:marshal] Marshaling: [2019-07-03T13:01:34-07:00] Thing<br/>[main] proof[0],hash[0] == 9dc9b7d5...<br/>[main] proof[0],hash[1] == 384214f3...<br/>[main] proof[0],hash[2] == 36e35370...<br/>[main] proof[0],hash[3] == 880846d5...<br/><strong class="kx hj">[main:wait]</strong> Status:ok<br/>[main:wait] Done<br/>[main] Done</span></pre><p id="1930" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码试图镜像日志的使用。在<code class="du ku kv kw kx b">main.go</code>有3个戈罗廷。其中之一——<code class="du ku kv kw kx b">put</code>——尝试向日志中异步添加一个<code class="du ku kv kw kx b">Thing</code>。另一个— <code class="du ku kv kw kx b">get</code> —尝试从日志中异步获取<code class="du ku kv kw kx b">Thing</code>。第三个— <code class="du ku kv kw kx b">wait</code> —尝试对添加到日志中的<code class="du ku kv kw kx b">Thing</code>执行包含证明。在<code class="du ku kv kw kx b">put</code>成功之前<code class="du ku kv kw kx b">get</code>和<code class="du ku kv kw kx b">wait</code>不能继续。更重要的是，<code class="du ku kv kw kx b">wait</code>直到能够计算包含证明才能成功。因此，在上面的日志输出中，虽然<code class="du ku kv kw kx b">get</code>第一次尝试成功，但是<code class="du ku kv kw kx b">wait</code>失败，休眠一秒钟，重试成功。</p><h2 id="4b50" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">Trillian客户端</h2><p id="2e98" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">当我询问实现inclusion proof的细节时，Trillian团队向我介绍了Trillian Client ( <code class="du ku kv kw kx b">trillian/client</code>)包。我没有意识到它的存在:-)本示例中的代码使用机器生成的(来自Trillian的protobufs) gRPC客户端。然而，Trillian客户端是在此之上的一个抽象，它还包括包含证明功能。在您的代码中，我建议您使用<code class="du ku kv kw kx b">trillian/client</code>而不是原始的gRPC客户端。</p><h2 id="d025" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论</h2><p id="48f0" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我们现在有了一个客户端(<code class="du ku kv kw kx b">main.go</code>)角色，它与一个万亿日志交互来添加、检索和证明<code class="du ku kv kw kx b">Things</code>的存在。在下一个故事中，我们将把这个客户机变成一个服务器，使用gRPC公开它，并生成一个(测试)客户机来使用它。决赛中(？)贴，我计划(！)来尝试Rust，并为这个角色生成一个Rust客户端。这实际上不是Trillian，但希望它能帮助您了解如何使用该解决方案。</p><p id="3134" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>