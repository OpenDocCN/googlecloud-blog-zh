<html>
<head>
<title>An app modernization story — Part 3 (Containerize &amp; Redeploy)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用程序现代化故事—第3部分(容器化和重新部署)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/an-app-modernization-story-part-3-containerize-redeploy-223b2be2c807?source=collection_archive---------1-----------------------#2020-02-12">https://medium.com/google-cloud/an-app-modernization-story-part-3-containerize-redeploy-223b2be2c807?source=collection_archive---------1-----------------------#2020-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" rel="noopener" href="/google-cloud/an-app-modernization-story-part-1-prototype-6a11398f6e7e"> part 1 </a>中，我谈到了最初的app及其挑战。在<a class="ae jd" rel="noopener" href="/google-cloud/an-app-modernization-story-part-2-lift-shift-7a3740f22860">第2部分</a>中，我谈到了向云的提升&amp;转变，带来了一些意想不到的好处。在本系列的第3部分中，我将讨论我们如何转变我们的纯Windows。NET框架app到容器化的多平台。NET Core app以及我们一路走来获得的巨大收益。</p><h2 id="78fa" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">为什么？</h2><p id="a49d" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">最初基于Windows VM的云设置为我们提供了良好的服务，在大约2年的时间里(从2017年初到2019年初)，问题很少。2019年初，我们想再次重温架构。这主要是由技术领域的进步推动的，即:</p><ol class=""><li id="b74a" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><strong class="ih hj">。NET Core，</strong>的模块化和现代化版本。NET框架变得非常流行。这是我们在开发下一代应用时必须考虑的问题。</li><li id="298e" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">Windows:我们对Windows的依赖严重限制了我们部署应用的空间。我们希望打破这种依赖，以释放更多的部署选项。</li><li id="c114" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">容器和围绕它们的项目如Kubernetes也变得非常受欢迎。我们想看看我们的应用程序是否可以容器化，并可能部署到GKE。</li><li id="1736" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">成本</strong>:我们希望避免Windows许可的成本以及在计算引擎上始终运行2个虚拟机的成本。</li></ol><h2 id="85c9" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">。网络核心</h2><p id="6021" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我们的首要任务是看看这个应用程序是否可以运行。网芯。我最初预订了一个周末来调查和移植应用程序。网芯。我原以为它需要在许多地方进行重大的重写。</p><p id="7a15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在一个周六的早上开始调查，到午饭时间，我已经有了运行这个应用程序的基础。网芯2.2。我很惊讶只用了半天时间。微软有很好的移植文档。NET框架到。NET Core )和类似<em class="ks">可移植性分析器</em>的工具，看看你的应用程序是否可以移植，以及<em class="ks"> dotnet try-convert </em>工具，以实际转换应用程序。</p><p id="7a48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不再依赖工具，而是简单地将我们的项目复制/粘贴到新的。NET核心项目，并让它们一个接一个地工作。这主要包括遵循。网核心风格的东西，寻找新的。NET核心版本的库，最后移植测试以确保一切正常。我们很幸运，这个应用程序很简单，相对模块化，有很好的测试覆盖率和所有的NuGet依赖项。NET核心版本。</p><h2 id="c42f" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">容器化(Linux与Windows)</h2><p id="2956" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我们的主要动机。NET Core移植是为了能够在Docker上的Linux容器中运行应用程序。如果我们这样做，不仅会打破我们对Windows的依赖，还能让我们在Windows服务器虚拟机之外部署应用。</p><p id="0126" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器化有它自己的挑战，特别是如果你不太熟悉Docker的复杂性(这里有一个<a class="ae jd" href="https://www.softwaredeveloper.blog/multi-project-dotnet-core-solution-in-docker-image" rel="noopener ugc nofollow" target="_blank">例子</a>)但是对于我们的应用来说，遵循微软的基本图像和文档是相对简单的。</p><p id="be7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于Windows容器的说明</strong>。当时，有Windows容器，但谷歌云对它们的支持不多。这就是为什么我们认为尝试移植到是个好主意。NET核心，并使应用程序在Linux上工作。在由于某些Windows依赖而无法实现的情况下，Windows容器现在在Google Kubernetes引擎(GKE)上得到支持。这是一个可行的选择，开始获得容器的好处，而不需要进行大的重写。</p><h2 id="4c94" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">应用引擎与谷歌Kubernetes引擎(GKE)</h2><p id="a82b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">一旦我们的应用程序在容器中运行，是时候从Windows服务器虚拟机转移到Linux和容器友好的环境中了。我们有两个主要选择:应用引擎(Flex)和GKE。最终，我们决定使用App Engine，主要是因为:</p><ol class=""><li id="6e08" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><strong class="ih hj"> Kubernetes复杂性</strong>:如果你有许多需求不同的微服务，并且你想以细粒度的方式单独管理它们，那么Kubernetes是一个很好的选择。我们不认为Kubernetes的复杂性在我们的单块应用程序中是合理的。</li><li id="e99b" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj"> App Engine特性</strong>:这是一个部署到App Engine的单一命令，默认有2个实例，无需任何配置就能自动缩放，以及修订和流量分流等非常有用的特性。</li></ol><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es kt"><img src="../Images/cd03d01feaf23b1fa50850db1c5cda34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*T52s2fyEbXEScJATXNOCWA.png"/></div></figure><p id="c6f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不仅摆脱了Windows(终于！)，但我们也保留了计算引擎的冗余/负载平衡功能，但在应用引擎上的麻烦要少得多。</p><p id="4bcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，基于应用引擎的解决方案在某些方面并不理想:</p><ol class=""><li id="794e" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">基于虚拟机:应用引擎(Flex)应用仍在虚拟机上运行。当然，大部分时间你不必看到或管理这些虚拟机，它们基于Linux很好，但你不能像真正的无服务器平台一样完全忽略它们</li><li id="6ceb" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">定价:由于你在虚拟机上运行，即使你的应用没有被使用，你也要像虚拟机一样被计费(每秒)。</li><li id="3d4b" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">缓慢的部署:定制映像部署对我们来说太慢了(长达10分钟),影响了我们的开发周期。</li></ol><h2 id="7b5c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">经验教训</h2><p id="f63b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在应用程序的这一阶段有许多变化和经验教训:</p><ol class=""><li id="feab" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><strong class="ih hj">为了明显的好处而重构</strong>:我们几乎有2年没有重构应用了，因为没有明显的好处。只是在那之后。NET Core成为主流，多平台和容器化提供了更好、更便宜的部署选项，其好处超过了对Windows的依赖。</li><li id="812e" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">扎实的功能测试至关重要</strong>:我们的端口要。NET Core之所以成功，是因为我们有可靠的功能测试作为依据。没有他们，我不认为我们会如此自信地完成主要的重构。</li><li id="69d3" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">项目组织比你想象的更重要</strong>:当你需要重构的时候，你如何组织你的解决方案，你的项目，你的库，你的包会有很大的不同。因为我们已经很好地组织了具有明确依赖关系的项目，所以我们能够将它们一个接一个地移植到。网芯。</li><li id="19f0" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">没有灵丹妙药</strong>:部署到应用引擎(Flex)解决了我们的主要问题(Windows依赖性)，但它并没有解决所有问题(基于虚拟机的定价)。它还引入了其他问题(部署缓慢)。重要的是要记住，没有完美的解决方案，一切都是妥协。</li></ol><h2 id="8016" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">然后</h2><p id="773e" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">消除对Windows的依赖是我们应用程序这一阶段的主要成就。然而，我们的应用程序仍然是运行在虚拟机上的单一整体。在本系列的下一篇也是最后一篇文章中，我将讨论我们如何通过云运行迁移到无服务器微服务架构。</p></div></div>    
</body>
</html>