<html>
<head>
<title>Parallel executions with Google Workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google工作流的并行执行</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/parallel-executions-with-google-workflows-3a16f8fee0eb?source=collection_archive---------0-----------------------#2021-02-22">https://medium.com/google-cloud/parallel-executions-with-google-workflows-3a16f8fee0eb?source=collection_archive---------0-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/14a1dd0791358e4096521e7696e56112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkkfyyZiSSj1D7znjUE9Sw.png"/></div></div></figure><p id="fd05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云组件有用且强大。然而，<strong class="is hj">它们都与其他的</strong>断开连接，当你想要部署一个完整的管道时，<strong class="is hj">你需要把它们粘在一起</strong>。你可以用PubSub和Cloud函数来实现。<br/>然而，它很快<strong class="is hj">变成了一个有很多主题和功能的意大利面设计</strong>。有一个<strong class="is hj">集中的地方来查看、管理和配置</strong>您的管道工作流程可能会很棒！</p><h1 id="d212" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">谷歌工作流程</h1><p id="e59f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">谷歌工作流程在这里进行。它已于2020年夏季在Cloud Next on Air上宣布，并于2021年1月开始正式上市。这是一个完全托管的解决方案，采用按使用付费的模式<strong class="is hj">。这是Cloud Composer的一个更轻便的<em class="kr">(也非常便宜的)</em>解决方案，基于Apache Airflow。对于很多用例来说已经足够了，而且<strong class="is hj">对于未来</strong>来说非常有前途。</strong></p><p id="add9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ks kt ge" href="https://medium.com/u/431147437aeb?source=post_page-----3a16f8fee0eb--------------------------------" rel="noopener" target="_blank"> Guillaume Laforge </a>(谷歌云开发者倡导者)已经分享了<a class="ae ku" rel="noopener" href="/google-cloud/day-1-with-cloud-workflows-your-first-step-to-hello-world-4b545064759e">他的工作流之旅</a>。他们和<a class="ks kt ge" href="https://medium.com/u/6444b44155fa?source=post_page-----3a16f8fee0eb--------------------------------" rel="noopener" target="_blank"> Mete Atamel </a>(也是谷歌云开发者倡导者)一起发布了<a class="ae ku" href="https://cloud.google.com/blog/topics/developers-practitioners/orchestrating-pic-daily-serverless-app-workflows" rel="noopener ugc nofollow" target="_blank">一篇很棒的博客文章</a>。<br/>所以<strong class="is hj">主题已经被很好的覆盖和记录了</strong>。</p><blockquote class="kv"><p id="231b" class="kw kx hi bd ky kz la lb lc ld le jn dx translated">然而，有一个缺失的部分:工作流中并行化步骤的能力。</p></blockquote><h1 id="588b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl bi translated">实验并行化</h1><p id="272b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我参与了Alpha项目，来自测试人员<strong class="is hj">的最大需求</strong>之一是调用的并行化。它已经被推到了开发团队的最高优先级。然而，<strong class="is hj">今天它还没有完全实现</strong>，我们只有<strong class="is hj">一个可以使用的实验特性</strong>:执行图<a class="ae ku" href="https://cloud.google.com/workflows/docs/reference/stdlib/experimental.executions/map" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="66c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个组件中，您需要引用</p><ul class=""><li id="e83b" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated"><strong class="is hj">您想要调用的工作流程ID </strong>。<em class="kr">我将称之为“可调用工作流”</em></li><li id="b89c" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">一系列的争论。数组中的每个条目都是对<em class="kr">“可调用工作流”</em>的并行调用</li><li id="d1ef" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated"><em class="kr">如果“可调用工作流”不在同一个区域和/或项目中，您也可以指定位置和项目ID</em></li></ul><p id="573a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以想象，通过设计，有<strong class="is hj"> 2【限制】</strong></p><ol class=""><li id="f48d" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn lw lo lp lq bi translated">您必须<strong class="is hj">创建另一个<em class="kr">可调用的工作流</em> </strong>才能使用执行图。你不能直接调用你想要的API。</li><li id="8213" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn lw lo lp lq bi translated">您必须使用<strong class="is hj">相同的<em class="kr">可调用工作流</em> </strong> <em class="kr">，</em>只是每个并行调用的参数不同。您不能并行化不同的<em class="kr">可调用工作流</em>，自定义参数总是相同的。</li></ol><p id="7343" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，这不再是一个限制，参见<strong class="is hj"> <em class="kr">高级工作流程</em> </strong>部分查看解决方法。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="32ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，让我们先试一试。</p><h1 id="155c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">首次并行执行</h1><p id="ea67" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为了测试执行的并行性，我们需要<strong class="is hj">执行一个花费或多或少时间的调用</strong>。<em class="kr">在现实世界用例中，你可以想象</em> <strong class="is hj"> <em class="kr">几个BigQuery查询并行</em> </strong> <em class="kr">，每个查询都有不同的执行时间。</em> <br/>然后我们需要构建一个<em class="kr">可调用的工作流</em>来使用这个应用<br/>，最后创建一个具有执行图实验特性的工作流</p><h2 id="b5ca" class="me jp hi bd jq mf mg mh ju mi mj mk jy jb ml mm kc jf mn mo kg jj mp mq kk mr bi translated">部署去瞌睡应用程序</h2><p id="428b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为了等待更多或更少的时间，我创建了一个简单的<strong class="is hj"> Go应用程序，它根据提供的查询参数</strong> a <code class="du ms mt mu mv b">w</code>(以秒为单位)休眠。</p><p id="60f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在<a class="ae ku" href="https://github.com/guillaumeblaquiere/parallel-workflow" rel="noopener ugc nofollow" target="_blank"> Github库找到它。</a>克隆它并运行这个命令</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="108d" class="me jp hi mv b fi ne nf l ng nh">gcloud beta run deploy --source=. --region=us-central1 \<br/>  --platform=managed --allow-unauthenticated sleepy-app</span></pre><p id="099f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">获取部署结束时提供的云运行服务URL。</em></p><h2 id="7c02" class="me jp hi bd jq mf mg mh ju mi mj mk jy jb ml mm kc jf mn mo kg jj mp mq kk mr bi translated">创建可调用的工作流</h2><p id="1fa0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这个可调用的工作流非常简单。它<strong class="is hj">使用参数</strong>中提供的参数调用云运行服务(此处名称为<code class="du ms mt mu mv b">wait</code>)并打印结果。</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="73cb" class="me jp hi mv b fi ne nf l ng nh">main:<br/>  params: [args]<br/>  steps:<br/>  - callSleepyApp:<br/>      call: http.get<br/>      args:<br/>        url: &lt;SLEEPY-APP URL&gt;<br/>        query:<br/>          w: ${args.wait}<br/>      result: result<br/>  - returnOutput:<br/>      return: ${result}</span></pre><p id="2f57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">用云运行服务URL </em>替换 <code class="du ms mt mu mv b"><em class="kr">&lt;SLEEPY-APP URL&gt;</em></code> <em class="kr"/></p><p id="e7c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和部署工作流</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="32f5" class="me jp hi mv b fi ne nf l ng nh">gcloud workflows deploy --source=workflow/run-long-process.yaml \<br/>     --location=us-central1 run-long-process</span></pre><p id="e5e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">在GitHub资源库中，工作流文件都在</em> <code class="du ms mt mu mv b"><a class="ae ku" href="https://github.com/guillaumeblaquiere/parallel-workflow/tree/main/workflow" rel="noopener ugc nofollow" target="_blank"><em class="kr">workflow</em></a></code> <a class="ae ku" href="https://github.com/guillaumeblaquiere/parallel-workflow/tree/main/workflow" rel="noopener ugc nofollow" target="_blank"> <em class="kr">目录下</em> </a> <em class="kr">。根据您的项目结构调整命令</em></p><h2 id="87a0" class="me jp hi bd jq mf mg mh ju mi mj mk jy jb ml mm kc jf mn mo kg jj mp mq kk mr bi translated">并行执行工作流</h2><p id="8647" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">最后是执行图。如上所述，您需要<strong class="is hj">的<em class="kr">可调用工作流</em> ID(此处为</strong> <code class="du ms mt mu mv b"><strong class="is hj">run-long-process</strong></code> <strong class="is hj">)并提供正确的参数。</strong></p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="9f95" class="me jp hi mv b fi ne nf l ng nh">main:<br/>  steps:<br/>  - parallel-executor:<br/>      call: experimental.executions.map<br/>      args:<br/>        workflow_id: run-long-process<br/>        arguments: [{"wait":5},{"wait":10},{"wait":15}]<br/>      result: result<br/>  - returnOutput:<br/>      return: ${result}</span></pre><p id="0cd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和部署工作流</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="3da6" class="me jp hi mv b fi ne nf l ng nh">gcloud workflows deploy --source=workflow/parallel-executor.yaml \<br/>     --location=us-central1 parallel-executor</span></pre></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="07d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以通过UI或CLI测试它</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="6bf7" class="me jp hi mv b fi ne nf l ng nh">gcloud workflows execute parallel-executor</span></pre><p id="6b1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，您可以看到<strong class="is hj">按照您在参数</strong>中定义的顺序获得了每个调用的结果数组。<em class="kr">无论哪一个先结束，在结果中都会尊重论证顺序</em></p><h1 id="9e94" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">高级工作流</h1><p id="fd7f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">实际上，它使用起来很简单，但并不完美。如前所述，对于高级用例，您可能会有一些<strong class="is hj">限制，我提出了解决方法</strong>。</p><h2 id="6c81" class="me jp hi bd jq mf mg mh ju mi mj mk jy jb ml mm kc jf mn mo kg jj mp mq kk mr bi translated">并行调用不同的URL</h2><p id="1cc4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">一个用例是<strong class="is hj">并行调用不同URL的能力</strong>。对此，一个解决方案是<strong class="is hj">将API调用包装在一个带有适当参数的“<em class="kr">可调用工作流”</em> </strong>中，如下所示</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="d9c6" class="me jp hi mv b fi ne nf l ng nh">main:<br/>  params: [args]<br/>  steps:<br/>  - prepareQuery:<br/>      switch:<br/>        - condition: ${"query" in args}<br/>          assign:<br/>            - query: ${args.query}<br/>        - condition: true<br/>          assign:<br/>            - query: null<br/>  - callCustomUrl:<br/>      call: http.get<br/>      args:<br/>        url: ${args.url}<br/>        query: ${query}<br/>      result: result<br/>  - returnOutput:<br/>      return: ${result}</span></pre><p id="37c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">你可以注意到</em> <code class="du ms mt mu mv b"><em class="kr">prepareQuery</em></code> <em class="kr">步骤，它允许调用者不传递一些参数(这里是</em> <code class="du ms mt mu mv b"><em class="kr">query</em></code> <em class="kr">参数)。</em></p><p id="7b32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个工作流是一个例子，您可以根据您的用例进行调整。<code class="du ms mt mu mv b">call</code>值可以不同，一个<code class="du ms mt mu mv b">body</code>可以传递到<code class="du ms mt mu mv b">callCustomUrl</code>步骤，…</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="f9ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，你就有了类似于这个的执行图，<em class="kr">有或者没有</em> <code class="du ms mt mu mv b"><em class="kr">query</em></code> <em class="kr">参数</em></p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="3ff8" class="me jp hi mv b fi ne nf l ng nh">main:<br/>  steps:<br/>  - parallel-executor:<br/>      call: experimental.executions.map<br/>      args:<br/>        workflow_id: custom-api-call<br/>        arguments: [{"url":"&lt;SLEEPY-APP URL&gt;","query":{"w":5}},{"url":"https://www.google.com"}]<br/>      result: result<br/>  - logStep:<br/>      call: sys.log<br/>      args:<br/>        text: ${result}<br/>        severity: INFO<br/>  - returnOutput:<br/>      return: ${result}</span></pre><h2 id="c925" class="me jp hi bd jq mf mg mh ju mi mj mk jy jb ml mm kc jf mn mo kg jj mp mq kk mr bi translated">并行调用不同的可调用工作流</h2><p id="85d7" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在另一个用例中，您希望<strong class="is hj">用不同的参数</strong>调用不同的<em class="kr">“可调用工作流】</em>。这里的想法是<strong class="is hj">将对一个特定的<em class="kr">【可调用工作流】</em> </strong> <em class="kr"> </em>的调用包装在一个<em class="kr">可调用工作流中。</em></p><p id="da00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，这听起来像俄罗斯娃娃，但这是一个实验性功能的变通方法，使用了另一个实验性选项:<a class="ae ku" href="https://cloud.google.com/workflows/docs/reference/stdlib/experimental.executions/run" rel="noopener ugc nofollow" target="_blank"> execution.run </a></p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="c910" class="me jp hi mv b fi ne nf l ng nh">main:<br/>  params: [args]<br/>  steps:<br/>  - callCustomWorkflow:<br/>      call: experimental.executions.run<br/>      args:<br/>        workflow_id: ${args.workflow}<br/>        argument: ${args.argument}<br/>      result: result<br/>  - returnOutput:<br/>      return: ${result}</span></pre></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="e45d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，您可以从一个执行图中调用这个包装器，将它与以前的现有工作流结合起来。</p><pre class="mw mx my mz fd na mv nb nc aw nd bi"><span id="c716" class="me jp hi mv b fi ne nf l ng nh">main:<br/>  steps:<br/>  - parallel-executor:<br/>      call: experimental.executions.map<br/>      args:<br/>        workflow_id: custom-workflow<br/>        arguments: [{"workflow":"run-long-process","argument":{"wait":5}},{"workflow":"custom-api-call","argument":{"url":"&lt;SLEEPY-APP URL&gt;","query":{"w":5}}}]<br/>      result: result<br/>  - returnOutput:<br/>      return: ${result}</span></pre></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><blockquote class="ni nj nk"><p id="447b" class="iq ir kr is b it iu iv iw ix iy iz ja nl jc jd je nm jg jh ji nn jk jl jm jn hb bi translated">您可以在GitHub存储库中找到部署和测试这个<code class="du ms mt mu mv b"><a class="ae ku" href="https://github.com/guillaumeblaquiere/parallel-workflow/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">README.ms</a></code> <a class="ae ku" href="https://github.com/guillaumeblaquiere/parallel-workflow/blob/main/README.md" rel="noopener ugc nofollow" target="_blank"> </a>文件的说明。</p></blockquote><h1 id="7ef4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">仅仅是开始</h1><p id="664c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如简介中所述，该产品非常新，但已经正式上市，前景非常看好。</p><p id="86f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有些解决方案并没有完美地包含和内置，但是您<strong class="is hj">可以在没有太多限制和约束的情况下实现许多用例</strong>。</p><p id="95fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在这些具体的实验特性上，<strong class="is hj">请记住，这些特性是实验性的</strong>，将来可能会被破坏或删除！<strong class="is hj"> <em class="kr">但是为了更好的解决方案，我敢肯定！</em>T12】</strong></p></div></div>    
</body>
</html>