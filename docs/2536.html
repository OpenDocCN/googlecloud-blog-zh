<html>
<head>
<title>Rollback your Google Cloud Function to its previous version</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将你的谷歌云功能恢复到之前的版本</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/rollback-your-google-cloud-function-to-its-previous-version-76db870744c6?source=collection_archive---------2-----------------------#2022-11-22">https://medium.com/google-cloud/rollback-your-google-cloud-function-to-its-previous-version-76db870744c6?source=collection_archive---------2-----------------------#2022-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b83f7e380dc758551477b58905652e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgMTsiJaVwq4lUSwru93cg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@testalizeme?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Testalize.me </a>在<a class="ae iu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5e73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谷歌<a class="ae iu" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云功能</a>是一个无服务器的执行环境，允许用户用7种不同的语言运行他们的代码，有多个版本的语言运行时。它灵活、可扩展、可靠，可用于多种任务，包括运行生产工作流程步骤、开发运维任务、安全验证等。与其他提供商一样，它实施“按需付费”原则，没有隐藏成本(尊重其他一些云提供商，他们提供额外服务并向您收取费用)。</p><p id="f566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它几乎是完美的(是的，我为谷歌工作，热爱谷歌云)，几乎没有什么小缺点。我最近遇到的一个是能够快速回滚到先前部署的版本，而不需要经历<a class="ae iu" href="https://cloud.google.com/functions/docs/deploy" rel="noopener ugc nofollow" target="_blank">部署过程</a>。经过搜索，我在stack overflow<a class="ae iu" href="https://stackoverflow.com/questions/46797662/retrieving-an-old-version-of-a-google-cloud-function-source" rel="noopener ugc nofollow" target="_blank">找到了一个答案，它利用了云功能存储其部署工件的方式。首先，快速回顾一下这个方法。</a></p><p id="3ea8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当部署云函数时，工件被压缩到归档文件中，归档文件被存储到部署函数实例的同一个项目中的一个专门的云存储桶中。桶可以通过它的名字找到。对于第1代云函数，其名称如下</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/afd91ac6345ea2a178895d22aae6265e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ud_TTMzVlcG6g6eTVIuoeA.png"/></div></div></figure><p id="8c7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于第二代来说，将会是这样</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/3cec6ac205b4013b97f93306256c3df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBP-GNlyZ-7U1K6rS0_Fdw.png"/></div></div></figure><p id="eb19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中,[PROJECT_NUMBER]表示部署该功能的唯一Google Cloud <a class="ae iu" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects" rel="noopener ugc nofollow" target="_blank">项目编号</a>,[ LOCATION]是部署该功能的地区。</p><p id="6e47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在bucket中，您可以找到包含函数工件的文件夹，对于第1代函数，文件夹的名称以函数名称开头，后面跟随着函数资源的唯一id(GUID格式),对于第2代函数，文件夹的名称就是函数的名称。</p><p id="fa6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://stackoverflow.com/questions/46797662/retrieving-an-old-version-of-a-google-cloud-function-source" rel="noopener ugc nofollow" target="_blank">监视流程</a>上的解决方案描述了<strong class="ix hj">第1代</strong>功能的回滚。以下bash脚本使用Google CLI来完成同样的工作:</p><pre class="ju jv jw jx fd jz ka kb bn kc kd bi"><span id="b972" class="ke kf hi ka b be kg kh l ki kj">FUNCTION_NAME="place-your-function-name-here"<br/>PROJECT_ID="place-your-project-id-here"<br/>PROJECT_NUM=$(gcloud projects describe $PROJECT_ID \<br/>  --format="value(project_number)")<br/>VERSION_NUM=$(gcloud functions describe --project=leoy-toolbox \<br/>  $FUNCTION_NAME --format="value(version_id)")<br/>BUILD_NUM=$(gcloud functions describe --project=leoy-toolbox \<br/>  $FUNCTION_NAME --format="value(build_id)")<br/>LOCATION=$(gcloud functions describe --project=leoy-toolbox \<br/>  $FUNCTION_NAME --format="value(name)") | awk -F/ '{ print $4 }')<br/>SOURCE=$(gsutil --p=$PROJECT_ID ls \<br/>  gs://gcf-sources-$PROJECT_NUM-$LOCATION/$FUNCTION_NAME* \<br/>  | grep -v "version-$VERSION_NUM" | tail -1)<br/>gcloud functions deploy --project=$PROJECT_ID $FUNCTION_NAME \<br/>  --source=$SOURCE/function-source.zip \<br/>  --region=$LOCATION</span></pre><p id="eb3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该脚本使用已知的项目id和函数名来检索其他信息，比如项目号、函数的位置、最新版本以及到先前版本工件的路径。然后它使用工件的URI来部署它。</p><blockquote class="kk kl km"><p id="f73a" class="iv iw kn ix b iy iz ja jb jc jd je jf ko jh ji jj kp jl jm jn kq jp jq jr js hb bi translated"><strong class="ix hj">注:</strong>此处的前一版本仅指从两个文件夹中选择一个，其名称不以当前部署版本的版本id结尾。</p></blockquote><p id="594b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，这将有一个重要的限制。如果发生以下部署序列，回滚工件将包含无效的部署代码/配置，而不是“当前成功部署之前的最后工作版本”。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/72e7b4e67e9121d39ea9ab7de731abb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjeRvD6ph94bFZLjgmIKEg.png"/></div></div></figure><p id="19e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是因为第1代云函数工件似乎只存储了<em class="kn">和</em>两个<em class="kn">最后一个</em>版本，而不管成功状态如何。</p><p id="ff03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二代云功能的情况要好得多。对于他们来说，具有该功能名称的文件夹存储了启用了<a class="ae iu" href="https://cloud.google.com/storage/docs/object-versioning" rel="noopener ugc nofollow" target="_blank">历史特征</a>的<code class="du ks kt ku ka b">function-source.zip</code>文件。因此，从理论上讲，您可以回滚到“最后好的”版本。然而，由于没有任何迹象表明哪个以前的版本是“好的”，这可能是一件棘手的事情。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="db57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">总结</strong>，可以在不运行vs源代码管理系统的情况下回滚之前部署的云功能版本。然而，该特性利用了未记录的存储云函数工件的方法，还不能用于生产工作流。</p><p id="aed0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">剧透</strong>:第二代云功能支持此功能的“工作正在进行中”。虽然没有做出承诺，但在23英尺的H1期待它是合理的🤞</p></div></div>    
</body>
</html>