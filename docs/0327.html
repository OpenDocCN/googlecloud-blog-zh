<html>
<head>
<title>Displaying Google Analytics metrics in your README</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在您的自述文件中显示Google Analytics指标</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/displaying-google-analytics-metrics-in-your-readme-2ce45fb7ea76?source=collection_archive---------0-----------------------#2017-07-05">https://medium.com/google-cloud/displaying-google-analytics-metrics-in-your-readme-2ce45fb7ea76?source=collection_archive---------0-----------------------#2017-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f1bc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">带有shields.io和Google Cloud功能的定制动态存储库徽章</h2></div><p id="c2b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你在GitHub(或其他在线代码托管服务)上浏览过开源代码，你可能以前见过这些库徽章:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/553487014d246d1a5d032bf0855e050e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7Tm6tjwotZ201rsXOnovQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">GitHub上的TensorFlow构建状态徽章</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/6f3a035437081d6d6ac7be1d0554f7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pp5j_w4wlXYl-IrHnXBj4g.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">GitHub上的Node.js请求代码覆盖徽章</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kj"><img src="../Images/b1c63aae7b16f85292b9d9fc081bce7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LE3GKJs5ix4j5zMoLN4E6w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">在GitLab上…</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kk"><img src="../Images/d12ff5c13d4b1be5f15cdd77c6af00ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BP_y2BBD_x43ugCx_4wrhg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">…还有BitBucket。</figcaption></figure><h1 id="15da" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">什么是存储库徽章？</h1><p id="842e" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">存储库徽章最普遍的形式是shields风格，上面截图中的大多数徽章都代表了这种风格。还有其他形式的徽章，例如请求存储库中精心制作的npm徽章。</p><p id="e522" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">资源库徽章通常用于显示关于资源库的信息，例如持续集成构建状态和代码覆盖率，但也可以是到文档或讨论的链接，显示库的最新版本和下载次数，或者基本上是您想要在资源库上显示的任何内容。</p><p id="f5f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以通过在浏览代码时留意它们，向下滚动<a class="ae li" href="https://shields.io/" rel="noopener ugc nofollow" target="_blank">https://shields.io/</a>并查看那里的许多例子，或者看一看<a class="ae li" href="https://github.com/dwyl/repo-badges" rel="noopener ugc nofollow" target="_blank">这个描述我遇到的库徽章的自述文件</a>来找到更多关于徽章的信息。</p><h1 id="800b" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">在徽章上显示每周用户</h1><p id="9450" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">我对显示一段时间内的活动(如每周下载次数或在线用户数)的徽章感兴趣，并希望在我的<a class="ae li" href="https://github.com/yi-jiayu/bus-eta-bot" rel="noopener ugc nofollow" target="_blank"> Bus Eta Bot存储库</a>中放置一个徽章，以显示过去一周使用我的Bot的独立用户的数量，这是我已经用Google Analytics跟踪的指标。最终结果如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lj"><img src="../Images/c01d0200a7e655a4d2a852c5da9f18fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*oapATx2iGXWNQioBbYQqBA.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">本周51个用户！</figcaption></figure><p id="9d59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们可以使用shields.io创建定制的shields风格的存储库徽章。</p><h1 id="f300" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">shields.io</h1><p id="3462" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">shields.io是一种服务，它从以下形式的URL生成自定义svg shields徽章:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="1b9c" class="lp km hi ll b fi lq lr l ls lt">https://img.shields.io/badge/&lt;SUBJECT&gt;-&lt;STATUS&gt;-&lt;COLOR&gt;.svg</span></pre><p id="f6c6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将解析为带有<code class="du lu lv lw ll b">&lt;COLOR&gt;</code>背景的左侧为<code class="du lu lv lw ll b">&lt;SUBJECT&gt;</code>右侧为<code class="du lu lv lw ll b">&lt;STATUS&gt;</code>的徽章。然后，您可以将该URL嵌入您的自述文件中，以在您的存储库页面上显示徽章。例如，h<a class="ae li" href="https://img.shields.io/badge/godoc-reference-blue.svg" rel="noopener ugc nofollow" target="_blank">ttps://img . shields . io/badge/Godoc-reference-blue . SVG</a>生成通常用于链接到Godoc for Go库文档的徽章:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lx"><img src="../Images/67f6a8a82df52263fe00e6ae3fb0133a.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*1PfhLHySXbPK0z0tvlBHUw.png"/></div></figure><p id="bdd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，将shields.io链接直接放入您的自述文件会创建一个静态标记，它只能通过新的提交进行更改。为了显示动态信息，徽章本身必须动态生成。</p><p id="1b31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实上，正如我在写这篇文章时才发现的，shields.io还可以为某些常见的统计数据动态生成徽章，例如:</p><ul class=""><li id="e36b" class="ly lz hi iz b ja jb jd je jg ma jk mb jo mc js md me mf mg bi translated">不同软件包管理器的最新版本和下载，例如npm、PyPI、crates.io</li><li id="1081" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">最新的GitHub版本，标记甚至提交，因为一个特定的标记</li><li id="4474" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js md me mf mg bi translated">Discord上的在线用户数量</li></ul><p id="1f7a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在<a class="ae li" href="https://shields.io/" rel="noopener ugc nofollow" target="_blank"> shields.io网站</a>上找到详尽的列表。</p><p id="628b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，还有许多其他的服务为您生成库徽章，包括大多数持续集成和代码覆盖提供者。然而，对于真正定制的或非公开的信息，我们必须自己生成。虽然我们可以运行自己的web服务器来实现这一点，但在这种情况下，利用Google Cloud的无服务器计算功能似乎更实际。</p><h1 id="46d7" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">谷歌云功能</h1><p id="c089" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">注意:我决定使用谷歌云功能，因为我的机器人已经是谷歌云平台(GCP)上的一个项目，我将从谷歌分析中提取数据，但总的来说，没有什么可以阻止你使用AWS Lambda或任何其他功能即服务(FaaS)提供商。</p><p id="59e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae li" href="https://cloud.google.com/functions/" rel="noopener ugc nofollow" target="_blank">谷歌云功能</a>是谷歌的FaaS产品，类似于AWS Lambda，允许你编写响应HTTP请求或由其他GCP服务事件触发的功能。目前，云函数仅使用JavaScript编写，并在Node.js 6.9.1运行时运行，因此我们将使用JavaScript来编写我们的函数。</p><p id="65c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们想要的是一个HTTP函数，当它被调用时，从某个地方获取一些信息，然后构建一个自定义的shields.io链接并返回一个302重定向到它。然后，我们可以将这个函数的端点嵌入到我们的README中，这样，每次它被触发时，都会用我们的最新数据动态生成一个屏蔽。在我的例子中，我想从Google Analytics属性中获取这些数据。</p><h1 id="2390" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">谷歌分析报告API</h1><p id="146c" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated"><a class="ae li" href="https://developers.google.com/analytics/devguides/reporting/core/v4/" rel="noopener ugc nofollow" target="_blank">谷歌分析报告API v4 </a>是分析报告API的最新版本，是“在谷歌分析中访问报告数据的最先进的编程方法”。我们将使用它来获得一个单一的数字:过去7天的独立用户的数量，尽管您可以将其更改为您想要的任何指标。您可以在<a class="ae li" href="https://developers.google.com/analytics/devguides/reporting/core/dimsmets" rel="noopener ugc nofollow" target="_blank">维度&amp;指标浏览器</a>中找到所有可用的指标。</p><h2 id="e89e" class="lp km hi bd kn mm mn mo kr mp mq mr kv jg ms mt kx jk mu mv kz jo mw mx lb my bi translated">证明</h2><p id="e978" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">不幸的是，分析报告API v4仅支持OAuth 2.0认证，而不是在同一个GCP项目内“仅仅工作”，这可能是因为谷歌分析是一项独立于谷歌云平台的服务。</p><p id="8d80" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，为了访问我们的数据，我们将不得不使用我们的GCP项目的服务帐户，该帐户已经在我们的谷歌分析帐户中获得了必要的权限。</p><p id="b5d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们需要创建一个服务帐户，并获取其私钥文件，我们将使用该文件向分析报告API验证我们自己。你可以按照谷歌文档中“创建服务账户”一节下的说明在这里:<a class="ae li" href="https://developers.google.com/identity/protocols/OAuth2ServiceAccount#creatinganaccount" rel="noopener ugc nofollow" target="_blank">使用OAuth 2.0进行服务器对服务器的应用</a>。一旦安全地下载了私钥文件，就可以继续下一步了。</p><p id="6bf4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要授予服务帐户对Google Analytics帐户的读取权限。您可以在“用户管理”部分的管理部分<a class="ae li" href="https://analytics.google.com/analytics/web/#management/Settings/" rel="noopener ugc nofollow" target="_blank">下点击</a>。</p><h1 id="e7fe" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">使用Node.js查询分析报告API</h1><p id="f880" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">一旦我们获得了一组服务帐户凭据，并授予了您的服务帐户读取您的Google Analytics数据的权限，我们就可以使用一个简短的Node.js程序来测试一切是否正常，该程序使用<a class="ae li" href="http://Google APIs Node.js Client" rel="noopener ugc nofollow" target="_blank"> Google APIs Node.js客户端</a>来查询分析报告API:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="48ef" class="lp km hi ll b fi lq lr l ls lt">"use strict";</span><span id="2634" class="lp km hi ll b fi mz lr l ls lt"><strong class="ll hj">const </strong>google = require('googleapis');<br/><br/><strong class="ll hj">const </strong>key = require('./credentials.json');<br/><strong class="ll hj">const </strong>viewId = 'YOUR_VIEW_ID';<br/><br/><strong class="ll hj">function </strong>getUsers(key, viewId) {<br/>    // https://github.com/google/google-api-nodejs-client#using-jwt-service-tokens<br/>    <strong class="ll hj">const </strong>jwtClient = <strong class="ll hj">new </strong>google.auth.JWT(<br/>        key.client_email,<br/>        <strong class="ll hj">null</strong>,<br/>        key.private_key,<br/>        ['https://www.googleapis.com/auth/analytics.readonly'],<br/>        <strong class="ll hj">null<br/>    </strong>);<br/><br/>    <strong class="ll hj">return new </strong>Promise((resolve, reject) =&gt; {<br/>        jwtClient.authorize(err =&gt; {<br/>            <strong class="ll hj">if </strong>(err) {<br/>                console.log(err);<br/>                <strong class="ll hj">return</strong>;<br/>            }<br/><br/>            // based on https://github.com/google/google-api-nodejs-client/issues/561<br/>            <strong class="ll hj">const </strong>analytics = google.analyticsreporting('v4');<br/>            analytics.reports.batchGet({<br/>                auth: jwtClient,<br/>                resource: {<br/>                    reportRequests: [<br/>                        {<br/>                            viewId: viewId,<br/>                            dateRanges: [<br/>                                {<br/>                                    startDate: '7daysAgo',<br/>                                    endDate: 'today'<br/>                                }<br/>                            ],<br/>                            metrics: [<br/>                                {<br/>                                    expression: 'ga:users'<br/>                                }<br/>                            ]<br/>                        }<br/>                    ]<br/>                }<br/>            }, (err, data) =&gt; {<br/>                <strong class="ll hj">if </strong>(err) {<br/>                    <strong class="ll hj">return </strong>reject(err);<br/>                } <strong class="ll hj">else </strong>{<br/>                    <strong class="ll hj">return </strong>resolve(data);<br/>                }<br/>            });<br/>        });<br/>    });<br/>}<br/><br/>getUsers(key, viewId)<br/>    .then(data =&gt; console.log(JSON.stringify(data)))<br/>    .catch(console.error);</span></pre><p id="ffd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，<code class="du lu lv lw ll b">./credentials.json</code>应该是您的服务帐户凭证文件的路径，您需要用您正在使用的视图ID替换<code class="du lu lv lw ll b">YOUR_VIEW_ID</code>。运行这个文件，我们应该看到一个JSON blob，其中包含我们感兴趣的指标(在下面的输出中是47):</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="321f" class="lp km hi ll b fi lq lr l ls lt">PS&gt; node .\test.js<br/>{"reports":[{"columnHeader":{"metricHeader":{"metricHeaderEntries":[{"name":"ga:users","type":"INTEGER"}]}},"data":{"row<br/>s":[{"metrics":[{"values":["47"]}]}],"totals":[{"values":["47"]}],"rowCount":1,"minimums":[{"values":["47"]}],"maximums"<br/>:[{"values":["47"]}]}}]}</span></pre><p id="7919" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然看起来有点乱，但实际值本身可以用<code class="du lu lv lw ll b">.reports[0].data.totals[0].values[0]</code>提取出来。</p><p id="eb13" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太好了！我们能够以编程的方式从Google Analytics获得指标的值。现在我们只需要编写一个云函数，它构建一个自定义的shields.io链接并重定向到它。</p><h1 id="63c5" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">编写我们的云函数</h1><p id="8c15" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">HTTP触发的云函数实际上只是一个Express.js路由处理程序，如果您以前使用过Express，应该会很熟悉。它只是一个接受请求上下文和响应上下文的函数:通过请求上下文访问关于传入请求的细节，并使用响应上下文上的方法进行响应。</p><p id="1b24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于实际操作的介绍，您可以按照云函数文档上的<a class="ae li" href="https://cloud.google.com/functions/docs/tutorials/http" rel="noopener ugc nofollow" target="_blank"> HTTP教程</a>来创建一个Hello World云函数，它用一些文本来响应任何传入的HTTP请求。</p><p id="851c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以前，我们设法从Google Analytics获得我们的指标值。使用shields.io URL，我们可以创建包含它的自定义徽章:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="0b6b" class="lp km hi ll b fi lq lr l ls lt"><a class="ae li" href="https://img.shields.io/badge/weekly%20users-51-yellow.svg" rel="noopener ugc nofollow" target="_blank">https://img.shields.io/badge/weekly%20users-51-yellow.svg</a></span></pre><p id="a4ce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成为</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es na"><img src="../Images/1381d7ba7a7427f14001153d9ceb68ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*rDkhIxGEgMiok_FvKXkfiw.png"/></div></figure><p id="7219" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在需要做的就是修改上面的代码，导出一个HTTP处理程序，该处理程序返回一个重定向到shields.io URL的消息，其中包含我们度量的最新值，而不仅仅是将该值打印到标准输出中。</p><p id="c82c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">替换</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="6d4f" class="lp km hi ll b fi lq lr l ls lt">getUsers(key, viewId)<br/>    .then(data =&gt; console.log(JSON.stringify(data)))<br/>    .catch(console.error);</span></pre><p id="c77e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="8164" class="lp km hi ll b fi lq lr l ls lt">exports.function = <strong class="ll hj">function </strong>(req, res) {<br/>    return getUsers(key, viewId)<br/>        .then(data =&gt; {<br/>            <strong class="ll hj">const </strong>value = data.reports[0].data.totals[0].values[0];<br/>            <strong class="ll hj">return </strong>res.redirect(302, `https://img.shields.io/badge/users-${value}%2Fweek-yellow.svg`);<br/>        })<br/>        .catch(err =&gt; {<br/>            console.error(err);<br/>            <strong class="ll hj">return </strong>res.sendStatus(500);<br/>        });<br/>};</span></pre><p id="3c67" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码使用了模板文字，这是一个相对较新的JavaScript特性，但是我们所做的只是将度量值插入到一个URL字符串中。</p><p id="5996" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经编写了云函数，我们可以部署它来测试它是否工作。假设您有以下文件夹结构:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="3c94" class="lp km hi ll b fi lq lr l ls lt">|- credentials.js<br/>|- index.js<br/>|- package.json</span></pre><p id="14df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用<code class="du lu lv lw ll b">gcloud</code>命令部署您的功能:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="34ca" class="lp km hi ll b fi lq lr l ls lt">gcloud --project [YOUR_PROJECT_ID] beta functions deploy [YOUR_FUNCTION_NAME] --stage-bucket [YOUR_STAGING_BUCKET_NAME] --trigger-http --memory 128MB</span></pre><p id="ac6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的命令中，<code class="du lu lv lw ll b">YOUR_PROJECT_ID</code>是您的GCP项目的ID，<code class="du lu lv lw ll b">YOUR_STAGING_BUCKET_NAME</code>是存储您的函数代码的云存储桶，<code class="du lu lv lw ll b">YOUR_FUNCTION_NAME</code>是您为函数选择的名称。我们在<code class="du lu lv lw ll b">package.json</code>中的<code class="du lu lv lw ll b">main</code>值被设置为<code class="du lu lv lw ll b">index.js</code>，而我们导出的HTTP处理程序被称为<code class="du lu lv lw ll b">function</code>，这是云函数寻找的默认值。我们还将为我们的函数分配的内存设置为最小值128MB，而不是默认的256MB，因为我们可能不需要太多的内存。在<a class="ae li" href="https://cloud.google.com/sdk/gcloud/reference/beta/functions/deploy" rel="noopener ugc nofollow" target="_blank"> Cloud SDK文档</a>中可以找到<code class="du lu lv lw ll b">gcloud beta functions deploy</code>选项的完整列表。</p><p id="14d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成功部署函数后，在输出中应该会看到函数端点的URL:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="ce51" class="lp km hi ll b fi lq lr l ls lt">...<br/>httpsTrigger:<br/>  url: https://us-central1-YOUR_PROJECT_ID.cloudfunctions.net/YOUR_FUNCTION_NAME<br/>...</span></pre><p id="75bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你访问这个网址，你应该从上面看到同样的徽章，但现在它是动态的！是时候将它添加到我们的自述文件中了。</p><h1 id="1bad" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">将徽章嵌入您的自述文件</h1><p id="af31" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">这是最简单的一步，尤其是如果您的自述文件中已经有了其他徽章。为了在Markdown中做到这一点，我们就像其他图像一样:</p><pre class="ju jv jw jx fd lk ll lm ln aw lo bi"><span id="4b7d" class="lp km hi ll b fi lq lr l ls lt">![Weekly users](https://us-central1-YOUR_PROJECT_ID.cloudfunctions.net/YOUR_FUNCTION_NAME)</span></pre><p id="9a23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将我们的新徽章嵌入到我们的自述文件中，并为它添加了一些替代文本。</p><h2 id="4240" class="lp km hi bd kn mm mn mo kr mp mq mr kv jg ms mt kx jk mu mv kz jo mw mx lb my bi translated">关于缓存的说明</h2><p id="13a1" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">存储库主机可能会缓存您的工卡。例如，GitHub通过其camo缓存代理用户图像(<a class="ae li" href="https://github.com/blog/1766-proxying-user-images" rel="noopener ugc nofollow" target="_blank">公告</a>)，而<a class="ae li" href="https://github.com/github/markup/issues/224" rel="noopener ugc nofollow" target="_blank">问题</a>之前已经提出过关于陈旧的存储库徽章。GitHub说他们尊重<code class="du lu lv lw ll b">Cache-Control</code>和<code class="du lu lv lw ll b">ETag</code>头，shields.io设置<code class="du lu lv lw ll b">cache-control: max-age=86400</code>，所以有可能我们的徽章会被缓存24小时。</p><p id="fa87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，由于在这种情况下，我显示的是每周用户计数，每天只更新一次，所以24小时的缓存时间不是很重要，我没有太注意它。根据您的使用情况，您可能需要找到一种方法来保持您的徽章新鲜。</p><h1 id="ec14" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">摘要</h1><p id="441a" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">在本帖中，我们</p><ol class=""><li id="d71c" class="ly lz hi iz b ja jb jd je jg ma jk mb jo mc js nb me mf mg bi translated">使用shields.io创建自定义存储库徽章，</li><li id="8f6d" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js nb me mf mg bi translated">使用分析报告API v4检索Google分析属性值，</li><li id="e25a" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js nb me mf mg bi translated">创建了一个云函数，它使用shields.io生成一个自定义的存储库徽章，包含我们的Google Analytics属性的实时值，以及</li><li id="1ead" class="ly lz hi iz b ja mh jd mi jg mj jk mk jo ml js nb me mf mg bi translated">将生成的徽章嵌入我们的自述文件。</li></ol><p id="92e9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在<a class="ae li" href="https://gist.github.com/yi-jiayu/e1fccd54a3ef7a4eed6c2a999420b50c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/yi-Jiayu/E1 fccd 54 a3 ef 7 a 4 eed 6 C2 a 999420 b 50 c</a>找到上面云函数的源代码。</p><p id="4e89" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我的具体用例涉及Google Analytics，并且我使用了Google Cloud函数，但本文中使用的所有技术都可以推广到其他用途，例如从Google Analytics中提取数据供自己使用，或者使用AWS Lambda从其他数据源创建自定义存储库徽章。</p><p id="15ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，和往常一样，如果您在新加坡并且经常乘坐公交车，请务必查看我的电报机器人<a class="ae li" href="https://t.me/BusEtaBot" rel="noopener ugc nofollow" target="_blank"> @BusEtaBot </a>查看公交eta！</p></div></div>    
</body>
</html>