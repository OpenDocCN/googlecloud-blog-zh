<html>
<head>
<title>Server Side Rendered React on Google Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端渲染谷歌云函数</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/server-side-rendered-react-on-google-cloud-functions-8b51b2b0878c?source=collection_archive---------0-----------------------#2017-05-24">https://medium.com/google-cloud/server-side-rendered-react-on-google-cloud-functions-8b51b2b0878c?source=collection_archive---------0-----------------------#2017-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="62de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">渲染HTML是我第一次尝试的Serverless的用例之一。我喜欢这个想法:</p><ol class=""><li id="30fe" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">单一功能<strong class="ih hj">(无服务器)</strong></li><li id="e152" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">渲染React组件<strong class="ih hj">(服务器端渲染)</strong></li><li id="88fa" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在HTTP端点上<strong class="ih hj">(微服务组合)</strong></li><li id="7c3f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">返回完整的应用程序/页面。<strong class="ih hj">(单页应用)</strong></li></ol><p id="d7ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个评论的好处都在网上有详细的记录。从在移动设备上提供更好的SEO和更快的响应的SSR，到定义当今大多数大公司基础设施的微服务，到为我们最喜爱的社交网络应用和在线协作工具提供动力的日益复杂的SPA，到无服务器在成本节约和无限可扩展性方面的惊人潜力。</p><p id="3a93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们尝试将一个简单的例子放在一起，说明如何在一个SPA中实现所有这些功能，这个例子是用部署在Google Cloud Functions上的React编写的。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/8ed9cc55351343270f7bac3183f9ffdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVbOZmTIY16Ix1xH_42yEA.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">这座城市</figcaption></figure><h2 id="949b" class="kh ki hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">无服务器功能</h2><p id="f1b7" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">让我们从一个简单的谷歌云功能开始。</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="eb5e" class="kh ki hi li b fi lm ln l lo lp">$ mkdir my-serverless-app<br/>$ cd my-serverless-app<br/>$ npm init -y</span></pre><p id="9377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在<em class="lq"> index.js </em>添加一些代码:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="6de7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及<em class="lq"> package.json </em>的脚本部分的新值:</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="7c4f" class="kh ki hi li b fi lm ln l lo lp">"scripts": {<br/>  <strong class="li hj">"deploy": "gcloud beta functions deploy my-serverless-app-1_0_0 --entry-point handler --trigger-http --stage-bucket medium-post-functions --memory=2048MB"</strong><br/>},</span></pre><p id="bf38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们有了这几个部分，我们可以简单地做:</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="42c3" class="kh ki hi li b fi lm ln l lo lp">$ yarn deploy</span></pre><p id="4ff3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">观看我们的GCF被部署。注意，我使用了2048Mb内存。(以后可以随意更改这个)。此时，我们有一个返回静态内容的HTTP端点。</p><h2 id="f30f" class="kh ki hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">服务器端渲染反应</h2><p id="76a4" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">此时为React创建另一个SSR实现并不是很有成效。已经有很多很好的实现了。再加上一大堆库来加快React开发的速度。</p><ul class=""><li id="ec4b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc lt jj jk jl bi translated"><em class="lq">create-react-app</em>(<a class="ae lu" href="https://www.npmjs.com/package/create-react-app" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/create-react-app</a>)用React启动的时候解决了很多问题，但是没有SSR。</li><li id="d91b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lt jj jk jl bi translated"><em class="lq">nwb</em>(<a class="ae lu" href="https://www.npmjs.com/package/nwb" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/nwb</a>)类似于create-react-app但是支持Preact、Inferno、组件库等。</li><li id="133d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lt jj jk jl bi translated">https://github.com/storybooks/react-cdk很喜欢这个，故事书是一个很好的创建组件库的方式，它有实时的风格指南。</li><li id="c60d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lt jj jk jl bi translated"><em class="lq">razzle</em>(<a class="ae lu" href="https://www.npmjs.com/package/razzle" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/razzle</a>)好库，看不上SSR。+1表示使用反应路由器v4。</li><li id="ba4e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lt jj jk jl bi translated"><em class="lq">下一个</em>(<a class="ae lu" href="https://www.npmjs.com/package/next" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/next</a>)大概是现在功能最全的React库了。Does SSR及其示例文件夹是纯JS黄金。；)</li></ul><p id="ca43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我会用<em class="lq"> Nextjs </em>。学习如何使用它的最好方法是去https://learnnextjs.com/的<a class="ae lu" href="https://learnnextjs.com/" rel="noopener ugc nofollow" target="_blank"/>(我做到了，花了我~20分钟掌握基本知识)。继续同一个回购，让我们先添加<em class="lq"> Nextjs </em>依赖项。</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="18e8" class="kh ki hi li b fi lm ln l lo lp">$ yarn add react react-dom next<br/>$ mkdir pages</span></pre><p id="afa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们制作一个<em class="lq"> pages/index.js </em>作为我们应用程序的根。</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="b7f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及对<em class="lq"> package.json </em>的一个小补充:</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="eb88" class="kh ki hi li b fi lm ln l lo lp">{<br/>  "scripts": {<br/>    <strong class="li hj">"dev": "next"</strong><br/>  }<br/>}</span></pre><p id="8fd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们现在可以做的是:</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="1411" class="kh ki hi li b fi lm ln l lo lp">$ yarn dev</span><span id="27eb" class="kh ki hi li b fi lv ln l lo lp">DONE  Compiled successfully in 3775ms                                                                                                                             &gt; Ready on http://localhost:3000</span></pre><p id="fd33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">去<a class="ae lu" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"><em class="lq">http://localhost:3000</em></a><em class="lq"/>看看我们的“App”</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lw"><img src="../Images/f41f4e37484edfe82cd27ef3ca5d96b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*E62ZHfjsBOBfhTE3c4YxXg.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">浏览器框架艺术<a class="ae lu" href="https://dribbble.com/shots/1582463-Browser-mockup" rel="noopener ugc nofollow" target="_blank">https://dribbble.com/shots/1582463-Browser-mockup</a></figcaption></figure><p id="9e40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不错，但对服务器端渲染或谷歌云功能来说不太好。我们需要构建我们的应用程序，并使用处理函数来服务它。Nextjs推荐的方法是创建一个定制服务器(<a class="ae lu" href="https://learnnextjs.com/basics/server-side-support-for-clean-urls/create-a-custom-server" rel="noopener ugc nofollow" target="_blank">https://learnnextjs . com/basics/Server-side-support-for-clean-URLs/create-a-Custom-Server</a>)</p><p id="ebe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们的定制服务器仅用于GCF，因此我们可以将其简化为:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="b4e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且在<em class="lq"> package.json </em>上再添加一个脚本，将我们的应用程序构建成一个可部署的变体。(默认情况下，内置应用程序存储在<em class="lq">上。下一个</em>文件夹，查看一下)</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="9ff6" class="kh ki hi li b fi lm ln l lo lp">{<br/>  "scripts": {<br/>    <strong class="li hj">"build": "next build"</strong><br/>  }<br/>}</span></pre><p id="3897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后:</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="fa11" class="kh ki hi li b fi lm ln l lo lp">$ yarn build<br/>$ yarn deploy</span><span id="1fde" class="kh ki hi li b fi lv ln l lo lp">....<br/>httpsTrigger:<br/>  url: <a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0" rel="noopener ugc nofollow" target="_blank">https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0</a><br/>....</span></pre><p id="48f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们访问:<a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0" rel="noopener ugc nofollow" target="_blank">https://us-central 1-revelation-165320 . cloud functions . net/my-server less-app-1 _ 0 _ 0</a>/</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lw"><img src="../Images/c2291c3e1052ab94611388579c5a3bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*pKEd9G7It_7MAPax83X_2w.png"/></div></figure><p id="a206" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意端点调用末尾的斜杠(/)。GCF和<em class="lq"> Nextjs </em> ends似乎有一些错误。GCF假设默认路由是一个空字符串，所以</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="61fa" class="kh ki hi li b fi lm ln l lo lp"><a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0" rel="noopener ugc nofollow" target="_blank">https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0</a></span><span id="2dd0" class="kh ki hi li b fi lv ln l lo lp">req.url === ''</span><span id="4ce3" class="kh ki hi li b fi lv ln l lo lp"><a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0/" rel="noopener ugc nofollow" target="_blank">https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0/</a></span><span id="26a4" class="kh ki hi li b fi lv ln l lo lp">req.url === '/'</span></pre><p id="4a57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果路径为空，则<em class="lq"> Nextjs </em>失败。这个小怪癖打破了没有尾随斜线的端点。我们的处理函数的一个更健壮的版本可以是:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="f387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在重新部署之后，我们可以安全地访问端点HTTP，而不需要尾部的斜杠。服务器端渲染。</p><h2 id="fa71" class="kh ki hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">微服务组合</h2><p id="ddf9" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">SSR部分一切正常。但是，我们的应用程序在客户端有致命的缺陷。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lx"><img src="../Images/7cda00b966afe0f853362c4e944460b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*4mxp39SMtBTuSqXPuALuZg.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">浏览器控制台上显示的失败资源。</figcaption></figure><p id="df9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的应用程序资源无法从GCF下载。这些资源基本上包括所有的应用资产，比如Javascript包、CSS和图片(如果有的话)。<em class="lq"> Nextjs </em>使用绝对路由获取资产并处理路由。我们需要从一个域的基本根路径或/来提供我们的应用程序。</p><p id="bc71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单的方法是使用NGINX:</p><pre class="js jt ju jv fd lh li lj lk aw ll bi"><span id="fe9e" class="kh ki hi li b fi lm ln l lo lp">http {<br/>  upstream app_server {<br/>    server <a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0" rel="noopener ugc nofollow" target="_blank">us-central1-revelatio-165320.cloudfunctions.net</a>;<br/>  }</span><span id="ef35" class="kh ki hi li b fi lv ln l lo lp">  server {<br/>    listen       80;<br/>    server_name  <a class="ae lu" href="http://www.mi-app.com" rel="noopener ugc nofollow" target="_blank">www.mi-app.com</a>;</span><span id="16f4" class="kh ki hi li b fi lv ln l lo lp">location / {<br/>      proxy_pass   https://<a class="ae lu" href="http://ws_server/" rel="noopener ugc nofollow" target="_blank">app_server</a><a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0" rel="noopener ugc nofollow" target="_blank">/my-serverless-app-1_0_0</a>;<br/>      proxy_redirect off;<br/>      proxy_http_version 1.1;<br/>      proxy_set_header Upgrade $http_upgrade;<br/>      proxy_set_header Connection "upgrade";<br/>    }<br/>  }<br/>}</span></pre><p id="685d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">NGINX是一款非常非常好的软件。但是，我认为真正的无服务器方法应该在服务器维护上零成本(cero)。所以，让我们选择另一个提供商，在这个例子中，快速(<a class="ae lu" href="https://www.fastly.com/" rel="noopener ugc nofollow" target="_blank">https://www.fastly.com/</a>)</p><p id="dad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以快速创建一项服务:</p><ol class=""><li id="2dc4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">设置我们自己的应用程序域。</li><li id="c9ba" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">设置主机为我们的云功能域，包括子域。(例如:us-central1-revelatio-165320.cloudfunctions.net<a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0" rel="noopener ugc nofollow" target="_blank"/>)</li><li id="e30c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">启用TLS并使用端口443</li><li id="d29e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">证书主机名和SNI主机名的值与#2相同</li><li id="f665" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">覆盖与#2相同的主机设置</li><li id="04b6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">创建一个头规则来转换请求的req.url属性，并重写所有url，从/*到<a class="ae lu" href="https://us-central1-revelatio-165320.cloudfunctions.net/my-serverless-app-1_0_0" rel="noopener ugc nofollow" target="_blank">/my-server less-app-1 _ 0 _ 0</a>/*(类型:<strong class="ih hj">请求/正则表达式</strong>，目的地:<strong class="ih hj"> url </strong>，源:<strong class="ih hj"> req.url </strong>，正则表达式:<strong class="ih hj"> ^(.*)$ </strong>，替换:<strong class="ih hj">/my-server less-app-1 _ 0 _ 0 \ 1</strong>)</li></ol><p id="9a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，Fastly要求您在域名DNS上添加一个CNAME注册中心才能正常工作。</p><p id="ee36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦所有这些设置就绪(花了我6个版本才弄对)，你就可以通过一个高性能的缓存和全局CDN在GCF上部署你的应用了。</p><p id="1a1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他谷歌云功能，如API后端，可以使用相同的方法部署，当然是在不同的路线上。/api/v1或/api/graphql。</p><p id="9444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lq">(查看如何在GCF上制作一个简单的mongoDB后端</em><a class="ae lu" rel="noopener" href="/google-cloud/creating-a-mongodb-crud-backend-on-google-cloud-functions-88bb5c1cef77"><em class="lq">https://medium . com/Google-cloud/creating-a-mongoDB-crud-back end-on-Google-cloud-functions-88 bb 5 C1 cef 77</em></a><em class="lq">)</em></p><h2 id="c6d3" class="kh ki hi bd kj kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">单页应用程序</h2><p id="58b2" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在这一点上，这篇文章变得太长了。所以，去<a class="ae lu" href="https://learnnextjs.com" rel="noopener ugc nofollow" target="_blank">https://learnnextjs.com</a>和<a class="ae lu" href="https://github.com/zeit/next.js/tree/v3-beta/examples" rel="noopener ugc nofollow" target="_blank">https://github.com/zeit/next.js/tree/v3-beta/examples</a>开发伟大的应用。</p><p id="0c11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编辑1:稍微修改了NGINX上游的例子。我还没有完全测试过这种方法，我建议您使用Kong API Gateway(https://get Kong . org)。</p></div></div>    
</body>
</html>