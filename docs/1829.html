<html>
<head>
<title>Node-RED solution deployment on GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP上的节点红色解决方案部署</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/node-red-solution-deployment-on-gcp-cb885e3528f9?source=collection_archive---------0-----------------------#2021-03-21">https://medium.com/google-cloud/node-red-solution-deployment-on-gcp-cb885e3528f9?source=collection_archive---------0-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/30a638c982b6b3c2263123314f7274c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QPRSzJDjg5OtsqRj"/></div></div></figure><p id="9ac1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个故事中，我们将假设你已经设计并实现了一个节点红色的解决方案，你希望把它放到谷歌云平台(GCP)上。在这里，我们将研究一些可以用来以安全的方式实现这一点的实践。</p><p id="9526" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们部署节点红色解决方案时，我们实际上将部署两个部分。我们将配置Node-RED运行时，以及我们希望在该运行时托管的解决方案。我们将在此展示的技术是创建一个自定义Docker映像，该映像将打包在一起:</p><ul class=""><li id="d995" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">红色节点。</li><li id="628b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们的解决方案依赖的任何自定义节点。</li><li id="90cb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">作为<code class="du kc kd ke kf b">flows.yaml</code>文件的解决方案。这是您开发的流程的描述文件。</li><li id="eb68" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们的节点红色实例的配置设置。</li></ul><p id="6d7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从基本的节点-红色环境开始。一个基本的Docker镜像由Node-RED项目团队分发，可以在Docker Hub上找到，名为<a class="ae kg" href="https://hub.docker.com/r/nodered/node-red" rel="noopener ugc nofollow" target="_blank"> nodered/node-red </a>。这将是我们建设的基础。</p><p id="d5ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将看看如何添加任何必需的依赖项。当我们使用Node-RED时，我们可以添加在Node-RED注册表中找到的包。例如，我们将包括在<a class="ae kg" href="https://flows.nodered.org/node/node-red-contrib-google-cloud" rel="noopener ugc nofollow" target="_blank">node-red-contrib-Google-cloud</a>包中找到的GCP节点。为了在我们的新Docker图像中包含这一点，我们将添加:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="f19c" class="kp kq hi kf b fi kr ks l kt ku">RUN npm install node-red-contrib-google-cloud</span></pre><p id="115a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将被插入我们的docker文件。这将使用npm执行依赖项的安装。我们将对我们依赖的每个包重复这个命令。</p><p id="dc7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的Node-RED流在JSON中被描述在一个名为<code class="du kc kd ke kf b">flows.json</code>的文件中。当镜像开始执行时，它会在<code class="du kc kd ke kf b">/data</code>目录中寻找这个文件。这意味着我们应该将我们希望执行的<code class="du kc kd ke kf b">flows.json</code>插入到图像中。我们可以使用Dockerfile命令来做到这一点:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="8aba" class="kp kq hi kf b fi kr ks l kt ku">COPY flows.json /data</span></pre><p id="197e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本Dockerfile文件变成:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="e93a" class="kp kq hi kf b fi kr ks l kt ku">FROM nodered/node-red<br/>RUN npm install node-red-contrib-google-cloud<br/>COPY flows.json /data</span></pre><p id="9198" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一个Docker文件是一个很好的开始，但我们需要一种方法来创建Docker图像。我们当然可以在本地工作站上使用Docker，但由于这是一个GCP的故事，我们有一个更好的方法。首先，我们将在GCP工件注册中心创建一个存储库。这是图像将被存储的地方。</p><p id="d90d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦创建了存储库，我们仍然需要构建映像并将其添加到那里。这就是GCP云构建发挥作用的地方。云构建是一个GCP解决方案，用于在云中构建应用程序，我们提供构建方法，GCP完成其余工作。云构建的配置是通过一个名为cloudbuild.yaml的文件完成的。</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="6c3f" class="kp kq hi kf b fi kr ks l kt ku">steps:<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  args: [ 'build', '-t', 'us-central1-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE}', '.' ]<br/>images:<br/>- 'us-central1-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE}'</span></pre><p id="dd46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解释这些指令的方式是，我们将执行一个涉及运行Docker的云构建步骤。这一步将提供我们当前目录的内容，其中包括我们的docker文件。然后，它将构建一个图像，并用我们的存储库的名称标记该图像。接下来，我们将把该映像推送到存储库，这样就完成了。</p><p id="264f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">向云构建提交我们的请求的命令是:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="992b" class="kp kq hi kf b fi kr ks l kt ku">gcloud builds submit \<br/>  --config=cloudbuild.yaml \<br/>  --substitutions=_REPOSITORY="repo1",_IMAGE="my-node-red" .</span></pre><p id="0f63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kc kd ke kf b">_REPOSITORY</code>值是我们之前创建的工件存储库的名称。<code class="du kc kd ke kf b">_IMAGE</code>值是我们将作为输出创建的图像的名称。</p><p id="b1d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最终结果将是存储库中的图像。剩下的工作是我们创建一个运行图像的计算引擎。</p><p id="0fd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于计算引擎通过图像在存储库中的名称来识别图像，因此每次计算引擎启动或重启时，它都会选取最新的图像。为了部署新版本的Node-RED流，我们将更新我们的<code class="du kc kd ke kf b">flows.json</code>文件，并重新运行云构建步骤，这将产生一个新的映像。</p><p id="ba2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要介绍一些其他的项目。Node-RED的核心操作在一个名为<code class="du kc kd ke kf b">settings.js</code>的文件中有描述。当我们构建自己的自定义节点红色映像时，我们很可能会想要提供一个修改后的版本，因为开箱即用的值对于启动和运行来说非常好，但从安全角度来看是完全开放的。</p><p id="f541" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了提供我们自己的版本，我们假设您有一个已经定制的文件的本地副本。然后，我们会将以下内容添加到docker文件中:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="a9bc" class="kp kq hi kf b fi kr ks l kt ku">COPY settings.js .</span></pre><p id="b47b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kc kd ke kf b">settings.js</code>文件是一个富含注释的JavaScript文件。在这里，我们将看看我们应该立即改变的一些关键组件。我们要研究的第一个项目是连接到Node-RED并执行开发任务的能力。在我们当前的故事中，真的没有必要这样做。我们已经在单独的Node-RED环境中构建并测试了我们的流，现在我们专注于在生产中运行Node-RED。应该禁用直接登录和执行开发的功能。考虑一下负面影响，如果我们让它处于启用状态，一个坏的参与者设法登录并将他们自己的代码注入到环境中。</p><p id="e981" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要禁用编辑器，在<code class="du kc kd ke kf b">settings.js</code>中设置以下内容:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="b906" class="kp kq hi kf b fi kr ks l kt ku">httpAdminRoot: false,</span></pre><p id="98ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在部署中，如果我们在禁用编辑器后尝试访问它，将会收到以下形式的消息:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="a59f" class="kp kq hi kf b fi kr ks l kt ku">Cannot GET /</span></pre><p id="8b78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们查看docker日志，我们还会看到来自Node-RED的消息:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="92fd" class="kp kq hi kf b fi kr ks l kt ku">21 Mar 14:50:50 - [info] Admin UI disabled</span></pre><p id="e7a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果出于某种原因，我们<em class="kv">确实</em>希望允许编辑流，我们应该定义一个userid/password对来提供认证和授权。密码被添加到我们的<code class="du kc kd ke kf b">settings.js</code>文件中，并以散列格式存储在其中。这意味着，如果有人得到了文件，他们仍然不知道密码。哈希密码是使用以下方法创建的:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="a60a" class="kp kq hi kf b fi kr ks l kt ku">node-red-admin hash-pw</span></pre><p id="20e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，系统会提示我们输入密码，并返回密码的哈希值。一旦我们有了散列密码，我们可以将以下内容添加到我们的<code class="du kc kd ke kf b">settings.js</code>:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="f067" class="kp kq hi kf b fi kr ks l kt ku">adminAuth: {<br/>  type: "credentials",<br/>  users: [{<br/>    username: "admin",<br/>    password: "$2b$08$awfc2.vPIIPniD/DfmgcFePfFGR9goVfOMXXcuyQnNG2xGXkBoX3O",<br/>    permissions: "*"<br/>  }]<br/>},</span></pre><p id="beca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，密码是哈希值。完成这些更改后，任何登录编辑器的尝试都将导致一个安全提示:</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/2461094c57008dbdef483c8c19ef9e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n8k2Bh2EsIdrXglE"/></div></div></figure><p id="b7f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与安全性相关的最后一个领域是流量加密。默认情况下，Node-RED可以通过HTTP访问。这不同于更安全的HTTPS，后者使用TLS进行传输加密。我们可以设置Node-RED来使用HTTPS。为了做到这一点，我们需要一些TLS证书。在开发过程中，您可以使用自己生成的证书。</p><p id="4158" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过进入<code class="du kc kd ke kf b">/data</code>目录并运行以下命令来设置SSL支持:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="4190" class="kp kq hi kf b fi kr ks l kt ku">openssl req -x509 -newkey rsa:4096 -keyout privkey.pem -out cert.pem -days 365 -nodes -subj "/C=US/ST=Denial/L=Springfield/O=Dis/CN=<a class="ae kg" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a>"</span></pre><p id="c7e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将产生一个<code class="du kc kd ke kf b">privkey.pem</code>和一个<code class="du kc kd ke kf b">cert.pem</code>。这些应该复制到映像中。确保将文件设置为具有“node-red”的所有者和组:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="b809" class="kp kq hi kf b fi kr ks l kt ku">COPY --chown=node-red:node-red privkey.pem /data<br/>COPY --chown=node-red:node-red cert.pem /data</span></pre><p id="107f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们可以编辑<code class="du kc kd ke kf b">settings.js</code>并更改:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="fefc" class="kp kq hi kf b fi kr ks l kt ku">https: {<br/>   key: require("fs").readFileSync('/data/privkey.pem'),<br/>   cert: require("fs").readFileSync('/data/cert.pem')<br/>},</span></pre><p id="07fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们配置的最终docker文件变成了:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="3e9a" class="kp kq hi kf b fi kr ks l kt ku">FROM nodered/node-red<br/>RUN npm install node-red-contrib-google-cloud<br/>COPY --chown=node-red:node-red flows.json /data<br/>COPY --chown=node-red:node-red settings.js /data<br/>COPY --chown=node-red:node-red privkey.pem /data<br/>COPY --chown=node-red:node-red cert.pem /data</span></pre><p id="6c01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果部署没有正常工作，我们可能需要查看容器的日志。最简单的方法是SSH到计算引擎并运行:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="1b68" class="kp kq hi kf b fi kr ks l kt ku">docker ps</span></pre><p id="15fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这里我们将能够找到容器ID，然后我们可以运行:</p><pre class="kh ki kj kk fd kl kf km kn aw ko bi"><span id="462a" class="kp kq hi kf b fi kr ks l kt ku">docker logs &lt;ContainerID&gt;</span></pre><p id="9ec1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后…这里有一个视频，演示了本文中描述的每个步骤。视频是为这篇文章设计的，所以请在观看视频前先阅读文章。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="1a7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另请参见:</p><ul class=""><li id="72a0" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae kg" href="https://nodered.org/" rel="noopener ugc nofollow" target="_blank">节点-红色主页</a></li><li id="f5fb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" href="https://cloud.google.com/blog/products/application-development/using-node-red-with-google-cloud" rel="noopener ugc nofollow" target="_blank">博客:Node-RED低代码编程来到GCP—2020–02</a></li><li id="ef23" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" rel="noopener" href="/google-cloud/gcp-document-ai-and-node-red-d062d7d7768e">文章:GCP文档AI和Node-RED </a></li></ul></div></div>    
</body>
</html>