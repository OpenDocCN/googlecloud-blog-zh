<html>
<head>
<title>Choosing an init process for running multiple processes in containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为在容器中运行多个进程选择一个init进程</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/init-process-for-containers-d03a471fa0cc?source=collection_archive---------1-----------------------#2019-07-15">https://medium.com/google-cloud/init-process-for-containers-d03a471fa0cc?source=collection_archive---------1-----------------------#2019-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="eaa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您正在开发容器，您一定听说过“每个容器一个进程”这句话。从本质上来说，<a class="ae jd" href="https://github.com/just-containers/s6-overlay/tree/fca73dc6d74708554702759ac168e5e3fd68662f#the-docker-way" rel="noopener ugc nofollow" target="_blank">在一个容器</a>中运行多个进程并没有什么不对，只要你的<code class="du je jf jg jh b">ENTRYPOINT</code>是一个合适的<a class="ae jd" href="https://en.wikipedia.org/wiki/Init" rel="noopener ugc nofollow" target="_blank">初始化进程</a>。一些用例是让进程互相帮助(例如sidecar代理进程)或移植遗留应用程序。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/a8b1a8fb9f1c64430235973026716f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0f34AYyLNm5LveUlO0T0A.png"/></div></div></figure><p id="2f28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我不得不在一个容器中生成一个sidecar进程。Docker自己的关于在一个容器中运行多个进程的教程<a class="ae jd" href="https://docs.docker.com/config/containers/multi-service_container/" rel="noopener ugc nofollow" target="_blank">是一个很好的起点，但是还不能投入生产。</a></p><p id="cd39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我<a class="ae jd" href="https://twitter.com/ahmetb/status/1149314533040594950" rel="noopener ugc nofollow" target="_blank">将我的任务</a>(交给Twitterverse)外包出去，寻找一个针对容器优化的<code class="du je jf jg jh b">init</code>替代品，它可以:</p><ol class=""><li id="7059" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">运行多个子进程，但不要重新启动它们</li><li id="081c" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">一旦子进程终止就退出(没有必要重启子进程，让容器崩溃，由docker或Kubernetes重启)</li><li id="5649" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">履行PID 1 ( <code class="du je jf jg jh b">init</code>进程)职责，如<a class="ae jd" href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/" rel="noopener ugc nofollow" target="_blank">僵尸小孩收割</a>和信号转发</li><li id="ee7e" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">愉快地安装在docker文件中并在容器中运行</li></ol><p id="9bc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我探讨了一些选项的利弊，例如:</p><ul class=""><li id="4a6a" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">超级管理者，</li><li id="acff" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated"><a class="ae jd" href="http://smarden.org/runit/" rel="noopener ugc nofollow" target="_blank"> runit </a>，</li><li id="26bc" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated"><a class="ae jd" href="https://mmonit.com/monit/" rel="noopener ugc nofollow" target="_blank">莫尼特</a></li><li id="b700" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated"><a class="ae jd" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank">蒂尼</a> / <a class="ae jd" href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html" rel="noopener ugc nofollow" target="_blank">哑-初始</a>，</li><li id="2105" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated"><a class="ae jd" href="https://skarnet.org/software/s6/" rel="noopener ugc nofollow" target="_blank"> s6 </a> ( <em class="kj">观众喜爱的</em>)，以及</li><li id="30bc" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated"><a class="ae jd" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank">TiNi</a>+bash 4 . x combo(<em class="kj">我个人最喜欢的</em>)。</li></ul><p id="303b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始吧:</p><h1 id="1cac" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">超级监管者</h1><p id="24ec" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Supervisord来自我们人类积极管理Linux服务器和我们在其上运行的守护进程的时代。与编写upstart/systemd脚本来监控服务相比，它给出了一个更高层次的<a class="ae jd" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-manage-supervisor-on-ubuntu-and-debian-vps" rel="noopener ugc nofollow" target="_blank">抽象。</a></p><p id="ee64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="b763" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">易于学习和使用的服务配置语言</li></ul><p id="4c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="700b" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">在容器映像中需要Python运行时(通常不可行)</li><li id="0f53" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">要求您编写一个配置文件(supervisord.conf)</li><li id="9c1b" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">当一个被监督的进程终止时，不允许你退出，因为supervisord本身是无限期运行的。</li></ul><h1 id="98ed" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><a class="ae jd" href="https://mmonit.com/monit/" rel="noopener ugc nofollow" target="_blank"> monit </a></h1><p id="9293" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Monit相当不错，但是它需要一个用相当复杂的DSL编写的配置文件，并且它的子进程监督是面向pidfile的，这对于我正在尝试做的事情来说是一个大材小用。</p><p id="07ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="0687" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">小(用C编写)，适合捆绑在一个容器图像中</li></ul><p id="610b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="165b" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">需要你写一个配置文件</li><li id="dda6" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">通过<em class="kj">用pidfiles间隔轮询</em>来检查儿童健康(而不是通过SIGCHLD信号)</li><li id="260e" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">当进程终止时不允许退出(倾向于重启进程)</li></ul><p id="fd93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">runit是sysvinit、upstart或systemd等操作系统级进程的合法替代品——对于容器来说，这是一个大材小用。</p><h1 id="efe9" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><a class="ae jd" href="https://skarnet.org/software/s6/" rel="noopener ugc nofollow" target="_blank"> s6 </a>(观众最爱)</h1><p id="9930" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">随着s6-overlay项目及其令人敬畏的文档，我从安德烈·巴兰、乔·米勒、保罗·汀斯利、瓦迪姆·克鲁斯和T21那里得到了很多twitter回复。以后如何使用这个我会单独写一篇文章。</p><p id="e2a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="5514" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">小(用C编写)，适合捆绑在一个容器图像中</li><li id="3c3a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">感谢<a class="ae jd" href="https://github.com/just-containers/s6-overlay" rel="noopener ugc nofollow" target="_blank"> s6-overlay </a>，针对docker容器图像进行了优化</li><li id="2818" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">通过创建包含<code class="du je jf jg jh b">run</code>和<code class="du je jf jg jh b">finish</code>脚本的<code class="du je jf jg jh b">/etc/services/{name}/</code>目录来声明服务模型。</li><li id="386c" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">可以在子进程退出时自行终止</li></ul><h1 id="7665" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><a class="ae jd" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"> tini </a>或<a class="ae jd" href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html" rel="noopener ugc nofollow" target="_blank">哑初始化</a></h1><p id="0735" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"> tini </a>和<a class="ae jd" href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html" rel="noopener ugc nofollow" target="_blank"> dumb-init </a>都是专门为Docker容器编写的，因为大多数容器入口点进程(比如python、java)都不能很好地履行<code class="du je jf jg jh b">PID 1</code>职责。</p><p id="c8cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当您使用<code class="du je jf jg jh b">--init</code>选项执行<code class="du je jf jg jh b">docker run</code>命令时，您的容器的原始入口点将被替换为<code class="du je jf jg jh b">tini</code>，并作为其子进程执行。</p><p id="d6ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="00e2" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">小型(用C编写)和容器优化</li><li id="50c7" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">经过生产强化，适合在容器中工作</li></ul><p id="48f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="aef9" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">无法运行多个直接子进程，因为它被设计为只有一个子进程(这是docker容器的原始入口点)</li></ul><h1 id="92bb" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><a class="ae jd" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"> tini </a> + bash 4.x</h1><p id="3611" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">这不是一个完整的解决方案，但如果您不关心优雅的终止(通过信号转发到孩子)，它可以完成工作。</p><p id="e31e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于tini(1)无法单独运行多个子进程，<code class="du je jf jg jh b">bash</code>为我们提供了一个退路:拥有一个bash脚本入口点，您可以在后台启动进程，当其中一个后台进程使用bash内置<code class="du je jf jg jh b">wait -n</code>(在bash-4.3中引入)终止时<strong class="ih hj">立即退出</strong>:</p><pre class="jj jk jl jm fd ln jh lo lp aw lq bi"><span id="08a4" class="lr kl hi jh b fi ls lt l lu lv">#!/usr/bin/env bash<br/>set -e<br/><br/>program1 &amp;<br/>program2 &amp;<br/>wait -n</span></pre><p id="c728" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在docker文件中，修改入口点:</p><pre class="jj jk jl jm fd ln jh lo lp aw lq bi"><span id="8b08" class="lr kl hi jh b fi ls lt l lu lv">ENTRYPOINT ["/bin/tini", "--", "entrypoint.sh"]</span></pre><p id="d933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="ac82" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">tini(1)是容器优化和小，处理僵尸收割等。</li><li id="1bbd" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">当子进程退出时容易终止(同时保留退出代码)</li></ul><p id="f2fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="5cf6" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ki ka kb kc bi translated">没有信号转发:你的容器仍然会退出，但是你失去了优雅终止的机会。</li><li id="7c44" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">您必须编写一个小的定制bash脚本entrypoint并发布bash 4.x</li><li id="e4e6" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ki ka kb kc bi translated">类似地，当一个子进程终止时，另一个进程不会得到正常的终止通知，因为bash会直接退出。</li></ul><h1 id="f152" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="97f6" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">我从我发起的Twitter帖子中学到了很多关于init进程的知识。非常感谢那些参与讨论的人(<a class="ae jd" href="https://twitter.com/tiborvass" rel="noopener ugc nofollow" target="_blank">蒂博尔·瓦斯</a>、<a class="ae jd" href="https://twitter.com/andrej_baran" rel="noopener ugc nofollow" target="_blank">安德烈·巴兰</a>、<a class="ae jd" href="https://twitter.com/rpkatz" rel="noopener ugc nofollow" target="_blank">里卡多·卡茨</a>、<a class="ae jd" href="https://twitter.com/miller_joe" rel="noopener ugc nofollow" target="_blank">乔·米勒</a>、<a class="ae jd" href="https://twitter.com/ptinsley" rel="noopener ugc nofollow" target="_blank">保罗·汀斯利</a>、<a class="ae jd" href="https://twitter.com/berkulsoy/" rel="noopener ugc nofollow" target="_blank">伯克·索尔斯</a>和<a class="ae jd" href="https://twitter.com/wadimkr" rel="noopener ugc nofollow" target="_blank">瓦迪姆·克鲁斯</a>和<a class="ae jd" href="https://twitter.com/vdemeest" rel="noopener ugc nofollow" target="_blank">文森特·德梅斯特</a>)</p><p id="e38a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望在一篇新的博客文章中跟进一个使用<a class="ae jd" href="https://github.com/just-containers/s6-overlay" rel="noopener ugc nofollow" target="_blank"> s6-overlay </a>在一个容器映像中运行多个流程的例子。</p><p id="29eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与此同时，请阅读我的新文章:<a class="ae jd" href="https://ahmet.im/blog/cloud-run-multiple-processes-easy-way/" rel="noopener ugc nofollow" target="_blank">云运行:在一个容器中运行多个流程(懒惰的方式)</a>，它采用了tini+bash4.x解决方案。</p><blockquote class="lw lx ly"><p id="e06b" class="if ig kj ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">[1]理想情况下，您应该真正避免在每个容器中运行多个进程，这是有很多理由的。尤其是在Kubernetes上，您应该使用带有多个容器的pod，这些容器共享同一个PID名称空间，并且它们会自动获得一个init进程。(又名<code class="du je jf jg jh b">pause</code>容器)。</p></blockquote></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="6e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kj">原载于2019年7月15日</em><a class="ae jd" href="https://ahmet.im/blog/minimal-init-process-for-containers/" rel="noopener ugc nofollow" target="_blank"><em class="kj">Ahmet . im</em></a><em class="kj">。</em></p></div></div>    
</body>
</html>