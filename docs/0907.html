<html>
<head>
<title>Prometheus and Stackdriver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">普罗米修斯和斯塔克德瑞弗</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/prometheus-and-stackdriver-fb8f7524ece0?source=collection_archive---------0-----------------------#2019-02-05">https://medium.com/google-cloud/prometheus-and-stackdriver-fb8f7524ece0?source=collection_archive---------0-----------------------#2019-02-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="a7ad" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="5c1b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Kubernetes的“新”Stackdriver监控自2018年5月左右首次发布本<a class="ae kb" href="https://cloud.google.com/blog/products/gcp/announcing-stackdriver-kubernetes-monitoring-comprehensive-kubernetes-observability-from-the-start" rel="noopener ugc nofollow" target="_blank">公告</a>以来一直处于公开测试阶段。从那以后，我花了相当多的时间研究它，其中一个我真正想更好理解的领域是它与<a class="ae kb" href="http://prometheus.io" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>的集成。我以前也从未真正使用过Prometheus，所以我也需要获得该工具的一些基本知识——特别是当我不断从客户那里听说它时，他们经常想知道如何在搬到GKE后继续使用它，或者如何用Stackdriver替换和/或补充它。下面是我尝试演示“GKE上的普罗米修斯与斯塔克德瑞”——从零开始。和<a class="ae kb" rel="noopener" href="/google-cloud/introduction-to-stackdriver-profiler-614b580b978a">剖析器</a>一样，我也想看看我是否能理解如何用多种语言编写代码。让我们看看会发生什么？</p><h1 id="ee3c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">普罗米修斯基础</h1><p id="99e6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我需要学习的第一件事是——第一件事。什么是普罗米修斯？它是如何工作的？在这个练习中，对我来说最重要的是——指标是如何工作的？幸运的是，有人出色地记录了我需要的东西。你可以在这里找到他们的系列<a class="ae kb" href="https://blog.pvincent.io/2017/12/prometheus-blog-series-part-1-metrics-and-labels/" rel="noopener ugc nofollow" target="_blank">，但是我需要从他们的帖子中了解和学习的关键事情是:</a></p><ul class=""><li id="bca7" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">有4种主要的度量类型——计数器(递增的)、计量器(上升和下降的)、摘要和直方图</li><li id="c299" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">为了让Prometheus从应用程序接收指标，应用程序需要公开一个具有可用指标值的专用端点(通常为/metrics)</li><li id="69ed" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">如果应用程序已经在某个地方写了度量(比如数据库或文件)，您可以创建一个Prometheus exporter来读取这些度量，然后公开它们</li><li id="b264" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">您需要一个存储指标的Prometheus服务器</li></ul><p id="613c" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我很确定我错过了很多东西。例如，我仍然不太理解注册表的概念，但这些信息足以让我工作。现在我们已经有了基本的东西，让我们开始实际操作吧。</p><h1 id="691b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在GKE上安装普罗米修斯并验证</h1><p id="eb51" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我开始演示如何在一个简单的应用程序中导出Prometheus指标，并让Stackdriver获取它们来测试Prometheus集成。令人欣慰的是，Stackdriver团队已经做了很好的工作，记录了实现这一目标所需的步骤。不管怎样，我们走一遍。</p><h1 id="637d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建GKE集群</h1><p id="2c1a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们需要创建一个集群。我们希望确保选择“新的”Stackdriver监控和日志记录配置。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="cce5" class="le ig hi la b fi lf lg l lh li">gcloud beta container --project "&lt;your project ID" \</span><span id="a644" class="le ig hi la b fi lj lg l lh li">clusters create "prometheus-demo-cluster" \</span><span id="edf3" class="le ig hi la b fi lj lg l lh li">--zone "&lt;desired zone&gt;" \</span><span id="f97f" class="le ig hi la b fi lj lg l lh li">--cluster-version "latest" \</span><span id="d0e9" class="le ig hi la b fi lj lg l lh li"><strong class="la hj">--enable-stackdriver-kubernetes</strong></span></pre><h1 id="340e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">安装普罗米修斯</h1><p id="64e9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来，我们需要在集群中安装Prometheus。根据兼容性<a class="ae kb" href="https://github.com/Stackdriver/stackdriver-prometheus-sidecar#compatibility" rel="noopener ugc nofollow" target="_blank">矩阵</a>，我想尽可能使用最新版本，在撰写本文时，是2.6.1。我以前从来没有真正安装过它，但是一分钟的搜索就找到了这个<a class="ae kb" href="https://devopscube.com/setup-prometheus-monitoring-on-kubernetes/" rel="noopener ugc nofollow" target="_blank">指南</a>，我也跟着看了。我不确定在这里重复这些步骤有多大价值，但我想捕捉我的经验，以防我需要再次这样做。</p><p id="8c1c" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">首先，我需要将自己设置为集群中的管理员:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ad1f" class="le ig hi la b fi lf lg l lh li">ACCOUNT=$(gcloud info --format='value(config.account)')</span><span id="7625" class="le ig hi la b fi lj lg l lh li">kubectl create clusterrolebinding owner-cluster-admin-binding \</span><span id="abe1" class="le ig hi la b fi lj lg l lh li">--clusterrole cluster-admin \</span><span id="8b1b" class="le ig hi la b fi lj lg l lh li">--user $ACCOUNT</span></pre><p id="0ffc" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">然后，我为Prometheus组件创建了一个专用的名称空间:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4558" class="le ig hi la b fi lf lg l lh li">kubectl create namespace prometheus</span></pre><p id="16a6" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">然后，我通过创建一个新角色，授予这个名称空间集群读取器权限。我复制了这个<a class="ae kb" href="https://raw.githubusercontent.com/bibinwilson/kubernetes-prometheus/master/clusterRole.yaml" rel="noopener ugc nofollow" target="_blank">文件</a>,并简单地将最后的名称空间名称改为“prometheus ”,而不是“monitoring”。我保存了文件并创建了角色:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="2c39" class="le ig hi la b fi lf lg l lh li">$ kubectl create -f clusterRole.yaml</span><span id="a639" class="le ig hi la b fi lj lg l lh li">clusterrole.rbac.authorization.k8s.io/prometheus created</span><span id="bb2a" class="le ig hi la b fi lj lg l lh li">clusterrolebinding.rbac.authorization.k8s.io/prometheus created</span></pre><p id="6bd5" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">下一步是为抓取和警报规则创建配置映射。我复制了这个<a class="ae kb" href="https://raw.githubusercontent.com/bibinwilson/kubernetes-prometheus/master/config-map.yaml" rel="noopener ugc nofollow" target="_blank">文件</a>，再次用“prometheus”替换对“monitoring”名称空间的引用，并应用它:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1a60" class="le ig hi la b fi lf lg l lh li">$ kubectl create -f configMap.yaml -n prometheus</span><span id="8d25" class="le ig hi la b fi lj lg l lh li">configmap/prometheus-server-conf created</span></pre><p id="8e62" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">接下来，按照指南，我为Prometheus部署创建了一个. yaml <a class="ae kb" href="https://github.com/yuriatgoogle/prometheus-demo/blob/master/kubernetes/prometheus-deployment.yaml" rel="noopener ugc nofollow" target="_blank">文件</a>，再次替换了名称空间引用和(重要的是！)更新参考2.6.1的Prometheus版本，并创建部署:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b3ea" class="le ig hi la b fi lf lg l lh li">$ kubectl create -f prometheus-deployment.yaml -n prometheus</span><span id="1a7d" class="le ig hi la b fi lj lg l lh li">deployment.extensions/prometheus-deployment created</span></pre><p id="e94b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">让我们检查一下，确保一切正常运行:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3441" class="le ig hi la b fi lf lg l lh li">$ kubectl get pods -n prometheus</span><span id="fe5a" class="le ig hi la b fi lj lg l lh li">NAME                                    READY   STATUS    RESTARTS   AGE</span><span id="80e2" class="le ig hi la b fi lj lg l lh li">prometheus-deployment-7ddb99dcb-fkz4d   1/1     Running   0          1m</span></pre><p id="85d0" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">最后，让我们通过将pod端口转发到localhost来检查以确保它工作正常:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="789a" class="le ig hi la b fi lf lg l lh li">$ kubectl port-forward prometheus-deployment-7ddb99dcb-fkz4d 8080:9090 -n prometheus</span><span id="d0f7" class="le ig hi la b fi lj lg l lh li">Forwarding from 127.0.0.1:8080 -&gt; 9090</span><span id="f5de" class="le ig hi la b fi lj lg l lh li">Forwarding from [::1]:8080 -&gt; 9090</span></pre><p id="09d6" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在，当我去<a class="ae kb" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>时，我可以看到这个:</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/28711757a0b5dc69ef67d9eb50b3e3d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TkWiqsmxcMs8Bo_r"/></div></div></figure><h1 id="02dc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">安装Stackdriver收集器</h1><p id="4fa9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经在集群中运行了Prometheus，我们需要安装Stackdriver收集器来将这些指标导出到Stackdriver后端。这明明是<a class="ae kb" href="https://cloud.google.com/monitoring/kubernetes-engine/prometheus" rel="noopener ugc nofollow" target="_blank">记载的</a>；首先，我在本地复制了这个<a class="ae kb" href="https://raw.githubusercontent.com/Stackdriver/stackdriver-prometheus-sidecar/master/kube/patch.sh" rel="noopener ugc nofollow" target="_blank">文件</a>。然后，我设置了所需的环境变量:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="035a" class="le ig hi la b fi lf lg l lh li">export KUBE_NAMESPACE=prometheus</span><span id="308b" class="le ig hi la b fi lj lg l lh li">export KUBE_CLUSTER=prometheus-demo-cluster</span><span id="c7e9" class="le ig hi la b fi lj lg l lh li">export GCP_REGION=&lt;my region&gt;</span><span id="a439" class="le ig hi la b fi lj lg l lh li">export GCP_PROJECT=&lt;my project ID&gt;</span><span id="551e" class="le ig hi la b fi lj lg l lh li">export DATA_DIR=/prometheus/</span><span id="219d" class="le ig hi la b fi lj lg l lh li">export DATA_VOLUME=prometheus-storage-volume</span><span id="d506" class="le ig hi la b fi lj lg l lh li">export SIDECAR_IMAGE_TAG=release-0.3.2</span></pre><p id="594e" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我运行了补丁脚本:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="a098" class="le ig hi la b fi lf lg l lh li">$ sh ./patch.sh deployment prometheus-deployment</span><span id="9821" class="le ig hi la b fi lj lg l lh li">deployment.extensions/prometheus-deployment patched</span></pre><p id="c039" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在，Stackdriver收集器在Prometheus吊舱中作为边车容器运行:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="6720" class="le ig hi la b fi lf lg l lh li">$ kubectl get pods -n prometheus</span><span id="a079" class="le ig hi la b fi lj lg l lh li">NAME                                     READY   STATUS    RESTARTS   AGE</span><span id="81c1" class="le ig hi la b fi lj lg l lh li">prometheus-deployment-744758f7cc-v6zqx   2/2     Running   2          1m</span></pre><p id="cf94" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">最后，我们准备看看是否有普罗米修斯指标出现在Stackdriver中。</p><p id="10f9" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">请注意，虽然对这种集成的支持还处于测试阶段，但每个项目有1000个普罗米修斯指标的限制。如果遇到这种情况，您应该能够在日志记录中找到一条“超过配额”的消息。</p><p id="77af" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我转到Metrics Explorer，过滤到我正在使用的集群，果然，它们就在那里！</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/d7e76e8b21ea87b0b373484cad8cf850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CHd3ZKZiwTSQ0sQ6"/></div></div></figure><p id="33be" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在，我准备在我的代码中做一些检测。</p><h1 id="5eff" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在应用程序中导出普罗米修斯指标</h1><p id="ab25" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我应该注意到，虽然我是从零开始，但是大多数人可能已经运行过Prometheus(在这种情况下不需要任何关于检测的信息)或者正在寻找检测选项。在后一种情况下，我们可能会引导他们走向<a class="ae kb" href="https://cloud.google.com/monitoring/custom-metrics/open-census" rel="noopener ugc nofollow" target="_blank"> OpenCensus </a>，而不是从普罗米修斯仪器开始，我希望很快有机会用OpenCensus做类似的练习。</p><h1 id="86be" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">计算机编程语言</h1><p id="9731" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我的意图很简单。我只想创建一个“Hello World”应用程序，它会在每次页面被点击时创建一个随机数，并在Stackdriver中将该数字显示为普罗米修斯度量。我不得不做一些关于如何做到这一点的研究，但是我发现了两个非常有用的资源。首先是普罗米修斯Python客户端<a class="ae kb" href="https://github.com/prometheus/client_python" rel="noopener ugc nofollow" target="_blank">本身</a>。第二个是别人发的一篇<a class="ae kb" rel="noopener" href="/@andrei.chernyshev/prometheus-python-flask-8487c3bc5b36">帖子</a>，解释了如何使用Flask中的客户端。有了这些信息，我勇往直前。</p><p id="182d" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">首先，我创建了一个基本的Flask应用程序。我导入了Prometheus客户机，并创建了一个基本的度量标准，每次访问主页时，我都将其设置为一个随机值。然后，我为/metrics创建了第二个Flask route，它公开了度量。你可以在这里看到完整的app.py文件<a class="ae kb" href="https://github.com/yuriatgoogle/prometheus-demo/blob/master/python/app.py" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="2f82" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">接下来，我需要从这个应用程序创建一个可以在GKE上运行的容器图像。我使用“pip freeze”保存了我的Python包<a class="ae kb" href="https://github.com/yuriatgoogle/prometheus-demo/blob/master/python/requirements.txt" rel="noopener ugc nofollow" target="_blank">状态</a>,并尽我所能创建了最基本的Dockerfile文件:</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="0338" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我使用Google Cloud Build创建了这个图像:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="d98a" class="le ig hi la b fi lf lg l lh li">gcloud builds submit — tag gcr.io/[project ID]/prometheus-demo-python .</span></pre><p id="95b7" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">第一次尝试就成功了！</p><p id="dab7" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">在GKE部署之前，我想在本地测试一下，以确保一切正常。我使用“docker run”运行图像:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="d636" class="le ig hi la b fi lf lg l lh li">$ docker run -p 8080:8080 gcr.io/[project ID]/prometheus-demo-python:latest</span></pre><p id="fea9" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">果然，我能够在/metrics上看到普罗米修斯指标:</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lu"><img src="../Images/48248fb723412c9c5146db859e2fce11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VyNTEmf8SmcaTcP0"/></div></div></figure><p id="8cea" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在，我需要定义我将用来在GKE上运行它的部署。我创建了一个. yaml <a class="ae kb" href="https://github.com/yuriatgoogle/prometheus-demo/blob/master/python/prometheus-demo.yaml" rel="noopener ugc nofollow" target="_blank">文件</a>来引用我的新图像。这里要注意的关键是这一部分，它告诉普罗米修斯从哪里获取度量:</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="a877" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我创建了部署:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="afa8" class="le ig hi la b fi lf lg l lh li">$ kubectl apply -f ./prometheus-demo.yaml</span><span id="7e78" class="le ig hi la b fi lj lg l lh li">deployment.extensions/prometheus-demo-python created</span></pre><p id="aa33" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">并使用负载平衡器来公开它:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="30c5" class="le ig hi la b fi lf lg l lh li">$ kubectl expose deployment prometheus-demo-python --type=LoadBalancer --port 8080</span><span id="421f" class="le ig hi la b fi lj lg l lh li">service/prometheus-demo-python exposed</span></pre><p id="ae79" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在，我可以在通过运行“kubectl get services”获得的外部IP上看到相同的/metrics页面。最后，是时候使用Metrics Explorer来查看我创建的随机值度量是否显示在Stackdriver中了:</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lv"><img src="../Images/b237dbd8c133602e29479138e63351e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4VFGuSRHQAZb7Uhy"/></div></div></figure><p id="f1d8" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">就在那里！</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/105c438037e9692a206f208d89ae5fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kw-Y7V6EVENAGpBD"/></div></div></figure><p id="666b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这太酷了！现在，让我们看看我是否能在围棋中做同样的事情？</p><h1 id="4b2e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">去</h1><p id="919c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">和以前一样，我需要四处看看，以了解如何用Prometheus检测我的(非常基本的)代码。我创建了一个基本的应用程序，并找到了Golang Prometheus <a class="ae kb" href="https://github.com/prometheus/client_golang" rel="noopener ugc nofollow" target="_blank">客户端</a>和一个<a class="ae kb" href="https://prometheus.io/docs/guides/go-application/" rel="noopener ugc nofollow" target="_blank">向导</a>来安装我的应用程序——两者都直接来自Prometheus。这足以让我继续前进。这里可以看到应用代码<a class="ae kb" href="https://github.com/yuriatgoogle/prometheus-demo/blob/master/go/main.go" rel="noopener ugc nofollow" target="_blank">。这里需要注意的是,/ route和/metrics路由实际上有两个独立的处理程序。第一个由http处理。ResponseWriter，而/metrics由promhttp处理。至少对我来说这很有趣！</a></p><p id="23e2" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在我的代码已经写好了，我需要用它构建一个容器映像，这样我就可以把它部署到GKE。以下是我使用云构建来构建映像的Dockerfile文件:</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="e442" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我花了一段时间才明白，为了让代码实际运行，我需要在order文件中包含构建步骤。这篇<a class="ae kb" href="https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/" rel="noopener ugc nofollow" target="_blank">帖子</a>非常有帮助，尽管我从来没有想出如何让我的图像变得那么小。然而，它建成并运行！</p><p id="932b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我再次使用“docker run”在本地测试该映像，以确保我看到了/metrics，特别是我创建的<em class="lw"> go_random_value </em>指标:</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lx"><img src="../Images/ea58ee5fa62fd618c6f8dcbdc4533004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N4g6bPPP3b6gelJ7"/></div></div></figure><p id="f2b9" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在，我准备部署到GKE。我复制了部署。yaml文件，注意修改Prometheus scrape设置以引用运行该服务的端口(8081而不是8080)，用go替换所有对Python的引用，并将其指向新的go映像。然后，我在一个不同的端口(同样是8081)上使用一个负载均衡器来公开部署，并检查是否可以在那个外部IP上使用/metrics端点。最后，我准备好查看go_random_value度量是否在Stackdriver中——它在！</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/dc7d18bf4673ea75b0144a2ad3651efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mN-rVPoI9i-kNsuT"/></div></div></figure><h1 id="9cf8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">节点. js</h1><p id="e321" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我想尝试的最后一个语言是Node.js，经过一番搜索，我发现没有一个来自Prometheus的“官方”客户端，但<a class="ae kb" href="https://github.com/siimon/prom-client" rel="noopener ugc nofollow" target="_blank">这个</a>似乎是标准。同样，我使用Express构建了一个简单的Hello World <a class="ae kb" href="https://github.com/yuriatgoogle/prometheus-demo/blob/master/node/app.js" rel="noopener ugc nofollow" target="_blank">应用程序</a>，它设置了一个随机值，并确保它在本地工作。</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="6a97" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这里需要注意的一点是，我的“用户”度量是列表中的第一个，这无疑使验证更加容易！</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div class="er es ly"><img src="../Images/3a7a124061254c91d0abefac2e50f7e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/0*2FcJkgaf8t9EoO2R"/></div></figure><p id="085b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">然后，我创建了一个docker文件，使用Cloud Build构建了映像，使用docker run在本地对其进行了测试，并以与之前相同的方式将其部署到我的集群中。果然node _ random _ value指标和其他指标一样显示在Stackdriver中！</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lz"><img src="../Images/6f12d47e9e55911f8cf0b0b37b8763d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NRp_fez5P47sGGL9"/></div></div></figure><h1 id="af93" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="9361" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我真的很喜欢这个练习，因为它让我有机会学习普罗米修斯的基础知识，迫使我回忆(学习？)如何为不同的语言创建Dockerfiles，并教会我如何让这些Prometheus metrics在Stackdriver中显示出来。后来，我可以看到进入管理时间序列标签，其他数据类型(如直方图？)，或者说如何在“生产中”实际操作普罗米修斯。但是我们现在就离开这里——谢谢你坚持到最后！如果你对代码或配置文件感兴趣，我已经在这个<a class="ae kb" href="https://github.com/yuriatgoogle/prometheus-demo" rel="noopener ugc nofollow" target="_blank">报告</a>中提供了它们。</p></div></div>    
</body>
</html>