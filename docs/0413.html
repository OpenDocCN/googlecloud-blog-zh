<html>
<head>
<title>Kubernetes Canary deployments 🐤 for mere mortals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes金丝雀部署🐤对于凡人来说</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-canary-deployments-for-mere-mortals-13728ce032fe?source=collection_archive---------0-----------------------#2017-10-24">https://medium.com/google-cloud/kubernetes-canary-deployments-for-mere-mortals-13728ce032fe?source=collection_archive---------0-----------------------#2017-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5e80" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">以及如何安全可靠地推出软件版本</h2></div><blockquote class="ix iy iz"><p id="e532" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">最初发布于<a class="ae jx" href="https://blog.dockbit.com/kubernetes-canary-deployments-for-mere-mortals-6696910a52b2" rel="noopener ugc nofollow" target="_blank"> Dockbit博客</a></p></blockquote><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/8e095ae6f8488c42cae2648c27519e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8p-jLv62-RSIrRzkN8M3uA.png"/></div></div></figure><p id="3687" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">Canary部署是一种降低发布新软件版本风险的模式。<a class="ae jx" href="https://en.wikipedia.org/wiki/Domestic_canary#Miner.27s_canary" rel="noopener ugc nofollow" target="_blank">名字</a>背后的历史并不美好。但是在软件中，对于采用连续交付实践的团队来说，释放金丝雀可能是一种战略战术。</p><p id="0fd6" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这个想法是，您将把一个新的版本与它的稳定版本一起逐步地部署到一小组服务器上。一旦您测试了waters，您就可以将这些更改推广到基础架构的其余部分。</p><p id="e15f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这有效地向一小部分用户公开了新版本，作为可能发生的故障的早期指示器。金丝雀对于避免有问题的部署和愤怒的用户非常方便！如果一个canary部署失败，其余的服务器不会受到影响，您可以简单地放弃它并修复根本原因。</p><p id="e68d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">从历史上看，实施金丝雀部署是一件痛苦的事情，尤其是对小公司而言。团队甚至不得不在他们的应用核心中实现诸如<a class="ae jx" href="https://martinfowler.com/bliki/FeatureToggle.html" rel="noopener ugc nofollow" target="_blank">功能切换</a>的技术来实现类似的行为。</p><p id="f9a2" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">Docker容器等技术🐳使我们向前迈进了一步，但是我们仍然缺乏实现高级部署技术的高级工具。</p><p id="6575" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated"><strong class="jd hj">输入容器编排器和调度器</strong>🚀</p><p id="2af6" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">当您开始需要将容器分发到单台机器之外时，通常会使用调度器和编排器，因此它是排序之上的另一个管理层。但这不一定是你应该采用它们的唯一理由。</p><p id="6113" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">仅举几个例子，通过简单地为容器采用调度器，您可以“免费”获得一些好处:自我修复、水平伸缩、服务发现、负载分布、部署管理等等。</p><p id="9bd8" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这已经是一个巨大的胜利了。如果您今天在Docker镜像中发布软件，那么对您的日常工作流程非常有帮助的特性之一就是容器部署的管理。您必须手动协调在不同节点上提取新版本的Docker映像并重启服务的日子已经一去不复返了。管弦乐队可以为你提炼出一句俏皮话。</p><p id="437b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">虽然市场上有太多的选择:<a class="ae jx" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank">码头工人群</a>，<a class="ae jx" href="https://www.nomadproject.io" rel="noopener ugc nofollow" target="_blank">哈西科尔游牧者</a>，<a class="ae jx" href="https://mesosphere.github.io/marathon/" rel="noopener ugc nofollow" target="_blank">马拉松</a>；一个真正致力于使Docker容器部署可重复和简化的调度程序是Kubernetes。</p><p id="d7c2" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">Kubernetes(简称k8s)awesome sauce在于它提供了现成的高级部署技术。许多场景都不需要或只需要很少的黑客就可以支持。现在，是的，您必须将您的软件封装在Docker映像中，并设置您的Kubernetes对象(pod、复制集、部署等..)，但是你的投资得到了这么多的回报。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kn ko l"/></div></figure><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="kn ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">布伦丹·伯恩斯(k8s联合创始人)讲述k8s如何让你的生活更轻松</figcaption></figure><p id="e88c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">看到Canary部署的实际情况比谈论它们更令人兴奋，所以让我们亲自动手，深入研究一个基于k8s的示例设置。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="95da" class="la lb hi bd lc ld le lf lg lh li lj lk io ll ip lm ir ln is lo iu lp iv lq lr bi translated">概观</h1><p id="7eb2" class="pw-post-body-paragraph ja jb hi jd b je ls ij jg jh lt im jj kk lu jm jn kl lv jq jr km lw ju jv jw hb bi translated">这里是总体规划:首先，我们需要一个k8s集群来工作。一个Kubernetes集群由十几个<a class="ae jx" href="https://kubernetes.io/docs/concepts/overview/components/" rel="noopener ugc nofollow" target="_blank">组件</a>组成。为了快速启动，我们将关注用于创建集群的自动化工具，而不是通过艰难的方式创建集群。</p><p id="73c4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">对于本地测试，Minikube 将为您提供非常好的服务。为了得到更真实的设置，我们将使用由k8s驱动的<a class="ae jx" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank">谷歌容器引擎</a> (GKE)。它将负责在<a class="ae jx" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank"> GCP </a>上设置实例，安装所有k8s组件以及处理初始配置。</p><p id="f3b2" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">部署到k8s要求我们的应用程序以容器格式打包。对于本演练，我们将使用<a class="ae jx" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>运行时。示例应用程序的两个版本(Stable和Canary)都将打包在Docker图像中，不同版本的Docker图像标记为<a class="ae jx" href="https://docs.docker.com/engine/reference/commandline/tag/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="ab1e" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">我们将首先对k8s上的Canary版本进行简单的设置，然后升级它以使用更多的技巧。</p><h1 id="7158" class="la lb hi bd lc ld lx lf lg lh ly lj lk io lz ip lm ir ma is lo iu mb iv lq lr bi translated">阶段0:准备环境</h1><p id="9cab" class="pw-post-body-paragraph ja jb hi jd b je ls ij jg jh lt im jj kk lu jm jn kl lv jq jr km lw ju jv jw hb bi translated">以下是您在GCP上开始使用k8s所需的内容:</p><ul class=""><li id="bd82" class="mc md hi jd b je jf jh ji kk me kl mf km mg jw mh mi mj mk bi translated"><a class="ae jx" href="https://console.cloud.google.com/cloud-resource-manager" rel="noopener ugc nofollow" target="_blank">选择或创建</a>一个项目。这将所有使用的资源分开，以便以后更容易清理。</li><li id="9c7f" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated"><a class="ae jx" href="https://support.google.com/cloud/answer/6293499#enable-billing" rel="noopener ugc nofollow" target="_blank">为项目启用计费</a>。</li><li id="812e" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated"><a class="ae jx" href="https://console.cloud.google.com/flows/enableapi?apiid=compute_component,container" rel="noopener ugc nofollow" target="_blank">为计算引擎和容器引擎启用API</a>。这些将允许我们使用<a class="ae jx" href="https://cloud.google.com/sdk/gcloud/" rel="noopener ugc nofollow" target="_blank"> gcloud </a> CLI工具访问所需的资源。</li><li id="27b7" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated">如果您还没有安装最新版本的<a class="ae jx" href="https://cloud.google.com/sdk/docs/#install_the_latest_cloud_tools_version_cloudsdk_current_version" rel="noopener ugc nofollow" target="_blank"> gcloud </a>。或者，可以使用<a class="ae jx" href="https://console.cloud.google.com/?cloudshell=true" rel="noopener ugc nofollow" target="_blank">云壳</a>。</li><li id="e889" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated">最后，通过执行<code class="du mq mr ms mt b">gcloud components install kubectl</code>安装<code class="du mq mr ms mt b">kubectl</code>。</li></ul><p id="9c45" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">接下来，我们可以继续创建一个<a class="ae jx" href="https://cloud.google.com/container-engine/docs/concepts/cluster-architecture" rel="noopener ugc nofollow" target="_blank">容器引擎集群</a>。该集群由至少一台主机和多台工作机组成，将自动为我们创建。</p><ul class=""><li id="6b3f" class="mc md hi jd b je jf jh ji kk me kl mf km mg jw mh mi mj mk bi translated">获取<a class="ae jx" href="https://support.google.com/cloud/answer/6158840?hl=en" rel="noopener ugc nofollow" target="_blank">项目ID </a>并将其存储在变量<code class="du mq mr ms mt b">export PROJECT_ID=&lt;ID&gt;</code>中。</li><li id="1190" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated">设置要使用的项目:<code class="du mq mr ms mt b">gcloud config set project $PROJECT_ID</code>。</li><li id="7ad9" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated">设置默认的计算引擎区域，例如:<code class="du mq mr ms mt b">gcloud config set compute/zone us-east1-d</code>。</li><li id="ccf4" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated">最后，创建容器集群，这里我们称之为<code class="du mq mr ms mt b">canary</code>:<code class="du mq mr ms mt b">gcloud container clusters create canary</code>。</li></ul><p id="e4c0" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">如果事情按照计划进行，您将能够通过执行:<code class="du mq mr ms mt b">kubectl cluster-info</code>获得k8s组件端点。</p><p id="14cf" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">GitHub资源库中提供了即将发布的材料中使用的代码/配置:</p><div class="mu mv ez fb mw mx"><a href="https://github.com/DockbitExamples/kubernetes" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">DockbitExamples/kubernetes</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">kubernetes — Kubernetes示例</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">github.com</p></div></div></div></a></div><h1 id="1da4" class="la lb hi bd lc ld lx lf lg lh ly lj lk io lz ip lm ir ma is lo iu mb iv lq lr bi translated">第一阶段:应用程序</h1><p id="75eb" class="pw-post-body-paragraph ja jb hi jd b je ls ij jg jh lt im jj kk lu jm jn kl lv jq jr km lw ju jv jw hb bi translated">首先，我们需要一个app来部署！为了这篇文章，我们创建了一个简单的Go应用程序。Go程序编译成自给自足的可移植二进制文件，因此它们非常适合在Docker映像中使用。</p><p id="9981" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">同样的方法也适用于可以打包在Docker容器中的任何其他技术栈。无论是需要编译的语言如<a class="ae jx" href="https://elixir-lang.org" rel="noopener ugc nofollow" target="_blank"> Elixir </a>还是解释语言如<a class="ae jx" href="http://ruby-lang.org" rel="noopener ugc nofollow" target="_blank"> Ruby </a>或<a class="ae jx" href="https://www.python.org" rel="noopener ugc nofollow" target="_blank"> Python </a>。只是在后一种情况下，您需要包含代码本身，而不是工件。</p><p id="89fd" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">该应用程序打印出部署的版本以及一些操作要求:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/tree/master/source" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/tree/master/source</a>获得</figcaption></figure><p id="5b3d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第8–10行:将应用程序的版本存储在名为<code class="du mq mr ms mt b">version</code>的常量中，并通过Go的<a class="ae jx" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank"> http包</a>将其打印出来。注意<code class="du mq mr ms mt b">version</code>被设置为<code class="du mq mr ms mt b">1.0</code>，这将是我们稍后将在Docker映像中烘焙的第一个“稳定”版本。</p><p id="e92f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第14–15，24行:作为健康检查，如果请求命中<code class="du mq mr ms mt b">/health</code>，应用程序将响应HTTP 200。</p><p id="42b4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第18–20，25行:在<code class="du mq mr ms mt b">/version</code>公开一个端点，它返回当前部署的应用程序的版本。这将使以后更容易确认k8s上运行的是哪个版本的应用程序。</p><p id="eb63" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第26行:最后，我们在端口<code class="du mq mr ms mt b">8080</code>上监听任何传入的HTTP请求。</p><p id="b283" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">现在，我们可以通过构建二进制文件来编译应用程序:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="a23f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">您会注意到使用了<code class="du mq mr ms mt b">netgo</code>构建标签。这有助于通过用system的libc代替Go的<code class="du mq mr ms mt b">netgo</code>库来生成静态二进制文件。</p><p id="66c1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">如果您在本地没有Go的构建设置，您可以使用位于<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/tree/master/source" rel="noopener ugc nofollow" target="_blank">这里</a>的预构建二进制文件。版本<code class="du mq mr ms mt b">1.0</code>的可下载版本可通过<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/source/1.0/app?raw=true" rel="noopener ugc nofollow" target="_blank">此链接</a>获得。</p><p id="5bb1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">接下来，我们需要将Go二进制文件封装到Docker映像中，以便稍后部署到k8s。</p><h1 id="bfe4" class="la lb hi bd lc ld lx lf lg lh ly lj lk io lz ip lm ir ma is lo iu mb iv lq lr bi translated">第二阶段:码头工人形象🐳</h1><p id="ca25" class="pw-post-body-paragraph ja jb hi jd b je ls ij jg jh lt im jj kk lu jm jn kl lv jq jr km lw ju jv jw hb bi translated">将Go工件包装在Docker映像中非常简单。只是将二进制文件复制到映像中。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/blob/master/docker file</a>获得</figcaption></figure><p id="e4e6" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">您会注意到，我们使用Docker <a class="ae jx" href="https://blog.dockbit.com/making-use-of-docker-build-arguments-68792d751f3" rel="noopener ugc nofollow" target="_blank">构建时参数</a>来指定将哪个版本的应用程序打包到映像中。</p><p id="aa23" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">由于我们的k8s设置是在<a class="ae jx" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank"> GCP </a>之上，我们可以利用<a class="ae jx" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册表</a>(简称GCR)来存储图像。URL根据我们之前设置的<a class="ae jx" href="https://support.google.com/cloud/answer/6158840?hl=en" rel="noopener ugc nofollow" target="_blank">项目ID </a>而改变。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="1151" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">Container Engine的一大优点是它会在k8s worker节点上自动预配置Docker注册凭证。因此k8s可以开箱即用地访问GCR的图像。</p><p id="1bb0" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">至此，我们已经有了一个正确打包在Docker映像中的应用程序，k8s可以使用和部署它。是时候一头扎进库伯内特斯了。</p><h1 id="47d6" class="la lb hi bd lc ld lx lf lg lh ly lj lk io lz ip lm ir ma is lo iu mb iv lq lr bi translated">阶段3:将Stable部署到k8s</h1><p id="5d82" class="pw-post-body-paragraph ja jb hi jd b je ls ij jg jh lt im jj kk lu jm jn kl lv jq jr km lw ju jv jw hb bi translated">在深入研究代码之前，我们需要熟悉一些k8s术语。首先也是最重要的:<a class="ae jx" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" rel="noopener ugc nofollow" target="_blank">吊舱</a>。</p><blockquote class="nh"><p id="15ba" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">Pod是Kubernetes的基本构建块，是您创建或部署的Kubernetes对象模型中最小和最简单的单元。一个Pod代表集群上正在运行的进程。</p><p id="65e1" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">一个容器(如鲸的容器或豌豆荚)是一组一个或多个容器(如Docker容器)，具有共享的存储/网络，以及如何运行容器的规范。一个pod的内容总是位于同一位置并被共同调度，并且在一个共享的上下文中运行</p></blockquote><p id="0df1" class="pw-post-body-paragraph ja jb hi jd b je nr ij jg jh ns im jj kk nt jm jn kl nu jq jr km nv ju jv jw hb bi translated">实际上，您最关心的是定义您的pod的“规格”。这些可以包括使用哪个容器映像、健康检查、在Pod中运行什么命令、暴露哪个端口等。对于大多数工作负载，您将拥有同一个Pod的多个实例，工作负载将使用某种形式的负载平衡在它们之间分配，这就引出了复制集的概念。</p><p id="c111" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated"><a class="ae jx" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank"> ReplicaSets </a>(简称RS)确保特定数量的pod副本同时运行。你只需告诉k8s，你需要某个Pod的x个副本，它会确保根据Pod的<a class="ae jx" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" rel="noopener ugc nofollow" target="_blank">生命周期</a>，完全相同的数量始终有效。</p><p id="69f7" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">然而，在编写k8s配置时，您很少需要定义副本集，而是使用<a class="ae jx" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>。</p><blockquote class="nh"><p id="85b6" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">部署是一个更高层次的概念，它管理副本集，并提供对pod的声明性更新以及许多其他有用的特性</p><p id="919f" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">您在部署对象中描述一个期望的状态，部署控制器以受控的速度将实际状态更改为期望的状态。您可以定义部署来创建新的副本集，或者删除现有的部署并在新部署中采用它们的所有资源。</p></blockquote><p id="facc" class="pw-post-body-paragraph ja jb hi jd b je nr ij jg jh ns im jj kk nt jm jn kl nu jq jr km nv ju jv jw hb bi translated">下面是一个使用我们之前构建的Docker映像定义k8s部署的示例:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-production.yml" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-production . yml</a>获得</figcaption></figure><p id="0c6e" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第1–2行:我们想要创建的Kubernetes <a class="ae jx" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank">对象</a>的种类以及创建时使用的API版本。</p><p id="cfbb" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第3–4行:唯一标识对象的元数据。</p><p id="03fb" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第5–12行:代表<a class="ae jx" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" rel="noopener ugc nofollow" target="_blank"> Pod模板</a>的开始。</p><blockquote class="nh"><p id="14fd" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">Pod模板是包含在其他对象中的pod规格。</p><p id="97f8" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">pod模板不指定所有副本的当前所需状态，而是像切饼刀一样。一旦饼干被切割，饼干就与切割者没有任何关系。</p></blockquote><p id="a371" class="pw-post-body-paragraph ja jb hi jd b je nr ij jg jh ns im jj kk nt jm jn kl nu jq jr km nv ju jv jw hb bi translated">在本例中，我们配置了一个模板，使其拥有同一个容器的3个副本，并附加了一些可用于引用部署对象的标签<a class="ae jx" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">。这个设置中的一个重要标签是<code class="du mq mr ms mt b">app: kubeapp</code>。例如，通过将应用程序名称设置为附加到pod，我们可以在以后从负载平衡器指向pod。</a></p><blockquote class="nh"><p id="e426" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">标签是附加到对象(如窗格)的键/值对。标签可用于组织和选择对象子集。</p></blockquote><p id="8373" class="pw-post-body-paragraph ja jb hi jd b je nr ij jg jh ns im jj kk nt jm jn kl nu jq jr km nv ju jv jw hb bi translated">第13–25行:定义了k8s将作为副本集的一部分在Pods中运行的容器的规格。</p><ul class=""><li id="0cd1" class="mc md hi jd b je jf jh ji kk me kl mf km mg jw mh mi mj mk bi translated">这些集装箱是基于储存在GCR的码头图像<code class="du mq mr ms mt b">gcr.io/PROJECT_ID/app:1.0</code>设计的。其中<code class="du mq mr ms mt b">PROJECT_ID</code>应按如下所示进行评估。</li><li id="e16b" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated"><code class="du mq mr ms mt b">imagePullPolicy</code>告诉k8s总是从Docker注册表中提取图像，以防有新的图像被推送，带有相同的标签。</li><li id="9f37" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated"><code class="du mq mr ms mt b">readinessProbe</code>定义对Pod运行的健康检查(在本例中，在端口8080上调用<code class="du mq mr ms mt b">/health</code>)。</li><li id="9df1" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated"><code class="du mq mr ms mt b">command</code>设置启动后在容器中运行的命令。这里我们指向Go二进制文件在<code class="du mq mr ms mt b">/app</code>的位置。</li><li id="a33d" class="mc md hi jd b je ml jh mm kk mn kl mo km mp jw mh mi mj mk bi translated"><code class="du mq mr ms mt b">ports</code>打开端口8080，以便容器可以接受和发送流量。</li></ul><p id="55de" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">在我们继续执行部署之前，我们需要解析<code class="du mq mr ms mt b">PROJECT_ID</code>，我们可以使用以前的<code class="du mq mr ms mt b">sed</code>来完成:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="e4be" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">为部署创建一个k8s <a class="ae jx" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a>也是一个好主意。Kubernetes支持由同一个物理集群支持的多个虚拟集群。这些虚拟集群被称为名称空间。</p><p id="76e4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">名称空间非常适合的一个例子是部署环境。因此，在完全相同的k8s集群中，您最终可以获得一个用于生产的名称空间和另一个用于暂存的名称空间。下面是创建名称空间的方法:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="9cfc" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">现在，我们终于可以开始部署了🚀</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="ed1b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">注意我们如何需要指定使用哪个名称空间。通过部署创建的所有k8s资源将驻留在<code class="du mq mr ms mt b">production</code>名称空间中。所以为了访问它们，我们需要总是添加<code class="du mq mr ms mt b">--namespace</code>参数。我们可以通过<code class="du mq mr ms mt b">rollout status</code>命令检查卷展的进度:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="d6b2" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">耶！😁</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div class="er es nw"><img src="../Images/27545c1ad0342c95d6a3f6771565132d.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/1*uTbW1iR_rMyH422AXvYCgg.gif"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">查克批准的部署！</figcaption></figure><p id="f836" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated"><code class="du mq mr ms mt b">get</code>命令可用于获取所有k8s对象的信息。要获得部署后创建的pod列表，我们可以运行:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="3f5f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">仔细观察，您会发现k8s将pod分布在3个worker <a class="ae jx" href="https://kubernetes.io/docs/concepts/architecture/nodes/" rel="noopener ugc nofollow" target="_blank">节点</a>上。</p><p id="d57f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">另一个非常有用的命令是<code class="du mq mr ms mt b">get events</code>。这从k8s控制器中提取了一系列事件，可以方便地进行故障排除和查看发生了什么。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="63c4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">此时，应用程序的3个副本已启动，并在端口<code class="du mq mr ms mt b">8080</code>上监听传入的连接。但是我们缺少完成设置的最后一个组件，它将允许我们访问应用程序:一个负载平衡器。</p><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es nx"><img src="../Images/5d1b43068e0a956c524aab25b3dd095b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZMJoE5e7sooxAa2KhrI8g.png"/></div></div></figure><p id="1141" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">k8s支持创建云原生负载平衡器(简称LB)。它通过创建一个负载平衡器(想想<a class="ae jx" href="https://cloud.google.com/load-balancing/" rel="noopener ugc nofollow" target="_blank"> GCP LB </a>或<a class="ae jx" href="https://aws.amazon.com/elasticloadbalancing/" rel="noopener ugc nofollow" target="_blank"> AWS ELB </a>)作为<a class="ae jx" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>来做到这一点。在实践中，服务可以有不同的含义。pod和服务之间的主要区别在于，pod是会死的(因此，如果它们重生，网络寻址会改变)，另一方面，服务可以通过给它们贴上<a class="ae jx" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">标签</a>来识别，以便以后参考，而不用担心寻址问题。</p><p id="0787" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">下面是如何将负载平衡器定义为指向前面创建的pod的服务:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-lb.yml" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-lb . yml</a>获得</figcaption></figure><p id="4c88" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第1–4行:指定我们使用k8s API版本1和元数据创建一个服务类型的k8s <a class="ae jx" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank">对象</a>。</p><p id="8a0f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第6行:将<a class="ae jx" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types" rel="noopener ugc nofollow" target="_blank">服务类型</a>设置为负载均衡器。这使用云提供商的负载均衡器对外公开服务。在我们的例子中，这将创建<a class="ae jx" href="https://cloud.google.com/load-balancing/" rel="noopener ugc nofollow" target="_blank"> GCP负载平衡器</a>，并自动创建所有必要的路由，以通过LB将pod内部运行的工作负载连接到外部世界。</p><p id="0ce4" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第7–11行:代表LB配置。在这种情况下，LB监听端口<code class="du mq mr ms mt b">80</code>，将请求定向到后端<code class="du mq mr ms mt b">8080</code>的TCP端口。</p><p id="7754" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第12–13行:向我们介绍了另一个重要的k8s概念:<a class="ae jx" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">选择器</a>。它们与标签一起工作来识别和分组k8s对象。早些时候，我们将<code class="du mq mr ms mt b">app: kubeapp</code>的标签分配给了我们的pod。在LB定义中，我们可以简单地在完全相同的标签上使用一个选择器，以便LB可以自动发现它可以将流量定向到哪个pod。</p><p id="b15c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">创建LB使用我们之前创建部署时使用的相同的<code class="du mq mr ms mt b">apply</code>命令:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="b5cd" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">云LB是异步创建的，一旦完成，您可以使用<code class="du mq mr ms mt b">get</code>命令获取LB的公共IP地址:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="0c48" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">我们还可以使用这个一行程序提取LB的IP地址👉</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="3681" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">厉害！我们的应用程序版本<code class="du mq mr ms mt b">1.0</code>(稳定版)已经部署🙌。两个k8s配置文件和一些命令采用了我们的Docker镜像，部署了3个分布式容器，创建了一个LB并把东西连接在一起，一点也不差！</p><h1 id="851a" class="la lb hi bd lc ld lx lf lg lh ly lj lk io lz ip lm ir ma is lo iu mb iv lq lr bi translated">阶段4:将Canary部署到k8s🐤</h1><p id="bc60" class="pw-post-body-paragraph ja jb hi jd b je ls ij jg jh lt im jj kk lu jm jn kl lv jq jr km lw ju jv jw hb bi translated">现在我们已经将稳定版本部署到集群中，我们可以开始部署Canary版本了。让我们把它命名为<code class="du mq mr ms mt b">2.0</code>，我们将遵循类似的流程。<code class="du mq mr ms mt b">1.0</code>和<code class="du mq mr ms mt b">2.0</code>之间的差值将仅仅是Go <a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/source/2.0/app.go#L8" rel="noopener ugc nofollow" target="_blank">常量</a>的值。</p><ul class=""><li id="9690" class="mc md hi jd b je jf jh ji kk me kl mf km mg jw mh mi mj mk bi translated">为<code class="du mq mr ms mt b">2.0</code>构建Go二进制文件(或者在这里下载一个预构建的二进制文件<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/source/2.0/app?raw=true" rel="noopener ugc nofollow" target="_blank">)。</a></li></ul><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><ul class=""><li id="9448" class="mc md hi jd b je jf jh ji kk me kl mf km mg jw mh mi mj mk bi translated">为<code class="du mq mr ms mt b">2.0</code>构建并推送Docker映像。</li></ul><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><ul class=""><li id="3b4f" class="mc md hi jd b je jf jh ji kk me kl mf km mg jw mh mi mj mk bi translated">通过应用与Stable略有不同的k8s配置推出Canary版本:</li></ul><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-canary.yml" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-canary . yml</a>获得</figcaption></figure><p id="663d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">让我们强调一下不同之处:</p><p id="1005" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第4、12行:区分Canary部署和Stable的唯一元数据。注意名为<code class="du mq mr ms mt b">env</code>的标签是如何不同的，但是Stable和Canary对于<code class="du mq mr ms mt b">app</code>标签共享相同的值<code class="du mq mr ms mt b">kubeapp</code>。</p><p id="e32a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第6行:为Canary版本设置我们需要的副本数量。这很重要，因为它控制了我们的用户点击金丝雀版本的比例。在这种情况下，我们有一个稳定:金丝雀的<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-production.yml#L6" rel="noopener ugc nofollow" target="_blank"> 3 </a> : <a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-canary.yml#L6" rel="noopener ugc nofollow" target="_blank"> 1 </a>比率，因此命中负载平衡器的25%的请求将获得金丝雀释放。</p><p id="500b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">我们不需要对LB做任何更改，因为它已经有一个应用于标签<code class="du mq mr ms mt b">app: kubeapp</code>的<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-lb.yml#L12-L13" rel="noopener ugc nofollow" target="_blank">选择器</a>，该标签跨越两个部署(稳定和金丝雀)。所以通过金丝雀部署发射的吊舱将自动加入LB。</p><p id="4a25" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">是时候释放金丝雀了🐤</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="579f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">我们可以通过在先前设置的<code class="du mq mr ms mt b">SERVICE_IP</code>上执行curl in for循环来模拟用户点击应用程序:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="af9a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">一旦<code class="du mq mr ms mt b">2.0</code>通过测试和批准，我们可以继续将<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/lb/app-production.yml#L16" rel="noopener ugc nofollow" target="_blank"> app-production.yml </a>中使用的Docker映像切换到<code class="du mq mr ms mt b">2.0</code>，然后简单地重新应用配置。另一种方法是将使用的图像直接保存到k8s API:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="447b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这将指示k8s发射新的吊舱，同时终止旧的吊舱。至此，您并不真正需要金丝雀部署。你可以通过执行<code class="du mq mr ms mt b">kubectl --namespace=production delete deployment/kubeapp-canary</code>来删除它。</p><p id="5eaa" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">一旦你开始测试Canary版本，你很快就会遇到的一个问题是LB可能会开始在两个版本之间切换你的会话，使得单独测试<code class="du mq mr ms mt b">2.0</code>变得非常困难。此外，使用k8s提供的LBs来实现SSL终止或路由规则等操作需求实际上是不可行的。</p><p id="890d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">进入<a class="ae jx" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#what-is-ingress" rel="noopener ugc nofollow" target="_blank">入口资源</a>。</p><h1 id="697d" class="la lb hi bd lc ld lx lf lg lh ly lj lk io lz ip lm ir ma is lo iu mb iv lq lr bi translated">阶段5:使用入口资源访问Canary部署</h1><blockquote class="nh"><p id="e97e" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">入口是允许入站连接到达群集服务的规则集合。</p><p id="8363" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">它可以被配置为向服务提供外部可访问的URL、负载平衡流量、终止SSL、提供基于名称的虚拟主机等等。</p></blockquote><p id="80a5" class="pw-post-body-paragraph ja jb hi jd b je nr ij jg jh ns im jj kk nt jm jn kl nu jq jr km nv ju jv jw hb bi translated">入口资源由一个<a class="ae jx" href="https://github.com/kubernetes/ingress-gce#what-is-an-ingress-controller" rel="noopener ugc nofollow" target="_blank">入口控制器</a>在k8s中提供。这些控制器抽象出用于实现高级负载平衡的后端软件的内部工作方式(甚至可以是<a class="ae jx" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> nginx </a>、<a class="ae jx" href="https://github.com/kubernetes/ingress-gce" rel="noopener ugc nofollow" target="_blank"> GCE LB </a>、HAProxy等)，让我们专注于路由规则。</p><p id="5137" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">入口控制器通常不会在初始集群创建时自动创建，尽管很酷的一点是它们可以作为k8s Pods部署。至于我们现有的<a class="ae jx" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank"> GKE </a>设置，它实际上已经存在<a class="ae jx" href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/faq/gce.md" rel="noopener ugc nofollow" target="_blank"/>，因此我们可以直接进入如何使用入口资源。</p><p id="6f68" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">我们对入口资源的目标是将Canary部署的流量分割到一个子域上。这将使得独立于稳定版本测试Canary版本变得更加容易。</p><p id="e4ff" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">让我们假设稳定版本在<code class="du mq mr ms mt b">http://foo.bar</code>可访问，金丝雀部署在<code class="du mq mr ms mt b">http://canary.foo.bar</code>。您需要在本地解析器(又名:<code class="du mq mr ms mt b">/etc/hosts</code>)中添加这些域的记录，将流量定向到入口资源的公共IP。</p><blockquote class="ix iy iz"><p id="fd2b" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在执行下一节中的命令之前，您可能需要删除之前创建的资源。抛弃名称空间并重新创建它可以通过这个任务来实现:<code class="du mq mr ms mt b"><em class="hi">kubectl delete namespace production &amp;&amp; kubectl create namespace production</em></code></p></blockquote><p id="8376" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">让我们从探索部署本身需要做哪些更改开始:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-production.yml" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-production . yml</a>获得</figcaption></figure><p id="a72e" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">部署对象是原样的，这里没有什么新东西。新配置位于第2部分(从第27行开始)。在这里，我们基本上是通过一个<code class="du mq mr ms mt b">NodePort</code>类型的k8s服务发布部署创建的pod。</p><blockquote class="nh"><p id="9cb3" class="ni nj hi bd nk nl nm nn no np nq jw dx translated">Kubernetes master将从一个标记配置的范围(缺省值:30000–32767)中分配一个端口，每个节点将该端口(每个节点上的相同端口号)代理到您的服务中。</p></blockquote><p id="36fb" class="pw-post-body-paragraph ja jb hi jd b je nr ij jg jh ns im jj kk nt jm jn kl nu jq jr km nv ju jv jw hb bi translated">我们的部署公开端口<code class="du mq mr ms mt b">8080</code>，因此服务指向该端口，并在节点本身上公开端口<code class="du mq mr ms mt b">80</code>。入口资源不能直接与部署对象对话，而是需要一个服务来首先发布部署。</p><p id="7119" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">与我们之前所做的类似，下面是部署+服务组合的流程:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="ee10" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">查询k8s API将向我们展示，Pods被集体公开为一个监听内部IP地址的服务。这也是通过指向pod<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-production.yml#L10-L12" rel="noopener ugc nofollow" target="_blank">模板</a>中使用的标签的<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-production.yml#L39-L41" rel="noopener ugc nofollow" target="_blank">选择器</a>来完成的。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="568a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">一旦服务发布，我们就可以开始创建我们的入口资源。下面我们定义一个最小资源:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-ingress-production.yml" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-ingress-production . yml</a>获得</figcaption></figure><p id="d935" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">和所有其他k8s对象一样，类型和元数据都被设置为<code class="du mq mr ms mt b">Ingress</code>。入口资源需要知道将请求路由到哪个后端，我们这里只有一个后端指向前面定义的服务。</p><p id="e458" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">在这种情况下，我们没有列出任何路由，这意味着这将代表<em class="jc">默认后端</em>，所有请求都将转到该后端。一旦后端的健康检查开始报告<code class="du mq mr ms mt b">HEALTHY</code>，我们就可以点击入口地址并开始测试我们的设置。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="513c" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">注意第16行，在我们能够访问入口资源IP地址之前，我们需要等待后端报告<strong class="jd hj"> HEALTHY </strong>。</p><p id="da3a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">金丝雀释放非常类似于稳定。唯一的区别是<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-canary.yml#L6" rel="noopener ugc nofollow" target="_blank">副本</a>的数量、要使用的Docker图像(在我们的例子中是<code class="du mq mr ms mt b"><a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-canary.yml#L16" rel="noopener ugc nofollow" target="_blank">2.0</a></code>)和相关的元数据。可以使用通常的流程来滚动部署:</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="5b20" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">为了能够在单独的子域上访问Canary版本，我们需要添加一些指向Canary <a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-canary.yml#L27-L41" rel="noopener ugc nofollow" target="_blank">服务</a>的入口路由。我们在这里使用的方法是基于名称的虚拟主机，其中入口资源将检查<a class="ae jx" href="https://tools.ietf.org/html/rfc7230#section-5.4" rel="noopener ugc nofollow" target="_blank">主机头</a>并判断它应该将流量发送到哪个服务。</p><pre class="jz ka kb kc fd ny mt nz oa aw ob bi"><span id="db0a" class="oc lb hi mt b fi od oe l of og"><strong class="mt hj">foo.bar        --|                 |-&gt; kubeapp-production-service 80<br/>                 |   Ingress IP    |<br/>canary.foo.bar --|                 |-&gt; kubeapp-canary-service     80</strong></span></pre><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">可从<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-ingress-canary.yml" rel="noopener ugc nofollow" target="_blank">https://github . com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-ingress-canary . yml</a>获得</figcaption></figure><p id="0956" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第6–8行:设置默认后端。这将匹配任何到达没有主机头集的入口IP地址的请求，将其定向到包含生产pod的生产服务。</p><p id="a833" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第9行:开始入口资源规则部分。</p><p id="6246" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第10–15行:匹配域<code class="du mq mr ms mt b">canary.foo.bar</code>并将流量定向到端口<code class="du mq mr ms mt b">80</code>上名为<code class="du mq mr ms mt b"><a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-canary.yml#L27-L41" rel="noopener ugc nofollow" target="_blank">kubeapp-canary-service</a></code>的k8s服务。</p><p id="fc1b" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">第16–21行:对我们用于服务的主域做同样的事情<code class="du mq mr ms mt b">foo.bar</code>。</p><figure class="jz ka kb kc fd kd"><div class="bz dy l di"><div class="ng ko l"/></div></figure><p id="6c34" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这种技术对于在生产环境中测试Canary版本非常有用，不会影响用户使用的稳定版本。相同的入口路由可以修改为在相同域的不同URL路径上工作，而不是使用vhosts(也称为<a class="ae jx" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#simple-fanout" rel="noopener ugc nofollow" target="_blank">扇出</a>)。</p><p id="b3aa" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">将Canary版本升级到生产可以使用前面讨论过的相同流程来执行:使用<code class="du mq mr ms mt b">set image</code>或者修改Docker映像以在<a class="ae jx" href="https://github.com/DockbitExamples/kubernetes/blob/master/k8s/ingress/app-production.yml#L16" rel="noopener ugc nofollow" target="_blank">生产配置</a>中使用。</p><p id="4f3d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">因此，在k8s上设置金丝雀部署并不困难。事情甚至可以通过<a class="ae jx" href="http://blog.kubernetes.io/2017/04/multi-stage-canary-deployments-with-kubernetes-in-the-cloud-onprem.html" rel="noopener ugc nofollow" target="_blank">多级金丝雀部署</a>和<a class="ae jx" href="https://istio.io/blog/canary-deployments-using-istio.html" rel="noopener ugc nofollow" target="_blank">流量权重的更精细控制</a>得到进一步发展。</p><h1 id="08c5" class="la lb hi bd lc ld lx lf lg lh ly lj lk io lz ip lm ir ma is lo iu mb iv lq lr bi translated">结论</h1><p id="d365" class="pw-post-body-paragraph ja jb hi jd b je ls ij jg jh lt im jj kk lu jm jn kl lv jq jr km lw ju jv jw hb bi translated">Kubernetes是一个巨大的项目，它允许各种形状和规模的公司采用过去只有大型公司才能使用的基础设施结构(k8s的灵感毕竟来自于<a class="ae jx" href="http://blog.kubernetes.io/2015/04/borg-predecessor-to-kubernetes.html" rel="noopener ugc nofollow" target="_blank"> borg </a>)。最重要的是，与其他系统相比，实现类似的设置相对容易。</p><p id="ae2d" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">这篇文章只是触及了一个用例的表面。k8s有适合每个人的东西，通过<a class="ae jx" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank">概念</a>挖掘，看看它在哪里适合你！</p><p id="f84f" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj kk jl jm jn kl jp jq jr km jt ju jv jw hb bi translated">让他们飞起来！🐤 🚀</p></div></div>    
</body>
</html>