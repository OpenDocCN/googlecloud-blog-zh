<html>
<head>
<title>BigQuery Explained: Storage Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery解释:存储概述</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-explained-storage-overview-70cac32251fa?source=collection_archive---------0-----------------------#2020-09-09">https://medium.com/google-cloud/bigquery-explained-storage-overview-70cac32251fa?source=collection_archive---------0-----------------------#2020-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><blockquote class="im in io"><p id="6fdb" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在谷歌云博客上关注BigQuery解释系列<a class="ae jo" href="https://cloud.google.com/blog/topics/developers-practitioners/bigquery-explained-blog-series" rel="noopener ugc nofollow" target="_blank">。有问题或者想聊天？在</a><a class="ae jo" href="https://twitter.com/rajesh_thallam" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae jo" href="https://www.linkedin.com/in/rajeshthallam/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系。</p></blockquote></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="e6d8" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在BigQuery解释系列的<a class="ae jo" rel="noopener" href="/google-cloud/bigquery-explained-overview-357055ecfda3">上一篇文章</a>中，我们回顾了BigQuery的高级架构，并展示了如何开始使用BigQuery。在本帖中，我们将探讨BigQuery存储组织、存储格式，并介绍BigQuery的最佳实践之一，对您的数据进行分区和集群，以获得最佳性能。让我们开始吧！</p><h1 id="cf99" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">大查询资源模型</h1><p id="eaa3" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">BigQuery将数据表组织成称为数据集的单元。这些数据集的范围是您的GCP项目。这些多重范围(项目、数据集和表)有助于您以逻辑方式组织信息。您可以使用多个数据集来分隔属于不同分析域的表，并且可以根据您的业务需求使用项目级范围来隔离数据集。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/687a32cedcd763e65a70a197207c8908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sG8rvBgrCPtueF56"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated"><strong class="bd ju">图:BigQuery资源[ </strong> <a class="ae jo" href="https://cloud.google.com/solutions/bigquery-data-warehouse" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ju">来源</strong></a><strong class="bd ju">】</strong>的结构概述</figcaption></figure><blockquote class="im in io"><p id="5abf" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="hi">项目</em></p></blockquote><ul class=""><li id="baf6" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">对象的根命名空间</li><li id="8b1b" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">包含多个数据集、作业、访问控制列表和IAM角色</li><li id="d6d1" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">控制计费、用户和用户权限</li></ul><blockquote class="im in io"><p id="fa05" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="hi">数据集</em></p></blockquote><ul class=""><li id="c12e" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">“相关”表/视图以及标签和描述的集合</li><li id="3ebe" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">允许数据集级别的存储访问控制</li><li id="151e" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">定义数据的位置，即多区域(美国、欧盟)或区域(亚洲-东北1)</li></ul><blockquote class="im in io"><p id="0c71" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="hi">表格</em></p></blockquote><ul class=""><li id="6b73" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">存储在托管存储中的列和行的集合</li><li id="1c3c" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">由具有强类型值列的架构定义</li><li id="93c7" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">允许<a class="ae jo" href="https://cloud.google.com/bigquery/docs/table-access-controls-intro" rel="noopener ugc nofollow" target="_blank">表级</a>和<a class="ae jo" href="https://cloud.google.com/bigquery/docs/column-level-security-intro" rel="noopener ugc nofollow" target="_blank">列级</a>的访问控制</li></ul><blockquote class="im in io"><p id="4419" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="hi">观点</em></p></blockquote><ul class=""><li id="b7e8" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">由SQL查询定义的虚拟表</li><li id="d1f5" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">允许视图级别的访问控制</li></ul><blockquote class="im in io"><p id="63f8" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="hi">工作岗位</em></p></blockquote><ul class=""><li id="eed2" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">BigQuery代表您运行的操作—加载数据、导出数据、复制数据或查询数据</li><li id="c1f7" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">作业是异步执行的</li></ul><p id="49db" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">当您从命令行、SQL查询或代码中引用一个表时，您可以使用下面的构造来引用它:<code class="du lz ma mb mc b">project.dataset.table</code>。</p><h1 id="7d4d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">存储管理</h1><p id="dc26" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">现在让我们回顾一下BigQuery如何管理保存数据的存储。传统的关系数据库，如MySQL，逐行存储数据(<a class="ae jo" href="http://publications.csail.mit.edu/abstracts/abstracts06/dna/dna.html" rel="noopener ugc nofollow" target="_blank">面向记录的存储</a>)。这使他们擅长事务性更新和<a class="ae jo" href="https://en.wikipedia.org/wiki/Online_transaction_processing" rel="noopener ugc nofollow" target="_blank"> OLTP </a>(在线事务处理)用例。另一方面，BigQuery使用列存储，其中每一列都存储在一个单独的文件块中。这使得BigQuery成为<a class="ae jo" href="https://en.wikipedia.org/wiki/Online_analytical_processing" rel="noopener ugc nofollow" target="_blank"> OLAP </a>(在线分析处理)用例的理想解决方案。您可以轻松地将数据流式传输(追加)到BigQuery表中，并更新或删除现有值。BigQuery <a class="ae jo" href="https://cloud.google.com/blog/products/data-analytics/dml-without-limits-now-in-bigquery" rel="noopener ugc nofollow" target="_blank">支持无限制的突变</a>(插入、更新、合并、删除)。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es md"><img src="../Images/9bc976dcd6d6ec36984945a7845ecf7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*soejo49qke3RpTps"/></div></div></figure><p id="9e4c" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">BigQuery使用了列存储的变体和改进。在内部，BigQuery以一种称为<a class="ae jo" href="https://cloud.google.com/blog/products/gcp/inside-capacitor-bigquerys-next-generation-columnar-storage-format" rel="noopener ugc nofollow" target="_blank">电容器</a>的专有列格式存储数据，这对数据仓库工作负载有很多好处。BigQuery使用专有格式，因为存储引擎可以与查询引擎协同发展，从而利用对数据布局的深入了解来优化查询执行。表中的每一列都存储在一个单独的文件块中，所有列都存储在一个电容器文件中，该文件在磁盘上被压缩和加密。BigQuery使用查询访问模式来确定物理碎片的最佳数量以及数据的编码方式。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es me"><img src="../Images/4cad5c1ba5dcd8839b94658d1b3eee3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/0*n6Gx3BlrqdaE9sCM"/></div></figure><p id="ad1a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">实际的持久层是由Google的分布式文件系统<a class="ae jo" href="https://cloud.google.com/files/storage_architecture_and_challenges.pdf" rel="noopener ugc nofollow" target="_blank"> Colossus </a>提供的，其中数据被自动压缩、加密、复制和分发。Colossus使用擦除编码在多个物理磁盘上存储冗余数据块，从而确保耐用性。所有这些都是在不影响查询的计算能力的情况下完成的。将存储与计算分离，使您能够无缝扩展到数Pb的存储容量，而无需额外的昂贵计算资源。将计算和存储分离还有许多其他的<a class="ae jo" href="https://cloud.google.com/blog/products/gcp/separation-of-compute-and-state-in-google-bigquery-and-cloud-dataflow-and-why-it-matters" rel="noopener ugc nofollow" target="_blank">好处</a>。</p><h1 id="1efd" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">利用长期储存的优势</h1><p id="a0f7" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">您可以在<a class="ae jo" href="https://cloud.google.com/bigquery/pricing#free" rel="noopener ugc nofollow" target="_blank">免费</a>将数据加载到BigQuery中(对于批量加载)，因为<a class="ae jo" href="https://cloud.google.com/bigquery/pricing#storage" rel="noopener ugc nofollow" target="_blank"> BigQuery存储成本</a>基于存储的数据量(每月前10 GB是免费的)以及存储是活动的还是长期的。</p><ul class=""><li id="50fe" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">如果您在过去90天内修改了一个表或分区，它将被视为活动存储，并会对以BigQuery存储速率存储的数据产生月费。</li><li id="cfb7" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">如果您有一个连续90天没有修改的表或分区，它将被视为长期存储，该表的存储价格<a class="ae jo" href="https://cloud.google.com/bigquery/pricing#long-term-storage" rel="noopener ugc nofollow" target="_blank">将自动下降50% </a>，与<a class="ae jo" href="https://cloud.google.com/storage/pricing#storage-pricing" rel="noopener ugc nofollow" target="_blank">云存储近线</a>的成本相同。折扣是以每个表、每个分区为基础的。如果修改表中的数据，90天计数器将重置。</li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mf"><img src="../Images/fd5eb40dbc6dc080e1b7898385bf1d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1B57tWxQxBhmh7a4"/></div></div></figure><p id="9501" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">优化成本的最佳实践是将数据保存在BigQuery中。利用BigQuery的长期存储价格，而不是将您的旧数据导出到另一个存储选项(如云存储)。这意味着不必删除旧数据或设计数据归档流程。因为数据保留在BigQuery中，所以您也可以使用相同的接口、相同的成本水平和相同的性能特征来查询较旧的数据。</p><h1 id="b9ef" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">分区和聚类</h1><p id="dbcd" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">如果您希望优化成本和性能，将数据保存在BigQuery中是最佳实践。另一个最佳实践是使用BigQuery的表分区和集群特性来组织数据，以匹配常见的数据访问模式。</p><h1 id="1ac0" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">分割</h1><p id="bd20" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">分区表是一种特殊的表，它被划分为称为分区的多个段，这使得管理和查询数据变得更加容易。您通常可以使用数据摄取时间或<code class="du lz ma mb mc b">TIMESTAMP</code> / <code class="du lz ma mb mc b">DATE</code>列或<code class="du lz ma mb mc b">INTEGER</code>列将大型表分割成许多较小的分区。BigQuery的解耦存储和计算架构利用基于列的分区来最小化插槽工作器从磁盘读取的数据量。一旦slot workers从磁盘中读取数据，BigQuery就可以自动确定更优的数据分片，并使用BigQuery的内存洗牌服务快速对数据进行重新分区。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mf"><img src="../Images/e8aaa4f4272c22d6f02a9c94a8f250e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*67n9CCfTc4Xy4zdB"/></div></div></figure><p id="3af8" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">写入基于列的时间分区表的数据会根据数据的值自动传递到适当的分区。类似地，在分区列上表达筛选器的查询可以减少扫描的总数据，这可以提高性能并降低按需查询的查询成本。</p><p id="f56a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">BigQuery支持以下创建分区表的方法</p><blockquote class="im in io"><p id="f499" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">摄取时间分区表</p></blockquote><ul class=""><li id="a140" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">根据数据的接收时间或到达时间进行分区。</li><li id="445e" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">BigQuery自动将数据加载到基于日期的每日分区中，以反映数据的接收或到达时间。</li><li id="278e" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">BigQuery向摄取时间分区表添加了两个伪列——一个<code class="du lz ma mb mc b">_PARTITIONTIME</code>伪列包含基于日期的数据时间戳，一个<code class="du lz ma mb mc b">_PARTITIONDATE</code>伪列包含日期表示。</li></ul><blockquote class="im in io"><p id="5617" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lz ma mb mc b">DATE</code> / <code class="du lz ma mb mc b">TIMESTAMP</code>列分区表</p></blockquote><ul class=""><li id="6481" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">基于<code class="du lz ma mb mc b">TIMESTAMP</code>或<code class="du lz ma mb mc b">DATE</code>列进行分区。</li><li id="d0e7" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">BigQuery根据分区列中的日期值(用UTC表示)将数据路由到适当的分区。</li><li id="5e81" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">BigQuery创建了两个特殊的分区:用于捕获分区列中的行NULL值的<code class="du lz ma mb mc b">__NULL__</code>分区和用于允许的日期范围之外的数据的<code class="du lz ma mb mc b">__UNPARTITIONED__</code>分区。</li><li id="bf4a" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">您可以从每小时分区开始创建具有一定粒度的分区。</li></ul><blockquote class="im in io"><p id="b541" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lz ma mb mc b">INTEGER</code>范围分区表</p></blockquote><ul class=""><li id="88e0" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">基于具有开始、结束和间隔值的整数列进行分区。</li><li id="89c4" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">BigQuery创建了两个特殊的分区:用于捕获分区列中具有空值的行的<code class="du lz ma mb mc b">__NULL__</code>分区和用于超出允许的整数范围的数据的<code class="du lz ma mb mc b">__UNPARTITIONED__</code>分区。</li></ul><p id="65ca" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们来看看分区的作用。为了查看非分区表和分区表之间的性能差异，我们将使用相同的数据集创建非分区表和分区表，并检查查询性能。</p><h2 id="6fed" class="mg jt hi bd ju mh mi mj jy mk ml mm kc jp mn mo kg jq mp mq kk jr mr ms ko mt bi translated"><strong class="ak">分区前</strong></h2><p id="0f4a" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">通过运行下面的SQL查询，我们将创建一个非分区表，其中的数据是从一个基于StackOverflow posts的<a class="ae jo" href="https://console.cloud.google.com/marketplace/browse?filter=solution-type:dataset&amp;_ga=2.99891288.755387171.1599359331-1764086539.1598401521" rel="noopener ugc nofollow" target="_blank">公共数据集</a>中加载的，方法是<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#creating_a_new_table_from_an_existing_table" rel="noopener ugc nofollow" target="_blank">从一个现有的表</a>中创建一个新表。此表将包含2018年创建的StackOverflow帖子。</p><pre class="kw kx ky kz fd mu mc mv mw aw mx bi"><span id="77c9" class="mg jt hi mc b fi my mz l na nb">CREATE OR REPLACE TABLE `stackoverflow.questions_2018` AS<br/>SELECT *<br/>FROM `bigquery-public-data.stackoverflow.posts_questions`<br/>WHERE creation_date BETWEEN '2018-01-01' AND '2018-07-01'</span></pre><p id="4fdb" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们<strong class="is hj">查询未分区表</strong>以获取2018年1月所有标记为‘Android’的StackOverflow问题。</p><pre class="kw kx ky kz fd mu mc mv mw aw mx bi"><span id="f72d" class="mg jt hi mc b fi my mz l na nb">SELECT<br/>  id,<br/>  title,<br/>  body,<br/>  accepted_answer_id,<br/>  creation_date,<br/>  answer_count,<br/>  comment_count,<br/>  favorite_count,<br/>  view_count<br/>FROM<br/>  `stackoverflow.questions_2018`<br/>WHERE<br/>  creation_date BETWEEN '2018-01-01' AND '2018-02-01'<br/>  AND tags = 'android';</span></pre><p id="9d85" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在查询运行之前，为了公平起见，在与分区表和聚簇表进行性能比较时，<a class="ae jo" href="https://cloud.google.com/bigquery/docs/cached-results#console" rel="noopener ugc nofollow" target="_blank">缓存被禁用。</a></p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es nc"><img src="../Images/b9e3236a1069d460ca18dcb0165912f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/0*KJgV6mx6MXK6nPQZ"/></div></figure><p id="57b7" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">从查询结果中可以看到，对一个<strong class="is hj"> <em class="ir">非分区表的查询，用了5.6s扫描了整个3.2GB的数据</em> </strong>，用的是2018年创建的StackOverflow posts。</p><h2 id="35d2" class="mg jt hi bd ju mh mi mj jy mk ml mm kc jp mn mo kg jq mp mq kk jr mr ms ko mt bi translated"><strong class="ak">对表格进行分区</strong></h2><p id="cabb" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">现在让我们看看分区表是否能做得更好。您可以通过多种方式在<a class="ae jo" href="https://cloud.google.com/bigquery/docs/creating-partitioned-tables#creating_ingestion-time_partitioned_tables" rel="noopener ugc nofollow" target="_blank">中创建分区表。我们将使用</a><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language" rel="noopener ugc nofollow" target="_blank"> BigQuery DDL语句</a>创建一个<code class="du lz ma mb mc b">DATE</code> / <code class="du lz ma mb mc b">TIMESTAMP</code>分区表。基于查询访问模式，我们选择分区列为<code class="du lz ma mb mc b">creation_date</code>。</p><pre class="kw kx ky kz fd mu mc mv mw aw mx bi"><span id="d69a" class="mg jt hi mc b fi my mz l na nb">CREATE OR REPLACE TABLE `stackoverflow.questions_2018_partitioned`<br/>PARTITION BY<br/>  DATE(creation_date) AS<br/>SELECT<br/>  *<br/>FROM<br/>  `bigquery-public-data.stackoverflow.posts_questions`<br/>WHERE<br/>  creation_date BETWEEN '2018-01-01' AND '2018-07-01';</span></pre><p id="b54d" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">现在让我们在禁用缓存的情况下对分区表<a class="ae jo" href="https://cloud.google.com/bigquery/docs/cached-results#console" rel="noopener ugc nofollow" target="_blank"/>运行前面的<strong class="is hj">查询，以获取2018年1月标记为“android”的所有StackOverflow问题。</strong></p><pre class="kw kx ky kz fd mu mc mv mw aw mx bi"><span id="b1f8" class="mg jt hi mc b fi my mz l na nb">SELECT<br/>  id,<br/>  title,<br/>  body,<br/>  accepted_answer_id,<br/>  creation_date,<br/>  answer_count,<br/>  comment_count,<br/>  favorite_count,<br/>  view_count<br/>FROM<br/>  `stackoverflow.questions_2018_partitioned`<br/>WHERE<br/>  creation_date BETWEEN '2018-01-01' AND '2018-02-01'<br/>  AND tags = 'android';</span></pre><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es nc"><img src="../Images/ba4fac7a591e5ebf5b85b354f71998f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/0*CjC3RRMjXGo-utIA"/></div></figure><p id="1872" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ir">带分区表的查询在&lt; 2s处理中只扫描了所需的分区~290MB数据</em> </strong>相比之下，带非分区表的查询运行处理3.2GB。</p><p id="7eb6" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在特定范围内进行查询时，分区管理是充分最大化BigQuery性能和成本的关键—它导致每次查询扫描的数据更少，并且在查询开始之前就确定了修剪。虽然分区降低了成本并提高了性能，但它也防止了由于用户意外查询非常大的整个表而导致的成本爆炸。</p><blockquote class="im in io"><p id="8421" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示:</strong>您可以通过<a class="ae jo" href="https://cloud.google.com/bigquery/docs/best-practices-storage#use_the_expiration_settings_to_remove_unneeded_tables_and_partitions" rel="noopener ugc nofollow" target="_blank">配置表过期</a>来删除不需要的表和分区，从而控制和优化存储成本。</p></blockquote><p id="2854" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj">在这里</strong>  <strong class="is hj">了解更多关于分区表</strong> <a class="ae jo" href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">。</strong></a></p><h1 id="1539" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">使聚集</h1><p id="a2ec" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">当在BigQuery中对表进行聚集时，表数据会根据表模式中一个或多个列的内容自动组织。您指定的列用于排列相关数据。通常高基数和非时态列是集群的首选。</p><p id="3afd" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">当数据写入聚集表时，BigQuery使用聚集列中的值对数据进行排序。这些值用于将数据组织到BigQuery存储中的多个块中。聚集列的顺序决定了数据的排序顺序。当新数据被添加到表或特定分区时，BigQuery在后台执行<a class="ae jo" href="https://cloud.google.com/blog/products/data-analytics/skip-the-maintenance-speed-up-queries-with-bigquerys-clustering" rel="noopener ugc nofollow" target="_blank">自动重新聚类</a>以恢复表或分区的排序属性。<em class="ir">自动重新聚类对用户来说是完全免费和自主的。</em></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mf"><img src="../Images/345744f81dddc8d9591dd8f8b28fdac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q2fK1S1fN9YCLihb"/></div></div></figure><p id="4928" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">群集可以提高某些类型的查询的性能，例如使用筛选子句的查询和聚合数据的查询。</p><ul class=""><li id="2c62" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">当包含filter子句的查询根据聚类列筛选数据时，BigQuery使用已排序的块来消除对不必要数据的扫描。</li><li id="c160" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">当查询基于聚类分析列中的值聚合数据时，性能会得到提高，因为排序后的块将具有相似值的行放在一起。</li></ul><p id="0529" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">BigQuery支持对已分区表和未分区表进行聚类。当您同时使用集群和分区时，您的数据可以通过一个<code class="du lz ma mb mc b">DATE</code>或<code class="du lz ma mb mc b">TIMESTAMP</code>列进行分区，然后在一组不同的列(最多四列)上进行集群。</p><p id="0855" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">回到上一个查询，让我们看看使用聚簇表的查询是如何执行的。</p><h2 id="4e9c" class="mg jt hi bd ju mh mi mj jy mk ml mm kc jp mn mo kg jq mp mq kk jr mr ms ko mt bi translated"><strong class="ak">集群表</strong></h2><p id="6d6f" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">您可以在<a class="ae jo" href="https://cloud.google.com/bigquery/docs/creating-clustered-tables#creating_clustered_tables" rel="noopener ugc nofollow" target="_blank">中以多种方式</a>创建集群表。我们将使用<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#creating_a_clustered_table" rel="noopener ugc nofollow" target="_blank"> BigQuery DDL语句</a>创建一个新的<code class="du lz ma mb mc b">DATE</code> / <code class="du lz ma mb mc b">TIMESTAMP</code>分区和集群表。基于查询访问模式，我们选择分区列为<code class="du lz ma mb mc b">creation_date</code>，集群键为<code class="du lz ma mb mc b">tag</code>。</p><pre class="kw kx ky kz fd mu mc mv mw aw mx bi"><span id="1109" class="mg jt hi mc b fi my mz l na nb">CREATE OR REPLACE TABLE `stackoverflow.questions_2018_clustered`<br/>PARTITION BY<br/>  DATE(creation_date)<br/>CLUSTER BY<br/>  tags AS<br/>SELECT<br/>  *<br/>FROM<br/>  `bigquery-public-data.stackoverflow.posts_questions`<br/>WHERE<br/>  creation_date BETWEEN '2018-01-01' AND '2018-07-01';</span></pre><p id="945b" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">现在，让我们在禁用缓存的情况下对分区和聚集表<a class="ae jo" href="https://cloud.google.com/bigquery/docs/cached-results#console" rel="noopener ugc nofollow" target="_blank"/>运行<strong class="is hj">查询，以获取2018年1月标记为“android”的所有StackOverflow问题。</strong></p><pre class="kw kx ky kz fd mu mc mv mw aw mx bi"><span id="84e3" class="mg jt hi mc b fi my mz l na nb">SELECT<br/>  id,<br/>  title,<br/>  body,<br/>  accepted_answer_id,<br/>  creation_date,<br/>  answer_count,<br/>  comment_count,<br/>  favorite_count,<br/>  view_count<br/>FROM<br/>  `stackoverflow.questions_2018_clustered`<br/>WHERE<br/>  creation_date BETWEEN '2018-01-01'<br/>  AND '2018-02-01'<br/>  AND tags = 'android';</span></pre><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es nd"><img src="../Images/6b3494d4c59110fa1f3a97eddafdea5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*JGNrkJjieFd-BU0_"/></div></figure><p id="ae11" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ir">使用分区和聚集表，查询在不到1s的时间内扫描了约275MB的数据，</em> </strong>这比分区表好。通过分区和聚类来组织数据的方式最大限度地减少了插槽工作线程扫描的数据量，从而提高了查询性能并优化了成本。</p><p id="d182" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">使用集群时需要注意的几件事:</p><ul class=""><li id="209d" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">在运行查询之前，群集不提供严格的成本保证。请注意，在上面的聚类结果中，查询验证报告处理了286.1MB的数据，但实际上查询只处理了275.2MB的数据。</li><li id="3f35" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">仅当您需要比单独分区所允许的粒度更大的粒度时，才使用集群。</li></ul><p id="af40" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj">在这里</strong>  <strong class="is hj">了解更多关于使用聚集表</strong> <a class="ae jo" href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">的信息。</strong></a></p><h1 id="b27f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">接下来呢？</h1><p id="f81a" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">在本文中，我们学习了BigQuery如何组织和管理保存数据的存储，如何通过对表进行分区和聚类来提高查询性能，以及如何在BigQuery中为非活动数据保留长期存储价格的数据。</p><ul class=""><li id="a64e" class="ll lm hi is b it iu ix iy jp ln jq lo jr lp jn lq lr ls lt bi translated">查看使用BigQuery的<a class="ae jo" href="https://youtu.be/wapi0aR4BZE" rel="noopener ugc nofollow" target="_blank">分区和集群的演示</a></li><li id="f60e" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated">了解何时使用集群和分区</li><li id="1524" class="ll lm hi is b it lu ix lv jp lw jq lx jr ly jn lq lr ls lt bi translated"><a class="ae jo" href="https://codelabs.developers.google.com/codelabs/gcp-bq-partitioning-and-clustering/#0" rel="noopener ugc nofollow" target="_blank"> Codelab </a>在您的<a class="ae jo" href="https://cloud.google.com/bigquery/docs/sandbox" rel="noopener ugc nofollow" target="_blank"> BigQuery沙箱</a>上尝试BigQuery分区和集群</li></ul><p id="a2f2" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在下一篇文章中，我们将探讨如何将数据导入BigQuery并分析数据。</p><p id="3e90" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">敬请关注。感谢您的阅读！有问题或者想聊天？在<a class="ae jo" href="https://twitter.com/rajesh_thallam" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae jo" href="https://www.linkedin.com/in/rajeshthallam/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p><p id="448c" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><em class="ir">感谢</em> <a class="ae jo" rel="noopener" href="/@thegrinch"> <em class="ir">尤里</em> </a> <em class="ir">和</em> <a class="ae jo" rel="noopener" href="/@presactlyalicia"> <em class="ir">艾丽西娅·威廉姆斯</em> </a> <em class="ir">对帖子的帮助。</em></p></div></div>    
</body>
</html>