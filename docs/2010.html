<html>
<head>
<title>Replicate data from BigQuery to Cloud SQL with Cloud Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云工作流将数据从BigQuery复制到云SQL</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/replicate-data-from-bigquery-to-cloud-sql-2b23a08c52b1?source=collection_archive---------1-----------------------#2021-11-22">https://medium.com/google-cloud/replicate-data-from-bigquery-to-cloud-sql-2b23a08c52b1?source=collection_archive---------1-----------------------#2021-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/18d6c5ca8e946c2faf0713cfa7157e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oH7h2HhwSwY8498a1rQRiA.png"/></div></div></figure><p id="8dbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着流行和云的力量，一些人认为独角兽是存在的:<strong class="is hj">一个可以统治它们的数据库！</strong> <br/>然而，技术和物理都无法实现这个梦想。因此，每个云提供商都提出了<strong class="is hj">许多数据存储选项，每个选项都适合非常具体的用例。</strong></p><h1 id="d874" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">大查询问题</h1><p id="9098" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">分析数据库，如BigQuery，在几秒钟内处理数Pb的数据是非常高效的。聚合、复杂查询、数十亿行的连接为公司创造了新的洞察力和新的价值。</p><p id="84f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不好的一面是延迟。为了处理大量数据，在开始查询之前，需要提供一组CPU/内存对(在BigQuery中称为“slots”)。而且就算很快，也就1秒左右。<em class="kr">即使数据量很低，或者查询很简单，过程也是一样的。</em></p><p id="a3f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这不是分析的问题，但不是实时的，如网站或API服务。</p><blockquote class="ks"><p id="88d0" class="kt ku hi bd kv kw kx ky kz la lb jn dx translated">需要像云SQL这样的低延迟数据库。</p></blockquote><h1 id="aa2d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz lc kb kc kd ld kf kg kh le kj kk kl bi translated">云SQL选项</h1><p id="2f3e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">云SQL是托管数据库服务，可以<strong class="is hj">运行MySQL、PostgreSQL和SQL server </strong>。这些数据库引擎可以在几毫秒内回答简单的查询，非常适合网站和API服务器。</p><p id="a3f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，<strong class="is hj">云SQL数据库不能横向扩展</strong>(并行添加额外的服务器来处理数据)，而<strong class="is hj">只能纵向扩展</strong>(增加一台服务器上的CPU和内存的数量)。<em class="kr">读取副本(并行的附加服务器)也可以只在一个服务器(副本)上运行查询。</em></p><p id="3583" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，<strong class="is hj">性能低下</strong>无法有效处理<strong class="is hj">大量数据</strong>(限制为10tb)</p><h1 id="96f9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">以低延迟提供强大的洞察力</h1><p id="3c13" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hj">企业需要强大的洞察力</strong>，能够计算和深入挖掘数Pb的数据，并能够以低延迟浏览结果<strong class="is hj"/>。</p><p id="c2f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最理想的是结合两个世界，但是独角兽并不存在！</p><blockquote class="ks"><p id="4a44" class="kt ku hi bd kv kw kx ky kz la lb jn dx translated">解决方案是在BigQuery中执行计算，并将结果导出到Cloud SQL以降低延迟。</p></blockquote><h2 id="96ec" class="lf jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">数据重复问题</h2><p id="6814" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">数据复制可能很可怕，或者被视为反模式。没那么明显。</p><ul class=""><li id="94d5" class="lt lu hi is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb bi translated"><strong class="is hj">数据重复增加成本！</strong> <br/>是的，是真的。然而，数据<strong class="is hj">存储成本比数据处理成本约低10倍</strong>，复制数据以优化处理<strong class="is hj">可以节省资金</strong>！</li><li id="cc13" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated"><strong class="is hj">重复数据失控。</strong> <br/>这可能是真的。在这种情况下，我们<strong class="is hj">需要定义“金源”。</strong>这里是BigQuery，<strong class="is hj">云SQL数据只在这里只读</strong>。不允许更新。<em class="kr">双向更新可能是一场管理噩梦；在这里，对于报告数据，我们用“主/复制”模式来避免这种担心。</em></li></ul><h1 id="9aa8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">将BigQuery数据加载到云SQL</h1><p id="b72d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><a class="ae mh" href="https://cloud.google.com/bigquery/docs/exporting-data#bq" rel="noopener ugc nofollow" target="_blank"> BigQuery允许<strong class="is hj">导出CSV文件</strong> </a>中的数据，并将文件存储在云存储中。<br/> <a class="ae mh" href="https://cloud.google.com/sql/docs/mysql/import-export/import-export-csv#import_data_from_a_csv_file" rel="noopener ugc nofollow" target="_blank">云SQL允许<strong class="is hj">从云存储中导入CSV文件</strong> </a>。</p><p id="2c69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原则上，这个过程似乎是显而易见的。<strong class="is hj">然而，事情没那么简单！</strong></p><ul class=""><li id="a5de" class="lt lu hi is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb bi translated">BigQuery在几个文件中导出大量数据<strong class="is hj">。</strong></li><li id="de26" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated">云存储<strong class="is hj">一次只能导入一个文件</strong>。不支持并发导入</li></ul><blockquote class="ks"><p id="e473" class="kt ku hi bd kv kw mi mj mk ml mm jn dx translated">为了对这个过程进行排序，需要一个编排。云工作流非常适合这一点！</p></blockquote><p id="4052" class="pw-post-body-paragraph iq ir hi is b it mn iv iw ix mo iz ja jb mp jd je jf mq jh ji jj mr jl jm jn hb bi translated">我们来写这个管道吧！</p><h2 id="8819" class="lf jp hi bd jq lg ms li ju lj mt ll jy jb mu ln kc jf mv lp kg jj mw lr kk ls bi translated">导出BigQuery数据</h2><p id="d2ab" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><a class="ae mh" href="https://cloud.google.com/bigquery/docs/exporting-data#bq" rel="noopener ugc nofollow" target="_blank"> BigQuery可以<strong class="is hj">导出存储在</strong>表</a>中的数据。它是免费的，但是你<strong class="is hj">不能选择你想要的数据</strong>或者<strong class="is hj">格式化/转换它们</strong>。它是以CSV格式将BigQuery存储复制并粘贴到云存储中。</p><p id="994e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这并不理想，因为我们必须<strong class="is hj">正确格式化要插入到云SQL </strong>中的数据。希望存在另一个选项:<a class="ae mh" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements#export_data_statement" rel="noopener ugc nofollow" target="_blank">出口声明</a>。</p><p id="e636" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该语句接受export的选项和参数中的查询。<strong class="is hj">查询的结果存储在云存储中的一个或多个文件</strong>中。<br/>一个简单的<strong class="is hj">查询执行导出</strong>！还有一个<a class="ae mh" href="https://cloud.google.com/workflows/docs/reference/googleapis/bigquery/v2/jobs/insert" rel="noopener ugc nofollow" target="_blank">工作流连接器用于运行查询！</a></p><p id="ef93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从这一步开始我们的工作流程。</p><pre class="mx my mz na fd nb nc nd ne aw nf bi"><span id="976a" class="lf jp hi nc b fi ng nh l ni nj">- export-query:<br/>    call: googleapis.bigquery.v2.jobs.query<br/>    args:<br/>      projectId: ${projectid}<br/>      body:<br/>        query: ${"EXPORT DATA OPTIONS( uri='gs://" + bucket + "/" + prefix + "*.csv', format='CSV', overwrite=true,header=false) AS " + query}<br/>        useLegacySql: false</span></pre><p id="deb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">因为你必须</em> <strong class="is hj"> <em class="kr">插入一个作业并读取数据</em> </strong> <em class="kr">，运行工作流的服务账号必须</em> <strong class="is hj"> <em class="kr">有权限访问数据</em> </strong> <em class="kr">(至少是</em> <code class="du nk nl nm nc b"><em class="kr">bigquery.dataViewer</em></code> <em class="kr">)并且</em> <strong class="is hj"> <em class="kr">能够在项目中创建一个作业</em> </strong> <em class="kr">(是</em> <code class="du nk nl nm nc b"><em class="kr">bigquery.jobUser</em></code> <em class="kr">)。要在云存储中写入导出文件，需要角色</em> <code class="du nk nl nm nc b"><em class="kr">storage.objectAdmin</em></code> <em class="kr">。</em></p><h2 id="e3c0" class="lf jp hi bd jq lg ms li ju lj mt ll jy jb mu ln kc jf mv lp kg jj mw lr kk ls bi translated">在云SQL中导入数据</h2><p id="7dc5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在，我们必须将数据导入到云SQL中。可以对云SQL管理API 执行一个<strong class="is hj"> API调用。<br/>但是，这次<strong class="is hj">没有连接器</strong>，我们不得不<strong class="is hj">直接调用API。</strong></strong></p><pre class="mx my mz na fd nb nc nd ne aw nf bi"><span id="bec8" class="lf jp hi nc b fi ng nh l ni nj">- callImport:<br/>    call: http.post<br/>    args:<br/>      url: ${"https://sqladmin.googleapis.com/v1/projects/" + projectid + "/instances/" + instance + "/import"}<br/>      auth:<br/>        type: OAuth2<br/>      body:<br/>        importContext:<br/>          uri: ${file}<br/>          database: ${databaseschema}<br/>          fileType: CSV<br/>          csvImportOptions:<br/>            table: ${importtable}<br/>    result: operation</span></pre><p id="ed1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">为调用，可以</em> <strong class="is hj"> <em class="kr">注</em> </strong> <code class="du nk nl nm nc b"><strong class="is hj"><em class="kr">OAuth2</em></strong></code> <strong class="is hj"> <em class="kr"> auth引数</em> </strong> <em class="kr">。需要</em> <strong class="is hj"> <em class="kr">允许工作流给API调用</em> </strong> <em class="kr">添加认证头。工作流服务帐户需要是云SQL admin才能执行导入。</em></p><p id="5d24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为:</p><ul class=""><li id="f938" class="lt lu hi is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb bi translated"><strong class="is hj">操作是异步的</strong></li><li id="bf87" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated">没有用于异步操作的连接器</li><li id="1941" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated">如果要导入多个文件，一次只能导入<strong class="is hj">一个文件</strong></li></ul><p id="ec58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须:</p><ul class=""><li id="88f2" class="lt lu hi is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb bi translated">通过<strong class="is hj">定期检查当前导入操作的状态</strong>获得当前导入的结束。</li><li id="ddb7" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated">当工作完成后，<strong class="is hj">继续过程</strong>:迭代其他文件或退出。</li></ul></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><p id="f4f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们<strong class="is hj">可以在导入调用的<code class="du nk nl nm nc b">result</code>中获得状态</strong>。这个变量被命名为<code class="du nk nl nm nc b">operation</code>。<br/> <em class="kr">如果状态不是</em> <code class="du nk nl nm nc b"><em class="kr">DONE</em></code> <em class="kr">，我们必须等待并再次检查，否则我们可以退出。</em></p><pre class="mx my mz na fd nb nc nd ne aw nf bi"><span id="c897" class="lf jp hi nc b fi ng nh l ni nj">- chekoperation:<br/>    switch:<br/>      - condition: ${operation.body.status != "DONE"}<br/>        next: wait<br/>    next: completed<br/>- completed:<br/>    return: "done"<br/>- wait:<br/>    call: sys.sleep<br/>    args:<br/>      seconds: 1<br/>    next: getoperation<br/>- getoperation:<br/>    call: http.get<br/>    args:<br/>      url: ${operation.body.selfLink}<br/>      auth:<br/>        type: OAuth2<br/>    result: operation<br/>    next: chekoperation</span></pre><p id="ec87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">API很好的提供了一个</em> <code class="du nk nl nm nc b"><em class="kr">selflink</em></code> <em class="kr">来获取运行状态。由于它，检查查询是最容易的。</em></p><h2 id="be81" class="lf jp hi bd jq lg ms li ju lj mt ll jy jb mu ln kc jf mv lp kg jj mw lr kk ls bi translated">浏览云存储中的导出文件</h2><p id="540d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们有这个过程的两个方面:出口和进口。<strong class="is hj">我们必须绑定它们</strong>，而<strong class="is hj">云存储就是建立关系的地方</strong>。但是……<strong class="is hj">这种联系并不容易！</strong></p><p id="aba2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，如果您仔细查看导入定义，您可以<strong class="is hj">一次只导入一个文件</strong>。而<strong class="is hj"> BigQuery导出可以创建一组文件</strong>。</p><p id="050b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们必须在导出期间<strong class="is hj">迭代BigQuery </strong>创建的文件，并为每个文件调用云SQL流程中的<strong class="is hj">导入步骤(或<a class="ae mh" href="https://cloud.google.com/workflows/docs/reference/syntax/subworkflows" rel="noopener ugc nofollow" target="_blank">子工作流</a></strong></p><pre class="mx my mz na fd nb nc nd ne aw nf bi"><span id="956e" class="lf jp hi nc b fi ng nh l ni nj">- list-files:<br/>    call: googleapis.storage.v1.objects.list<br/>    args:<br/>      bucket: ${bucket}<br/>      pageToken: ${pagetoken}<br/>      prefix: ${prefix}<br/>    result: listResult<br/>- process-files:<br/>    for:<br/>      value: file<br/>      in: ${listResult.items}<br/>      steps:<br/>        - wait-import:<br/>            call: load_file<br/>            args:<br/>              projectid: ${projectid}<br/>              instance: ${instance}<br/>              databaseschema: ${databaseschema}<br/>              importtable: ${importtable}<br/>              file: ${"gs://" + bucket + "/" + file.name}1</span></pre></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><p id="b72f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，如果你有大量的文件，<strong class="is hj">云存储列表API答案可以包含几页</strong>。我们必须遍历文件和页面。</p><p id="2d03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在<a class="ae mh" href="https://github.com/guillaumeblaquiere/workflow-bq-to-cloudsql" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>中看到的，子工作流<code class="du nk nl nm nc b">list_file_to_import</code> <strong class="is hj">不是递归的，在浏览下一页时不会调用自己</strong>。将<strong class="is hj">整体结果</strong> <code class="du nk nl nm nc b"><strong class="is hj">listResult</strong></code> <strong class="is hj">发送回调用者</strong>。</p><p id="28d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，云<strong class="is hj">工作流在子工作流调用的深度</strong>上有一个限制，如果达到这个限制，你可以<a class="ae mh" href="https://cloud.google.com/workflows/docs/troubleshooting#execution_errors" rel="noopener ugc nofollow" target="_blank">获得一个</a> <code class="du nk nl nm nc b"><a class="ae mh" href="https://cloud.google.com/workflows/docs/troubleshooting#execution_errors" rel="noopener ugc nofollow" target="_blank">RecursionError</a></code>。<br/>所以，<strong class="is hj">诀窍是退出子工作流</strong>，用所需的信息给<strong class="is hj">让调用者选择用不同的参数再次调用同一个子工作流</strong>，在那种情况下是<code class="du nk nl nm nc b">nextPageToken</code>。</p></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><p id="3287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">你可以在GitHub资源库</em>  <em class="kr">中找到</em> <a class="ae mh" href="https://github.com/guillaumeblaquiere/workflow-bq-to-cloudsql/blob/main/import.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="kr">完整的工作流代码。您需要自定义分配步骤来设置您的值，或者更新此第一步以从工作流参数中动态获取值。<br/>如果您有问题要自动处理，您可能还需要添加一些错误管理检查</em></a></p><h1 id="c906" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">生产您的同步</h1><p id="1637" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">随着工作流的构建和部署，您必须在需要时执行它。可以是一个时间表，用<a class="ae mh" href="https://cloud.google.com/workflows/docs/schedule-workflow" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">云调度器</strong> </a>，也可以是一个事件。</p><p id="7f06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，你必须<strong class="is hj">编写一个云函数(或云运行/应用引擎)来捕捉事件并运行一个工作流</strong>执行。不过，很快，你就可以用<a class="ae mh" href="https://cloud.google.com/eventarc/docs" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">event arc</strong></a><strong class="is hj">开箱</strong>做<strong class="is hj">了。</strong></p></div><div class="ab cl nn no gp np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hb hc hd he hf"><p id="8a24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据分析和低延迟数据库<strong class="is hj">是互补的</strong>，为了利用两者的力量，一个<strong class="is hj">安全和协调的工作流是达到下一个水平的正确途径</strong>。</p></div></div>    
</body>
</html>