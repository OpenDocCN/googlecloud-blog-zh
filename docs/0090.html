<html>
<head>
<title>A to Z of Google Cloud Platform a personal selection — R — Rolling Updates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云平台的a到Z个人精选— R —滚动更新</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-r-rolling-updates-fb6634c5f400?source=collection_archive---------0-----------------------#2016-04-17">https://medium.com/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-r-rolling-updates-fb6634c5f400?source=collection_archive---------0-----------------------#2016-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将讲述如何在GCP计算产品上实现应用程序的滚动更新。</p><p id="fd4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之前，我只想确保我们在我所说的滚动更新的意思上是一致的。</p><p id="2e73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我所说的滚动更新是指在几乎没有停机时间的情况下发布新版本软件的能力。当推出新版本时，软件的先前版本被推出，直到单步更新过程结束，只有软件的新版本在运行。除了推出更新之外，您还必须能够暂停推出，并在需要时回滚。如果你没有能力从垃圾部署中恢复，那么这是一条单行道！</p><p id="72f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对应用程序进行更新的另一种方法是canary发布。在canary版本中，你可以在发布现有版本的同时发布新版本，但是无论你在新版本和旧版本并行运行后做出什么决定，你都不只是继续推出更新，而是在一段时间内停止更新过程。如果新版本变得有点糟糕，你最终会完全或不完全切换到新版本。看一看<a class="ae jd" href="http://martinfowler.com/bliki/CanaryRelease.html" rel="noopener ugc nofollow" target="_blank">这里</a>的金丝雀释放的一个很好的演练。</p><p id="4e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不打算讨论每种方法的利弊，尽管我觉得那样会让这篇文章偏离主题。所以从现在开始:-)</p><h2 id="8a41" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">使用GCE滚动更新</h2><p id="0090" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我将在这里讨论的内容假设您为每个新版本“烘焙”了新的定制图像。</p><p id="d0ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GCP有一个很棒的<a class="ae jd" href="https://cloud.google.com/solutions/automated-build-images-with-jenkins-kubernetes" rel="noopener ugc nofollow" target="_blank">解决方案&amp;教程</a>(感谢@evandbrown)使用Jenkins、packer和kubernetes创建“烘焙”图像。因此，如果你有兴趣了解如何建立一个CI/CD系统来烘焙/创建你自己的定制图像，这绝对值得一读。</p><p id="51c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我知道你可以使用一个配置管理工具在你的车队中推出应用程序级更新，但是通过将实例视为不可变的，你可以很容易地利用使用<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/#create_managed_group" rel="noopener ugc nofollow" target="_blank">管理的实例组</a>来实现滚动更新。</p><p id="71d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">托管实例组使用<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-templates" rel="noopener ugc nofollow" target="_blank">实例模板</a>来定义组中每个实例的属性。</p><p id="9324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在创建实例的常规请求中定义的任何设置都可以在实例模板中描述，包括任何实例元数据、启动脚本、持久性磁盘、服务帐户等。</p><p id="a697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过在<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/#starting_an_update" rel="noopener ugc nofollow" target="_blank">滚动更新</a>中指定一个新模板，您可以轻松地更新组中的所有实例。</p><p id="3124" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要开始滚动更新，您需要遵循下面概述的步骤(详细步骤请参见<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/#starting_an_update" rel="noopener ugc nofollow" target="_blank">文档</a>)。本高级演练假设您已经有一批通过托管实例组定义和管理的实例。</p><ol class=""><li id="9b07" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">请求进入<a class="ae jd" href="https://docs.google.com/forms/d/1zQa29jRJTDX_1A3_L7QHdeh6sRd8Z21HIqLSLb7RCrk/viewform" rel="noopener ugc nofollow" target="_blank">滚动更新功能</a></li><li id="4702" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">启用实例组更新程序API，您将看到此屏幕</li></ol><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es ks"><img src="../Images/a0db9dfa14fd1c3294f56b87c3522c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/0*Hj2iBfWXfKicDo_J."/></div></figure><p id="b6d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们使用GCE，所以您不需要创建任何其他凭证，并且您可以开始使用API</p><p id="a50b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.使用更新的属性创建新模板。因此，假设您已经创建了一个新图像，您可以将该图像的名称添加到模板中</p><p id="b6e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.使用gcloud命令或<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/updater/v1beta1/rollingUpdates" rel="noopener ugc nofollow" target="_blank"> API </a>开始更新。您可以通过传递想要的值来更改默认值。</p><p id="bbc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面列出了您可以更改的可选标志。它们给你一个很好的指示，告诉你如何控制更新，并满足我的要求，能够放弃推出。</p><p id="8d27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">— max-num-concurrent-instances，它定义了同时更新的实例数量。</p><p id="4951" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">— instance-startup-timeout，定义应用更新后更新等待实例启动的最大秒数。如果实例没有在时间限制之前启动，更新程序会将更新记录为失败。</p><p id="ba53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">— min-instance-update-time，定义更新程序更新每个实例所用的最小秒数。更新程序仅在当前更新完成且花费的更新时间最短时才开始下一次更新。</p><p id="1e59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">— max-num-failed-instances，它定义在更新程序将整个组更新记录为失败之前，可以失败的最大实例更新数。</p><p id="f9bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">—实例后自动暂停，指示更新特定数量的实例后自动暂停更新。暂停之后，你可以决定是<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/#cancelrollingupdate" rel="noopener ugc nofollow" target="_blank">取消</a>还是<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/#continuerollingupdate" rel="noopener ugc nofollow" target="_blank">继续</a>更新。</p><p id="5cda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动滚动更新的默认gcloud命令如下所示:</p><pre class="kt ku kv kw fd la lb lc ld aw le bi"><span id="ba23" class="je jf hi lb b fi lf lg l lh li">gcloud alpha compute rolling-updates start \<br/><br/>--group example-group \<br/>--template example-template \<br/>--zone us-central1-f</span></pre><p id="3213" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以传递上面列出的可选标志来覆盖gcloud命令的默认值。</p><p id="20b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">滚动更新可以应用于所有实例组，无论它们是否启用了<a class="ae jd" href="https://cloud.google.com/compute/docs/autoscaler/" rel="noopener ugc nofollow" target="_blank">自动缩放</a>。查看<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/#rollingupdateandautoscaler" rel="noopener ugc nofollow" target="_blank">文档</a>了解自动缩放托管实例组和滚动更新如何交互的详细信息。</p><h2 id="0c30" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">与GKE滚动更新</h2><p id="c51f" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">GKE (Google Container Engine)是GCP完全托管的kubernetes服务，因此当我们谈论如何实现滚动更新时，我们谈论的是如何更新您在kubernetes集群上运行的应用程序或组件。当我谈论GCP时，我指的是GKE，但我描述的关于GKE滚动更新的大部分内容实际上是指k8s(kubernetes的缩写)</p><p id="c2f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下表描述了Kubernetes的概念</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/1dfc12632b178f6a9f6aadd67581da13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DlDNx9cF_f8PbJiH."/></div></div></figure><p id="82c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的应用程序容器被部署到一个pod。</p><p id="55ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器绝对应该被视为不可变的。是的，我没有进入辩论，没有让你做决定，只是陈述，并把它留在这里！这意味着当您更新应用程序或微服务组件时，您将创建一个新的容器映像。</p><p id="4719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">滚动更新过程基本上是用更新的容器替换正在运行的容器。</p><p id="ee38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种方法可以通过复制控制器或通过部署来管理您的应用程序，因此根据您选择的配置，滚动更新过程会略有不同。使用部署应该是所使用的方法，所以这就是我将要谈论的。</p><p id="9552" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么什么是部署呢？你可能会问。<a class="ae jd" href="http://kubernetes.io/docs/user-guide/deployments/" rel="noopener ugc nofollow" target="_blank">部署</a>为<a class="ae jd" href="http://kubernetes.io/docs/user-guide/pods/" rel="noopener ugc nofollow" target="_blank">容器</a>和<a class="ae jd" href="http://kubernetes.io/docs/user-guide/replicasets/" rel="noopener ugc nofollow" target="_blank">副本集</a>(下一代复制控制器)提供声明性更新。您只需要在一个部署对象中描述期望的状态，部署控制器就会以可控的速度为您将实际状态更改为期望的状态。(GKE管理的k8s版本支持)</p><p id="03db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kubernetes文档会向您详细介绍什么是部署以及如何使用，所以我不会重复。</p><p id="6452" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个名为webapp-deployment.yaml的示例部署yaml文件</p><pre class="kt ku kv kw fd la lb lc ld aw le bi"><span id="1cef" class="je jf hi lb b fi lf lg l lh li">apiVersion: extensions/v1beta1</span><span id="2bc1" class="je jf hi lb b fi lo lg l lh li">kind: Deployment</span><span id="a9ac" class="je jf hi lb b fi lo lg l lh li">metadata:</span><span id="5138" class="je jf hi lb b fi lo lg l lh li">name: webapp-deployment</span><span id="60eb" class="je jf hi lb b fi lo lg l lh li">spec:</span><span id="ada2" class="je jf hi lb b fi lo lg l lh li">replicas: 3</span><span id="e736" class="je jf hi lb b fi lo lg l lh li">template:</span><span id="6593" class="je jf hi lb b fi lo lg l lh li">metadata:</span><span id="38ab" class="je jf hi lb b fi lo lg l lh li">labels:</span><span id="45fc" class="je jf hi lb b fi lo lg l lh li">app: mywebapp</span><span id="f440" class="je jf hi lb b fi lo lg l lh li">spec:</span><span id="0b42" class="je jf hi lb b fi lo lg l lh li">containers:</span><span id="5818" class="je jf hi lb b fi lo lg l lh li">- name: mywebapp</span><span id="c081" class="je jf hi lb b fi lo lg l lh li">image: mywebapp:1.0.1</span><span id="908b" class="je jf hi lb b fi lo lg l lh li">ports:</span><span id="36f9" class="je jf hi lb b fi lo lg l lh li">- containerPort: 80</span></pre><p id="78ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它用于部署一个名为mywebapp的映像，该映像的版本是1.0.1，并且将打开mywebapp的3个pod</p><p id="f5ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们假设您已经有了一个<a class="ae jd" href="https://cloud.google.com/container-engine/docs/clusters/operations#creating_a_container_cluster" rel="noopener ugc nofollow" target="_blank"> GKE集群并正在运行</a>，并且已经部署了这个版本(参见<a class="ae jd" href="http://kubernetes.io/docs/user-guide/deployments/#creating-a-deployment" rel="noopener ugc nofollow" target="_blank">文档</a>了解如何部署到正在运行的集群)</p><p id="348f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要对您的应用程序实施滚动更新，以下是所需步骤的总结:</p><ol class=""><li id="9ac4" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">创建一个包含您的更新应用程序或微服务的新容器映像，并将其推送到您的映像存储库中</li><li id="584c" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">使用上面的例子，我们将把我们的容器映像my-app从1.0.1更新到2.0.0</li><li id="f421" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">然后，您可以执行以下两项操作之一来执行更新:</li><li id="93e5" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">创建一个名为new-webapp-deployment.yaml的新部署yaml文件，该文件将image: my-app:1.0.1修改为my-app:2.0.0</li><li id="52c1" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">通过运行以下命令来部署部署:</li></ol><pre class="kt ku kv kw fd la lb lc ld aw le bi"><span id="503c" class="je jf hi lb b fi lf lg l lh li">$ kubectl apply -f my-folder/new-webapp-deployment.yaml<br/>deployment “webapp-deployment” configured</span></pre><p id="c371" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，您可以使用kubectl edit直接编辑部署(注意，除非您想在vi中找到自己，然后确保您设置了KUBE编辑器或编辑器环境变量)。编辑部署并更改<strong class="ih hj">. spec . template . spec . containers[0]。图片</strong>从<strong class="ih hj"> mywebapp:1.0.1 </strong>到<strong class="ih hj"> mywebapp:2.0.0 </strong></p><pre class="kt ku kv kw fd la lb lc ld aw le bi"><span id="ac1f" class="je jf hi lb b fi lf lg l lh li">$ kubectl edit deployment/webapp-deployment<br/>deployment “webapp-deployment” edited</span></pre><p id="1bd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这执行了一个<a class="ae jd" href="http://kubernetes.io/docs/user-guide/deployments/#rolling-update-deployment" rel="noopener ugc nofollow" target="_blank">滚动更新</a>。如果您按照GKE/K8s文档中的hello world示例进行操作，就可以看到这一点。特别要注意的是，它不会破坏所有运行旧版本的pod，而是保持一些运行，直到有一些新的pod运行更新的应用程序。不过真正巧妙的是，使用<strong class="ih hj">. spec . strategy . type = = rolling update</strong>可以指定<strong class="ih hj"> maxUnavailable </strong>和<strong class="ih hj"> maxSurge </strong>来控制滚动更新过程。<a class="ae jd" href="http://kubernetes.io/docs/user-guide/deployments/#rolling-update-deployment" rel="noopener ugc nofollow" target="_blank">文档</a>对此有很好的解释</p><p id="97aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了满足我的滚动更新标准，您必须能够回滚到以前的版本，GKE / k8s允许通过实现方法<strong class="ih hj"> .spec.rollbackTo </strong>和<strong class="ih hj">. spec . roll back to . revision</strong>或使用kubectl命令:<strong class="ih hj">kube CTL rollout undo deployment</strong>来实现这一点，因此在我们的示例中，要使用<a class="ae jd" href="http://kubernetes.io/docs/user-guide/kubectl/kubectl_rollout/" rel="noopener ugc nofollow" target="_blank"> kubectl rollout </a>命令回滚到my-app的以前版本，我们将使用:</p><pre class="kt ku kv kw fd la lb lc ld aw le bi"><span id="7a58" class="je jf hi lb b fi lf lg l lh li">$ kubectl rollout undo webapp-deployment</span></pre><p id="1d67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以回滚到特定版本。</p><h2 id="e72c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">与GAE滚动更新</h2><p id="0665" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">GAE是需要最少客户配置和管理的计算目标，您会认为它是进行滚动部署的最直接方式，您这样想是对的。</p><p id="8fff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GAE允许你上传不同版本的应用程序并切换到那个版本。你也可以分流流量，但这不符合我对滚动更新的定义。</p><p id="c1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">App engine默认从你应用的默认版本提供流量(我知道说一句笨拙的话！) .你可以上传一个新版本，这将不会提供任何流量，直到你切换到你刚刚上传的新版本</p><p id="11f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用python和App Engine标准来阐述这个公认的简短描述。</p><p id="63d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GCP提供了一个名为appcfg.py的工具，用于上传你的python应用程序的新版本(GO也使用这个工具，但是Java使用maven，所以检查语言特定的文档)</p><p id="f321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的第一次部署会自动成为默认部署，并为100%的流量提供服务。</p><p id="defe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用appcfg.py来<a class="ae jd" href="https://cloud.google.com/appengine/docs/python/tools/uploadinganapp" rel="noopener ugc nofollow" target="_blank">上传</a>您的新版本，然后您将在控制台中看到您现在有了应用程序的两个版本</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es lp"><img src="../Images/532164afb7c01be325798f06fbe95d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*49QYL_kNp4QHF6nf."/></div></figure><p id="9fff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过选中版本2旁边的复选框，您可以路由所有或部分流量，或将所有流量迁移到此版本。要实施滚动部署，请选择<a class="ae jd" href="https://cloud.google.com/appengine/docs/python/console/#traffic-migration" rel="noopener ugc nofollow" target="_blank">迁移流量</a>。迁移需要很短的时间(可能几分钟)，确切的时间间隔取决于应用程序接收的流量和运行的实例数量。迁移完成后，新版本将接收100%的流量。</p><p id="9865" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用流量迁移时，您应该使用<a class="ae jd" href="https://cloud.google.com/appengine/docs/python/config/appconfig#Python_Warmup_requests" rel="noopener ugc nofollow" target="_blank">预热请求</a>在任何实时请求到达新实例之前将应用程序代码加载到该实例中，从而在您切换到新版本时帮助您的用户减少请求延迟</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es lq"><img src="../Images/ee6b9edb33d76862e0d3220029129e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*hVAwyjt-j8oZ1NEh."/></div></figure><p id="8b13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以加载10个不同的版本，并轻松地切换到其中任何一个。</p><p id="f182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lr">请注意，我描述的流量迁移功能仅在App Engine标准环境中可用</em></p><p id="df11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用引擎灵活环境的行为略有不同，因为当您创建新版本的应用时，您会创建一个新的Docker容器，并使用<a class="ae jd" href="https://cloud.google.com/sdk/gcloud/reference/preview/app/deploy" rel="noopener ugc nofollow" target="_blank"> gcloud app deploy </a>命令自动构建Docker容器并将流量切换到这个新版本。</p><p id="c671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过使用-no-promote标志来覆盖这种默认行为</p></div></div>    
</body>
</html>