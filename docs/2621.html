<html>
<head>
<title>Cloud Functions Best Practices (2/4) : Optimize the Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云功能最佳实践(2/4):优化云功能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-functions-best-practices-2-4-optimize-the-cloud-functions-5874f9d8c8b5?source=collection_archive---------0-----------------------#2022-12-13">https://medium.com/google-cloud/cloud-functions-best-practices-2-4-optimize-the-cloud-functions-5874f9d8c8b5?source=collection_archive---------0-----------------------#2022-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d222" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码，调用，完美地构造你的函数代码</p><p id="a5c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是4篇文章系列的一部分，其中我给出了关于Google云功能开发的各种建议。这项工作是两年日常实践、部署和监测的结果。其中一些最佳实践直接来自官方文档，另一些来自我的经验，被证明是最有效的。对于任何不同的观点，请随意评论这篇(免费)文章。谢谢！</p><p id="5227" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&lt;&lt;&lt; <a class="ae je" href="https://beranger.medium.com/cloud-functions-best-practices-1-4-get-the-environment-ready-af666af89f62" rel="noopener">云功能最佳实践(1/4):准备好环境</a></p><p id="dcf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://beranger.medium.com/cloud-functions-best-practice-3-4-secure-the-cloud-functions-1c9642c4706" rel="noopener">云功能最佳实践(3/4):保护云功能</a> &gt; &gt; &gt;</p><p id="0576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://beranger.medium.com/cloud-functions-best-practice-4-4-monitor-and-log-the-executions-22222aa25f1b" rel="noopener">云功能最佳实践(4/4):监控和记录执行</a> &gt; &gt; &gt;</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="b806" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">优化云功能</h1><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/65db412f692f07d8aaa177bfc2268eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMeAeFRNHCwjbPpGoK3xmg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">罕见的野生云函数图像</figcaption></figure><p id="2ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在线教程很酷，我的甚至超级酷！；)通过一堆文章，任何人都可以学习<a class="ae je" href="https://beranger.medium.com/native-implementation-of-google-secret-manager-in-cloud-functions-93a1732dd175" rel="noopener">如何在Google Cloud Functions中使用Secret Manager</a>，<a class="ae je" href="https://beranger.medium.com/secure-google-cloud-functions-with-api-gateway-848f687963ae" rel="noopener">如何保护一个Google Cloud Function </a> s，<a class="ae je" href="https://beranger.medium.com/rate-limit-google-cloud-functions-with-api-gateway-19b54bb9d9e9" rel="noopener">如何对它们进行速率限制</a>，如何使用云存储、Cloud Pub/Sub以及每一个可能的工具。</p><p id="6e24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，</p><p id="4c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它有一个很大的缺点教程是为一个单一的、简短的、特定的主题而制作的。</p><p id="5c31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">商业项目绝不是简短和具体的。</p><p id="051f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">业务项目结合了多种云功能，使用各种需要尝试、测试和调试的工具，希望是高效的。</p><p id="5551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何做到这一点在单功能教程中没有解释。</p><p id="c7ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我在第二篇文章中讨论的优化函数代码，以支持多云函数管理、快速调用、安全部署和高效测试与调试。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="7acd" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">分割和委派</h1><p id="e520" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在谷歌云功能使用几个月后，功能之间可能会有一些复制粘贴:向Slack发送消息，<a class="ae je" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjD1tSUvKv7AhXZSfEDHRELA8QQFnoECCEQAQ&amp;url=https%3A%2F%2Fpython.plainenglish.io%2Fhow-to-read-write-label-mails-from-gmail-with-python-9695f288f685&amp;usg=AOvVaw3d7ADldB1wEKfPWLalSj1B" rel="noopener ugc nofollow" target="_blank">使用Gmail发送电子邮件，</a><a class="ae je" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjoo5iMvKv7AhWMQvEDHUfpBQ0QFnoECA4QAQ&amp;url=https%3A%2F%2Fpython.plainenglish.io%2Fmaster-google-sheets-api-in-python-cheat-sheet-3535e86fbe17&amp;usg=AOvVaw1ILJzWO7_TNqX9f9DpucUi" rel="noopener ugc nofollow" target="_blank">使用谷歌表单，</a>，登录BigQuery以及更多的用例。</p><p id="50ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果Slack更新了他们的API会怎么样？如果一个新的参数被用于一堆Google云函数的API所要求，那该怎么办？</p><p id="7bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将是地狱，以更新他们所有人，重新部署和重新测试他们。</p><p id="83c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我强烈推荐为特定任务创建通用函数。</p><p id="c244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">架构变化如下:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lf"><img src="../Images/677f8effe9d4654117f5f7d23dcecbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sCGV4h4Oubf5tvYANXgcg.jpeg"/></div></div></figure><p id="49ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我同意…从这个角度来看，创建、部署和监控云功能会更加复杂。</p><p id="21f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这里的要点是为每个使用的API创建一个特定的通用函数，如果这个API在将来可能被重用的话。</p><p id="b295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那条路怎么样？&gt;&gt;&gt;</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lg"><img src="../Images/4c942800402fdcbc682d47526d3c7407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNkwFjBB1redcLb4n8OZpw.jpeg"/></div></div></figure><p id="a1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下…你要改变左边配置的一个API的1个小参数…祝你好运！:D</p><p id="f865" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">右边的建筑有<strong class="ih hj">很多优点</strong>:</p><ul class=""><li id="9639" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">代码不会重复，便于任何更新、维护和测试(有点枯燥)</li><li id="1c69" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">函数执行更少的任务，更少的崩溃原因，便于调试，1个函数，1个任务</li><li id="5846" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">不再需要将slack、gmail和多个包导入一个功能中</li><li id="a353" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">因为不需要导入，<a class="ae je" href="https://beranger.medium.com/reduce-cold-start-and-execution-time-of-google-cloud-functions-9830280962ff" rel="noopener">冷启动时间和执行时间更快了</a>，CPU使用率也降低了</li><li id="34ca" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">通过发布/订阅将一个通用云功能链接到另一个云功能是小菜一碟(3行)，如果您想添加一个Slack通知程序或Gmail发送程序，几乎不需要测试…</li></ul><blockquote class="lv lw lx"><p id="6ecf" class="if ig jd ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated"><em class="hi">但是，我该怎么做呢？</em></p></blockquote><p id="33a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，创建一个通用的云函数(在这个例子中是一个Slack publisher):</p><pre class="kl km kn ko fd mb mc md bn me mf bi"><span id="1f3e" class="mg jn hi mc b be mh mi l mj mk">from slack import WebClient<br/>import base64<br/>import json<br/># ...<br/><br/>def slack_connection():<br/>    try:<br/>        client = WebClient(token=SLACK_TOKEN)<br/><br/>    except Exception as e:<br/>        print('End-Slack Error', e)<br/>        return<br/><br/>    return client<br/><br/>def main(event, context):<br/><br/>  event_data = base64.b64decode(event['data']).decode('utf-8')<br/>  req = json.loads(event_data)<br/><br/>  text, channel = req.get('text', ''), req.get('channel', '')<br/>  <br/>  #<br/>  # Send message to slack...<br/>  #<br/><br/>  return 1</span></pre><p id="b5c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并将其部署为后台功能:</p><pre class="kl km kn ko fd mb mc md bn me mf bi"><span id="1f9b" class="mg jn hi mc b be mh mi l mj mk">gcloud functions deploy generic_slack --region=europe-west2 --entry-point mail --runtime python310 --trigger-topic='generic_slack'</span></pre><p id="efca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有一个云函数，带一个文本和一个频道属性，发布到Slack。</p><p id="d3ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将它作为后台功能可以保护它不被任何人访问。</p><p id="0466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在<strong class="ih hj">任何</strong>云函数中，我们只需要添加这些行:</p><pre class="kl km kn ko fd mb mc md bn me mf bi"><span id="d711" class="mg jn hi mc b be mh mi l mj mk">from google.cloud import pubsub_v1<br/>import json<br/><br/>TOPIC_SLACK = 'projects/YOUR-PROJECT/topics/generic_slack'<br/><br/>publisher = pubsub_v1.PublisherClient()<br/><br/>def publish_slack(text):<br/><br/>    body = {<br/>        "text": text,<br/>        "channel": "#random"<br/>    }<br/>    <br/>    publisher.publish(TOPIC_SLACK, json.dumps(body).encode('utf-8'))<br/><br/>#<br/># ... inside the main function<br/>#<br/>publish_slack("Hello, I'm generic, light, efficient and easy to send!")</span></pre><p id="c23b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个代码片段的开始，我们导入PubSub，创建一个通用函数(通用云函数的),然后用我们的自定义文本调用这个函数。</p><p id="7eaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你想添加用户名或自定义表情符号吗？</p><p id="f2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有比这更简单的了，我们只需要回到我们的Slack Cloud函数，更新代码和输入，我们就可以开始了！:)</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="dc62" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">智能缓存</h1><p id="e5a6" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">云函数是无状态的，这也是我们喜欢它的原因！</p><p id="9747" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着在两次调用之间，没有共享任何东西:全局变量、内存、文件系统或其他状态。</p><p id="2dbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">…</p><p id="57e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么都没有？</p><p id="1909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">…</p><p id="cf42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，启动一个新函数会加载很多东西:运行时、包、你的代码。</p><p id="ce01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这被称为功能实例。</p><p id="84a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种加载需要几秒钟的时间，称为“冷启动”，这是预热功能所需的时间。</p><p id="cba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数实例不会在函数完成后马上消失。它将在云中“保持温暖”一会儿(如果幸运的话，在5-15分钟之间)，供将来的调用重用。</p><p id="56eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种魔力允许两件事:</p><ul class=""><li id="915f" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">减少冷启动，因为功能已经设置好了(见我以前的文章<a class="ae je" href="https://beranger.medium.com/reduce-cold-start-and-execution-time-of-google-cloud-functions-9830280962ff" rel="noopener">减少谷歌云功能的冷启动和执行时间</a></li><li id="0003" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">重用全局变量。全局变量可以在全局范围内实例化在任何函数之外，在文件的最开始。它的值可以在后续调用中重用，而不必重新计算。</li></ul><p id="30b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用全局作用域将缓存来自繁重计算过程和导入的值，这对于数据库连接特别有用，因此函数不必在每次调用时都进行连接。</p><p id="4739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具体来说，最好将缓存用于以下目的:</p><ul class=""><li id="acd7" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">访问Google APIs(比如Pub/Sub、Secret Manager、big query……)</li></ul><pre class="kl km kn ko fd mb mc md bn me mf bi"><span id="171a" class="mg jn hi mc b be mh mi l mj mk">from google.cloud import pubsub_v1<br/><br/>publisher = pubsub_v1.PublisherClient() # Publisher client is outside the main function to be reusable<br/><br/>def main(request):<br/>	# ... Your function code<br/>	publisher.publish(TOPIC, json.dumps(payload).encode('utf-8'))<br/>	# ...</span></pre><ul class=""><li id="4143" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">数据库连接</li><li id="1a2b" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">包导入</li></ul><p id="c18a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缓存的好与不好之间可能有几秒钟的差别。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="3a7f" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">做一个懒惰的进口商</h1><p id="cb51" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">成为一个懒惰的进口商将减少冷启动时间。</p><p id="fcac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般概念是只导入将在云功能执行期间使用的包。</p><p id="48b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">意思是…在主函数中导入包<em class="jd">。</em></p><p id="e595" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是一个常见的模式，坦率地说，它是丑陋的。一个好的技术领导者会拒绝这种进口的公关，但出于性能原因，这很酷！</p><p id="6493" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Lazy import回答了这个问题:为什么要导入可能用不到的包？</p><p id="49b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">软件包和依赖项是GCF冷启动性能的<a class="ae je" rel="noopener" href="/@duhroach/improving-cloud-function-cold-start-time-2eb6f5700f6">头号贡献者</a>。</p><p id="5fda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该最大限度地避免它们，更重要的是，如果不经常使用，在全局范围内避免它们。</p><p id="0e47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，只有被使用的依赖项必须被导入= &gt;如果有一个依赖项使用的特定函数，导入这个非常特定的函数。</p><p id="12ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，如果依赖项被用于一些特定的路径，它们应该被导入到这些路径的<strong class="ih hj">中。这不是标准做法，但它可以节省谷歌云功能冷启动的宝贵时间。</strong></p><p id="e8a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想说，如果一个包在不到75%的情况下被使用，那么惰性导入是有意义的。</p><p id="4d47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果一家银行希望在取款超过1000欧元后通知客户，这并不常见，云函数可能不需要在每次调用时都通知客户，可能有10%的情况，下面的代码很有意义:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="ml mm l"/></div></figure></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="e1f1" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">不要创建或删除文件</h1><p id="a658" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我们之前看到了函数实例可以被回收。全局变量，包可以在调用之间保持。</p><p id="4353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">文件也是如此！</p><p id="b1b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建到Google Cloud函数中的文件会消耗该函数可用的内存。这种记忆不是无限的(像星球的资源呵呵)。</p><p id="f170" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在云函数中创建许多文件可能会导致内存不足错误和后续的冷启动链接。</p><p id="91e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，创建一个文件到一个云函数中并没有太多的理由…除了一个API提供者强加的<em class="jd">离奇</em>案例。</p><p id="7cdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在创建之后或函数结束之前删除文件。</p><p id="5397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌云存储是为了文件相关的情况，可以处理文件创建，文件传输，文件转换。请参见下面的示例:</p><pre class="kl km kn ko fd mb mc md bn me mf bi"><span id="aea9" class="mg jn hi mc b be mh mi l mj mk">from google.cloud import storage<br/>import pandas as pd<br/><br/># Create storage client<br/>client = storage.Client()<br/><br/>bucket = client.get_bucket("any_bucket_name")<br/><br/>final_df = # any pandas df<br/><br/>blob = storage.Blob("file_name.csv", bucket)<br/><br/>blob.upload_from_string(final_df.to_csv(header=False), 'text/csv')</span></pre><p id="eb5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，csv文件将直接在云存储空间中创建！</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="c9a0" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">使用最小和最大实例</h1><p id="dbc0" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我将在2021年中期引入一个特性，继续这篇最佳实践文章。</p><p id="8607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最小实例和最大实例。</p><h2 id="5aea" class="mn jn hi bd jo mo mp mq js mr ms mt jw iq mu mv ka iu mw mx ke iy my mz ki na bi translated">最小实例</h2><p id="0104" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我想这个特性很简单，即使暂时没有请求，它也能让X实例保持温暖。</p><p id="ae34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，如果min-instances设置为&gt; 0，就不再有冷启动！</p><p id="7c71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我要补充几点说明:</p><ul class=""><li id="32f0" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">最小实例保持X个实例预热，X是在UI中填充或使用<code class="du nb nc nd mc b">-min-instances</code> gcloud标志的实例数，这意味着，如果同时调用超过X个函数，额外的n个函数将需要预热，仍然会有一些冷启动。</li><li id="cf70" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">这种行为没有硬性的保证。在官方文件中，他们声明:<code class="du nb nc nd mc b">Cloud Functions **attempts** to keep function instances idle for an unspecified amount of time after handling a request.</code></li><li id="7c75" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">在部署和崩溃之后，仍然会有冷启动</li></ul><p id="f4d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个特性是有代价的。这几乎就像支付一个24/7运行的云功能的价格(100%的GB秒价格)。<a class="ae je" href="https://cloud.google.com/functions/pricing" rel="noopener ugc nofollow" target="_blank">见定价</a>。对于低内存的云函数，它很便宜，但是如果函数需要大量内存，可能存在更便宜的解决方案。</p><p id="8765" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我强烈建议为面向用户的函数设置一个最小实例值。</p><h2 id="de9a" class="mn jn hi bd jo mo mp mq js mr ms mt jw iq mu mv ka iu mw mx ke iy my mz ki na bi translated">最大实例数</h2><p id="2d6b" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">Max instances不同于它的兄弟，它与冷启动无关。</p><p id="1465" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Max instances用于控制谷歌云功能的缩放行为。</p><p id="7caa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这个概念听起来很简单，我还是要补充一些见解:</p><ul class=""><li id="1c39" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">Max instances的目标是保护云功能。通过设置这一限制，开发人员可以确保运行的云功能不会超过该限制(在流量峰值的情况下，可能会稍微超过该限制)。</li><li id="ef24" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">每个云功能必备… <strong class="ih hj">每个云功能必备</strong>！在没有限制的情况下，一个云函数可以在几秒钟内扩展到1 000个实例，如果这个函数运行几个小时，就要花掉一大笔钱。<strong class="ih hj">设定一个值</strong>，即使很大。</li><li id="0464" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">更重要的是，通过HTTPs(防止DDoS攻击)可以从任何地方访问云功能</li><li id="55e3" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">对于访问API的云函数来说,<strong class="ih hj">甚至比</strong>更重要。原因有二:首先，云函数使用的外部API键如果超出了自身的限制，就会被阻塞。第二，如果这个功能是访问一个昂贵的服务，像Twilio这样的短信发送器…妈妈咪呀你<strong class="ih hj">搞砸了</strong>这个工作！还要考虑<a class="ae je" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiGzLGtvb_7AhXiQeUKHfrIATgQFnoECCQQAQ&amp;url=https%3A%2F%2Fberanger.medium.com%2Frate-limit-google-cloud-functions-with-api-gateway-19b54bb9d9e9&amp;usg=AOvVaw3x3Htly_GVArlQLFLnZUQ2" rel="noopener ugc nofollow" target="_blank">速率限制你的谷歌云功能</a>。</li></ul><p id="ef2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置max-instances后，将出现错误“<strong class="ih hj"> <em class="jd"> POST 429 […]请求被中止，因为没有可用的实例</em> </strong>”。</p><p id="3ce0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题是因为云函数收到的请求比可用实例多。</p><p id="fafe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个实例一次只能处理一个请求，同时请求的数量不应超过max-instances值。</p><p id="2622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有，哼，请求将在一个舒适的鞋盒中保温30秒，等待一个可用的实例。</p><p id="2896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有可用的实例，请求将会失败。</p><p id="cb09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哈！</p><p id="b5a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那又怎样？</p><p id="6b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">错误<strong class="ih hj"> <em class="jd"> POST 429 […]请求被中止，因为没有可用的实例</em> </strong>有3个紧急解决方案(灵感来自Guillaume Blaquiere在<a class="ae je" href="https://stackoverflow.com/questions/69495018/the-request-was-aborted-because-there-was-no-available-instance-google-cloud" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>上的回答):</p><ul class=""><li id="c066" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">增加最大实例值</li><li id="dba9" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">启用云函数<a class="ae je" href="https://cloud.google.com/functions/docs/bestpractices/retries#enabling_and_disabling_retries" rel="noopener ugc nofollow" target="_blank">重试</a>，也可以使用发布/订阅订阅，这提供了进行指数级重试的能力，并提供了很好的调优</li><li id="f37c" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">使用接受并行处理的产品，如云运行</li></ul><p id="e1f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，缩放可能需要时间，此错误可能会在放大时出现。</p><p id="a34e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要了解有关该器件的更多信息:</p><p id="1ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://cloud.google.com/functions/docs/configuring/min-instances" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/functions/docs/configuring/min-instances</a></p><p id="7bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://cloud.google.com/functions/docs/configuring/max-instances" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/functions/docs/configuring/max-instances</a></p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="2f84" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">使用本机机密管理器实现</h1><p id="f8a1" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果我们有多个函数共享的变量呢？</p><p id="fb93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这些变量像凭证一样敏感呢？</p><p id="92d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们必须更改一个在许多云函数中使用的变量/API键/ID，该怎么办？</p><p id="8125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你使用环境变量来存储秘密:这是一个非常糟糕的做法，请继续阅读</p><p id="1e16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud提出了一项名为Secret Manager的服务。</p><p id="7ba9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Secret Manager是一个全面管理的、集中的、安全的、方便的存储系统，用于存储秘密和任何种类的密钥。</p><p id="56af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Secret Manager中更改一个秘密将会在任何地方更改它。更重要的是，可以控制访问，并且可以独立管理访问权限。</p><p id="9d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于许多原因，使用Secret Manager的本机实现应该是首选，但出于许多原因，我不想在这里重复自己，因此出于许多原因，我将您重定向到以前的一篇文章，从可用性、性能和安全性方面进行比较:</p><div class="ne nf ez fb ng nh"><a href="https://beranger.medium.com/native-implementation-of-google-secret-manager-in-cloud-functions-93a1732dd175" rel="noopener follow" target="_blank"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">Google Secret Manager在云函数中的原生实现</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">你应该使用全新的实现吗？比较了3种方法:可用性、安全性、性能…</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">beranger.medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ku nh"/></div></div></a></div></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="df4a" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">再见</h1><p id="d17a" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我希望这篇文章能让您的云功能开发更上一层楼。</p><p id="0885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前一部分:</p><p id="ebb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&lt;&lt;&lt; <a class="ae je" href="https://beranger.medium.com/cloud-functions-best-practices-1-4-get-the-environment-ready-af666af89f62" rel="noopener">云功能最佳实践(1/4):准备好环境</a></p><p id="1dc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一部分:</p><p id="53c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://beranger.medium.com/cloud-functions-best-practice-3-4-secure-the-cloud-functions-1c9642c4706" rel="noopener">云功能最佳实践(3/4):保护云功能</a> &gt; &gt; &gt;</p><p id="43b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://beranger.medium.com/cloud-functions-best-practice-4-4-monitor-and-log-the-executions-22222aa25f1b" rel="noopener">云功能最佳实践(4/4):监控和记录执行</a> &gt; &gt; &gt;</p><p id="7e1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你的15次鼓掌！</p></div></div>    
</body>
</html>