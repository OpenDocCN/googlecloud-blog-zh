<html>
<head>
<title>Time series analytics with BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BigQuery进行时间序列分析</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/time-series-analytics-with-bigquery-f65867c1ce74?source=collection_archive---------0-----------------------#2020-11-13">https://medium.com/google-cloud/time-series-analytics-with-bigquery-f65867c1ce74?source=collection_archive---------0-----------------------#2020-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a44b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">翻转、填充和线性插值技术</h2></div><p id="68cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(2020年12月1日更新:本文中的用户定义函数已被添加到<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-utils/tree/master/udfs/community" rel="noopener ugc nofollow" target="_blank"> BigQuery社区UDF</a>中，并略有改动。例如，可以用<code class="du ju jv jw jx b">bqutil.fn.ts_tumble()</code>调用<a class="ae jt" href="https://github.com/GoogleCloudPlatform/bigquery-utils/tree/master/udfs/community#ts_tumbleinput_ts-timestamp-tumble_seconds-int64" rel="noopener ugc nofollow" target="_blank">翻转功能</a></p><p id="14e9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着BigQuery越来越多地被用作web事件和物联网等实时分析数据的存储；许多用户要求使用<a class="ae jt" href="https://en.wikipedia.org/wiki/Time_series" rel="noopener ugc nofollow" target="_blank">时间序列</a>函数，类似于在像<a class="ae jt" href="http://opentsdb.net/docs/build/html/user_guide/query/index.html" rel="noopener ugc nofollow" target="_blank"> OpenTSDB </a>这样的专用产品中发现的那些函数。虽然BigQuery目前没有专门的时间序列函数，但是有一些简单的函数和技术可以用来直接在BigQuery中执行时间序列分析。</p><p id="f596" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于演示目的，本指南中的示例使用公共的<a class="ae jt" href="https://pantheon.corp.google.com/marketplace/product/san-francisco-public-data/sf-311?project=billing-test-271515" rel="noopener ugc nofollow" target="_blank">旧金山311 </a>数据集，分别使用created_date和supervisor_district作为时间戳和序列键来执行时间序列分析。这些例子可以应用于常见的时间序列问题，如日志分析或物联网监控。</p><p id="6c6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jy">本指南要求您创建新的UDF，并假设您将在名为“timeseries”的数据集中创建它们。</em></p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><h2 id="779d" class="kg kh hi bd ki kj kk kl km kn ko kp kq jg kr ks kt jk ku kv kw jo kx ky kz la bi translated">通过翻转功能创建和分组</h2><p id="b333" class="pw-post-body-paragraph ix iy hi iz b ja lb ij jc jd lc im jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">有时称为时段或时间片，一个<a class="ae jt" href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/operators/windows.html#tumbling-windows" rel="noopener ugc nofollow" target="_blank">翻转</a>代表数据可能落入的非重叠时间窗口。这不同于<code class="du ju jv jw jx b">timestamp_trunc()</code>函数，因为它可以在任意秒数的窗口上聚合。</p><p id="98b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数相当简单，它按翻转大小向下舍入，允许值对齐并聚合到同一个时间组中。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="1606" class="kg kh hi jx b fi lo lp l lq lr">CREATE OR REPLACE FUNCTION timeseries.tumble_interval(<br/> val TIMESTAMP, tumble_seconds INT64)<br/>AS (<br/> timestamp_seconds(div(UNIX_SECONDS(val), tumble_seconds) *  tumble_seconds))<br/>);</span></pre><p id="614a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试该功能时，显示了向下舍入到15分钟(900秒)间隔的翻转列。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="73a3" class="kg kh hi jx b fi lo lp l lq lr">SELECT<br/> unique_key,<br/> supervisor_district,<br/> created_date,<br/> timeseries.tumble_interval(created_date, 900) tumble<br/>FROM `bigquery-public-data.san_francisco.311_service_requests`<br/>WHERE supervisor_district in (6, 11)<br/>ORDER BY supervisor_district, tumble desc</span></pre><figure class="lg lh li lj fd lt er es paragraph-image"><div class="er es ls"><img src="../Images/53835f6b8cdb336dddc14a91f38a0b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*L1954EoaJT8OXWrS"/></div></figure><p id="a943" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">向下舍入的滚动窗口可用于聚集该时间段的数据，例如，在该时间窗口期间发生的事件的计数。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="521e" class="kg kh hi jx b fi lo lp l lq lr">SELECT<br/> supervisor_district,<br/> timeseries.tumble_interval(created_date, 900) tumble,<br/> count(*) as count<br/>FROM `bigquery-public-data.san_francisco.311_service_requests`<br/>WHERE supervisor_district in (6, 11)<br/>GROUP BY supervisor_district, tumble<br/>order by tumble desc</span></pre><figure class="lg lh li lj fd lt er es paragraph-image"><div class="er es lw"><img src="../Images/5fc533b76ff8f6497301eee2142d514b.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/0*WPMfMaL4x6_zAds-"/></div></figure><p id="4216" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">处理缺失值</strong></p><p id="5ec6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看查询结果，有问题。没有任何事件的时间范围显示为完全缺失的记录。这在物联网场景中尤其成问题，在这种场景中，在两个或更多传感器值之间计算重要指标。</p><p id="47f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">处理缺失值最常用的技术是:用默认值填充时间窗口，如“0”，最接近的前一个有效值，或使用<a class="ae jt" href="https://en.wikipedia.org/wiki/Linear_interpolation" rel="noopener ugc nofollow" target="_blank">线性插值</a>绘制估计值。</p><p id="acd4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">生成候选时间戳</strong></p><p id="88eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了在BigQuery中创建合成行，我们将依赖于<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays#flattening_arrays" rel="noopener ugc nofollow" target="_blank"> UNNEST </a>操作，该操作将值数组转换为行，以及<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions#generate_timestamp_array" rel="noopener ugc nofollow" target="_blank"> generate timestamp array </a>函数来创建候选值数组以填充空白。然后，可以将合成行留在原始时间序列聚合的外部，以填充空白。</p><p id="e616" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了简化任务，我们将创建<code class="du ju jv jw jx b">gen_ts_candidates(..)</code>函数，该函数返回包含时间戳和系列键的结构值数组。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="a4d8" class="kg kh hi jx b fi lo lp l lq lr">CREATE OR REPLACE FUNCTION<br/>timeseries.gen_ts_candidates(keys ARRAY&lt;STRING&gt;, tumble_seconds INT64, min_ts TIMESTAMP, max_ts Timestamp)<br/>AS ((<br/> SELECT ARRAY_AGG(x)<br/> FROM (<br/>   SELECT series_key, tumble_val<br/>   FROM UNNEST(<br/>     GENERATE_TIMESTAMP_ARRAY(<br/>       timeseries.tumble_interval(min_ts, tumble_seconds),<br/>       timeseries.tumble_interval(max_ts, tumble_seconds),<br/>       INTERVAL tumble_seconds SECOND<br/>     )<br/>   ) AS tumble_val<br/>   CROSS JOIN UNNEST(keys) AS series_key<br/> ) x<br/>));</span></pre><p id="2525" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">用连接填充记录间隙</strong></p><p id="d9fb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面显示的复杂SQL展示了一种填充值的技术。</p><ol class=""><li id="0ae8" class="lx ly hi iz b ja jb jd je jg lz jk ma jo mb js mc md me mf bi translated">命名子查询<code class="du ju jv jw jx b">requests</code>表示原始的聚合时间窗口查询。</li><li id="c470" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mc md me mf bi translated">命名子查询<code class="du ju jv jw jx b">args</code>为<code class="du ju jv jw jx b">gen_ts_candidates</code>函数创建参数。或者，您可以直接在查询中输入您的参数。</li><li id="03d8" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js mc md me mf bi translated">然后，生成的候选时间序列被<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#left_outer_join" rel="noopener ugc nofollow" target="_blank">左外连接</a>到原始表，以填充缺失的行。</li></ol><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="9ad4" class="kg kh hi jx b fi lo lp l lq lr">WITH requests as (<br/> SELECT<br/>   cast(supervisor_district as STRING) supervisor_district,<br/>   timeseries.tumble_interval(created_date, 900) as tumble,<br/>   count(*) as count<br/> FROM `bigquery-public-data.san_francisco.311_service_requests` a<br/> WHERE supervisor_district in (6, 11)<br/> AND CAST(created_date as DATE) = '2018-01-18'<br/> GROUP BY supervisor_district, tumble<br/>),<br/>args AS (<br/> SELECT<br/>   array_agg(DISTINCT supervisor_district) as key,<br/>   min(tumble) as min_ts,<br/>   max(tumble) as max_ts<br/> FROM requests<br/>)<br/>SELECT *<br/>FROM UNNEST(<br/>  (SELECT<br/>     timeseries.gen_ts_candidates(key, 900, min_ts, max_ts)<br/>   FROM args)<br/>) a<br/>LEFT OUTER JOIN requests b<br/> ON a.series_key = b.supervisor_district<br/> AND a.tumble_val = b.tumble<br/>ORDER BY tumble_val DESC</span></pre><figure class="lg lh li lj fd lt er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es ml"><img src="../Images/1cd9cf1d023b29376b9408f75e2ebfad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*brisT39QjEb33xMj"/></div></div></figure><h2 id="56d7" class="kg kh hi bd ki kj kk kl km kn ko kp kq jg kr ks kt jk ku kv kw jo kx ky kz la bi translated">用最后一个值或默认值填充</h2><p id="412e" class="pw-post-body-paragraph ix iy hi iz b ja lb ij jc jd lc im jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">一旦每个时间窗口都有记录，就可以使用LAST_VALUE窗口函数或默认值来填充这些新记录的缺失值。LAST_VALUE函数将获取<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/analytic-function-concepts#def_window_spec" rel="noopener ugc nofollow" target="_blank">窗口规范</a>的最后一个非空值，包括行的当前值；而缺省值将会用一个常数替换当前值，如果它是null的话。</p><p id="9180" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前一个示例的基础上，您现在可以看到这些空窗口填充了有效值。此示例还按系列关键字supervisor district进行排序，以使LAST_VALUE功能更加明显。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="9a3e" class="kg kh hi jx b fi lo lp l lq lr"><strong class="jx hj">...</strong><br/>SELECT <br/> series_key as supervisor_district,<br/> tumble_val as tumble,<br/> <strong class="jx hj">LAST_VALUE(count IGNORE NULLS)<br/>   OVER (PARTITION BY series_key<br/>         ORDER BY tumble_val ASC<br/>         RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)<br/> AS last_value,<br/> coalesce(count, 0) AS def,</strong><br/> count as unfilled<br/>FROM UNNEST(<br/>  (SELECT<br/>     timeseries.gen_ts_candidates(key, 900, min_ts, max_ts)<br/>   FROM args)<br/>) a<br/>LEFT OUTER JOIN requests b<br/> ON a.series_key = b.supervisor_district<br/> AND a.tumble_val = b.tumble<br/>ORDER BY supervisor_district, tumble_val DESC</span></pre><figure class="lg lh li lj fd lt er es paragraph-image"><div class="er es mq"><img src="../Images/6ef1e24ba08710480b9207b1faa84b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*v6UZOh0QmLnROsuu"/></div></figure><p id="c1d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">有效值之间的线性插值</strong></p><p id="50c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://en.wikipedia.org/wiki/Linear_interpolation" rel="noopener ugc nofollow" target="_blank">线性插值</a>是一个简单的概念，它的数学原理很容易理解。该函数求出前一个值和后一个值之间的斜率，您使用一个直线方程(y=mx + b)来确定当前位置的值。诀窍在于提供所用值的相对坐标。BigQuery <a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#struct_type" rel="noopener ugc nofollow" target="_blank"> struct </a>可以用作包含(x，y)坐标的复杂类型；时间戳秒数可用于x轴上的相对位置。</p><p id="39f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建<code class="du ju jv jw jx b">linear_interpolation</code>函数和一个便利函数<code class="du ju jv jw jx b">interpolate_ts_val_or_fill()</code>来翻译时间戳和处理错误情况。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="40fd" class="kg kh hi jx b fi lo lp l lq lr">CREATE OR REPLACE function<br/>timeseries.linear_interpolate(pos INT64,<br/>        prev STRUCT&lt;x INT64,y FLOAT64&gt;,<br/>        next STRUCT&lt;x INT64,y FLOAT64&gt;)<br/>AS (<br/>CASE<br/>  WHEN prev IS NULL OR next IS NULL THEN null<br/>  ELSE<br/>  <em class="jy">--y = m * x + b</em><br/>  (next.y - prev.y)/(next.x - prev.x) * (pos - prev.x) + prev.y<br/>END<br/>);</span><span id="b31a" class="kg kh hi jx b fi mr lp l lq lr">CREATE OR REPLACE FUNCTION<br/>timeseries.interpolate_ts_val_or_fill(value FLOAT64,<br/>        pos TIMESTAMP,<br/>        prev STRUCT&lt;x TIMESTAMP, y FLOAT64&gt;,<br/>        next STRUCT&lt;x TIMESTAMP, y FLOAT64&gt;,<br/>        def FLOAT64)<br/>AS (<br/> CASE<br/>   WHEN value IS NOT NULL THEN value<br/>   WHEN prev IS NULL OR next IS NULL THEN def<br/>   ELSE<br/>     timeseries.linear_interpolate(<br/>       unix_seconds(pos),<br/>       STRUCT(unix_seconds(prev.x) AS x, prev.y AS y),<br/>       STRUCT(unix_seconds(next.x) AS x, next.y AS y)<br/>     )<br/> END<br/>);</span></pre><p id="f04a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对坐标使用结构非常重要，因为它们允许以可被LAST_VALUE和FIRST_VALUE窗口函数选取的方式打包多个值。</p><p id="676f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重写用于插值时间序列间隙的完整SQL显著的变化用<strong class="iz hj">粗体</strong>标出。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="2a1c" class="kg kh hi jx b fi lo lp l lq lr">WITH requests as (<br/> <strong class="jx hj">SELECT *,<br/>   IF(count is null, null,<br/>     STRUCT(tumble as x, count as y)<br/>   ) AS coord<br/> FROM (</strong><br/>   SELECT<br/>     cast(supervisor_district as STRING) supervisor_district,<br/>     timeseries.tumble_interval(created_date, 900) as tumble,<br/>     count(*) as count<br/>   FROM `bigquery-public-data.san_francisco.311_service_requests` a<br/>   WHERE supervisor_district in (6, 11)<br/>   AND CAST(created_date as DATE) = '2018-01-18'<br/>   AND created_date &lt; '2018-01-18 08:30:00'<br/>   GROUP BY supervisor_district, tumble<br/> <strong class="jx hj">)</strong><br/>),<br/>args AS (<br/> SELECT<br/>   array_agg(DISTINCT supervisor_district) as key,<br/>   min(tumble) as min_ts,<br/>   max(tumble) as max_ts<br/> FROM requests<br/>)<br/>SELECT <br/>   series_key as supervisor_district,<br/>   tumble_val as tumble,<br/>   <strong class="jx hj">timeseries.interpolate_ts_val_or_fill(<br/>     count,<br/>     tumble_val,<br/>     LAST_VALUE(coord IGNORE NULLS)<br/>         OVER (PARTITION BY series_key<br/>           ORDER BY unix_seconds(tumble_val) ASC<br/>           RANGE BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING),<br/>     FIRST_VALUE(coord IGNORE NULLS)<br/>         OVER (PARTITION BY series_key<br/>           ORDER BY unix_seconds(tumble_val) ASC<br/>           RANGE BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING),<br/>     0<br/> ) as intrp,</strong><br/> count as unfilled<br/>FROM UNNEST(<br/>  (SELECT<br/>     timeseries.gen_ts_candidates(key, 900, min_ts, max_ts)<br/>   FROM args)<br/>) a<br/>LEFT OUTER JOIN requests b<br/> ON a.series_key = b.supervisor_district<br/> AND a.tumble_val = b.tumble<br/>ORDER BY supervisor_district, tumble_val DESC</span></pre><figure class="lg lh li lj fd lt er es paragraph-image"><div class="er es ms"><img src="../Images/045ea4a5709ca1d2da6db8f457308e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*gakXgVtEUsdltDo-"/></div><figcaption class="mt mu et er es mv mw bd b be z dx translated">第5行和第9行之间的线性插值清晰可见</figcaption></figure><p id="7a8f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">比较两个系列</strong></p><p id="7d2c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">乍一看，即使有函数，这也是太多的SQL来排列和比较两个系列。视图可以使查询更易于管理。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="c323" class="kg kh hi jx b fi lo lp l lq lr">CREATE OR REPLACE VIEW timeseries.311_req_series<br/>AS (<br/>  WITH requests AS (<br/>    SELECT *,<br/>    IF(count, null, null,<br/>      STRUCT(tumble as x, count as y)<br/>    ) AS coord<br/>...<br/>);</span></pre><p id="2c54" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在可以用一个简单的连接来比较两个系列。</p><pre class="lg lh li lj fd lk jx ll lm aw ln bi"><span id="5ff1" class="kg kh hi jx b fi lo lp l lq lr">SELECT<br/>  ABS(a.intrp - b.intrp) AS difference,<br/>  *<br/>FROM timeseries.311_req_series a<br/>LEFT OUTER JOIN (<br/>  SELECT * FROM timeseries.311_req_series<br/>  WHERE supervisor_district = '6'<br/>) b<br/>ON a.tumble = b.tumble<br/>WHERE a.supervisor_district = '11';</span></pre><figure class="lg lh li lj fd lt er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mx"><img src="../Images/12728ff6e034fcd35363002b8f9bf7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nrkeWCT1HiEH_EgJ"/></div></div><figcaption class="mt mu et er es mv mw bd b be z dx translated">系列6和11的插值之间的差异</figcaption></figure><h1 id="7d1b" class="my kh hi bd ki mz na nb km nc nd ne kq io nf ip kt ir ng is kw iu nh iv kz ni bi translated">额外资源</h1><p id="f872" class="pw-post-body-paragraph ix iy hi iz b ja lb ij jc jd lc im jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">在以后的文章中，我计划探索滑动窗口和替代插值函数。</p><ul class=""><li id="5ae7" class="lx ly hi iz b ja jb jd je jg lz jk ma jo mb js nj md me mf bi translated">BigQuery的标准SQL <a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators" rel="noopener ugc nofollow" target="_blank">引用</a></li><li id="3daf" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js nj md me mf bi translated">数据流SQL中的<a class="ae jt" href="https://cloud.google.com/dataflow/docs/reference/sql/streaming-extensions" rel="noopener ugc nofollow" target="_blank">窗口</a></li><li id="aef1" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js nj md me mf bi translated"><a class="ae jt" href="https://en.wikipedia.org/wiki/Interpolation" rel="noopener ugc nofollow" target="_blank">插补技术</a></li><li id="0c09" class="lx ly hi iz b ja mg jd mh jg mi jk mj jo mk js nj md me mf bi translated"><a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays#flattening_arrays" rel="noopener ugc nofollow" target="_blank">在BigQuery中展平数组</a></li></ul></div></div>    
</body>
</html>