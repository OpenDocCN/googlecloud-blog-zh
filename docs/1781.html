<html>
<head>
<title>Using Cloud Build with a multi-stage Docker build file and a private repo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过多阶段Docker构建文件和私有回购使用云构建</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-cloud-build-with-a-multi-stage-docker-build-file-and-a-private-repo-82d15da3461a?source=collection_archive---------0-----------------------#2021-01-31">https://medium.com/google-cloud/using-cloud-build-with-a-multi-stage-docker-build-file-and-a-private-repo-82d15da3461a?source=collection_archive---------0-----------------------#2021-01-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/ee0d1869aacb595297d455ccb7e14646.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*qA6tV3ap3pBkfQ8nHUjHAw.png"/></div></figure><p id="ecc2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用多阶段Docker文件是使用容器来构建Go应用程序或服务，然后将生成的二进制文件打包到尽可能最小的容器映像中的一种好方法。有很多<a class="ae jk" rel="noopener" href="/@chemidy/create-the-smallest-and-secured-golang-docker-image-based-on-scratch-4752223b7324">伟大的</a> <a class="ae jk" href="https://fabianlee.org/2020/01/26/golang-using-multi-stage-builds-to-create-clean-docker-images/" rel="noopener ugc nofollow" target="_blank">例子</a>，但是这里有一个让我想起过去的概念，<a class="ae jk" rel="noopener" href="/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07">为静态Go二进制文件构建Docker映像|作者Kelsey Hightower </a>。</p><p id="1d35" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">云构建是一个非常棒的托管构建管道流程，具有很大的灵活性…所以让我们将两者结合起来！哦，让我们也加入一个转折，这就是这篇笔记的真正意义:多阶段构建使用了一个位于私有git repo中的模块。</p><p id="1147" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为此，我将几个不同的概念放在一起，以实现以下目标:</p><ul class=""><li id="cc71" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">使用云构建创建Go服务，其中…</li><li id="b754" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">Go服务依赖于私有git repo中的一个模块，通过…</li><li id="6080" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">多级Docker构建文件</li></ul><p id="40fa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">归根结底，我需要一种安全的方式来提供对私钥的多阶段容器构建过程访问。</p><p id="5472" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">云构建的文档… </strong></p><p id="7a81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Cloud Build的文档中有一篇关于如何使用Secret Manager 中存储的密钥访问私有GitHub存储库的<a class="ae jk" href="https://cloud.google.com/cloud-build/docs/access-private-github-repos" rel="noopener ugc nofollow" target="_blank">文章，提供了所有必需的设置和一个有用的简单构建配置示例。</a></p><p id="0925" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">概括一下那篇文章，建立一个密钥对，将公钥应用于特定Github存储库的部署设置(一个密钥用于单个存储库，一个<a class="ae jk" href="https://docs.github.com/en/developers/overview/managing-deploy-keys#deploy-keys" rel="noopener ugc nofollow" target="_blank">部署密钥</a>),然后将私钥上传到Secret Manager。该密钥将在基于临时容器的构建过程的云构建步骤期间被访问，并指出提供云构建服务帐户以访问秘密的适当角色，秘密管理器秘密访问器(<code class="du jz ka kb kc b">roles/secretmanager.secretAccessor</code>)。从Secret Manager检索的密钥不会存储在正在构建的最终映像的任何层中。该文章以一个云构建配置结束，该配置将私有repo的内容克隆到本地构建工作区，在云构建管道中构建代码。很好，但是我们有一个多阶段的docker文件，它将用于构建。</p><p id="0693" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">使用秘密管理器通过SSH with在docker文件中</strong></p><p id="db29" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<a class="ae jk" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank"> Go模块</a>，构建Go应用将首先下载指定的依赖模块。这就是棘手的地方——Go需要知道如何通过SSH在容器中访问私有git repo。</p><p id="6d31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Go通常使用HTTPS来访问git repos，但是要在多级docker文件中使用SSH密钥，必须做一些事情:</p><ul class=""><li id="2e89" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">在主机上有一个密钥可以提供给多级容器</li><li id="28a4" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">通过构建时ARG变量使密钥在容器中可用</li><li id="112d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">将Go配置为对目标git repo使用SSH而不是HTTPS</li></ul><p id="1cec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，通过docker build的——build-ARG参数传入构建时ARG变量(ssh私有密钥)。</p><p id="dc61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一部分很简单，上面有记录:使用Secret Manager获取密钥并写入文件。在这种情况下，主机是构建过程，临时存储该密钥的地方是卷装载。</p><p id="76dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其次，我修改了Dockerfile，引入了特殊的环境变量，作为build-arg传递给<code class="du jz ka kb kc b">docker build</code> <a class="ae jk" href="https://docs.docker.com/engine/reference/builder/#arg" rel="noopener ugc nofollow" target="_blank"> ARG </a>，然后是一些命令，以确保构建容器注册了SSH密钥，并使<a class="ae jk" href="https://golang.org/doc/faq#git_https" rel="noopener ugc nofollow" target="_blank">从HTTPS(默认)全局切换到SSH </a>以访问git repo，在本例中是GitHub。人们可以使用gitlab、bitbucket等其他git repos切换到SSH访问。也是。由于我在这里使用GitHub，所以我没有添加任何其他的回复。</p><p id="30af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">配置Go使用私有存储库的下一步是添加<code class="du jz ka kb kc b"><a class="ae jk" href="https://golang.org/cmd/go/#hdr-Module_configuration_for_non_public_modules" rel="noopener ugc nofollow" target="_blank">GOPRIVATE</a></code> env变量来包含私有存储库的前缀。</p><p id="4842" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是完整的文档:</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="0cf6" class="kl km hi kc b fi kn ko l kp kq"># Start by building the application.<br/>FROM golang:1.15-buster as build</span><span id="f42c" class="kl km hi kc b fi kr ko l kp kq">ARG SSH_PRIVATE_KEY</span><span id="ef31" class="kl km hi kc b fi kr ko l kp kq">WORKDIR /root/src/app<br/>ADD . /root/src/app</span><span id="bc55" class="kl km hi kc b fi kr ko l kp kq"># import the private key<br/># note: intermediary images are deleted and not present in final image layers<br/>RUN mkdir -p ~/.ssh &amp;&amp; umask 0077 &amp;&amp; echo "${SSH_PRIVATE_KEY}" &gt; ~/.ssh/id_rsa \<br/>&amp;&amp; git config --global url."git@github.com:".insteadOf https://github.com/ \<br/>&amp;&amp; ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><span id="1fb7" class="kl km hi kc b fi kr ko l kp kq"># <a class="ae jk" href="https://golang.org/cmd/go/#hdr-Module_configuration_for_non_public_modules" rel="noopener ugc nofollow" target="_blank">https://golang.org/cmd/go/#hdr-Module_configuration_for_non_public_modules</a><br/>ENV GOPRIVATE github.com/ghchinoy/robotreadme</span><span id="30db" class="kl km hi kc b fi kr ko l kp kq">RUN go get -d -v ./...<br/>RUN go build -o /root/bin/app</span><span id="b47b" class="kl km hi kc b fi kr ko l kp kq"># Now copy it into our base image.<br/>FROM gcr.io/distroless/base-debian10<br/>COPY --from=build /root/bin/app /<br/>CMD ["/app"]</span></pre><h1 id="e499" class="ks km hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">一路走来学到的东西</strong></h1><p id="3c55" class="pw-post-body-paragraph im in hi io b ip lp ir is it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj hb bi translated"><strong class="io hj">云建造的逃生舱:码头工人</strong>T2】</p><ul class=""><li id="637b" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">使用一个基本构建器和<a class="ae jk" href="https://cloud.google.com/cloud-build/docs/build-config#entrypoint" rel="noopener ugc nofollow" target="_blank">入口点参数</a>允许在使用参数时有更大的灵活性——您不受限于构建器入口点可以接受的参数。我对此有些纠结，因为默认参数没有正确地进行shell替换(我想在私钥中进行<code class="du jz ka kb kc b">cat</code>)。一旦我这么做了，我有了一个小小的发现，所有的<a class="ae jk" href="https://cloud.google.com/cloud-build/docs/cloud-builders" rel="noopener ugc nofollow" target="_blank">云构建者</a>都可以像其他容器一样被对待。</li><li id="0017" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">容器构建步骤中使用的docker映像不挂载卷。通常，如果您使用默认的cloud builder，您会看到如下示例，即使您要添加卷装载，也不会在args参数中指示如何访问卷。通过入口点，用户可以引用挂载卷，在本例中，ssh密钥就在这里。</li></ul><p id="cdd7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用docker cloud builder的典型构建步骤，这里没有什么特别的</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="97bf" class="kl km hi kc b fi kn ko l kp kq">- name: 'gcr.io/cloud-builders/docker'<br/>  args: ['build', '-t', 'gcr.io/$PROJECT_ID/$_SERVICE/v1, '.']</span></pre><p id="9824" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">取而代之的是两个步骤，第一步是从Secret Manager中检索密钥(其中密钥被命名为<code class="du jz ka kb kc b">my-github-deploy-key</code>)并将其作为卷添加到构建器的工作区，第二步是使用入口点和包含密钥的卷构建映像。</p><pre class="kd ke kf kg fd kh kc ki kj aw kk bi"><span id="998a" class="kl km hi kc b fi kn ko l kp kq"># Access the id_github file from Secret Manager<br/>- name: gcr.io/cloud-builders/gcloud<br/>  entrypoint: 'bash'<br/>  args: [ '-c', 'gcloud secrets versions access latest --secret=my-github-deploy-key &gt; /root/.ssh/id_github' ]<br/>  volumes:<br/>  - name: 'ssh'<br/>    path: /root/.ssh</span><span id="a6e9" class="kl km hi kc b fi kr ko l kp kq"># Build the container image<br/>- name: 'docker'<br/>  entrypoint: 'sh'<br/>  args: [ '-c', 'docker build --build-arg SSH_PRIVATE_KEY="$(cat /root/.ssh/id_github)" -t gcr.io/$PROJECT_ID/$_SERVICE .' ]<br/>  volumes:<br/>  - name: 'ssh'<br/>    path: /root/.ssh</span></pre><p id="49eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">谷歌云秘密管理器和云KMS </strong></p><p id="004b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">管理机密的替代方案是使用<a class="ae jk" href="https://cloud.google.com/kms/docs" rel="noopener ugc nofollow" target="_blank">云KMS </a>。有很多使用云KMS的例子，这让我觉得没有太多人使用云秘密管理器来达到这个目的。本文很好地概括了Secret Manager和云KMS之间的差异:<a class="ae jk" href="https://cloud.google.com/secret-manager/docs/overview" rel="noopener ugc nofollow" target="_blank"> Secret Manager概念概述| Secret Manager文档</a></p><ul class=""><li id="b2d2" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://github.com/GoogleCloudPlatform/cloud-builders/issues/44" rel="noopener ugc nofollow" target="_blank">https://github . com/Google cloud platform/cloud-builders/issues/44</a></li><li id="4f12" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" rel="noopener" href="/@lestrrat/taming-google-container-builder-22a6dded155c">https://medium . com/@ lestr rat/taming-Google-container-builder-22 a6 dded 155 c</a></li></ul><p id="f988" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">云构建的工作空间</strong> —它是云构建管道在步骤之间的共享临时空间，可用于步骤之间的状态。虽然我在最后一个例子中没有使用它，但在我创建它的时候，它确实很有帮助。</p><ul class=""><li id="60aa" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><a class="ae jk" href="https://cloud.google.com/cloud-build/docs/build-config#dir" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/cloud-build/docs/build-config#dir</a></li><li id="9c51" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" href="https://github.com/GoogleCloudPlatform/cloud-builders/issues/372" rel="noopener ugc nofollow" target="_blank">https://github . com/Google cloud platform/cloud-builders/issues/372</a></li><li id="c185" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><a class="ae jk" rel="noopener" href="/google-cloud/how-to-pass-data-between-cloud-build-steps-de5c9ebc4cdd">https://medium . com/Google-cloud/how-to-pass-data-between-cloud-build-steps-de 5c 9 ebc 4c DD</a></li></ul></div></div>    
</body>
</html>