<html>
<head>
<title>Google Cloud Run on Rails: a real life example (Part 4: going live!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Cloud Run on Rails:一个真实的例子(第4部分:上线！)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-run-on-rails-a-real-life-example-part-4-going-live-64c566b73b7b?source=collection_archive---------3-----------------------#2019-05-21">https://medium.com/google-cloud/google-cloud-run-on-rails-a-real-life-example-part-4-going-live-64c566b73b7b?source=collection_archive---------3-----------------------#2019-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1716" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在经历了<a class="ae jd" rel="noopener" href="/@laurent_90293/google-cloud-run-on-rails-a-real-life-example-part-1-preparing-the-ground-705c94ab8a7a">第一部</a>、<a class="ae jd" rel="noopener" href="/@laurent_90293/google-cloud-run-on-rails-a-real-life-example-part-2-running-locally-5734a1a7532f">第二部</a>和<a class="ae jd" rel="noopener" href="/@laurent_90293/google-cloud-run-on-rails-a-real-life-example-part-3-production-environment-and-security-e109063ef745">第三部</a>之后，这里是这个系列的最后一集。这是您的应用程序在互联网中实际运行的地方。😅</p><h1 id="bfcf" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">准备Google云构建</h1><p id="be95" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Cloud Run in life的使命是部署和扩展包装在容器中的HTTP/S驱动的工作负载。因此，让我们为Ruby on Rails应用程序构建一个容器。因为本教程的目标是向您展示如何最好地利用各种GCP服务，所以让我们依靠<a class="ae jd" href="https://cloud.google.com/cloud-build/docs/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Build </a> (GCB)来组装我们的容器。</p><p id="c91f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在启动build命令之前，我们必须授予Cloud Build(或者更准确地说是模拟Cloud Build的服务帐户)对我们之前加密的三条信息的<code class="du kh ki kj kk b">cloudkms.cryptoKeyDecrypter</code>角色(参见<a class="ae jd" rel="noopener" href="/@laurent_90293/google-cloud-run-on-rails-a-real-life-example-part-3-production-environment-and-security-e109063ef745">第3部分</a>)。有了这个角色，Cloud Build能够在构建过程中需要时解密这些秘密(在下面的<code class="du kh ki kj kk b">cloudbuild.yaml</code>文件中有更多相关信息)。</p><p id="b28e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查找由GCP自动创建的云构建服务帐户的名称，请访问<a class="ae jd" href="https://console.cloud.google.com/iam-admin/iam/project" rel="noopener ugc nofollow" target="_blank">谷歌云平台控制台IAM </a>页面，并查找角色为“云构建服务帐户”且符合以下模式的帐户:<code class="du kh ki kj kk b">xxx...xxx@cloudbuild.gserviceaccount.com</code>。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><h1 id="0928" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">运行生成操作</h1><p id="1e3a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与其调动本地机器的处理能力来构建应用程序容器，不如让我们将这项任务委托给<a class="ae jd" href="https://cloud.google.com/cloud-build/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Build </a>。在撰写本文时，前120分钟*每天*是免费的，您只需为Google云存储中容器映像使用的空间付费，这反过来又为您提供了5GB的免费空间。我们的容器映像的大小小于100 MB，这意味着除非您坚持保留您的构建的最后50个版本，否则您不用支付一分钱。如果真的到了那一步，你仍然可以享受300美元的免费积分。</p><p id="931c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们花点时间回顾一下云构建将使用的配置文件。它们都可以在源代码库的根目录下找到。</p><p id="0185" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> cloudbuild.yaml </strong>:这个文件描述了cloudbuild构建容器必须经历的步骤。文件本身由四个步骤组成。实际上是五个，但第一个是隐含的:</p><ol class=""><li id="6e41" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">创建源目录(当前工作目录)的压缩tarball，将其转移到GCS bucket中，并在Cloud Build工作区中解压缩归档文件。</li><li id="f05a" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">请云KMS解密master.key.enc文件，以便它可用于其余的构建过程(以及我们将发布的未来容器)</li><li id="fd8f" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">对服务帐户凭据执行相同的操作</li><li id="345f" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">按照<code class="du kh ki kj kk b">Dockerfile</code>中的说明构建容器，在此之前，确保解密生产数据库密码，并将其作为环境变量(DB_PWD)传递</li><li id="ddf2" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">将新映像推送到容器注册表，以便通过云运行部署到生产环境中</li></ol><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="ad32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Dockerfile </strong>:这个文件由云构建中的“构建映像”步骤调用。阅读下面的评论，找出每个语句的作用。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="d0f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，找到下面的<code class="du kh ki kj kk b">entrypoint.sh</code> <strong class="ih hj"> </strong>脚本，它将在每次云运行启动新的容器实例时运行。这需要说几句话:</p><ol class=""><li id="834f" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">db:create rake任务实际上将在云运行实例的第一次启动时创建数据库，对后续运行没有影响</li><li id="f177" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">在entrypoint脚本中运行db:migrate是一个方便的技巧。但是，它可能偶尔会在日志中生成错误消息，这些错误消息是由同时启动的并发云运行实例引起的。尽管这是无害的。</li><li id="8bf6" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><code class="du kh ki kj kk b">$PORT</code>是由云在运行时提供的，还有许多其他环境变量<a class="ae jd" href="https://cloud.google.com/run/docs/reference/container-contract#env-vars" rel="noopener ugc nofollow" target="_blank"/>。</li></ol><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="0a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是构建容器的时候了:</p><pre class="kl km kn ko fd lg kk lh li aw lj bi"><span id="6093" class="lk jf hi kk b fi ll lm l ln lo">$ gcloud builds submit --config cloudbuild.yaml</span></pre><p id="f205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建步骤的日志应该在您的屏幕上展开。几分钟后，您应该会看到一条成功消息，以及刚刚创建的容器映像的名称。</p><p id="0896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong> : <em class="lp">构建日志也可以在</em> <code class="du kh ki kj kk b"><em class="lp">~/.config/gcloud/logs</em></code> <em class="lp">中找到，也可以从Google Cloud Web控制台的菜单&gt; Cloud Build下找到，以防您需要进一步调查。</em></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/7fa886b23fbb2dd5b713114d46092da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MM9vdJwfkE8-d-I1"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">显示最新版本的云构建Web控制台</figcaption></figure><p id="53a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果构建成功，云构建还会将最新的容器映像推送到相册文件夹下的<a class="ae jd" href="https://cloud.google.com/container-registry/docs/" rel="noopener ugc nofollow" target="_blank">容器注册表</a>中:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mb"><img src="../Images/55a725dde8a6ac73768c08a66b856175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mxUCYXXKzgWCyzZR"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">显示最新构建的容器映像的容器注册表Web控制台</figcaption></figure><h1 id="a44f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">检查漏洞</h1><p id="2410" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">使用像Cloud Run这样的无服务器服务肯定会让您的生产部署变得更加轻松。您基本上可以忘记管理自己的服务器或集群的所有复杂性。但是有一件事您一定不能忘记:那就是确保您构建和部署的容器是安全的，不会受到攻击。</p><p id="0431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，从容器注册表的设置菜单中，您可以激活漏洞扫描API(见下面的截图)。在我撰写本文时，它仍处于测试阶段，但我强烈建议您立即激活该功能，因为它将帮助您在实际部署到生产环境之前发现映像中的任何潜在漏洞。<strong class="ih hj">非常* </strong>有用的服务。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mc"><img src="../Images/1904edb2aa830a0afe5c8310f2bae931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MrhbwSythnN0lCi2"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">在容器注册表中启用自动容器映像漏洞扫描</figcaption></figure><h1 id="81b5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">部署应用程序</h1><p id="594f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果您的构建进展顺利，并且在您的过程中没有发现严重的漏洞，您可以要求Cloud Run部署您刚刚构建的映像:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="a483" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个参数“photo-album”是我们给云运行服务起的名字。它会在第一次部署时自动实例化。</p><ul class=""><li id="0c13" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc md ky kz la bi translated">第二个参数是刚刚构建并在容器注册表中注册的映像的路径。</li><li id="361e" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc md ky kz la bi translated">第三个参数告诉Cloud Run将哪个云SQL用于此服务。如果您进行其他部署，则不需要第三个参数，因为Cloud Run会将它从一个服务版本持续到下一个版本。</li><li id="18d4" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc md ky kz la bi translated">最后一个参数告诉云构建忽略身份验证步骤。这是因为在您创建的项目中，您被授予了角色<code class="du kh ki kj kk b">project.owner</code>。</li></ul><p id="b206" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署大约需要一分钟，最后一条消息会告诉您应用程序的公共URL。从那一刻起，你就在直播！</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es me"><img src="../Images/a712788e12f4fcb48202f88a5a24605a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOmmR_76OrjbovUDz1YJoQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">云运行修订屏幕</figcaption></figure><h1 id="4166" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">监控您的应用</h1><p id="5546" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">一旦您的应用程序部署到生产环境中，就不要再去关注它了。首先要做的是确保Cloud Run捕获Rails日志。Cloud Run监控大量日志消息的<a class="ae jd" href="https://cloud.google.com/run/docs/logging#container-logs" rel="noopener ugc nofollow" target="_blank"> I/O源</a>，其中一个是标准输出。事实证明，从Rails 5开始，将Rails生产日志重定向到STDOUT只是设置RAILS_LOG_TO_STDOUT环境变量的问题。这就是为什么您会在Dockerfile文件中找到以下语句:</p><pre class="kl km kn ko fd lg kk lh li aw lj bi"><span id="c827" class="lk jf hi kk b fi ll lm l ln lo"># Redirect Rails log to STDOUT for Cloud Run to capture<br/>ENV RAILS_LOG_TO_STDOUT=true</span></pre><p id="ee57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">云运行日志可在云运行Web控制台的<code class="du kh ki kj kk b">LOGS</code>选项卡下获得(参见上面的屏幕截图)。</p><p id="45d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了收集系统和应用程序日志消息，Cloud Run还收集许多指标，如请求计数、请求延迟以及容器CPU和内存分配。指标可从同名的选项卡中获得(参见上面的屏幕截图)。</p><p id="0090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用云运行收集Rails日志是第一步。一个更高级的替代方案是使用Google <a class="ae jd" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>不仅收集日志消息，还在出现错误时激活应用程序监控/警报、堆栈跟踪和源代码级调试。但是我们将这个主题留给另一篇文章。😄</p><h1 id="e590" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="ef0d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">恭喜你！您已经完成了本教程的学习。当然，这需要消化大量信息，但是现在您已经有了安全部署Rails应用程序并使它们随意伸缩的坚实基础。在我撰写本文时，Cloud Run仍处于测试阶段，但它已经是一个非常稳定且可扩展的产品。预计未来几周和几个月会有更多功能发布。</p><p id="6475" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然这绝不是一篇全面的文章。您可能希望在Rails应用程序中利用许多其他GCP服务，例如:</p><ul class=""><li id="fe49" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc md ky kz la bi translated">使用云任务触发异步后台处理任务(例如，在后台生成照片的缩略图)</li><li id="9372" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc md ky kz la bi translated">使用云调度程序生成周期性任务</li><li id="cb9b" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc md ky kz la bi translated">将Rails日志消息重定向到Stackdriver，以获得更高级的监控、警报和调试功能</li><li id="0570" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc md ky kz la bi translated">进行性能研究，为您的应用找到最佳的云运行实例<a class="ae jd" href="https://cloud.google.com/run/docs/configuring/memory-limits" rel="noopener ugc nofollow" target="_blank">内存限制</a>与<a class="ae jd" href="https://cloud.google.com/run/docs/configuring/concurrency" rel="noopener ugc nofollow" target="_blank">并发级别</a>的比率。</li></ul><p id="78e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个主题都可以是(将会是？😉)一篇文章本身的主题。因此，请尽情阐述并享受Google Cloud Run上Rails的强大功能。</p><p id="9417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一如既往，欢迎评论。</p></div></div>    
</body>
</html>