<html>
<head>
<title>Using Memorystore with Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过云运行使用Memorystore</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-memorystore-with-cloud-run-82e3d61df016?source=collection_archive---------0-----------------------#2020-07-21">https://medium.com/google-cloud/using-memorystore-with-cloud-run-82e3d61df016?source=collection_archive---------0-----------------------#2020-07-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8f25d84ce6f9030a32bdf8f461d949bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eCD-C_aF_kcTR8KH"/></div></div></figure><p id="76a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Google的Memorystore服务提供了一个完全托管的Redis环境。Cloud Run提供了一个完全托管的容器托管环境，具有自动扩展功能。这为设计由Cloud Run托管的、利用Memorystore服务的解决方案提供了机会。在本文中，我们将研究如何设置它。</p><p id="db72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当我们创建一个Memorystore实例时，它将被赋予一个私有IP地址，该地址将对单个VPC网络可见。此外，Memorystore只允许来自包含在同一区域内的资源的连接。这提供了使用VPC对等从同一地区/VPC的计算引擎对内存存储的即时访问:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/f2df0a055184c32b1bd93f41a2e19a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/0*kXYzakrvgm-auxTG"/></div></figure><p id="618d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从云运行访问Memorystore需要一些额外的步骤。这是因为Cloud Run是一个受管理的无服务器环境，与任何特定的VPC(例如与Memorystore对等的VPC)都没有关联。对此的解决方案是使用无服务器VPC访问。</p><p id="0bf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在与Cloud Run和Memorystore相同的区域创建一个无服务器VPC访问连接器，并与memory store相同的VPC相关联。有了这些，我们就可以指示云运行利用连接器来访问Memorystore。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/3d12f27fb873c501ac56eafde31eeb98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/0*aN3i71_EOVpfcyCr"/></div></figure><p id="0aaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们通过一个例子来说明这个故事。首先，我们创建一个Memorystore实例:</p><pre class="jp jq jr js fd ju jv jw jx aw jy bi"><span id="7d68" class="jz ka hi jv b fi kb kc l kd ke">gcloud redis instances create redis1 --region us-central1</span></pre><p id="b3e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该实例将被称为“redis1 ”,并存在于“us-central1”区域。该命令需要几分钟才能完成。创建实例后，我们需要记下分配给我们的IP地址。</p><pre class="jp jq jr js fd ju jv jw jx aw jy bi"><span id="6225" class="jz ka hi jv b fi kb kc l kd ke">gcloud redis instances describe redis1 --region us-central1</span></pre><p id="fb1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在显示的信息中，我们将找到一个带有标签“host”的条目。记下IP地址，因为这是我们将用来连接Redis实例的地址。现在，我们可以创建VPC访问连接器:</p><pre class="jp jq jr js fd ju jv jw jx aw jy bi"><span id="cae4" class="jz ka hi jv b fi kb kc l kd ke">gcloud compute networks vpc-access connectors \<br/>  create my-vpc-connector \<br/>  --network default \<br/>  --region us-central1 \<br/>  --range 10.8.0.0/28</span></pre><p id="243d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建一个名为“my-vpc-connector”的访问连接器，它与默认的vpc网络和美国中部1地区相关联。连接器的IP地址将取自CIDR范围10.8.0.0/28。</p><p id="c738" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以创建一个利用Redis的云托管应用程序。这里有一个例子:</p><pre class="jp jq jr js fd ju jv jw jx aw jy bi"><span id="7b9a" class="jz ka hi jv b fi kb kc l kd ke"><strong class="jv hj">const</strong> express = require('express');<br/><strong class="jv hj">const</strong> cors = require('cors')<br/><strong class="jv hj">const</strong> redis = require("redis");<br/><br/><strong class="jv hj">const</strong> app = express();<br/><br/><strong class="jv hj">const</strong> client = redis.createClient({<br/>  "host": process.env.REDIS_IP<br/>});<br/>client.on("error", <strong class="jv hj">function</strong>(error) {<br/>  console.error(error);<br/>});<br/><br/>app.use(cors());<br/><br/>app.get('/', (req, res) =&gt; {<br/>  res.set('Cache-Control', 'no-store');<br/>  client.set("key", "value!", redis.print);<br/>  client.get("key", (err, reply) =&gt; {<br/>    res.send(`<br/>    &lt;html&gt;<br/>      &lt;head&gt;<br/>      &lt;/head&gt;<br/>      &lt;body&gt;<br/>        &lt;p&gt;Connecting to Redis at: ${process.env.REDIS_IP}&lt;/p&gt;<br/>        &lt;p&gt;Value of key just read: ${reply}&lt;/p&gt;<br/>      &lt;/body&gt;<br/>    &lt;/html&gt;<br/>    `);<br/>    });<br/>  });<br/><br/><strong class="jv hj">const</strong> port = process.env.PORT || 8080;<br/>app.listen(port, () =&gt; {<br/>  console.log(`Listening on port ${port}`);<br/>});</span></pre><p id="6e08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意使用了一个名为REDIS_IP的环境变量，该变量预计会被提供。这将包含要使用的Memorystore实例的IP地址。</p><p id="9805" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们构建一个容器映像(未显示)。一旦构建了容器映像，我们就可以部署到云运行:</p><pre class="jp jq jr js fd ju jv jw jx aw jy bi"><span id="d2e6" class="jz ka hi jv b fi kb kc l kd ke">gcloud run deploy cloud-run-app \<br/>  --image gcr.io/[PROJECT_ID]/cloud-run-app \<br/>  --max-instances 1 \<br/>  --platform managed \<br/>  --region us-central1 \<br/>  --vpc-connector my-vpc-connector \<br/>  --allow-unauthenticated \<br/>  --set-env-vars "REDIS_IP=[IP_ADDRESS]"</span></pre><p id="e81a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们将名为REDIS_IP的环境变量设置为REDIS实例的IP地址。还要注意，我们提供了之前创建的VPC连接器，以提供云运行和内存存储之间的链接。</p><p id="a74e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个GitHub存储库<a class="ae kf" href="https://github.com/kolban-google/accessing-memorystore-from-cloud-run" rel="noopener ugc nofollow" target="_blank">,其中包含了刚刚显示的完整示例。</a></p><p id="2d0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下视频进一步展示了这些步骤。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="b04f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献</strong>:</p><ul class=""><li id="68fb" class="ki kj hi is b it iu ix iy jb kk jf kl jj km jn kn ko kp kq bi translated"><a class="ae kf" href="https://cloud.google.com/memorystore/docs/redis/networking" rel="noopener ugc nofollow" target="_blank">Redis-Networking的存储库</a></li><li id="d06e" class="ki kj hi is b it kr ix ks jb kt jf ku jj kv jn kn ko kp kq bi translated"><a class="ae kf" href="https://cloud.google.com/vpc/docs/configure-serverless-vpc-access" rel="noopener ugc nofollow" target="_blank">配置无服务器VPC访问</a></li><li id="e609" class="ki kj hi is b it kr ix ks jb kt jf ku jj kv jn kn ko kp kq bi translated"><a class="ae kf" href="https://cloud.google.com/run/docs/configuring/connecting-vpc" rel="noopener ugc nofollow" target="_blank">(云运行)连接到VPC网络</a></li></ul></div></div>    
</body>
</html>