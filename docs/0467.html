<html>
<head>
<title>Firebase: Developing a Web Service with Admin SDK, Flask and Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase:使用Admin SDK、Flask和Google Cloud开发Web服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/firebase-developing-a-web-service-with-admin-sdk-flask-and-google-cloud-6fb97eb38b80?source=collection_archive---------0-----------------------#2017-12-18">https://medium.com/google-cloud/firebase-developing-a-web-service-with-admin-sdk-flask-and-google-cloud-6fb97eb38b80?source=collection_archive---------0-----------------------#2017-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e33ac5c8d0daeb3a6d7a8398f40d05d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yO5s-_ziUqyWKDKqi55XrQ.jpeg"/></div></div></figure><div class=""/><p id="6e63" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://firebase.google.com/docs/admin/setup" rel="noopener ugc nofollow" target="_blank"> Firebase管理SDK</a>支持从可信环境访问<a class="ae jo" href="https://firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase </a>。因此，Admin SDKs可用于与各种公共云和私有云的Firebase进行交互。顺便提一下，Google Compute Engine、Google App Engine和Google Cloud Functions等精选云平台产品是基于管理SDK的服务器端Firebase应用程序的绝佳部署目标。这些云环境在规模、便利性、DevOps自动化和成本方面为开发人员提供了广泛的选择。</p><p id="62a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本帖中，我们将使用<a class="ae jo" href="https://github.com/firebase/firebase-admin-python" rel="noopener ugc nofollow" target="_blank"> Admin Python SDK </a>和<a class="ae jo" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Flask </a>开发一个简单的web服务。像在大多数服务器端开发项目中一样，我们将首先在本地编码和测试应用程序。然后，我们将通过在<a class="ae jo" href="https://cloud.google.com/compute/" rel="noopener ugc nofollow" target="_blank">谷歌计算引擎</a>中部署代码来进行生产演练，谷歌的基础设施即服务(IaaS)云。我们将学习如何从服务器端Python应用程序访问Firebase，以及如何授权部署在<a class="ae jo" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>中的代码发出的Firebase API调用。我们还将探索一些潜在的陷阱，并提出解决方案。</p><h2 id="8415" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">设置开发环境</h2><p id="c9fd" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">首先，我们需要一台Python 2.7或更高版本的工作站。我还建议使用<code class="du kp kq kr ks b"><a class="ae jo" href="https://virtualenv.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank">virtualenv</a></code>将你的项目和它的依赖项与其他所有东西隔离开来。在Unix/Linux shell中执行以下命令，启动一个新的<code class="du kp kq kr ks b">virtualenv</code>沙箱，并安装所需的模块。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="77f7" class="jp jq ht ks b fi lb lc l ld le">$ virtualenv env<br/>$ source env/bin/activate<br/>(env) $ pip install firebase-admin flask</span></pre><p id="ee9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<a class="ae jo" href="https://developers.google.com/identity/protocols/application-default-credentials" rel="noopener ugc nofollow" target="_blank"> Google应用程序默认凭证(ADC) </a>来授权我们的应用程序发出的Firebase API调用。ADC是部署在GCP的应用程序的推荐授权机制。它使我们不必将凭证硬编码到应用程序中，或者将敏感的凭证文件与代码一起发送。然而，为了对使用ADC的应用进行本地测试，我们需要做一些事情。首先，为您的Firebase项目下载<a class="ae jo" href="https://firebase.google.com/docs/admin/setup#add_firebase_to_your_app" rel="noopener ugc nofollow" target="_blank">服务帐户凭证</a>。然后设置<code class="du kp kq kr ks b">GOOGLE_APPLICATION_CREDENTIALS</code>环境变量指向下载的文件。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="0c28" class="jp jq ht ks b fi lb lc l ld le">(env) $ export GOOGLE_APPLICATION_CREDENTIALS=path/to/creds.json</span></pre><p id="a00c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们需要确保系统中安装了<a class="ae jo" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a>。这给了我们<code class="du kp kq kr ks b">gcloud</code>命令行工具。我们稍后将使用它来与Google Compute Engine进行交互。</p><h2 id="54f7" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">编写应用程序</h2><p id="8ce5" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">事不宜迟，让我们继续编码我们的Python web服务。如果您正在跟进，您可以简单地将清单1的内容复制到一个名为<code class="du kp kq kr ks b">superheroes.py</code>的文件中。确保替换第10行的<code class="du kp kq kr ks b">&lt;DB_NAME&gt;</code>占位符，使它指向您的Firebase数据库。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">清单1:基于Admin SDK和Flask的Python web服务</figcaption></figure><p id="225e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在清单1的第9行，我们通过调用<code class="du kp kq kr ks b">initialize_app()</code>来初始化Firebase Admin SDK。这是在函数之外完成的，以确保它只发生一次。请注意，我们没有向<code class="du kp kq kr ks b">initialize_app()</code>传递任何显式凭证。这将提示SDK寻找ADC。然后我们获得一个对名为<code class="du kp kq kr ks b">superheroes</code>的实时数据库节点的引用。我们的web服务管理的所有数据都将存储在这个节点下。接下来，我们有四个函数，它们构成了web服务的公共接口。注意它们是如何使用Flask decorators映射到不同的HTTP方法和URL路径的。最后，我们有一个名为<code class="du kp kq kr ks b">_ensure_hero()</code>的内部助手函数。</p><p id="69ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署时，超级英雄web服务公开了与典型CRUD操作相对应的四个操作:</p><ul class=""><li id="1794" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">创建一个新的超级英雄条目。</li><li id="eefc" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kp kq kr ks b">GET /heroes/&lt;id&gt;</code>:通过ID检索超级英雄条目。</li><li id="9b31" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kp kq kr ks b">PUT /heroes/&lt;id&gt;</code>:按ID更新超级英雄条目。</li><li id="f002" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kp kq kr ks b">DELETE /heroes/&lt;id&gt;</code>:按ID删除超级英雄条目。</li></ul><h2 id="4e0e" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">带它去兜风</h2><p id="f07d" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在我们已经为本地试运行做好了准备。所以让我们点燃那个瓶子吧！</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="3f53" class="jp jq ht ks b fi lb lc l ld le">(env) $ <!-- -->export FLASK_APP=superheroes.py<br/>(env) $ flask run</span></pre><p id="fced" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将启动一个监听端口5000的web服务器。让我们尝试在数据库中创建一个新的超级英雄。清单2显示了我们将使用的JSON有效负载。只需将其复制到一个名为<code class="du kp kq kr ks b">spiderman.json</code>的文件中。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lf lg l"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">清单2:创建条目的示例JSON有效负载</figcaption></figure><p id="0b21" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在运行下面的curl命令将<code class="du kp kq kr ks b">spiderman.json</code>文件发送到我们的web服务。如果一切顺利，它将返回一个包含唯一ID的<code class="du kp kq kr ks b">201 Created</code>响应。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="001b" class="jp jq ht ks b fi lb lc l ld le">$ curl -v -X POST -d @spiderman.json -H "Content-type: application/json" <a class="ae jo" href="http://localhost:5000/heroes" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/heroes</a><br/>&lt; HTTP/1.0 201 CREATED<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 35<br/>&lt; Server: Werkzeug/0.13 Python/2.7.6<br/>&lt; Date: Fri, 15 Dec 2017 22:16:39 GMT<br/>&lt; <br/>{<br/>  "id": "-L0RF2E2upW9jhCjmi6R"<br/>}</span></pre><p id="02c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，您还应该返回Firebase控制台，检查实时数据库的内容。在<code class="du kp kq kr ks b">superheroes/</code>路径下创建一个新条目。您会注意到新条目的密钥与我们的web服务返回的ID相同。您可以将这个ID发送回web服务来检索超级英雄条目。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="46d1" class="jp jq ht ks b fi lb lc l ld le">$ curl -v http://localhost:5000/heroes/-L0RF2E2upW9jhCjmi6R<br/>&lt; HTTP/1.0 200 OK<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 197<br/>&lt; Server: Werkzeug/0.13 Python/2.7.6<br/>&lt; Date: Fri, 15 Dec 2017 22:18:11 GMT<br/>&lt; <br/>{<br/>  "name": "Spider-Man", <br/>  "realName": "Peter Parker", <br/>...</span></pre><p id="7650" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也可以随意尝试上传和删除请求。查看每个操作如何改变Firebase数据库中的内容。如果你发送一个带有无效超级英雄id的请求，服务器会回复一个<code class="du kp kq kr ks b">404 Not Found</code>响应。这个检查是在清单1中的<code class="du kp kq kr ks b">_ensure_hero()</code>助手函数中实现的。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="8c4e" class="jp jq ht ks b fi lb lc l ld le">$ curl -v http://localhost:5000/heroes/invalid_id<br/>&lt; HTTP/1.0 404 NOT FOUND<br/>&lt; Content-Type: text/html<br/>&lt; Content-Length: 233<br/>&lt; Server: Werkzeug/0.13 Python/2.7.6<br/>&lt; Date: Fri, 15 Dec 2017 22:18:16 GMT<br/>&lt; <br/>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;<br/>&lt;title&gt;404 Not Found&lt;/title&gt;<br/>...</span></pre><h2 id="4316" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">部署到Google计算引擎:第1课</h2><p id="3c6e" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">将生产web服务部署到IaaS云时，需要考虑很多因素。要使用多少个虚拟机实例？虚拟机实例的大小是多少？如何处理负载均衡？使用什么样的监控？我们如何根据不同的负载条件进行扩展？这份问题清单真的令人震惊。由于这个原因，在像Google App Engine这样的平台即服务(PaaS)云中部署面向web的应用程序通常更简单、更好。他们为我们处理所有繁重的工作。但是IaaS有它的用途，这个练习的目的是看看我们如何从计算引擎访问Firebase。因此，我们将保持事情绝对简单，只将我们的代码部署到单个VM实例。在以后的文章中，我将讨论如何将这个web服务移植到Google App Engine。</p><p id="67fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最重要的是。我们需要确保<code class="du kp kq kr ks b">gcloud</code>命令行工具被配置为与“正确的”GCP项目交互——特别是当您有多个项目在使用的时候。回想一下，我们的应用程序使用ADC来授权Firebase交互。为此，我们应该在与Firebase数据库相同的GCP项目中启动我们的VM。Firebase项目实际上是一个伪装的GCP项目——这意味着当您创建Firebase项目时，您实际上创建了一个GCP项目。我们需要确保我们的Firebase数据库和计算引擎VM实例驻留在同一个项目中。可以理解的是，项目<code class="du kp kq kr ks b">X</code>中的ADC不能授权访问项目<code class="du kp kq kr ks b">Y</code>中的Firebase数据库——至少在没有额外配置的情况下不能。要为<code class="du kp kq kr ks b">gcloud</code>指定项目，从Firebase控制台找出您的项目ID，并运行以下命令。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="170c" class="jp jq ht ks b fi lb lc l ld le">$ gcloud config set project <em class="lz">my_firebase_project_id</em></span></pre><p id="2b22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们启动一个新的Linux VM实例，并通过SSH连接到它。我将把这个实例称为<code class="du kp kq kr ks b">flask-demo</code>。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="b8bc" class="jp jq ht ks b fi lb lc l ld le">$ <!-- -->gcloud compute instances create flask-demo<br/>$ gcloud compute instances start flask-demo<br/>$ gcloud compute instances ssh flask-demo</span></pre><p id="f02d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算引擎实例相当简单。所以你必须做一些工作来安装所有必要的软件。在虚拟机中运行以下命令。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="cdd1" class="jp jq ht ks b fi lb lc l ld le">(vm) $ sudo apt-get install -y python-pip<br/>(vm) $ pip install --user firebase-admin google-auth-oauthlib<br/>(vm) $ sudo pip install flask</span></pre><p id="71f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里需要注意一些事情。我们的应用程序并不真正需要包<code class="du kp kq kr ks b">google-auth-oauthlib</code>。它的安装只是为了克服一个加密模块加载问题。在我写这篇文章的时候，这个问题正在被解决，所以你可能不需要它了。其次，我们全局安装Flask，这样我们就可以从shell中运行<code class="du kp kq kr ks b">flask</code>命令行工具。请注意，我们在这里没有使用<code class="du kp kq kr ks b">virtualenv</code>，但是如果您愿意，可以随意使用。</p><p id="5698" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦VM实例完全设置好，就将web服务实现复制到VM的文件系统中。您可以<code class="du kp kq kr ks b">scp</code>源文件，或者简单地手动复制和粘贴文件内容，因为<code class="du kp kq kr ks b">superheroes.py</code>很小。在现实世界中，您将拥有版本控制系统和其他工具来处理此类任务。最后，点燃那个瓶子！</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="b852" class="jp jq ht ks b fi lb lc l ld le">(vm) $ export FLASK_APP=superheroes.py<br/>(vm) $ flask run</span></pre><p id="b708" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还没有配置虚拟机的防火墙。因此，我们不能通过远程发送请求来测试这一点。但是我们应该能够在虚拟机上运行curl命令。然而，当我们这么做的时候，我们得到了这个。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="1605" class="jp jq ht ks b fi lb lc l ld le">&lt; HTTP/1.0 500 INTERNAL SERVER ERROR<br/>&lt; Content-Type: text/html<br/>&lt; Content-Length: 291<br/>&lt; Server: Werkzeug/0.13 Python/2.7.13<br/>&lt; Date: Fri, 15 Dec 2017 01:47:01 GMT<br/>&lt;<br/>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;<br/>&lt;title&gt;500 Internal Server Error&lt;/title&gt;<br/>...</span></pre><p id="8a39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Flask服务器还记录了如下内容。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="b435" class="jp jq ht ks b fi lb lc l ld le">[2017-12-15 01:47:01,051] ERROR in app: Exception on /heroes/spiderman [GET]<br/>Traceback (most recent call last):<br/>  File "/usr/local/lib/python2.7/dist-packages/flask/app.py", line 1982, in wsgi_app<br/>    response = self.full_dispatch_request()<br/>  File "/usr/local/lib/python2.7/dist-packages/flask/app.py", line 1614, in full_dispatch_request<br/>    rv = self.handle_user_exception(e)<br/>  File "/usr/local/lib/python2.7/dist-packages/flask/app.py", line 1517, in handle_user_exception<br/>    reraise(exc_type, exc_value, tb)<br/>  File "/usr/local/lib/python2.7/dist-packages/flask/app.py", line 1612, in full_dispatch_request<br/>    rv = self.dispatch_request()<br/>  File "/usr/local/lib/python2.7/dist-packages/flask/app.py", line 1598, in dispatch_request<br/>    return self.view_functions[rule.endpoint](**req.view_args)<br/>  File "/home/hkj/flask-demo/demo.py", line 23, in read_hero<br/>    hero = superheroes.child(id).get()<br/>  File "/usr/local/lib/python2.7/dist-packages/firebase_admin/db.py", line 147, in get<br/>    return self._client.body('get', self._add_suffix())<br/>  File "/usr/local/lib/python2.7/dist-packages/firebase_admin/_http_client.py", line 93, in body<br/>    resp = self.request(method, url, **kwargs)<br/>  File "/usr/local/lib/python2.7/dist-packages/firebase_admin/db.py", line 769, in request<br/>    raise ApiCallError(self._extract_error_message(error), error)<br/>ApiCallError: <strong class="ks hu">401 Client Error: Unauthorized for url: https://my-db-name.firebaseio.com/superheroes/</strong><strong class="ks hu">-L0RF2E2upW9jhCjmi6R</strong><strong class="ks hu">.json</strong><br/>Reason: Unauthorized request.<br/>127.0.0.1 - - [15/Dec/2017 01:47:01] "GET /heroes/<!-- -->-L0RF2E2upW9jhCjmi6R<!-- --> HTTP/1.1" 500 -</span></pre><p id="7386" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哎呀！发生了什么事？似乎我们的web服务从Firebase数据库收到了一个<code class="du kp kq kr ks b">401 Unauthorized</code>响应。换句话说，我们的VM实例上的ADC未能授权Firebase数据库调用。但是为什么呢？</p><p id="aad1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了完全理解发生了什么，我们需要对什么是<em class="lz"> OAuth2作用域</em>有一个粗略的概念。</p><h2 id="d76f" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">在虚拟机上设置OAuth2作用域</h2><p id="19e6" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated"><a class="ae jo" href="https://www.oauth.com/oauth2-servers/scope/" rel="noopener ugc nofollow" target="_blank"> Scopes </a>提供了一种方法来限制用户从OAuth2令牌获得的访问级别。通过将令牌的范围缩小到几个服务，服务提供商可以确保令牌的持有者只能访问这些服务。这在像GCP这样有许多服务的环境中非常有用。作用域构成了防止意外或恶意滥用云服务的一层防御。它们还有助于以更细粒度的方式授权客户端。例如，在同一个GCP项目中，一个用户只能访问云存储，另一个用户只能访问云Firestore。这是通过在颁发给两个用户的令牌中包含适当的范围子集来实现的。</p><p id="e135" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">各种GCP服务和访问它们所需的OAuth2范围在这里<a class="ae jo" href="https://developers.google.com/identity/protocols/googlescopes" rel="noopener ugc nofollow" target="_blank">有所记载</a>。要访问Firebase数据库，客户端应用程序必须提供具有以下两个范围的OAuth2令牌:</p><ul class=""><li id="bf80" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><code class="du kp kq kr ks b">https//www.googleapis.com/auth/firebase.database</code></li><li id="670b" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><code class="du kp kq kr ks b">https://www.googleapis.com/auth/userinfo.email</code></li></ul><p id="294a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，计算引擎中的ADC不会将这些范围添加到颁发的令牌中。因此，Firebase database拒绝了我们在云中的web服务发出的请求。这反过来导致了我们所看到的错误。</p><p id="7071" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算引擎中的每个虚拟机实例都有一组固定的关联范围。VM实例上的ADC将只在OAuth2令牌中包括这些范围。因此，我们问题的解决方案是用所需的作用域配置VM实例。我们可以通过运行以下命令来检查它当前的作用域。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="aa92" class="jp jq ht ks b fi lb lc l ld le">$ gcloud compute instances describe flask-demo --format json<br/>...<br/>"serviceAccounts": [<br/>   {<br/>    "email": "your.gserviceaccount.com",<br/>    "scopes": [<br/>     "https://www.googleapis.com/auth/cloud-platform",<br/>     "https://www.googleapis.com/auth/userinfo.email"<br/>     ]<br/>    }<br/>  ],<br/>...</span></pre><p id="3b69" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出中的<code class="du kp kq kr ks b">serviceAccounts</code>部分显示了VM中当前设置的OAuth2范围。我们可以看到一个必需的Firebase范围丢失了。因此，我们需要停止VM实例，添加所需的作用域，然后再次启动它。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="2bae" class="jp jq ht ks b fi lb lc l ld le">$ <!-- -->gcloud compute instances stop flask-demo<br/>$ export SCOPES=https://www.googleapis.com/auth/firebase.database,https://www.googleapis.com/auth/userinfo.email,https://www.googleapis.com/auth/cloud-platform<br/>$ gcloud compute instances set-service-account flask-demo \<br/>    --scopes $SCOPES<br/>$ gcloud compute instances start flask-demo</span></pre><p id="2d97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还可以通过将<code class="du kp kq kr ks b">--scopes</code>标志传递给实例创建命令来创建具有必要范围的VM。这可以帮助我们避免许多额外的步骤。</p><h2 id="9fc3" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">部署到Google计算引擎:第二步</h2><p id="21ff" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在，我们已经准备好在云中进行另一次测试。像往常一样启动Flask应用程序，并尝试发送一些请求。这一次一切都会好的。重新配置的VM中的ADC应该使所需的作用域在OAuth2令牌中可用。</p><p id="ac2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能还对从远程机器向超级英雄web服务发送请求感兴趣。要做到这一点，我们需要做两件事。</p><ul class=""><li id="1f32" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">将Flask web服务绑定到虚拟机的公共网络接口。这可以通过向烧瓶启动命令传递一个标志来实现。</li></ul><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="39e1" class="jp jq ht ks b fi lb lc l ld le">(vm) $ flask run --host=0.0.0.0</span></pre><ul class=""><li id="cbae" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">从虚拟机的防火墙暴露烧瓶HTTP端口(5000)。这是通过本地开发环境中的<code class="du kp kq kr ks b">gcloud</code>工具来完成的。</li></ul><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="91b2" class="jp jq ht ks b fi lb lc l ld le">$ <!-- -->gcloud compute firewall-rules create open-flask-rule --allow tcp:5000 --source-tags=flask-demo --source-ranges=0.0.0.0/0</span></pre><p id="11c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，使用VM实例的公共IP地址，我们可以从任何地方访问云中的超级英雄web服务。</p><h2 id="b438" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">结论</h2><p id="0be2" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们在Google Compute Engine中成功开发并部署了一款服务器端Firebase应用。我们的是一个简单的基于Python和Flask的web服务，但是它可以是任何东西。可能性包括:</p><ul class=""><li id="34c7" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">一个Python Scikit-Learn脚本，定期根据Firebase数据训练模型</li><li id="0480" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">构建在云Firestore之上的Java JAX-RS API</li><li id="53dd" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">用于批量发送FCM通知的Node.js Express服务器应用程序</li><li id="c891" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">一个独立的Go二进制文件，可以增量更新用户的权限</li></ul><p id="6927" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在这个例子中经历的开发和部署过程非常简单。只有两件事需要注意，这两件事都与我们使用ADC有关:</p><ol class=""><li id="1bda" class="ll lm ht is b it iu ix iy jb ln jf lo jj lp jn ma lr ls lt bi translated">在与Firebase数据库相同的GCP项目中启动VM实例。这就是我们最初使用ADC的原因。</li><li id="cd26" class="ll lm ht is b it lu ix lv jb lw jf lx jj ly jn ma lr ls lt bi translated">将所需的Firebase OAuth2作用域分配给VM实例。这是必需的，以便虚拟机上的ADC可以授权我们的代码进行的Firebase交互。</li></ol><p id="a047" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我很快会写一篇关于将这个应用程序部署到Google App Engine的帖子。您将会看到，由于更高的抽象级别，部署过程变得更加简单。同时，你可以在<a class="ae jo" href="https://github.com/hiranya911/firecloud/tree/master/python/flask-on-gce" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到与这个迷你项目相关的所有资源和支持材料。</p><p id="0cd7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这能让您了解使用Firebase Admin SDKs可以构建什么类型的东西，以及如何在Google Cloud中部署这样的应用程序。一如既往，我欢迎评论和问题。我也很想知道你打算用Firebase和Google Cloud构建什么。</p></div></div>    
</body>
</html>