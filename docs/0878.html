<html>
<head>
<title>Building Token Recommender in Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google云平台中构建令牌推荐器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/building-token-recommender-in-google-cloud-platform-1be5a54698eb?source=collection_archive---------0-----------------------#2019-01-14">https://medium.com/google-cloud/building-token-recommender-in-google-cloud-platform-1be5a54698eb?source=collection_archive---------0-----------------------#2019-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="226e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将指导您创建一个使用<a class="ae jd" href="http://tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>、<a class="ae jd" href="https://cloud.google.com/ml-engine/" rel="noopener ugc nofollow" target="_blank">云机器学习引擎</a>、<a class="ae jd" href="https://cloud.google.com/endpoints" rel="noopener ugc nofollow" target="_blank">云端点</a>和<a class="ae jd" href="https://cloud.google.com/appengine" rel="noopener ugc nofollow" target="_blank">应用引擎</a>构建的<a class="ae jd" href="https://en.wikipedia.org/wiki/ERC-20" rel="noopener ugc nofollow" target="_blank"> ERC20 </a>令牌推荐系统。该解决方案基于Google 的<a class="ae jd" href="https://cloud.google.com/solutions/machine-learning/recommendation-system-tensorflow-overview" rel="noopener ugc nofollow" target="_blank">教程文章。用于训练推荐系统的数据取自我们在BigQuery </a>中的<a class="ae jd" href="https://cloud.google.com/blog/products/data-analytics/ethereum-bigquery-how-we-built-dataset" rel="noopener ugc nofollow" target="_blank">公共以太坊数据集。</a></p><p id="dfc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章分为以下几个部分:</p><ol class=""><li id="3e16" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">推荐系统的协同过滤介绍。</li><li id="1bf6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">令牌推荐系统模型的建立和训练。</li><li id="cb1f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">优化云ML引擎中的超参数。</li><li id="9043" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">将推荐系统部署到云端点和应用引擎。</li></ol><h2 id="312b" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">推荐系统的协同过滤介绍</h2><p id="ce5a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>技术是一种生成用户推荐的强大方法。协作过滤仅依靠观察到的用户行为来做出推荐，不需要配置文件数据或内容访问。</p><p id="ad44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该技术基于以下观察:</p><ul class=""><li id="37c6" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">以类似方式与项目交互的用户(例如，购买相同的令牌或查看相同的文章)共享一个或多个隐藏的偏好。</li><li id="d32a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">具有共享偏好的用户很可能以相同的方式对相同的项目做出响应。</li></ul><p id="b9c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协同过滤问题可以使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Matrix_factorization_(recommender_systems)" rel="noopener ugc nofollow" target="_blank">矩阵分解</a>来解决。假设您有一个由用户id及其与产品的交互组成的矩阵。每行对应一个唯一的用户，每列对应一个项目。项目可以是目录中的产品、物品或令牌。矩阵中的每个条目捕获用户对单个项目的评级或偏好。评级可以是明确的，直接由用户反馈生成，或者可以是隐含的，基于用户购买或与商品或代币的交互次数。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/2b18470c1295d8ba34c97310fd8b6d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ_G6a57APZXb7IyuG7Isw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">评级矩阵</figcaption></figure><p id="e53d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">矩阵分解方法假设所有项目都有一组共同的属性，不同的项目在表达这些属性的程度上有所不同。此外，矩阵分解方法假设每个用户对这些属性中的每一个都有自己的表达式，与项目无关。以这种方式，可以通过对用户对于每个属性的强度求和来近似用户的项目评级，其中每个属性由项目表达该属性的程度来加权。这些属性有时被称为隐藏的<strong class="ih hj">或T4潜在的</strong>因素。</p><p id="4734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要将潜在因素的存在转化为评级矩阵，您需要这样做:对于一组大小为<em class="lj"> u </em>的用户<strong class="ih hj"> <em class="lj"> U </em> </strong>和大小为<em class="lj"> i </em>的项目<strong class="ih hj"> <em class="lj"> I </em> </strong>，您挑选任意数量的<strong class="ih hj"> k </strong>潜在因素，并将大矩阵<strong class="ih hj"> <em class="lj"> R </em> </strong>分解为两个小得多的矩阵<strong class="ih hj"> <em class="lj"> X矩阵<strong class="ih hj"> <em class="lj"> X </em> </strong>有尺寸<strong class="ih hj"> u </strong> × <strong class="ih hj"> k </strong>，<strong class="ih hj"> <em class="lj"> Y </em> </strong>有尺寸<strong class="ih hj"> k </strong> × <strong class="ih hj"> i </strong>。</em></strong></p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lk"><img src="../Images/f9e82c6b2a80623dbdd97cc91ba46eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Clxq1r8d23ov4iNyKQUwZw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">用行和列因子近似评定矩阵</figcaption></figure><p id="9028" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要计算用户<em class="lj"> u </em>对项目<em class="lj"> i </em>的评价，您需要取两个向量的点积。损失函数可以定义为实际评级和根据潜在因素计算的评级之间的均方根误差(RMSE)。</p><p id="475d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的令牌推荐器，我们将使用用户持有特定令牌的供应百分比，作为用户评级矩阵中的隐式评级。</p><h2 id="411b" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">令牌推荐系统模型的建立和训练</h2><p id="5bc6" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><strong class="ih hj">检查代码并安装依赖项:</strong></p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="1d17" class="js jt hi lm b fi lq lr l ls lt">wget <a class="ae jd" href="https://repo.continuum.io/miniconda/Miniconda2-latest-MacOSX-x86_64.sh" rel="noopener ugc nofollow" target="_blank">https://repo.continuum.io/miniconda/Miniconda2-latest-MacOSX-x86_64.sh</a></span><span id="115a" class="js jt hi lm b fi lu lr l ls lt">bash Miniconda2-latest-MacOSX-x86_64.sh</span><span id="3209" class="js jt hi lm b fi lu lr l ls lt">git clone --branch medium_article<strong class="lm hj"> </strong><a class="ae jd" href="https://github.com/blockchain-etl/token-recommender" rel="noopener ugc nofollow" target="_blank">https://github.com/blockchain-etl/token-recommender</a><br/>cd token-recommender<br/>conda create -n token_recommender<br/>conda install -n token_recommender --file conda.txt<br/>source activate token_recommender<br/>pip install -r requirements.txt<br/>pip install tensorflow==1.4.1</span></pre><p id="3a70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">从BigQuery查询令牌评级:</strong></p><p id="d3ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在BigQuery中运行以下查询，并将结果导出到GCS存储桶，例如<code class="du lv lw lx lm b">gs://your_bucket/data/token_balances.csv</code></p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="6342" class="js jt hi lm b fi lq lr l ls lt">#standardSQL<br/><strong class="lm hj">with </strong>top_tokens <strong class="lm hj">as </strong>(<br/>  <strong class="lm hj">select </strong>token_address, <strong class="lm hj">count</strong>(1) <strong class="lm hj">as </strong>transfer_count<br/>  <strong class="lm hj">from </strong>`bigquery-public-data.crypto_ethereum.token_transfers` <strong class="lm hj">as </strong>token_transfers<br/>  <strong class="lm hj">group by </strong>token_address<br/>  <strong class="lm hj">order by </strong>transfer_count <strong class="lm hj">desc<br/>  </strong>limit 1000<br/>),<br/>token_balances <strong class="lm hj">as </strong>(<br/>    <strong class="lm hj">with </strong>double_entry_book <strong class="lm hj">as </strong>(<br/>        <strong class="lm hj">select </strong>token_address, to_address <strong class="lm hj">as </strong>address, <strong class="lm hj">cast</strong>(<strong class="lm hj">value as </strong>float64) <strong class="lm hj">as value</strong>, block_timestamp<br/>        <strong class="lm hj">from </strong>`bigquery-public-data.crypto_ethereum.token_transfers`<br/>        <strong class="lm hj">union all<br/>        select </strong>token_address, from_address <strong class="lm hj">as </strong>address, -<strong class="lm hj">cast</strong>(<strong class="lm hj">value as </strong>float64) <strong class="lm hj">as value</strong>, block_timestamp<br/>        <strong class="lm hj">from </strong>`bigquery-public-data.crypto_ethereum.token_transfers`<br/>    )<br/>    <strong class="lm hj">select </strong>double_entry_book.token_address, address, <strong class="lm hj">sum</strong>(<strong class="lm hj">value</strong>) <strong class="lm hj">as </strong>balance<br/>    <strong class="lm hj">from </strong>double_entry_book<br/>    <strong class="lm hj">join </strong>top_tokens <strong class="lm hj">on </strong>top_tokens.token_address = double_entry_book.token_address<br/>    <strong class="lm hj">where </strong>address != <strong class="lm hj">'0x0000000000000000000000000000000000000000'<br/>    group by </strong>token_address, address<br/>    <strong class="lm hj">having </strong>balance &gt; 0<br/>),<br/>token_supplies <strong class="lm hj">as </strong>(<br/>    <strong class="lm hj">select </strong>token_address, <strong class="lm hj">sum</strong>(balance) <strong class="lm hj">as </strong>supply<br/>    <strong class="lm hj">from </strong>token_balances<br/>    <strong class="lm hj">group by </strong>token_address<br/>)<br/><strong class="lm hj">select <br/>    </strong>token_balances.token_address, <br/>    token_balances.address <strong class="lm hj">as </strong>user_address, <br/>    balance/supply * 100 <strong class="lm hj">as </strong>rating<br/><strong class="lm hj">from </strong>token_balances<br/><strong class="lm hj">join </strong>token_supplies <strong class="lm hj">on </strong>token_supplies.token_address = token_balances.token_address<br/><strong class="lm hj">where </strong>balance/supply * 100 &gt; 0.001</span></pre><p id="340f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的SQL通过传输计数查询前1000个令牌，计算每个令牌的余额，并输出<code class="du lv lw lx lm b">(token_address, user_address, rating)</code>三元组。那里的等级计算为用户持有的供应的百分比。这个过滤器——<code class="du lv lw lx lm b"><strong class="ih hj">where </strong>balance/supply * 100 &gt; 0.001</code>——防止空投出现在结果中。</p><p id="8476" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">了解代码结构</strong></p><p id="10c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">型号代码包含在<code class="du lv lw lx lm b">wals_ml_engine</code>目录中。代码的高级功能由以下文件实现:</p><ol class=""><li id="4b1f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du lv lw lx lm b">mltrain.sh</code> —启动各种类型的云机器学习引擎作业。</li><li id="807e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lv lw lx lm b">task.py</code> —解析云机器学习引擎作业的参数并执行训练。</li><li id="c5e9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lv lw lx lm b">model.py</code> —加载数据集；从数据中创建两个稀疏矩阵，一个用于训练，一个用于测试；对评定的培训稀疏矩阵执行WALS。</li><li id="6202" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><code class="du lv lw lx lm b">wals.py</code>——创造了WALS模式；执行WALS算法；计算一组行/列因子和评级矩阵的均方根误差(<a class="ae jd" href="https://wikipedia.org/wiki/Root-mean-square_deviation" rel="noopener ugc nofollow" target="_blank"> RMSE </a>)。</li></ol><p id="eb1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">csv文件加载到<code class="du lv lw lx lm b">model.py</code>文件中:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="a479" class="js jt hi lm b fi lq lr l ls lt">headers = [<strong class="lm hj">'token_address'</strong>, <strong class="lm hj">'user_address'</strong>, <strong class="lm hj">'rating'</strong>]<br/>balances_df = pd.read_csv(input_file,<br/>                         sep=<strong class="lm hj">','</strong>,<br/>                         names=headers,<br/>                         header=0,<br/>                         dtype={<br/>                             <strong class="lm hj">'token_address'</strong>: np.str,<br/>                             <strong class="lm hj">'user_address'</strong>: np.str,<br/>                             <strong class="lm hj">'rating'</strong>: np.float32,<br/>                         })</span></pre><p id="37da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后创建以下数组:</p><ul class=""><li id="0996" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated">用户地址的数组，</li><li id="76d1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">令牌地址的数组，</li><li id="61b1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated">一个三元组数组，包含从0开始的用户和令牌索引以及相应的评级。</li></ul><p id="1888" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，这些三元组被随机分为测试和训练数据集，并转换为稀疏矩阵:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="cd3f" class="js jt hi lm b fi lq lr l ls lt">test_set_size = len(ratings) / TEST_SET_RATIO<br/>test_set_idx = np.random.choice(xrange(len(ratings)),<br/>                                size=test_set_size, replace=False)<br/>test_set_idx = sorted(test_set_idx)<br/><br/><em class="lj"># sift ratings into train and test sets<br/></em>ts_ratings = ratings[test_set_idx]<br/>tr_ratings = np.delete(ratings, test_set_idx, axis=0)</span><span id="0a61" class="js jt hi lm b fi lu lr l ls lt"><em class="lj"># create training and test matrices as coo_matrix's<br/></em>u_tr, i_tr, r_tr = zip(*tr_ratings)<br/>tr_sparse = <strong class="lm hj">coo_matrix</strong>((r_tr, (u_tr, i_tr)), shape=(n_users, n_items))<br/><br/>u_ts, i_ts, r_ts = zip(*ts_ratings)<br/>test_sparse = <strong class="lm hj">coo_matrix</strong>((r_ts, (u_ts, i_ts)), shape=(n_users, n_items))</span></pre><p id="998f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">WALS模型是在<a class="ae jd" href="https://github.com/blockchain-etl/token-recommender/blob/medium_article/wals_ml_engine/trainer/wals.py" rel="noopener ugc nofollow" target="_blank"> wals.py </a>的<code class="du lv lw lx lm b">wals_model</code>方法中创建的，因式分解是在同一个文件的<code class="du lv lw lx lm b">simple_train</code>方法中完成的。结果是<a class="ae jd" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> numpy </a>格式的行和列因子。</p><p id="8cbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在本地和谷歌ML引擎中训练模型</strong></p><p id="3c96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">若要在本地训练模型，请运行以下命令，指定上一步中导出的CSV文件的路径:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="a27b" class="js jt hi lm b fi lq lr l ls lt">./mltrain.sh local gs://your_bucket/data/token_balances.csv</span></pre><p id="6be3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出应该如下所示:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="671a" class="js jt hi lm b fi lq lr l ls lt">INFO:tensorflow:Train Start: 2019-01-10 23:22:06<br/>INFO:tensorflow:Train Finish: 2019-01-10 23:22:12<br/>INFO:tensorflow:train RMSE = 0.76<br/>INFO:tensorflow:test RMSE = 0.95</span></pre><p id="1861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RMSE对应于预测评级与测试集相比的平均误差。平均而言，该算法产生的每个评级与测试集中的实际用户评级相差不超过0.95个百分点。如下一节所示，WALS算法在使用优化的超参数时表现得更好。</p><p id="8740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在云ML引擎中运行它:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="0815" class="js jt hi lm b fi lq lr l ls lt">./mltrain.sh train gs://your_bucket/data/token_balances.csv</span></pre><p id="ceaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在GCP控制台<strong class="ih hj"> ML引擎</strong>部分的<strong class="ih hj">作业</strong>页面上监控作业的状态和输出。点击<strong class="ih hj">日志</strong>查看作业输出。</p><p id="565d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因子分解后，因子矩阵以<a class="ae jd" href="http://www.numpy.org/" rel="noopener ugc nofollow" target="_blank"> numpy </a>格式保存在四个单独的文件中，因此它们可用于执行建议:</p><ul class=""><li id="8952" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">user.npy </code>—用于将用户索引映射到用户地址的用户地址数组</li><li id="47fa" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">item.npy</code> —用于将令牌索引映射到令牌地址的令牌地址数组</li><li id="87db" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">row.npy</code> —用户潜在因素</li><li id="3dff" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">col.npy</code> —代币潜在因素</li></ul><p id="8017" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本地培训时，可以在<code class="du lv lw lx lm b">wals_ml_engine/jobs </code>目录下找到那些文件。</p><p id="9858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用以下代码来测试这些建议:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="8545" class="js jt hi lm b fi lq lr l ls lt"><strong class="lm hj">import </strong>numpy <strong class="lm hj">as </strong>np<br/><strong class="lm hj">from </strong>model <strong class="lm hj">import </strong>generate_recommendations<br/><br/>user_address = <strong class="lm hj">'0x8c373ed467f3eabefd8633b52f4e1b2df00c9fe8'<br/></strong>already_rated = [<strong class="lm hj">'0x006bea43baa3f7a6f765f14f10a1a1b08334ef45'</strong>,<strong class="lm hj">'0x5102791ca02fc3595398400bfe0e33d7b6c82267'</strong>,<strong class="lm hj">'0x68d57c9a1c35f63e2c83ee8e49a64e9d70528d25'</strong>,<strong class="lm hj">'0xc528c28fec0a90c083328bc45f587ee215760a0f'</strong>]<br/>k = 5<br/><br/>model_dir = <strong class="lm hj">'../jobs/wals_ml_local_20190107_235006'<br/><br/></strong>user_map = np.load(model_dir + <strong class="lm hj">"/model/user.npy"</strong>)<br/>item_map = np.load(model_dir + <strong class="lm hj">"/model/item.npy"</strong>)<br/>row_factor = np.load(model_dir + <strong class="lm hj">"/model/row.npy"</strong>)<br/>col_factor = np.load(model_dir + <strong class="lm hj">"/model/col.npy"</strong>)<br/>user_idx = np.searchsorted(user_map, user_address)<br/>user_rated = [np.searchsorted(item_map, i) <strong class="lm hj">for </strong>i <strong class="lm hj">in </strong>already_rated]<br/><br/>recommendations = generate_recommendations(user_idx, user_rated, row_factor, col_factor, k)<br/><br/>tokens = [item_map[i] <strong class="lm hj">for </strong>i <strong class="lm hj">in </strong>recommendations]<br/><br/><strong class="lm hj">print</strong>(tokens)</span></pre><h2 id="4d74" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">在云ML引擎中调整超参数</h2><p id="329e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">您可以在这里找到超参数调整<a class="ae jd" href="https://github.com/blockchain-etl/token-recommender/blob/master/wals_ml_engine/trainer/config/config_tune.json" rel="noopener ugc nofollow" target="_blank">的配置文件。</a></p><ul class=""><li id="8f8e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">latent_factors</code> —潜在因素的数量(最少5个，最多50个)。</li><li id="e827" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">regularization</code> — L2正则化常数(最小值:0.001，最大值:10.0)。</li><li id="ccca" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">unobs_weight</code> —未观察到的重量(最小值:0.001，最大值:5.0)。</li><li id="3cab" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">feature_wt_exp</code> —特征权重指数(最小值:0.0001，最大值:10)。</li><li id="6cb9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">num_iters</code> —交替最小二乘迭代的次数(最小值:10，最大值:20)</li></ul><p id="8f33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要调整超参数，首先将mltrain.sh中的<code class="du lv lw lx lm b">BUCKET</code>变量更改为您的bucket。然后运行以下命令:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="f186" class="js jt hi lm b fi lq lr l ls lt">./mltrain.sh tune gs://your_bucket/data/token_balances.csv</span></pre><p id="f00b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以在Cloud ML引擎控制台中看到调优的进度。超参数调整的结果存储在云ML引擎作业数据中，您可以在<strong class="ih hj">作业</strong>页面中访问该数据。工作结果包括所有汇总指标测试的最佳RMSE分数。</p><p id="32b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我调优的最佳参数，你也可以在<a class="ae jd" href="https://github.com/blockchain-etl/token-recommender/blob/medium_article/wals_ml_engine/trainer/model.py" rel="noopener ugc nofollow" target="_blank">库</a>中找到:</p><ul class=""><li id="fbdc" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">latent_factors</code> — 22</li><li id="d1e8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">regularization</code> — 0.12</li><li id="4bb4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">unobs_weight</code> — 0.001</li><li id="07d9" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">feature_wt_exp</code> —9.43</li><li id="c4cb" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc ks jk jl jm bi translated"><code class="du lv lw lx lm b">num_iters</code> — 20</li></ul><p id="66de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，与默认参数相比，误差稍微小一些:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="43e2" class="js jt hi lm b fi lq lr l ls lt">INFO:tensorflow:train RMSE = 0.97<br/>INFO:tensorflow:test RMSE = 0.87</span></pre><h2 id="3b08" class="js jt hi bd ju jv jw jx jy jz ka kb kc iq kd ke kf iu kg kh ki iy kj kk kl km bi translated">将推荐系统部署到Google App Engine</h2><p id="c507" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">您可以在存储库中找到Swagger格式的REST API定义，用于提供令牌建议:<a class="ae jd" href="https://github.com/blockchain-etl/token-recommender/blob/medium_article/app/openapi.yaml" rel="noopener ugc nofollow" target="_blank"> openapi.yaml </a>。App Engine的API实现在<a class="ae jd" href="https://github.com/blockchain-etl/token-recommender/blob/medium_article/app/main.py" rel="noopener ugc nofollow" target="_blank"> main.py </a>文件中。</p><p id="0229" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，准备部署API端点服务:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="ae03" class="js jt hi lm b fi lq lr l ls lt">cd scripts<br/>./prepare_deploy_api.sh</span></pre><p id="f916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令的输出应该如下所示:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="6684" class="js jt hi lm b fi lq lr l ls lt">To deploy:  gcloud endpoints services deploy /var/folders/t0/y38g0z2s6jqcnwp8452j026h0000gp/T/tmp.fIelYqSh8B.yaml</span></pre><p id="5d04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行提供的命令:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="a6cf" class="js jt hi lm b fi lq lr l ls lt">gcloud endpoints services deploy /var/folders/t0/y38g0z2s6jqcnwp8452j026h0000gp/T/tmp.fIelYqSh8B.yaml</span></pre><p id="3046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建应用程序将从中读取模型的存储桶:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="ade5" class="js jt hi lm b fi lq lr l ls lt">export BUCKET=gs://recserve_$(gcloud config get-value project 2&gt; /dev/null)<br/>gsutil mb ${BUCKET}</span></pre><p id="dd55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将<code class="du lv lw lx lm b">token_balances.csv</code>文件上传到bucket:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="e48f" class="js jt hi lm b fi lq lr l ls lt">gsutil cp ../data/token_balances.csv ${BUCKET}/data/</span></pre><p id="a58d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练模型并将模型文件上传到存储桶:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="f5dc" class="js jt hi lm b fi lq lr l ls lt">./mltrain.sh local ${BUCKET}/data/token_balances.csv \<br/>    --use-optimized --output-dir ${BUCKET}</span></pre><p id="cebc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建应用程序引擎应用程序:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="d481" class="js jt hi lm b fi lq lr l ls lt">gcloud app create --region=us-central1<br/>gcloud app update --no-split-health-checks</span></pre><p id="1815" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备部署App Engine应用程序:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="7590" class="js jt hi lm b fi lq lr l ls lt">./prepare_deploy_app.sh</span></pre><p id="261a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将出现以下输出:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="1c64" class="js jt hi lm b fi lq lr l ls lt">To deploy:  gcloud -q app deploy ../app/app_template.yaml_deploy.yaml</span></pre><p id="15d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行提供的命令:</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="5cfa" class="js jt hi lm b fi lq lr l ls lt">gcloud -q app deploy ../app/app_template.yaml_deploy.yaml</span></pre><p id="a8c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序部署后，您将能够查询API:<a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/${project_id}.appspot.com/recommendation?user_address=0x8c373ed467f3eabefd8633b52f4e1b2df00c9fe8&amp;num_recs=5">https://$ { project _ id } . appspot . com/recommendation？user _ address = 0x8c 373 ed 467 F3 ea befd 8633 b 52 F4 E1 B2 df 00 c 9 Fe 8&amp;num _ RECs = 5</a>(用您的值替换${project_id})</p><pre class="ku kv kw kx fd ll lm ln lo aw lp bi"><span id="4503" class="js jt hi lm b fi lq lr l ls lt">{<br/>    token_addresses: [<br/>        "0x8ae4bf2c33a8e667de34b54938b0ccd03eb8cc06",<br/>        "0x226bb599a12c826476e3a771454697ea52e9e220",<br/>        "0xcbcc0f036ed4788f63fc0fee32873d6a7487b908",<br/>        "0xf7b098298f7c69fc14610bf71d5e02c60792894c",<br/>        "0xc86d054809623432210c107af2e3f619dcfbf652"<br/>    ]<br/>}</span></pre><p id="ff64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在similarcoins.com<a class="ae jd" href="https://www.similarcoins.com/" rel="noopener ugc nofollow" target="_blank">试试这些推荐。阅读我们的文章，其中描述了我们如何评估和改进推荐系统:</a></p><div class="ly lz ez fb ma mb"><a href="https://towardsdatascience.com/machine-learning-on-ethereum-data-recommending-tokens-5a2a1c779849" rel="noopener follow" target="_blank"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">以太坊数据上的机器学习:推荐令牌</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">Evgeny Medvedev和Alex Svanevik在D5报道</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">towardsdatascience.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ld mb"/></div></div></a></div></div></div>    
</body>
</html>