<html>
<head>
<title>Hack: Use Cloud Functions as a webserver with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hack:使用云功能作为Golang的网络服务器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/hack-use-cloud-functions-as-a-webserver-with-golang-42edc7935247?source=collection_archive---------1-----------------------#2021-12-02">https://medium.com/google-cloud/hack-use-cloud-functions-as-a-webserver-with-golang-42edc7935247?source=collection_archive---------1-----------------------#2021-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d960754d5b92034bca4d5b1cf2920a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvgdNj2Nbnccipiv2JkMuQ.png"/></div></div></figure><p id="9a8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无服务器是一个新的范例，它改变了开发习惯。“无服务器管理”模式很棒，但是它的对手是T4。在FaaS <em class="jo">(作为服务的功能)</em>，只有<strong class="is hj">一个功能被暴露</strong>，只有一个单一目的工作负载的入口点。</p><p id="0ad7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是云功能的设计。但是，有时候，<strong class="is hj">你想要(或者需要)做更多的事情</strong>。我已经<a class="ae jp" rel="noopener" href="/google-cloud/use-multiple-paths-in-cloud-functions-python-and-flask-fc6780e560d3">写了一篇关于Python解决方案的文章</a>，但是这需要外部依赖来构建黑客。这一次，<strong class="is hj">使用Golang，可以通过使用本地特性来本地提供多条路径</strong>。</p><p id="33e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始讨论细节吧</p><h1 id="4b8b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">路由传入的请求</h1><p id="707c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">按照设计，<strong class="is hj">云功能是单一用途的</strong>并且只服务于<strong class="is hj">一个入口点</strong>。</p><p id="a97e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步，也是这个黑客的主要目的，是<strong class="is hj">在这个惟一的入口点上获取请求，并根据URL <em class="jo"> (sub) </em>路径将其路由到另一段代码</strong>。<br/>为了实现这一点，我们可以使用<strong class="is hj"> Go native server复用器</strong>并根据路径路由请求。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="c097" class="lc jr hi ky b fi ld le l lf lg">var mux = newMux()<br/><br/>func Webserver(w http.ResponseWriter, r *http.Request) {<br/>   mux.ServeHTTP(w, r)<br/>}<br/><br/>func newMux() *http.ServeMux {<br/>   mux := http.NewServeMux()<br/>   mux.HandleFunc("/static/", serveStatic)<br/>   mux.HandleFunc("/hello", hello)<br/>   mux.HandleFunc("/subroute/login", login)<br/>   return mux<br/>}</span></pre><p id="7156" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有外部依赖性，所有特性都内置在Golang核心库中。</p><h2 id="7063" class="lc jr hi bd js lh li lj jw lk ll lm ka jb ln lo ke jf lp lq ki jj lr ls km lt bi translated">服务动态端点</h2><p id="c744" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">现在，路由器能够将请求路由到<code class="du lu lv lw ky b">HandleFunc</code>，我们可以执行<strong class="is hj">专用代码来动态处理请求</strong>。<br/>这里举2个例子:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="dd7d" class="lc jr hi ky b fi ld le l lf lg">func hello(w http.ResponseWriter, r *http.Request) {<br/>   fmt.Fprint(w,"Hello World!")<br/>}<br/><br/>func login(w http.ResponseWriter, r *http.Request) {<br/>   fmt.Fprint(w,"Login from /subroute/login")<br/>}</span></pre><h2 id="29ee" class="lc jr hi bd js lh li lj jw lk ll lm ka jb ln lo ke jf lp lq ki jj lr ls km lt bi translated">提供静态资源</h2><p id="644f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们也可以<strong class="is hj">服务静态资源</strong>！但这要棘手得多。</p><p id="110b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，<strong class="is hj"> Golang是一种强大的编译语言</strong>:只有<strong class="is hj">需要的文件和依赖项被编译</strong>并添加到一个<strong class="is hj">唯一的二进制</strong>。编译后你没有额外的文件或目录，既不需要<strong class="is hj">系统或环境依赖</strong>，也不需要Golang安装来运行二进制文件。</p><p id="5118" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，因为<strong class="is hj">静态文件不是用Golang代码</strong>编译的，它们<strong class="is hj">也没有嵌入Golang二进制代码</strong>。它们被丢弃。</p><blockquote class="lx"><p id="cf22" class="ly lz hi bd ma mb mc md me mf mg jn dx translated">如何服务静态文件和目录？</p></blockquote><p id="845e" class="pw-post-body-paragraph iq ir hi is b it mh iv iw ix mi iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated">想法是把文件放在Go二进制文件之外的某个地方，并为它们服务。这里的<strong class="is hj">窍门是知道云函数的容器封装是如何</strong>的。</p><p id="f4cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您部署您的云功能时，您<strong class="is hj">提交您的源代码</strong>，它被发送到Cloud Build来构建容器。在容器构建过程中，<strong class="is hj">源文件被添加到容器内的一个目录中，该目录位于专用目录</strong> : <br/> <code class="du lu lv lw ky b">/workspace/src/&lt;Go package name&gt;</code></p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="bc98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Golang中，为了在运行时以编程的方式知道包名，并且为了避免硬编码的值，你可以在一个哑元类型上使用反射</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="9c01" class="lc jr hi ky b fi ld le l lf lg">type Empty struct{}<br/><br/>var functionSourceCodeDir = "/workspace/src/" + reflect.TypeOf(Empty{}).PkgPath()</span></pre><p id="2260" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你有了你的源文件的根路径，你<strong class="is hj">必须服务它们</strong>，就像这样</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="f8b2" class="lc jr hi ky b fi ld le l lf lg">func serveStatic(w http.ResponseWriter, r *http.Request) {<br/>   file := r.URL.Path<br/>   if strings.HasSuffix(file,"/") {<br/>      // Set the default page<br/>      file+="index.html"<br/>   }<br/>   http.ServeFile(w, r, path.Clean(functionSourceCodeDir+file))<br/>}</span></pre><p id="2e45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注意，本</em> <strong class="is hj"> <em class="jo">包装结构可以随时更改，恕不另行通知！</em>T19】</strong></p><h2 id="b4ea" class="lc jr hi bd js lh li lj jw lk ll lm ka jb ln lo ke jf lp lq ki jj lr ls km lt bi translated">基于云功能的网络服务器</h2><p id="e812" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">所有的部件都在这里，你只需要测试它是否像预期的那样工作。你可以在 <a class="ae jp" href="https://github.com/guillaumeblaquiere/cloudfunction-webserver" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">我的GitHub库</strong> </a> <strong class="is hj"> </strong>中找到<strong class="is hj">的源代码，按照那个步骤操作:</strong></p><ul class=""><li id="393e" class="mt mu hi is b it iu ix iy jb mv jf mw jj mx jn my mz na nb bi translated"><strong class="is hj">使用该命令部署您的功能</strong></li></ul><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="dfc0" class="lc jr hi ky b fi ld le l lf lg"># Runtime v1<br/>gcloud beta functions deploy --runtime=v1 \<br/>  --region=us-central1 --allow-unauthenticated \<br/>  --runtime=go113 --trigger-http --entry-point=Webserver webserver</span><span id="e183" class="lc jr hi ky b fi nc le l lf lg"># Runtime v2<br/>gcloud beta functions deploy --runtime=v2 \<br/>  --region=us-central1 --allow-unauthenticated \<br/>  --runtime=go113 --trigger-http --entry-point=Webserver webserver</span></pre><p id="34d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">根据需要更改区域、安全性和功能名称。</em></p><ul class=""><li id="7773" class="mt mu hi is b it iu ix iy jb mv jf mw jj mx jn my mz na nb bi translated"><strong class="is hj">测试这些URL </strong>路径:</li></ul><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3f40" class="lc jr hi ky b fi ld le l lf lg"># Dynamic content<br/>https://us-central1-&lt;ProjectId&gt;.cloudfunctions.net/webserver/hello<br/>https://us-central1-&lt;ProjectId&gt;.cloudfunctions.net/webserver/subroute/login</span><span id="d9c6" class="lc jr hi ky b fi nc le l lf lg"># Static content<br/>https://us-central1-&lt;ProjectId&gt;.cloudfunctions.net/webserver/static/<br/>https://us-central1-&lt;ProjectId&gt;.cloudfunctions.net/webserver/static/index.html<br/>https://us-central1-&lt;ProjectId&gt;.cloudfunctions.net/webserver/static/subdir/login.html</span></pre><p id="60c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">用自己的项目ID </em>替换 <code class="du lu lv lw ky b"><em class="jo">&lt;ProjectId&gt;</em></code> <em class="jo"/></p><blockquote class="lx"><p id="3a04" class="ly lz hi bd ma mb mc md me mf mg jn dx translated">这和预期的一样，但是这是一个好主意吗？</p></blockquote><h1 id="c487" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb nd kd ke kf ne kh ki kj nf kl km kn bi translated">V1运行时:并发问题</h1><p id="e9eb" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">名为v1 的<strong class="is hj">云函数遗留运行时被设计为<strong class="is hj">每次只为每个实例服务一个请求。</strong> <br/>这意味着，如果您有4个并发请求，将会产生4个实例并处理这些请求。</strong></p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/f9173d9dc94deae9b4f87b0f06fd2484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyDIyUEGRHTcLVLxNP7zTg.png"/></div></div></figure><p id="cc0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个设计约束不是中性的，因为:</p><ul class=""><li id="e7fc" class="mt mu hi is b it iu ix iy jb mv jf mw jj mx jn my mz na nb bi translated">您将有<strong class="is hj"> 4次冷启动</strong>，即实例启动和初始化云函数代码的时间</li><li id="981a" class="mt mu hi is b it nh ix ni jb nj jf nk jj nl jn my mz na nb bi translated">您将支付<strong class="is hj"> 4倍的处理成本</strong>，即您将有4个实例，每个请求一个，因此是处理时间&amp;成本的4倍。</li></ul><p id="3b84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“4”不是随机选择的。这是浏览器为下载资源(如静态资源)而创建的标准并发连接数。</p><p id="0f4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一个1000个并发云函数实例的硬限制<strong class="is hj">并行</strong>，您可以很快达到这个限制。</p><p id="f3f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">你可以在</em> <a class="ae jp" rel="noopener" href="/google-cloud/cloud-run-vs-cloud-functions-whats-the-lowest-cost-728d59345a2e"> <em class="jo">我的一篇相当老的文章</em> </a> <em class="jo">中找到更多关于云运行&amp;云函数对比的细节。</em></p><h1 id="6235" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">V2运行时:云运行的力量</h1><p id="a5a8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">云功能<strong class="is hj">下一代运行时，命名为V2，由云运行</strong>提供支持。</p><p id="77c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这一巨大改进，您就可以利用云运行并发特性，默认情况下在同一个实例上处理多达80个并发请求，通过配置可以处理多达1000个请求。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/98b065ce5aca7303eea03ce706ff81f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prrEe9ItaEddxQja699bYw.png"/></div></div></figure><p id="affc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次，当您接收到4个(或更多)并发请求时，<strong class="is hj"> v2运行时能够在同一个实例</strong>上处理它们，因此避免了V1运行时以前的缺点。</p><h1 id="12c4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">一个常见的警告:开发者体验</h1><p id="f25d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">就开发者体验而言，<strong class="is hj">云函数运行时v1或v2都有同样的问题:本地开发体验</strong>。</p><p id="1e44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，你没有任何东西可以在你的工作站上运行，你只有一段代码，一个函数。</p><blockquote class="lx"><p id="17f0" class="ly lz hi bd ma mb mc md me mf mg jn dx translated">那么，如何运行你的函数呢？怎么测试？</p></blockquote><p id="d3a0" class="pw-post-body-paragraph iq ir hi is b it mh iv iw ix mi iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated">当你构建复杂的函数时，进行测试和小的迭代尤其重要。总是等待大约2分钟来在云功能服务上部署你的代码并测试/验证/调试它是没有效率的。<br/><em class="jo"/><a class="ae jp" href="https://cloud.google.com/functions/docs/functions-framework" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="jo">函数框架</em> </strong> </a> <strong class="is hj"> <em class="jo">倾向于根据语言很好地解决</em> </strong> <em class="jo">的问题，但它的</em> <strong class="is hj"> <em class="jo">并不总是理想的</em> </strong> <em class="jo">。</em></p><p id="7e06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要<strong class="is hj">构建一些额外的东西</strong>，一个小的/脏的东西来本地启动你的代码功能，一些能够获得HTTP请求的东西</p><blockquote class="nn no np"><p id="1cf2" class="iq ir jo is b it iu iv iw ix iy iz ja nq jc jd je nr jg jh ji ns jk jl jm jn hb bi translated">例如网络服务器！</p></blockquote><p id="fa6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">我在</em> <a class="ae jp" rel="noopener" href="/google-cloud/cloud-run-and-cloud-function-what-i-use-and-why-12bb5d3798e1"> <em class="jo">里已经讲过了，我的第一篇文章</em> </a> <em class="jo">。<br/> </em>最后，<strong class="is hj">你有一个web服务器调用你的函数</strong>。准备好部署并且<strong class="is hj">完全兼容应用引擎或云运行。</strong> <br/> <em class="jo">这里只是运行你的功能代码。如果你</em> <strong class="is hj"> <em class="jo">有环境依赖值</em> </strong> <em class="jo">，像云函数容器里的源文件目录，</em> <strong class="is hj"> <em class="jo">就比较难在本地构建一些等价的东西。</em>T72】</strong></p><blockquote class="lx"><p id="07cf" class="ly lz hi bd ma mb mc md me mf mg jn dx translated">那么，为什么一个被黑的云函数？</p></blockquote><h1 id="77f6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb nd kd ke kf ne kh ki kj nf kl km kn bi translated">为正确的工作使用正确的工具</h1><p id="90be" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">基于云运行的V2运行时是一个不错的选择，没有V1运行时的一些缺点。</p><blockquote class="lx"><p id="caef" class="ly lz hi bd ma mb mc md me mf mg jn dx translated">然而，这个解决方案仍然是一个黑客！</p></blockquote><p id="034f" class="pw-post-body-paragraph iq ir hi is b it mh iv iw ix mi iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated"><strong class="is hj">产品有自己的优势</strong>并被<strong class="is hj">相应设计</strong>，更<strong class="is hj">便携</strong>，更<strong class="is hj">可扩展</strong>，更<strong class="is hj">高效</strong>(在性能、成本或开发者体验/生产力方面)！<br/>在这种情况下，<strong class="is hj">云运行之上的V2运行时增加了一些额外的约束。</strong></p><blockquote class="lx"><p id="d38a" class="ly lz hi bd ma mb mc md me mf mg jn dx translated">为什么要用云函数而不是云运行？</p></blockquote><p id="7f22" class="pw-post-body-paragraph iq ir hi is b it mh iv iw ix mi iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hb bi translated">有了云运行，<strong class="is hj">本地测试更容易了</strong>，开箱即用的<strong class="is hj">可移植性更强了</strong>，而且您仍然是容器内运行时环境的<strong class="is hj">主人</strong>。<em class="jo">你</em> <strong class="is hj"> <em class="jo">避免任何容器包装的改变</em> </strong> <em class="jo">这样就可以破解这种黑客攻击，就像静态资源一样。</em></p><p id="338b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了云运行，你<strong class="is hj">可以释放你的可能性</strong>，变得<strong class="is hj">更加敏捷</strong>！性能和优势将是相同的云功能V2和这个黑客，但没有缺点！</p></div></div>    
</body>
</html>