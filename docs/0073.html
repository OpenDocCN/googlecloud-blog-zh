<html>
<head>
<title>Monitoring distributed systems with Google Big Query and R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Google Big Query和R监控分布式系统</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/monitoring-distributed-systems-with-google-big-query-and-r-6fa3a17a81e8?source=collection_archive---------0-----------------------#2016-02-29">https://medium.com/google-cloud/monitoring-distributed-systems-with-google-big-query-and-r-6fa3a17a81e8?source=collection_archive---------0-----------------------#2016-02-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="58cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博文中，我将解释我们如何使用<a class="ae jd" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank">谷歌的大查询</a>来存储和挖掘日志数据，然后使用开源统计编程语言<a class="ae jd" href="http://www.r-project.org/" rel="noopener ugc nofollow" target="_blank"> R </a>来运行统计测试，以确定新代码是否行为正确。</p><p id="3488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="http://www.nomanini.com/" rel="noopener ugc nofollow" target="_blank"> Nomanini </a>我们相信持续交付是一项关键的业务优势，在过去三年中，它让我们赶上并超过了一些更成熟的竞争对手。</p><p id="e17d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今年，我们将交付率从1月份的每月10个生产版本提高到9月份的50多个版本，而没有增加我们的工程人员。我们也从几百台设备扩展到了近一千台。手动升级和监控每个设备现在是不可能的。</p><p id="1695" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使有成千上万的单元和自动化验收测试在CI中运行，当在现场向销售点设备推出新代码时，总会有一些担忧。破损的代码会阻碍销售，甚至更糟，把一个设备变成一块昂贵的砖头。</p><h1 id="b1ea" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">向现场设备推出固件</h1><p id="e1f4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在新版本的固件通过自动化测试后，它将从CI升级到Alpha，然后升级到Beta。我们的用户和他们的设备默认订阅我们的稳定升级频道，但我们已经说服他们中的一些人成为测试版测试者，他们的终端订阅了测试版升级频道。(感谢，<a class="ae jd" href="http://www.chromium.org/getting-involved/dev-channel" rel="noopener ugc nofollow" target="_blank"> Chromium Project </a>这个伟大的想法。)一旦代码升级到测试版，测试频道上的设备就开始升级到新的固件。</p><p id="b42e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了限制任何潜在的影响，我们通过每两分钟仅升级一个设备来限制我们的部署。一旦设备被告知升级，它就登录到服务器，下载新的二进制文件，当商家不使用终端时，无缝启动新版本的固件。</p><p id="68cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有两个版本的主代码(我们内部对固件的称呼)，一个是测试版，另一个是稳定版。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/f4c9148e66a31db6ae928dfae70d5406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M03oMIDvmUwR8U3O.png"/></div></div></figure><p id="ac5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何能确定新的测试版固件没有以自动化测试中没有检测到的微妙方式被破坏？我们如何知道何时可以将测试版升级到稳定版，以便所有终端都可以获得升级？</p><p id="2955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用的流程是:</p><ol class=""><li id="6c7f" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">在现场运行时，监控稳定版和测试版嵌入式固件的指标。</li><li id="1b23" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">将指标从设备上传到我们的服务器(<a class="ae jd" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank"> Google App Engine </a>)并保存到数据库。(<a class="ae jd" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank">谷歌大查询</a>)</li><li id="78e3" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">将指标提取到统计分析工具中。(<a class="ae jd" href="http://www.r-project.org/" rel="noopener ugc nofollow" target="_blank"> R </a>或<a class="ae jd" href="http://www.rstudio.com/" rel="noopener ugc nofollow" target="_blank"> RStudio </a>)</li><li id="fc9c" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">运行统计测试，以确定稳定版和测试版之间是否有任何差异。</li><li id="4eb3" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">如果没有区别，那么就没有理由不将测试版代码升级为稳定版。</li></ol><h1 id="f53f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">现场监控</h1><p id="ae86" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与大多数嵌入式产品一样，现场监控也极具挑战性。终端由电池供电，并使用通常不可靠的GSM/GPRS网络连接回我们的服务器。我们只有几百kB的闪存可用于日志。在一些国家，通过GSM传输数据的费用超过每兆1美元，有时高达每兆10美元。所以我们不能像在数据中心那样上传原始日志文件或发送UDP数据包。</p><p id="4b40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">苹果的iPad和iPhone使用统计(设置—通用—关于—诊断&amp;使用—诊断&amp;使用数据)聚合键:全天的价值指标。看起来他们有直方图类型计数(像背光亮度，有10%桶)；以及事件数、秒数、毫安功率的计数器。</p><p id="8189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">摘自我的一个日常iPad日志文件:</p><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="5a69" class="lm jf hi li b fi ln lo l lp lq"> com.apple.power.backlight.values.000_010  <br/> 5387  <br/> com.apple.power.backlight.values.010_020  <br/> 162  <br/> com.apple.power.backlight.values.020_030  <br/> 11898  <br/> com.apple.power.backlight.values.030_040  <br/> 52714  <br/> com.apple.power.backlight.values.040_050  <br/> 0  <br/> com.apple.power.backlight.values.050_060  <br/> 0  <br/> com.apple.power.backlight.values.060_070  <br/> 0  <br/> com.apple.power.backlight.values.070_080  <br/> 0  <br/> com.apple.power.backlight.values.080_090  <br/> 0  <br/> com.apple.power.backlight.values.090_100  <br/> 0  <br/>   <br/> com.apple.power.state.charging.count  <br/> 1  <br/> com.apple.power.state.charging.duration  <br/> 18898  <br/> com.apple.power.state.charging.energy  <br/> -20573  <br/> com.apple.power.state.overall.average_length  <br/> 33698  <br/> com.apple.power.state.overall.average_power  <br/> 49</span></pre><p id="26bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以此为灵感，我们编写了一个小的C++库，它可以被想要被检测的应用程序代码调用。计数保存在C++ key:value映射中。在世界协调时午夜，地图被序列化为JSON并上传到我们的服务器。</p><p id="72a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JSON数据包看起来像这样:</p><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="1b47" class="lm jf hi li b fi ln lo l lp lq">{<br/>  "counts": {<br/>    "ERROR": 7,<br/>    "WARNING": 1475,<br/>    "INFO": 19622,<br/>    "DEBUG": 362754,<br/>    "[E].EventsManager.423": 2,<br/>    "[E].GPSManager.259": 1,<br/>    "[E].SlaveCommsDispatcher.158": 2,<br/>    "[E].SlaveCommsDispatcher.311": 1,<br/>    "[E].SlaveCommsDispatcher.395": 1,<br/>    "CSQ.BitErrors.0": 42,<br/>    "CSQ.BitErrors.1": 1,<br/>    "CSQ.BitErrors.3": 2,<br/>    "CSQ.BitErrors.5": 1,<br/>    "CSQ.SignalStrength.6-11": 18,<br/>    "CSQ.SignalStrength.12-17": 12,<br/>    "CSQ.SignalStrength.18-23": 15,<br/>    "CSQ.SignalStrength.24-29": 1,<br/>    "GPRS.TimeToConnect.0-20": 2<br/>  },<br/>  "firmwareVersion": "4264-548923b591c6",<br/>  "startTime": "2014-09-22 00:00:01.152",<br/>  "endTime": "2014-09-23 00:00:06.574"<br/>}</span></pre><p id="6ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里发生了几件事:</p><p id="0105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">错误、警告、信息和调试计数是代码运行时终端记录的调试行的总数。</p><p id="8ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于记录的每个错误或关键行，库以[loglevel].filename.linenumber的格式生成一个键，如[E].GPSManager.259，并增加该键的计数。我们还增加了全局错误计数器。</p><p id="3963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录文件名和行号可以告诉我们导致错误的代码区域。即使没有堆栈跟踪，我们也很清楚是什么导致了问题。此外，这并不意味着检测特定设备上的详细错误，而是检测许多设备上的类似错误，以便我们可以检测错误版本。</p><p id="9a65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还使用日志库来构建有趣的直方图:一个例子是CSQ，或信号强度，一个范围从0 (0%)到32 (100%)的值。每次我们读取CSQ，我们增加正确的桶。这用于测试不同硬件版本上天线放置的变化是否提高了这些设备的信号质量。</p><p id="16d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直方图也用于定时事件:GPRS。time to connect . 0–20:2表示调制解调器连接到GPRS网络需要0到20秒的时间。由于没有其他桶，这意味着所有GPRS连接都短于20秒。</p><p id="35aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，在午夜(UTC ),设备在JSON数据包中发送它们的计数，并且计数器被重置回0。服务器将这些数据与它来自的设备的唯一ID一起传输到Google Big Query的一个表中。</p><p id="2f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更早地发现问题，测试版设备会更频繁地上传统计数据(每2、4、8或12小时一次)，以便我们在新的测试版开始推出后更快地获得诊断信息。</p><h1 id="0601" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">将诊断数据流式传输到Google Big Query</h1><p id="d276" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在正常连接到我们的服务器的过程中，终端将JSON诊断包上传到运行在<a class="ae jd" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank"> Google App Engine </a>上的应用程序。一旦数据到达服务器，它就被打包到一个<a class="ae jd" href="https://cloud.google.com/appengine/docs/python/taskqueue/overview-push" rel="noopener ugc nofollow" target="_blank">推送任务</a>中，该任务连接到Google Big Query的<a class="ae jd" href="https://cloud.google.com/bigquery/streaming-data-into-bigquery" rel="noopener ugc nofollow" target="_blank">流插入API </a>，在那里它被插入到我们的诊断事件日志表中。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lr"><img src="../Images/c320225c457c699a16c59e1a66600db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1xGC0xKskq4XEKN_.png"/></div></div></figure><h1 id="06f2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在大查询中创建视图</h1><p id="2bed" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">因为所有的诊断事件(不仅仅是计数器)都流入这个表，所以我创建了一个视图，只提取诊断计数器数据，简化了下游处理。</p><p id="0a28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要通过大查询<a class="ae jd" href="https://bigquery.cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> web UI </a>创建视图，像往常一样编写一个查询，然后单击Save View。它将要求项目、保存视图的数据集和表ID，即视图的表名。保存后，该视图可以像任何其他表查询一样进行查询。</p><p id="a737" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用以下SQL来创建我的视图:</p><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="5602" class="lm jf hi li b fi ln lo l lp lq">SELECT  <br/>   JSON_EXTRACT_SCALAR(event_data, '$.firmwareVersion') AS firmware_version,<br/>   device_id,  <br/>   SUM(INTEGER(JSON_EXTRACT_SCALAR(event_data, '$.counts.CRITICAL'))) AS critcals,  <br/>   SUM(INTEGER(JSON_EXTRACT_SCALAR(event_data, '$.counts.ERROR'))) AS errors,  <br/>   SUM(INTEGER(JSON_EXTRACT_SCALAR(event_data, '$.counts.DEBUG'))) AS debugs,  <br/>   1e6 * SUM(INTEGER(JSON_EXTRACT_SCALAR(event_data,'$.counts.ERROR'))) / SUM(INTEGER(JSON_EXTRACT_SCALAR(event_data, '$.counts.DEBUG'))) AS error_rate  <br/> FROM [nomanini.event_log]  <br/> WHERE event = 'Counters'  <br/> GROUP BY firmware_version, device_id  <br/> ORDER BY firmware_version DESC, device_id DESC;</span></pre><p id="3474" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在event_log表中，计数器作为JSON对象存储在event_data列中。大查询SQL的另一个伟大特性是<a class="ae jd" href="https://cloud.google.com/bigquery/query-reference?hl=de#jsonfunctions" rel="noopener ugc nofollow" target="_blank"> JSON_EXTRACT_SCALAR </a>，它允许您通过指定键路径从JSON对象中提取数据。</p><p id="18a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从event_log表中，我得到了device_id，这是每个终端的唯一标识符，从JSON的event_data列中，我得到了固件版本、关键、错误和调试计数。</p><p id="7d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用GROUP BY firmware_version，device_id对计数求和，因此我得到了每个设备在每个固件版本上产生的错误总数。我还计算了error_rate，它被定义为每百万个调试行中的错误数，或者error/debug * 1e6。(稍后将详细介绍原因。)</p><p id="f841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询此视图:</p><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="b1ef" class="lm jf hi li b fi ln lo l lp lq">SELECT * FROM [nomanini.firmware_error_rates] LIMIT 10;</span></pre><p id="46fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给出:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ls"><img src="../Images/c02824b4a27a63c722595ae2fca0ddd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/0*BU2sfz58UJoXO6zi.png"/></div></figure><h1 id="f507" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">从Google Big Query获取数据到R</h1><p id="536d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在R广泛的CRAN资源库中有一个奇妙的<a class="ae jd" href="https://github.com/hadley/bigrquery" rel="noopener ugc nofollow" target="_blank"> bigrquery </a>包，它允许您在R内部运行SQL查询，并在R数据框架中获得结果。</p><p id="1f60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">r将启动OAuth进程并打开您的浏览器进行身份验证。查询运行，结果保存在结果数据框中。</p><p id="dc73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了从R内部查询Big Query中的firmware_error_rates视图，我运行了以下代码:</p><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="f635" class="lm jf hi li b fi ln lo l lp lq">library(bigrquery)  <br/>   <br/> # The two versions that we want to compare: Beta and Stable   <br/> firmware_version_beta = "4264-548923b591c6"  <br/> firmware_version_stable = "4252-c2b7961f0a5b"  <br/>   <br/> # The base SQL statement  <br/> sql_query_a = "SELECT firmware_version, device_id, critcals, errors, debugs, error_rate FROM [nomanini-dashboard:nomanini.firmware_error_rates] WHERE firmware_version = '"  <br/> sql_query_b = "' ORDER BY device_id LIMIT 100;"  <br/>   <br/> # Create the SQL strings, concatenate using paste  <br/> sql_beta &amp;lt;- paste(sql_query_a, firmware_version_beta, sql_query_b, sep="")  <br/> sql_stable &amp;lt;- paste(sql_query_a, firmware_version_stable, sql_query_b, sep="")  <br/>   <br/> # Run the queries for both the old and new versions  <br/> v_beta &amp;lt;- query_exec("nomanini-dashboard", "nomanini", sql_beta)  <br/> v_stable &amp;lt;- query_exec("nomanini-dashboard", "nomanini", sql_stable)  <br/>   <br/> # Fill NA's (null's) with 1 so can log transform the data  <br/> v_beta[is.na(v_beta)] &amp;lt;- 1  <br/> v_stable[is.na(v_stable)] &amp;lt;- 1  <br/>   <br/> # Join two data frames by the common key variable device_id  <br/> # only device_id’s that are in both v_stable and v_beta will be in the merged data frame  <br/> merged &amp;lt;- merge(v_beta, v_stable, by="device_id", suffixes = c(".beta",".stable"))</span></pre><p id="5c9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码在视图上运行两个查询，一个用于测试版，一个用于稳定版；用1替换任何空值(这样我们就可以对数据进行日志转换，稍后会详细介绍)；然后合并两个结果集，使得只有同时处于稳定版本和测试版本的设备被包括在合并的数据帧中。</p><h1 id="104f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用Student t-test和Wilcoxon符号等级测试检测错误的代码版本</h1><p id="d8e3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们想检测一个测试版是否是“坏的”,这样我们就可以尽早阻止这种新的、有缺陷的代码的推出。目前，如果平均来说，一个版本比当前的稳定版本记录了更多的错误，我们就把它定义为“坏”版本。</p><p id="7686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下图中，两个版本(蓝色和绿色版本)被认为具有相似的质量，因为这两个版本上的设备具有相似的错误数量。(每个方块代表一个设备，x轴是设备在该版本中出现的错误数。)</p><p id="0c47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">红色版本的设备有更多的错误，这意味着该版本有问题。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lt"><img src="../Images/dce646680606c52994af5c671328e00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4O5QLjH8356yTRNw.png"/></div></div></figure><p id="ff0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进行统计测试，我们使用<a class="ae jd" href="http://en.wikipedia.org/wiki/Student's_t-test#Paired_samples" rel="noopener ugc nofollow" target="_blank">学生的成对样本t检验</a>，因为我们正在比较两个版本的代码，版本_旧和版本_新，相同的设备在版本_旧和版本_新组中，因为每个设备都在版本_旧上，几天后升级到版本_新。这构建了两个数据集，但是在两个样本中具有相同的群体(装置)。</p><p id="5ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在测试的假设是:</p><ul class=""><li id="dd0a" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc lu kz la lb bi translated">H0:零假设:“两个版本的错误率分布没有区别。”</li><li id="ae08" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lu kz la lb bi translated">哈:替代假设:“新版本与旧版本的错误率分布不同。”(注意，错误率可能更好或更坏，因此是双面测试。)</li></ul><p id="f6a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里做了一些假设:</p><ol class=""><li id="7d21" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">劣质版本比优质版本记录了更多的错误。</li><li id="df6c" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">一个差的发布(一个有问题的发布)的错误与调试日志行的比率(E/D比率)比好的发布要高。</li><li id="6e0c" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">一个版本上所有设备的E/D比率都是相似的。或者至少是正态分布的。</li><li id="50ff" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">E/D比率变化的唯一原因是由于代码变化。没有任何外部因素影响错误的数量。(我们知道这是错误的，因为像连接性差、电池没电等等。导致记录错误，但希望这些异常值相对较少。)</li><li id="4ea6" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">E/D比值的平均值会随着不良释放而显著变化，而在类似质量的释放之间不会显著变化。</li><li id="c59c" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">在两个版本之间进行配对t检验将检测E/D比值样本均值的变化。</li></ol><p id="135a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但首先，我们需要进行一些数据转换，使数据“表现更好”，这样我们的测试就有更大的机会在噪音中找到信号。</p><h1 id="1af4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">从绝对错误数变为错误率，以说明不同的使用模式</h1><p id="5a9a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果你一直在关注，你会发现我从谈论错误变成了谈论错误率。这是因为我们需要标准化错误的绝对数量，以说明终端的使用量。经常使用的终端往往会出现更多由环境引起的错误，例如GSM和GPRS连接不良、纸张用完、电池没电导致子系统关闭，以及现场发生的许多其他与固件无关但无论如何都应该记录的问题。</p><p id="391e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过将记录的错误行数除以记录的调试行数，再乘以100万，我们可以得到每100万个调试行的错误数，这个数字允许在设备之间进行比较，无论它们在一个版本上运行了一个小时还是一个星期。</p><h1 id="381e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">对t检验中的异常值进行对数归一化处理</h1><p id="d1de" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">因为我们的测试人员相对较少，所以我决定不删除离群值并丢弃数据。但这意味着有一个带有一些远距离异常值的长尾，因此数据不再是正态分布的，这违反了t检验的一个<a class="ae jd" href="http://en.wikipedia.org/wiki/Student's_t-test#Assumptions" rel="noopener ugc nofollow" target="_blank">假设</a>。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lv"><img src="../Images/53b6eb6c83cd3195848cf62d7649894d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PzLdkvoEbeQYxET3.png"/></div></div></figure><p id="eb38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了抓住这个尾巴，一个常见的转换是对数据进行对数转换。[ <a class="ae jd" href="http://stats.stackexchange.com/questions/18844/when-and-why-to-take-the-log-of-a-distribution-of-numbers" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae jd" href="http://www.r-statistics.com/2013/05/log-transformations-for-skewed-and-wide-distributions-from-practical-data-science-with-r/" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]在下图中你可以清楚地看到对数变换是如何使分布更加正常的。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lv"><img src="../Images/ad093ca9c2a61f8b6500421c21d3db00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tf4K54DSOF29wgRI.png"/></div></div></figure><p id="3c26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择了以10为底的对数(而不是自然对数，或以2为底)，这样x轴上的每个单位都是误差率增加的一个数量级。</p><p id="fc46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将在上面的代码片段中看到，我将有0个错误(NA或nulls)的设备设置为有1个错误，这样记录日志仍然有效。(就我而言，百万分之0的调试错误与百万分之1的调试错误是相等的。)</p><h1 id="926a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在R中运行t测试</h1><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="4c65" class="lm jf hi li b fi ln lo l lp lq">&amp;gt; t.test(log10(merged$error_rate.beta), log10(merged$error_rate.stable), paired=TRUE)<br/>   <br/> Paired t-test</span><span id="2204" class="lm jf hi li b fi lw lo l lp lq">data:  log10(merged$error_rate.beta) and log10(merged$error_rate.stable)<br/>t = -1.7194, df = 13, p-value = 0.1092<br/>alternative hypothesis: true difference in means is not equal to 0<br/>95 percent confidence interval:<br/> -0.9404635  0.1068907<br/>sample estimates:<br/>mean of the differences <br/>             -0.4167864 </span><span id="792c" class="lm jf hi li b fi lw lo l lp lq">Geometric mean of the differences (base 10): 0.3830131</span></pre><p id="19ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意，由于对数变换，测试中引用的平均值实际上是几何平均值，而不是算术平均值。[ <a class="ae jd" href="http://onlinestatbook.com/2/transformations/log.html" rel="noopener ugc nofollow" target="_blank"> 1 </a> ])</p><h1 id="1138" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用Wilcoxon符号秩检验</h1><p id="e42d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">或许更正确的是，我运行了<a class="ae jd" href="http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test" rel="noopener ugc nofollow" target="_blank"> Wilcoxon符号秩检验</a>，因为与t检验不同，<a class="ae jd" href="http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test#Assumptions" rel="noopener ugc nofollow" target="_blank">没有假设错误率的正态分布</a>，这使得它对异常值更加稳健。对于这个测试，那么，我不需要记录标准化数据。这也使得结果的解释变得稍微容易一些。</p><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="4a17" class="lm jf hi li b fi ln lo l lp lq">&amp;gt; wilcox.test(merged$error_rate.beta, merged$error_rate.stable, paired=TRUE, conf.int=TRUE)  <br/>   <br/> Wilcoxon signed rank test</span><span id="0e40" class="lm jf hi li b fi lw lo l lp lq">data:  merged$error_rate.beta and merged$error_rate.stable<br/>V = 30, p-value = 0.1726<br/>alternative hypothesis: true location shift is not equal to 0<br/>95 percent confidence interval:<br/> -505.36438   55.72701<br/>sample estimates:<br/>(pseudo)median <br/>     -121.2072</span></pre><p id="c43e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中位数是两个版本之间错误率的变化。这里，-121意味着新的测试版比当前的稳定版每百万调试行少121个错误。我们有95%的把握，测试版中每百万调试行的错误数比稳定版少505到多56个。</p><p id="6a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们两个测试中的p值都大于<a class="ae jd" href="http://en.wikipedia.org/wiki/P-value" rel="noopener ugc nofollow" target="_blank"> 0.05显著性水平</a>，所以我们不能拒绝零假设，并且必须接受“两个版本的错误率分布之间没有差异”，因此<strong class="ih hj">版本之间的代码质量是相似的</strong>。</p><p id="c7ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于此，我们将把测试版代码升级为稳定版。</p><p id="c05f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们不能说代码是好是坏，只能说如果我们满意旧的稳定版本，那么我们应该满意新的测试版本。</p><h1 id="510d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">显示数据</h1><p id="fe52" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">或许比统计测试更容易解释的是<a class="ae jd" href="https://stat.ethz.ch/R-manual/R-devel/library/graphics/html/boxplot.html" rel="noopener ugc nofollow" target="_blank">箱线图</a>和<a class="ae jd" href="https://stat.ethz.ch/R-manual/R-devel/library/graphics/html/stripchart.html" rel="noopener ugc nofollow" target="_blank">带状图</a>。条形图表中的每个彩色方块代表单个设备的错误率。方框图显示了最小值和最大值，第一个和第三个四分位数，深色带是中间值。它还将所有异常值显示为圆圈。(蓝色版本右边有两个异常值。)为了可读性，我将这些图垂直分开。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lv"><img src="../Images/2a7cff141c0ae2f70b66f5c92db6a2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OLh_zwE6XS2Al-_O.png"/></div></div></figure><p id="9de8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到在两个版本中，带状图和箱形图在很大程度上相互重叠，因此两个版本具有相似的错误率，直观地支持了上面的统计测试。</p><h1 id="3a0b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">好的，那么这真的能发现问题吗？</h1><p id="6c68" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">几个月前，我们在一个子系统中完成了主要的代码重构。我们开始推出新的测试版固件，虽然大多数设备在升级后表现正常，但在一些设备上，代码会中断，因为它没有正确处理只在现场出现的角落情况，然后只在少数设备上出现。</p><p id="3453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些错误被设备记录下来，上传到服务器，并在我们运行这些测试时被检测到。出现错误的设备在下图中清晰可见，聚集在右边的红色异常值处。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lv"><img src="../Images/69e81fd1d05f8d1f9b09692bfeaf770b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MDuPkBjRlPq76mBr.png"/></div></div></figure><p id="222e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">t检验和Wilcoxon检验的p值都低于0.05显著性水平，有力地证明了两个版本之间存在差异。</p><pre class="ki kj kk kl fd lh li lj lk aw ll bi"><span id="a31f" class="lm jf hi li b fi ln lo l lp lq">&amp;gt; t.test(log10(merged$error_rate.beta), log10(merged$error_rate.stable), paired=TRUE)<br/>   <br/>     Paired t-test</span><span id="4991" class="lm jf hi li b fi lw lo l lp lq">data:  log10(merged$error_rate.beta) and log10(merged$error_rate.stable)<br/>t = 2.8624, df = 28, p-value = 0.007872<br/>alternative hypothesis: true difference in means is not equal to 0<br/>95 percent confidence interval:<br/>0.1131325 0.6825117<br/>sample estimates:<br/>mean of the differences<br/>              0.3978221</span><span id="c344" class="lm jf hi li b fi lw lo l lp lq">Geometric mean of the differences (base 10): 2.499321</span><span id="325a" class="lm jf hi li b fi lw lo l lp lq">&amp;gt; wilcox.test(merged$error_rate.beta, merged$error_rate.stable, paired=TRUE, conf.int=TRUE)  <br/>   <br/>     Wilcoxon signed rank test</span><span id="f806" class="lm jf hi li b fi lw lo l lp lq">data:  merged$error_rate.beta and merged$error_rate.stable<br/>V = 318, p-value = 0.02906<br/>alternative hypothesis: true location shift is not equal to 0<br/>95 percent confidence interval:<br/>     7.075123 14546.761849<br/>sample estimates:<br/>(pseudo)median<br/>      183.0312</span></pre><p id="3a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于这个证据，我们停止了代码的推广。在[E].filename.linenumber couters的帮助下，我们能够确定是什么导致了问题，编写了一个单元测试，重现了错误，修复了代码并推出了新版本。</p><h1 id="0a7e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">今后</h1><p id="fd01" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我想做的事情有很多，主要是让检测过程更加自动化，并向devops团队提供一个关于新固件推出情况的良好概览仪表板。</p><p id="70ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我可能会在<a class="ae jd" href="https://cloud.google.com/compute/" rel="noopener ugc nofollow" target="_blank">计算引擎</a>的一个实例上运行<a class="ae jd" href="https://www.opencpu.org/" rel="noopener ugc nofollow" target="_blank"> OpenCPU </a>，一个R的RESTful API，这样R函数就可以被运行在AppEngine上的生产应用调用。</p><p id="d8ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他一些想法:</p><ol class=""><li id="605a" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">每小时自动运行测试，并标记异常值以供支持人员调查。</li><li id="f2a7" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">如果统计测试检测到重大变化，则自动暂停推广。</li><li id="1d17" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">监视[E].filename.linenumber，它们是特定类型问题的有力指示，而不仅仅是全局错误计数。</li><li id="d49a" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">随着我们将发布数量提高到每天一个以上的固件版本，我们将需要增加测试人员的数量，以便我们可以在开始推出后更快地获得测试结果。</li></ol><h1 id="e722" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">参考</h1><p id="79d3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">互联网上充斥着关于学习和统计学的信息。我读过的最好的统计学教科书之一是<a class="ae jd" href="http://health.adelaide.edu.au/psychology/ccs/teaching/lsr/" rel="noopener ugc nofollow" target="_blank">用R学习统计学:心理学学生和其他初学者教程</a>，作者提供了免费的pdf下载。每当我感到困惑的时候，这就是我的教科书。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="4a8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="me">原载于2014年10月4日www.dalehumby.com</em><em class="me"/><a class="ae jd" href="http://www.dalehumby.com" rel="noopener ugc nofollow" target="_blank"><em class="me">。</em></a></p></div></div>    
</body>
</html>