<html>
<head>
<title>App Engine Startup time and the Global Variable problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用引擎启动时间和全局变量问题</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/app-engine-startup-time-and-the-global-variable-problem-7ab10de1f349?source=collection_archive---------1-----------------------#2017-04-13">https://medium.com/google-cloud/app-engine-startup-time-and-the-global-variable-problem-7ab10de1f349?source=collection_archive---------1-----------------------#2017-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c9955a89d377d463baaeaead77866249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-WTHy5UvOc2BnvCcMwBwA.png"/></div></div></figure><div class=""/><p id="b5f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我在T1之前所说的，我的朋友(卡特)向我寻求帮助来提高他的网站“<em class="jp">诱饵和缝线</em>”的性能，该网站将钓鱼爱好者与当地设计师匹配起来，为钓鱼旅行设计定制服装。虽然这是一个很棒的想法，但beta测试人员遇到了冷启动性能问题。像大多数性能问题一样，第一步是<a class="ae jo" rel="noopener" href="/@duhroach/understanding-and-profiling-app-engine-cold-boot-time-908431aa971d">正确地分析它。</a></p><p id="5d7a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分析显示，问题不在于GAE本身(GAE标准冷启动时间非常快)。问题在于实例冷启动时运行的代码，而不是在处理其他请求时运行的代码。当然，下一步是挖掘这些数据的结果，找出是什么阻碍了<em class="jp">用户尽可能快地行动起来。</em></p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">忙到没时间看书？查看上面的视频以了解总结。</figcaption></figure><h1 id="4ca1" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">去跳到一根木头上</h1><p id="469c" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">在Google Cloud控制台中查看日志时，我们得到了一个确认，告诉我们冷启动请求有问题。下面的日志显示，加载请求后的第一组8–10个请求比之后的请求要慢得多:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/024466b2a537ddcb6d701964da59e101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*BO_BaTxNHLHgVDgpoSEdPg.png"/></div></figure><p id="1bfd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看日志中的时间戳，我意识到这个问题不是在加载请求的之后<em class="jp">立即出现的请求，而是与加载请求的</em>同时出现的<em class="jp">。时间戳显示，慢速请求与加载请求几乎在同一毫秒到达:</em></p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es le"><img src="../Images/67256f607ed54114e90fb11403ce70c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*yZhoxWTQNurZdV-o9eBZsw.png"/></div></figure><p id="0220" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">鉴于这一事实，我们真正应该看这个日志数据的方式是有两组请求:一组与加载请求同时到达(慢速)，另一组在加载请求之后到达(快速)。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/95e85636e445d2dfa7e212c332edc84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*bHOgSeaYh6CH0BDxWaKkAw.png"/></div></figure><p id="e6eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">鉴于这种思维的转变，我突然意识到哪里出了问题:<strong class="is hu">并行请求</strong>。</p><h1 id="255c" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">并行请求和冷启动</h1><p id="63a7" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">如果您在GAE标准中启用了<a class="ae jo" href="https://cloud.google.com/appengine/docs/python/config/appref#threadsafe" rel="noopener ugc nofollow" target="_blank"> threadsafe </a>,那么您的应用程序可以接收并行请求，这些请求将会分散到不同的线程上，在同一个实例上执行工作。这通常非常重要，因为它允许您最大限度地利用现有的实例资源。</p><p id="bcda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在这种情况下，这会导致一个问题，因为加载请求中的某些东西导致并行请求的其余部分阻塞<em class="jp">，直到加载请求完成</em>。查看下面的日志，您可以看到每个并行请求在等待时会变慢；在某些情况下，比加载请求本身慢2倍:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/18e4c8ea813f383fa88f305cada70146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*24CibLvvdqHKBD-5-A2v6g.png"/></div></figure><p id="23ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这不是并行请求的正常行为。代码中的某些东西导致其他请求一直等到第一个请求完成。仔细一看，问题很快就出现了:<strong class="is hu">卡特在摆弄全局变量</strong>。</p><h1 id="d270" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">全局变量和冷启动时间</h1><p id="5f15" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">当应用程序代码被导入、实例化并开始执行时，通常还需要启动一个全局数据块、公共函数或状态信息。大多数时候，这些系统在范围上倾向于全局的，因为它们需要被如此多的子系统使用(例如，一个日志记录系统。)在App Engine的情况下，这种全局初始化工作可能会延迟启动时间，因为它必须在请求得到服务之前完成。</p><p id="08e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑下面几行代码，这些代码执行一个数据库调用(或者在我们的例子中，一个<a class="ae jo" href="https://cloud.google.com/appengine/docs/python/ndb/" rel="noopener ugc nofollow" target="_blank"> NDB获取</a>)来填充一个全局值，该值将在剩余的服务生命周期中使用。</p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="lf jv l"/></div></figure><p id="25cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这段代码是我们全局初始化过程的一部分，一旦实例启动，它将对一些数据进行NDB查询。这个小变化对启动性能的影响是巨大的。下图显示了运行此代码时冷启动与冷启动的区别。下图显示了执行50次迭代的启动所用时间的第95个百分点。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lg"><img src="../Images/943dfd435ef175863b61db97bb440cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*9LYFnUavGEeRAzeg39LAHg.png"/></div></figure><p id="8134" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到，对于这个简单的测试，启动时间大约慢了4倍。公平地说，这个初始化获取只发生在这个实例的开始，后续的请求(甚至在多个线程上)将共享这个数据，并且不会产生开销。虽然开机时间仍然是&lt; 1 second, it’s now gotten 3x slower, for a single NDB fetch during this global path.</p><h1 id="9ade" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Lazy loading globals</h1><p id="8234" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">With all this in mind, <em class="jp">的诱饵，但是针脚的</em>问题就变得很清楚了:</p><ul class=""><li id="e719" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">加载请求需要额外的冷启动时间</li><li id="6f5f" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">每个请求都试图实例化同一个全局变量，导致线程间的阻塞争用。</li><li id="c269" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">因此，loading-request将获得全局变量的锁，需要更长的时间来完成请求，因此所有其他并行请求都将等待。</li></ul><p id="5e85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们问题的解决方案来自一个非常简单的实现:并不是每个请求<em class="jp">实际上都使用了全局变量</em>。但是因为全局逻辑正在发生，所以无论如何，其他请求最终也会阻塞这个变量的初始化。</p><p id="2d4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一点上，修复非常简单:根据使用它的第一个实例，将全局变量改为惰性初始化:</p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="lf jv l"/></div></figure><p id="e3ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，应用程序仍然(最终)支付成本来执行NDB查询，但这里的技巧是，当getCDN函数<strong class="is hu">不在主路径</strong>中时，它的性能会更好。如果这个全局变量只在20%的提取中使用，那么在绝对需要时才进行全局提取的情况下，一般的冷启动时间会有所改善。</p><p id="83f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于我们的用例，这非常重要，因为您可以看到加载请求通常在计算中不使用全局变量:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/fe17db0ba3d70cba5a77aac86658d090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*5yKspz05cpnwU7O4SC1-3A.png"/></div></figure><p id="2294" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然这是一个<em class="jp">特有的</em>案例，但是你可以很快看到冷启动时间会导致问题，事实上，会影响你的底线。</p><h1 id="adb5" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">每一毫秒都很重要</h1><p id="199e" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">对于那些在启动时间很重要的情况下使用过<a class="ae jo" href="https://en.wikipedia.org/wiki/Managed_code" rel="noopener ugc nofollow" target="_blank">托管语言</a>的人来说，这些信息大部分都是老掉牙的。但是在云计算的世界里，这些微小的性能异常会产生严重的后果，不仅影响用户对性能的感知，还会影响<em class="jp">纯成本</em>:每天有100个加载请求，比常规请求慢187倍，这将导致计算时间的巨大开销。</p></div></div>    
</body>
</html>