<html>
<head>
<title>Getting Started with Artifact Registry: Deploying to Google Kubernetes Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工件注册入门:部署到Google Kubernetes引擎</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/getting-started-with-artifact-registry-deploying-to-google-kubernetes-engine-ee490da2f6de?source=collection_archive---------1-----------------------#2020-04-15">https://medium.com/google-cloud/getting-started-with-artifact-registry-deploying-to-google-kubernetes-engine-ee490da2f6de?source=collection_archive---------1-----------------------#2020-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9017" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> Google Cloud最近发布了下一代容器管理工具:Artifact Registry。借助Artifact Registry，您可以管理您的构建工件，同时与云的构建、测试和部署套件以及第三方CI/CD系统集成。通过与分析功能的集成，Artifact Registry提供了您所使用的包的材料清单视图，同时持续地监控和更新那些工件的状态。这为您的软件开发和交付过程中使用的包、容器映像和其他依赖项提供了可见性和控制。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/8b585eead39c66a13a94f1933972c1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwpbNEAEbrPI1phJkHy0uw.png"/></div></div></figure><h1 id="b7bf" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用工件注册管理构建工件</h1><p id="5f69" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我最近发表了一篇<a class="ae kt" rel="noopener" href="/@ThatJenPerson/manage-your-build-artifacts-with-artifact-registry-953b98c58715">博文</a>，宣布发布<a class="ae kt" href="https://cloud.google.com/artifact-registry/docs/overview" rel="noopener ugc nofollow" target="_blank">工件注册库</a>，一个存储容器和构建工件的地方。帖子中包含了一个关于组织我的第一个家的相当无力的比喻，但我不想错过这个向全世界讲述我的房子的机会！我会试着想一个更好的比喻，但老实说，我只是对有机会谈论我的家庭项目感到超级兴奋。就像当你只想阅读食谱，但你必须滚动阅读几段关于作者意大利之行的段落，在那里他们采摘了仍被露水打湿的葡萄成熟的西红柿，如果你不想阅读我的手工作品，你可以继续滚动到好东西。我写的每一篇Artifact Registry文章都很有可能包括家庭装修，尤其是考虑到我现在不被允许离开这个地方。但是，实际阅读这一部分的好处是，您将会惊讶于我是如何将这一切与工件注册表联系起来的！我也会的，因为我还在写作，还没有决定。</p><h1 id="c475" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">我拿到了。是关于那些储物盒</h1><p id="c165" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">你知道每个人都有的储物盒吗？它们看起来像这样:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/850fa4822738aac95525d9e6a129a89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgmdcMdU0sdKDVsPW9vChg.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">这么有条理！</figcaption></figure><p id="ad96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们非常适合解决储物问题。我的健身房里有这些零碎的东西:鞋子、阻力带、时钟、护腕等等。我可以把我所有的健身器材存放在一个存储单元中(就像Artifact Registry一样)，同时根据它们的用途把它们分成不同的立方体(就像不同的存储库一样)。这是一个很好的类比，对吗？没有吗？好的，我下次会更加努力。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/3943b06d69f5d0f2fec0e327f7a8dde2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXmna3oLJkqLD2ByO3UDYQ.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">看哪！我的家庭健身房。我需要它为我的健美准备，但这是一个长篇大论的另一篇博文。</figcaption></figure><h1 id="4527" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">好东西来了！</h1><p id="d668" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果你跳过了这些细枝末节，这里是信息开始的地方，所以请注意！</p><h1 id="4866" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">神器注册表+谷歌Kubernetes引擎= ❤</h1><p id="a285" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果你正在阅读这篇文章，很有可能你已经知道了<a class="ae kt" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a>，但是为了更彻底，这里有一个快速概述。GKE是一个面向容器化应用的企业级平台，包括有状态和无状态、AI和ML、Linux和Windows、复杂和简单的web应用、API和后端服务。您可以使用GKE来利用行业首创的功能，如四路自动扩展和无压力管理。您还可以优化GPU和TPU配置，使用集成的开发人员工具，并从SREs获得多集群支持。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es la"><img src="../Images/934c597168cbe70118417cf3af48fb5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*8yIAewHwjOC1Gq8h0q1QPw.png"/></div></figure><p id="fbc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">神器注册表和谷歌Kubernetes引擎是天作之合。通过GKE使用工件注册，您可以在一个地方管理所有的工件。例如，您可以构建Maven包，将它们推送到AR，用Cloud Build和Jib对它们进行容器化，然后将它们部署到GKE。同时在构建过程、工件管理和GKE中使用一致的IAM。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lb"><img src="../Images/cc070ccc946066be3562f154cf2f4aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*ajSlM5ISpMEiuZbPb2DCAg.png"/></div></figure><p id="00fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Artifact Registry还使您能够在完全区域化的堆栈中运行。通过Artifact Registry，澳大利亚或南美的客户可以运行GKE集群并管理同一地区的容器映像，并且在提取映像时无需支付任何出口成本。很可爱，是吧？</p><h1 id="6fc4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">入门指南</h1><p id="2733" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">要开始，您需要一个现有的存储库。您可以在<a class="ae kt" href="https://cloud.google.com/artifact-registry/docs" rel="noopener ugc nofollow" target="_blank">文档</a>或<a class="ae kt" rel="noopener" href="/@ThatJenPerson/manage-your-build-artifacts-with-artifact-registry-953b98c58715">我的上一篇博客文章</a>中找到如何创建存储库。我还包含了这个gcloud命令，以防您需要快速提醒:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="a384" class="lh jr hi ld b fi li lj l lk ll">gcloud beta artifacts repositories create draynepipe — repository-format=docker — location=us-central1 — description="Docker repository"</span></pre><p id="ae9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建一个名为draynepipe的新存储库。</p><h1 id="be20" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">获取您的代码</h1><p id="2d26" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">从新的或现有的代码开始。下面是一个简单的go helloworld应用程序，我将在我的容器中使用它:</p><p id="66ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> helloworld.go </em> </strong></p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="d0d7" class="lh jr hi ld b fi li lj l lk ll">package main</span><span id="3f8e" class="lh jr hi ld b fi lm lj l lk ll">import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"<br/>  "os"<br/>)</span><span id="b56f" class="lh jr hi ld b fi lm lj l lk ll">func main() {<br/>  http.HandleFunc("/", handler)</span><span id="d6b1" class="lh jr hi ld b fi lm lj l lk ll">  port := os.Getenv("PORT")<br/>  if port == "" {<br/>    port = "8080"<br/>  }</span><span id="dabb" class="lh jr hi ld b fi lm lj l lk ll">  log.Printf("Listening on localhost:%s", port)<br/>  log.Fatal(http.ListenAndServe(fmt.Sprintf(":%s", port), nil))<br/>}</span><span id="5735" class="lh jr hi ld b fi lm lj l lk ll">func handler(w http.ResponseWriter, r *http.Request) {<br/>  log.Print("Hello world received a request.")<br/>  target := os.Getenv("TARGET")<br/>  if target == "" {<br/>    target = "World"<br/>  }<br/>  fmt.Fprintf(w, "Hello %s!\n", target)<br/>}</span></pre><p id="9e8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还在这里加入了docker文件，尽管它基本上是样板文件:</p><p id="b1f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> Dockerfile </em> </strong></p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="d5fd" class="lh jr hi ld b fi li lj l lk ll"># Use the offical Golang image to create a build artifact.<br/># This is based on Debian and sets the GOPATH to /go.<br/># <a class="ae kt" href="https://hub.docker.com/_/golang" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/golang</a><br/>FROM golang:1.12 as builder</span><span id="3bea" class="lh jr hi ld b fi lm lj l lk ll"># Copy local code to the container image.<br/>WORKDIR /app<br/>COPY . .</span><span id="01b4" class="lh jr hi ld b fi lm lj l lk ll"># Build the command inside the container.<br/>RUN CGO_ENABLED=0 GOOS=linux go build -v -o helloworld</span><span id="4e6e" class="lh jr hi ld b fi lm lj l lk ll"># Use a Docker multi-stage build to create a lean production image.<br/># <a class="ae kt" href="https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds</a><br/>FROM alpine<br/>RUN apk add — no-cache ca-certificates</span><span id="fadb" class="lh jr hi ld b fi lm lj l lk ll"># Copy the binary to the production image from the builder stage.<br/>COPY — from=builder /app/helloworld /helloworld</span><span id="4ce1" class="lh jr hi ld b fi lm lj l lk ll"># Run the web service on container startup.<br/>CMD ["/helloworld"]</span></pre><h1 id="a6f4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用云构建构建项目</h1><p id="c0d1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">请注意，您不必使用云构建来构建您的项目，但是这样做允许您自动将映像推送到工件注册表。</p><p id="26fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您还不知道您的云项目ID，您可以通过运行以下命令来获取它:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="afe3" class="lh jr hi ld b fi li lj l lk ll">gcloud config get-value project</span></pre><p id="8be9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用以下内容创建一个名为<code class="du ln lo lp ld b">cloudbuild.yaml</code>的文件:</p><p id="1246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">cloud build . YAML</em></strong></p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="27c5" class="lh jr hi ld b fi li lj l lk ll">steps:<br/>  - name:'gcr.io/cloud-builders/docker'<br/>  args: [ 'build', '-t', 'us-central1-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE}', '.' ]<br/>images:<br/>  - 'us-central1-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE}'</span></pre><p id="b427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变量<code class="du ln lo lp ld b">${_REPOSITORY}</code>和<code class="du ln lo lp ld b">${_IMAGE}</code>用于存储库名称和存储库中映像的名称，这样它们可以在构建时使用定制的云构建替换进行替换。</p><p id="636f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您希望使用同一个构建配置文件将映像推送到不同环境的存储库，例如测试、试运行或生产环境，那么这种方法非常有用。例如，这个命令会用<em class="jd"> draynepipe </em>替换存储库名称，用<em class="jd"> my-image </em>替换映像名称:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="13f3" class="lh jr hi ld b fi li lj l lk ll">gcloud builds submit — config=cloudbuild.yaml \<br/>— substitutions=_REPOSITORY="draynepipe",_IMAGE="pipe-image" .</span></pre><p id="c2a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我运行这个来提交我的容器，以使用云构建进行构建。然后，使用工件注册表将它存储在draynpipe存储库中。</p><h1 id="7c89" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">配置Docker存储库访问</h1><p id="e335" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">您可能需要配置对容器的访问。查看文档,了解创建集群所需的最低GKE版本，这些集群拥有从同一个项目中的Docker存储库中提取容器的默认权限。如果您没有使用这些GKE版本，您将需要使用<a class="ae kt" href="https://cloud.google.com/artifacts/docs/access-control#gke" rel="noopener ugc nofollow" target="_blank">Kubernetes imagePullSecrets</a>配置对拉容器的访问。</p><p id="3904" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要从另一个项目中的存储库中访问容器，那么您需要将对该存储库的读取权限授予用于提取图像的身份</p><h1 id="6511" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">运行图像</h1><p id="a253" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">一旦配置了访问，就可以使用以下命令在GKE集群上运行工件注册表映像:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="2c62" class="lh jr hi ld b fi li lj l lk ll">kubectl run [NAME] — image=LOCATION-docker.pkg.dev/PROJECT-ID/REPOSITORY/IMAGE:TAG</span></pre><p id="5742" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在哪里</p><ul class=""><li id="efcd" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">[名称]是您为对象指定的名称</li><li id="4b8c" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">位置是存储库的区域或多区域位置。</li><li id="5704" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">PROJECT-ID是您的Google云控制台项目ID。</li><li id="b504" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">存储库是存储图像的存储库的名称。</li><li id="b498" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">图像是存储库中图像的名称。</li><li id="d967" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">标记是您要提取的图像版本的标记。</li></ul><p id="0038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我的<code class="du ln lo lp ld b">helloworld.go</code>命令是这样的:</p><pre class="jf jg jh ji fd lc ld le lf aw lg bi"><span id="7125" class="lh jr hi ld b fi li lj l lk ll">kubectl run helloworld — image=us-central1-docker.pkg.dev/drayne/draynepipe/pipe-image:v1</span></pre><p id="022e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我存储在工件注册库中的图像被部署到GKE！</p><h1 id="c0e8" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">轮到你了！</h1><p id="2890" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">准备好开始从工件注册表部署到Google Kubernetes引擎了吗？查看Docker 的<a class="ae kt" href="https://cloud.google.com/artifact-registry/docs/docker/quickstart" rel="noopener ugc nofollow" target="_blank">工件注册表快速入门和关于与Google Kubernetes引擎</a>集成的<a class="ae kt" href="https://cloud.google.com/artifact-registry/docs/integrations#gke" rel="noopener ugc nofollow" target="_blank">工件注册表指南！对工件注册有疑问吗？欢迎在下面评论或发微博给我！</a></p></div></div>    
</body>
</html>