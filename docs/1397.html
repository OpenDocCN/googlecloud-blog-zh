<html>
<head>
<title>CatOps: Functions Framework, Cloud Tasks, and my cat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CatOps:功能框架、云任务和我的猫</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/catops-functions-framework-cloud-tasks-and-my-cat-7b32a0b71db6?source=collection_archive---------5-----------------------#2020-04-22">https://medium.com/google-cloud/catops-functions-framework-cloud-tasks-and-my-cat-7b32a0b71db6?source=collection_archive---------5-----------------------#2020-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/1d50190cc0063d813b0442829869fc67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*_rYLT5imx0wYPsjy.gif"/></div></figure><p id="8587" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我有一个相对简单的问题，我的猫，尼克，可以打开我们的前门，让自己出去。因为他是一只严格的室内猫，这是一个问题。在真正的计算机呆子时尚中，我过度设计了一个解决方案，在指定的延迟后自动锁门，以防止尼克逃跑。我的解决方案涉及到<a class="ae jk" href="https://github.com/GoogleCloudPlatform/functions-framework-ruby" rel="noopener ugc nofollow" target="_blank"> Ruby Functions Framework </a>，一个容器，<a class="ae jk" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> Google Cloud Run </a>，以及<a class="ae jk" href="https://cloud.google.com/tasks" rel="noopener ugc nofollow" target="_blank"> Google Cloud Tasks </a>。</p><p id="0810" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然这篇文章是关于CatOps的，但是这个解决方案更加通用。如果您想在聊天机器人延迟后调用webhook，发送电子邮件，或者提醒人们他们的购物车中有他们没有购买的商品，您可以做一些类似于这个CatOps项目的事情。</p><h1 id="dfbe" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">体系结构</h1><p id="9cf7" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">这个项目的硬件和触发器是智能家居应用和IFTTT的Rube Goldberg。但是最重要的是，我的门有一个简单的HTTP接口。它们在解锁时会发送一个HTTP请求，如果收到特定的HTTP请求，就会锁定。</p><p id="84e8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个项目有趣的部分是写一些代码，我可以在门解锁时调用，然后在10分钟后锁定它。听起来很简单，但是我遇到了很多挑战。</p><p id="a1e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我不想设置服务器或构建Rails或Sinatra应用程序。我知道这应该只有几行代码，感觉有点多余。我还想将函数作为服务使用，这被宣传为简单脚本的理想选择。谷歌的FaaS 解决方案不支持Ruby，但谷歌刚刚发布了Ruby Functions框架。该框架允许您在任何可以运行容器的地方构建和运行函数。对于在哪里运行我的容器，我有几个选择，但我对<a class="ae jk" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">云运行</a>很好奇，它保证设置起来很简单。</p><p id="91b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我遇到的第二个问题是开门和锁门之间的10分钟延迟。我第一次尝试使用<code class="du ko kp kq kr b">sleep(600)</code>，但是IFTTT和门的webhook接口在等待响应时都超时了。所以我被迫做一些更优雅的事情。</p><p id="3772" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://cloud.google.com/tasks" rel="noopener ugc nofollow" target="_blank">云任务</a>是解决超时问题的正确方案，原因有几个。首先，HTTP目标任务类型在任务执行时发送一个HTTP请求。我将HTTP目标设置为webhook URL，这使我不必自己编写代码来调用webhook。其次，Cloud Tasks允许您安排一个任务在特定的时间执行，所以我可以安排我的锁请求在门打开10分钟后运行。</p><h1 id="75e7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">代码</h1><p id="e9f0" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">Ruby Functions框架是一个gem，您可以使用Bundler和<code class="du ko kp kq kr b">Gemfile</code>以标准方式将它包含在您的项目中。</p><p id="5e06" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要编写一个函数，你要将你的代码作为一个块传递给<code class="du ko kp kq kr b">FunctionsFramework</code>类的<code class="du ko kp kq kr b">http</code>类方法。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="4380" class="la jm hi kr b fi lb lc l ld le">require "functions_framework"<br/><br/>FunctionsFramework.http("my_function_name") do |request|<br/><br/>  Do Stuff Here<br/><br/>end</span></pre><p id="1d60" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">云任务需要在服务器端进行一些设置，这在文档中有很好的解释<a class="ae jk" href="https://cloud.google.com/tasks/docs/creating-queues" rel="noopener ugc nofollow" target="_blank">，所以我在这里不再赘述。一旦初始设置完成，创建任务就很简单了。您创建一个具有适当键的散列，并调用<code class="du ko kp kq kr b">create_task</code>方法。</a></p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="67c8" class="la jm hi kr b fi lb lc l ld le">require "google/cloud/tasks"<br/><br/>tasks_client = Google::Cloud::Tasks.new<br/>PARENT = tasks_client.queue_path(PROJECT, COMPUTE_REGION, QUEUE_NAME)<br/><br/>task = {http_request: {http_method: "POST"}}<br/>task[:schedule_time] = {seconds: (Time.now() + 600).to_i}<br/>task[:http_request] = {url: URL_GOES_HERE}<br/><br/>response = tasks_client.create_task(PARENT, task)</span></pre><p id="7c82" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我需要做的最后一件事是添加一些配置。我需要知道是前门还是后门触发了该功能，这样我就知道延迟后该锁哪扇门。我设置了一个IFTTT触发器来发送一个名为“door”的参数，它可以是“front”也可以是“back”。因为请求对象是<code class="du ko kp kq kr b">Rack::Request</code>的一个实例，所以您可以像往常一样通过<code class="du ko kp kq kr b">params</code>方法访问参数。最后，出于灵活性和隐私的原因，我将锁门的URL提取到一个环境变量中。</p><p id="62da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是函数的主体。要查看设置，您可以查看GitHub上的文件。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="9c00" class="la jm hi kr b fi lb lc l ld le">FunctionsFramework.http("lock_door") do |request|<br/>  task = {http_request: {http_method: "POST"}}<br/><br/>  door = request.params["door"]<br/><br/>  if door == "back" then<br/>    task[:schedule_time] = {seconds: (Time.now() + DELAY_BACK).to_i}<br/>    task[:http_request] = {url: BACKDOOR}<br/>  elsif door == "front" then<br/>    task[:schedule_time] = {seconds: (Time.now() + DELAY_FRONT).to_i}<br/>    task[:http_request] = {url: FRONTDOOR}<br/>  end<br/><br/>  begin<br/>    response = tasks_client.create_task(PARENT, task)<br/>  rescue Exception =&gt; e<br/>    FunctionsFramework.logger.error "Exception creating task"<br/>  end<br/><br/>  FunctionsFramework.logger.info "Created task #{response.name}"<br/>  "Created task #{response.name}"<br/>end</span></pre><h1 id="d7f1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">测试</h1><p id="4184" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">功能框架gem附带了我能够使用的测试支持。因为我的代码也使用云任务，所以我需要为这些调用创建一个测试double，以防止我的测试命中我的生产任务队列。</p><p id="308e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是我为云任务客户端创建的测试替身。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="7a99" class="la jm hi kr b fi lb lc l ld le">Response = Struct.new(:name) { }<br/><br/>class TasksClientStub<br/>  attr_accessor :task_history, :project, :location, :queue<br/><br/>  def initialize<br/>    @task_history = Hash.new { |h, k| h[k] = [] }<br/>  end<br/><br/>  def create_task parent, task<br/>    @task_history[parent] &lt;&lt; task<br/><br/>    Response.new("/#{task_history.length}")<br/>  end<br/><br/>  def queue_path project, location, queue<br/>    @project = project<br/>    @location = location<br/>    @queue = queue<br/><br/>    "projects/#{project}/locations/#{location}/queues/#{queue}"<br/>  end<br/>end</span></pre><p id="08b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">double包含我在函数中调用的方法，<code class="du ko kp kq kr b">initialize</code>、<code class="du ko kp kq kr b">create_task</code>和<code class="du ko kp kq kr b">queue_path</code>。在内部，它将任务队列表示为数组的散列，因此我可以看到我的函数排队的任务，并验证它们是正确的。我还创建了一个名为response的结构作为<code class="du ko kp kq kr b">Rack::Response</code>的双测试，因为我不需要Rack中的所有方法和字段。</p><p id="33f9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了创建的替身，我就可以编写测试了。我的代码有单独的前门和后门分支，所以我为每个分支编写了一个测试。这是前门的测试。后门案例的测试是类似的。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="0dd3" class="la jm hi kr b fi lb lc l ld le">require "functions_framework/testing"<br/><br/>def test_function_creates_correct_task_for_front_door<br/>  task_stub = TasksClientStub.new<br/><br/>  Google::Cloud::Tasks.stub :new, task_stub do<br/><br/>    load_temporary "locker.rb" do<br/>      request = make_post_request "http://example.com:8080/", "door=front"<br/><br/>      response = nil<br/><br/>      _out, err = capture_subprocess_io do<br/>        response = call_http "lock_door", request<br/>      end<br/><br/>      assert_equal 200, response.status<br/><br/>      parent = task_stub.task_history.keys.first<br/>      assert_equal "projects/thagomizer-home-automation/locations/us-central1/queues/door-locker", parent<br/><br/>      task = task_stub.task_history[parent].first<br/><br/>      assert_match /front/, task[:http_request][:url]<br/>    end<br/>  end<br/>end</span></pre><p id="b25e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在第6行，我使用Minitest的stub方法让函数使用test double。然后在第8行，我加载了函数文件。在这个块中，我使用函数框架助手方法<code class="du ko kp kq kr b">make_post_request</code>来构建一个post请求，其中包含函数需要的参数<code class="du ko kp kq kr b">door=front</code>。要调用这个函数，您可以使用函数框架测试包中的<code class="du ko kp kq kr b">call_http</code>助手和<code class="du ko kp kq kr b">capture_subprocess_io</code>。最后，断言验证函数是否成功返回，验证队列/父队列是否设置正确，并最终确保为前门请求创建的任务对象是正确的。</p><h1 id="bf3e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">部署和结论</h1><p id="cf32" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">本系列的下一篇文章将解释如何对Google Cloud Run进行初始部署。它还将向您展示如何在Cloud Build上为任何Ruby应用程序设置基本的CI / CD。但是如果你非常想继续前进，你可以按照功能框架的<a class="ae jk" href="https://github.com/GoogleCloudPlatform/functions-framework-ruby" rel="noopener ugc nofollow" target="_blank">自述文件</a>进行初始手动部署。</p><p id="5172" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在结束这篇文章之前，我想说清楚这篇文章的整个前提是荒谬的。对于有问题的猫，一个更直接，也可能更便宜的解决办法是买一个他打不开的新门把手。但是，我对这种纯粹荒谬的情景感到高兴。我也在环境中学习了一些新技术。我通常发现，当我在解决一个我关心的问题时，我会比从教程中复制和粘贴代码学得更好。即使我的特定用例很荒谬，一个事件触发另一个事件倒计时的潜在场景也是我一次又一次遇到的。有很多严重的业务问题可以使用类似于我的CatOps项目的代码来解决。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="70ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="lm">原载于2020年4月22日https://www.thagomizer.com</em><em class="lm"/><a class="ae jk" href="https://www.thagomizer.com/blog/2020/04/22/catops-responding-to-external-events-with-cloud-functions-cloud-tasks.html" rel="noopener ugc nofollow" target="_blank"><em class="lm">。</em></a></p></div></div>    
</body>
</html>