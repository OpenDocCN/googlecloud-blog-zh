<html>
<head>
<title>Mount a file as a volume in Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云运行中将文件装载为卷</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/mount-a-file-as-a-volume-in-cloud-run-facc74c02cc6?source=collection_archive---------0-----------------------#2021-07-27">https://medium.com/google-cloud/mount-a-file-as-a-volume-in-cloud-run-facc74c02cc6?source=collection_archive---------0-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6643ab2d3dff9071bb8a858ab5637353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIN3gSkdZRenYLxvLEV4-A.png"/></div></div></figure><p id="742a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几年前，云运行<strong class="is hj">重新定义了无服务器模式</strong>。Cloud Run还<strong class="is hj">做出了承诺:在任何安装了</strong> <a class="ae jo" href="https://knative.dev/docs/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Knative </strong> </a>的Kubernetes集群<strong class="is hj">上的可移植性</strong>。<em class="jp">我</em> <a class="ae jo" rel="noopener" href="/google-cloud/knative-and-cloud-run-portability-in-action-1a655c914318"> <em class="jp">演示了一下这个便携性</em> </a> <em class="jp">哪个厉害！</em></p><p id="0c15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Knative和Cloud Run <strong class="is hj">实现了相同的API和相同的原则</strong>:你创建一个容器，你部署它，它会根据你的流量自动伸缩。</p><p id="2ac8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了确保和实现这种可伸缩性，Cloud Run和Knative在容器范例中有一个主要的约束</p><blockquote class="jq"><p id="4d70" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">容器必须是无状态的。您不能在容器上安装卷</p></blockquote><p id="969e" class="pw-post-body-paragraph iq ir hi is b it ka iv iw ix kb iz ja jb kc jd je jf kd jh ji jj ke jl jm jn hb bi translated">所以，今天(2021年7月):<strong class="is hj">不可能在云Run上挂载一个卷。</strong>但是……</p><h1 id="4f59" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">云运行中的秘密管理</h1><p id="72ca" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">云运行托管应用程序的服务，像大多数应用程序一样，它们<strong class="is hj">需要访问秘密</strong> : API密钥、数据库凭证、私有密钥……<br/>在Google Cloud上，管理秘密的推荐<strong class="is hj">工具是</strong> <a class="ae jo" href="https://cloud.google.com/secret-manager" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">秘密管理器</strong> </a> <strong class="is hj">。</strong></p><p id="6939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Cloud Run提出了一个<strong class="is hj">方便的</strong> <a class="ae jo" href="https://cloud.google.com/run/docs/configuring/secrets" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">与Secret Manager </strong> </a>的集成，并且因为Cloud Run希望在任何Kubernetes集群上尽可能的可移植，所以它<strong class="is hj">实现了类似的secret management </strong>特性。您可以加载一个秘密值:</p><ul class=""><li id="6172" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">要么转换成环境变量</li><li id="5718" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">或者将其作为卷安装。</li></ul><h1 id="a44a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">在云运行中将机密装载为卷</h1><p id="2775" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">这个特性很棒，并且符合Kubernetes最佳实践。要通过云运行实现这一点，您需要在Secret Manager中创建一个秘密:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="776c" class="mf kg hi mb b fi mg mh l mi mj"># Create a secret name<br/>gcloud secrets create medium</span><span id="4bdb" class="mf kg hi mb b fi mk mh l mi mj"># Create a secret version<br/>echo "my secret" | gcloud secrets versions add --data-file=- medium</span></pre><p id="4524" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，您可以部署您的Cloud Run服务，并将机密装载为一个卷:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="ca4e" class="mf kg hi mb b fi mg mh l mi mj">gcloud beta run deploy &lt;SERVICE_NAME&gt; --image &lt;IMAGE&gt; \<br/>  --update-secrets=/secrets/mysecret=medium:latest</span></pre><p id="3d88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，将它作为来自您的服务的任何文件来读取，例如在Golang中(file <code class="du ml mm mn mb b">server.go</code>):</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="7d11" class="mf kg hi mb b fi mg mh l mi mj">package main<br/><br/>import (<br/>   "fmt"<br/>   "io/ioutil"<br/>   "net/http"<br/>   "os"<br/>)</span><span id="1f52" class="mf kg hi mb b fi mk mh l mi mj">var fileLocation = "/secrets/mysecret"</span><span id="90d0" class="mf kg hi mb b fi mk mh l mi mj">func main() {<br/><br/>   http.HandleFunc("/", func (w http.ResponseWriter,<br/>                                  r *http.Request) {<br/>      f, err :=os.Open(fileLocation)<br/>      if err != nil {<br/>         w.WriteHeader(http.<em class="jp">StatusInternalServerError</em>)<br/>         fmt.Fprint(w,err)<br/>         return<br/>      }<br/>      b, err := ioutil.ReadAll(f)<br/>      if err != nil {<br/>         w.WriteHeader(http.<em class="jp">StatusInternalServerError</em>)<br/>         fmt.Fprint(w,err)<br/>         return<br/>      }<br/>      fmt.Println(string(b))<br/>      fmt.Fprint(w,string(b))<br/>      return<br/>   })<br/>   http.ListenAndServe(":8080", nil)<br/>}</span></pre><p id="f2db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打电话给你的服务，是的，你有<code class="du ml mm mn mb b">my secret</code>显示！您成功地<strong class="is hj">将一个秘密挂载为一个文件，并在您的代码中读取它</strong>！</p><blockquote class="jq"><p id="f62b" class="jr js hi bd jt ju jv jw jx jy jz jn dx translated">嘿，你把秘密当成文件读了！为什么不把秘密文件当文件读？</p></blockquote><h1 id="23c9" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc bi translated">在云运行中挂载(秘密)文件</h1><p id="c44e" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">类似地，作为一个秘密值，你可以从一个文件创建一个秘密！让我们加载一个文件作为秘密，就像这样:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="6a00" class="mf kg hi mb b fi mg mh l mi mj">gcloud secrets versions add --data-file=./server.go medium</span></pre><p id="2499" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再试试<strong class="is hj"> Boom，你已经在云运行中挂载了一个文件</strong>！！<br/> <em class="jp">因为我们在部署的时候定义了</em> <code class="du ml mm mn mb b"><em class="jp">medium</em></code> <em class="jp">秘密的</em> <code class="du ml mm mn mb b"><em class="jp">latest</em></code> <em class="jp">版本，所以你可以马上得到最新版本的秘密。如果愿意，您可以定义一个静态版本。</em></p><h1 id="f42a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用案例和限制</h1><p id="5f7f" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">在讨论用例之前，让我们<strong class="is hj">看一下限制</strong>:</p><ul class=""><li id="7698" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">您只能<strong class="is hj">读取文件内容</strong>，不能写入或更新它，除非您创建了一个新的秘密版本</li><li id="6ee1" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">您的秘密<a class="ae jo" href="https://cloud.google.com/secret-manager/quotas#content_limits" rel="noopener ugc nofollow" target="_blank">内容<strong class="is hj">限制为64kb</strong>T18】</a></li></ul><p id="8e36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这些限制，最好的用例是加载一个<strong class="is hj">配置文件作为卷</strong>。</p><ul class=""><li id="b0bd" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">应用程序不需要更新配置文件<strong class="is hj"/></li><li id="948e" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">配置文件<strong class="is hj">可以包含秘密</strong></li><li id="c4bf" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">配置文件<strong class="is hj">很小，符合64KiB的限制</strong></li></ul><p id="a3f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，在部署云运行服务时，您可以在不同的卷中加载几个(秘密)文件。</p><h1 id="d5b8" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">云运行和卷</h1><p id="da5c" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">Cloud Run还不支持卷，但是由于Secret Manager的集成和特定的用例，您可以模拟这种支持。我用它进行了春季启动部署，它真的很有帮助！</p><p id="6af8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于配置、秘密管理和防止在Git存储库中推送敏感数据来说,<strong class="is hj">非常棒。</strong></p></div></div>    
</body>
</html>