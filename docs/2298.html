<html>
<head>
<title>Analysing Git repository activities with BigQuery SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BigQuery SQL分析Git存储库活动</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/analysing-a-git-repository-activities-with-bigquery-sql-e40a6d85d667?source=collection_archive---------2-----------------------#2022-08-10">https://medium.com/google-cloud/analysing-a-git-repository-activities-with-bigquery-sql-e40a6d85d667?source=collection_archive---------2-----------------------#2022-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="46c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从git平台生成的报告很棒，但是如果我们需要更大的灵活性来创建git日志报告呢？在本文中，我们将探索如何将日志从git存储库导出到BigQuery中，并使用SQL应用一些分析查询。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ca"><img src="../Images/f2df5c912e1363df2b6a3bfa60bd2f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*To7q5y4jLryPnKXsL0J7yQ.png"/></div></div></figure><p id="27e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一个git存储库，它有多年的活动历史和成千上万的贡献。给定日志，人们最终需要对其进行深入查询，以了解一些历史、活动和贡献。在本文中，我们将遵循一种从头开始的方法，并尝试使用git和SQL所提供的功能。</p><p id="d3cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将以<a class="ae jo" href="https://github.com/GoogleCloudPlatform/professional-services" rel="noopener ugc nofollow" target="_blank">这个存储库为例</a>。有趣的是，它被用作一个单一的回购协议，由几个代表不同项目的文件夹组成。分析的一部分将与理解文件夹的活动并最终识别可能的所有者相关。</p><h1 id="d90a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">提取并加载Git日志</h1><p id="11db" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我们练习的第一部分，从从git日志中提取有用的信息开始。git log命令提供了一个有用的特性，叫做<a class="ae jo" href="https://git-scm.com/docs/pretty-formats#_pretty_formats" rel="noopener ugc nofollow" target="_blank">漂亮的格式</a>。它在显示什么作为提交元数据以及如何格式化它方面提供了很大的灵活性。这对于准备稍后解析和导入的日志数据非常有用。</p><p id="e134" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本地克隆的存储库上，您可以运行类似于下面的命令。</p><pre class="jd je jf jg fd ks kt ku kv aw kw bi"><span id="af46" class="kx jq hi kt b fi ky kz l la lb">git —-git-dir ../professional-services/.git log —-name-only --pretty=format:’commit: %H %nsubject: %s %nauthor: %aN %nemail: %aE %ndate: %at’</span></pre><p id="0fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这应该会返回类似于以下示例的输出。对于每次提交，代表散列、主题、作者姓名、作者电子邮件、日期和在该提交中修改的文件列表的行。</p><pre class="jd je jf jg fd ks kt ku kv aw kw bi"><span id="3970" class="kx jq hi kt b fi ky kz l la lb">commit: e551dd384acc13f6d9d186d678a8b158214c62e6<br/>subject: fix typo and add addition config step (#844)<br/>author: Someone<br/>email: <a class="ae jo" href="mailto:7sanai@gmail.com" rel="noopener ugc nofollow" target="_blank">someone@somewhere.com</a><br/>date: 1655821884<br/>tools/pubsub2inbox/examples/scc-finding-config.yaml</span><span id="ec89" class="kx jq hi kt b fi lc kz l la lb">commit: f96748b7b3b8f54b17e18e57c58934c57071f676<br/>subject: Disclaimer for java version and copyright updates (#841)<br/>author: abc-xyz<br/>email: <a class="ae jo" href="mailto:78390589+anuradha-bajpai-google@users.noreply.github.com" rel="noopener ugc nofollow" target="_blank">78390589+abc-xyz@users.noreply.github.com</a><br/>date: 1655797941<br/>tools/quota-monitoring-alerting/README.md<br/>tools/quota-monitoring-alerting/java/quota-notification/src/main/java/functions/SendNotification.java<br/>tools/quota-monitoring-alerting/java/quota-notification/src/main/java/functions/eventpojos/PubSubMessage.java<br/>tools/quota-monitoring-alerting/java/quota-notification/src/test/java/functions/SendNotificationTest.java<br/>tools/quota-monitoring-alerting/java/quota-scan/pom.xml<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/ListProjects.java<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/ScanProjectQuotas.java<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/ScanProjectQuotasHelper.java<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/eventpojos/GCPProject.java<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/eventpojos/GCPResourceClient.java<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/eventpojos/ProjectQuota.java<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/eventpojos/PubSubMessage.java<br/>tools/quota-monitoring-alerting/java/quota-scan/src/main/java/functions/eventpojos/TimeSeriesQuery.java<br/>tools/quota-monitoring-alerting/java/terraform/example.tfvars<br/>tools/quota-monitoring-alerting/java/terraform/main.tf<br/>tools/quota-monitoring-alerting/java/terraform/terraform.tfvars<br/>tools/quota-monitoring-alerting/java/terraform/variables.tf</span></pre><h2 id="bbcb" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">决定日志存储结构</h2><p id="e318" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">解析和转换逻辑将取决于我们希望用来存储数据的结构。该数据类似于“一对多”关系，每个提交都有其独特的细节，以及与该提交相关联的一组文件。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lq"><img src="../Images/2f0fe928c2050439ea49e11dcb2abbe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*fOutWKbW8p2qd6d0W4xbww.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">我们的日志数据类似于1:n的关系</figcaption></figure><p id="c519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上面的模型，一个人可能会在与多个提交相关联的文件上重复。在关系数据库的上下文中，我们甚至可以进一步规范化。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lv"><img src="../Images/b8465596a86322f3491b6dd65672bdbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTzWAtQUzw24MLlGzovTyw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">完全反规范化是一种选择，但不是BigQuery的最佳选择！</figcaption></figure><p id="4f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这个用例的实际情况是，我们主要是在一组日志上运行分析性读取查询，而不是应用事务性CRUD操作。</p><p id="8ea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们可以通过将我们的日志存储在一个完全非规范化的表中来使事情变得更加灵活和简单。这简化了解析、日志编写，并最终避免了BigQuery SQL中的额外连接。我要研究的结构应该是这样的:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lw"><img src="../Images/79100557bfd1cf09cce6cc0be2da6072.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*AlXcRagBcDEYequYHha_zw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">非标准化但对分析工作有效</figcaption></figure><p id="36f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BQ中非规范化表中存储的日志在每个文件的每次提交中都有一个<strong class="ih hj">行。我知道行与行之间有很多重复，但BigQuery的引擎针对以这种方式构建的数据进行了很好的优化，即表更少，列更窄，行更高。</strong></p><h2 id="41ab" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">提取并加载到BigQuery</h2><p id="a1f4" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在我们已经在BigQuery中定义了目标结构，我们可以继续编写一个快速脚本，将这些日志解析成一个结构，该结构可以通过BQ CLI命令轻松地加载到BigQuery表中。在这个例子中，我们将把git日志转换成表示为JSONL(行分隔的JSON)的行。</p><p id="905e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个快速的Python脚本。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="3f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过类似下面的方式运行脚本</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="15eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将生成一个<strong class="ih hj"> jsonl </strong>文件，准备加载到BigQuery中。结构看起来会像这样</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="94b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这一点来看，通过bq命令加载到BigQuery应该是微不足道的，例如</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lz"><img src="../Images/1a750cdc65bcfa4d0f4377434c46d217.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*iIb7CRrUzKPrAg9HMleOTg.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">生成的模式应该如下所示</figcaption></figure><p id="2fbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经将数据添加到了BigQuery表中，我们可以开始运行一些分析查询了。</p><h1 id="02d0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">查询数据</h1><h2 id="0fa4" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">从路径派生子项目类型和名称</h2><p id="d2b2" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在本文的前面，我提到了我们正在使用的存储库示例将遵循命名约定的文件夹和子文件夹视为独立的项目。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ma"><img src="../Images/1ab678ef3b20b320f226ccf5b90fed49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Neolw7wpfDgG8mb1eq0LuQ.png"/></div></div></figure><p id="f8ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在每个类别下，我们有一堆代表独立项目的文件夹。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/315cc3363764791699f647a89edf594b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mp-uF85M-f8TC509N73VJg.png"/></div></div></figure><h2 id="45e4" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">初始清理查询</h2><p id="6c8e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">假设我们有与每次提交相关联的每个文件的文件路径，我们可以应用<strong class="ih hj"> REGEXP_EXTRACT </strong>来导出项目名称和类型(基于父文件夹)。</p><p id="e085" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在repo中，有几个不相关的文件夹也包含在提取的日志中。我们可以从REGEXP_EXTRACT的结果中过滤出那些与我们要寻找的模式不匹配的空值。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">清理初始日志，提取文件夹</figcaption></figure><p id="df43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果应该类似于下面的截图。如果你打算经常使用这个结果作为基础，你可能想考虑把它定义为一个单独的<a class="ae jo" href="https://cloud.google.com/bigquery/docs/materialized-views-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">物化视图</strong> </a>。</p><p id="368c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了方便和说明，我将通过<strong class="ih hj">和</strong>在后续查询中重用这个查询，而不是一个物化视图。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mc"><img src="../Images/21e764ff704e8eccdab737034d6c7750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lozW2Z3wzUMkux20iTa2qw.png"/></div></div></figure><h2 id="72ab" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">每个子项目的上次更新</h2><p id="38c3" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果我们对识别每个子文件夹(也就是子项目)的最后作者日期感兴趣呢？这对于SQL来说应该很简单，通过<strong class="ih hj">和</strong>将查询建立在前一个查询的基础上。我们所要做的就是在类型和项目名称上应用一个<strong class="ih hj"> GROUP_BY </strong>，同时获得author_date的最大值。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">确定每个项目的最后作者日期</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es md"><img src="../Images/1e7b7c46fbbb517f30f073d580b600be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MC-KcNgSsMvEcK6lFZN6TA.png"/></div></div></figure><h2 id="44a3" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">每个子项目的作者</h2><p id="a843" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">另一个有用的查询是识别每个文件夹中的所有作者。</p><p id="807d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这与前面的查询略有不同。<strong class="ih hj"> ARRAY_AGG </strong>是一个很酷的聚合函数，允许我们通过<strong class="ih hj">ARRAY _ AGG(DISTINCT author _ email)</strong>为每个sub_repo生成一个所有作者的数组字段。在这里应用<strong class="ih hj"> DISTINCT </strong>很重要，因为在原始数据中，由于每次提交每个文件都有一行，所以我们有很多重复。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="9f48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在BigQuery UI上，这应该会给出类似于下图的结果(在截图中，作者的电子邮件被模糊处理以保护隐私)。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es me"><img src="../Images/9a80a4e3b090ad469978b69450d4ca04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxuHhus7fsNcCuvHeydwVg.png"/></div></div></figure><h2 id="99fd" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">每个子项目中每个作者的提交次数</h2><p id="a6c7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">以类似的方式，我们可以通过简单地对这两个值进行分组并对commit_hash值应用不同的<strong class="ih hj">COUNT</strong>来确定每个用户的每个子回购的提交数量。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="cb36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出如下所示</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mf"><img src="../Images/ac82f05dcb58d5fff1438cfe6366b5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nm9CWfld421ziiOIRACA8A.png"/></div></div></figure><h2 id="370d" class="kx jq hi bd jr ld le lf jv lg lh li jz iq lj lk kd iu ll lm kh iy ln lo kl lp bi translated">确定每个子项目的顶级作者</h2><p id="cce0" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在让我们考虑一下，在同一个报告中获得每个项目的顶级作者列表。我们可以在前一个查询的基础上编写一个新的查询，简单地将每个项目的作者提交聚合到一个漂亮的结构值数组中，并通过</p><pre class="jd je jf jg fd ks kt ku kv aw kw bi"><span id="de55" class="kx jq hi kt b fi ky kz l la lb">ARRAY_AGG(STRUCT(author_email,<br/>      commits_in_folder)<br/>  ORDER BY<br/>    commits_in_folder DESC) AS authors</span></pre><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="9ebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且应该返回每个子repo的struct数组，如下所示。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mg"><img src="../Images/da389e1d6d185d131ebb61f8b60bd5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrnnBELNyuTtRFOdIl5gbw.png"/></div></div></figure><h1 id="d850" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">包裹</h1><p id="a18f" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在，您已经有了一个快速的工具，可以简化和导出git日志，以便在BigQuery中进行分析。查询这些数据的可能性是无限的，可能还有我们没有涉及的重要(可解决的)角度，例如</p><ul class=""><li id="0afc" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">不断将新日志应用到BigQuery表中</li><li id="21a6" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">处理不再存在但包含在历史中的目录/文件夹</li><li id="5fae" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">在仪表板上绘制结果</li></ul><p id="d5bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些可能是另一篇后续文章中要解决的有趣主题。同时，希望听到您的反馈！</p></div></div>    
</body>
</html>