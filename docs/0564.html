<html>
<head>
<title>Cloudprober: gRPC Probes &amp; Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云探测器:gRPC探测器和Kubernetes</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloudprober-grpc-probes-kubernetes-b8c2708cb3ab?source=collection_archive---------0-----------------------#2018-04-08">https://medium.com/google-cloud/cloudprober-grpc-probes-kubernetes-b8c2708cb3ab?source=collection_archive---------0-----------------------#2018-04-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="58b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我为<a class="ae jd" href="https://cloudprober.org/" rel="noopener ugc nofollow" target="_blank">cloud proper</a>编写了一个简单的基于gRPC的扩展。Cloudprober创建了一个探针“代理”,它通过<a class="ae jd" href="https://grpc.io" rel="noopener ugc nofollow" target="_blank"> gRPC </a>与探针进行通信。</p><p id="f575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将Cloudprober部署到Kubernetes 的一个挑战是，Cloudprober会产生探测进程，并使用stdin/stdout与它们通信。在容器化Cloudprober时，这种紧密耦合带来了挑战。最简单的解决方案是将Cloudprober与一个探测器封装在一起，但这可能会受到限制。</p><p id="496e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在错误地尝试使用管道将容器化的cloud probe与容器化的probe连接起来之后，我意识到一个好的解决方案是使用gRPC并利用cloud probe已经定义的protobufs。</p><h2 id="06cd" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">设置</h2><p id="baf0" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">请跟随云探测器<a class="ae jd" href="https://cloudprober.org/getting-started/" rel="noopener ugc nofollow" target="_blank">入门</a>。在本文的后面，您可以将解决方案部署到Kubernetes。我假设您能够部署自己的集群。</p><h2 id="259c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">密码</h2><p id="6c36" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">让我们从probeserver.proto开始:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="3d95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cloudprober的<a class="ae jd" href="https://github.com/google/cloudprober/blob/master/probes/external/serverutils/serverutils.go" rel="noopener ugc nofollow" target="_blank"> serverutils </a>定义了一个<code class="du kl km kn ko b">Serve</code>函数，它接受<code class="du kl km kn ko b">ProbeRequest</code>并返回<code class="du kl km kn ko b">ProbeReplies</code>。这是Cloudprober与其产生的探针(本地)进行交互的机制。我们将修改该签名，以反映gRPC服务器接收<code class="du kl km kn ko b">ProbeRequest</code>消息并返回<code class="du kl km kn ko b">ProbeReply</code>消息。</p><blockquote class="kp kq kr"><p id="ec39" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>这个<code class="du kl km kn ko b">proto</code>导入了Cloudprober的<code class="du kl km kn ko b">serverutils</code>定义的<code class="du kl km kn ko b">proto</code>。您将需要在本地拥有Cloudprober源代码(或者至少是<code class="du kl km kn ko b">server.proto</code>)，并且应该可以在下面定义的<code class="du kl km kn ko b">proto_path</code>上访问它。此外，保留双目录的<code class="du kl km kn ko b">probeserver/probeserver/probeserver.proto</code> gRPC在这方面有点“挑战性”。</p></blockquote><p id="d5f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要生成Golang:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="d665" class="je jf hi ko b fi la lb l lc ld">protoc \<br/>--proto_path=${GOPATH}/src \<br/>-I=probeserver/ \<br/>probeserver/probeserver.proto \<br/>--go_out=plugins=grpc:probeserver</span></pre><p id="90c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了保持一致性，我建议您也创建<code class="du kl km kn ko b">probeserver/client</code>和<code class="du kl km kn ko b">probeserver/server</code>目录。</p><p id="6ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户<code class="du kl km kn ko b">main.go</code>来了:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><blockquote class="kp kq kr"><p id="da84" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">用你的GitHub帐号ID替换<code class="du kl km kn ko b">{YOUR_GITHUB_ACCOUNT}</code>。</p></blockquote><p id="6882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里包含了许多<code class="du kl km kn ko b">log.Print</code>语句。请随意清除这些。这段代码摘自gRPC的“Hello World”示例。如果有更好的实现方法，请告诉我。</p><p id="04a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码表示一个Cloudprober探针的通用代理，并使用gRPC与探针通信。它使用Protobuf生成的代码与服务器通信。<code class="du kl km kn ko b">PROBE_HOST</code>和<code class="du kl km kn ko b">PROBE_PORT</code>默认为<code class="du kl km kn ko b">localhost</code>和<code class="du kl km kn ko b">50051</code>。当我们将应用程序容器化并在Kubernetes上运行时，我们将使用这些。</p><p id="ccdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码获取Cloudprober提供的<code class="du kl km kn ko b">ProbeRequest</code>，并将其转发给远程gRPC服务器(也称为<code class="du kl km kn ko b">ProbeRequest</code>)。它从gRPC服务器获取<code class="du kl km kn ko b">ProbeReply</code>，从中创建一个新的<code class="du kl km kn ko b">ProbeReply</code>，并将新的<code class="du kl km kn ko b">ProbeReply</code>传递回Cloudprober。</p><p id="9aa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器<code class="du kl km kn ko b">main.go</code>在这里:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><blockquote class="kp kq kr"><p id="d9b1" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">用你的GitHub帐号ID替换<code class="du kl km kn ko b"><em class="hi">{YOUR_GITHUB_ACCOUNT}</em></code>。</p></blockquote><p id="9cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器代表一个名为<code class="du kl km kn ko b">probe</code>的探测器的具体实现。它使用Protobuf生成的代码与服务器通信。<code class="du kl km kn ko b">PROBE_PORT</code>默认为<code class="du kl km kn ko b">50051</code>。当我们将代码部署到Kubernetes时，我们将使用它。</p><p id="cdcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就好像我们在为Cloudprober开发一个常规的(服务器)探测器一样，服务器实现了一个<code class="du kl km kn ko b">probe</code>。该探头随机休眠一段时间，然后返回该延迟作为探头的测量值<code class="du kl km kn ko b">duration_ms</code>。</p><p id="6dff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与为Cloudprober开发常规探针不同，我们不使用<code class="du kl km kn ko b">serverutils.Serve</code>调用<code class="du kl km kn ko b">probe</code>，而是使用gRPC服务<code class="du kl km kn ko b">Probe</code>的<code class="du kl km kn ko b">Serve</code>方法。您可能还记得，<code class="du kl km kn ko b">Serve</code>接受一个<code class="du kl km kn ko b">ProbeRequest</code>调用我们的探测器(<code class="du kl km kn ko b">probe</code>)，并将结果作为<code class="du kl km kn ko b">ProbeReply</code>返回。</p><p id="0035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的。</p><h2 id="bacb" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">本地测试</h2><p id="fa0f" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">要运行客户端，我们需要一个cloudprober.local.cfg:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="542d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将该文件放在<code class="du kl km kn ko b">probeserver/client</code>目录中——假设您已经按照其网站上的说明安装并构建了Cloudprober您可以运行客户端:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="742a" class="je jf hi ko b fi la lb l lc ld">cloudprober --config_file=./cloudprober.local.cfg --logtostderr</span></pre><p id="06fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要从另一个终端会话运行探测器(服务器)，请切换到<code class="du kl km kn ko b">probeserver/server</code>目录并运行:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="d3dd" class="je jf hi ko b fi la lb l lc ld">go run main.go</span></pre><p id="70c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试<code class="du kl km kn ko b">PROBE_PORT</code>，给两个命令加上相同设置的前缀<strong class="ih hj">,例如</strong></p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="1e22" class="je jf hi ko b fi la lb l lc ld">PROBE_PORT=9999 go run main.go</span></pre><p id="4a21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将看到许多行输出，但是对于客户端来说，关键行的形式如下:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="7790" class="je jf hi ko b fi la lb l lc ld">cloudprober probe=grpc_probe,dst= success=1 total=31 latency=...<br/>cloudprober probe=grpc_probe,dst= duration_ms=541</span></pre><p id="91ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些反映了在<code class="du kl km kn ko b">cloudprober.local.cfg</code>文件中提供的探测器名称<code class="du kl km kn ko b">grpc_probe</code>，请求成功(<code class="du kl km kn ko b">success</code>，远程探测器的随机休眠(在本例中)为541毫秒。你们的价值观会不一样。</p><p id="53ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于服务器，您将看到匹配的输出:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="2266" class="je jf hi ko b fi la lb l lc ld">[Serve] request=request_id:31 time_limit:2500 ; reply=&lt;nil&gt;<br/>[Serve] Probe replies: duration_ms 541<br/>[Serve] request=request_id:31 time_limit:2500 ; reply=request_id:31 payload:"duration_ms 541"</span></pre><p id="229b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du kl km kn ko b">Cloudprober</code>运行时，它在<code class="du kl km kn ko b">9313</code>上暴露了一个普罗米修斯端点。你可以通过卷曲或浏览<code class="du kl km kn ko b">localhost:9313/metrics</code>来观察。在其他措施中(！)，您还应该看到“持续时间_毫秒”指标:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="d8aa" class="je jf hi ko b fi la lb l lc ld">#TYPE success counter<br/>success{ptype="external",probe="grpc_probe",dst=""} 31 1523142921115<br/>#TYPE total counter<br/>total{ptype="external",probe="grpc_probe",dst=""} 32 1523142921115<br/>#TYPE latency counter<br/>latency{ptype="external",probe="grpc_probe",dst=""} 2880611.175 1523142921115<br/>#TYPE duration_ms counter<br/>duration_ms{ptype="external",probe="grpc_probe",dst=""} 541 1523142921115</span></pre><h2 id="eb58" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">用集装箱装</h2><p id="e584" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">为了部署到Kubernetes，我们需要用gRPC代理和一个探测器来封装Cloudprober。对于后者，我们将使用上面的测试探针。</p><p id="b9f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建最佳Golang容器有多种方法。我喜欢Nick的<a class="ae jd" href="https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/" rel="noopener ugc nofollow" target="_blank">方法</a>，构建静态二进制和<code class="du kl km kn ko b">FROM scratch</code>。我也一直喜欢和使用<a class="ae jd" href="https://github.com/Yelp/dumb-init" rel="noopener ugc nofollow" target="_blank">哑初始化</a>。不要忘了如果你也沿着这条路去抓你机器的<code class="du kl km kn ko b">ca-certificates.crt</code>。</p><p id="0f8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是客户的档案:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><blockquote class="kp kq kr"><p id="a80a" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj">NB</strong>docker file引用了不同的<code class="du kl km kn ko b">cloudprober.docker.cfg</code>来补偿二进制的使用和路径的变化。这是文件:</p></blockquote><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="9692" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我假设你已经创建了名为<code class="du kl km kn ko b">gcr.io/${PROJECT}/cloudprober:grpc-client</code>和<code class="du kl km kn ko b">gcr.io/${PROJECT}/cloudprober:grpc-server</code>的容器。</p><p id="8a5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很抱歉把“_”和“-”换成了您的名字，但是对于Kubernetes命名，我们更喜欢用“-”来表示容器。</p><h2 id="ec98" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">容器测试</h2><blockquote class="kp kq kr"><p id="41de" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">测量两次，切割一次…</p></blockquote><p id="e67e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们重新测试一下，客户机和服务器都是容器化的。为了确保安全，让我们使用不同的端口:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="267f" class="je jf hi ko b fi la lb l lc ld">PROBE_PORT=7777</span></pre><p id="0d39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于客户:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="1a2c" class="je jf hi ko b fi la lb l lc ld">docker run \<br/>--interactive \<br/>--rm \<br/>--net=host \<br/>--env=PROBE_PORT=${PROBE_PORT} \<br/>gcr.io/${PROJECT}/cloudprober:grpc-client</span></pre><p id="659b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于服务器:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="1de3" class="je jf hi ko b fi la lb l lc ld">docker run \ <br/>--interactive \<br/>--tty \ <br/>--rm \<br/>--publish=${PROBE_PORT}:${PROBE_PORT} \<br/>--env=PROBE_PORT=${PROBE_PORT} \<br/>gcr.io/${PROJECT}/cloudprober:grpc-server</span></pre><p id="139d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切正常，您应该会看到与之前类似的结果。应该能行。因为客户端<code class="du kl km kn ko b">--net=host</code>您应该能够像以前一样为客户端卷曲Prometheus端点。</p><h2 id="c24e" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">[容器]注册表</h2><p id="6605" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我假设你的容器叫做<code class="du kl km kn ko b">cloudprober:grpc_client</code>和<code class="du kl km kn ko b">cloudprober:grpc_server</code>。如果您使用的是Kubernetes引擎，我建议您将这些推送到与您的集群在同一个项目中的T21容器寄存器。无论如何，将它们推送到您的群集可以访问它们的代表处。</p><h2 id="95e4" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">库伯内特，库伯内特，库伯内特</h2><p id="8152" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">该探测器可以作为侧车(与Cloudprober一起)部署，也可以作为服务独立运行。</p><p id="1613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们双管齐下:</p><p id="4cc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">边车</em></p><p id="5c56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个集装箱都在一个箱子里。为了简单起见，我们也将连接保留为默认的<code class="du kl km kn ko b">PROBE_PORT</code>。对于笑声，你可以想出如何在边车中使用不同的<code class="du kl km kn ko b">PROBE_PORT</code>。</p><p id="8064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将需要一个deployment.yaml，并且——我将避免我习惯性的懒惰——我们将部署到它自己的名称空间<code class="du kl km kn ko b">sidecar</code>。</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="59a8" class="je jf hi ko b fi la lb l lc ld">kubectl create namespace cloudprober-sidecar</span></pre><p id="0d46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个您需要替换的部署文件<code class="du kl km kn ko b">${PROJECT}:</code></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="6178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="dad3" class="je jf hi ko b fi la lb l lc ld">kubectl apply --filename=deployment.sidecar.yaml</span></pre><p id="7b55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你应该有一个<code class="du kl km kn ko b">deployment</code>，和一个<code class="du kl km kn ko b">pod</code>，有两个容器<code class="du kl km kn ko b">grpc-client</code>和<code class="du kl km kn ko b">grpc-server</code>。这是Kubernetes dashie:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/e6e7cd59266c2ac1a9352ea7e1fab60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcKOiFfcz7NaNVmOdXeDsA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">Kubernetes仪表板</figcaption></figure><p id="1024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和云控制台:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lp"><img src="../Images/7368cac514de67f72982eaf0fac22ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCbVRabt2jfQ-T6IEvDyqg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">云控制台</figcaption></figure><p id="f841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且，您可以检查日志:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="23bc" class="je jf hi ko b fi la lb l lc ld">SIDECAR_POD=$(\<br/>  kubectl get pods \<br/>  --namespace=cloudprober-sidecar \<br/>  --output=jsonpath="{.items[0].metadata.name}")</span><span id="2685" class="je jf hi ko b fi lq lb l lc ld">kubectl logs pods/${SIDECAR_POD} grpc-client \<br/>--namespace=cloudprober-sidecar</span><span id="04b6" class="je jf hi ko b fi lq lb l lc ld">kubectl logs pods/${SIDECAR_POD} grpc-server \<br/>--namespace=cloudprober-sidecar</span></pre><p id="17f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以查看普罗米修斯指标端点:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="dcc6" class="je jf hi ko b fi la lb l lc ld">NODE_HOST=$(\<br/>  kubectl get nodes \<br/>  --output=jsonpath="{.items[0].metadata.name}")</span><span id="0de2" class="je jf hi ko b fi lq lb l lc ld">SIDECAR_PORT=$(\<br/>  kubectl get services/sidecar \<br/>  --namespace=cloudprober-sidecar \<br/>  --output=jsonpath="{.spec.ports[0].nodePort}")</span><span id="b0e7" class="je jf hi ko b fi lq lb l lc ld">gcloud compute ssh ${NODE_HOST} \<br/>--project=${PROJECT} \<br/>--ssh-flag="-L ${SIDECAR_PORT}:localhost:${SIDECAR_PORT}"</span></pre><blockquote class="kp kq kr"><p id="c4f3" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">你可能注意到了，事实上，我在边车里使用了不同的<code class="du kl km kn ko b">PROBE_PORT</code>;-)</p></blockquote><p id="9139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<code class="du kl km kn ko b">localhost:${SIDECAR_PORT}/metrics</code>上找到指标端点。</p><p id="76fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">服务</em></p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="e3c2" class="je jf hi ko b fi la lb l lc ld">kubectl create namespace cloudprober-service</span></pre><p id="dc65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个部署文件，你需要替换<code class="du kl km kn ko b">${PROJECT}:</code></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="53f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署使用:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="7ca8" class="je jf hi ko b fi la lb l lc ld">kubectl apply --filename=deployment.service.yaml</span></pre><p id="815f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个比较复杂。分别展开<code class="du kl km kn ko b">grpc-client</code>和<code class="du kl km kn ko b">grpc-server</code>。每个都有相关联的服务。<code class="du kl km kn ko b">grpc-client</code>通过Kubernetes DNS名称<code class="du kl km kn ko b">grpc-server.cloudprober-service.svc.default.cluster.local</code>访问<code class="du kl km kn ko b">grpc-server</code>。我们再次将gRPC绑定到端口<code class="du kl km kn ko b">8888</code>，而不是它的默认端口。</p><p id="0dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是Kubernetes dashie:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lr"><img src="../Images/515fa1670e45ccfd0d2b535f8439b0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dgTc_8iNMa_U-H6A5q4Zw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">Kubernetes仪表板</figcaption></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ls"><img src="../Images/61a7deedf1ef2f80eec316ed61e965ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dQKPZAmpOOwoM6hXmGQHw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">云控制台</figcaption></figure><p id="9275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次让我们使用云日志记录:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ls"><img src="../Images/defee7918d64ccb56ba289ad7cb0aebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P16mvf2PZl1vBEJ2nRAGDA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">谷歌云控制台:日志记录</figcaption></figure><p id="9874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，您将看到一个技巧，即使用云控制台起草一个过滤器，然后可以在命令行中使用:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="8c6e" class="je jf hi ko b fi la lb l lc ld">FILTER="resource.type=\"container\" "\<br/>"resource.labels.cluster_name=\"${CLUSTER}\" "\<br/>"resource.labels.namespace_id=\"cloudprober-service\" "\<br/>"logName=\"projects/${PROJECT}/logs/grpc-client\" "\<br/>"textPayload:\"labels=ptype=external,probe=grpc_client,dst=\""</span><span id="d7c2" class="je jf hi ko b fi lq lb l lc ld">gcloud logging read "${FILTER}" \<br/>--project=$PROJECT \<br/>--format=json \<br/>| jq .[].textPayload</span></pre><p id="fbab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上面的<code class="du kl km kn ko b">NODE_HOST</code>和<code class="du kl km kn ko b">SIDECAR_PORT</code>，您可以使用以下命令添加<code class="du kl km kn ko b">SERVICE_PORT</code>:</p><pre class="ke kf kg kh fd kw ko kx ky aw kz bi"><span id="3f98" class="je jf hi ko b fi la lb l lc ld">SERVICE_PORT=$(\<br/>  kubectl get services/grpc-client \<br/>  --namespace=cloudprober-service \<br/>  --output=jsonpath="{.spec.ports[0].nodePort}")</span><span id="613a" class="je jf hi ko b fi lq lb l lc ld">gcloud compute ssh ${NODE_HOST} \<br/>--project=${PROJECT} \<br/>--ssh-flag="-L ${SIDECAR_PORT}:localhost:${SIDECAR_PORT}" \<br/>--ssh-flag="-L ${SERVICE_PORT}:localhost:${SERVICE_PORT}"</span></pre><p id="8158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并通过<code class="du kl km kn ko b">localhost:${SERVICE_PORT}</code>访问该服务的度量端点。</p><h2 id="311a" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">结论</h2><p id="f9fc" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">Cloudprober很整洁。事实上——虽然我希望它有用——我不清楚这些对其他人是否有用。如果有用的话，我认为正确的下一步应该是将代理代码放入Cloudprober本身，这样另一个<code class="du kl km kn ko b">external_probe</code> <code class="du kl km kn ko b">mode</code>可能就是<code class="du kl km kn ko b">PROXY</code>，并且包含一些类似于这里概述的gRPC客户端代码。</p><p id="f25d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反馈和建议<strong class="ih hj">永远</strong>欢迎。</p><p id="527c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p></div></div>    
</body>
</html>