<html>
<head>
<title>GKE startup time &amp; the container problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GKE启动时间&amp;集装箱问题</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/gke-startup-time-the-container-problem-d9166b03c3c0?source=collection_archive---------0-----------------------#2017-06-09">https://medium.com/google-cloud/gke-startup-time-the-container-problem-d9166b03c3c0?source=collection_archive---------0-----------------------#2017-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d9dc4b6b7d36750855f51f34b01f8003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8gFMHNLtQJj-DnrepTSjw.jpeg"/></div></div></figure><div class=""/><p id="972d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上一次，<a class="ae jo" rel="noopener" href="/@duhroach/profiling-gke-startup-time-9052d81e0052">我介绍了剖析&amp;获得可见性</a>的各种方法，以了解给定pod的Google容器引擎(GKE)启动时间。考虑到Kubernetes在启动阶段的复杂性，这是非常有用的，它有时会在奇怪的地方隐藏性能问题。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jp"><img src="../Images/b0f1475d6a699ea9c468addc394cc102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvQapLJgyvj_Fq_zReS6IQ.png"/></div></div></figure><p id="60b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不经意间，这就是<em class="ju">培根住的地方！</em>遇到了一个问题:即使有了kubernetes的强大功能，它们的容器仍然需要下载一些数据，结果是它们的初始化舞蹈导致了胃灼热。(懂了吗？因为这是一个食品应用？…)</p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="jv jw l"/></div></figure><h1 id="1b8a" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">取决于容器</h1><p id="e0ff" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">培根，活下去！我已经将他们的代码从GCE移植到GKE，因此，他们所有的容器都在pod启动过程的并行阶段初始化(FWIW:他们<em class="ju">确实有一个单独的init容器，它正在做一些"<em class="ju">对不起，我不能告诉你那个</em>工作，大约需要2-3秒，但是我马上就要谈到它..) .应用上一篇文章中的分析过程，我们最终获得了容器的如下计时:</em></p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es la"><img src="../Images/2bea7c4d69a6bcad0909bfc459f84c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*acxtXWMRdvIUqZDmpsgHHQ.png"/></div></figure><p id="2cd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中三个容器花费了大量的时间来启动，最重要的是公共/管理端点，它们在健康检查阶段直接使用。</p><p id="2499" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在查看公共端点时，我看到了看起来是罪魁祸首的东西:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lb"><img src="../Images/2f12895071f60d5e1472e1db1e09a206.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*-T7m2DMfH4cYlF9jZHwIyA.png"/></div></div></figure><p id="034c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">公共端点的初始化代码快速调用Stats容器，以确保它在继续之前启动并运行。啊，现在我们看到问题了。</p><p id="7b09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那个urlfetch命令是一个<strong class="is hu">阻塞</strong>调用。因为并行容器是随机初始化的，所以端点首先被初始化，但是由于它们对stats容器的依赖而被阻塞。显然不理想..</p><h1 id="a5e7" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">让我们使用初始化容器！</h1><p id="c85d" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">因为看起来我们依赖于stats容器，所以将该容器移动到<em class="ju"> init </em>阶段是有意义的，这样并行容器就不必陷入这种奇怪的竞争状态，并且可以正确执行。我们可以看到系统是如何反应的；基本上，init阶段现在延长了2-4秒，这导致整个系统启动总体上变得更糟:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lc"><img src="../Images/a038dbb54bdf5671502ef1a532d73489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*siAoZu2EOj8MCLaHspQGsg.png"/></div></figure><p id="8696" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(记住，他们现有的“<em class="ju">不能告诉你关于那个</em>”init容器已经做了大约2-2.5秒的工作，所以我们看到这个过程加倍了)</p><h1 id="e9e5" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">别管初始化容器了！</h1><p id="88f3" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">这明显是<em class="ju">方向错了</em>；这使得整个冷启动时间变慢。</p><p id="5efe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，<em class="ju">培根，活了！</em>决定返回，对他们的代码做一些小的修改:stats模块在那里帮助执行启动相关任务的计时，但是由于他们现在可以看到代码之外的那些东西<em class="ju">(感谢我们设置的剖析工具)，他们很乐意消除对端点的依赖。</em></p><p id="ba33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果是，我们最终在地面上丢弃了一些信号，但是对于我的新启动测试代码来说，保留这些信息并不重要。一旦进行了这一更改，stats容器就可以在并行阶段移回，从而提高整个系统的性能:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lc"><img src="../Images/9cbbdc4ef2e83876321e900c2a0840ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*xYUIQ3L0Qily34aLGxyeBQ.png"/></div></figure><h1 id="aded" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">发现和收获</h1><p id="6340" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">我从这里学到了一些东西:</p><p id="147f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">在容器中计时启动时间有点复杂<em class="ju">，</em> </strong>但是很重要。</p><p id="e658" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了真正以一种合理的方式获得这些信息，你需要以非常特殊的方式修改每个单独的容器，这需要了解它所运行的容器。我确信这是一件好事，这是有开发和运营方面的原因的，但是我还没有看到这一点。</p><p id="d801" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">初始化容器是关键路径。</strong>由于容器以线性顺序初始化，执行一个容器所花费的时间会延迟其他容器的启动时间。单个不良因素会给启动时间带来巨大负担。因此，您应该考虑在容器的初始化阶段和之后的并行阶段执行多少工作。(注意，如果你感兴趣的话，凯尔西·海托华<a class="ae jo" rel="noopener" href="/@kelseyhightower/12-fractured-apps-1080c73d481c#.rp57cshi7">有一篇关于驾驭这种复杂性的文章</a></p><p id="3621" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">避免并行初始化依赖。</strong>这些容器是随机创建的。避免它们之间的线性依赖。让容器A需要容器B可能会出现问题，如果A在B之前初始化，那么A会等待一段随机的时间。如果可能的话，考虑将这些依赖项转移到init阶段，或者完全移除这些依赖项。</p></div></div>    
</body>
</html>