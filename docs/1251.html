<html>
<head>
<title>Distributed Tracing with OpenTelemetry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开放式遥测分布式跟踪</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/distributed-tracing-with-opentelemetry-c0215ef38203?source=collection_archive---------1-----------------------#2020-01-09">https://medium.com/google-cloud/distributed-tracing-with-opentelemetry-c0215ef38203?source=collection_archive---------1-----------------------#2020-01-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="066b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">去年年底，我有幸出版了关于使用OpenCensus进行分布式追踪的参考指南。在这篇文章中，我介绍了分布式跟踪的基础知识，比如跟踪、跨度和上下文传播，并演示了如何使用OpenCensus来检测一对用Go编写的简单的前端/后端服务。从那以后，OpenCensus和OpenTracing项目合并成了<a class="ae jd" href="https://opentelemetry.io" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>，这是一套“API、库、代理和收集器服务，用于从您的应用程序中捕获分布式跟踪和指标。”我想尝试用新项目重现我在OpenCensus中的工作，看看有多少变化。</p><h1 id="a6c9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">目标</h1><p id="4941" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对于这个练习，我构建了一个简单的<a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/opentelemetry-tracing-demo" rel="noopener ugc nofollow" target="_blank">演示</a>。它由两个服务组成。前端服务接收传入的请求，并向后端发出请求。后端接收请求并返回响应。我们的目标是跟踪这种交互，以确定总体响应延迟，并理解这两种服务以及它们之间的网络连接如何影响总体延迟。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/9197bc5b11e69477855ce5d9fd28ebdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*as-fF_4igPIFQApS.png"/></div></div></figure><p id="a2ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最初的指南中，这两个服务被部署在两个独立的GKE集群中，但是这实际上对于演示分布式跟踪是不必要的。在本练习中，我们将简单地在本地运行这两个服务。</p><p id="d318" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然基本概念在参考指南中有所涉及，并且在Google Dapper research <a class="ae jd" href="https://research.google.com/archive/papers/dapper-2010-1.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>中有更详细的内容，但是仍然有必要在这里简要介绍一下，这样我们就可以理解它们是如何在代码中实现的。</p><p id="753a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自参考指南:</p><blockquote class="kt ku kv"><p id="ac03" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated">一条跟踪<em class="hi">是描述分布式系统如何响应用户请求的全部信息。跟踪由</em>跨度<em class="hi">组成，其中每个跨度代表服务用户请求所涉及的特定请求和响应对。</em>父<em class="hi">跨度描述终端用户观察到的延迟。每个</em>子<em class="hi">跨度描述了分布式系统中的特定服务是如何被调用和响应的，以及为每个服务捕获的延迟信息。</em></p></blockquote><p id="5d68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在前面提到的研究论文中用这个图表很好地说明了:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es la"><img src="../Images/b13975609ac12aee70a0cabb73707266.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*CJdN9YG1o5BXsNuq.png"/></div></figure><p id="7843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看如何使用OpenTelemetry在前端/后端服务对中实现分布式跟踪。</p><blockquote class="kt ku kv"><p id="6aaa" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">注意</em> </strong> <em class="hi">这大部分是从OpenTelemetry发布的</em><a class="ae jd" href="https://github.com/open-telemetry/opentelemetry-go/tree/master/example" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a><em class="hi">样本中选取的【Github】</em><a class="ae jd" href="https://github.com/open-telemetry/opentelemetry-go" rel="noopener ugc nofollow" target="_blank"><em class="hi"/></a><em class="hi">【回购】。我做了相对较小的改动，添加了定制的spans并使用了Mux路由器，而不仅仅是基本的HTTP处理。</em></p></blockquote><h1 id="9cc6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">前端代码</h1><p id="ea32" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们先来回顾一下前端<a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/blob/master/opentelemetry-tracing-demo/go/frontend/frontend.go" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><h1 id="1a0e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">进口</h1><p id="46da" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，进口:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="3289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，我们主要使用各种各样的OpenTelemetry库。我们还将使用<a class="ae jd" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Mux </a>路由器来处理HTTP请求(我主要使用它，因为它似乎类似于Node.js中的Express)。</p><h1 id="4229" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">主要功能</h1><p id="c5a5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">接下来，让我们看看我们服务的<code class="du ld le lf lg b">main()</code>函数:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="2312" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，这是一条直路。我们从一开始就初始化跟踪，并使用Mux路由器来处理对<code class="du ld le lf lg b">/</code>的请求的单个路由。然后，我们在端口8080上启动服务器。我添加了一个环境变量来检查我是否在本地运行代码，以绕过MacOS提示，按照这些<a class="ae jd" rel="noopener" href="/@leeprovoost/suppressing-accept-incoming-network-connections-warnings-on-osx-7665b33927ca">指令</a>允许入站网络连接。</p><h1 id="6e91" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">初始化跟踪</h1><p id="e8e9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">接下来，我们来看看<code class="du ld le lf lg b">initTracer()</code>功能:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="9f44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们只是实例化Stackdriver导出器，并设置采样参数来捕获每个跟踪。</p><h1 id="65b8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">处理请求</h1><p id="f01e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最后，让我们看看被调用来处理对<code class="du ld le lf lg b">/</code>的请求的<code class="du ld le lf lg b">mainHandler()</code>函数。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="87ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们将跟踪器的名称设置为“OT-tracing-demo ”,并启动一个标记为“incoming call”的根span。然后，我们创建一个标记为“后端调用”的子跨度，并将上下文传递给它。然后，我们向后端服务器创建一个请求，其位置在一个env变量中定义，并将我们的上下文注入到该请求中——稍后我们将看到如何在后端使用该上下文。最后，我们发出请求，获取状态代码，并输出确认消息。相当简单！</p><p id="b7f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几件事需要进一步注意:</p><ul class=""><li id="755e" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">我显式地关闭子跨度，而不是使用<code class="du ld le lf lg b">defer</code>来控制计时器停止的确切时间。</li><li id="fe84" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">我将事件添加到跨度中，以获得更清晰的标签。</li></ul><p id="a756" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看我们的<a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/blob/master/opentelemetry-tracing-demo/go/backend/backend.go" rel="noopener ugc nofollow" target="_blank">后端</a>。</p><h1 id="cbb2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">后端代码</h1><p id="324b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这里的大部分代码与前端非常相似——我们使用完全相同的<code class="du ld le lf lg b">main()</code>和<code class="du ld le lf lg b">initTracer()</code>函数来运行服务器和初始化跟踪。</p><h1 id="a098" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">主处理器</h1><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="784e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ld le lf lg b">mainHandler()</code>函数看起来确实很不一样。这里，我们从传入的请求中提取span上下文，使用该上下文创建一个新的请求对象，并使用该请求上下文创建一个新的span。我们还将一个事件添加到我们的span中进行显式标记。最后，我们向调用者返回“OK”并关闭我们的span。同样，我可以使用<code class="du ld le lf lg b">defer span.End()</code>而不是显式地这样做。</p><blockquote class="kt ku kv"><p id="e445" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">注意</em></strong><em class="hi">span上下文和request上下文的区别。当接受传入的上下文并使用它来创建子跨度时，这一点尤其重要。关于这两个的进一步探索，可以看看来自OpenTracing的相关</em> <a class="ae jd" href="https://opentracing.io/docs/best-practices/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">文档</em> </a> <em class="hi">。</em></p></blockquote><p id="661d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经看到了如何在我们的代码中实现跟踪工具，让我们看看这个工具产生了什么。在为前端和后端设置了相关的环境变量并使用<code class="du ld le lf lg b">gcloud auth login</code>登录Google Cloud后，我们可以在本地运行前端和后端。一旦我们这样做了，我们就可以点击前端的http://localhost:8080 并发出一些请求。这应该会立即导致跟踪被写入Stackdriver:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lv"><img src="../Images/2bd2f27126a29cd6cfd35cfc3fcea955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xrfWskTjgndyMSOV.png"/></div></div></figure><p id="ee48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到我们在代码中指定的span名称，以及我们为了更清楚地标记而添加的事件。另一件让我惊喜的事情是，OpenTelemetry明确地添加了HTTP/networking栈的步骤，包括DNS、连接、发送和接收数据。</p><p id="dbb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我非常喜欢尝试用OpenTelemetry重现我在OpenCensus中所做的工作，并最终发现它可以理解和清晰，尤其是当我被指向tracer时。Start()方法来创建子跨度。下次当我尝试使用OpenTelemetry的stats特性来创建自定义指标时，请回来。直到那时！</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="149f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【http://github.com】原载于<a class="ae jd" href="https://gist.github.com/39d92d18d1369cf2cc87b5ee5602d7c7" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw">。</em></p></div></div>    
</body>
</html>