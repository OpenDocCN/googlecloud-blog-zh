<html>
<head>
<title>Cloud Tasks is a little stateful</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云任务有点有状态</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-tasks-is-a-little-stateful-7ef39aad7d00?source=collection_archive---------0-----------------------#2019-11-25">https://medium.com/google-cloud/cloud-tasks-is-a-little-stateful-7ef39aad7d00?source=collection_archive---------0-----------------------#2019-11-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/48eb9c9a84ea4ef3c53d5f75fe90fe9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0QC_M4YlQ9rNzz5D03QAw.png"/></div></div></figure><div class=""/><p id="cd98" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像<a class="ae jo" href="https://cloud.run" rel="noopener ugc nofollow" target="_blank"> Cloud Run </a>这样的无服务器产品旨在托管无状态服务，允许惊人的水平扩展。像<a class="ae jo" href="https://cloud.google.com/firestore/docs" rel="noopener ugc nofollow" target="_blank"> Firestore </a>和<a class="ae jo" href="https://cloud.google.com/storage/docs" rel="noopener ugc nofollow" target="_blank">云存储</a>这样的外部服务经常被用来将“状态”带回到画面中。在这篇文章中，我将探索云任务如何为您的应用程序架构带来一些有状态的东西，这些用例中有一个排队系统可以提供帮助。</p><p id="6f23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我使用了新增加的<a class="ae jo" href="https://cloud.google.com/tasks/docs/creating-http-target-tasks" rel="noopener ugc nofollow" target="_blank">云任务HTTP Targets </a>，它允许你创建的每一个任务被配置为交付给一个web服务。对于云任务的更一般的介绍，去阅读<a class="ae jo" rel="noopener" href="/google-cloud/asynchronous-code-execution-with-google-cloud-tasks-9b73ceaf48c3">与谷歌云任务的异步代码执行</a>，然后回来。</p><h2 id="d7dc" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">对队列应用“有状态”吗？</h2><p id="d2d5" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">排队系统的前提是信息进去了，工作完成后最终消失。在详细解释这在云任务中的应用之前，我们先来讨论一下定义:</p><p id="8a20" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">来自</strong> <a class="ae jo" href="https://en.wikipedia.org/wiki/State_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">维基百科</strong> </a> <strong class="is hu">和</strong><a class="ae jo" href="https://whatis.techtarget.com/definition/stateless" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">TechTarget</strong></a><strong class="is hu">:</strong></p><blockquote class="kp kq kr"><p id="3401" class="iq ir ks is b it iu iv iw ix iy iz ja kt jc jd je ku jg jh ji kv jk jl jm jn hb bi translated">如果一个系统被设计成能记住之前的事件或用户交互，那么它就被描述为有状态的；记忆的信息称为系统的<strong class="is hu">状态</strong>。</p></blockquote><p id="6058" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然云任务不会无限期地记住之前的事件，但在这些事件被系统的无状态组件(如云功能或云运行服务)丢弃后，它会记住这些事件中的数据。让我们探索云任务如何使用这些被遗忘的信息。</p><h2 id="4f71" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">云任务支持特定于任务的属性</h2><p id="d75d" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在云任务中，您创建一个<strong class="is hu">任务</strong>，它代表稍后要按照特定<strong class="is hu">队列</strong>的配置确定的速度完成的一点工作。每个任务可以携带唯一的属性，将当前请求的详细信息传播到队列中。这允许您跳过在数据库中存储这个工作项的数据。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kw"><img src="../Images/9d78301c655066490c9672353321443c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfVN8hPDeznoR7bMTsPTXA.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">唯一请求属性在云运行流程的生命周期之外传递，并传播到App Engine中的云任务处理程序。在https://bramp.github.io/js-sequence-diagrams/<a class="ae jo" href="https://bramp.github.io/js-sequence-diagrams/" rel="noopener ugc nofollow" target="_blank">上创建的图表</a></figcaption></figure><p id="94d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您创建一个任务时，您正在定义一个HTTPS请求，该请求将被分派给一个处理该请求的<strong class="is hu">处理器</strong>。该处理程序可以从HTTP请求中提取任何内容，并使用它在其他系统中查找数据。</p><p id="3270" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至少，每个HTTP目标任务都需要一个URL来分派任务。当然，URL可以包含任意路径和查询字符串组件，作为一种传送某些数据的机制。除此之外，可以覆盖HTTP方法和主体，并在请求中添加任意的HTTP头。这里有一个使用<strong class="is hu"> gcloud </strong>创建一个任务的例子，这个任务带有一个定制的查询字符串“搜索参数”和一个稍微微妙的头来携带一个用户ID。</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="83ed" class="jp jq ht lg b fi lk ll l lm ln">gcloud tasks create-http-task --queue my-queue \<br/>  --url "<a class="ae jo" href="https://search.example123-uc.a.run.app/?object=piano&amp;color=red" rel="noopener ugc nofollow" target="_blank">https://search.example123-uc.a.run.app?s=piano&amp;color=red</a>" \<br/>  --header "Request-User-Id: user123"<br/>Created task [projects/my-project/locations/us-central1/queues/my-queue/tasks/1234567890].</span></pre><p id="3f53" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不是将请求对象存储到数据库中，而是将该请求的关键细节存储在任务中。另一方面，<code class="du lo lp lq lg b">user123</code>的关键账户详细信息是保密的，并根据需要通过ID进行查找。</p><h2 id="b5cc" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">云任务让您可以检查任务状态</h2><p id="f81c" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">一旦创建了任务，分派将取决于如何配置<a class="ae jo" href="https://cloud.google.com/tasks/docs/creating-queues#rate" rel="noopener ugc nofollow" target="_blank">队列</a>，URL另一端的处理程序的性能，以及通常处理的成功程度。在任务完成之前，您可以检查它的细节以确认它具有您期望的HTTP属性，并检查交付情况。</p><p id="89a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用<code class="du lo lp lq lg b">gcloud</code>或API检查任务的交付细节。gcloud有一个方便的命令，它利用云任务API来获取任务对象:</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="70bd" class="jp jq ht lg b fi lk ll l lm ln">gcloud tasks describe projects/my-project/locations/us-central1/queues/my-queue/tasks/1234567890</span><span id="3fd9" class="jp jq ht lg b fi lr ll l lm ln">createTime: '2019–09–16T19:01:09Z'<br/>dispatchCount: 9<br/>dispatchDeadline: 600s<br/>firstAttempt:<br/> dispatchTime: '2019–09–16T19:01:09.525182Z'<br/>lastAttempt:<br/> dispatchTime: '2019–09–16T19:01:37.984184Z'<br/> responseStatus:<br/> code: 9<br/> message: 'FAILED_PRECONDITION(9): HTTP status code 405'<br/> responseTime: '2019–09–16T19:01:38.007307Z'<br/> scheduleTime: '2019–09–16T19:01:37.982882Z'<br/>name: projects/my-project/locations/us-central1/queues/my-queue/tasks/1234567890<br/>scheduleTime: '2019–09–16T19:02:03.607307Z'<br/>view: BASIC</span></pre><p id="84ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这些详细信息中，我们看到云任务已经尝试交付9次，并获得HTTP状态代码405。它将继续尝试(取决于您的配置，最多30天)，直到它获得2xx响应代码。</p><p id="5a58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，看起来任务处理程序并不期望云任务默认使用<code class="du lo lp lq lg b">HTTP POST</code>请求。没有任务更新选项，所以选项是更改处理程序服务以支持POST或删除并重新创建任务。</p><p id="c94b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们尝试使用<code class="du lo lp lq lg b">GET</code>方法重新创建任务:</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="9b9f" class="jp jq ht lg b fi lk ll l lm ln">gcloud tasks delete <!-- -->projects/my-project/locations/us-central1/queues/my-queue/tasks/1234567890<br/>Deleted task [<!-- -->1234567890<!-- -->]</span><span id="244b" class="jp jq ht lg b fi lr ll l lm ln">gcloud tasks create-http-task --queue my-queue \<br/>  --url "<a class="ae jo" href="https://search.example123-uc.a.run.app/?object=piano&amp;color=red" rel="noopener ugc nofollow" target="_blank">https://search.example123-uc.a.run.app?s=piano&amp;color=red</a>" \<br/>  --header "Request-User-Id: user123" \<br/>  --method GET<br/>Created task [projects/my-project/locations/us-central1/queues/my-queue/tasks/2468101214161820].</span></pre><p id="8c26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再次尝试相同的describe命令，我们看到该任务不再存在，并且来自API的错误显示它已经不存在:</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="96f1" class="jp jq ht lg b fi lk ll l lm ln">{<br/>  "error": {<br/>    "code": 404,<br/>    "message": "Requested entity was not found.",<br/>    "status": "NOT_FOUND"<br/>  }<br/>}</span></pre><p id="9392" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们尝试描述我们的新任务，我们可能会看到它已经被处理了:</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="1906" class="jp jq ht lg b fi lk ll l lm ln">{<br/>  "error": {<br/>    "code": 404,<br/>    "message": "The task no longer exists, though a task with this name existed recently. The task either successfully completed or was deleted.",<br/>    "status": "NOT_FOUND"<br/>  }<br/>}</span></pre><p id="8a57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着我们可以<a class="ae jo" href="https://cloud.google.com/tasks/docs/reference/rest/v2/projects.locations.queues.tasks/get" rel="noopener ugc nofollow" target="_blank">请求任务细节</a>，并使用响应来回答许多问题，包括:</p><ul class=""><li id="0cfe" class="ls lt ht is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">处理程序服务是否中断？它发送的是哪个状态码？</li><li id="0115" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">任务是否具有我们期望的所有属性？</li><li id="8f85" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">任务完成了吗？</li></ul><p id="f262" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能不希望使用云任务来代替数据库中的状态字段，因为“完成”消息会消失。</p><h2 id="8408" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">云任务处理计时</h2><p id="cd1e" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">当您创建一个任务时，您可以设置一个<code class="du lo lp lq lg b">schedule-time</code>属性，让您的任务在未来30天内交付。这意味着即使在后端系统的维护期间，您的一线服务也可以不断增加工作。</p><h2 id="66c7" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak">云任务让你独一无二地命名一个任务</strong></h2><p id="d393" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在上面的一些命令中，任务ID是非常数字的，但是作为开发人员，您可以为您的队列指定一个唯一的ID。如果它是唯一的，它将是您需要处理的唯一ID。</p><p id="0ac3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果不是，云任务会有帮助地发回一个错误。你可能会想，这又是一个需要处理的错误；然而，这是一个奇妙的特性。这意味着您可以围绕异步工作负载的创建实现一个断路器。</p><p id="a29c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，假设您有一个内容管理系统，它需要在任何有内容更新的24小时内更新一个站点地图。如果没有变化，你就不想构建站点地图，也不想构建不止一次。</p><p id="9f84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用云任务重复数据删除和计划功能，您可以轻松构建一个“trip-line”机制，如果至少进行了一次内容更新，该机制将在凌晨2点运行您的作业:</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/d917d987ad4273428509b9f6e21ec668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*FKi9W7KNBL4Ok3NII8lgVA.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">无论给定事件被触发多少次，都只会创建一个命名任务的实例，并且只需要一个。在<a class="ae jo" href="https://bramp.github.io/js-sequence-diagrams/" rel="noopener ugc nofollow" target="_blank">https://bramp.github.io/js-sequence-diagrams/</a>上创建的图表</figcaption></figure><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="76f5" class="jp jq ht lg b fi lk ll l lm ln">gcloud tasks create-http-task sitemap-rebuild --queue my-queue\<br/>  --url "<a class="ae jo" href="https://cms.example123-uc.a.run.app/sitemap-rebuild" rel="noopener ugc nofollow" target="_blank">https://cms.example123-uc.a.run.app/sitemap-rebuild</a>" \<br/>  --schedule-time 2019-09-17T05:30:00Z</span><span id="2a5a" class="jp jq ht lg b fi lr ll l lm ln"># First Time<br/>Created task [projects/my-project/locations/us-central1/queues/my-queue/tasks/sitemap-rebuild].</span><span id="f4ee" class="jp jq ht lg b fi lr ll l lm ln"># Second Time, get an HTTP 409 error<br/>ERROR: (gcloud.tasks.create-http-task) ALREADY_EXISTS: Requested entity already exists</span></pre><p id="5bda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们看到了云任务可以提供无服务器应用程序成功所需的应用程序状态的许多方式:</p><ul class=""><li id="b3c4" class="ls lt ht is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">保存特定于请求的详细信息，供以后处理</li><li id="ca9d" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">分享任务处理进度的详细信息</li><li id="e5fc" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">根据您的时间要求安排交付</li><li id="80b7" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">建立“trip-lines ”,这样<em class="ks">你就不需要做额外的工作</em>来阻止你的<em class="ks">任务处理程序做额外的工作</em></li></ul><p id="ea4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要浏览使用云任务向异步工作负载传输状态的示例，请查看云任务文档中的<a class="ae jo" href="https://cloud.google.com/tasks/docs/tutorial-gcf" rel="noopener ugc nofollow" target="_blank">明信片教程。</a></p></div></div>    
</body>
</html>