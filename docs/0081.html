<html>
<head>
<title>Deploying Django, Postgres, and Redis Containers To Kubernetes (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Django、Postgres和Redis容器部署到Kubernetes(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploying-django-postgres-and-redis-containers-to-kubernetes-part-2-b287f7970a33?source=collection_archive---------1-----------------------#2016-03-31">https://medium.com/google-cloud/deploying-django-postgres-and-redis-containers-to-kubernetes-part-2-b287f7970a33?source=collection_archive---------1-----------------------#2016-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/db96fae9a712b196675cb56fbb0a8b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*c7cyhaGqdUWzJmsAgXyjIQ.png"/></div></figure><p id="f91a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是我关于将Django应用程序部署到Kubernetes的系列文章的第二部分。<a class="ae jk" rel="noopener" href="/google-cloud/deploying-django-postgres-redis-containers-to-kubernetes-9ee28e7a146#.hxa3x1fsg">点击此处</a>阅读第一部分，在这里我将一个Django应用打包并在Kubernetes上运行，仅使用内存缓存和SQLite数据库。第2部分假设您已经完成了第1部分的步骤，并且您的Django应用程序可以使用外部IP，只是没有连接适当的数据库或缓存。</p><p id="c401" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本教程结束时，您将拥有Django应用程序和一个PostgreSQL数据库，受Kubernetes秘密数据库密码和Redis缓存保护，以及由CDN提供的静态文件。</p><p id="1fb2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">和以前一样，你可以在<a class="ae jk" href="https://github.com/waprin/kubernetes_django_postgres_redis" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到本教程的所有代码、带有完整说明的自述文件和问题跟踪器。如果你遇到任何后续问题，你可以在Github问题跟踪上提交问题，并提到waprin@，或者在Twitter上提到我<a class="ae jk" href="https://twitter.com/waprin_io" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9343" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你对在Google Cloud上运行Django的其他方法和教程感兴趣，我最近发布了一个在Google Cloud上运行Django的<a class="ae jk" href="http://cloud.google.com/python/django" rel="noopener ugc nofollow" target="_blank">新登录页面</a>，其中包括在Google App Engine标准环境、Google App Engine灵活环境(以前是托管虚拟机)、Google Compute Engine和使用Google CloudSQL(完全托管MySQL)的Google Container Engine(Kubernetes)上运行Django的新快速入门指南。看看吧！同样，如果你遇到任何问题，请在Github或Twitter上给我留言。</p><p id="1fca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Redis和Postgres都不是高可用性的设置——我将在下一篇文章中解决这个问题。</p><h1 id="5738" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤0:一些调试技巧</h1><p id="a7f9" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在本教程中有很多步骤要走，我自己通常不会100%正确地完成它们。如果遇到问题，请记住以下一些有用的命令:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="60da" class="kx jm hi kt b fi ky kz l la lb">$ kubectl logs &lt;pod name&gt;</span></pre><p id="f079" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">kubectl日志将显示容器的标准输出/错误，这通常是我查找问题的第一个地方。如果你需要更深入地挖掘，你可以在容器上运行一些命令，比如“cat”一个文件。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9c4d" class="kx jm hi kt b fi ky kz l la lb">$ kubectl exec &lt;frontend-pod&gt; -- cat /etc/secrets/djangouserpw</span></pre><p id="83da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想看到一个资源的所有Kubernetes元信息，试试“kubectl describe ”:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b283" class="kx jm hi kt b fi ky kz l la lb">$ kubectl describe pod &lt;pod_name&gt;</span><span id="9268" class="kx jm hi kt b fi lc kz l la lb">$ kubectl describe service &lt;service_name&gt;</span><span id="7b5c" class="kx jm hi kt b fi lc kz l la lb">$ kubectl describe rc &lt;rc_name&gt;</span></pre><p id="e9d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我遇到问题时，最简单的方法就是删除并重建资源。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9586" class="kx jm hi kt b fi ky kz l la lb">$ kubectl delete rc frontend</span><span id="8de2" class="kx jm hi kt b fi lc kz l la lb">$ kubectl create -f kubernetes_configs/frontend.yaml</span></pre><h1 id="9d0b" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤1:部署Redis</h1><p id="c2c3" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">Redis是一种流行的内存键值存储，通常用于缓存，尽管它也可以用作主数据库或队列。在本例中，我们将重点关注仅将其用作缓存，因此我们不需要任何磁盘存储。对于我们的用例，它跟踪到目前为止页面的访问者数量。让我们快速浏览一下mysite/settings.py中的Django配置:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d3cc" class="kx jm hi kt b fi ky kz l la lb">CACHES = {<br/>    'default': {<br/>        'BACKEND': 'redis_cache.RedisCache',<br/>        'LOCATION': [<br/>            '%s:%s' % (os.getenv('REDIS_MASTER_SERVICE_HOST', '127.0.0.1'),<br/>                       os.getenv('REDIS_MASTER_SERVICE_PORT', 6379)),<br/>            '%s:%s' % (os.getenv('REDIS_SLAVE_SERVICE_HOST', '127.0.0.1'),<br/>                       os.getenv('REDIS_SLAVE_SERVICE_PORT', 6379))<br/>        ],<br/>        'OPTIONS': {<br/>            'PARSER_CLASS': 'redis.connection.HiredisParser',<br/>            'PICKLE_VERSION': 2,<br/>            'MASTER_CACHE': '%s:%s' % (<br/>                os.getenv('REDIS_MASTER_SERVICE_HOST', '127.0.0.1')<br/>                , os.getenv('REDIS_MASTER_SERVICE_PORT', 6379))<br/>        },<br/>    },</span></pre><p id="e38b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如你所见，我们使用了<a class="ae jk" href="https://github.com/sebleier/django-redis-cache" rel="noopener ugc nofollow" target="_blank"> django-redis-cache </a>和<a class="ae jk" href="https://github.com/redis/hiredis" rel="noopener ugc nofollow" target="_blank"> hiredis </a> Python库让django与redis对话。默认情况下，我们将主机和端口配置为localhost和默认的Redis端口(6379)，但是我们可以替换这些环境变量来进行不同的配置。</p><p id="c874" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Kubernetes集群中，REDIS_MASTER_SERVICE_HOST将由任何名为“REDIS_MASTER”的服务的虚拟IP自动填充。这意味着只要我们创建“redis_master”和“redis_slave ”,并将它们配置为侦听6379，所有这些环境变量都会自动填充。</p><p id="3cf2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意，如果您只有一个Redis主服务器，将REDIS_MASTER_SLAVE_HOST指向同一个主机也可以。</p><p id="c66f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以用一个命令在Kubernetes中创建Redis集群:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3469" class="kx jm hi kt b fi ky kz l la lb">$ kubectl create -f kubernetes_configs/redis_cluster.yaml</span></pre><p id="cd19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就是这样！好的，但是让我们添加一些关于正在发生的事情的上下文。再一次，在本地运行容器是有益的。Redis在<a class="ae jk" href="https://hub.docker.com/_/redis/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>上有官方图片，所以我们可以在本地运行。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2be0" class="kx jm hi kt b fi ky kz l la lb">$ brew install redis # install redis cli locally on OS X<br/>$ eval $(docker-machine env dev) # initialize my Docker client to my ‘dev’ machine <br/>$ docker run -p 6379:6379 redis # Pull and run the official Redis docker image<br/>$ redis-cli -h $(docker-machine ip dev)</span></pre><p id="607e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您在Linux工作站上工作并直接运行Docker，那么您可以通过localhost:6379访问您的本地Redis，但是如果您使用Docker-Machine，您必须首先获得您的虚拟机的IP。您还必须安装Redis CLI。在OS X，我用自制软件来完成这个任务。</p><p id="605f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以使用Redis本地映像在本地运行您的应用程序。</p><p id="c8a7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们回过头来看看我们在<a class="ae jk" href="https://github.com/waprin/kubernetes_django_postgres_redis/blob/master/kubernetes_configs/redis_cluster.yaml" rel="noopener ugc nofollow" target="_blank"> kubernetes Redis配置</a>中到底做了什么。我们正在创建两个服务，一个用于读写主机，一个用于只读从机。我们将主复制控制器设置为仅创建一个副本。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5fc8" class="kx jm hi kt b fi ky kz l la lb">replicas: 1</span></pre><p id="728a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一方面，从属复制控制器将从两个副本开始，如果需要，可以扩展到更多副本:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f73c" class="kx jm hi kt b fi ky kz l la lb">$ kubectl scale rc redis-slave --replicas=5</span></pre><p id="0125" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可能注意到的最后一件事是，从属服务器的图像字段被设置为gcr.io/google_samples/gb-redisslave:v1，而不仅仅是redis。gcr映像是PHP留言簿示例中的一个公共映像，它扩展了基本映像并启动Redis，但允许它以可以连接到master的只读从属模式启动。你可以<a class="ae jk" href="https://github.com/kubernetes/kubernetes/tree/master/examples/guestbook/redis-slave" rel="noopener ugc nofollow" target="_blank">自己看一下图像</a>。</p><h1 id="6210" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤2:部署PostgreSQL</h1><p id="1b04" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">因为Django设置被配置为使用Redis服务和PostgreSQL服务，所以在我们重新构建没有NODB标志的应用程序之前，您应该首先设置Postgres。Postgres需要一个持久磁盘。这些指令将使用一个谷歌持久磁盘，但是<a class="ae jk" href="http://kubernetes.io/docs/user-guide/volumes/#awselasticblockstore" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档包含了如何将它更改为亚马逊EBS卷的指令</a>。</p><p id="bd53" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于README.md中的容器引擎说明，您可以创建一个500GB的磁盘，如下所示:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b6da" class="kx jm hi kt b fi ky kz l la lb">$ gcloud compute disks create pg-data --size 500GB</span></pre><p id="7132" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们需要创建数据库。首先，我们将创建一个Kubernetes Secret来包含我们的数据库密码。创建一个秘密可以让我们在集群中存储诸如密码或SSL证书之类的东西，而无需将其添加到映像本身或存储到不安全的存储中。你可能想知道为什么我们在Postgres中使用秘密而不是Redis。在这两种情况下，我们都没有公开任何一个外部服务，这意味着我们不需要秘密，但在这两种情况下，使用秘密来保护您的数据可能仍然更安全。您使用您的最佳判断，但是在这种情况下，我认为演示如何使用Kubernetes的秘密来存储密码会有所帮助。</p><p id="2470" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">秘密将以base64格式保存，所以你必须对它进行编码。注意:base64是一种压缩格式，但它不是加密格式，base64格式的密码和明文一样不安全。在OS X或Linux上，您可以使用命令行:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0e2a" class="kx jm hi kt b fi ky kz l la lb">$ echo mysecretpassword | base64</span></pre><p id="2fcb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">打开“kubernetes _ configs/db _ password . YAML ”,用上述base64命令的输出替换<your-base64-encoded-pw-here>。</your-base64-encoded-pw-here></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f621" class="kx jm hi kt b fi ky kz l la lb"><strong class="kt hj">apiVersion: </strong>v1<br/><strong class="kt hj">kind: </strong>Secret<br/><strong class="kt hj">metadata:<br/>  name: </strong>db-passwords<br/><strong class="kt hj">data:<br/>  djangouserpw: </strong>bXlzZWNyZXRwYXNzd29yZAo=</span></pre><p id="6126" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，将机密添加到集群中:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4315" class="kx jm hi kt b fi ky kz l la lb">$ kubectl create -f kubernetes_configs/db_password.yaml</span></pre><p id="f295" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，如果你运行“kubectl get secrets ”,你可以看到你创建的秘密，db-passwords。</p><p id="9848" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦创建了秘密，您就可以创建Postgres pod。我们可以在“kubernetes _ configs/postgres . YAML”中查看我们的配置。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="723a" class="kx jm hi kt b fi ky kz l la lb"><strong class="kt hj">spec:<br/>  containers:<br/>  </strong>- <strong class="kt hj">name: </strong>postgres<br/>    <strong class="kt hj">image: </strong>gcr.io/$GCLOUD_PROJECT/postgres-pw<br/>    <em class="ld"># disable this in production<br/>    </em><strong class="kt hj">imagePullPolicy: </strong>Always<br/>    <strong class="kt hj">ports:<br/>    </strong>- <strong class="kt hj">containerPort: </strong>5432<br/>    <strong class="kt hj">volumeMounts:<br/>    </strong>- <strong class="kt hj">name: </strong>postgresdata<br/>      <strong class="kt hj">mountPath: </strong>/usr/local/var/postgres<br/>    - <strong class="kt hj">name: </strong>secrets<br/>      <strong class="kt hj">mountPath: </strong>/etc/secrets<br/>      <strong class="kt hj">readOnly: </strong>true<br/>  <em class="ld"># PostgreSQL Data<br/>  # Replace this with the persistent disk of your choice<br/>  # TODO: replace with Persistent Volume<br/>  </em><strong class="kt hj">volumes:<br/>  </strong>- <strong class="kt hj">name: </strong>postgresdata<br/>    <strong class="kt hj">gcePersistentDisk:<br/>      </strong><em class="ld"># your disk name here<br/>      </em><strong class="kt hj">pdName: </strong>pg-data<br/>      <strong class="kt hj">fsType: </strong>ext4<br/>  - <strong class="kt hj">name: </strong>secrets<br/>    <strong class="kt hj">secret:<br/>      secretName: </strong>db-passwords</span></pre><p id="0407" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">像往常一样，我们正在为我们的数据库创建一个服务，以便其他Pods可以与我们的服务对话。我们还为Postgres容器创建了一个复制控制器，但是与Redis master示例一样，将其限制为一个Pod。一次只有一个Pod可以读写持久性磁盘，因此在我们进行高可用性设置之前，拥有更多Pod没有任何意义。创建具有一个副本的复制控制器而不是直接创建Pod的优点是，如果复制控制器失败，它将重新启动我们的Pod，因为它的任务是始终确保一个标签为“name=postgres”的Pod一直存在。</p><p id="a78f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在创建Postgres映像之前，我们必须构建它。我们不能只部署普通的Postgres映像，因为我们需要添加几行代码从秘密文件中读取密码，并在我们的数据库配置中使用它。看看<a class="ae jk" href="https://github.com/waprin/kubernetes_django_postgres_redis/blob/master/postgres_image/Dockerfile" rel="noopener ugc nofollow" target="_blank">postgres _ image/docker file</a>看看这是怎么做到的。这个秘密通过Pod配置挂载到/etc/secrets/djangouserpw中，然后docker文件将它读入一个环境变量。不幸的是，目前secrets只能作为文件而不是环境变量使用，所以您必须自己添加这些行。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e65e" class="kx jm hi kt b fi ky kz l la lb">ENTRYPOINT []</span><span id="23ca" class="kx jm hi kt b fi lc kz l la lb">CMD export POSTGRES_DB=guestbook; export POSTGRES_USER=django_user; export POSTGRES_PASSWORD=$(cat /etc/secrets/djangouserpw) ;./docker-entrypoint.sh postgres;</span></pre><p id="ecba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要构建和推送映像，请转到“postgres_image/Dockerfile”目录并运行以下命令:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e4e3" class="kx jm hi kt b fi ky kz l la lb">$ cd postgres_image<br/>$ gcloud config set project &lt;your-project-id&gt;<br/>$ make build<br/>$ make push</span></pre><p id="5559" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Makefile只是别名Docker命令来构建图像并将其推送到Google容器注册表。或者，您可以构建一个图像并将其推送到DockerHub。</p><p id="3abc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上传图像后，编辑“kubernetes _ configs/postgres . YAML”并替换“waprin/postgres_image”以反映您刚刚推送的Docker图像的图像名称，该名称应为“gcr . io/your-project-id/postgres-pw”。或者，当然，你可以只使用我的图像，因为它应该是同样的事情。完成后，创建Postgres Pod:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1ded" class="kx jm hi kt b fi ky kz l la lb">$ kubectl create -f kubernetes_configs/postgres.yaml</span></pre><h1 id="f16f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤3:重新部署Django应用程序并运行迁移</h1><p id="21fd" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">现在，如果我们运行“kubectl get services ”,我们应该会看到我们的Postgres和Redis服务(redis-slave和redis-master)。我们可以运行“kubectl get rc”来查看每个复制控制器，运行“kubectl get pods”来查看rc创建的每个容器(副本)。</p><p id="6365" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我们之前已经用' NODB '环境变量集构建了Django映像，所以我们想禁用它。再次切换到“guestbook”目录，确保“ENV NODB”行被注释掉。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5d96" class="kx jm hi kt b fi ky kz l la lb"><strong class="kt hj"><em class="ld"># Comment it out and rebuild this image once you have Postgres and Redis services in your cluster<br/></em>#ENV </strong>NODB 1</span></pre><p id="86bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完成后，重新构建容器并再次推送(记住这些make命令是docker build/docker push的别名):</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="21ba" class="kx jm hi kt b fi ky kz l la lb">$ make build<br/>$ make push</span></pre><p id="ae55" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要做的下一件事是编辑复制控制器配置。因为我们需要一个数据库密码，所以我们也需要在前端安装Kubernetes Secret。它已经在“kubernetes _ config/fronted . YAML”中，只是被注释掉了，所以取消注释:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c764" class="kx jm hi kt b fi ky kz l la lb"><em class="ld"># uncomment the following lines with NODB set to 0, so you can mount the DB secrets<br/></em><strong class="kt hj">volumeMounts:<br/>  </strong>- <strong class="kt hj">name: </strong>secrets<br/>    <strong class="kt hj">mountPath: </strong>/etc/secrets<br/>    <strong class="kt hj">readOnly: </strong>true<br/><strong class="kt hj">volumes:<br/></strong>- <strong class="kt hj">name: </strong>secrets<br/>  <strong class="kt hj">secret:<br/>    secretName: </strong>db-passwords</span></pre><p id="c88b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于您更改了复制控制器的定义，此时，最简单的方法就是删除rc并重新创建它:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8940" class="kx jm hi kt b fi ky kz l la lb">$ kubectl delete rc frontend</span><span id="f209" class="kx jm hi kt b fi lc kz l la lb">$ kubectl create -f kubernetes_configs/frontend.yaml</span></pre><p id="8d96" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您想避免停机，那么最好的方法可能是“<a class="ae jk" href="http://kubernetes.io/docs/user-guide/kubectl/kubectl_patch/" rel="noopener ugc nofollow" target="_blank"> kubectl修补</a>”资源。</p><p id="c970" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您没有更新复制控制器定义，只是想改变映像，最安全的方法是<a class="ae jk" href="http://kubernetes.io/docs/user-guide/rolling-updates/" rel="noopener ugc nofollow" target="_blank">滚动更新</a>，它将一次旋转1个新容器，并且只有在新容器成功启动时才会继续。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b08b" class="kx jm hi kt b fi ky kz l la lb">$ kubectl rolling-update frontend \<br/>--image=gcr.io/${GCLOUD_PROJECT}/guestbook</span></pre><p id="117e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果像我一样，您喜欢危险的生活，并且不介意短暂的停机时间，您可以改为编辑frontend.yaml文件以指向您的新映像，将复制控制器缩小到0(杀死所有pod)，然后再将其放大。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="abbc" class="kx jm hi kt b fi ky kz l la lb">$ kubectl scale rc frontend --replicas=0 # kill your pods<br/>$ kubectl scale rc frontend --replicas=3 # new image</span></pre><p id="ee68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在任何情况下，我们需要更改的不仅仅是映像，以便装载机密，因此在这种情况下，删除/创建或修补整个复制控制器是必要的。</p><p id="57ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后一步是运行我们的数据库迁移。Kubernetes的一个优点是，我们可以使用“kubectl exec”命令来执行容器中的任何命令。因此，要运行迁移，我们只需选择一个仲裁前端单元，并从那里运行它们。</p><p id="76fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，获取您的pod列表，以便您可以选择一个前端pod:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b563" class="kx jm hi kt b fi ky kz l la lb">$ kubectl get pods</span></pre><p id="9ced" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，选择一个前端单元，并使用它来运行迁移:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="63c7" class="kx jm hi kt b fi ky kz l la lb">$ kubectl exec $(FRONTEND_POD_NAME) -- python /app/manage.py migrate</span></pre><p id="66a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者您可以使用我设置的Makefile别名来自动完成这项工作:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1f0f" class="kx jm hi kt b fi ky kz l la lb">$ make migrations</span></pre><p id="4ea6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完成后，我们可以再次执行“kubectl get services”来获取前端的外部IP。如果一切顺利，应用程序现在应该服务并正确维护状态。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="645c" class="kx jm hi kt b fi ky kz l la lb">$ kubectl get services<br/>NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><span id="d81a" class="kx jm hi kt b fi lc kz l la lb">frontend 10.67.245.107 104.154.27.239 80/TCP 8h</span><span id="20b4" class="kx jm hi kt b fi lc kz l la lb">kubernetes 10.67.240.1 &lt;none&gt; 443/TCP 9h</span><span id="0951" class="kx jm hi kt b fi lc kz l la lb">postgres 10.67.255.67 &lt;none&gt; 5432/TCP 9h</span><span id="ac49" class="kx jm hi kt b fi lc kz l la lb">redis-master 10.67.244.152 &lt;none&gt; 6379/TCP 8h</span><span id="e7e4" class="kx jm hi kt b fi lc kz l la lb">redis-slave 10.67.240.128 &lt;none&gt; 6379/TCP 8h</span></pre><h1 id="1b21" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤4:提供静态内容</h1><p id="9c13" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">虽然应用程序现在应该正确地保存数据，但我们仍然在设置中打开了调试标志。如果我们把它拿掉，我们会发现所有的CSS样式表和Javascript都不见了。这是因为该应用程序被配置为使用Django的静态文件处理程序，这适用于调试用途，但不适用于在生产环境中提供文件。</p><p id="8b6e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为静态内容提供服务有多种选择，任何CDN(内容交付网络)都足够了。虽然我明显有点偏见，但谷歌云存储是一个不错的选择，因为它既是一个全球可用的文件存储库<em class="ld">又是一个CDN。</em></p><p id="e9bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要使用GCS作为静态文件处理程序选项，首先创建一个可公开访问的GCS bucket:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0c57" class="kx jm hi kt b fi ky kz l la lb">$ gsutil mb gs://&lt;your-project-id&gt;<br/>$ gsutil defacl set public-read gs://&lt;your-project-id&gt;</span></pre><p id="7b68" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当然，我有一个Makefile别名做同样的事情:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d1b3" class="kx jm hi kt b fi ky kz l la lb">$ make bucket</span></pre><p id="9deb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，将Django静态内容收集到settings指定的本地文件夹中。静态_根</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ac33" class="kx jm hi kt b fi ky kz l la lb">$ python manage.py collectstatic</span></pre><p id="6fdb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，将您的内容上传到GCS(替换<your-gcs-bucket>)</your-gcs-bucket></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="46d4" class="kx jm hi kt b fi ky kz l la lb">$ gsutil rsync -R static/ gs://&lt;your-gcs-bucket&gt;/static</span></pre><p id="1e9a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，您可以更改设置。STATIC_URL指向这个桶名和when设置。DEBUG设置为False，它将从此URL提供服务。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="98d0" class="kx jm hi kt b fi ky kz l la lb"><strong class="kt hj"><em class="ld">STATIC_URL = 'https://storage.googleapis.com/your-project/static/'</em></strong></span></pre><p id="8fff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此时，您应该有一个运行在Postgres数据库和Redis缓存上的Django应用程序，它们都运行在Kubernetes中。</p><p id="46e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们服务的高可用性方面还有一些工作要做。下次见！</p></div></div>    
</body>
</html>