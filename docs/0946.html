<html>
<head>
<title>Auth’ing w/ Kubernetes Engine service accounts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">授权Kubernetes引擎服务帐户</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/authing-w-kubernetes-engine-service-accounts-ae752b46ed18?source=collection_archive---------0-----------------------#2019-03-07">https://medium.com/google-cloud/authing-w-kubernetes-engine-service-accounts-ae752b46ed18?source=collection_archive---------0-----------------------#2019-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="deae" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">警告开发者</h2></div><p id="62f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用Kubernetes(！idspnonenote)来验证Kubernetes引擎资源。)服务帐户。我在Kubernetes(引擎)文档中找不到这种方法的例子，所以请谨慎对待，如果您对这种方法有任何安全顾虑，<strong class="iz hj">不要</strong>使用它。</p><p id="7812" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的目标是使用Kubernetes引擎服务帐户来认证和授权一些软件过程，例如CI|CD管道。</p><blockquote class="jt ju jv"><p id="b3f5" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>当我最初研究这个问题时，我假设服务帐户需要是Google云平台服务帐户，而不是Kubernetes引擎服务帐户。</p></blockquote><h2 id="f4df" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">串</h2><p id="53a1" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">我假设您有一个(牺牲性的)集群(称为<code class="du la lb lc ld b">cluster</code>)愿意用来测试这个集群和一个称为<code class="du la lb lc ld b">root</code>的上下文。</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="a658" class="ka kb hi ld b fi lm ln l lo lp">kubectl config get-clusters<br/>NAME<br/>cluster</span><span id="fc74" class="ka kb hi ld b fi lq ln l lo lp">kubectl config get-contexts<br/>CURRENT   NAME   CLUSTER   AUTHINFO    NAMESPACE<br/>          root   cluster   [[YOU]]</span></pre><h2 id="4023" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">语境</h2><p id="0bbd" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">为了确保我们明确使用哪个上下文，让我们取消默认上下文；这将要求我们为每个<code class="du la lb lc ld b">kubectl</code>命令明确引用我们想要的上下文:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="3a5b" class="ka kb hi ld b fi lm ln l lo lp">kubectl config unset current-context</span><span id="317c" class="ka kb hi ld b fi lq ln l lo lp">kubectl get nodes<br/>The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><span id="0563" class="ka kb hi ld b fi lq ln l lo lp">kubectl get nodes --context=root<br/>NAME                                        STATUS   ROLES    AGE   VERSION<br/>gke-cluster-01-default-pool-b0fa792d-lt2v   Ready    &lt;none&gt;   80m<br/>gke-cluster-01-default-pool-b2ff416e-vtbt   Ready    &lt;none&gt;   80m<br/>gke-cluster-01-default-pool-b457df6d-6n2s   Ready    &lt;none&gt;   80m</span></pre><h2 id="38cd" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">命名空间</h2><p id="276a" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">为了确定我们的工作范围，让我们为此创建并使用一个名称空间:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="e33d" class="ka kb hi ld b fi lm ln l lo lp">NAMESPACE=test</span><span id="c40a" class="ka kb hi ld b fi lq ln l lo lp">kubectl create namespace ${NAMESPACE} --context=root<br/>namespace/test created</span></pre><h2 id="e7ed" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">服务帐户</h2><p id="8ed3" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">让我们创建一个Kubernetes引擎服务帐户。为简单起见，我们将在<code class="du la lb lc ld b">${NAMESPACE}</code>中创建服务帐户，但它不需要在也不限于这个名称空间中创建:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="45be" class="ka kb hi ld b fi lm ln l lo lp">NAME=test</span><span id="cbc2" class="ka kb hi ld b fi lq ln l lo lp">echo "<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/> name: ${NAME}<br/> namespace: ${NAMESPACE}<br/>" | kubectl apply --filename=- --context=root<br/>serviceaccount/${NAME} created</span></pre><blockquote class="jt ju jv"><p id="c984" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">如果你不喜欢我重复使用<code class="du la lb lc ld b">test</code>这个名字，我很抱歉。因为每个资源都是不同的，所以这不是问题。使用你喜欢的价值观。</p></blockquote><h2 id="f534" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">证明</h2><p id="b0e7" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">Kubernetes引擎利用Google[云平台] [OAuth2]认证。如果您检查您的Kubernetes配置文件，您会看到您的凭证是使用<code class="du la lb lc ld b">gcloud config config-helper</code>获得的:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="366e" class="ka kb hi ld b fi lm ln l lo lp">users:<br/>- name: [[YOUR-GOOGLE-ID]]<br/>  user:<br/>    auth-provider:<br/>      config:<br/>        access-token: ya29.[[REDACTED]]<br/>        cmd-args: <strong class="ld hj">config config-helper</strong> --format=json<br/>        cmd-path: /usr/lib/google-cloud-sdk/bin/<strong class="ld hj">gcloud</strong><br/>        expiry: "2019-03-07T23:59:59Z"<br/>        expiry-key: '{.credential.token_expiry}'<br/>        token-key: '{.credential.access_token}'<br/>      name: gcp</span></pre><p id="5174" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您运行这个命令，您将会看到由<code class="du la lb lc ld b">gcloud</code>命令获得的<code class="du la lb lc ld b">access_token</code>，并由<code class="du la lb lc ld b">kubectl</code>用来向集群验证您的身份。</p><p id="19dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章中概述的方法的一个副作用是，它不要求<code class="du la lb lc ld b">gcloud</code>对软件重复验证集群可用。</p><p id="8646" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将创建一个新用户(名为<code class="du la lb lc ld b">${NAME}</code>)来代表服务帐户:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="bae0" class="ka kb hi ld b fi lm ln l lo lp">SECRET=$(kubectl get serviceaccount/${NAME} \<br/>--namespace=${NAMESPACE} \<br/>--context=root \<br/>--output=jsonpath="{.secrets[0].name}")</span><span id="b55b" class="ka kb hi ld b fi lq ln l lo lp">TOKEN=$(kubectl get secret/${SECRET} \<br/>--namespace=${NAMESPACE} \<br/>--context=root \<br/>--output=jsonpath="{.data.token}" | base64 --decode)</span><span id="cb99" class="ka kb hi ld b fi lq ln l lo lp">kubectl config set-credentials ${NAME} \<br/>--token=${TOKEN}</span><span id="858c" class="ka kb hi ld b fi lq ln l lo lp">kubectl config set-context ${NAME} \<br/>--user=${NAME} \<br/>--cluster=cluster</span></pre><blockquote class="jt ju jv"><p id="1513" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj">NB</strong><code class="du la lb lc ld b">set-credentials</code>命令正在向您的Kubernetes配置文件添加一个<strong class="iz hj">载体</strong>令牌。您必须控制对此令牌和文件的访问。如果你失去了其中任何一个的控制权，撤销秘密(！)使用<code class="du la lb lc ld b">kubectl delete secret/${SECRET} --namespace=${NAMESPACE} --context=root</code>。</p><p id="99dd" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">在最后一个命令中，我们将创建一个以<code class="du la lb lc ld b">${NAME}</code>命名的上下文。您可能更喜欢将上下文命名为与用户名不同的名称。</p><p id="6be3" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">如果你得到base64解码值。但是<code class="du la lb lc ld b">kubectl get secret/${SECRET} ...</code>返回base64编码的值。我们想要解码后的值。</p></blockquote><p id="e843" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果你回顾~/。kube/config文件中，您应该看到为<code class="du la lb lc ld b">${NAME}</code>添加了一个<code class="du la lb lc ld b">user</code>条目和一个<code class="du la lb lc ld b">context</code>条目:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="eeb0" class="ka kb hi ld b fi lm ln l lo lp">contexts:<br/><strong class="ld hj">- context:<br/>    cluster: cluster<br/>    user: ${NAME}<br/>  name: ${NAME}</strong><br/>- context:<br/>    cluster: cluster<br/>    user: [[YOU]]<br/>  name: root<br/>current-context: ""<br/>kind: Config<br/>preferences: {}<br/>users:<br/>- name: [[YOU]]<br/>  user:<br/>    auth-provider:<br/>      config:<br/>        access-token: ya29.[[REDACTED]]<br/>        cmd-args: config config-helper --format=json<br/>        cmd-path: /usr/lib/google-cloud-sdk/bin/gcloud<br/>        expiry: "2019-03-07T23:59:59Z"<br/>        expiry-key: '{.credential.token_expiry}'<br/>        token-key: '{.credential.access_token}'<br/>      name: gcp<br/><strong class="ld hj">- name: ${NAME}<br/>  user:<br/>    token: ${TOKEN}</strong></span></pre><p id="3e09" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="f724" class="ka kb hi ld b fi lm ln l lo lp">kubectl get nodes --context=${NAME}<br/>Error from server (Forbidden): nodes is forbidden: User "system:serviceaccount:<strong class="ld hj">${NAMESPACE}:${NAME}</strong>" cannot list resource "nodes" in API group "" at the cluster scope</span></pre><p id="7b11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">已验证但未授权。</p><h2 id="a3b1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">批准</h2><p id="d9a7" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">此帐户在群集上没有权限。</p><p id="8613" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将授予<code class="du la lb lc ld b">${NAME}</code>使用部署的能力。为此，我们需要创建一个角色(为了更具体，我使用了<code class="du la lb lc ld b">Role</code>而不是<code class="du la lb lc ld b">ClusterRole</code>，然后在<code class="du la lb lc ld b">${NAME}</code>和<code class="du la lb lc ld b">Role</code>之间创建一个<code class="du la lb lc ld b">RoleBinding</code>。</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="9e3c" class="ka kb hi ld b fi lm ln l lo lp">echo "<br/>---<br/>kind: Role<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/>  name: ${NAME}<br/>  namespace: ${NAMESPACE}<br/>rules:<br/>- apiGroups:<br/>  - apps<br/>  - extensions<br/>  resources:<br/>  - deployments<br/>  verbs:<br/>  - create<br/>  - delete<br/>  - get<br/>  - list<br/>  - patch<br/>  - update<br/>  - watch<br/>...<br/>---<br/>kind: RoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/>  name: ${NAME}<br/>  namespace: ${NAMESPACE}<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: ${NAME}<br/>  namespace: ${NAMESPACE}<br/>roleRef:<br/>  kind: Role<br/>  name: ${NAME}<br/>  apiGroup: rbac.authorization.k8s.io<br/>---<br/>" | kubectl apply --filename=- --context=root<br/>role.rbac.authorization.k8s.io/${NAME} created<br/>rolebinding.rbac.authorization.k8s.io/${NAME} created</span></pre><h2 id="f9b7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">试验</h2><p id="40b4" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">让我们在名称空间<code class="du la lb lc ld b">default</code>和<code class="du la lb lc ld b">${NAMESPACE}</code>中创建测试部署:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="2b45" class="ka kb hi ld b fi lm ln l lo lp">kubectl run nginx \<br/>--image=nginx \<br/>--replicas=1 \<br/>--namespace=default \<br/>--context=root</span><span id="6d0c" class="ka kb hi ld b fi lq ln l lo lp">kubectl run nginx \<br/>--image=nginx \<br/>--replicas=1 \<br/>--namespace=${NAMESPACE} \<br/>--context=root</span></pre><p id="3142" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的<code class="du la lb lc ld b">root</code>上下文拥有完全授权，但是我们的<code class="du la lb lc ld b">${NAME}</code>上下文(代表我们的<code class="du la lb lc ld b">${NAME}</code>用户)应该只能枚举<code class="du la lb lc ld b">${NAMESPACE}</code>中的部署:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="aaa3" class="ka kb hi ld b fi lm ln l lo lp">kubectl get deployments \<br/>--context=${NAME} \<br/>--namespace=<strong class="ld hj">default</strong><br/>Error from server (Forbidden): deployments.extensions is forbidden: User "system:serviceaccount:${NAMESPACE}:${NAME}" cannot list resource "deployments" in API group "extensions" in the namespace "default"</span><span id="58a1" class="ka kb hi ld b fi lq ln l lo lp">kubectl get deployments \<br/>--context=${NAME} \<br/>--namespace=<strong class="ld hj">${NAMESPACE}</strong><br/>NAME    DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>nginx   1         1         1            1           25s</span></pre><blockquote class="jt ju jv"><p id="b5ff" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong> <code class="du la lb lc ld b">kubectl run</code>使用<code class="du la lb lc ld b">extensions</code>而不是新的<code class="du la lb lc ld b">apps</code> API组创建部署。</p></blockquote><h2 id="79b6" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">结论</h2><p id="534f" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">由Google OAuth支持的Kubernetes Engine auth是非常好的，也是一个不错的选择。</p><p id="b28e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如这里所展示的，如果您有一个集群外部的软件(而不是人)并且需要与集群交互，那么您可以使用Kubernetes服务帐户来验证和授予帐户精确的权限(授权)。</p><p id="b6c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直接将<code class="du la lb lc ld b">gcloud</code>包含在外部软件的配置中就省去了。尽管——请记住——添加到<code class="du la lb lc ld b">~/.kube/config</code>文件中的令牌是一个<strong class="iz hj">不记名</strong>令牌。拥有令牌的任何人都可以使用服务帐户的权限访问群集。如果您失去了对令牌或引用它的Kubernetes配置文件的控制，<strong class="iz hj">删除秘密</strong>:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="f2e7" class="ka kb hi ld b fi lm ln l lo lp">kubectl delete secret/${SECRET} \<br/>--namespace=${NAMESPACE} \<br/>--context=root</span></pre><p id="61d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将禁止使用令牌:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="4255" class="ka kb hi ld b fi lm ln l lo lp">kubectl delete secret/${SECRET} \<br/>--namespace=${NAMESPACE} \<br/>--context=<strong class="ld hj">root</strong><br/>secret "fred-token-nbqw9" deleted</span><span id="2dfe" class="ka kb hi ld b fi lq ln l lo lp">kubectl get deployment/nginx \<br/>--namespace=${NAMESPACE} \<br/>--context=${NAME}<br/>NAME    DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>nginx   1         1         1            1           59m</span><span id="2f19" class="ka kb hi ld b fi lq ln l lo lp">kubectl get deployment/nginx \<br/>--namespace=${NAMESPACE} \<br/>--context=${NAME}<br/>error: You must be logged in to the server (Unauthorized)</span></pre><p id="111c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果不是即时的，但应该是迅速的。</p><h2 id="9fac" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">整理一下！</h2><p id="8b0f" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">大锤式的整理方法是:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="0ae7" class="ka kb hi ld b fi lm ln l lo lp">kubectl delete namespace/${NAMESPACE} --context=root</span></pre><p id="55e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为<code class="du la lb lc ld b">Service Account</code>、<code class="du la lb lc ld b">Role</code>、<code class="du la lb lc ld b">RoleBinding</code>和一个<code class="du la lb lc ld b">Deployment</code>是在这个名称空间中创建的，所以它们将被一起删除。</p><p id="9bec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要删除其他部署:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="760d" class="ka kb hi ld b fi lm ln l lo lp">kubectl delete deployment/nginx --namespace=<strong class="ld hj">default</strong> --context=root</span></pre><p id="24f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要删除配置文件更改，请执行以下操作:</p><pre class="le lf lg lh fd li ld lj lk aw ll bi"><span id="12c6" class="ka kb hi ld b fi lm ln l lo lp">kubectl config unset users.${NAME}<br/>kubectl config unset contexts.${NAME}</span></pre><p id="758d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>