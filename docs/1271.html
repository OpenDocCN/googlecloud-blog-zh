<html>
<head>
<title>Custom metrics in Node.js with OpenTelemetry (and Prometheus)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenTelemetry(和Prometheus)在Node.js中自定义指标</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/custom-metrics-in-node-js-with-opentelemetry-and-prometheus-c10c8c0204d3?source=collection_archive---------0-----------------------#2020-01-27">https://medium.com/google-cloud/custom-metrics-in-node-js-with-opentelemetry-and-prometheus-c10c8c0204d3?source=collection_archive---------0-----------------------#2020-01-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7583" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇<a class="ae jd" href="https://dev.to/yurigrinshteyn/distributed-tracing-with-opentelemetry-in-go-473h" rel="noopener ugc nofollow" target="_blank">帖子</a>中，我用<a class="ae jd" href="https://opentelemetry.io" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>解决了我的第一个项目，并构建了一个基本的演示来展示如何使用分布式跟踪和Stackdriver导出器。我选择Go来做这个练习，因为当时它是唯一一种有Stackdriver导出器来跟踪的语言。这一次，我想尝试将OpenTelemetry用于度量工具，并注意到opentelemetry-go还没有准备好度量的Stackdriver导出器。我尝试使用Prometheus exporter来代替，但是不知道如何让它与Mux路由器配合良好，于是改用Node.js。</p><p id="467f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以——下面是我如何构建一个基本的Hello World Node.js应用程序，并用OpenTelemetry对其进行测试，以向Prometheus展示基本的“黄金信号”指标(请求计数、错误计数和延迟)。</p><p id="f8ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和往常一样，我在Github <a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/opentelemetry-metrics/demo" rel="noopener ugc nofollow" target="_blank"> repo </a>中提供了我的代码。让我们回顾一下有趣的部分。</p><h1 id="9957" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">导入和设置</h1><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="88c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我只使用了三个外部包——Express用于处理请求，两个OpenTelemetry包——一个用于编写指标，另一个用于将指标导出到Prometheus。对<code class="du kj kk kl km b">:8081/metrics</code>的请求将由普罗米修斯公司处理。</p><blockquote class="kn ko kp"><p id="c544" class="if ig kq ih b ii ij ik il im in io ip kr ir is it ks iv iw ix kt iz ja jb jc hb bi translated"><em class="hi">注意，我已经覆盖了Prometheus exporter </em> <a class="ae jd" href="https://github.com/open-telemetry/opentelemetry-js/blob/master/packages/opentelemetry-exporter-prometheus/src/prometheus.ts#L32-L38" rel="noopener ugc nofollow" target="_blank"> <em class="hi">代码</em> </a> <em class="hi">中设置的默认端口。</em></p></blockquote><h1 id="bee3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">度量定义</h1><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="6348" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一部分中，我定义了我想要跟踪的三个指标。请求计数和错误计数都是单调计数器，这意味着它们只能增加。响应延迟是一个非单调的指标，因为我想跟踪每个请求的延迟。我还使用了一个标签，因为我不知道如何在没有标签的情况下让指标正常工作。</p><h1 id="b15e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">请求处理</h1><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="092c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，应用程序准备好接受传入的请求。对<code class="du kj kk kl km b">:8081/metrics</code>的请求将由Prometheus处理，我使用Express来处理对<code class="du kj kk kl km b">:8080/</code>的请求。对于每一个请求，应用程序都会创建一个计时器(<code class="du kj kk kl km b">measuredLatency</code>)，并让它一直运行，直到它准备好响应。它生成一个0到100之间的随机数，并使用它返回一半的错误，在这种情况下，不会报告延迟。如果没有要返回的错误，应用程序<code class="du kj kk kl km b">sleeps</code>在1到10秒之间，拍摄另一个时间快照，计算经过的时间，并返回该值作为延迟。</p><h1 id="240d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">指标端点</h1><p id="2fb9" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当我在本地运行应用程序时，我可以点击<code class="du kj kk kl km b">/metrics</code>端点，查看我在那里注册的指标:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/9eb136d94e1ff0da1c7e8f0fbd06bd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fQOCVVmB_OhIpRuH.png"/></div></div></figure><p id="ac01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，我已经准备好运行应用程序，并产生实际的流量。这需要:</p><ul class=""><li id="e49a" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated">创建GKE集群</li><li id="d553" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">在上面安装普罗米修斯</li><li id="7e8b" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">部署app，配置要抓取的<code class="du kj kk kl km b">/metrics</code>端点</li></ul><p id="1fe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们开始吧！</p><h1 id="d474" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">创建集群</h1><p id="89f1" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我采用了一种非常简单的方法，并使用云控制台创建了一个使用n1标准节点的单节点集群(结果证明这是一个错误的选择)。然后，我使用<code class="du kj kk kl km b">gcloud container clusters get-credentials &lt;cluster&gt; --zone=&lt;zone&gt;</code>获取凭证，以便能够从我的本地工作站访问它。</p><pre class="kc kd ke kf fd lu km lv lw aw lx bi"><span id="cea2" class="ly jf hi km b fi lz ma l mb mc">$ kubectl get nodes</span><span id="8c0f" class="ly jf hi km b fi md ma l mb mc">NAME                                     STATUS   ROLES    AGE     VERSION</span><span id="e386" class="ly jf hi km b fi md ma l mb mc">gke-small-cluster-pool-1-b40da891-fc1p   Ready    &lt;none&gt;   7h27m   v1.15.7-gke.23</span></pre><p id="44e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择了这个简单的选项:</p><pre class="kc kd ke kf fd lu km lv lw aw lx bi"><span id="4302" class="ly jf hi km b fi lz ma l mb mc">$ brew install helm <em class="kq"># install helm, the package manager for Kubernetes</em></span><span id="a76c" class="ly jf hi km b fi md ma l mb mc">$ helm repo add stable https://kubernetes-charts.storage.googleapis.com/</span><span id="41cf" class="ly jf hi km b fi md ma l mb mc">$ helm repo update</span><span id="dfaa" class="ly jf hi km b fi md ma l mb mc">$ helm install prometheus stable/prometheus</span></pre><p id="909d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这足以让Prometheus启动并运行，但我必须增加集群的大小，以获得足够的CPU来运行一切。</p><pre class="kc kd ke kf fd lu km lv lw aw lx bi"><span id="56cc" class="ly jf hi km b fi lz ma l mb mc">&gt; kubectl get pods</span><span id="92d3" class="ly jf hi km b fi md ma l mb mc">NAME                                            READY   STATUS    RESTARTS   AGE</span><span id="f1c6" class="ly jf hi km b fi md ma l mb mc">prometheus-alertmanager-77995478d8-lh4c5        2/2     Running   0          6m34s</span><span id="43ef" class="ly jf hi km b fi md ma l mb mc">prometheus-kube-state-metrics-f96cbbf97-vc56g   1/1     Running   0          6m34s</span><span id="fe83" class="ly jf hi km b fi md ma l mb mc">prometheus-node-exporter-8xlwp                  1/1     Running   0          114s</span><span id="0df6" class="ly jf hi km b fi md ma l mb mc">prometheus-node-exporter-s2pnt                  1/1     Running   0          6m34s</span><span id="f798" class="ly jf hi km b fi md ma l mb mc">prometheus-node-exporter-xbtrs                  1/1     Running   0          112s</span><span id="c953" class="ly jf hi km b fi md ma l mb mc">prometheus-pushgateway-747dc5fb57-rw72p         1/1     Running   0          6m34s</span><span id="7398" class="ly jf hi km b fi md ma l mb mc">prometheus-server-6f7467bfdd-5vfgx              2/2     Running   0          6m34s</span></pre><p id="0be3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我通过使用<code class="du kj kk kl km b">port-forward</code>验证了普罗米修斯正在工作:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es me"><img src="../Images/693c5c6a7600c4c0342f4157bf1a224c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LAqzJiFR_9cA5nqj.png"/></div></div></figure><h1 id="ce2b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">部署应用程序</h1><p id="6e92" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我创建了一个简单的Dockerfile文件:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="f47a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用<code class="du kj kk kl km b">gcloud builds submit</code>构建了映像，并创建了一个部署文件:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="2500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我使用<code class="du kj kk kl km b">kubectl apply -f</code>创建应用程序，并使用<code class="du kj kk kl km b">kubectl expose deployment --type=LoadBalancer</code>使其对外可用。一旦外部IP地址可用，我就配置一个Stackdriver正常运行时间检查来生成稳定的流量。</p><p id="cb83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至此，所有的设置都已完成。我再次访问Prometheus，以确认我使用OpenTelemetry创建的指标可用:</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/5c23a936752807769cf58ee4f1260f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oVTSOoteXtmw8Jx6.png"/></div></div></figure><h1 id="2d05" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我学到了什么？</h1><p id="aab1" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在我的OpenCensus <a class="ae jd" href="https://github.com/yuriatgoogle/stack-doctor/blob/master/opencensus-metrics/node/app.js" rel="noopener ugc nofollow" target="_blank">练习</a>中，我学会了使用视图、测量和度量等原语。我还学习了如何创建直方图和控制聚合。我在OpenTelemetry方面非常有限的经验表明，这个模型似乎更简单一些。在本练习中，我简单地定义了指标，并在必要时设置了它们的值。出口商负责剩下的部分。虽然我可能错过了很多细节，但这种最初的体验使事情看起来更容易开始，这对刚刚开始使用这种仪器的人来说非常好。</p><p id="dd55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我也意识到这个项目仍然处于相对早期的阶段。例如，在我写这篇文章时，没有可用的Stackdriver度量导出器。已经为(至少)Go和Node.js编写了跟踪导出器，但是还没有度量标准。因此，在GCP上使用它将要求我使用这些<a class="ae jd" href="https://cloud.google.com/monitoring/kubernetes-engine/prometheus#configuration" rel="noopener ugc nofollow" target="_blank">指令</a>来设置普罗米修斯/Stackdriver集成</p><p id="d843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我非常喜欢学习如何使用OpenTelemetry来创建定制的度量遥测技术——使用它来检测我的应用程序以暴露“黄金信号”非常简单，这在很大程度上要归功于OpenTelemetry Github repo中提供的优秀示例。感谢您的阅读——下次当我尝试使用OpenTelemetry将跟踪和日志集成到Stackdriver中时再来！</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="cc76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【http://github.com】最初发表于<a class="ae jd" href="https://gist.github.com/20e9affa4aaf2ba8adf413ca72ab5b76" rel="noopener ugc nofollow" target="_blank"><em class="kq"/></a><em class="kq">。</em></p></div></div>    
</body>
</html>