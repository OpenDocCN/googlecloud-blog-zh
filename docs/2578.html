<html>
<head>
<title>How do you use Feature Store in the MLOps process on Vertex AI?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Vertex AI上的MLOps过程中使用特征存储？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-do-you-use-feature-store-in-the-mlops-process-on-vertex-ai-802ddca2cac4?source=collection_archive---------0-----------------------#2022-12-01">https://medium.com/google-cloud/how-do-you-use-feature-store-in-the-mlops-process-on-vertex-ai-802ddca2cac4?source=collection_archive---------0-----------------------#2022-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/879e6c8be4960cdd419cae9a7ed3584d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d3FLiZAJ5kJnykdn"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1 — Vertex AI问答系列徽标</figcaption></figure><p id="e5ed" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Google Cloud CloudAir网络研讨会上@ MLOps的一个问题是:</p><blockquote class="jt"><p id="2645" class="ju jv hi bd jw jx jy jz ka kb kc jr dx translated">如何在Vertex AI上的MLOps过程中使用特征存储？</p></blockquote><p id="176a" class="pw-post-body-paragraph iu iv hi iw b ix kd iz ja jb ke jd je jf kf jh ji jj kg jl jm jn kh jp jq jr hb bi translated">因为不是第一次收到这个问题，所以以此为契机，写<a class="ae js" rel="noopener" href="/@ivannardini/got-a-vertex-ai-question-ask-and-ill-try-to-help-724e69513519">顶点AI Q &amp; A系列</a>第1篇，说说Vertex AI上沿着MLOps进程的特征库的作用。根据<a class="ae js" href="https://cloud.google.com/resources/mlops-whitepaper" rel="noopener ugc nofollow" target="_blank">这份白皮书</a>，MLOps流程中可能涉及到功能商店的步骤如下:</p><ul class=""><li id="14a7" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">模型实验，包括特征工程和模型训练</li><li id="5589" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">持续培训</li><li id="f8d1" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">在线预测</li></ul><p id="5c83" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我将详细讨论特征商店如何在银行场景中预测欺诈交易的每个步骤<a class="ae js" href="https://github.com/GoogleCloudPlatform/fraudfinder/tree/main" rel="noopener ugc nofollow" target="_blank">中发挥作用。而且我会使用</a><a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore" rel="noopener ugc nofollow" target="_blank"> Vertex AI功能商店</a>，Google Cloud上完全托管的功能商店服务。有了它，我将能够提供代码样本，并利用它与Vertex AI服务的集成来说明一些概念，并演示功能商店如何支持和改进您在Google Cloud上的MLOps流程。</p><h1 id="d336" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">模型实验和功能存储:存储、监控和消费您的功能</h1><h1 id="bcc7" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">特征工程和特征存储</h1><p id="4830" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">通常，在开发ML模型之前，您需要构建特征。</p><p id="99cf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">在规模上，您可能在几个团队中为许多不同的ML应用程序拥有相同的特性</strong>。</p><p id="aa1d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，<strong class="iw hj">在一家银行公司</strong>中，您可能拥有<em class="lz">customer _ nb _ tx _ last _ month</em>特性，了解每个客户上个月的交易数量。该功能可用于构建FraudFinder团队的欺诈检测ML模型和LoanAnalyzer团队的贷款资格ML模型</p><p id="c26e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不同的团队也可能构建不同的特性来表达相同的属性或特征。</p><p id="1137" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">在我们的银行公司</strong>，您可能有不同的数据科学家使用不同的公式计算<em class="lz">终端_风险_指数_上月</em>特征，该特征是关于终端暴露于欺诈交易的风险指数。</p><p id="f575" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了避免在不同的团队中多次计算相同的特性，并保证特性的一致性，你可以决定引入一个特性库。功能存储是存储、组织和共享这些功能的存储库。该存储库从数据管道(批处理和流)中获取特征，每次原始数据可用时，数据管道都会计算特征。它使你的特性可以被不同的团队发现和重用。一旦摄入，特征库允许您搜索和过滤特征，更重要的是，<strong class="iw hj">特征库允许您通过监控特征的分布来跟踪特征，并随着时间的推移检测异常</strong>。</p><p id="804d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事实上，一旦你有了新的数据，你就可以计算新的特征。但是因为数据可能会随着时间发生显著变化(<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore/overview#detect_drift" rel="noopener ugc nofollow" target="_blank">漂移</a>)，所以您需要监控特性分布，并识别潜在的特性分布变化，这些变化会影响使用这些特性的下游模型的性能。</p><p id="5885" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">在欺诈检测场景中，</strong>想象一下，如果银行由于新的营销活动而在一个地区收集新客户，导致<em class="lz">地区</em>特征分布发生变化。现在，让我们假设您训练了一个ML模型，由于示例数量有限，该模型在该地区表现不佳。但是整体性能足够好，足以说服您的团队将其投入生产。在这种情况下，当新的欺诈交易在该地区发生时，您和您的团队需要一些时间来澄清为什么在没有要素存储的情况下整体模型性能会显著下降，该要素存储允许您快速监控要素分布，例如在这种情况下的地区。</p><p id="4402" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面，您将看到功能商店如何跨多个团队提供存储、搜索和监控功能。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/1fdcf7fae5ec90106aea528a329339a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kkiHrxYN4n6xf071opdb-w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2 —模型开发和特性存储</figcaption></figure><p id="cd24" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">根据您的组织，您可能具有以下使用功能存储的角色:</p><ul class=""><li id="72c2" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">平台管理员，负责管理功能存储及其操作，如创建数据模型、定义功能访问或监控策略</li><li id="a99e" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">数据工程师负责通过数据管道创建要素并将其发布到要素存储中</li><li id="5cd7" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">数据分析师、数据科学家和机器学习工程师，他们从特征存储中定义和使用特征，用于训练和服务ML模型</li></ul><p id="d945" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你是一名数据科学家，你可以很容易地从谷歌云上Vertex AI特征商店中的熊猫数据帧中提取你的特征。事实上，一旦新的要素存储资源可用，您就可以使用Vertex AI Python SDK中的以下代码:</p><pre class="mb mc md me fd mf mg mh bn mi mj bi"><span id="ec2d" class="mk kx hi mg b be ml mm l mn mo">from typing import List<br/>from pandas import DataFrame<br/>from google.cloud import aiplatform<br/><br/><br/>def ingest_features_df(<br/>    project: str,<br/>    location: str,<br/>    featurestore_id: str,<br/>    entity_type_id: str,<br/>    features_ids: List[str],<br/>    feature_time: str,<br/>    features_df: DataFrame,<br/>    entity_id_field: str<br/>) -&gt; aiplatform.featurestore.EntityType:<br/>    """<br/>    Ingests features into a Featurestore from a Pandas DataFrame.<br/>    Args:<br/>        project: The Google Cloud project ID.<br/>        location: The Google Cloud location.<br/>        featurestore_id: The Featurestore ID.<br/>        entity_type_id: The Entity Type ID.<br/>        features_ids: The list of Feature IDs.<br/>        feature_time: The Feature timestamp.<br/>        features_df: The Pandas DataFrame containing the features.<br/>        entity_id_field: The Entity ID field.<br/>    Returns:<br/>        None<br/>    """<br/>    # Initialize the Vertex SDK for Python<br/>    aiplatform.init(project=project, location=location)<br/><br/>    # Get the entity type from an existing Featurestore<br/>    entity_type = aiplatform.featurestore.EntityType(entity_type_id=entity_type_id,<br/>                                                     featurestore_id=featurestore_id)<br/>    # Ingest the features<br/>    entity_type.ingest_from_df(<br/>        feature_ids=features_ids,<br/>        feature_time=feature_time,<br/>        df_source=features_df,<br/>        entity_id_field=entity_id_field<br/>    )<br/><br/>    return entity_type</span></pre><p id="5fc6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在哪里</p><ul class=""><li id="8b77" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated"><em class="lz">feature _ id</em>是您想要导入值的特性的唯一标识符</li><li id="30f8" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="lz"> feature_time </em>是保存每个实体的特征时间戳的列</li><li id="112e" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="lz"> features_df </em>是包含你特征的熊猫数据框</li><li id="cb64" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="lz"> entity_id_field </em>是保存相关功能组的唯一标识符的列</li></ul><p id="9a54" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面你可以看到在我们的欺诈检测场景中，Vertex AI功能商店中的功能是什么样子的。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/8cb8d1165878281fae4a84821616ff38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXtJMAHmFdabBsdWKLNi5g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3 —按实体类型过滤的特征存储和特征视图</figcaption></figure><p id="bf68" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，如果启用了特征值监控，顶点AI功能还将允许跟踪特征值分布随时间变化的程度，如<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore/monitoring#feature" rel="noopener ugc nofollow" target="_blank">文档</a>中所述。</p><p id="1192" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，如果启用了特征值监控，顶点AI功能还将允许跟踪特征值分布随时间变化的程度，如<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore/monitoring#feature" rel="noopener ugc nofollow" target="_blank">文档</a>中所述。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/4f0a081f6c79798a75feffdd7de38f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JLeZOtCOPes35wVY"/></div></div></figure><p id="2797" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您知道了功能存储使功能可重用，并且有助于监控它们。但是你可能会问:</p><blockquote class="jt"><p id="fd11" class="ju jv hi bd jw jx jy jz ka kb kc jr dx translated"><em class="mr">“你提到过，当我需要将功能扩展到许多用例时，可以使用功能库。</em> <strong class="ak"> <em class="mr">然而，如果不是这样呢？一个特征库还能对训练ML模型有用吗？”</em>T15】</strong></p></blockquote><p id="47b9" class="pw-post-body-paragraph iu iv hi iw b ix kd iz ja jb ke jd je jf kf jh ji jj kg jl jm jn kh jp jq jr hb bi translated">是的，会的。事实上，特征库解决的另一个挑战是可能影响模型的数据泄漏或目标泄漏。</p><h1 id="8090" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">模型训练和特征存储</h1><p id="4313" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">在实时场景中，您会不断获得新数据来重构要素，但在收集您想要预测的标注之前需要一些时间。</p><p id="7062" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">回到欺诈检测场景</strong>，假设您有每个终端每小时的交易数量<em class="lz">terminal _ nb _ tx _ last _ month</em>作为特征。您可以每小时收集一次新的交易，并因此每天计算24次新的特征值。但是，在您建立的模型预测到某项交易是欺诈性的之后，调查将会开始，这将需要时间来确认该交易是否确实是欺诈。</p><p id="129d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这些情况下，<strong class="iw hj">用于训练模型的训练数据集只有在包含根据观察标签之前而非之后的可用数据计算的特征时才有效。</strong>根据收集目标后的可用数据计算的任何特征都不能正确表示预测目标变量的特征值。这是因为您将使用仅在采集标注后才可用的特征值来构建模型。换句话说，你可以用<a class="ae js" href="https://cloud.google.com/blog/topics/developers-practitioners/kickstart-your-organizations-ml-application-development-flywheel-vertex-feature-store" rel="noopener ugc nofollow" target="_blank">【未来预测现在】</a>。因此，可能会出现这样的情况:您的模型在培训期间表现良好，但在投入生产时表现不佳，从而产生<a class="ae js" href="https://developers.google.com/machine-learning/guides/rules-of-ml#:~:text=Training%2Dserving%20skew%20is%20a,train%20and%20when%20you%20serve." rel="noopener ugc nofollow" target="_blank">培训服务偏差</a>。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/831be896d365baa4415ec61a724b552a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lAOko33-YV4NjQ1v"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4 —图片中的数据泄漏</figcaption></figure><p id="d1d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">在我们使用<em class="lz">terminal _ nb _ tx _ last _ month</em>功能的欺诈检测场景</strong>中，如果我们假设它与我们的<em class="lz"> is_fraud </em>目标高度正相关，那么在生产中，模型将倾向于预测更多的欺诈交易，而不仅仅是因为我们将错误的特征值与我们的标签相关联。这就是生产数据泄漏会导致模型精度下降的原因。</p><p id="a242" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">有了特征库，你就可以防止训练和发球偏斜。要素存储允许您通过使用时间点查询在标注变得可用之前获取随时间计算的要素的最新视图。时间点查询通过防止未来特征值的泄漏来检索到您收集标签时为止的每个记录的特征值。因此，生成的训练数据集将包含观察到的标注的代表性特征值。</strong></p><p id="9360" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面，您将了解功能存储如何允许您使用时间点查询生成训练数据集。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/d502e72401f34f797722fd670a570704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHPwOxJdaU8T0V1KVr8glA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图5 —模型训练和特征存储</figcaption></figure><p id="02f1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">用</strong> <a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">顶点AI特征库</strong> </a> <strong class="iw hj">做时间点查询相当简单。</strong>当你需要训练你的模型时，你可以使用<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore#use-vertex-ai-feature-store" rel="noopener ugc nofollow" target="_blank">特征库SDK </a>来<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore/serving-batch" rel="noopener ugc nofollow" target="_blank">获取</a>特征，并将它们物化在一个数据帧中。下面是示例代码。</p><pre class="mb mc md me fd mf mg mh bn mi mj bi"><span id="8a50" class="mk kx hi mg b be ml mm l mn mo"><br/>from typing import Dict, List<br/>from pandas import DataFrame<br/>from google.cloud import aiplatform<br/><br/><br/>def batch_serve_features_df(<br/>        project: str,<br/>        location: str,<br/>        featurestore_id: str,<br/>        serving_feature_ids: Dict[str, List[str]],<br/>        read_instances_df: DataFrame,<br/>        pass_through_fields: List[str]) -&gt; DataFrame:<br/>    """<br/>    Retrieves batch feature values from a Featurestore and writes them to a GCS bucket.<br/>    Args:<br/>        project: The Google Cloud project ID.<br/>        location: The Google Cloud location.<br/>        featurestore_id: The Featurestore ID.<br/>        serving_feature_ids: The dictionary of Entity Type IDs and Feature IDs to retrieve.<br/>        read_instances_df: The Pandas DataFrame containing entities and feature values.<br/>        pass_through_fields: The list of fields to pass through extra to the label column.<br/>    Returns:<br/>        The Pandas DataFrame containing the dataset.<br/>    """<br/><br/>    # Initialize the Vertex SDK for Python<br/>    aiplatform.init(project=project, location=location)<br/><br/>    # Get an existing Featurestore<br/>    featurestore = aiplatform.featurestore.Featurestore(featurestore_name=featurestore_id)<br/><br/>    # Get data with a point-in-time query from the Featurestore<br/>    df = featurestore.batch_serve_to_df(<br/>        serving_feature_ids=serving_feature_ids,<br/>        read_instances_df=read_instances_df,<br/>        pass_through_fields=pass_through_fields<br/>    )<br/><br/>    return df</span></pre><p id="6142" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在哪里</p><ul class=""><li id="c786" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated"><em class="lz">serving _ feature _ id</em>是要从特征库中获取的特征，</li><li id="102b" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="lz"> read_instances_df </em>是Pandas数据帧，带有目标变量、服务时间戳和您要用来读取的实体。</li><li id="63f7" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="lz"> pass_through_fields </em>是你想从实例数据帧中读取的任何其他变量。</li></ul><p id="4a1f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用这种方法，您可以执行高效的时间点查找，并将要素存储中所有必需的要素值连接到标注(和其他变量)以创建正确的数据集来训练您的模型。</p><h1 id="e8cc" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">持续培训和功能商店:满足您的培训需求</h1><p id="584b" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">训练ML模型是一项重复的任务。为了自动化该任务并持续训练您的模型，您构建ML管道。ML管道允许您结合一些触发器来编排和自动化您的模型训练。</p><p id="6678" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">每次ML管道被触发时，它需要接收新的训练数据。在拥有要素存储的情况下，您可以通过运行时间点查询来创建训练数据集，该时间点查询将根据您收集标注的时间来检索要素。</strong></p><p id="a13f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">根据您将如何自动化您的训练，一种可能性是在您的ML管道中创建一个摄取组件，它将从特征存储中获取特征并使用它们来训练您的ML模型。下面您可以看到如何触发新的ML管道，该管道使用由功能存储中的时间点查询创建的训练数据集。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/0f5d84a31575e071fb80fbbb0d3b819e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSpuXPpmCyuGSruHHpyLbA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图6 —持续培训和特征库</figcaption></figure><p id="d613" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Vertex AI上，你使用<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/pipelines/introduction" rel="noopener ugc nofollow" target="_blank"> Vertex AI Pipelines </a>使用Kubeflow Pipelines (KFP)或Tensorflow Extended (TFX) DSL以无服务器方式运行ML管道。这些框架允许您构建一个摄取组件来实现时间点逻辑。下面您可以看到摄取管道组件的伪代码，您可以在我们的欺诈检测场景中使用KFP构建该组件。</p><pre class="mb mc md me fd mf mg mh bn mi mj bi"><span id="8855" class="mk kx hi mg b be ml mm l mn mo">from kfp.v2.dsl import component<br/>from typing import NamedTuple<br/><br/><br/>@component(output_component_file="batch_serve_features_gcs.yaml",<br/>           base_image="python:3.9",<br/>           packages_to_install=["google-cloud-aiplatform"])<br/>def batch_serve_features_gcs(feature_store_id: str,<br/>                             gcs_destination_output_uri_prefix: str,<br/>                             gcs_destination_type: str,<br/>                             serving_feature_ids: str,<br/>                             read_instances_uri: str,<br/>                             project: str,<br/>                             location: str) -&gt; NamedTuple("Outputs", [("gcs_destination_output_uri_paths", str)]):<br/>    # Import libraries<br/>    import os<br/>    from json import loads<br/>    from google.cloud import aiplatform<br/>    from google.cloud.aiplatform.featurestore import Featurestore<br/><br/>    # Initialize Vertex AI client<br/>    aiplatform.init(project=project, location=location)<br/><br/>    # Initiate feature store and run batch serve request<br/>    featurestore = Featurestore(featurestore_name=feature_store_id)<br/><br/>    # Serve features in batch on GCS<br/>    serving_feature_ids = loads(serving_feature_ids)<br/>    featurestore.batch_serve_to_gcs(<br/>        gcs_destination_output_uri_prefix=gcs_destination_output_uri_prefix,<br/>        gcs_destination_type=gcs_destination_type,<br/>        serving_feature_ids=serving_feature_ids,<br/>        read_instances_uri=read_instances_uri<br/>    )<br/><br/>    # Store metadata<br/>    gcs_destination_output_path_prefix = gcs_destination_output_uri_prefix.replace("gcs://", "/gcs/")<br/>    gcs_destination_output_paths = os.path.join(gcs_destination_output_path_prefix, "*.csv")<br/>    component_outputs = NamedTuple("Outputs",<br/>                                   [("gcs_destination_output_uri_paths", str), ], )<br/><br/>    return component_outputs(gcs_destination_output_paths)</span></pre><p id="1254" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该组件利用<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore/serving-batch#batch_serve_feature_values" rel="noopener ugc nofollow" target="_blank"> Vertex AI Python SDK </a>从Vertex AI特征存储中批量提供特征值以获取数据。作为输入，它采用包含新标签的表的BigQuery URI，作为输出，它返回可用于创建顶点AI数据集资源的URIs列表。通过这种方式，您可以将与新训练数据相关联的所有元数据存储在Vertex AI ML元数据中，以实现可再现性。</p><h1 id="1841" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在线预测和特征存储:为您的特征服务</h1><p id="0f73" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">让我们假设您有一个ML管道，它从一个特征库中获取特征并训练您的模型。现在您已经有了模型，您想部署它来生成实时预测。可以想象，每次新的预测请求到来时，您都需要传递模型期望接收的特征值作为输入，以生成实时预测。</p><p id="2a38" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在某些情况下，<a class="ae js" href="https://learning.oreilly.com/library/view/machine-learning-design/9781098115777/ch06.html" rel="noopener ugc nofollow" target="_blank">可能希望计算、存储特性并使其可用于低延迟的传入预测请求，而不是创建实时特性管道</a>、<strong class="iw hj">。</strong>例如，FraudFinder团队会考虑在数据仓库而不是流数据管道中计算<em class="lz"> customer_nb_tx_last_day </em>特征(过去一整天的交易数量)。在那些在服务器端计算特性的场景中，BigQuery之类的数据仓库没有经过优化，无法大规模地实时提供服务。这就是为什么您需要一个不同的服务，该服务允许功能查找，并为每个数据实体(如欺诈检测用例中的客户或终端)返回一个包含许多列的单行。</p><p id="3c6a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，<a class="ae js" href="https://towardsdatascience.com/do-you-really-need-a-feature-store-e59e3cc666d3" rel="noopener" target="_blank">即使您可以在部署模型</a>时计算特性，您也需要确保重现您在训练模型时的相同预处理步骤。如果您不能做到这一点，训练数据和服务数据之间可能会再次出现偏差，这可能会严重影响您的模型性能。为了减轻这种偏差，您可以在线消除预处理步骤，并且<strong class="iw hj">提供您在训练期间已经拥有的相同聚合特征来生成在线预测。</strong></p><p id="b1e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">这两种场景都为引入功能商店提供了有价值的理由，在功能商店中，您拥有一项服务，可帮助您以低延迟的规模提供培训时可用的相同聚合功能。因为它提供了与你训练你的ML模型相同的特性，它有助于减轻可能的训练服务偏差。</strong></p><p id="b48e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下图中，您可以看到要素存储如何允许用户提供用于生成在线预测的要素。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/96bc945985072c8044fb71a2683bf8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bTIso1MDRdkX1FM85L_qw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图7 —预测服务和特征存储</figcaption></figure><p id="7e4a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过使用Vertex AI Python SDK，您可以轻松地将要素服务集成到服务中。以下是如何应用read方法从Vertex AI要素库中检索要素的简单示例。</p><pre class="mb mc md me fd mf mg mh bn mi mj bi"><span id="43b3" class="mk kx hi mg b be ml mm l mn mo">from typing import List<br/>from pandas import DataFrame<br/>from google.cloud import aiplatform<br/><br/><br/>def online_serve_feature_values(<br/>        project: str,<br/>        location: str,<br/>        featurestore_id: str,<br/>        entity_type_id: str,<br/>        entity_ids: List[str],<br/>        feature_ids: List[str]) -&gt; DataFrame:<br/>    """<br/>    Retrieves online feature values from a Featurestore.<br/>    Args:<br/>        project: The Google Cloud project ID.<br/>        location: The Google Cloud location.<br/>        featurestore_id: The Featurestore ID.<br/>        entity_type_id: The Entity Type ID.<br/>        entity_ids: The list of Entity IDs.<br/>        feature_ids: The list of Feature IDs.<br/>    Returns:<br/>        A Pandas DataFrame containing the feature values.<br/>    """<br/><br/>    # Initialize the Vertex SDK for Python<br/>    aiplatform.init(project=project, location=location)<br/><br/>    # Get the entity type from an existing Featurestore<br/>    entity_type = aiplatform.featurestore.EntityType(entity_type_id=entity_type_id,<br/>                                                     featurestore_id=featurestore_id)<br/>    # Retrieve the feature values<br/>    feature_values = entity_type.read(entity_ids=entity_ids, feature_ids=feature_ids)<br/><br/>    return feature_values</span></pre><p id="9172" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在哪里</p><ul class=""><li id="d8bd" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated"><em class="lz"> entity_ids </em>是相关特征组的标识符列表</li><li id="c00b" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="lz"> features_ids </em>是您想要检索的特征标识符的列表</li></ul><p id="8e13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该方法返回每个要素的最新值，这意味着默认情况下会返回具有最新时间戳的要素值。</p><h1 id="1693" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="f4d7" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">在<a class="ae js" href="https://cloudonair.withgoogle.com/events/innovators-mlops-on-google-cloud" rel="noopener ugc nofollow" target="_blank"> Google Cloud CloudAir网络研讨会</a>上，有一个问题是:</p><blockquote class="jt"><p id="4989" class="ju jv hi bd jw jx jy jz ka kb kc jr dx translated">如何在Vertex AI上的MLOps过程中使用特征存储？</p></blockquote><p id="566c" class="pw-post-body-paragraph iu iv hi iw b ix kd iz ja jb ke jd je jf kf jh ji jj kg jl jm jn kh jp jq jr hb bi translated">根据我的学习和经验，我认为以下是MLOps流程中可能涉及到功能库的步骤:</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/0216ae2d6d87b0178408019f605fc47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOOAizzypP9Qh2AfPz2Z1w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图8-如何在Vertex AI上的MLOps过程中使用特征库？</figcaption></figure><p id="8da7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">重要的是，并不是所有的ML场景都需要一个特性库。我建议参考Lak Lakshmanan的这篇文章来评估你是否真的需要一个功能商店。</p><h1 id="e00a" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">下一步是什么</h1><p id="4277" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">我希望你能更好地理解Google Cloud上的MLOps过程中特性商店的作用。如果是这样，你可能想在Vertex AI上开始使用它。查看<a class="ae js" href="https://cloud.google.com/vertex-ai/docs/featurestore/overview" rel="noopener ugc nofollow" target="_blank">文档</a>和这个<a class="ae js" href="https://github.com/GoogleCloudPlatform/vertex-ai-samples/tree/main/notebooks/official/feature_store" rel="noopener ugc nofollow" target="_blank">库</a>以了解更多信息。如果你对Vertex AI的功能商店和任何其他服务有进一步的问题，请随时发表评论或在<a class="ae js" href="https://www.linkedin.com/in/ivan-nardini/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>或<a class="ae js" href="https://twitter.com/IlNardo92" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上联系。</p><p id="a8d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢<a class="mw mx ge" href="https://medium.com/u/4b21e207ea2c?source=post_page-----802ddca2cac4--------------------------------" rel="noopener" target="_blank"> Kaz Sato </a>、<a class="mw mx ge" href="https://medium.com/u/ac26de3bc89e?source=post_page-----802ddca2cac4--------------------------------" rel="noopener" target="_blank">Rajesh thal am</a>、<a class="mw mx ge" href="https://medium.com/u/8f61f3a4e09c?source=post_page-----802ddca2cac4--------------------------------" rel="noopener" target="_blank"> Gabriele Randelli </a>以及所有同事的反馈和建议。</p></div></div>    
</body>
</html>