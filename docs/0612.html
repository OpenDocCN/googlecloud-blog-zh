<html>
<head>
<title>Ethereum on Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云平台上的以太坊</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/ethereum-on-google-cloud-platform-8f10c82493ca?source=collection_archive---------0-----------------------#2018-05-22">https://medium.com/google-cloud/ethereum-on-google-cloud-platform-8f10c82493ca?source=collection_archive---------0-----------------------#2018-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1bb3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">谷歌云平台上的区块链平台</h2></div><p id="8c85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谷歌的超高速网络、强大的虚拟机和固态硬盘加上其最先进的容器技术，使谷歌云平台(GCP)成为区块链平台无与伦比的目的地。</p><p id="6fe2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在确保开发者意识到这一点方面，谷歌可以做得更好。</p><p id="13c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">去年年底，我写了一篇文章，描述了如何将以太坊部署到GCP。从那时到今天，我没有用过以太坊。这篇文章更新了之前的文章，用更简单的方法在GCP上运行以太坊，使用:(a)容器优化的操作系统；(b)使用Kubernetes发动机。</p><p id="8d25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你需要一个GCP项目，并且有免费的选项。你需要安装<a class="ae jt" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank">云软件开发套件</a>(又名<code class="du ju jv jw jx b">gcloud</code>)。让我们开始吧。</p><h2 id="86ec" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">容器优化的操作系统</h2><p id="995c" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">容器优化操作系统允许您将Docker映像部署到Google计算引擎虚拟机。这是运行<code class="du ju jv jw jx b">ethereum/client-go</code>图像的最简单方式:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="c905" class="jy jz hi jx b fi lg lh l li lj">INSTANCE=[[YOUR-INSTANCE]] # cos-ethereum<br/>ZONE=[[YOUR-ZONE]]         # us-west1-c<br/>PROJECT=[[YOUR-PROJECT]]</span><span id="d9ab" class="jy jz hi jx b fi lk lh l li lj">gcloud beta compute instances create-with-container ${INSTANCE} \<br/>--boot-disk-size=500GB \<br/>--boot-disk-type=pd-ssd \<br/>--container-image=ethereum/client-go \<br/>--container-arg="--rpc" \<br/>--container-arg="--rpcaddr=0.0.0.0" \<br/>--container-restart-policy=always \<br/>--container-mount-host-path=\<br/>mount-path=/root,\<br/>host-path=/tmp/client-go,\<br/>mode=rw \<br/>--image-family=cos-stable \<br/>--image-project=cos-cloud \<br/>--zone=${ZONE} \<br/>--project=${PROJECT}</span></pre><blockquote class="ll lm ln"><p id="8763" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>为了避免耗尽磁盘，容器使用500GB(整个默认配额)的SSD永久存储。根据您的喜好，减少<code class="du ju jv jw jx b">boot-disk-size</code>或将<code class="du ju jv jw jx b">boot-disk-type</code>改为pd标准。</p><p id="285d" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>如果您希望使用<strong class="iz hj">测试</strong>网络，请在现有的<code class="du ju jv jw jx b">— container-arg</code>标志前添加<code class="du ju jv jw jx b">— container-arg="— testnet”</code>。如果您更喜欢使用标记，请在现有的<code class="du ju jv jw jx b">--container-arg</code>标记之前添加<code class="du ju jv jw jx b">— container-arg=" — rinkeby"</code>。</p></blockquote><p id="29c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虚拟机应该在30秒内运行，您可以使用以下命令查看其状态:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="0830" class="jy jz hi jx b fi lg lh l li lj">gcloud compute ssh ${INSTANCE} \<br/>--command="sudo journalctl --unit=konlet-startup --follow" \<br/>--project=${PROJECT}</span></pre><blockquote class="ll lm ln"><p id="7cb8" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong> <code class="du ju jv jw jx b">konlet-startup</code>是容器优化OS中对应Docker镜像部署的systemd服务。</p></blockquote><p id="f898" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成功看起来像:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="3000" class="jy jz hi jx b fi lg lh l li lj">Created a container with name 'cos-ethereum' and ID: fdd6...<br/>Starting a container with ID: fdd6...<br/>Saving welcome script to profile.d</span></pre><p id="274a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以确认容器正在运行:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="9445" class="jy jz hi jx b fi lg lh l li lj">gcloud compute ssh ${INSTANCE} \<br/>--command="docker ps --format='[{{.ID}}] {{.Names}}: {{.Status}}'" \<br/>--project=${PROJECT}</span><span id="94c3" class="jy jz hi jx b fi lk lh l li lj">[a8c710e75ae3] cos-ethereum: Up 8 minutes</span></pre><p id="a7a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，您可以使用<code class="du ju jv jw jx b">gcloud</code>启动<code class="du ju jv jw jx b">ssh</code>端口转发到实例:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="483a" class="jy jz hi jx b fi lg lh l li lj">gcloud compute ssh ${INSTANCE} \<br/>--ssh-flag="-L 8545:localhost:8545" \<br/>--project=${PROJECT}</span></pre><p id="cf3c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从不同的shell中，您可以连接到实例上运行的以太坊节点:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="3c58" class="jy jz hi jx b fi lg lh l li lj">docker run \<br/>--rm \<br/>--interactive \<br/>--net=host \<br/>--tty \<br/>ethereum/client-go \<br/>  attach <a class="ae jt" href="http://localhost:8545" rel="noopener ugc nofollow" target="_blank">http://localhost:8545</a></span></pre><p id="5ee6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将产生:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="4bd9" class="jy jz hi jx b fi lg lh l li lj">Welcome to the Geth JavaScript console!</span><span id="69d1" class="jy jz hi jx b fi lk lh l li lj">instance: Geth/v1.8.9-unstable-0fe47e98/linux-amd64/go1.10.2<br/> modules: eth:1.0 net:1.0 rpc:1.0 web3:1.0</span><span id="eee0" class="jy jz hi jx b fi lk lh l li lj">&gt;</span></pre><p id="13e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在GCP上运行以太坊利用了谷歌云日志。您将能够自动查看和查询日志。</p><p id="28bd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">https://console.cloud.google.com/logs/viewers</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ls"><img src="../Images/5fbc32936190ab9366c17e1c03151bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQJWFL6oHM8c0pulYgVkXg.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">Stackdriver日志记录“全局:gcplogs-docker-driver”</figcaption></figure><blockquote class="ll lm ln"><p id="5714" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>略带迷惑地(！)，您必须选择“Global”作为资源，然后您应该看到“gcplogs-docker-driver”作为选项。如上所述，这将提供容器的日志。</p></blockquote><p id="4cfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您通过云控制台看到的一切也可以从CLI访问。在这种情况下，您可以运行以下命令来查看容器的日志:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="838f" class="jy jz hi jx b fi lg lh l li lj">FILTER="resource.type=\"global\" "\<br/>"logName=\"projects/${PROJECT}/logs/gcplogs-docker-driver\" "</span><span id="a797" class="jy jz hi jx b fi lk lh l li lj">gcloud logging read "${FILTER}" \<br/>--project=$PROJECT \<br/>--format="value(jsonPayload.data)" \<br/>--order=asc</span></pre><p id="cc5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该记录如下条目:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="d8fc" class="jy jz hi jx b fi lg lh l li lj">INFO [05-23|00:47:38] Imported new state entries               count=1920 elapsed=8.560ms   processed=2993520 pending=6080  retry=0    duplicate=31 unexpected=283<br/>INFO [05-23|00:47:39] Imported new state entries               count=1920 elapsed=110.058ms processed=2995440 pending=5488  retry=0    duplicate=31 unexpected=283<br/>INFO [05-23|00:47:39] Imported new state entries               count=1306 elapsed=11.663ms  processed=2996746 pending=6196  retry=0    duplicate=31 unexpected=283<br/>INFO [05-23|00:47:39] Imported new block receipts              count=691  elapsed=286.192ms number=1358549 hash=3633f9…19e595 size=1.94mB   ignored=0<br/>...<br/>...<br/>Fatal: Error starting protocol stack: write /root/.ethereum/rinkeby/geth/chaindata/004464.ldb: no space left on device<br/>Fatal: Error starting protocol stack: write /root/.ethereum/rinkeby/geth/chaindata/004464.ldb: no space left on device</span></pre><p id="a49a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>你不想要的是“设备上没有剩余空间”形式的日志条目，因为它们终止了容器。如果你收到这些，你需要增加<code class="du ju jv jw jx b">boot-disk-size</code>标志的大小或者抓取更少的数据。</p><p id="8781" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还可以获得对虚拟机的基本监控，而不是对容器的监控。</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es me"><img src="../Images/2292cc4ceaad937e4339987e85ea9e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYR5E2KZKBoTwwFL2u3Ehg.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">Stackriver监控</figcaption></figure><p id="364c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以<code class="du ju jv jw jx b">exit</code>使用JavaScript控制台删除以太坊虚拟机:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="3a72" class="jy jz hi jx b fi lg lh l li lj">gcloud compute instances delete ${INSTANCE} \<br/>--zone=${ZONE} \<br/>--project=${PROJECT}</span></pre><h2 id="be09" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">库伯内特发动机</h2><p id="b4d1" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">如果您喜欢使用Kubernetes(引擎)集群，命令也很简单。</p><p id="8bab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您通过了集群的身份验证，以下步骤将为以太坊创建一个名称空间，创建一个磁盘(实际上是一个Kubernetes PersistentVolumeClaim)，部署一个Go以太坊(又名“geth”)节点，并将其端口转发到您的本地工作站，以便您可以连接到它:</p><figure class="ky kz la lb fd lt"><div class="bz dy l di"><div class="mf mg l"/></div></figure><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="a290" class="jy jz hi jx b fi lg lh l li lj">NAMESPACE=ethereum<br/>kubectl create namespace ${NAMESPACE}<br/>kubectl apply --filename=deployment.yaml --namespace=${NAMESPACE}</span></pre><blockquote class="ll lm ln"><p id="e313" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>如果您更喜欢使用<strong class="iz hj">测试</strong>网络，请在第33–34行之间插入<code class="du ju jv jw jx b">"--testnet"</code>(包括引号)。如果您更喜欢使用Rinkeby network，请插入<code class="du ju jv jw jx b">"--rinkeby"</code>。</p></blockquote><p id="acfc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将导致:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="6ba9" class="jy jz hi jx b fi lg lh l li lj">persistentvolumeclaim "ethereum" created<br/>deployment.extensions "ethereum" created<br/>service "ethereum" created</span></pre><p id="91b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该能够看到创建的持久卷声明:</p><p id="705b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://console.cloud.google.com/kubernetes/storage?project=dazwilkin-180520-lucky" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/kubernetes/storage</a></p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mh"><img src="../Images/1ffeaa3be52e946aafb90ea1cfae9ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIC4Ucu8bs-MA7yDSoFOUA.png"/></div></div></figure><p id="6f6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以及部署:</p><p id="34e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://console.cloud.google.com/kubernetes/workload?project=dazwilkin-180520-lucky" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/kubernetes/workload</a></p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mi"><img src="../Images/77cb31bd75ce327546fd4c1328da5860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iy-AqAQfIuQ6xSL3sRhzOg.png"/></div></div></figure><p id="356c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在GCP上运行以太坊会自动产生一些有用的好处，包括控制台监控:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ls"><img src="../Images/97eebb8469dbdaa2d43abdde16ca5b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYop2F7iDUp6WVpreddlJQ.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">云控制台:Kubernetes</figcaption></figure><p id="c19f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">日志记录:</p><p id="c0e0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://console.cloud.google.com/logs/viewer" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/logs/viewer</a></p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mj"><img src="../Images/45aeac66a82893a5eaee76a95ddb1a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pc93npyXpCX1wxatRmMKZw.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">堆栈驱动程序日志:GKE集装箱</figcaption></figure><p id="75aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些Stackdriver优点(尽管最近宣布的<a class="ae jt" href="https://cloud.google.com/kubernetes-monitoring/" rel="noopener ugc nofollow" target="_blank"> Stackdriver Kubernetes监控</a>-在该集群上未启用)甚至更好。如果您还没有为项目配置Stackdriver，那么您需要首先这样做，并且您可以使用免费层:</p><p id="815e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://console.cloud.google.com/monitoring" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/monitoring</a></p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mk"><img src="../Images/0851771560faf29383dda4452f4e6de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApLXIKJbSA33J9c2EVgoIw.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">Stackdriver监控:Kubernetes引擎集群</figcaption></figure><p id="d479" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用ssh端口转发(通过<code class="du ju jv jw jx b">gcloud</code>)从我们的工作站访问Go Ethereum节点，而不打开防火墙。</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="5a81" class="jy jz hi jx b fi lg lh l li lj">SERVICE=ethereum<br/>NAMESPACE=ethereum</span><span id="c106" class="jy jz hi jx b fi lk lh l li lj">NODE=$(\<br/>  kubectl get nodes \<br/>  --output=jsonpath='{.items[0].metadata.name}')</span><span id="b9ff" class="jy jz hi jx b fi lk lh l li lj">PORT=$(\<br/>  kubectl get services/${SERVICE} \<br/>  --namespace=${NAMESPACE} \<br/>  --output=jsonpath='{.spec.ports[?(@.name=="default")].nodePort}')</span><span id="ab44" class="jy jz hi jx b fi lk lh l li lj">echo ${PORT}</span><span id="6f3e" class="jy jz hi jx b fi lk lh l li lj">gcloud compute ssh ${NODE} \<br/>--ssh-flag="-L ${PORT}:localhost:${PORT}" \<br/>--project=${PROJECT}</span></pre><blockquote class="ll lm ln"><p id="e90d" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>这些看起来模糊不清的命令抓取了一个Kubernetes集群的节点名；确定以太坊服务在哪个节点端口上提供服务；然后使用<code class="du ju jv jw jx b">gcloud</code>将该节点的端口转发到本地主机的(相同)端口。如果您愿意，您可以使用— <code class="du ju jv jw jx b">ssh-flag=“-L 8545:localhost:${PORT}”</code>,然后在随后的命令中也用<code class="du ju jv jw jx b">8545</code>替换<code class="du ju jv jw jx b">${PORT}</code>。你的选择！</p><p id="4410" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>我的情况<code class="du ju jv jw jx b">echo ${PORT}</code>(这次)返回<code class="du ju jv jw jx b">30873</code>。</p></blockquote><p id="ae6b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，从本地工作站运行<code class="du ju jv jw jx b">geth</code> JavaScript客户机，并连接到Kubernetes集群上运行的节点:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="258f" class="jy jz hi jx b fi lg lh l li lj">docker run \<br/>--rm \<br/>--interactive \<br/>--tty  \<br/>--net=host \<br/>ethereum/client-go attach <a class="ae jt" href="http://localhost:31783" rel="noopener ugc nofollow" target="_blank">http://localhost:$</a>{PORT}</span></pre><blockquote class="ll lm ln"><p id="e298" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>在我这里，<code class="du ju jv jw jx b">${PORT}</code>的值是<code class="du ju jv jw jx b">30873</code>。</p></blockquote><p id="7f59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后你应该进入以太坊JavaScript控制台:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="252e" class="jy jz hi jx b fi lg lh l li lj">Welcome to the Geth JavaScript console!</span><span id="78e0" class="jy jz hi jx b fi lk lh l li lj">instance: Geth/v1.8.9-unstable-0fe47e98/linux-amd64/go1.10.2<br/> modules: eth:1.0 net:1.0 rpc:1.0 web3:1.0</span><span id="52f0" class="jy jz hi jx b fi lk lh l li lj">&gt;</span></pre><p id="2919" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成后，最简单的方法是删除Kubernetes名称空间，这将删除部署、服务和PeristentVolumeClaim声明:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="44c2" class="jy jz hi jx b fi lg lh l li lj">kubectl delete namespace ${NAMESPACE}</span></pre><h2 id="3ffb" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">撇开18-05-25不谈:钱包</h2><p id="0033" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">我发现了一个使用传递给Kubernetes(引擎)的钱包作为秘密的问题。使用Secrets(和ConfigMaps)向Pods提供数据被认为是Kubernetes的一个良好实践。但是，当(卷)装入pod时，Secrets和ConfigMaps的实现是将文件内容呈现为符号链接。这似乎是钱包和以太坊的问题:</p><p id="bc3e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://github.com/ethereum/go-ethereum/issues/16793" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/go-ethereum/issues/16793</a></p><p id="8123" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想在部署到Kubernetes时使用现有的wallet文件，这应该与创建一个秘密一样简单(您可以类似地使用ConfigMaps，但是秘密为…秘密和其他机密信息提供了不透明性),然后将秘密挂载为一个供以太坊节点访问的卷挂载。然而，如上所述，这对于以太坊是不正确的。因此，您将需要下面的“黑客工作区”中的额外步骤。</p><p id="64e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，创造秘密:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="6f53" class="jy jz hi jx b fi lg lh l li lj">kubectl create secret generic keystore \<br/>--from-file=PATH/TO/YOUR/keystore \<br/>--namespace=$NAMESPACE</span></pre><blockquote class="ll lm ln"><p id="1049" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>你的路径应该在一个名为<code class="du ju jv jw jx b">keystore</code>的目录中结束，这个目录和它的钱包将被编码成秘密。</p></blockquote><p id="b5d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的权宜之计是在以太坊节点启动之前，使用init容器将钱包从Secret(名为<code class="du ju jv jw jx b">/keystore</code>)复制到emptyDir(名为<code class="du ju jv jw jx b">/cache</code>)卷中，并配置以太坊在<code class="du ju jv jw jx b">/cache</code>而不是<code class="du ju jv jw jx b">/keystore</code>中寻找钱包(因为这不起作用)。这是因为复制符号链接会复制底层文件。</p><figure class="ky kz la lb fd lt"><div class="bz dy l di"><div class="mf mg l"/></div></figure><blockquote class="ll lm ln"><p id="12bb" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>参见下一节“固态硬盘”将<code class="du ju jv jw jx b">datadir</code>配置为固态硬盘而非硬盘。</p><p id="73ca" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">第31–39行创建一个名为<code class="du ju jv jw jx b">init-service</code>的初始化容器。<code class="du ju jv jw jx b">init-service</code>使用Alpine将<code class="du ju jv jw jx b">UTC*</code>格式的文件从<code class="du ju jv jw jx b">/keystore</code>复制到<code class="du ju jv jw jx b">/cache</code>。这些目录是卷挂载的。体积在第66–75行中定义(针对Pod而非特定容器)。<code class="du ju jv jw jx b">keystore</code>是否包含作为符号链接挂载的钱包文件的密码，如果直接使用，这些文件似乎无法与以太坊一起工作。<code class="du ju jv jw jx b">cache</code>是一个emptyDir卷，如果以太坊在复制到这里时使用钱包，它就可以工作！</p><p id="6442" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>在第46行，以太坊被配置为使用<code class="du ju jv jw jx b">/cache</code>目录来存放带有<code class="du ju jv jw jx b">--keystore=/cache</code>的钱包。</p></blockquote><h2 id="f1d6" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">（同solid-statedisk）固态（磁）盘</h2><p id="930f" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">上面使用的Kubernetes部署包括一个<code class="du ju jv jw jx b">PersistentVolumeClaim</code>规范，第7行定义了<code class="du ju jv jw jx b">standard</code>的<code class="du ju jv jw jx b">storageClassName</code>。这对应于常规<a class="ae jt" href="https://cloud.google.com/persistent-disk/" rel="noopener ugc nofollow" target="_blank">持久磁盘</a>。</p><p id="71d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您喜欢使用速度更快的固态硬盘，我们必须首先在Kubernetes引擎中注册新的存储类:</p><figure class="ky kz la lb fd lt"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="6545" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="7e33" class="jy jz hi jx b fi lg lh l li lj">kubectl apply --filename=ssd.yaml</span></pre><p id="121a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当您查询Kubernetes引擎存储类时，应该添加一个名为<code class="du ju jv jw jx b">ssd</code>的新类型<code class="du ju jv jw jx b">pd-ssd</code>:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ml"><img src="../Images/b3017c394d3f4eff86a29e843d9e3dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEOeR26BdnkhhgeN7HTXEg.png"/></div></div></figure><p id="8bdb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以修改部署文件的第7行，将<code class="du ju jv jw jx b">storageClassName: standard</code>改为<code class="du ju jv jw jx b">storageClassName: ssd</code>。</p><p id="e97e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GCP项目的默认“永久磁盘SSD (GB)”配额是每个分区500 GB。如果您没有增加这些配额，您将无法调配500 GiB(！)磁盘。因此，也请*将部署中第12行的值减少*到例如400Gi (~429GB)，这应该足够了*除非*您的项目中有其他SSD PD。或者，请求增加配额:</p><p id="3adc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://pantheon.corp.google.com/iam-admin/quotas?project=dazwilkin-180522-ethereum&amp;folder&amp;organizationId=433637338589&amp;service=compute.googleapis.com&amp;metric=Persistent%20Disk%20SSD%20(GB)" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/iam-admin/quotas?PROJECT = $ { PROJECT }&amp;service = compute . Google APIs . com&amp;metric = Persistent % 20 disk % 20 SSD % 20(GB)</a></p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mm"><img src="../Images/f6fa08748dd32bb4a041b95d22776914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mZ9uau1XOtxXHdvcsa_OQ.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">配额:永久磁盘SSD (GB)</figcaption></figure><p id="80bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要实现此更改，我们必须删除并重新创建部署:</p><pre class="ky kz la lb fd lc jx ld le aw lf bi"><span id="9f84" class="jy jz hi jx b fi lg lh l li lj">kubectl delete --filename=deployment.yaml --namespace=${NAMESPACE}<br/>kubectl apply --filename=deployment.yaml --namespace=${NAMESPACE}</span></pre><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mn"><img src="../Images/b688f58e4cc388971bf43b56072ed3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yvuH-dMZWrxtprGlRp1Fg.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">计算引擎:磁盘</figcaption></figure><blockquote class="ll lm ln"><p id="1673" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>有4个计算引擎磁盘:3个是“标准持久磁盘”,分别用于Kubernetes集群中的3个节点。第四个磁盘为430GB (==400GiB)，属于“SSD持久磁盘”类型。它是在我们应用部署时由PersistentVolumeClaim创建的。</p></blockquote><h2 id="c5c0" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jg kj kk kl jk km kn ko jo kp kq kr ks bi translated">结论</h2><p id="a25f" class="pw-post-body-paragraph ix iy hi iz b ja kt ij jc jd ku im jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">在这篇文章中，我提供了两种在Google云平台上运行单个以太坊节点的简单方法。</p><p id="d9b6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随时欢迎反馈。</p><p id="c32e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>