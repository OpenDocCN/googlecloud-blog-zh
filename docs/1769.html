<html>
<head>
<title>Customizing GKE nodes labeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义GKE节点标签</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/customizing-gke-nodes-labeling-d921a35cb9b4?source=collection_archive---------1-----------------------#2021-01-22">https://medium.com/google-cloud/customizing-gke-nodes-labeling-d921a35cb9b4?source=collection_archive---------1-----------------------#2021-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0a0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">术语<em class="jd">标签</em>通常描述附加到某个对象的键/值对。在Kubernetes中，标签是附加到显示的资源(如pod)上的键/值对。Kubernetes标签可用于组织和选择对象子集。谷歌云标签(在本文中称为云标签)主要用于<a class="ae je" href="https://cloud.google.com/billing/docs/concepts#labels" rel="noopener ugc nofollow" target="_blank">对计费报告中的资源</a>进行分类，以简化支出成本的分析。当术语<em class="jd">标签</em>用于GKE服务时，有时会产生歧义和混乱。将它们称为“集群标签”的GKE文档可能会造成混淆。本质上，集群标签是在<a class="ae je" href="https://cloud.google.com/kubernetes-engine/docs/how-to/creating-managing-labels" rel="noopener ugc nofollow" target="_blank">集群级别</a>上定义的云标签。如果需要更深入的使用分析，GKE提供了一个<a class="ae je" href="https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-usage-metering" rel="noopener ugc nofollow" target="_blank">集群资源使用</a>机制，该机制根据名称空间或Kubernetes标签跟踪Kubernetes对象的资源使用情况。这种机制没有与计费报告集成，并且需要额外的成本计算。</p><p id="d5ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时不需要在Kubernetes对象级别上进行成本分析。在单个Kubernetes节点的级别上跟踪支出成本就足够了。一个简单的解决方案是将集群节点的Kubernetes标签“导出”到运行节点的GCE实例的云标签中。</p><h1 id="128b" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">一种算法</h1><p id="c92c" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在Kubernetes中，集群节点被标记为存储关于底层主机的元数据，如CPU或操作系统家族，并支持亲和或反亲和部署场景。节点也有注释和污点，可以用于相同的目标。为了简单起见，这个解决方案将只使用节点的标签。</p><p id="3c2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法的一个输入是标签键的列表。该算法将读取节点的所有标签，并将它们与列表进行比较。对于每个匹配的键，它将创建一个具有相同键/值对的云标签，并将其设置为运行该节点的GCE实例。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/b6e169d7e34fe1f245a051bcf0ef4edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/0*3ZePWwJeTMz3XR8p"/></div></figure><p id="b648" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法的实现是使用Python 3.8完成的，但可以很容易地移植到其他语言。</p><h1 id="5d4a" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">读取Kubernetes节点标签</h1><p id="eba3" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">使用<a class="ae je" href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/node-v1/#get-read-the-specified-node" rel="noopener ugc nofollow" target="_blank"> Kubernetes API </a>读取节点标签。虽然可以使用Kubernetes客户端库，但是一个简单的HTTP请求就可以了:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="99fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遵循<a class="ae je" href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/#directly-accessing-the-rest-api-1" rel="noopener ugc nofollow" target="_blank">准则</a>，代码使用<code class="du ks kt ku kv b">kubernetes.default.svc</code>主机名来调用API服务器。可以从自动安装的令牌文件中读取与pod相关联的服务帐户的授权凭证。该帐户必须拥有对群集资源“节点”的读取权限。节点名可以通过pod的环境变量公开。响应包含带有所有节点属性的JSON。JSON与命令返回的JSON相同:<code class="du ks kt ku kv b">kubectl get node {NODE_NAME} -o=json</code>。</p><h1 id="2626" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">更新GCE实例的云标签</h1><p id="930d" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">为GCE实例设置云标签也可以使用HTTP请求来实现。但是最简单的方法是使用用于Python的Google客户端库。实现使用<code class="du ks kt ku kv b">googleapiclient.discovery</code>和<code class="du ks kt ku kv b">google.auth</code>包。初始化使用连接到GKE节点虚拟机的云服务帐户的凭据。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="006f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">必须使用<a class="ae je" href="https://cloud.google.com/compute/docs/reference/rest/v1/instances/setLabels" rel="noopener ugc nofollow" target="_blank"> setLabels </a> API为GCE实例设置云标签。除了一组标签之外，调用参数还包括项目id、区域名、实例名和当前标签指纹。GKE对集群节点和托管节点的GCE实例使用相同的名称。使用<code class="du ks kt ku kv b">failure-domain.beta.kubernetes.io/zone</code>键将区域名称存储为Kubernetes标签。它可以从节点标签中检索。要获取当前云标签指纹，需要一个额外的<a class="ae je" href="https://cloud.google.com/compute/docs/reference/rest/v1/instances/get" rel="noopener ugc nofollow" target="_blank"> API调用</a>。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kq kr l"/></div></figure><h1 id="f10c" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">部署解决方案</h1><p id="5cf5" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">解决方案实现由两个文件组成:main.py和requirements.txt。或者，可以将文件加载到配置映射中，并将映射作为目录安装到pod的容器中。替代方法避免了构建/管理容器映像的需要。可以使用以下命令直接从文件中创建配置映射:</p><pre class="kj kk kl km fd kw kv kx ky aw kz bi"><span id="3d09" class="la jg hi kv b fi lb lc l ld le">kubectl create configmap node-labeling-files --from-file=main.py \<br/>  --from-file=requirements.txt</span></pre><p id="1431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署必须使用一个服务帐户，该帐户允许它通过Kubernetes API读取“节点”资源。建议创建一个。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="2d7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<a class="ae je" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank"> daemonset </a>最适合运行该解决方案，因为它在集群的每个节点上运行一个pod实例。daemonset中的pod从configMap挂载文件，并定义预配置的Kubernetes服务帐户。命令参数将解决方案配置为使用关键字“workload”来“导出”Kubernetes标签:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kq kr l"/></div></figure><h1 id="22dc" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">关于最佳实践的建议</h1><p id="8a6f" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">所展示的解决方案仅用于演示。使用指定的云服务帐户运行Kubernetes工作负载是一个很好的安全实践，该帐户使用<a class="ae je" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">工作负载标识</a>链接到工作负载的Kubernetes服务帐户。使用附加到集群GCE实例的服务帐户被认为是不太安全的。</p><blockquote class="lf lg lh"><p id="f228" class="if ig jd ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">请注意，如果您在启用了工作负载身份的GKE集群上尝试这个解决方案，您将无法使用附加到GCE实例的云服务帐户。</p></blockquote><p id="bb5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">daemonset和其他对象应该部署到专用的命名空间，而不是像演示中那样部署到“默认”命名空间。</p><h1 id="1910" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">那里没有什么？</h1><ul class=""><li id="1f6d" class="ll lm hi ih b ii kd im ke iq ln iu lo iy lp jc lq lr ls lt bi translated">该解决方案没有描述云服务帐户的配置和工作负载身份的使用。</li><li id="c586" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">该解决方案不包括标记装载到GCE实例的持久磁盘。</li><li id="94ee" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">该解决方案不支持实时更改群集节点标签。</li></ul><h1 id="3aa4" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">包裹</h1><ul class=""><li id="576e" class="ll lm hi ih b ii kd im ke iq ln iu lo iy lp jc lq lr ls lt bi translated">从pod调用Kubernetes API非常简单。它需要一个具有适当权限的服务帐户的小设置，并且可以在没有额外的库或框架的情况下完成。</li><li id="204e" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">调用谷歌API也是一样，尽管使用<a class="ae je" href="https://developers.google.com/api-client-library" rel="noopener ugc nofollow" target="_blank">谷歌客户端库</a>使得代码更加紧凑和易于实现。</li><li id="7a76" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">该解决方案不需要管理授权凭证。</li><li id="2b61" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">解决方案演示的完整代码可以在<a class="ae je" href="https://github.com/minherz/gke_node_labeling" rel="noopener ugc nofollow" target="_blank"> github </a>中找到。</li></ul></div></div>    
</body>
</html>