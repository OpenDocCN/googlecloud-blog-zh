<html>
<head>
<title>How to add a cache layer to the Google Datastore (in Node.js)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何向Google Datastore添加缓存层(在Node.js中)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-add-a-cache-layer-to-the-google-datastore-in-node-js-ffb402cd0e1c?source=collection_archive---------0-----------------------#2018-05-08">https://medium.com/google-cloud/how-to-add-a-cache-layer-to-the-google-datastore-in-node-js-ffb402cd0e1c?source=collection_archive---------0-----------------------#2018-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e16fde12e78f52b4ab6fe06e7046eb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3YMeO5Oe1AxOwD4j."/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae iu" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>拍摄</figcaption></figure><p id="e2ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们都知道缓存对于<strong class="ix hj">提高应用程序性能的重要性。</strong>我们可以在多个地方添加缓存层，今天我们将了解如何在<strong class="ix hj">应用程序级别</strong>添加缓存层。这个缓存将防止我们一次又一次地访问数据存储库，请求相同的未修改的数据。</p><p id="38f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是<em class="jt">我们如何</em>轻松缓存数据存储实体<strong class="ix hj"> <em class="jt">键</em> </strong>或数据存储<strong class="ix hj"> <em class="jt">查询</em> </strong>？我们如何知道<em class="jt">何时</em>需要<strong class="ix hj">使缓存</strong>无效，从而确保总是从数据存储中获取最新数据？</p><p id="189b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将在此记录我为解决这些问题所经历的过程。这个过程让我第一次发布了<a class="ae iu" href="https://github.com/sebelga/gstore-cache" rel="noopener ugc nofollow" target="_blank"> gstore-cache </a>。但后来我意识到缓存机制可以用于其他NoSQL数据库，于是我将缓存逻辑(<a class="ae iu" href="https://github.com/sebelga/nsql-cache" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> nsql-cache </strong> </a>)从数据库实现中分离出来，并使其与供应商无关。</p><p id="438f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我刚刚发布了Google Datastore的第一个数据库适配器:<br/><a class="ae iu" href="https://github.com/sebelga/nsql-cache-datastore" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">nsql-cache-Datastore</strong></a>。这个<strong class="ix hj">缓存层</strong>位于<a class="ae iu" href="https://github.com/googleapis/nodejs-datastore" rel="noopener ugc nofollow" target="_blank">@ Google-cloud/datastore</a>客户端的<em class="jt">前端</em>，并自动为您管理缓存。</p><h1 id="44cf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">默认，“魔法”方式</strong></h1><p id="7e75" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我将直接向您展示<strong class="ix hj">使用nsql-cache-datastore向您的现有应用添加缓存层有多简单</strong>。希望这样我就能在整篇文章中保持你的注意力……:)</p><h2 id="e3e7" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">安装依赖项</h2><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="f78d" class="kx jv hi lq b fi lu lv l lw lx">npm install nsql-cache nsql-cache-datastore --save</span></pre><h2 id="e163" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">实例化缓存</h2><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="fa54" class="kx jv hi lq b fi lu lv l lw lx">// datastore.js</span><span id="6ebd" class="kx jv hi lq b fi ly lv l lw lx">const Datastore = require('@google-cloud/datastore');<br/>const NsqlCache = require('nsql-cache'); // new<br/>const dsAdapter = require('nsql-cache-datastore'); // new</span><span id="8aa3" class="kx jv hi lq b fi ly lv l lw lx">const datastore = new Datastore();<br/>const cache = new NsqlCache({ db: dsAdapter(datastore) }); // new</span><span id="d0dd" class="kx jv hi lq b fi ly lv l lw lx">module.exports = { datastore, cache } ;</span></pre><p id="715c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样。有了这3行代码，你就为你的实体获取添加了一个<strong class="ix hj"> LRU内存</strong>缓存，这会立刻提升你的应用程序的性能。<br/>它具有以下默认配置:</p><ul class=""><li id="8d84" class="lz ma hi ix b iy iz jc jd jg mb jk mc jo md js me mf mg mh bi translated">缓存中的最大对象数:100</li><li id="cd6d" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">实体的TTL(生存时间)(通过<em class="jt">键</em>获取):10分钟</li><li id="3ea1" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated"><em class="jt">查询的TTL</em>:5秒</li></ul><p id="fb34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用程序代码的其余部分不会改变。从上面的文件中导入@google-cloud/datastore实例，并使用它的API。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="cc62" class="kx jv hi lq b fi lu lv l lw lx">import { datastore } from './datastore';</span><span id="790f" class="kx jv hi lq b fi ly lv l lw lx">const key1 = datstore.key(['Post', 123]);<br/>const key2 = datstore.key(['Post', 456]);</span><span id="af14" class="kx jv hi lq b fi ly lv l lw lx">datastore.get([key1, key2).then((result) =&gt; {<br/>    const [entity1, entity2] = result;<br/>    ...<br/>});</span></pre><p id="e503" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自<a class="mq mr ge" href="https://medium.com/u/4f3f4ee0f977?source=post_page-----ffb402cd0e1c--------------------------------" rel="noopener" target="_blank"> @ </a> google-cloud/datastore的<code class="du mn mo mp lq b">datastore.get()</code>、<code class="du mn mo mp lq b">datastore.save()</code>、<code class="du mn mo mp lq b">datastore.createQuery()</code>和所有必要的方法已经被nsql-cache<strong class="ix hj">包装</strong>，你不必担心缓存。</p><p id="fb21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不喜欢这么多的魔法，我将在下面向你展示如何停用客户端的包装，并手动管理缓存。</p><p id="ab81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要强调的一个很好的特性是当你用<code class="du mn mo mp lq b">datastore.get()</code>方法进行<em class="jt">批处理</em>操作(多键)时。nsql-cache将<strong class="ix hj"> <em class="jt">仅</em>获取它在缓存</strong>中没有找到的键(在多存储中——我们将在下面看到——这意味着它将按顺序遍历每个缓存，寻找在前一个缓存中没有找到的键)。<br/>在前面的例子中，如果<em class="jt"> key1 </em>在缓存中，而<em class="jt"> key2 </em>不在，nsql-cache将<strong class="ix hj"> only </strong>从数据存储中获取<em class="jt"> key2 </em>。</p><p id="53e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器上的内存高速缓存对于快速提升性能很有帮助，但是它当然也有其局限性(例如，在无服务器的<em class="jt"> </em>中，请求之间没有共享内存)。</p><p id="763a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何将nsql-cache连接到全局<a class="ae iu" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank">Redis<em class="jt">T31】数据库</em></a>。</p><h2 id="8285" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">连接到Redis</h2><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="add4" class="kx jv hi lq b fi lu lv l lw lx">const Datastore = require('@google-cloud/datastore');<br/>const NsqlCache = require('nsql-cache');<br/>const dsAdapter = require('nsql-cache-datastore');<br/>const redisStore = require('cache-manager-redis-store');</span><span id="9fe4" class="kx jv hi lq b fi ly lv l lw lx">const datastore = new Datastore();<br/>const cache = new NsqlCache({<br/>    db: dsAdapter(datastore),<br/>    stores: [{<br/>        store: redisStore,<br/>        host: 'localhost', // default value<br/>        port: 6379, // default value<br/>        auth_pass: 'xxxx'<br/>    }]<br/>});</span><span id="9ab0" class="kx jv hi lq b fi ly lv l lw lx">module.exports = { datastore, cache };</span></pre><p id="348f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您有了一个Redis缓存，其默认配置如下:</p><ul class=""><li id="0321" class="lz ma hi ix b iy iz jc jd jg mb jk mc jo md js me mf mg mh bi translated">实体的TTL(密钥):1天</li><li id="2d7f" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">TTL查询:0 →无限</li></ul><p id="b4c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">无限缓存</strong>用于查询？真的吗？…是:)</p><p id="4121" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据存储上的查询总是与实体<em class="jt">种类相关联。</em>这意味着如果我们有办法保存一个<em class="jt">引用</em>到我们为每种实体类型所做的所有查询，那么只有当<em class="jt">相同</em>类型<em class="jt">或</em>的实体被添加/更新或删除时，我们才能<strong class="ix hj">使</strong>的缓存无效。</p><p id="25f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当提供Redis客户端时，这正是nsql-cache正在做的事情。每次成功解析数据存储查询时，都会发生3项操作:</p><ul class=""><li id="9308" class="lz ma hi ix b iy iz jc jd jg mb jk mc jo md js me mf mg mh bi translated">为查询生成唯一的<em class="jt">缓存键</em></li><li id="746d" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">将查询的响应保存在Redis中的这个缓存键处</li><li id="48f6" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">在<strong class="ix hj">并行操作</strong>中，将缓存键保存到Redis <strong class="ix hj">集合<em class="jt">中</em>集合</strong></li></ul><p id="5731" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下次我们添加、更新或删除实体时，nsql-cache将:</p><ul class=""><li id="0c24" class="lz ma hi ix b iy iz jc jd jg mb jk mc jo md js me mf mg mh bi translated">读取该实体<em class="jt">种类</em>的Redis集合<em class="jt">成员</em>(缓存键)<em class="jt"> </em></li><li id="b2b3" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">删除所有缓存键(从而使查询缓存无效)</li></ul><h2 id="971b" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">配置</h2><p id="a2c0" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">根据应用程序的大小，为查询保留无限的缓存可能对您来说太多了(是的，它会变得非常大！).<br/>让我们看看如何为键和查询定义不同的生存时间。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="34d6" class="kx jv hi lq b fi lu lv l lw lx">const cache = new NsqlCache({<br/>    db: dsAdapter(datastore),<br/>    stores: [{<br/>        store: redisStore,<br/>        host: 'localhost',<br/>        port: 6379,<br/>        auth_pass: 'xxxx',<br/>    }],<br/>    config: {<br/>        ttl: {<br/>            keys: 60 * 60, // 1 hour<br/>            queries: 60 * 30 // 30 minutes<br/>        }<br/>    }<br/>});</span></pre><p id="24a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，您只需要为每种类型的缓存提供一个以<em class="jt">秒</em>为单位的持续时间，Redis就会自动删除过期的缓存。</p><p id="2ba5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:在配置中定义的TTL持续时间可以在以后的任何请求中被覆盖。</p><h2 id="37ac" class="kx jv hi bd jw ky kz la ka lb lc ld ke jg le lf ki jk lg lh km jo li lj kq lk bi translated">多商店缓存</h2><p id="29d4" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">那些关注的人可能已经注意到<code class="du mn mo mp lq b">stores</code>设置是一个数组。这是因为nsql-cache使用了强大的<a class="ae iu" href="https://github.com/BryanDonovan/node-cache-manager" rel="noopener ugc nofollow" target="_blank">缓存管理器库</a>，允许您定义<strong class="ix hj">多个缓存存储</strong>，每个存储中有不同的TTL值。</p><p id="5e5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，这允许您为最常访问的实体/查询使用一个速度极快的<em class="jt">内存</em>高速缓存(TTL较短)，为较长的TTL使用第二个<em class="jt"> Redis </em>高速缓存(也非常快，但网络i/o的一些延迟是不可避免的)。</p><p id="1724" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何设置2个缓存存储。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="6103" class="kx jv hi lq b fi lu lv l lw lx">const cache = new NsqlCache({<br/>    db: dsAdapter(datastore),<br/>    stores: [{<br/>        store: 'memory',<br/>        max: 100, // maximum number of objects<br/>    },{<br/>        store: redisStore,<br/>        host: 'localhost', // default value<br/>        port: 6379, // default value<br/>        auth_pass: 'xxxx',<br/>    }]<br/>});</span></pre><p id="c2a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了改变每个商店的默认ttl值，在TTL配置中提供一个配置对象，由商店<em class="jt">名称</em>提供。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3cad" class="kx jv hi lq b fi lu lv l lw lx">const cache = new NsqlCache({<br/>    ...,<br/>    config: {<br/>        ttl: {<br/>            memory: {<br/>                keys: 60 * 5, // default<br/>                queries: 5 // default<br/>            },<br/>            redis: {<br/>                keys: 60 * 60 * 24, // default<br/>                queries: 0 // default (infinite)<br/>            },<br/>        }<br/>    }<br/>});</span></pre><h1 id="7de2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">复杂的查询</h1><p id="afab" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">正如我们所看到的，nsql-cache自动保存对每种实体类型的所有查询的引用(如果已经提供了Redis客户端)。在某些情况下，您可能希望<strong class="ix hj">聚合</strong>多个查询，并将它们保存为一个键/值。nsql-cache为此提供了一个方法:<code class="du mn mo mp lq b">cache.queries.kset()</code></p><p id="7bf7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个例子，我们进行多次查询来获取网站主页的数据。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="c4a1" class="kx jv hi lq b fi lu lv l lw lx">const { datastore, cache } = require('./datastore');</span><span id="d6a9" class="kx jv hi lq b fi ly lv l lw lx">const fetchHomeData = () =&gt; {<br/>    // Check the cache first...<br/>    return cache.get('website:home').then(data =&gt; {<br/>        if (data) {<br/>            // in cache, great!<br/>            return data;<br/>        }<br/><br/>        // Cache not found, query the data..</span><span id="0bbb" class="kx jv hi lq b fi ly lv l lw lx">        const queryPosts = datastore<br/>            .createQuery('Posts')<br/>            .filter('category', 'tech')<br/>            .limit(10)<br/>            .order('publishedOn', { descending: true });<br/><br/>        const queryTopStories = datastore<br/>            .createQuery('Posts')<br/>            .order('score', { descending: true })<br/>            .limit(3);<br/><br/>        const queryProducts = datastore<br/>            .createQuery('Products')<br/>            .filter('featured', true);<br/><br/>        return Promise.all([<br/>            queryPosts.run(),<br/>            queryTopStories.run(),<br/>            queryProducts.run()<br/>        ])<br/>        .then(([posts, topStories, products]) =&gt; {<br/>            // Aggregate our data<br/>            const homeData = {<br/>                posts,<br/>                topStories,<br/>                products,<br/>            };<br/><br/>            // We save the result of the 3 queries<br/>            // to the "website:home" cache key<br/>            // and associate the data to the "Posts" &amp; "Products" <br/>            // Entity Kinds.<br/>            // We can now safely keep the cache infinitely<br/>            // until we add/edit or delete a "Posts" or a <br/>            // "Products" entity Kind<br/>            return cache.queries<br/>                .kset(<br/>                     'website:home',<br/>                     homeData,<br/>                     ['Posts', 'Products']<br/>                );<br/>        });<br/>    });<br/>};</span></pre></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h1 id="ca57" class="ju jv hi bd jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr bi translated">先进的“手动”方式</h1><p id="cedd" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">如果你不想要这么多魔法，更喜欢自己管理缓存，你可以禁用@google-cloud/datastore客户端的包装，使用<a class="ae iu" href="https://github.com/sebelga/nsql-cache#api" rel="noopener ugc nofollow" target="_blank"> NsqlCache API </a>。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="559b" class="kx jv hi lq b fi lu lv l lw lx">const cache = new NsqlCache({<br/>    db: dsAdapter(datastore),<br/>    config: {<br/>        wrapClient: false<br/>    }<br/>});</span></pre><p id="14eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您现在负责管理缓存。您可以通过<code class="du mn mo mp lq b">cache.keys.read()</code>和<code class="du mn mo mp lq b">cache.queries.read()</code>方法使用另一个抽象层。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="8031" class="kx jv hi lq b fi lu lv l lw lx">const { datastore, cache } = require('./datastore');</span><span id="1897" class="kx jv hi lq b fi ly lv l lw lx">const key = datastore.key(['Company', 'Google']);</span><span id="31f9" class="kx jv hi lq b fi ly lv l lw lx">// The cache.keys.read() will:<br/>// - check the cache<br/>// - if not found, fetch from the Datastore<br/>// - prime the cache</span><span id="b71f" class="kx jv hi lq b fi ly lv l lw lx">cache.keys.read(key).then(([entity]) =&gt; { ... })</span></pre><p id="1ac6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者你可以100%手动…(你真的想那样吗？)</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="8292" class="kx jv hi lq b fi lu lv l lw lx">const { datastore, cache } = require('./datastore');</span><span id="c5ce" class="kx jv hi lq b fi ly lv l lw lx">const key = datastore.key(['Company', 'Google']);</span><span id="fa0b" class="kx jv hi lq b fi ly lv l lw lx">cache.get(key)<br/>    .then(entity) =&gt; {<br/>        if (entity){<br/>            return entity;<br/>        }<br/>        return datastore.get(key)<br/>            .then(([entity]) =&gt; {<br/>                if (!entity) { <br/>                    return;<br/>                }<br/>                // Prime the cache<br/>                return cache.set(key, entity);<br/>            })<br/>    });</span></pre><p id="6a97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您没有包装数据存储客户端，请阅读Nsql API文档并查看<a class="ae iu" href="https://github.com/sebelga/nsql-cache-datastore" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">Nsql-cache-datastore</strong></a>存储库中的示例。</p><p id="cedf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样。我希望通过这篇文章，我已经向你展示了为你的谷歌数据存储实体添加一个缓存层是多么容易。我希望在未来的帖子中，我将能够提供一些基准(如果有人能给我指出一个好的工具/服务来完成它们，我将不胜感激！).</p><p id="33e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请给我留下您对我所采取的方法的意见，如果您看到任何可以改进的地方，请告诉我！</p><p id="3669" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>