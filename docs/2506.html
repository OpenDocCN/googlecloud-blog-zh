<html>
<head>
<title>Understanding the Dataflow Quickstart for Python Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Python的数据流快速入门教程</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/understanding-the-dataflow-quickstart-for-python-tutorial-e134f39564c7?source=collection_archive---------1-----------------------#2022-11-15">https://medium.com/google-cloud/understanding-the-dataflow-quickstart-for-python-tutorial-e134f39564c7?source=collection_archive---------1-----------------------#2022-11-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bb76" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">字数统计管道的逐步解构</h2></div><h1 id="6026" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">介绍</h1><p id="535e" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">Python教程的<a class="ae kl" href="https://cloud.google.com/dataflow/docs/quickstarts/create-pipeline-python" rel="noopener ugc nofollow" target="_blank">数据流快速入门是在Apache Beam和Dataflow中启动和运行的一个很好的方法。然而，如果您以前没有Apache Beam经验，您可以执行整个教程，但仍然不知道您刚才做了什么。什么是“管道”？这个“|”管道操作符是怎么回事？什么是“帕尔多”？</a></p><p id="c0c5" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">因此，我花时间将整个Dataflow Quickstart for Python教程分解为基本步骤和基本原则，并对所需代码进行了逐行解释。通过理解Python Apache Beam SDK的基础和组成部分，您将能够自信地设计和构建自己的管道，而不仅仅是依赖于模板。</p><p id="632b" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果你想继续下去，请继续读下去。</p><h1 id="29a2" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">初始化</h1><p id="e386" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">从完成Python教程的<a class="ae kl" href="https://cloud.google.com/dataflow/docs/quickstarts/create-pipeline-python" rel="noopener ugc nofollow" target="_blank">数据流快速入门中的“开始之前”到“本地运行管道”的步骤开始。</a></p><p id="6145" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">现在，从<a class="ae kl" href="https://github.com/apache/beam/blob/master/sdks/python/apache_beam/examples/wordcount.py" rel="noopener ugc nofollow" target="_blank"> Apache Beam Github </a>下载<code class="du kr ks kt ku b">wordcount.py</code>源代码，并运行该命令以确保您可以在本地运行源代码:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="2d34" class="ld iy hi ku b be le lf l lg lh">python wordcount.py --output outputs</span></pre><p id="de23" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这就是我们将要开始的地方。</p><h1 id="a2d6" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">语境</h1><p id="0032" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这将是对<code class="du kr ks kt ku b">wordcount.py</code>代码的一次迭代探索，从基本原则开始，一路解释Apache Beam SDK。在我们进行的过程中，一定要在每一步都运行<code class="du kr ks kt ku b">python wordcount.py --output outputs</code>，观察打印语句结果和输出文件；这将有助于巩固概念，因为它们建立在彼此的基础上。此外，每个人都有不同的能力和理解水平；你可以随意跳过需要的步骤，也可以在必要的地方用你自己的研究进行更深入的挖掘。我们走吧！</p><h1 id="d673" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第一步:你好，世界</h1><p id="9078" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们将从零开始:你好世界。创建并运行这段代码，确认你的理智。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/31368d84f8c9043f8818b8b3c4186b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IP6Ls-XiGnRgqCGIjFegNw.png"/></div></div></figure><h1 id="cb55" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">步骤2:创建Apache Beam管道</h1><p id="da09" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在，导入Beam并在上下文管理器中创建管道:</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lq"><img src="../Images/d68d61c2f30818337eb04eb63346e0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_cOjP9V5b3TYhhz24rcp8A.png"/></div></div></figure><p id="3d99" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><code class="du kr ks kt ku b">beam.Pipeline()</code>构造函数返回一个Apache管道对象。<a class="ae kl" href="https://beam.apache.org/documentation/programming-guide/" rel="noopener ugc nofollow" target="_blank">来自阿帕奇波束文档</a>:</p><blockquote class="lr ls lt"><p id="4694" class="jp jq lu jr b js km ij ju jv kn im jx lv ko ka kb lw kp ke kf lx kq ki kj kk hb bi translated"><em class="hi">管道封装了你的整个数据处理任务，从开始到结束。这包括读取输入数据、转换数据和写入输出数据。所有的光束驱动程序必须创建一个管道。</em></p></blockquote><p id="b79d" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">此外，<code class="du kr ks kt ku b">with</code>语句创建一个运行时上下文，管道在其中运行。这有助于处理错误和在出现故障时进行清理。<a class="ae kl" href="https://realpython.com/python-with-statement/" rel="noopener ugc nofollow" target="_blank">点击此处</a>了解关于<code class="du kr ks kt ku b">with</code>陈述的更多信息。</p><p id="0d37" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">注意，如果运行这段代码，什么都不会改变；您仍然得到相同的“Hello World”输出。</p><h1 id="8318" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">步骤3:处理输入参数</h1><p id="6b06" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><em class="lu">注意:如果您已经熟悉Python的命令行参数，可以跳过这一步。</em></p><p id="df08" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">现在，<code class="du kr ks kt ku b">import argparse</code>，将<code class="du kr ks kt ku b">argv=None</code>设置为<code class="du kr ks kt ku b">run()</code>函数中的一个参数，实例化<code class="du kr ks kt ku b">parser</code>，并添加要监听的参数。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ly"><img src="../Images/1fddbd855dde8322e42adb1d97d473c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7Esb0Z3Ta2Q1GOGGmp3Zg.png"/></div></div></figure><p id="e39c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><code class="du kr ks kt ku b">parse_known_args()</code>方法通过<code class="du kr ks kt ku b">argv</code>参数解析给文件的输入。"它返回一个包含已填充的名称空间和剩余参数字符串列表的元组."<a class="ae kl" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> (Python Docs) </a>换句话说，“名称空间”包含已知的/预期的参数(<code class="du kr ks kt ku b">known_args</code>),而<code class="du kr ks kt ku b">pipeline_args</code>列表包含传递给Python程序的所有其他内容。</p><p id="a8de" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">继续运行下面的命令，根据您的兴趣进行调整，看看给定的参数如何填充<code class="du kr ks kt ku b">known_args</code>和<code class="du kr ks kt ku b">pipeline_args</code>变量。</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="304a" class="ld iy hi ku b be le lf l lg lh">python wordcount_3.py --input known1 --output known2<br/>python wordcount_3.py --input known1 --output known2 aRandomPipelineArg1 aRandomPipelineArg2</span></pre><h1 id="e7b3" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">步骤4:生成管道选项</h1><p id="4e82" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这一步导入<code class="du kr ks kt ku b">PipelineOptions</code>并使用它创建一个对象给射束管道。这就是misc选项列表从命令行进入射束管道本身的方式。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lz"><img src="../Images/6f5c22b9f489b84e8f6a34265e5e5a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrTNw7-K2GkfL3bDWX0CGQ.png"/></div></div></figure><p id="7206" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">虽然在本教程中，这些管道参数对于在本地运行Beam管道不是必需的，但是当您想要在数据流上运行管道时，它们是相关的。</p><h1 id="84e6" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">步骤5:访问管道中的已知参数</h1><p id="c7cd" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在，让我们去掉“Hello World ”,代之以我们在Python调用中传递的一些值。</p><p id="5116" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">在<code class="du kr ks kt ku b">parser.add_argument()</code>通话中，添加<code class="du kr ks kt ku b">dest='input'</code>和<code class="du kr ks kt ku b">dest='output'</code>的线路。然后在Beam管道中，用<code class="du kr ks kt ku b">print(known_args.input)</code>替换“Hello World”。注意，无论您为<code class="du kr ks kt ku b">--input</code>标志传递什么，它都将被附加到由<code class="du kr ks kt ku b">dest=''</code>指定的属性上。在我们的例子中，因为<code class="du kr ks kt ku b">dest='input'</code>，<code class="du kr ks kt ku b">input</code>是我们可以使用的键。因此，我们为<code class="du kr ks kt ku b">--input</code>标志传递的内容可以通过调用<code class="du kr ks kt ku b">known_args.input</code>来访问。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ma"><img src="../Images/3e9b20164902646623442481c58b53b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6yu30DQ_pKx9Jf_IR103g.png"/></div></div></figure><p id="5646" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">注意:如果您没有在<code class="du kr ks kt ku b">add_argument()</code>调用中显式设置<code class="du kr ks kt ku b">dest</code>，那么名称空间键将被设置为用作参数标志的值。在我们的例子中，它们都被称为<code class="du kr ks kt ku b">input</code>，所以这并不重要，但这是需要注意的。</p><p id="a925" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">请自行测试这段代码，以了解这些部分是如何交互的。</p><h1 id="e13f" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第六步:管道操作员</h1><p id="ae4c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在，我们将使用管道操作符向管道添加更多内容。继续导入<code class="du kr ks kt ku b">ReadFromText</code>和<code class="du kr ks kt ku b">WriteFromText</code>。我们将让管道简单地把它得到的任何东西作为输入写到输出，没有任何转换。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mb"><img src="../Images/f72b4852eb0a81cb03ae12f73d5e1c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fy2urhCJJa3P4Z0A4blzAA.png"/></div></div></figure><p id="4ee1" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">管道操作符类似于Java的“应用”。在Python世界中，它的操作类似于方法链接。来自<a class="ae kl" href="https://beam.apache.org/documentation/programming-guide/#applying-transforms" rel="noopener ugc nofollow" target="_blank">阿帕奇光束文件</a>:</p><blockquote class="lr ls lt"><p id="959d" class="jp jq lu jr b js km ij ju jv kn im jx lv ko ka kb lw kp ke kf lx kq ki kj kk hb bi translated"><em class="hi">Beam SDK中的每个转换都有一个通用的应用方法(或管道运算符|)。调用多个射束转换类似于方法链接，但是有一点小小的不同:将转换应用于输入PCollection，将转换本身作为参数传递，操作返回输出PCollection。</em></p></blockquote><p id="62e0" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这些文档还为管道运营商提供了一个非常有用的简单公式:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="8e6a" class="ld iy hi ku b be le lf l lg lh">[Output PCollection] = [Input PCollection] | [Transform]</span></pre><p id="8374" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">现在您可能还想知道管道和转换之间的<code class="du kr ks kt ku b">'&lt;Text&gt;' &gt;&gt;</code>是干什么用的。正如StackOverflow上的用户<a class="ae kl" href="https://stackoverflow.com/questions/43796046/explain-apache-beam-python-syntax" rel="noopener ugc nofollow" target="_blank">“RF-”解释的那样</a></p><blockquote class="lr ls lt"><p id="8f8e" class="jp jq lu jr b js km ij ju jv kn im jx lv ko ka kb lw kp ke kf lx kq ki kj kk hb bi translated"><em class="hi">&gt;&gt;“允许您命名一个步骤，以便在各种ui中更容易地显示——在|和&gt; &gt;之间的字符串仅用于这些显示目的和识别该特定应用。</em></p></blockquote><p id="8c5c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">所以，这只是为了展示的目的。</p><p id="9fa0" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">为了便于查看，我还在这一步中添加了日志记录。</p><h1 id="c0d5" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">步骤7:帕尔多</h1><p id="b560" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在让我们进入<code class="du kr ks kt ku b">beam.ParDo()</code>转换。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mc"><img src="../Images/aa25aefebdac78d718ae0a03571f8104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uv2iukr4DQsV0RB5Sb0m-Q.png"/></div></div></figure><p id="709c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">可以通过创建<code class="du kr ks kt ku b">beam.DoFn</code>的子类来创建DoFn对象。子类是通过将<code class="du kr ks kt ku b">beam.DoFn</code>传递给你的类定义来创建的。</p><p id="d616" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">我们将从Beam文档中的<code class="du kr ks kt ku b">ComputeWordLengthFn()</code>示例开始。这是一个简单返回每个元素长度的函数。请注意，我们在流水线中的“读”和“写”步骤之间添加了“长度”步骤。</p><p id="5d6a" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">注意，ParDo函数中的<code class="du kr ks kt ku b">process</code>方法需要遵循特定的格式。如<a class="ae kl" href="https://beam.apache.org/documentation/programming-guide/#applying-transforms" rel="noopener ugc nofollow" target="_blank">阿帕奇光束文件</a>所述:</p><blockquote class="lr ls lt"><p id="0e73" class="jp jq lu jr b js km ij ju jv kn im jx lv ko ka kb lw kp ke kf lx kq ki kj kk hb bi translated"><em class="hi">在DoFn子类中，您将编写一个方法流程，在其中提供实际的处理逻辑。您不需要从输入集合中手动提取元素；Beam SDKs会为您处理这些问题。您的流程方法应该接受一个argument元素，即input元素，并返回一个iterable及其输出值。可以通过yield语句发出单个元素来实现这一点，也可以通过iterable语句使用return语句，比如list或generator。</em></p></blockquote><p id="0ba9" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">所以你的<code class="du kr ks kt ku b">process</code>方法必须有这个签名:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="5ac7" class="ld iy hi ku b be le lf l lg lh">def process(self, element):</span></pre><p id="62d7" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">继续运行这段代码，看看它是如何工作的:<code class="du kr ks kt ku b">python wordcount.py --output outputs</code></p><p id="54a5" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">请注意，我们在函数中有一个<code class="du kr ks kt ku b">print</code>和<code class="du kr ks kt ku b">input</code>语句用于可视性。还要注意，输出文件现在包含每行的长度，而不是文件中的单词。</p><h1 id="9b3b" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第八步:WordExtractingDoFn()</h1><p id="e027" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在我们将实现原来的<code class="du kr ks kt ku b">wordcount.py</code>文件中指定的<code class="du kr ks kt ku b">WordExtractingDoFn()</code>。</p><p id="9de5" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">所以去掉<code class="du kr ks kt ku b">ComputeWordLengthFn</code>帕尔多变换，用<code class="du kr ks kt ku b">beam.ParDo(WordExtractingDoFn().with_output_types(str)</code>代替</p><p id="badb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">注意在<code class="du kr ks kt ku b">WordExtractingDoFn</code>的函数定义中，它使用正则表达式将每个元素(每个“行”)转换成一个组成单词的列表。我添加了打印语句来显示每一行和结果列表。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es md"><img src="../Images/fe8513cd92999e51c1f7dd335500b762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZhsUVckMbU5SSEsLpvSZQ.png"/></div></div></figure><p id="3291" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">添加此转换会产生如下所示的输出:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="fbf6" class="ld iy hi ku b be le lf l lg lh">    KING LEAR<br/><br/><br/>    DRAMATIS PERSONAE<br/><br/><br/>LEAR king of Britain  (KING LEAR:)<br/><br/>KING OF FRANCE:<br/><br/>DUKE OF BURGUNDY (BURGUNDY:)<br/><br/>DUKE OF CORNWALL (CORNWALL:)<br/><br/>DUKE OF ALBANY (ALBANY:)<br/><br/>EARL OF KENT (KENT:)<br/><br/>EARL OF GLOUCESTER (GLOUCESTER:)<br/><br/>EDGAR son to Gloucester.<br/><br/>EDMUND bastard son to Gloucester.<br/><br/>CURAN a courtier.<br/><br/>Old Man tenant to Gloucester.<br/><br/>...</span></pre><p id="e242" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">对此:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="1ee0" class="ld iy hi ku b be le lf l lg lh">KING<br/>LEAR<br/>DRAMATIS<br/>PERSONAE<br/>LEAR<br/>king<br/>of<br/>Britain<br/>KING<br/>LEAR<br/>KING<br/>OF<br/>FRANCE<br/>DUKE<br/>OF<br/>BURGUNDY<br/>BURGUNDY<br/>DUKE<br/>OF<br/>CORNWALL<br/>CORNWALL<br/>DUKE<br/>OF<br/>ALBANY<br/>ALBANY<br/>EARL<br/>OF<br/>KENT<br/>KENT<br/>EARL<br/>OF<br/>GLOUCESTER<br/>GLOUCESTER<br/><br/>...</span></pre><p id="6075" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">请注意，我还在“Split”转换步骤中添加了<code class="du kr ks kt ku b">with_output_types()</code>方法。正如在<a class="ae kl" href="https://stackoverflow.com/questions/47978342/apache-beam-clarifying-an-expected-behavior-of-output-typehint-on-python-sdk" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>中解释的那样:“指定的输出类型仅用于确保与后续转换的一致性。”在我们的例子中，这不会有什么不同，但是我添加它来反映<code class="du kr ks kt ku b">wordcount.py</code>文件。</p><h1 id="0ad8" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第九步:梁。地图()</h1><p id="9ee8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">对于步骤9，我们将利用<code class="du kr ks kt ku b">beam.Map()</code>转换；包括在新的“PairWithOne”步骤中。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es md"><img src="../Images/be4df5ed7c9b07bcc3b2620b09d7637a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKbVK6H-OcAifedOClJdmw.png"/></div></div></figure><p id="6fbb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated"><code class="du kr ks kt ku b">beam.Map()</code>方法接受一个函数，并将其应用于PCollection中的每个元素。在我们的例子中，我们传入一个匿名lambda函数，该函数返回一个与1配对的输入元素元组(因此步骤名为‘PairWithOne’)</p><p id="2d83" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">虽然有其他功能可以满足这里的要求，但是选择<code class="du kr ks kt ku b">Map()</code>功能是因为，根据<a class="ae kl" href="https://beam.apache.org/documentation/programming-guide/#applying-transforms" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="lr ls lt"><p id="c1af" class="jp jq lu jr b js km ij ju jv kn im jx lv ko ka kb lw kp ke kf lx kq ki kj kk hb bi translated"><em class="hi">如果您的ParDo执行输入元素到输出元素的一对一映射——也就是说，对于每个输入元素，它应用一个恰好产生一个输出元素的函数，您可以使用更高级别的映射转换。</em></p></blockquote><p id="df33" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">添加此转换将获得以下内容的输出:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="8e73" class="ld iy hi ku b be le lf l lg lh">KING<br/>LEAR<br/>DRAMATIS<br/>PERSONAE<br/>LEAR<br/>king<br/>of<br/>Britain<br/>KING<br/>LEAR<br/>KING<br/>OF<br/>FRANCE<br/>DUKE<br/>OF<br/>BURGUNDY<br/>BURGUNDY<br/>DUKE<br/>OF<br/>CORNWALL<br/>CORNWALL<br/>DUKE<br/>OF<br/>ALBANY<br/>ALBANY<br/>EARL<br/>OF<br/>KENT<br/>KENT<br/>EARL<br/>OF<br/>GLOUCESTER<br/>GLOUCESTER<br/><br/>...</span></pre><p id="1dd9" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">对此:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="65b6" class="ld iy hi ku b be le lf l lg lh">('KING', 1)<br/>('LEAR', 1)<br/>('DRAMATIS', 1)<br/>('PERSONAE', 1)<br/>('LEAR', 1)<br/>('king', 1)<br/>('of', 1)<br/>('Britain', 1)<br/>('KING', 1)<br/>('LEAR', 1)<br/>('KING', 1)<br/>('OF', 1)<br/>('FRANCE', 1)<br/>('DUKE', 1)<br/>('OF', 1)<br/>('BURGUNDY', 1)<br/>('BURGUNDY', 1)<br/>('DUKE', 1)<br/>('OF', 1)<br/>('CORNWALL', 1)<br/>('CORNWALL', 1)<br/>('DUKE', 1)<br/>('OF', 1)<br/>('ALBANY', 1)<br/>('ALBANY', 1)<br/>('EARL', 1)<br/>('OF', 1)<br/>('KENT', 1)<br/>('KENT', 1)<br/>('EARL', 1)<br/>('OF', 1)<br/>('GLOUCESTER', 1)<br/>('GLOUCESTER', 1)<br/><br/>...</span></pre><h1 id="8167" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第十步:梁。CombinePerKey()</h1><p id="7a6f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在我们需要一个转换来计算每个单词的所有实例。为此，我们将使用<code class="du kr ks kt ku b">beam.CombinePerKey(sum)</code>转换。</p><p id="1b8d" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">创建“GroupAndSum”步骤，如下所示:</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es md"><img src="../Images/74ab77ae8e941ee07557d3e2ecff245b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vo7KSSSchJEP-ekNqlKrmA.png"/></div></div></figure><p id="4c6f" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">CombinePerKey聚合“接受一个函数，该函数将一组值作为输入，并为每个键组合这些值。”(<a class="ae kl" href="https://beam.apache.org/documentation/transforms/python/aggregation/combineperkey/" rel="noopener ugc nofollow" target="_blank"> Beam Docs </a>)在这种情况下，键是每个元组中的单词。因此“sum”函数将每个键的所有值相加。因为元组的所有值都是1，这实际上与计算每个唯一的单词是一样的。</p><p id="958f" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">添加此转换将获取以下内容的输出:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="096e" class="ld iy hi ku b be le lf l lg lh">('KING', 1)<br/>('LEAR', 1)<br/>('DRAMATIS', 1)<br/>('PERSONAE', 1)<br/>('LEAR', 1)<br/>('king', 1)<br/>('of', 1)<br/>('Britain', 1)<br/>('KING', 1)<br/>('LEAR', 1)<br/>('KING', 1)<br/>('OF', 1)<br/>('FRANCE', 1)<br/>('DUKE', 1)<br/>('OF', 1)<br/>('BURGUNDY', 1)<br/>('BURGUNDY', 1)<br/>('DUKE', 1)<br/>('OF', 1)<br/>('CORNWALL', 1)<br/>('CORNWALL', 1)<br/>('DUKE', 1)<br/>('OF', 1)<br/>('ALBANY', 1)<br/>('ALBANY', 1)<br/>('EARL', 1)<br/>('OF', 1)<br/>('KENT', 1)<br/>('KENT', 1)<br/>('EARL', 1)<br/>('OF', 1)<br/>('GLOUCESTER', 1)<br/>('GLOUCESTER', 1)<br/><br/>...</span></pre><p id="e4ba" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">对此:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="f2d9" class="ld iy hi ku b be le lf l lg lh">('KING', 243)<br/>('LEAR', 236)<br/>('DRAMATIS', 1)<br/>('PERSONAE', 1)<br/>('king', 65)<br/>('of', 447)<br/>('Britain', 2)<br/>('OF', 15)<br/>('FRANCE', 10)<br/>('DUKE', 3)<br/>('BURGUNDY', 8)<br/>('CORNWALL', 63)<br/>('ALBANY', 67)<br/>('EARL', 2)<br/>('KENT', 156)<br/>('GLOUCESTER', 141)<br/><br/>...</span></pre><h1 id="71b8" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">第十一步:梁。映射元组()</h1><p id="9a62" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们来到流水线中的最后一个转换，<code class="du kr ks kt ku b">beam.MapTuple()</code>。</p><p id="830c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">正如<a class="ae kl" href="https://beam.apache.org/documentation/transforms/python/elementwise/map/" rel="noopener ugc nofollow" target="_blank">文档</a>所观察到的:“如果您的PCollection由(key，value)对组成，您可以使用MapTuple将它们解包到不同的函数参数中。”</p><p id="dae1" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">在我们的例子中，我们将一个定制的格式化函数<code class="du kr ks kt ku b">format_result</code>传递给MapTuple()转换。这个<code class="du kr ks kt ku b">format_result</code>函数接受每个元素的元组的两个部分，“word”和“count”，并将它们作为重新格式化的字符串返回。</p><p id="e082" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">代码现在看起来像这样:</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es md"><img src="../Images/c86cb83e11887e9fc475a46e729bad55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*411wirlxTsFtGMQM0w61mA.png"/></div></div></figure><p id="f5cb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">这种重新格式化转换的输出来自:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="3556" class="ld iy hi ku b be le lf l lg lh">('KING', 243)<br/>('LEAR', 236)<br/>('DRAMATIS', 1)<br/>('PERSONAE', 1)<br/>('king', 65)<br/>('of', 447)<br/>('Britain', 2)<br/>('OF', 15)<br/>('FRANCE', 10)<br/>('DUKE', 3)<br/>('BURGUNDY', 8)<br/>('CORNWALL', 63)<br/>('ALBANY', 67)<br/>('EARL', 2)<br/>('KENT', 156)<br/>('GLOUCESTER', 141)<br/><br/>...</span></pre><p id="b1ff" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">对此:</p><pre class="kv kw kx ky fd kz ku la bn lb lc bi"><span id="0f43" class="ld iy hi ku b be le lf l lg lh">KING: 243<br/>LEAR: 236<br/>DRAMATIS: 1<br/>PERSONAE: 1<br/>king: 65<br/>of: 447<br/>Britain: 2<br/>OF: 15<br/>FRANCE: 10<br/>DUKE: 3<br/>BURGUNDY: 8<br/>CORNWALL: 63<br/>ALBANY: 67<br/>EARL: 2<br/>KENT: 156<br/>GLOUCESTER: 141<br/><br/>...</span></pre><h1 id="db5b" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">步骤12:链接转换</h1><p id="c1db" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们已经到达了旅程的终点！我们将以重命名和重新格式化射束管道代码中的步骤来结束，以匹配基线<code class="du kr ks kt ku b">wordcount.py</code>文件。请注意如何将转换链接在一起，每一行都以管道操作符开始:</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es me"><img src="../Images/e835a02331f214f5da46c224419ec199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sw5zB4WZEAGMIJZ-OY885A.png"/></div></div></figure><p id="9a4a" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">尽管链接的步骤看起来有些不同，但同样的<code class="du kr ks kt ku b">[Output PCollection] = [Input PCollection] | [Transform]</code>流程仍然适用，输出也是一样的。</p><p id="7d75" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">还要注意在这一步中我如何包含了<code class="du kr ks kt ku b">SetupOptions</code>类来“保存主会话”正如最初的<code class="du kr ks kt ku b">wordcount.py</code>注释继续陈述的那样:“我们使用save_main_session选项，因为该工作流中的一个或多个DoFn依赖于全局上下文(例如，在模块级导入的模块)。”当我在我的本地机器上运行它时，它的缺失并没有引起问题，但是为了完整起见，我把它包括进来了。</p><p id="2c6c" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">就是这样！我们完了！</p><h1 id="cf57" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">附录</h1><p id="8e4f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了进一步扩展你的知识和学习，这里还有两件事你可以试试:</p><ol class=""><li id="ba2a" class="mf mg hi jr b js km jv kn jy mh kc mi kg mj kk mk ml mm mn bi translated">修改管道代码，在计算之前将所有单词字符串转换为小写。答案在教程第7步<a class="ae kl" href="https://cloud.google.com/dataflow/docs/quickstarts/create-pipeline-python#modify-the-pipeline-code" rel="noopener ugc nofollow" target="_blank">中找到。</a></li><li id="9ea2" class="mf mg hi jr b js mo jv mp jy mq kc mr kg ms kk mk ml mm mn bi translated">尝试将您的管道部署到Google Cloud上的数据流运行器。<a class="ae kl" href="https://cloud.google.com/dataflow/docs/quickstarts/create-pipeline-python#run-the-pipeline-on-the-dataflow-service" rel="noopener ugc nofollow" target="_blank">详情在此</a>。</li></ol><h1 id="99d6" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">结论</h1><p id="b98a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这是一个循序渐进、反复探索的Python教程的数据流快速入门。我希望这种方法有助于您对Apache Beam的Python SDK如何工作有一个基本的了解。</p><p id="5774" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">如果我遗漏了什么或者有什么步骤需要进一步澄清，请在评论中告诉我。</p><p id="fcbb" class="pw-post-body-paragraph jp jq hi jr b js km ij ju jv kn im jx jy ko ka kb kc kp ke kf kg kq ki kj kk hb bi translated">保重！</p><h1 id="4e69" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">代码许可证</h1><p id="774a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">本指南中的所有代码截图都包含在<a class="ae kl" href="http://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"> Apache许可证2.0版</a>中</p></div></div>    
</body>
</html>