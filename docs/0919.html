<html>
<head>
<title>Uploading data to Firestore using Dataflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用数据流将数据上传到Firestore</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/uploading-data-to-firestore-using-dataflow-67ebecabf3b8?source=collection_archive---------0-----------------------#2019-02-14">https://medium.com/google-cloud/uploading-data-to-firestore-using-dataflow-67ebecabf3b8?source=collection_archive---------0-----------------------#2019-02-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b0c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Firestore是谷歌云平台上的下一代NoSQL数据库，增加了对云数据存储的各种改进，如实时更新、强一致性查询等。它最近被提升为全面可用，所以是时候深入了解它了。</p><p id="152a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Firestore有两种风格。一个是本机模式，类似于新Firestore的所有功能，而第二个是数据存储模式，适合希望继续使用数据存储(向后兼容)和属性的用户，尽管是在Firestore上运行的引擎盖下。</p><p id="81f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Firestore通过<a class="ae jd" href="https://firebase.google.com/docs/firestore/manage-data/export-import" rel="noopener ugc nofollow" target="_blank"> Cloud SDK </a>提供数据导出/导入，但是如果你需要初始批量导入来加载数据到Firestore呢？</p><p id="ba36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于我之前的例子<a class="ae jd" rel="noopener" href="/google-cloud/uploading-data-to-cloud-datastore-using-dataflow-26c2588b9a8d">使用数据流</a>上传数据到云数据库，我想再次使用Apache Beam运行在数据流上。从这个意义上说，数据流是伟大，它足以为管道编写代码，它自动为批处理作业提供服务器(工人),当它完成时，它清理一切。</p><p id="9b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于Firestore相对较新，并不是所有地方都支持Firestore，这也与Apache Beam有关，但情况并不那么糟糕。我将描述我使用Beam向Firestore Native上传批量数据的两种方式。仅给出背景，我将上传120万条包含基于Best Buy数据集的产品信息的记录。Python (2.7)代码在<a class="ae jd" href="https://github.com/zdenulo/upload-data-firestore-dataflow" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><h2 id="7ec9" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">1.使用datastoreio</h2><p id="c125" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">由于没有将数据写入Firestore的本机转换，出于好奇，我尝试使用相同的数据存储。在我的数据存储示例中，我创建了自定义DoFn来创建数据存储实体，我在本例中也使用了该实体。</p><p id="57fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个管道看起来像这样:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="43c4" class="je jf hi kj b fi kn ko l kp kq">with beam.Pipeline(options=options) as p:<br/>        (p | 'Reading input file' &gt;&gt; beam.io.ReadFromText(input_file_path)<br/>         | 'Converting from csv to dict' &gt;&gt; beam.ParDo(CSVtoDict(),['sku', 'name', 'regularPrice',  'salePrice', 'type', 'url', 'image',                                 'inStoreAvailability'])<br/>         | 'Create entities' &gt;&gt; beam.ParDo(CreateEntities())<br/>         | 'Write entities into Datastore' &gt;&gt; WriteToDatastore(PROJECT)<br/>         )</span></pre><p id="c764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在csvtoDict中，我将CSV行解析为Python字典，CreateEntities转换如下所示:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="ca87" class="je jf hi kj b fi kn ko l kp kq">class CreateEntities(beam.DoFn):<br/>    """Creates Datastore entity"""<br/>    def process(self, element):<br/>        entity = entity_pb2.Entity()<br/>        sku = int(element.pop('sku'))<br/>        element['regularPrice'] = float(element['regularPrice'])<br/>        element['salePrice'] = float(element['salePrice'])<br/>        element['name'] = unicode(element['name'].decode('utf-8'))<br/>        element['type'] = unicode(element['type'].decode('utf-8'))<br/>        element['url'] = unicode(element['url'].decode('utf-8'))<br/>        element['image'] = unicode(element['image'].decode('utf-8'))<br/>        element['inStoreAvailability'] = unicode(element['inStoreAvailability'])<br/><br/>        datastore_helper.add_key_path(entity.key, 'Product', sku)<br/>        datastore_helper.add_properties(entity, element)<br/>        return [entity]</span></pre><p id="af00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，在我的项目中，我在本地模式下使用Firestore，它上传数据没有任何问题。我注意到的唯一不寻常的事情是密钥被更改了，例如，如果我将id设置为1，在Firestore文档中id是__id1__，即，它在我的id“__ id”之前和“_ _”之后添加，不知道为什么。</p><p id="2997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法感觉有点像欺骗，因为据我所知，应该不可能将数据存储API与Firestore Native一起使用(反之亦然)，尽管这一切都归结于协议缓冲区，或者这可能是一些过渡状态，我很好奇更深入的解释。</p><p id="6289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一句话:如果你可以忍受修改的id，并且不上传一些非常复杂的——多次嵌套的文档，这应该没问题。</p><p id="b6a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是用其他支持的字段类型创建的代码示例</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="272c" class="je jf hi kj b fi kn ko l kp kq">class CreateEntities(beam.DoFn):<br/>    """Creates Datastore entity with different types of fields, just to verify what is possible"""<br/><br/>    def process(self, idx):<br/>        entity = entity_pb2.Entity()<br/>        embed = entity_pb2.Entity()  # embedded document<br/>        ss = {<br/>            'ss': unicode('X'),  # string<br/>            'bb': False,  # boolean<br/>            'll': [1, 2, 3],  # list of integers<br/>            'ii': 123  # integer<br/>        }<br/>        datastore_helper.add_properties(embed, ss)  # setting properties for embedded document<br/>        element = dict()<br/>        element['s'] = unicode('String')  # string<br/>        element['b'] = True  # boolean<br/>        element['l'] = [unicode('s'), unicode('a'), unicode('b')]  # list of strings<br/>        element['i'] = 1  # integer<br/>        element['e'] = embed  # embedded document<br/>        datastore_helper.add_key_path(entity.key, 'ds', idx)  # setting id for document<br/>        datastore_helper.add_properties(entity, element)  # setting properties for document<br/>        return [entity]</span></pre><p id="b70e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Firestore UI中，它看起来像这样:</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es kr"><img src="../Images/f6449da1c8ffb98205f8a5b1ce8a2b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*Clz4WEND13yFXzRI.png"/></div></figure><h2 id="55a1" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">2.使用Firestore客户端库</h2><p id="0683" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">当你不知道什么的时候，你谷歌一下，如果它与软件开发有关，第一个答案来自于<a class="ae jd" href="https://stackoverflow.com/questions/52637894/write-data-into-google-firestore-in-pipeline" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>，这启发了我使用<a class="ae jd" href="https://googleapis.github.io/google-cloud-python/latest/firestore/index.html" rel="noopener ugc nofollow" target="_blank"> Python的Firestore客户端库</a>来创建我自己的简单转换。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="647a" class="je jf hi kj b fi kn ko l kp kq">class FirestoreWriteDoFn(beam.DoFn):<br/>    MAX_DOCUMENTS = 200<br/><br/>    def __init__(self, project, collection):<br/>        self._project = project<br/>        self._collection = collection<br/>        super(FirestoreWriteDoFn, self).__init__()<br/><br/>    def start_bundle(self):<br/>        self._mutations = []<br/><br/>    def finish_bundle(self):<br/>        if self._mutations:<br/>            self._flush_batch()<br/><br/>    def process(self, element, *args, **kwargs):<br/>        self._mutations.append(element)<br/>        if len(self._mutations) &gt; self.MAX_DOCUMENTS:<br/>            self._flush_batch()<br/><br/>    def _flush_batch(self):<br/>        db = firestore.Client(project=self._project)<br/>        batch = db.batch()<br/>        for mutation in self._mutations:<br/>            if len(mutation) == 1:<br/>                # autogenerate document_id<br/>                ref = db.collection(self._collection).document()<br/>                batch.set(ref, mutation)<br/>            else:<br/>                ref = db.collection(self._collection).document(mutation[0])<br/>                batch.set(ref, mutation[1])<br/>        r = batch.commit()<br/>        logging.debug(r)<br/>        self._mutations = []</span></pre><p id="f368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是受<a class="ae jd" href="https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/gcp/datastore/v1/datastoreio.py" rel="noopener ugc nofollow" target="_blank"> datastoreio </a>模块的启发，该模块更加复杂和强大，即它具有重试、根据延迟自动调整写入等功能。</p><p id="bbde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然Firestore支持每次批量写入最多500个文档或每次调用10MB，但为了安全起见，我使用了200个。在_flush_batch方法中，我添加了文档上传时没有id的情况，虽然我没有使用。</p><p id="ba01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个管道的步骤与之前的步骤相同，只是在引擎盖下有一些变化:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="e852" class="je jf hi kj b fi kn ko l kp kq">with beam.Pipeline(options=options) as <em class="kv">p</em>:<br/>    (<em class="kv">p </em>| 'Reading input file' &gt;&gt; beam.io.ReadFromText(input_file_path)<br/>     | 'Converting from csv to dict' &gt;&gt; beam.ParDo(CSVtoDict(),<br/>                                                   ['sku', 'name', 'regularPrice', 'salePrice', 'type', 'url', 'image',<br/>                                                    'inStoreAvailability'])<br/>     | 'Create entities' &gt;&gt; beam.ParDo(CreateEntities())<br/>     | 'Write entities into Firestore' &gt;&gt; WriteToDatastore(<em class="kv">PROJECT</em>)<br/>     )</span></pre><p id="a791" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在CreateEntities转换中，我提取数据并准备写入:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="526a" class="je jf hi kj b fi kn ko l kp kq">class CreateEntities(beam.DoFn):<br/>    """Creates Datastore entity"""<br/><br/>    def process(self, element):<br/>        document_id = unicode(element.pop('sku'))<br/>        element['regularPrice'] = float(element['regularPrice'])<br/>        element['salePrice'] = float(element['salePrice'])<br/>        element['name'] = unicode(element['name'].decode('utf-8'))<br/>        element['type'] = unicode(element['type'].decode('utf-8'))<br/>        element['url'] = unicode(element['url'].decode('utf-8'))<br/>        element['image'] = unicode(element['image'].decode('utf-8'))<br/>        element['inStoreAvailability'] = unicode(element['inStoreAvailability'])<br/>        return [(document_id, element)]</span></pre><p id="e76d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是数据流作业的详细信息。</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es kw"><img src="../Images/a8c0a41e50ddf07629ea27372c3851db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/0*XqEAfRH4OejnT6F4.png"/></div></figure><p id="541d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个工作需要14–15分钟(包括资源调配)。数据流成本为0.12美元，Firebase成本为2.26美元(约120万次写操作)。在工作完成之前，工人人数增加到19人。时间与我的数据存储上传作业类似，尽管在这种情况下，它使用的工作线程数量较少(数据存储作业为19对60)。</p></div></div>    
</body>
</html>