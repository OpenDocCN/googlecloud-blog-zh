<html>
<head>
<title>Secure GraphQL APIs in minutes with Cloud Run and GRAND Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用云运行和大堆栈在几分钟内保护GraphQL APIs</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/secure-graphql-apis-in-minutes-with-google-cloud-run-and-grand-stack-97d050dbc744?source=collection_archive---------1-----------------------#2019-06-06">https://medium.com/google-cloud/secure-graphql-apis-in-minutes-with-google-cloud-run-and-grand-stack-97d050dbc744?source=collection_archive---------1-----------------------#2019-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8bc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud最近在下一届' 19大会上宣布了<a class="ae jd" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank"> Cloud Run </a>，我想踢踢轮胎。Cloud Run让您轻松运行无状态容器，Google为您管理基础设施和扩展。您可以以类似于Google Cloud函数的方式使用它们，除了您可以带来任何您喜欢的运行时，因为您正在部署Docker容器。</p><p id="7d71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想我应该尝试将Cloud Run作为GraphQL应用程序的无服务器后端，结果证明这非常简单！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/406c9fb1d299894c477bc9e846523030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETaUHTD30rKa29ZVkCk2bw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">云作为GraphQL API的无服务器后端运行</figcaption></figure><p id="6f25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图显示了我们将要设置的内容。从模式开始，我们想建立一个GraphQL微服务。用户发出查询，由运行在Cloud Run上的无服务器后端处理。后端使用Neo4j数据库来存储数据。整个设置由OAuth2层保护。</p><blockquote class="ju jv jw"><p id="dac5" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">graph QL是什么？</strong>它是一种API的查询语言，也是一个用现有数据完成这些查询的运行时。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。(GraphQL.org)</p></blockquote><p id="206d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我保证，这将会相对简单，因为谷歌将会为我们做很多事情。我们开始吧！</p><h1 id="531b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">第一步:制作数据库</h1><p id="615e" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">我们需要一个地方来存放我们的数据。我在GCP市场推出了<a class="ae jd" href="https://console.cloud.google.com/marketplace/details/neo4j-public/neo4j-enterprise-causal-cluster?q=neo4j&amp;id=551c0a32-fb3c-4c83-a362-595cf28649cd" rel="noopener ugc nofollow" target="_blank"> Neo4j企业</a>。因为Neo4j是一个本地图形数据库，它特别适合支持GraphQL APIs，遵循<a class="ae jd" href="https://grandstack.io/" rel="noopener ugc nofollow" target="_blank"> GRAND Stack </a>模式。</p><p id="2242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">建立数据库只需要填写一些值，并将其启动到您选择的GCP项目中。<a class="ae jd" href="https://neo4j.com/developer/neo4j-google-cloud-launcher/" rel="noopener ugc nofollow" target="_blank">关于如何做到这一点的文档可以在这里找到</a>。几分钟后，我的部署完成，我有了数据库的端点URL、用户名和密码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es le"><img src="../Images/619b6e157d3ea191a54eb5e3970698e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzE63KdJrvi--z0ntBld_A.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Neo4j集群准备就绪！</figcaption></figure><p id="c9b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jx">关于Kubernetes </em>的说明:Neo4j也<a class="ae jd" href="https://console.cloud.google.com/marketplace/details/neo4j-public/causal-cluster-k8s" rel="noopener ugc nofollow" target="_blank">可用于GKE </a>，当然，如果我们愿意，云运行允许我们将容器部署到现有集群中。这是一个很好的选择，但是为了简化设置，我们今天将使用虚拟机，这样我们就不需要创建和配置GKE集群。</p><h1 id="b534" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">步骤2:创建云运行服务</h1><p id="bb9f" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">让我们转到<a class="ae jd" href="https://console.cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">云运行控制台</a>，点击“创建服务”按钮。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lf"><img src="../Images/d33ce56515d89af412e98de6ee03d187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*CoY6nOTe9EsjuBn1LZ-GhA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">创建云运行服务</figcaption></figure><p id="ebea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在使用一个我为此构建的小型实用容器，名为<a class="ae jd" href="https://github.com/moxious/plumbline" rel="noopener ugc nofollow" target="_blank"> Plumbline </a>。这个容器基本上只是一个简单node.js程序的Dockerfile包装器，该程序使用<a class="ae jd" href="https://github.com/neo4j-graphql/neo4j-graphql-js" rel="noopener ugc nofollow" target="_blank"> neo4j-graphql-js </a>连接到neo4j。这段代码管理GraphQL层，并将用户查询翻译成Neo4j使用的底层数据库查询语言(Cypher)。我们正在部署的容器图像URL是我的公共版本，<code class="du lg lh li lj b">gcr.io/neo4j-k8s-marketplace-public/plumbline:0.0.1</code>，但是当然您可以自己从源代码构建它，或者使用任何其他容器。</p><p id="64e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只需要一个GraphQL typedefs列表和一些新数据库的连接信息就可以工作了。Neo4j-graphql-js处理所有其他事情，包括自动向我们的模式添加访问器和赋值器。</p><blockquote class="ju jv jw"><p id="bf36" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">Neo4j-graphql-js非常方便，因为它让我们专注于编写一个简单的领域模型，并且大部分样板文件可以自动处理。</p></blockquote><p id="0097" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一小组GraphQL typedefs。我们将从一个完全空白的图表开始，并希望按照这个模型创建我们的信息:</p><pre class="jf jg jh ji fd lk lj ll lm aw ln bi"><span id="06ef" class="lo kc hi lj b fi lp lq l lr ls">type Person {<br/>   name: String!<br/>   knows: [Person] @relation(name: "KNOWS", direction: "OUT")<br/>   likes: [Hobby] @relation(name: "LIKES", direction: "OUT")<br/>}</span><span id="1ccc" class="lo kc hi lj b fi lt lq l lr ls">type Hobby {<br/>   name: String!<br/>   liked_by: [Person] @relation(name: "LIKES", direction: "IN")<br/>}</span></pre><p id="4188" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">够简单；我们已经命名了可以认识其他人的人，也可以有自己喜欢的爱好的人。这个简单的图表可以帮助我们推荐谁介绍谁，因为我们有共同的兴趣！</p><p id="87e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那些<code class="du lg lh li lj b">@relation</code>指令是neo4j-graphql-js关于如何存储相关信息的提示。我们的“Person”项将是图中的节点，我们将在Neo4j中存储“KNOWS”关系来处理这些关系。如果你想知道所有这些是如何工作的全部细节，请参考neo4j-graphql-js文档。</p><h1 id="213b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">步骤3:配置服务来提供GraphQL API</h1><p id="bc27" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">接下来，在我们的“创建服务”屏幕中，我们需要设置环境变量，这些变量最初隐藏在“显示可选设置”按钮后面。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lu"><img src="../Images/d95abe9ca495732bb609974a9124ed1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*lIRioLL1cogskKGze9Q0KQ.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">定义必要的环境变量</figcaption></figure><p id="63c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这让我们的容器知道如何连接到我们的数据库，以及应该使用哪组typedefs来创建GraphQL API。</p><p id="2a0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后点击创建！片刻之后:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lv"><img src="../Images/701cd74e376e765cf4f992cf9e3ed1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*segwgEHDLw6UsEwNydXQSg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">我们的工作部署！</figcaption></figure><h1 id="662d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">认证和授权</h1><p id="6b1f" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">由于我们创建了一个数据库，并且我们准备好读写数据，向世界公开这样一个API并不是一个好主意。如果我们愿意，云运行允许我们公开暴露端点，但是我们没有选择这个选项。</p><p id="324c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cloud Run的默认设置是，你可以免费获得一个OAuth2层，它由你的Google Cloud项目所拥有的相同权限提供支持。通过使用常规gcloud命令生成OAuth2“承载令牌”,您可以对我们刚刚创建的端点进行身份验证。</p><p id="059b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这非常方便，因为它使我们不必在docker容器本身中有额外的认证逻辑！谷歌还提供了文档，说明你的容器如何使用这个令牌来获取用户T2的信息。</p><p id="7586" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想知道如何获得允许您对端点进行身份验证的令牌，就像这样:</p><pre class="jf jg jh ji fd lk lj ll lm aw ln bi"><span id="aeae" class="lo kc hi lj b fi lp lq l lr ls">export TOKEN=$(gcloud config config-helper --format 'value(credential.id_token)' --force-auth-refresh)</span></pre><h1 id="3bae" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">步骤4:使用我们的新API！</h1><p id="c211" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">为了简单起见，您可以使用<code class="du lg lh li lj b">curl</code>来使用我们的新API，它有一个HTTPS端点。为了工作，<strong class="ih hj"> curl需要发送不记名令牌来授权我们的新服务</strong>，还需要设置一些额外的头。</p><p id="b344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个关于我们如何使用API的curl示例:</p><pre class="jf jg jh ji fd lk lj ll lm aw ln bi"><span id="fa80" class="lo kc hi lj b fi lp lq l lr ls">curl $ENDPOINT -H 'Content-Type: application/json' -H 'Accept: application/json' -H "Authorization: Bearer $TOKEN" --data-binary '{"query":"mutation {\n  CreatePerson(name:\"Will\"){\n    name\n  }\n}\n"}'</span></pre><p id="ac6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，将GraphQL查询格式化为curl的JSON很快就会过时，所以我使用了一个<a class="ae jd" href="https://launchpad.graphql.com/new" rel="noopener ugc nofollow" target="_blank"> Apollo Launchpad </a>来发布我的查询。如果你在家里尝试这样做，你需要确保你的启动板，无论你在哪里运行它，都包括这个不记名令牌，否则你会得到未经授权的错误。</p><p id="e0ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创造一个人和一个爱好。这些变异函数是由上面提到的neo4j-graphql-js提供的，并且是自动生成的，与我们漂亮的GraphQL typedefs一起使用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/53d09f00d00ef5445f785e95ebd97186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pg3g8nV7Dn7HGE1skQbXg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">创造一个人和一个爱好</figcaption></figure><p id="689e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们再创造一个人，“威尔”，断言大卫喜欢吉他。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/ce00ab727360b1b1382c95c33ea749dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IBRRiak7jnTyOkFqRferw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">创造另一个人，并声称大卫喜欢吉他</figcaption></figure><p id="e973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">威尔也喜欢吉他。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ly"><img src="../Images/008a059b4c592eaa714567981af80c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Di70EowLhDECZ8pEDjEoXA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">威尔也喜欢吉他！</figcaption></figure><p id="8a17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们有了一个简单的图表，我们可以使用一个常规的GraphQL查询来检查我们的数据是否在那里:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lz"><img src="../Images/f1cd8b3297bc0175cbff4963a90d3473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*145sYLjgaLEFgBOCxhPFdw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">对我们刚刚存储的数据的GraphQL查询</figcaption></figure><p id="ef9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Neo4j浏览器端的后端，我们可以看到同样的情况，使用的是Cypher。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/4f97d6eb26bb663146bff90d0d08d108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gm90V34r-SR1bPJPFHcwJQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Neo4j浏览器反映了我们通过GraphQL创建的相同图形</figcaption></figure><h1 id="078b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="e46b" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">云运行是部署易于管理和使用的无服务器后端的好方法。在Google Marketplace上结合neo4j-graphql-js和neo4j，您可以非常快速地建立一个完整的GraphQL API，并将其作为一个微服务，作为更大解决方案的一部分。</p><p id="ecf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这里，我们可以:</p><ol class=""><li id="442f" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">使用我们的后端API，构建一个React应用程序来匹配基于共同兴趣的人</li><li id="6eee" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">让其他微服务根据需要调用这个服务，以便为更大的应用程序提供图形存储</li></ol></div></div>    
</body>
</html>