<html>
<head>
<title>Large data processing with Cloud Dataflow and Cloud Datastore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云数据流和云数据存储进行大数据处理</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/large-data-processing-with-cloud-dataflow-and-cloud-datastore-839aae5ee372?source=collection_archive---------1-----------------------#2019-03-04">https://medium.com/google-cloud/large-data-processing-with-cloud-dataflow-and-cloud-datastore-839aae5ee372?source=collection_archive---------1-----------------------#2019-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a754" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何并行处理大规模csv文件。</h2></div><p id="9aff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的一个<a class="ae jt" href="https://ioannotator.com" rel="noopener ugc nofollow" target="_blank">项目</a>中，我需要处理大小从几百MB到GB甚至TB的大型文本文件。用户上传一个csv文件，我们需要将每一行写入<a class="ae jt" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank">谷歌云数据存储</a>(非SQL文档数据库)。</p><p id="d012" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，在这个大小范围内，使用简单的web服务器是无法存档的。这就是我利用<a class="ae jt" href="https://cloud.google.com/dataflow" rel="noopener ugc nofollow" target="_blank">谷歌云数据流</a>的地方，我编写了一个管道来处理这些csv文件，并将它们保存到谷歌云数据存储中。在这篇文章中，我想和你分享我是如何解决这个任务的。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/776643dbf536152ae53ff15d487b0582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HlcV4TVVnyMAcVLu5Su0A.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">运行中的数据流</figcaption></figure><blockquote class="kk"><p id="03ed" class="kl km hi bd kn ko kp kq kr ks kt js dx translated">大规模的文本注释可能很难，这就是为什么我目前正在构建一个可以在机器学习项目中使用的文本注释器。这篇文章是基于我在实现过程中的学习。如果你不想错过，就在Twitter上关注我吧。</p></blockquote><h1 id="08b8" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">先决条件</h1><p id="c4c9" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">您需要两个需求:第一个是apache beam本身，第二个是数据流。请记住，如果您想在本地运行您的管道，您需要使用Python 2.7。Apache Beam还是<a class="ae jt" href="https://issues.apache.org/jira/browse/BEAM-1251" rel="noopener ugc nofollow" target="_blank">不支持Python 3 </a>。</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="de6b" class="lw kv hi ls b fi lx ly l lz ma">pip install apache-beam<br/>pip install apache-beam[gcp]</span></pre><p id="9ccb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对<a class="ae jt" href="https://beam.apache.org/documentation/" rel="noopener ugc nofollow" target="_blank"> Apache Beam </a>和<a class="ae jt" href="https://cloud.google.com/dataflow/docs/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Dataflow </a>的基本了解是有益的。</p><h1 id="6b3a" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">如何启动数据流管道</h1><p id="b1f7" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">基本上，您有五种选择来启动管道:</p><ul class=""><li id="c454" class="me mf hi iz b ja jb jd je jg mg jk mh jo mi js mj mk ml mm bi translated">在本地，此选项适用于开发目的。</li><li id="1b81" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated">如果你想运行一次管道，直接在数据流中。</li><li id="7a58" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated">在数据流用户界面中。</li><li id="c967" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated">使用gcloud命令。</li><li id="9664" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mj mk ml mm bi translated">Via <a class="ae jt" href="https://cloud.google.com/dataflow/docs/reference/rest/" rel="noopener ugc nofollow" target="_blank">云数据流API </a>。</li></ul><p id="0c0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，对于最后3个选项，您需要创建一个数据流模板。</p><h1 id="5abd" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">云数据流模板</h1><p id="1471" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">要创建数据流模板，您必须使用<strong class="iz hj">add _ value _ provider _ argument</strong>value provider。这就是我们将参数传递给数据流管道的方式。例如，在我们的例子中，csv文件的路径。</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="36bd" class="lw kv hi ls b fi lx ly l lz ma">class ProcessOptions(PipelineOptions):</span><span id="654a" class="lw kv hi ls b fi ms ly l lz ma"><a class="ae jt" href="http://twitter.com/classmethod" rel="noopener ugc nofollow" target="_blank">@classmethod</a><br/>    def _add_argparse_args(cls, parser):<br/>        parser.add_value_provider_argument(<br/>           '--input',<br/>           dest='input',<br/>           type=str,<br/>           required=False,<br/>           help='Local file or a file in a Google Storage Bucket.')</span></pre><p id="3b7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您不使用模板，您可以简单地使用:</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="2945" class="lw kv hi ls b fi lx ly l lz ma">parser.add_argument(...)</span></pre><h1 id="268f" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">建造管道</h1><p id="bd67" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">为了构建管道，我们创建一个管道对象并将<code class="du mt mu mv ls b">PipelineOptions</code>传递给它。</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="130d" class="lw kv hi ls b fi lx ly l lz ma">process_options = PipelineOptions().view_as(ProcessOptions)<br/>p = beam.Pipeline(options=process_options)</span></pre><p id="6f94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的管道由4个不同的步骤组成:</p><ol class=""><li id="e574" class="me mf hi iz b ja jb jd je jg mg jk mh jo mi js mw mk ml mm bi translated"><strong class="iz hj">从文本中读取:</strong>从本地路径或Google Cloud Bucket中读取输入文件，这是我们的管道数据。</li><li id="58df" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi translated"><strong class="iz hj">处理CSV: </strong>我们的第一个<a class="ae jt" href="https://beam.apache.org/documentation/programming-guide/#transforms" rel="noopener ugc nofollow" target="_blank">转换</a>，它接受数据中的每一行并提取所需的信息。</li><li id="620b" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi translated"><strong class="iz hj">构建实体:</strong>创建云数据存储实体</li><li id="9d9c" class="me mf hi iz b ja mn jd mo jg mp jk mq jo mr js mw mk ml mm bi translated"><strong class="iz hj">写实体:</strong>最后将每一行作为一个实体写入云数据存储。</li></ol><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="59ee" class="lw kv hi ls b fi lx ly l lz ma">(p<br/>     | 'Read from text' &gt;&gt; beam.io.ReadFromText(process_options.input, skip_header_lines=0)<br/>     | 'Process CSV' &gt;&gt; <br/>beam.ParDo(ProcessCSV(),['text','label'])<br/>     | 'Build entities' &gt;&gt; <br/>beam.ParDo(BuildEntities(), process_options.entity)<br/>     | 'Write entities into Datastore' &gt;&gt; <br/>WriteToDatastore('annotator'))</span></pre><p id="b4d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们运行我们的管道。</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="7571" class="lw kv hi ls b fi lx ly l lz ma">p.run().wait_until_finish()</span></pre><h1 id="6cbe" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">创建数据流模板</h1><p id="28c6" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">要创建模板，我们必须用模板的Google云存储位置来定义<code class="du mt mu mv ls b">--template_location</code>。该命令如下所示:</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="d2e9" class="lw kv hi ls b fi lx ly l lz ma">python2 -m process \     <br/>  --runner DataflowRunner \     <br/>  --project io-annotator \     <br/>  --staging_location gs://io-dataflow/staging \     <br/>  --temp_location gs://io-dataflow/temp \     <br/>  --template_location gs://io-dataflow/templates/process-csv \    <br/>  --save_main_session True</span></pre><p id="09b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该命令在给定的<code class="du mt mu mv ls b">--template_location</code>处创建模板:</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="79f8" class="lw kv hi ls b fi lx ly l lz ma">INFO:root:A template was just created at location gs://io-dataflow/templates/process-csv</span></pre><p id="a13d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您的存储桶现在应该包含两个文件夹staging和template:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ca"><img src="../Images/3c6213b8254c2df1bf749e93390b6d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_15uO0H6JTCJ0P5kGT_Vw.png"/></div></div></figure><h1 id="8aaa" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">[计]元数据</h1><p id="07fd" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">此外，我们用元数据扩展模板，以验证我们的参数，并将有价值的信息添加到数据流UI中。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mx"><img src="../Images/43c4d218947a81718087bb3c8cc2a853.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*3TL7jWJPn10gy2D1mXg6CQ.png"/></div></figure><p id="5ba4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">元数据文件遵循这个命名<code class="du mt mu mv ls b">&lt;template-name&gt;_metadata</code>，必须上传到templates文件夹。</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="fd41" class="lw kv hi ls b fi lx ly l lz ma">{<br/>  "name": "Transform CSV",<br/>  "description": "Transforms a csv file and saves it into Cloud Datastore",<br/>  "parameters": [{<br/>    "name": "input",<br/>    "label": "Input Cloud Storage file",<br/>    "help_text": "The path to the csv file in Google Cloud Storage Bucket",<br/>    "regexes": ["^gs:\/\/[^\n\r]+$"],<br/>    "is_optional": false<br/>  },<br/>  {<br/>    "name": "entity",<br/>    "label": "Cloud Datastore entity name",<br/>    "help_text": "The Google Cloud Datastore entity name",<br/>    "is_optional": false<br/>  }]<br/>}</span></pre><h1 id="c451" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">启动数据流模板</h1><p id="d6e5" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在本文中，我们将模板用于数据流用户界面。</p><p id="2cc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要启动模板，请转到<a class="ae jt" href="https://console.cloud.google.com/dataflow/createjob" rel="noopener ugc nofollow" target="_blank">数据流创建作业页面</a>并选择自定义模板作为云数据流模板。我们需要额外的参数输入云存储文件和云数据存储实体名称。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es my"><img src="../Images/c46c5cc3f492cdf4dfbfe662794ae6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*LNmLvTSXHjHD9YB6udkMyg.png"/></div></figure><p id="75dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行作业并切换到云数据存储区以查看结果。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mz"><img src="../Images/40b0b4f368d20c8f629492ba1e992964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQgCPJFWhI0HyCXNQSSk0g.png"/></div></div></figure><h1 id="9534" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">属国</h1><p id="520a" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">这个话题花了我一些时间，☕，这就是为什么我想与你分享解决方案。</p><p id="d49f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然DirectRunner在本地一切正常，但当我尝试在数据流中启动管道时，出现了以下错误:</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="f6ca" class="lw kv hi ls b fi lx ly l lz ma">NameError: global name 'csv' is not defined</span></pre><p id="23d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">原来，像<code class="du mt mu mv ls b">import csv </code>这样的函数、变量和全局导入在云数据流作业的序列化过程中不会被保存。换句话说，全局名称空间的状态没有加载到云数据流工作器上。</p><p id="f063" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看<a class="ae jt" href="https://cloud.google.com/dataflow/docs/resources/faq?hl=en#how_do_i_handle_nameerrors" rel="noopener ugc nofollow" target="_blank">数据流常见问题解答</a>有助于解决这个问题，只需添加一个额外的管道选项。</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="9855" class="lw kv hi ls b fi lx ly l lz ma">--save_main_session True</span></pre><h1 id="894d" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">云数据存储限制</h1><p id="7308" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">云数据存储对UTF-8编码的属性有1500字节的限制。这意味着如果你想保存更多的单词，那么你会得到一个错误。如果你看一下<a class="ae jt" href="https://cloud.google.com/datastore/docs/concepts/limits?hl=en" rel="noopener ugc nofollow" target="_blank">文档</a>，你会很快注意到它只是对索引属性的一个限制。未编制索引的属性的最大大小是1 MB，这足以满足我们的要求。</p><p id="53b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下设置将属性从索引中排除。作为交换，你不能再搜索这个属性。</p><pre class="jv jw jx jy fd lr ls lt lu aw lv bi"><span id="e418" class="lw kv hi ls b fi lx ly l lz ma">exclude_from_indexes=True</span></pre><h1 id="079b" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">包扎</h1><p id="d0df" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">我希望我能与你分享如何使用云数据流来处理存储在谷歌云存储中的大文件，并将它们转换为云数据存储实体。</p><p id="f3fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为下一篇文章的一部分，我将与您分享如何将云功能和云数据流结合到无服务器的大型数据处理环境中，因为我们希望实现完全自动化的管道。</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="a8d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="nh">感谢阅读。</em></p><p id="409f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="nh">本文的代码和示例数据可在</em> <a class="ae jt" href="https://github.com/SaschaHeyer/Io-Data-Processing" rel="noopener ugc nofollow" target="_blank"> <em class="nh"> GitHub </em> </a> <em class="nh">上获得。</em></p><p id="936e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢我的文章，请留下一些掌声👏。<br/>非常感谢您的反馈和问题，您可以在Twitter上找到我<a class="ae jt" href="https://twitter.com/HeyerSascha" rel="noopener ugc nofollow" target="_blank"><em class="nh">@ HeyerSascha</em></a><em class="nh">。</em></p><h1 id="c011" class="ku kv hi bd kw kx ky kz la lb lc ld le io mb ip lg ir mc is li iu md iv lk ll bi translated">关于作者</h1><p id="50a0" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated"><a class="ae jt" href="https://twitter.com/HeyerSascha" rel="noopener ugc nofollow" target="_blank">Sascha Heyer</a>Io Annotator创始人一个针对文本和图像的AI注释平台<br/>，它提供了几种图像和文本注释工具。</p></div></div>    
</body>
</html>