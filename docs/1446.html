<html>
<head>
<title>Use GFE Server-Timing Header in Cloud Spanner Debugging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云扳手调试中使用GFE服务器定时头</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/use-gfe-server-timing-header-in-cloud-spanner-debugging-d7d891a50642?source=collection_archive---------2-----------------------#2020-05-27">https://medium.com/google-cloud/use-gfe-server-timing-header-in-cloud-spanner-debugging-d7d891a50642?source=collection_archive---------2-----------------------#2020-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="055b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">概述</strong></h1><p id="7390" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">GFE服务器定时头最近已经在所有云扳手API中启用。这意味着Spanner用户现在可以在<a class="ae kb" href="https://cloud.google.com/security/infrastructure/design#google_front_end_service" rel="noopener ugc nofollow" target="_blank"> GFE </a>上检索每个云Spanner响应的延迟指标。它有助于更好地区分客户端、网络、GFE和扳手后端之间的延迟来源。</p><h1 id="8473" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">背景</strong></h1><ul class=""><li id="c970" class="kc kd hi jf b jg jh jk jl jo ke js kf jw kg ka kh ki kj kk bi translated">如今，云客户可以通过使用客户端库中的OpenCensus来查看客户端RPC的延迟度量和跟踪范围。(参见<a class="ae kb" href="https://opencensus.io/integrations/google_cloud/google_cloud_spanner/" rel="noopener ugc nofollow" target="_blank">公开普查指南</a>。)</li><li id="6917" class="kc kd hi jf b jg kl jk km jo kn js ko jw kp ka kh ki kj kk bi translated">Spanner请求的延迟被自动捕获，并作为Stackdriver <a class="ae kb" href="https://cloud.google.com/monitoring/api/metrics_gcp#gcp-spanner" rel="noopener ugc nofollow" target="_blank">系统指标</a>"spanner.googleapis.com/api/request_latencies"公开。</li><li id="28d6" class="kc kd hi jf b jg kl jk km jo kn js ko jw kp ka kh ki kj kk bi translated">此外，如果QueryMode设置为<a class="ae kb" href="https://github.com/googleapis/googleapis/blob/master/google/spanner/v1/spanner.proto#L456" rel="noopener ugc nofollow" target="_blank"> Profile </a>，则响应中的扳手<a class="ae kb" href="https://cloud.google.com/spanner/docs/reference/rest/v1/ResultSetStats" rel="noopener ugc nofollow" target="_blank"> QueryStats </a>可用。它包括查询执行所用的时间。</li><li id="2535" class="kc kd hi jf b jg kl jk km jo kn js ko jw kp ka kh ki kj kk bi translated">然而，在延迟分解中仍然有一个缺失的部分，那就是谷歌前端(GFE)的延迟。没有GFE延迟，很难调试高延迟问题，因为可能有多种原因(例如，客户端应用程序离GFE太远)，但没有足够的信息来区分。</li></ul><h1 id="ead3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">格式</strong></h1><p id="ef6a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，对于来自Cloud Spanner的每个响应，无论是REST还是gRPC，都会有一个额外的头，其中包含GFE上的总运行时间。格式是</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="7737" class="kz ig hi kv b fi la lb l lc ld">server-timing: gfet4t7; dur=[GFE latency in ms]</span></pre><p id="d4e6" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">用户可以以各种方式利用GFE延迟信息。</p><p id="f3dc" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">请注意，该标头与GFE响应相关联，因此在某些错误情况下，如果没有收到GFE响应(例如，客户端取消了请求或GFE不可用)，标头将会丢失。</p><h1 id="6973" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">一次性调试</strong></h1><p id="d124" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最简单的方法是在web浏览器上调试查询。下面的例子使用了Chrome开发工具:</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/cdb2db964dbe0b5031bd72b4d6292a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hA1kdC2yUaxjpn7r"/></div></div></figure><p id="d662" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">如果用户更习惯curl或gcloud CLI，他们还可以从命令行检查REST响应中的GFE延迟:</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lr"><img src="../Images/81c840739d7b329f173f6c88cecd924f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_jRUsvEGTkHI0ePE"/></div></div></figure><h1 id="c75e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">以编程方式调试</h1><p id="17d4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来，让我们研究如何以编程方式使用这个头。我们将在下面的例子中使用Spanner Go、Java和Python客户端。</p><h2 id="1760" class="kz ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">去</h2><p id="3979" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在Go客户端中，调用Spanner APIs时，只需提供一个<a class="ae kb" href="https://godoc.org/google.golang.org/grpc#Header" rel="noopener ugc nofollow" target="_blank"> gRPC头调用选项</a>。它将捕获传出RPC的标头:</p><figure class="kq kr ks kt fd lk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="59ff" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">更多细节参见<a class="ae kb" href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md" rel="noopener ugc nofollow" target="_blank"> gRPC元数据文档</a>。</p><h2 id="837b" class="kz ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><p id="8f4b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在Java客户端中，用户需要实现ClientInterceptor接口并拦截传出的RPC，以便检索头:</p><figure class="kq kr ks kt fd lk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="a680" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">然后在实例化Spanner客户端时，提供HeaderClientInterceptor:</p><figure class="kq kr ks kt fd lk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h2 id="395d" class="kz ig hi bd ih ls lt lu il lv lw lx ip jo ly lz it js ma mb ix jw mc md jb me bi translated">计算机编程语言</h2><p id="8353" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在Python客户机中，事情稍微复杂一些。这是因为Spanner Python APIs是由<a class="ae kb" href="https://pypi.org/project/google-api-core/" rel="noopener ugc nofollow" target="_blank"> google-api-core </a>包装的，而google-api-core并没有公开一个客户端选项来操纵头部。为了绕过这个约束，我们需要直接调用<a class="ae kb" href="https://github.com/googleapis/python-spanner/tree/master/google/cloud/spanner_v1/proto" rel="noopener ugc nofollow" target="_blank">原始生成的扳手API</a>，然后从call.initial_metadata中检索头:</p><figure class="kq kr ks kt fd lk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h1 id="c56b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">聚合、可视化和调试</h1><p id="6460" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在检索GFE延迟指标后，高级用户可以在监控工具上导出、聚合和可视化延迟数据，并并排比较客户端应用延迟、GFE延迟和扳手查询执行延迟:</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/438dfc016de450fd4fa107530c079c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gVggJ3obBfpkfHGe"/></div></div></figure><p id="84ec" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">(这个例子用的是Spanner Go客户端，OpenCensus和Prometheus。代码片段可以在<a class="ae kb" href="https://gist.github.com/songy23/37fe8747d48577ca21be65ca9e388b84" rel="noopener ugc nofollow" target="_blank">这里</a>找到。)</p><p id="78f4" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">或者，用户可以将GFE延迟作为一个属性链接到跟踪跨度:</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mh"><img src="../Images/ed1bc7e7863b8121f5b67aa37305a5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZ1GTMbJHfv2eYFfeThqwA.png"/></div></div></figure><p id="aaed" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">(这个例子用的是Spanner Go客户端，OpenCensus和Jaeger。代码片段可以在<a class="ae kb" href="https://gist.github.com/songy23/001102b91293572fb3913dcfd4a84b17" rel="noopener ugc nofollow" target="_blank">这里</a>找到。)</p><p id="b9cd" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">通过比较客户端、GFE和Spanner查询执行之间的延迟，用户和支持工程师现在应该能够缩小Spanner操作缓慢的原因。举个例子，</p><ul class=""><li id="8995" class="kc kd hi jf b jg le jk lf jo mi js mj jw mk ka kh ki kj kk bi translated">如果查询执行延迟很高，用户可以专注于优化模式、索引和查询以获得更好的性能。</li><li id="b34e" class="kc kd hi jf b jg kl jk km jo kn js ko jw kp ka kh ki kj kk bi translated">如果GFE延迟较高，而扳手延迟较低，则可能是GFE有问题。用户可以将此信息包括在支持票据中，以便支持工程师可以专注于GFE故障排除。</li><li id="e738" class="kc kd hi jf b jg kl jk km jo kn js ko jw kp ka kh ki kj kk bi translated">如果客户端延迟较高，而GFE和扳手延迟较低，则客户端和区域GFE之间可能存在网络问题。用户可能需要修复他们的网络路由。</li></ul><h1 id="b4c5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><p id="2c53" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">W3C服务器-定时规格:<a class="ae kb" href="https://www.w3.org/TR/server-timing/" rel="noopener ugc nofollow" target="_blank">www.w3.org/TR/server-timing/</a></p><p id="ddfe" class="pw-post-body-paragraph jd je hi jf b jg le ji jj jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka hb bi translated">Google前端(GFE)设计概述:<a class="ae kb" href="https://cloud.google.com/security/infrastructure/design#google_front_end_service" rel="noopener ugc nofollow" target="_blank">cloud . Google . com/security/infra structure/Design # Google _ Front _ End _ service</a></p></div></div>    
</body>
</html>