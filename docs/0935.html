<html>
<head>
<title>Building APIs with gRPC: Continued</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用gRPC构建API:续</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/building-apis-with-grpc-continued-f53b5a5ab850?source=collection_archive---------1-----------------------#2019-02-25">https://medium.com/google-cloud/building-apis-with-grpc-continued-f53b5a5ab850?source=collection_archive---------1-----------------------#2019-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文档讨论了如何进一步开发在<a class="ae jd" rel="noopener" href="/@ratrosy/building-api-services-a-beginners-guide-7274ae4c547f">使用gRPC </a>构建API中创建的gRPC API服务。它介绍了:</p><ul class=""><li id="3a33" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">gRPC API服务中实现<code class="du jn jo jp jq b">CREATE</code>、<code class="du jn jo jp jq b">LIST</code>、<code class="du jn jo jp jq b">UPDATE</code>和<code class="du jn jo jp jq b">DELETE</code>方法的常见模式</li><li id="ac07" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">gRPC API服务中的流</li><li id="40a6" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">gRPC API服务中错误处理和分页的常见模式</li></ul><p id="08f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该文档是<a class="ae jd" rel="noopener" href="/@ratrosy/building-api-services-a-beginners-guide-7274ae4c547f">构建API服务:初学者指南</a>教程系列的一部分。</p><blockquote class="jw jx jy"><p id="dc68" class="if ig jz ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">注意:本教程使用Python 3。当然，OpenAPI generator支持多种编程语言。</p></blockquote><h1 id="20c3" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">关于API服务</h1><p id="59b2" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在本教程中，您将把之前创建的简单的单端点gRPC API服务开发成一个成熟的相册服务，用户可以在其中创建(上传)、列出、获取和删除他们的照片。该服务提供以下方法(端点):</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="b648" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">开始之前</h1><ol class=""><li id="1594" class="je jf hi ih b ii lb im lc iq ln iu lo iy lp jc lq jk jl jm bi translated">开始使用gRPC 构建API<a class="ae jd" href="http://Building APIs with gRPC" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="0eab" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc lq jk jl jm bi translated"><a class="ae jd" href="https://github.com/michaelawyu/api_tutorial" rel="noopener ugc nofollow" target="_blank">下载源代码</a>。打开<code class="du jn jo jp jq b">grpc/photo_album</code>。</li></ol><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="3436" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">理解代码</h1><p id="5ba1" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">正如在<a class="ae jd" href="http://Building APIs with gRPC" rel="noopener ugc nofollow" target="_blank">用gRPC构建API</a>中介绍的，本教程中的相册gRPC API服务是从协议缓冲区规范文件<code class="du jn jo jp jq b">example.proto</code>构建的。该规范包含API服务的输入(请求)和输出(响应)协议缓冲区消息类型，以及将输入和输出关联在一起的服务定义。然后，您可以使用Protocol Buffers编译器将规范编译成Python数据类、服务器端工件和客户端工件；这些工件可以帮助您构建gRPC API服务及其客户端库。</p><h2 id="1ee1" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated">资源及其领域</h2><p id="edd5" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">这个gRPC API服务有两个资源:<code class="du jn jo jp jq b">User</code>和<code class="du jn jo jp jq b">Photo</code>。<code class="du jn jo jp jq b">User</code>是<code class="du jn jo jp jq b">Photo</code>的父资源。</p><p id="0c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">User</code>的资源名格式为<code class="du jn jo jp jq b">//myapiservice.com/users/USER-ID</code>。用户特征3个字段:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="fb2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">Photo</code>的资源名格式为<code class="du jn jo jp jq b">//myapiservice.com/users/USER-ID/photos/PHOTO-ID</code>。照片有3个区域:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，为了简单起见，协议缓冲区没有对保留字段和必填字段的内置支持。<strong class="ih hj">所有字段都是可选的</strong>。开发人员必须在服务器端(和客户端，如果必要的话)验证数据。</p><h2 id="1903" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated">重用协议缓冲区消息类型</h2><p id="96af" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated"><code class="du jn jo jp jq b">example.proto</code>从<code class="du jn jo jp jq b">protobuf</code>包中导入三种消息类型:</p><pre class="lg lh li lj fd mf jq mg mh aw mi bi"><span id="9ebc" class="lr ke hi jq b fi mj mk l ml mm">import “google/protobuf/empty.proto”;<br/>import “google/protobuf/timestamp.proto”;<br/>import “google/protobuf/field_mask.proto”;</span></pre><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="e0f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些消息类型帮助您在gRPC API服务中实现通用模式(更具体地说，是空消息、时间点和字段掩码)。Google为日常用例提供了多种协议缓冲区消息类型；它们在Google API服务中被广泛使用。有关更多信息，请参见<code class="du jn jo jp jq b"><a class="ae jd" href="https://github.com/protocolbuffers/protobuf" rel="noopener ugc nofollow" target="_blank">protobuf</a></code>和<code class="du jn jo jp jq b"><a class="ae jd" href="https://github.com/googleapis/api-common-protos" rel="noopener ugc nofollow" target="_blank">api-common-protos</a></code> GitHub项目。</p><p id="4c50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，您也可以将您自己项目中的消息类型导入到一个<code class="du jn jo jp jq b">.proto</code>文件中。例如，要从<code class="du jn jo jp jq b">my_project/my_dependencies/messages.proto</code>导入消息类型，只需在<code class="du jn jo jp jq b">.proto</code>文件的开头写下<code class="du jn jo jp jq b">import “my_project/my_dependencies/messages.proto”</code>。</p><h2 id="ec9c" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated"><code class="du jn jo jp jq b">CREATE</code>方法</h2><p id="22be" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated"><code class="du jn jo jp jq b">example.proto</code>指定了两种<code class="du jn jo jp jq b">CREATE</code>方法，<code class="du jn jo jp jq b">CreateUser</code>和<code class="du jn jo jp jq b">CreatePhoto</code>:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b4be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">CreateUser</code>和<code class="du jn jo jp jq b">CreatePhoto</code>分别以<code class="du jn jo jp jq b">User</code>和<code class="du jn jo jp jq b">CreatePhotoRequest</code>作为输入和输出<code class="du jn jo jp jq b">User</code>和<code class="du jn jo jp jq b">Photo</code>。<code class="du jn jo jp jq b">CreatePhotoRequest</code>指定了两个字段，<code class="du jn jo jp jq b">parent</code>和<code class="du jn jo jp jq b">photo</code>:</p><ul class=""><li id="6f93" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">parent</code>是<code class="du jn jo jp jq b">Photo</code>的父资源<code class="du jn jo jp jq b">User</code>的资源名称。该方法引用该值为特定的<code class="du jn jo jp jq b">User</code>创建一个<code class="du jn jo jp jq b">Photo</code>。</li><li id="9fec" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">photo</code>是要创建的<code class="du jn jo jp jq b">Photo</code>资源。</li></ul><p id="f71e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个方法将在服务器端和客户端工件中编译成<code class="du jn jo jp jq b">CreateUser</code>和<code class="du jn jo jp jq b">CreatePhoto</code>。覆盖服务器端工件，在API服务中创建方法，如<code class="du jn jo jp jq b">server.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/server/server.py</code>)所示:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="66c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用客户端工件，通过客户端库连接方法，如<code class="du jn jo jp jq b">client.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/client/client.py</code>)所示:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="1884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">推荐做法为</strong> <code class="du jn jo jp jq b"><strong class="ih hj">CREATE</strong></code> <strong class="ih hj">方法</strong></p><p id="904b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">CREATE</code>方法通常把要创建的资源作为输入。如果该资源是另一个资源的子资源，则输入消息类型还应该有一个父参数，用于其父资源的资源名称。此外，如果您的API服务支持自定义资源标识符，请在您的消息类型中添加资源ID。</p><p id="c324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在设计API和前面的章节中所讨论的，资源的<code class="du jn jo jp jq b">name</code>字段总是被保留；客户端不应该能够通过资源中的名称字段声明自定义标识符。相反，将资源ID作为一个单独的字段添加到输入中，并在服务器端生成完整的资源名称。</p><p id="4e93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在<a class="ae jd" rel="noopener" href="/@ratrosy/designing-apis-4eed43409f93">设计API</a>中所讨论的，<code class="du jn jo jp jq b">CREATE</code>方法本质上是非幂等的；您应该尽可能检查重复的资源。</p><p id="2d55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，<code class="du jn jo jp jq b">CREATE</code>方法应该输出新创建的资源，而不是状态消息(<code class="du jn jo jp jq b">“Resource created.”</code>)，以便帮助API消费者更容易地对新资源执行后续操作。当您的资源有保留或可选字段时，这一点尤其重要。</p><h2 id="df01" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated"><code class="du jn jo jp jq b">DELETE</code>方法</h2><p id="a1e8" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated"><code class="du jn jo jp jq b">example.proto</code>指定一种<code class="du jn jo jp jq b">DELETE</code>方法，<code class="du jn jo jp jq b">DeletePhoto</code>:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c192" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入为<code class="du jn jo jp jq b">DeletePhotoRequest</code>，输出为<code class="du jn jo jp jq b">Empty</code>(空消息)。它只指定了一个字段，<code class="du jn jo jp jq b">name</code>:</p><ul class=""><li id="be63" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">name</code>是要删除的<code class="du jn jo jp jq b">Photo</code>的资源名称。</li></ul><p id="3dbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法将被编译成<code class="du jn jo jp jq b">DeletePhoto</code>中的服务器端和客户端工件。覆盖服务器端工件，在API服务中创建方法，如<code class="du jn jo jp jq b">server.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/server/server.py</code>)所示:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="e081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用客户端工件，通过客户端库连接到方法，如<code class="du jn jo jp jq b">client.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/client/client.py</code>)所示:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="bd8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">推荐做法为</strong> <code class="du jn jo jp jq b"><strong class="ih hj">DELETE</strong></code> <strong class="ih hj">方法</strong></p><p id="8f55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">DELETE</code>方法也是非幂等的。然而，与<code class="du jn jo jp jq b">CREATE</code>方法不同，错误地重复调用<code class="du jn jo jp jq b">DELETE</code>方法几乎没有副作用:除了第一次，所有的调用都将失败，因为资源在第一次尝试时已经被移除。</p><p id="c7df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想为<code class="du jn jo jp jq b">DELETE</code>方法指定额外的参数，请将它们添加到输入消息类型中。<code class="du jn jo jp jq b">DELETE</code>方法应该总是返回空消息；但是，如果您的API服务对已删除的资源有保留策略，请考虑返回已删除的资源。</p><h2 id="1906" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated">更新方法</h2><p id="efb1" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated"><code class="du jn jo jp jq b">example.proto</code>指定一个<code class="du jn jo jp jq b">UPDATE</code>方法，<code class="du jn jo jp jq b">UpdateUser</code>。</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="868c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">UpdateUser</code>取<code class="du jn jo jp jq b">UpdateUserRequest</code>并返回<code class="du jn jo jp jq b">User</code>。<code class="du jn jo jp jq b">UpdateUserRequest</code>指定了三个字段，<code class="du jn jo jp jq b">name</code>、<code class="du jn jo jp jq b">user</code>和<code class="du jn jo jp jq b">mask</code>:</p><ul class=""><li id="2de5" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">name</code>是要更新的<code class="du jn jo jp jq b">User</code>的资源名称。</li><li id="33c6" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">user</code>是更新后的<code class="du jn jo jp jq b">User</code>资源。</li><li id="0441" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">mask</code>是一个字段<code class="du jn jo jp jq b">mask</code>。</li></ul><p id="7999" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">字段掩码是更新资源的标准模式，在Google APIs中被广泛采用。它本质上指定了在<code class="du jn jo jp jq b">UPDATE</code>方法中要更新的路径(字段)的集合，允许API服务只修改指定的字段，而不修改其他字段。工作流程如下:</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/07af6649f758017bdd151b92ed8123b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFP6Mq52EbVHHyKr-NaThg.png"/></div></div></figure><p id="b11c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法将被编译成<code class="du jn jo jp jq b">UpdateUser</code>中的服务器端和客户端工件。覆盖服务器端工件，在API服务中创建方法，如<code class="du jn jo jp jq b">server.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/server/server.py</code>)所示:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="4dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并调用客户端工件通过客户端库连接到方法，如<code class="du jn jo jp jq b">client.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/client/client.py</code>)所示:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="4776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最佳实践为</strong> <code class="du jn jo jp jq b"><strong class="ih hj">UPDATE</strong></code> <strong class="ih hj">方法</strong></p><p id="d338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与<code class="du jn jo jp jq b">CREATE</code>和<code class="du jn jo jp jq b">DELETE</code>方法一样，<code class="du jn jo jp jq b">UPDATE</code>方法也是非幂等的。幸运的是，一般来说，接受对<code class="du jn jo jp jq b">UPDATE</code>方法的重复调用是可以的；如果没有并发问题，所有这些都将成功，但资源保持不变。</p><p id="c63b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想为<code class="du jn jo jp jq b"> UPDATE</code>方法指定附加参数，请将它们添加到输入消息类型中。您应该在<code class="du jn jo jp jq b">UPDATE</code>方法中返回更新的资源。</p><h2 id="3f0c" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated">列表方法和分页</h2><p id="8b62" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated"><code class="du jn jo jp jq b">example.proto</code>指定一种<code class="du jn jo jp jq b">LIST</code>方法，<code class="du jn jo jp jq b">ListPhotos</code>:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="1a2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">ListPhotos</code>以<code class="du jn jo jp jq b">ListPhotosRequest</code>为输入，返回<code class="du jn jo jp jq b">ListPhotosResponse</code>。<code class="du jn jo jp jq b">ListPhotosRequest</code>指定三个字段:<code class="du jn jo jp jq b">parent</code>、<code class="du jn jo jp jq b">order_by</code>和<code class="du jn jo jp jq b">page_token</code>。<code class="du jn jo jp jq b">ListPhotosResponse</code>指定2个字段:集合<code class="du jn jo jp jq b">Photos</code>和<code class="du jn jo jp jq b">next_page_token</code>。</p><ul class=""><li id="2189" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">parent</code>是父资源的资源名称(<code class="du jn jo jp jq b">User</code>)。<code class="du jn jo jp jq b">ListPhotos </code>使用该值检索特定用户的照片。</li><li id="4f52" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">order_by</code>顾名思义就是<code class="du jn jo jp jq b">Photos</code>在结果中的顺序。</li><li id="9dbb" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">page_token</code>启用<code class="du jn jo jp jq b">LIST</code>方法中的分页。更多信息，请看<a class="ae jd" rel="noopener" href="/@ratrosy/designing-apis-4eed43409f93">设计API:设计模式:分页</a>。</li></ul><p id="552d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法将被编译成<code class="du jn jo jp jq b">ListPhotos</code>中的服务器端和客户端工件。覆盖服务器端工件，在API服务中创建方法，如<code class="du jn jo jp jq b">server.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/server/server.py</code>)所示:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="226d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<code class="du jn jo jp jq b">server.py</code>在服务器端独占地保存所有的分页状态。</p><p id="fce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用客户端工件，通过客户端库连接到方法，如<code class="du jn jo jp jq b">client.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/client/client.py</code>)所示。用户可以使用<code class="du jn jo jp jq b">next_page_token</code>手动请求下一个页面，尽管强烈建议您提供一个包装器方法来自动化这个过程，最好是以迭代器的形式。</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="e761" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最佳做法为</strong> <code class="du jn jo jp jq b"><strong class="ih hj">LIST</strong></code> <strong class="ih hj">方法</strong></p><p id="9ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下，您应该在API服务的所有<code class="du jn jo jp jq b">LIST</code>方法中实现分页。另外，考虑通过额外的参数，比如<code class="du jn jo jp jq b">order_by</code>和<code class="du jn jo jp jq b">max_results</code>，授予客户对<code class="du jn jo jp jq b">LIST</code>方法的更好的控制。</p><p id="aa0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">LIST</code>方法是幂等的。</p><h2 id="57ee" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated">流动</h2><p id="d959" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">对流的支持是gRPC API服务相对于HTTP RESTful服务的主要优势之一；与HTTP RESTful API服务中的<code class="du jn jo jp jq b">BATCH</code>端点相比，它为开发人员和客户提供了更加自然和习惯的体验。<code class="du jn jo jp jq b">example.proto</code>有两种启用流式传输的方法:<code class="du jn jo jp jq b">UploadPhoto</code>，单向(客户端到服务器)流式传输方法，和<code class="du jn jo jp jq b">StreamPhotos</code>，双向流式传输方法。gRPC还支持单向的服务器到客户端流。</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="af07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">带有<code class="du jn jo jp jq b">stream</code>关键字的方法启用了流。例如，要创建一个单向的客户端到服务器的流方法，用<code class="du jn jo jp jq b">stream</code>关键字标记输出(响应)消息类型；和单向服务器到客户端流式传输方法输入(请求)消息类型。当输入和输出消息类型都具有关键字时，该方法就成为双向流端点。</p><p id="8513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上传照片</strong></p><p id="bd93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">UploadPhoto</code>接受一个<code class="du jn jo jp jq b">PhotoDataBlock</code>流作为输入，返回一个<code class="du jn jo jp jq b">Empty</code>消息。它是<code class="du jn jo jp jq b">CreatePhoto</code>的补充端点，使客户端能够将二进制图像数据逐块上传到服务器。客户端首先调用<code class="du jn jo jp jq b">CreatePhoto</code>来创建<code class="du jn jo jp jq b">Photo</code>资源，然后调用<code class="du jn jo jp jq b">UploadPhoto</code>来传输数据(您可能想要在客户端库中添加一些助手方法来帮助自动化这个过程)。强烈建议gRPC API服务开发人员采用这种模式来处理二进制数据，因为gRPC对消息的大小有限制(默认为4MB)。PhotoDataBlock有四个字段:<code class="du jn jo jp jq b">name</code>、<code class="du jn jo jp jq b">data_block</code>、<code class="du jn jo jp jq b">data_block_hash</code>和<code class="du jn jo jp jq b">data_hash</code>。</p><p id="950c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">name</code>是要上传的照片的资源名称。<code class="du jn jo jp jq b">data_block</code>是一块二进制数据。<code class="du jn jo jp jq b">data_block_hash</code>和<code class="du jn jo jp jq b">data_hash</code>顾名思义，分别是数据块和完整二进制数据的哈希；它们有助于验证数据的完整性。服务器端首先使用<code class="du jn jo jp jq b">data_block_hash</code>验证每个数据块，将所有数据块合并成完整的文件，然后使用<code class="du jn jo jp jq b">data_hash</code>再次验证。</p><p id="4779" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法将被编译成<code class="du jn jo jp jq b">UploadPhoto</code>中的服务器端和客户端工件。覆盖服务器端工件，在API服务中创建方法，如<code class="du jn jo jp jq b">server.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/server/server.py</code>)所示。由于<code class="du jn jo jp jq b">UploadPhoto</code>的特点是客户端到服务器的单向流，<code class="du jn jo jp jq b">server.py</code>中的函数<code class="du jn jo jp jq b">UploadPhoto</code>将<a class="ae jd" href="https://www.w3schools.com/python/python_iterators.asp" rel="noopener ugc nofollow" target="_blank">迭代器</a>作为输入(<code class="du jn jo jp jq b">request_iterator</code>)。如果有帮助的话，可以把它想象成一个常规的<code class="du jn jo jp jq b">UploadPhotoRequest</code>对象的Python列表；gRPC简单地遍历它来获取所有的请求。此外，系统会自动为您处理所有复杂的流问题。</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="f200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用客户端工件，通过客户端库连接到方法，如<code class="du jn jo jp jq b">client.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/client/client.py</code>)所示。要从客户端进行流式传输，构建一个iterable ( <code class="du jn jo jp jq b">PhotoDataBlockRequestIterable</code>)并将其传递给客户端工件:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><blockquote class="jw jx jy"><p id="79c7" class="if ig jz ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">对Python中的迭代器、可迭代、迭代感到困惑？<a class="ae jd" href="https://stackoverflow.com/questions/9884132/what-exactly-are-iterator-iterable-and-iteration" rel="noopener ugc nofollow" target="_blank">这个StackOverflow的回答可能会有帮助</a>。</p></blockquote><p id="91f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于单向流方法的更多信息</strong></p><p id="3396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">gRPC保持流中的顺序。因此，要将这些块组合成图像，只需按照到达的顺序将它们连接起来。</p><p id="73f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流的两端都可以选择提前终止流。在本教程中，当迭代器抛出<a class="ae jd" href="https://docs.python.org/3.7/library/exceptions.html#StopIteration" rel="noopener ugc nofollow" target="_blank"> StopIteration </a>异常时，客户端自动结束流，如果传入的<code class="du jn jo jp jq b">PhotoDataBlock</code>被破坏，服务器将取消流。相应地为例外做好准备。</p><p id="6f6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑在客户端库中添加helpers方法来帮助进行流式处理。</p><p id="bf99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，<code class="du jn jo jp jq b">create_and_upload_photo</code>是一个帮助器方法，它一次创建并上传一张照片。它将图像的路径作为输入，并对客户端完全隐藏迭代细节。</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7d54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">流媒体照片</strong></p><p id="ce7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">StreamPhotos</code>取一个<code class="du jn jo jp jq b">GetPhotoRequest</code>的流，返回一个<code class="du jn jo jp jq b">Photo</code>的流。该方法本质上是以自动批处理模式运行的<code class="du jn jo jp jq b">GetPhoto</code>，使客户端能够检索大量的<code class="du jn jo jp jq b">Photos</code>，而不必重复调用<code class="du jn jo jp jq b">GetPhoto</code>方法。基本上，对于流中的每个<code class="du jn jo jp jq b">GetPhotoRequest</code>发送，API服务都返回一个<code class="du jn jo jp jq b">Photo</code>。</p><p id="c464" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法将被编译成<code class="du jn jo jp jq b">StreamPhotos</code>中的服务器端和客户端工件。覆盖服务器端工件，在API服务中创建方法，如<code class="du jn jo jp jq b">server.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/server/server.py</code>)所示。与<code class="du jn jo jp jq b">UploadPhoto</code>类似，<code class="du jn jo jp jq b">StreamPhotos </code>以一个迭代器(<code class="du jn jo jp jq b">request_iterator</code>)作为输入，表示一个<code class="du jn jo jp jq b">GetPhotoRequest</code>消息流；服务器遍历迭代器，并将请求逐个传递给<code class="du jn jo jp jq b">GetPhoto</code>方法。</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="002f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，该函数使用关键字<code class="du jn jo jp jq b">yield</code>返回一个生成器；gRPC调用生成器来准备服务器到客户端流中的响应。</p><blockquote class="jw jx jy"><p id="4a16" class="if ig jz ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">对Python中的生成器感到困惑？来自Python基金会的这个Wiki页面可能会有所帮助。</p></blockquote><p id="320a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用客户端工件，通过客户端库连接到方法，如<code class="du jn jo jp jq b">client.py</code> ( <code class="du jn jo jp jq b">/grpc/photo_album/client/client.py</code>)所示。要从客户端流式传输，构建一个iterable ( <code class="du jn jo jp jq b">PhotoDataBlockRequestIterable</code>)并将其传递给客户端存根。由于这是一个双向流方法，它返回一个迭代器；循环通过它来获取照片。</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="8a0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于双向流方法的更多信息</strong></p><p id="35bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">双向流方法的客户端到服务器和服务器到客户端流独立工作。在本教程中，这两个流看起来是同步的:服务器按照到达的顺序，为客户端到服务器流中的每个<code class="du jn jo jp jq b">GetPhotoRequest</code>返回一个<code class="du jn jo jp jq b">Photo</code>;然而，他们并不一定要这样做。例如，您可以编写一个方法，让客户端上传一个文件，同时下载另一个文件。</p><h2 id="e036" class="lr ke hi bd kf ls lt lu kj lv lw lx kn iq ly lz kr iu ma mb kv iy mc md kz me bi translated">错误处理</h2><p id="e741" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">要从服务器端或客户端抛出一个错误，用错误代码和细节设置gRPC上下文，然后返回一个<code class="du jn jo jp jq b">Empty</code>响应:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="f513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要用Python gRPC包捕获客户端和服务器端的错误，请注意<code class="du jn jo jp jq b">grpc.RpcError</code>异常，它是所有gRPC异常的基础异常。您可以从错误对象中提取错误代码和详细信息:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="d160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">gRPC提供了预设错误代码的集合。建议您尽可能使用它们:</p><figure class="lg lh li lj fd lk"><div class="bz dy l di"><div class="ll lm l"/></div></figure><blockquote class="jw jx jy"><p id="95c1" class="if ig jz ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated"><code class="du jn jo jp jq b">CUSTOM</code>错误代码是为定制用例保留的；gRPC本身永远不会生成这些错误代码。</p></blockquote><h1 id="ab50" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在本地运行代码</h1><p id="37b6" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">转到<code class="du jn jo jp jq b">/grpc/photo_album/server/</code>并在后台运行<code class="du jn jo jp jq b">server.py</code>:</p><pre class="lg lh li lj fd mf jq mg mh aw mi bi"><span id="358e" class="lr ke hi jq b fi mj mk l ml mm">python server.py</span></pre><p id="32f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器监听本地主机:8080。使用客户端连接到服务器；转到<code class="du jn jo jp jq b">/grpc/photo_album/client</code>并运行以下Python脚本:</p><pre class="lg lh li lj fd mf jq mg mh aw mi bi"><span id="e2a4" class="lr ke hi jq b fi mj mk l ml mm">import client<br/>client = client.ExamplePhotoServiceClient()<br/>client.create_user(display_name='John Smith', email='user@example.com')</span></pre><p id="fc70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该会看到以下输出:</p><pre class="lg lh li lj fd mf jq mg mh aw mi bi"><span id="269f" class="lr ke hi jq b fi mj mk l ml mm">User created.<br/>name: "//myapiservice.com/users/0947a5a52fa3464da0cee1d9a3a22c8e"<br/>display_name: "John Smith"<br/>email: "user@example.com"</span></pre></div></div>    
</body>
</html>