<html>
<head>
<title>GCP Infrastructure as Code with Deployment Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用部署管理器将GCP基础设施作为代码</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/2018-google-deployment-manager-5ebb8759a122?source=collection_archive---------0-----------------------#2018-05-02">https://medium.com/google-cloud/2018-google-deployment-manager-5ebb8759a122?source=collection_archive---------0-----------------------#2018-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/92e647ca7cb64b4f9c61adf6e8b05d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c71MGBJTmz_XvqrY1rUbIg.png"/></div></div></figure><p id="d0c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基础设施作为代码是一种实践，它通过使用代码来描述基础设施，使基础设施的配置可复制、可伸缩且易于审查。基础设施即代码源于对基础设施也是“软件”的认识，对于公共云来说尤其如此。因为它是软件，所以也应该进行版本控制、测试和评审。更好的是，您可以开始将所需基础设施的描述与应用程序的代码放在一起，从而在一个地方获得所需的所有内容的完整定义。您可以开始一起测试和部署一切。</p><p id="57a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有许多工具可以帮助你实现这一点，例如Ansible和Terraform，但它们并不总是能够提供与公共云托管平台(如AWS、Azure或Google Cloud Platform)完全匹配的服务。考虑到新功能推出的惊人速度，这并不奇怪。这就是为什么一些云提供商也给你他们自己的基础设施作为代码工具，作为他们产品的一部分。AWS有“亚马逊云形成”，Azure有“Azure资源管理器”，对于谷歌云有“部署管理器”。它们都提供了一种使用声明性语言来定义云基础设施资源的方法，例如，您可以将其放入git存储库中。此外，您可以使用模板，这允许您避免代码重复，并使得在不同的部署阶段测试相同的基础设施代码成为可能。</p><p id="7a27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将重点关注Google云平台，以及如何使用Google Cloud Deployment Manager来自动化所有GCP资源的配置。作为实际演示，我们将部署一个Kubernetes集群和一个在其上运行的简单应用程序，所有这些都是自动创建的。它包括以下资源:</p><ul class=""><li id="b220" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">一个Kubernetes集群(Google Kubernetes引擎)</li><li id="a4bd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Kubernetes部署</li><li id="99f1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Kubernetes服务</li><li id="6c02" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Kubernetes入口定义</li></ul><h2 id="c036" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">部署管理器基础</h2><p id="4a59" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">在我们开始使用部署管理器创建GCP资源之前，让我们先快速总结一下它是如何工作的。</p><p id="0ba1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署管理器有一个<em class="lc">部署</em>的概念，它是GCP资源的集合，这些资源形成一个逻辑单元并一起部署。部署的资源可以是GCP上任何可用的资源:虚拟机、IP地址、数据库服务器、Kubernetes集群等。</p><p id="7f7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了创建部署，您需要一个<em class="lc">部署配置</em>，它是一个包含资源定义的YAML文件。为了让您有个概念，它可能如下所示:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="5cb4" class="kc kd hi li b fi lm ln l lo lp">resources:<br/>- name: example-vm<br/>  type: compute.v1.instance<br/>  properties:<br/>    zone: europe-west1-b<br/>    machineType: zones/europe-west1-b/machineTypes/n1-standard-1<br/>    disks:<br/>       ...</span></pre><p id="f2cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个列出的资源总是有一个<em class="lc">类型</em>，这是将要创建的资源的种类(VM、IP地址等)。)，一个<em class="lc">名称</em>，和<em class="lc">属性</em>，描述应该用什么参数创建资源。</p><p id="e686" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与Ansible相比，一个重要的概念是，当您创建一个部署时，它作为资源本身存在于GCP中。如果您稍后更改了部署的配置(例如，通过修改YAML文件)，并运行更新命令，部署管理器会将新配置与其之前部署的配置进行比较，并且只进行所需的更改。不仅需要做的工作更少，更重要的是，它还确保了从配置中删除的任何资源也将从GCP基础架构中删除。</p><p id="51af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在GitHub上的<a class="ae lq" href="https://github.com/GoogleCloudPlatform/deploymentmanager-samples" rel="noopener ugc nofollow" target="_blank">Google Deployment Manager samples</a>项目中找到许多部署配置示例。它通常比<a class="ae lq" href="https://cloud.google.com/deployment-manager/docs/" rel="noopener ugc nofollow" target="_blank">官方文档</a>更有用，可以找出你应该定义什么参数。</p><h2 id="ed89" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">准备工作(如果你想执行代码)</h2><p id="a080" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">如果您想了解部署管理器是如何工作的，我建议您在阅读时也尝试部署这个示例应用程序。您将会看到，部署所有这些组件是多么的快速和简单。通常需要几天才能设置好的东西，现在只需要几分钟。如果您想这样做，请做如下准备:</p><p id="0076" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，确保您有一个GCP帐户和一个启用了计费的GCP项目。此外，您需要安装<a class="ae lq" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank">谷歌云SDK </a>，其中包括我们将使用的“gcloud”命令行工具。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="a7ba" class="kc kd hi li b fi lm ln l lo lp">$ gcloud auth login<br/>$ gcloud config set project $MYPROJECT_ID</span></pre><p id="39ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，克隆我用本文中的所有代码示例准备的github repo:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="9580" class="kc kd hi li b fi lm ln l lo lp">$ git clone https://github.com/schweikert/gcp-infra-as-code<br/>$ cd gcp-infra-as-code</span></pre><h2 id="5061" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">创建Kubernetes集群</h2><p id="6719" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我们要做的第一件事是创建一个Kubernetes集群。在<a class="ae lq" href="https://cloud.google.com/deployment-manager/docs/configuration/supported-resource-types" rel="noopener ugc nofollow" target="_blank">支持的资源列表</a>中可以发现，部署管理器中资源的名称是“container.v1.cluster”。一个非常简单的定义如下:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="0f32" class="kc kd hi li b fi lm ln l lo lp">resources:<br/><br/>- name: cluster<br/>  type: container.v1.cluster<br/>  properties:<br/>    zone: europe-west1-b<br/>    cluster:<br/>      description: "My example cluster"<br/>      initialNodeCount: 2</span></pre><p id="fc0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将在具有两个节点的单个区域中创建一个Kubernetes集群。</p><p id="35b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">github存储库中的<a class="ae lq" href="https://github.com/schweikert/gcp-infra-as-code/blob/master/cluster-1/cluster.yaml" rel="noopener ugc nofollow" target="_blank"> cluster.yaml </a>文件指定了更多的参数，比如跨两个区域分布节点，并为集群节点启用“自动升级”。</p><p id="1836" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用“create”命令实例化此部署:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="2b15" class="kc kd hi li b fi lm ln l lo lp">$ gcloud deployment-manager deployments create example-cluster --config cluster-1/cluster.yaml</span></pre><p id="08af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将使用cluster-1/cluster.yaml中的定义创建一个名为“example-cluster”的部署。您可以稍后更新yaml文件，并使用“update”命令更新已部署的部署:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="fed9" class="kc kd hi li b fi lm ln l lo lp">$ gcloud deployment-manager deployments update example-cluster --config cluster-1/cluster.yaml</span></pre><p id="d8a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该命令将已部署的部署与新定义进行比较，并仅执行所需的更改(例如，创建您添加的新资源)。</p><p id="5c0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，删除集群。我们稍后将再次重新创建它。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="c312" class="kc kd hi li b fi lm ln l lo lp">$ gcloud deployment-manager deployments delete example-cluster</span></pre><h2 id="d814" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">模板</h2><p id="2125" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这些yaml文件实际上是您的基础设施“代码”，您可能希望在部署之前先测试这些代码。为了有效地实现这一点，您应该为测试和生产部署相同的代码，即使这些环境可能需要不同地指定一些参数。</p><p id="ccd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是模板非常有用的地方。您可以将一个模板用于所有环境，只需参数化需要不同的内容。部署管理器支持Python脚本和Jinja 2作为模板语言。我将使用Jinja 2演示模板化，因为尽管Python是Google推荐的，但我发现Jinja 2更适合这个用例，而且更容易阅读。</p><p id="273a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“cluster-2”目录包含相同的示例，但分为两个文件。</p><p id="3be0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lq" href="https://github.com/schweikert/gcp-infra-as-code/blob/master/cluster-2/example-cluster.yaml" rel="noopener ugc nofollow" target="_blank">资源定义</a>:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="5b97" class="kc kd hi li b fi lm ln l lo lp">imports:<br/>- path: templates/cluster.jinja<br/>  name: cluster.jinja<br/><br/>resources:<br/>- name: example-cluster<br/>  type: cluster.jinja<br/>  properties:<br/>    description: "Example Cluster"<br/>    zones:<br/>    - europe-west3-b  <br/>    - europe-west3-c<br/>    initialNodeCount: 1</span></pre><p id="3a8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个文件的结构与非模板版本非常相似，但是它不是直接实例化GCP资源，而是实例化一个模板。该模板实例还有一个名称和属性，可以在模板定义中使用。</p><p id="9ef4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lq" href="https://github.com/schweikert/gcp-infra-as-code/blob/master/cluster-2/templates/cluster.jinja" rel="noopener ugc nofollow" target="_blank">模板</a>:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="cf38" class="kc kd hi li b fi lm ln l lo lp">resources:<br/><br/>- name: {{ env['name'] }}<br/>  type: container.v1.cluster<br/>  properties:<br/>    zone: {{ properties['zones'][0] }}<br/>    ...</span></pre><p id="55f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Jinja 2语法，模板实例名和属性被用来参数化它。</p><p id="25a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建部署的命令与之前相同:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e277" class="kc kd hi li b fi lm ln l lo lp">$ gcloud deployment-manager deployments create example-cluster --config cluster-2/example-cluster.yaml</span></pre><h2 id="0959" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">部署经理和第三方资源</h2><p id="d9c3" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">Deployment Manager的一个惊人的能力是，除了它已经知道的以外，您可以教它管理您想要的任何类型的资源。如果管理这些资源的API满足<a class="ae lq" href="https://cloud.google.com/deployment-manager/docs/configuration/type-providers/process-adding-api" rel="noopener ugc nofollow" target="_blank">的一些标准</a>，那么您可以添加该API并定义第三方资源作为您的部署管理器部署的一部分。</p><p id="8ba3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个非常有趣的用例是Kubernetes资源的管理。部署管理器并不知道如何创建、修改或删除Kubernetes集群的Kubernetes资源，但是您可以添加代码来实现这一点。</p><p id="0bf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes资源是通过与Kubernetes的交互来管理的，这种交互是通过一个定义良好的版本化API来实现的。为了使它同时具有可扩展性和向后兼容性，有多个API端点来反映托管资源的范围和成熟度。例如，“服务”是核心功能的一部分，被认为是成熟的，因为这种管理服务资源的方法是API端点“/api/v1”的一部分。其他最近添加的资源类型可以在其他端点找到:“部署”被认为是测试版，由API端点“/API/extensions/v1 beta 1”管理。</p><p id="5063" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这些API端点中的每一个，我们将需要为部署管理器添加指令，以便它知道如何使用它。所需的代码通常作为集群部署的一部分进行部署，这样一旦创建了集群，就可以开始管理其中的Kubernetes资源。</p><p id="acb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“cluster-3”示例包含一个额外的部分，它将使部署Kubernetes资源成为可能。如果您查看“cluster-3/templates/cluster . jinja”文件，您会发现:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="9311" class="kc kd hi li b fi lm ln l lo lp">{% set K8S_ENDPOINTS = {<br/>      '': 'api/v1',<br/>      '-apps': 'apis/apps/v1',<br/>      '-rbac': 'apis/rbac.authorization.k8s.io/v1',<br/>      '-v1beta1-extensions': 'apis/extensions/v1beta1'<br/>} %}<br/><br/>...<br/><br/>{% for typeSuffix, endpoint in K8S_ENDPOINTS.iteritems() %}<br/>- name: {{ env['name'] }}-type{{ typeSuffix }}<br/>  type: deploymentmanager.v2beta.typeProvider<br/>  properties:<br/>    ...<br/>    descriptorUrl: https://$(ref.{{ env['name'] }}.endpoint)/swaggerapi/{{ endpoint }}<br/>{% endfor %}</span></pre><p id="4a2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不会深入细节，但是您可以看到它使用Jinja循环为我们想要使用的每个API端点创建定义。它使用Swagger或OpenAPI URL来发现每个端点上有哪些可用的方法，以及如何调用它们。模板中循环的第一次迭代将产生这样的结果:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="0b2a" class="kc kd hi li b fi lm ln l lo lp">- name: example-cluster-type<br/>  type: deploymentmanager.v2beta.typeProvider<br/>  properties:<br/>    descriptorUrl: https://$(ref.example-cluster.endpoint)/swaggerapi/api/v1<br/>    ...</span></pre><p id="068c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lr ls lt li b">$(ref.example-cluster.endpoint)</code>是内联引用，在部署时解析为已创建资源(“示例集群”)的属性(“端点”)。在这种情况下，它解析为Kubernetes主服务的IP地址。它还设置了这两个资源(<code class="du lr ls lt li b">example-cluster-type</code>和<code class="du lr ls lt li b">example-cluster</code>)之间的依赖关系，部署管理器将确保资源以正确的顺序创建。</p><p id="1c7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lr ls lt li b">descriptorUrl</code>类似于:<code class="du lr ls lt li b">https://35.198.131.165/swaggerapi/api/v1</code>，用于解析Kubernetes的api/v1 "方法。该示例包含另外三个API端点，您可以根据需要对其进行扩展(例如，根据您的部署需要访问的API)。</p><p id="212e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在同一个部署中开始使用这些新资源类型，也可以在同一项目中创建的新部署中开始使用。</p><p id="dda2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署集群后，您可以在GCP控制台(注意，有一个专门用于部署管理器的部分)或使用gcloud工具看到新的类型:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="add4" class="kc kd hi li b fi lm ln l lo lp">$ gcloud deployment-manager types list | grep example<br/>example-cluster-type<br/>example-cluster-type-apps<br/>example-cluster-type-rbac<br/>example-cluster-type-v1beta1-extensions</span></pre><h2 id="2d28" class="kc kd hi bd ke kf kg kh ki kj kk kl km jb kn ko kp jf kq kr ks jj kt ku kv kw bi translated">Kubernetes应用程序</h2><p id="b894" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">现在我们终于可以使用部署管理器创建Kubernetes应用程序了。我们将定义三个资源:一个Kubernetes“部署”,带有一个pod规范、一个服务和一个入口，使应用程序可以从集群外部访问。</p><p id="5880" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在<a class="ae lq" href="https://github.com/schweikert/gcp-infra-as-code/blob/master/hello-world-1/templates/hello-world.jinja" rel="noopener ugc nofollow" target="_blank">模板文件</a>中看到的，每个Kubernetes资源都是通过引用上述基于API的类型之一创建的，我们将其定义为集群部署的一部分。例如:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e835" class="kc kd hi li b fi lm ln l lo lp">- name: example-hello-world-svc<br/>  type: env[‘project’]/example-cluster-type:/api/v1/namespaces/{namespace}/services<br/>  properties:<br/>    apiVersion: v1<br/>    kind: Service</span></pre><p id="074d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些宏用于使编写资源(名称前缀、集群类型等)变得更容易。).</p><p id="8fed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用3个Kubernetes资源部署模板，如下所示:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="650b" class="kc kd hi li b fi lm ln l lo lp">$ gcloud deployment-manager deployments update example-hello-world --config hello-world-1/example.yaml</span></pre><p id="2819" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GCP将自动分配一个短暂的静态IP地址来访问您的应用程序。您可以使用kubectl命令找出它是什么，但是首先您需要获得它所需的凭证:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="44c5" class="kc kd hi li b fi lm ln l lo lp">$ gcloud container clusters get-credentials example-cluster --zone europe-west1-b<br/><br/>$ kubectl get pod                              <br/>NAME                                   READY     STATUS    RESTARTS   AGE                                                <br/>hello-world-example-75d79ccdd5-pmjcg   1/1       Running   0          1m<br/>hello-world-example-75d79ccdd5-vtb6g   1/1       Running   0          1m</span></pre><p id="3452" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以查看入口资源，找出外部IP地址:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="7274" class="kc kd hi li b fi lm ln l lo lp">$ kubectl get ingress -o wide<br/>NAME                  HOSTS     ADDRESS         PORTS     AGE<br/>hello-world-example   *         35.201.65.191   80        10m</span></pre><p id="00f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…并在此访问您的申请:【http://35.201.65.191 T2】。</p><p id="fe13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">瞧，一个完全可复制的Kubernetes集群和应用程序，描述为代码:)</p><p id="707a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要继续使用部署管理器，您可以查看一下Google KMS，它允许您使用存储在GCP的密钥来加密秘密(这样您就可以将加密的值放在您的配置文件中)，并使用该密钥生成Kubernetes秘密。我已经测试过并且运行良好的另一个方法是创建一个PostgreSQL数据库，并使用通过部署管理器生成的服务帐户部署云SQL代理。让我知道你是否有兴趣阅读这方面的文章。</p><p id="cdbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成实验后，不要忘记清理一切，这样你就不会浪费GCP学分。</p></div></div>    
</body>
</html>