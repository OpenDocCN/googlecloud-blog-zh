<html>
<head>
<title>Sample SQL Translator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">示例SQL转换器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/sample-sql-translator-fb3ab8876b35?source=collection_archive---------2-----------------------#2020-11-13">https://medium.com/google-cloud/sample-sql-translator-fb3ab8876b35?source=collection_archive---------2-----------------------#2020-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="efb1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码</h1><p id="9349" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我很高兴宣布一个用Python编写的全面的示例SQL解析器、翻译器和格式化器。它可以在https://github.com/google/sample-sql-translator的<a class="ae kb" href="https://github.com/google/sample-sql-translator" rel="noopener ugc nofollow" target="_blank">开源获得。</a></p><h1 id="aa34" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概观</h1><p id="6e62" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">其目的是进行以下工作-</p><ul class=""><li id="d952" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">提供一个SQL递归下降解析器的例子。</li><li id="0855" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">为SQL解析器、重写、分析和格式化提供模板。</li></ul><p id="dfe7" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">SQL的方言主要基于<a class="ae kb" href="https://cloud.google.com/bigquery/docs/reference/standard-sql" rel="noopener ugc nofollow" target="_blank"> BigQuery标准SQL </a>，增加了一些额外的特性。</p><h1 id="1264" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么是递归下降解析器？</h1><p id="7b5f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">经过多年使用LL和LR解析器——当今使用的常用工具——的多次尝试，我已经转而使用纯手工制作的递归下降解析器。</p><p id="cac8" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">在<a class="ae kb" href="https://blog.reverberate.org/2013/09/ll-and-lr-in-context-why-parsing-tools.html" rel="noopener ugc nofollow" target="_blank">这篇博文</a>中可以找到一些关于解析器/词法分析器工具挑战的很好的背景。</p><p id="4223" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">同样值得注意的是，GCC和clang都改用了手工制作的递归下降解析器。参见<a class="ae kb" href="http://gcc.gnu.org/wiki/New_C_Parser" rel="noopener ugc nofollow" target="_blank"> gcc </a>和<a class="ae kb" href="http://clang.llvm.org/features.html" rel="noopener ugc nofollow" target="_blank">铿锵</a>。</p><p id="e4f4" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这提供了一个复杂解析器的例子，我希望它易于阅读、维护和扩展。唯一的状态保存在<a class="ae kb" href="https://github.com/google/sample-sql-translator/blob/master/sql_parser/lexer.py" rel="noopener ugc nofollow" target="_blank"> lexer.py </a>中，它提供了查找标识符、字符串和数字的基本方法。</p><p id="ec3c" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">一个很好的起点是查看<a class="ae kb" href="https://github.com/google/sample-sql-translator/blob/master/sql_parser/types.py" rel="noopener ugc nofollow" target="_blank"> types.py </a>中的解析类型。</p><h1 id="de2c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">潜在的使用案例</h1><p id="0c39" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">扩展这段代码有许多潜在的用例:</p><ul class=""><li id="5799" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">提供格式化工具作为持续集成的一部分。</li><li id="a808" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">分析代码中的表依赖和其他有趣的信息。在AST上搜索你想要的任何信息。</li><li id="fea4" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">将SQL(可能是定制的SQL方言)翻译成不同的目标方言。</li></ul><p id="fddd" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">注意，在所有情况下，都需要根据需要扩展解析器和格式化。</p><h1 id="5728" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">成分</h1><h2 id="5ddc" class="kv ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">sql_parser</h2><p id="a1d7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">sql_parser是一个纯粹的<a class="ae kb" href="https://en.wikipedia.org/wiki/Recursive_descent_parser" rel="noopener ugc nofollow" target="_blank">递归下降解析器</a>，它生成Python冻结的dataclass对象作为AST。AST还包含生成rfmt格式的SQL的方法。</p><p id="b017" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">唯一可变的状态包含在lexer类中，它是注释列表(用于关联)和当前解析位置。所有其他解析状态都是当前调用栈和执行点。</p><h2 id="d7ef" class="kv ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">sql_rewriter</h2><p id="7cca" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">sql_rewriter包含为不同的sql方言重写AST的基本示例。它还包括一些示例依赖性提取算法。</p><h2 id="2b8e" class="kv ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">rfmt</h2><p id="ef2f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">rfmt是用于输出的格式化库，从<a class="ae kb" href="https://github.com/google/rfmt/tree/master/inst/python/rfmt" rel="noopener ugc nofollow" target="_blank">https://github.com/google/rfmt</a>复制而来。</p><p id="fcb7" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这是一个通用格式库。关于其方法的更多信息可以在<a class="ae kb" href="https://research.google/pubs/pub44667/" rel="noopener ugc nofollow" target="_blank">的研究论文</a>中找到。</p><h1 id="632a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">例子</h1><p id="6fad" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有SQL重写(例如将CASE语句转换成IF)和SQL格式化程序的例子。还有一个解析一大组SQL的例子——<a class="ae kb" href="https://github.com/google/sample-sql-translator/tree/master/examples/table_analysis" rel="noopener ugc nofollow" target="_blank">this SQL</a>——并生成最小连接树。这可以使用<a class="ae kb" href="https://graphviz.org/" rel="noopener ugc nofollow" target="_blank"> graphviz </a>可视化:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/90509511032f60c6c7c9952d4b5e9602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bFAvOQxiFHys773e.jpg"/></div></div></figure><p id="fdf2" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><em class="lv">注意:这个SQL是通过以编程方式生成AST并使用这个库生成SQL而创建的。</em></p><h1 id="bf7f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="fa77" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">希望这个库能对写解析器提供一些启发或者教育。如果你觉得有用，请在<a class="ae kb" href="https://github.com/google/sample-sql-translator" rel="noopener ugc nofollow" target="_blank"> Git仓库</a>中给我反馈。</p></div></div>    
</body>
</html>