<html>
<head>
<title>Custom tracing in Profiling GAE using the Stackdriver API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Stackdriver API分析GAE时的自定义跟踪</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/custom-tracing-in-profiling-gae-using-the-stackdriver-api-b270288622c6?source=collection_archive---------0-----------------------#2017-06-21">https://medium.com/google-cloud/custom-tracing-in-profiling-gae-using-the-stackdriver-api-b270288622c6?source=collection_archive---------0-----------------------#2017-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d9dc4b6b7d36750855f51f34b01f8003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8gFMHNLtQJj-DnrepTSjw.jpeg"/></div></div></figure><div class=""/><p id="3c47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你还记得几周前的一次<a class="ae jo" rel="noopener" href="/google-cloud/understanding-and-profiling-app-engine-cold-boot-time-908431aa971d"/>，我帮助了一组开发人员，为Google App Engine的StackDriver添加了一些自定义跟踪信息。从那以后，我收到了许多请求，询问我是如何做到的更多信息，所以，让我们来看看。</p><h1 id="7583" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">了解跟踪</h1><p id="7193" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">跟踪(也称为<a class="ae jo" href="http://www.gamasutra.com/view/news/176420/Indepth_Using_Chrometracing_to_view_your_inline_profiling_data.php" rel="noopener ugc nofollow" target="_blank">“在线分析”</a>)是任何性能测试中的重要工具。该工具允许您获得代码中开始/结束API调用之间的精确计时，并且在处理复杂的依赖关系时，非常有助于跟踪您的时间去了哪里。跟踪的一个缺点是，它要求您修改现有的源代码来跟踪给定段所花费的时间。这通常包括用基于作用域的宏来处理代码，这些宏处理定时、缓冲以及将特定数据记录到某些输出中。</p><p id="7e9e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也是Stackdriver集成App Engine标准如此牛逼的原因；它将代表您处理所有RPC命令的跟踪，不需要修改代码。</p><p id="e4d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云控制台中列出了所有跟踪，您可以查看、浏览所有捕获的跟踪。最后，选择一个将显示RPC调用位置和请求时间的图形表示:</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es ks"><img src="../Images/4a9533bee427dc3fcc81b43d45f0913a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*ehfePm6R6sMnzbtTs1ySag.png"/></div></figure><h1 id="b51a" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Stackdriver跟踪API</h1><p id="9b57" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">虽然RPC跟踪很重要，但有时也需要对本地代码进行分析。因为代表你跟踪所有的函数调用会是一个巨大的性能问题，所以Stackdriver提供了一个<a class="ae jo" href="https://cloud.google.com/trace/docs/reference/v1/rest/v1/projects/patchTraces" rel="noopener ugc nofollow" target="_blank"> <em class="kx">补丁</em> API </a>，允许你用定制数据来增加你的跟踪。这样，您就可以准确地指定想要包含在跟踪中的数据，而不会有任何干扰。</p><p id="4baa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以<a class="ae jo" href="https://cloud.google.com/trace/docs/reference/v1/rest/v1/projects/patchTraces" rel="noopener ugc nofollow" target="_blank">查看文档</a>，但是要点是您点击了一个REST端点，并向它提供了一个JSON字符串，其中包括您的计时数据和您想要修补的跟踪ID。与api交互的唯一复杂部分在于A) Auth，以及JSON字符串的格式。</p><p id="516e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢天谢地，对于B来说，<a class="ae jo" href="https://cloud.google.com/trace/docs/reference/v1/rest/v1/projects/patchTraces" rel="noopener ugc nofollow" target="_blank">文档</a>包含了一个小部件，您可以使用它来弄清楚到底需要什么。如果您使用下面的值，您将获得一个正确执行小部件的单一跨度。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ky"><img src="../Images/e60ee4483b26820d5e40d8589830e18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F303YmjR3Kwx4CLvTtj6jg.png"/></div></div></figure><h1 id="60fe" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置本地环境</h1><p id="1c8e" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">一旦您准备好开始测试代码，您将需要首先设置您的本地环境。我正在使用python，因此需要安装Google API python客户端库。</p><p id="bcff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，导航到您的项目文件夹，并升级库:</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es kz"><img src="../Images/7d76e61c846325be4b232e9c74e3c4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/0*lPi9J8tsmFXpFjMJ."/></div></figure><p id="314f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，您需要在本地将库安装到项目中；调用下面的命令在一个。/lib "文件夹。当您部署项目时，该文件夹也将被复制。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es la"><img src="../Images/b0727f2c7272cc5174fc6dfe9ea3c015.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/0*SyZNMrU_xebrRvRB."/></div></div></figure><p id="d84c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FWIW在API客户端的“<a class="ae jo" href="https://developers.google.com/api-client-library/python/start/get_started" rel="noopener ugc nofollow" target="_blank">入门页面</a>上有更多的细节(如果你需要深入了解)。</p><h1 id="b587" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建探查器类</h1><p id="3d2b" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果你像我一样已经存在了很长时间，那么你很可能已经多次编写了一个定时器类。这个概念非常简单:给定一个定时器对象，调用start/stop应该跟踪它们之间经过的时间。我们的内联分析器实际上没有什么不同，只是我们为timer类添加了一个惟一的ID(为了保持一致，我称之为“span ”),还添加了一些限定了作用域的回调函数，使它更易于使用。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="beb5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了为我们的请求收集跟踪，我们需要某种管理对象，它具有足够长的持久性来存储我们的跨度并在被请求时返回它们的数据。这可以采取许多形状和形式，我的简单版本是故意裸露的骨骼，目的是在每次您想要开始一个范围概要文件时调用<em class="kx"> span </em>函数。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="2128" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用法非常简单:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="14ec" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">向API提交结果</h1><p id="6e77" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">有了上面的类，我们就有能力对代码块进行计时，所以下一个大问题是如何正确地将它们提交给StackDriver API。为此，我们首先需要能够获取项目的ID，以及请求对象的ID(这样我们就可以修补它的跟踪)。</p><p id="16ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以通过appengine API轻松获取项目ID(注意，这需要为身份库添加第三方库。查看<a class="ae jo" href="https://cloud.google.com/appengine/docs/standard/python/tools/using-libraries-python-27#vendoring" rel="noopener ugc nofollow" target="_blank">Google . app engine . ext . vendor</a>了解更多)。</p><p id="f745" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://gist.github.com/mainroach/5d75d882e81e1ba8ad0cd7cbb93afb0b" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/main roach/5d 75d 882 e 81 e 1 ba 8 ad 0 CD 7 cbb 93 AFB 0 b</a></p><p id="a607" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请求ID也很容易获得，因为它是由Google前端生成的，并且通常在请求头中注释为“X-Cloud-Trace-Context”。我们可以很容易地获取这些信息(如果存在的话):</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="3afc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们的span &amp; trace对象允许生成JSON，所以我们可以通过一些简单的数据构建来创建栈驱动API所期望的JSON blob:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="1fbb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经准备好了所有数据，我们终于可以连接到stackdriver API了。这首先要求我们按顺序进行一些身份验证，然后最终提交我们感兴趣的主体数据。为了获得关于如何做到这一点的信息，我不得不深入研究API库，但这里是所需的最短版本:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="8b38" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">所有人现在在一起！</h1><p id="267c" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我修改了TraceContext对象以接受来自头文件包的云跟踪信息，并将其打包在一起:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="c154" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打开请求的跟踪，向我们展示了我们想要的东西:</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/29e3383826e92d2686e912acd4f9de9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*nmx0enBGHAAnp31ALBndvQ.png"/></div></figure><h1 id="3ed1" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">警告</h1><p id="faba" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我必须强调的是，这段代码现在作为快照工作。我预计其中一些东西的格式可能会改变，或者一些API会随着时间的推移成熟为官方API。</p><p id="ede4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，请注意，您将会看到响应时间增加，因为提交跟踪结果会增加一些将数据推送到跟踪API的开销:</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es le"><img src="../Images/7306530b73d19b83a697e11722eb0fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*De1f3RpkoT6VEUhbc-MWaA.png"/></div></figure><p id="7ca1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，请确保非常小心地部署和使用这些跟踪数据。您必须始终注意，您的跟踪信息不会对性能造成太大的影响！</p></div></div>    
</body>
</html>