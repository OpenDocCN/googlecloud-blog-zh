<html>
<head>
<title>Golang | Copy to GCS &amp; Check Bucket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang |复制到GCS并检查存储桶</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/golang-copy-to-gcs-check-bucket-58721285788e?source=collection_archive---------0-----------------------#2020-09-14">https://medium.com/google-cloud/golang-copy-to-gcs-check-bucket-58721285788e?source=collection_archive---------0-----------------------#2020-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5d97c93862981713fff9996577b48795.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*65iXGLup5igJDZXA1oOFXw.png"/></div></figure><p id="7ab4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你是否在尝试使用Go将文件放入谷歌云存储，而不是将它们拖到运行代码的计算机上，或者打开它们并将内容读入一个新文件？如果是的话，我不久前也是。这里有一个快速的PSA来分享我整理的解决这个问题的代码。</p><h1 id="f91a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">将文件复制到GCS</h1><p id="a67a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">下面的代码示例可以将文件从一个url位置获取到GCS中，而无需将其下载到运行代码的服务器上。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="4158" class="kw jl hi ks b fi kx ky l kz la">import (<br/>    "cloud.google.com/go/storage"<br/>    "fmt"<br/>    "io"<br/>    "net/http"<br/>)</span><span id="9739" class="kw jl hi ks b fi lb ky l kz la">func storeGCS(url, bucketName, fileName string) error {<br/>    // Create GCS connection<br/>    ctx := context.Background()<br/>    client, err := storage.NewClient(ctx)</span><span id="3f3f" class="kw jl hi ks b fi lb ky l kz la">    // Connect to bucket<br/>    bucket = client.Bucket(bucketName)</span><span id="8506" class="kw jl hi ks b fi lb ky l kz la">    // Get the url response<br/>    if response, err := http.Get(url); err != nil {<br/>        return fmt.Errorf("HTTP response error: %v", err)<br/>    }<br/>    <em class="lc">Defer response.Body.Close()</em></span><span id="9079" class="kw jl hi ks b fi lb ky l kz la">    if response.StatusCode == http.StatusOK {<br/>        // Setup the GCS object with the filename to write to<br/>        obj := bucket.Object(fileName)<br/><br/>        <em class="lc">// w implements io.Writer.<br/>        </em>w := obj.NewWriter(ctx)<br/><br/>       <em class="lc">// Copy file into GCS<br/>       if </em>_, err := io.Copy(w, response.Body); err != nil {<em class="lc"><br/>           </em>return fmt.Errorf("Failed to copy to bucket: %v", err)<br/>       }<br/><br/>       <em class="lc">// Close, just like writing a file. File appears in GCS after<br/>       </em>if err := w.Close(); err != nil {<br/>           return fmt.Errorf("Failed to close: %v", err)<br/>       }<br/>    }<br/>    return nil<br/>}</span></pre><p id="e074" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关键线路包括<strong class="io hj"> io。复制</strong>，它将获取HTTP响应中的内容，并直接复制到bucket中。这个文件是什么格式并不重要，因为它不需要读取它。它只需要获取响应中的内容，并将其复制到GCS。我发现这非常有用，尤其是在处理压缩文件的时候。这也适用于图像文件，但实际上也适用于任何文件。</p><p id="94be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这假设在您使用的计算机上设置了凭据，因此它将能够登录到您的GCP并加载到GCS中。此外，该代码假设bucket存在。否则，您需要创建一个存储桶。</p><h1 id="3371" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Golang示例创建GCS存储桶(如果不存在)</h1><p id="07a9" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">下面是检查bucket是否存在的示例代码，如果不存在就创建它。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a421" class="kw jl hi ks b fi kx ky l kz la">import (<br/>    "cloud.google.com/go/storage"<br/>    "context"<br/>    "fmt"<br/>    "google.golang.org/api/iterator"<br/>    "log"<br/>)</span><span id="92ce" class="kw jl hi ks b fi lb ky l kz la">func CreateGCSBucket(bucketName, projectID string) error {<br/>   // Setup context and client<br/>    ctx := context.Background()<br/>    client := storage.NewClient(ctx)<br/>   <br/>    <em class="lc">// Setup client bucket to work from<br/>    </em>bucket = client.Bucket(bucketName)<br/><br/>    buckets := client.Buckets(ctx, projectID)<br/>    for {<br/><em class="lc">        </em>if bucketName == "" {<br/>            return fmt.Errorf("BucketName entered is empty %v.", bucketName)<br/>          }<br/>       attrs, err := buckets.Next()<br/>       <em class="lc">// Assume bucket not found if at Iterator end and create <br/>       </em>if err == iterator.Done {<br/>           <em class="lc">// Create bucket <br/>           </em>if err := bucket.Create(ctx, projectID, &amp;storage.BucketAttrs{<br/>            Location: "US",<br/>           }); err != nil {<em class="lc"><br/>               </em>return fmt.Errorf("Failed to create bucket: %v", err)<br/>           }<br/>           log.Printf("Bucket %v created.\n", bucketName)<br/>           return nil<br/>        }<br/>        if err != nil {<br/>            return fmt.Errorf("Issues setting up Bucket(%q).Objects(): %v. Double check project id.", attrs.Name, err)<br/>        }<br/>        if attrs.Name == bucketName {<br/><em class="lc">            </em>log.Printf("Bucket %v exists.\n", bucketName)<br/>            return nil<br/>         }<br/>   }<br/>}</span></pre><p id="4b01" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">需要注意的关键一点是与<strong class="io hj">客户争夺该项目的所有份额。桶，</strong>循环的<strong class="io hj">使用<strong class="io hj">桶遍历每个桶名。接下来</strong>并确认迭代器不在末尾，<strong class="io hj">迭代器。搞定</strong>。如果是，那么用<strong class="io hj">桶创建一个桶。创建</strong>但是如果您发现带有<strong class="io hj">属性的存储桶列表中提供的存储桶名称。Name == bucketName </strong>那么您不需要创建它。</strong></p><h1 id="98f6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">包裹</h1><p id="719b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">上面提供了两个Go代码示例，重点是如何使用Go将文件复制到GCS中，归结起来就是使用<strong class="io hj"> io。复制</strong>。此外，如何检查一个bucket是否已经存在，如果不存在，那么创建它。一个重要的测试包是<a class="ae ld" href="https://godoc.org/cloud.google.com/go/storage" rel="noopener ugc nofollow" target="_blank"> Go Storage </a>包，它提供了关于如何与GCS交互的更多细节，以及关于如何测试与GCS交互的<a class="ae ld" href="https://github.com/googleapis/google-cloud-go-testing/tree/master/storage/stiface" rel="noopener ugc nofollow" target="_blank"> Stiface </a>。</p><p id="46fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些代码片段来自我正在从事的一个名为Project OCEAN(开源社区生态系统焦点)的项目，该项目致力于对技术开源社区的公共结构和影响进行建模。你可以在我们的<a class="ae ld" href="https://github.com/google/project-OCEAN" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中查看关于上述代码的更多细节。</p></div></div>    
</body>
</html>