<html>
<head>
<title>Vault HA on GKE via Helm Charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过舵轮图在GKE上跳马</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/vault-ha-on-gke-via-helm-charts-687899ddfd08?source=collection_archive---------0-----------------------#2022-12-05">https://medium.com/google-cloud/vault-ha-on-gke-via-helm-charts-687899ddfd08?source=collection_archive---------0-----------------------#2022-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1d4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现代系统需要访问大量秘密，包括数据库凭证、外部服务的API密钥、面向服务架构通信的凭证。如今，大多数企业的凭证遍布其组织。密码、API密钥和凭证存储在纯文本、应用程序源代码、配置文件和其他位置。因为这些凭证无处不在，这种蔓延使得真正知道谁有权访问和访问什么变得困难和令人生畏。以纯文本形式保存凭据还会增加内部和外部攻击者进行恶意攻击的可能性。</p><p id="d7bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很难了解谁在访问哪些机密，如果没有定制的解决方案，添加密钥滚动、安全存储、详细的审计日志几乎是不可能的。这就是Vault介入的地方。Vault获取所有这些凭据，并将它们集中在一个位置进行定义，这样可以减少不必要的凭据暴露。但Vault更进了一步，它确保用户、应用和系统经过身份验证并明确授权访问资源，同时还提供审计跟踪，可捕获和保存客户端操作的历史记录。</p><h1 id="9f03" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是跳马？</h1><p id="f348" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Vault是一个基于身份的秘密和加密管理系统。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/356a1ff080da216bb1f12b3118cbbd95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ws5PUgomwzLaZHIztU2gdw.png"/></div></div></figure><h1 id="d974" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">跳马是如何工作的？</h1><p id="cd05" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">核心Vault工作流程包含四个阶段:</p><ul class=""><li id="4884" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated"><strong class="ih hj">认证:</strong>Vault中的认证是客户端提供信息的过程，Vault使用该信息来确定他们是否是他们所声称的身份。一旦根据auth方法对客户端进行了身份验证，就会生成一个令牌并将其与策略相关联。</li><li id="7daf" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">验证:</strong> Vault根据第三方可信来源(如Github、LDAP、AppRole等)来验证客户端。</li><li id="533d" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">授权</strong>:客户端匹配金库安全策略。此策略是一组规则，用于定义客户端可以使用其保管库令牌访问哪些API端点。策略提供了一种声明性的方式来授予或禁止对Vault中特定路径和操作的访问权限。</li><li id="76ed" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">访问</strong> : Vault通过基于与客户端身份相关的策略发布令牌来授予对秘密、密钥和加密功能的访问权。然后，客户端可以将它们的存储令牌用于将来的操作。</li></ul><h1 id="8957" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">通过Helm将Vault安装到Google Kubernetes引擎</h1><p id="f0e7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">谷歌Kubernetes引擎(GKE)可以在标准或自动驾驶模式下在其安全和管理的Kubernetes服务中运行Vault。标准模式为您提供了配置集群底层基础架构的灵活性，而自动驾驶模式为您提供了无需干预的优化集群体验。</p><h1 id="e043" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">先决条件</h1><p id="1824" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你需要一个<a class="ae lg" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云账户</a>、<a class="ae lg" href="https://cloud.google.com/sdk/docs/quickstart" rel="noopener ugc nofollow" target="_blank">谷歌云命令行界面</a>、<a class="ae lg" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> Kubernetes CLI </a>和<a class="ae lg" href="https://helm.sh/docs/helm/" rel="noopener ugc nofollow" target="_blank"> Helm CLI </a>。</p><p id="da75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">OS X家酿:</strong></p><ol class=""><li id="f0ac" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc lh ky kz la bi translated">用<a class="ae lg" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制</a>安装<code class="du li lj lk ll b">gcloud</code>。</li></ol><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="33a9" class="lq je hi ll b be lr ls l lt lu">$ brew install google-cloud-sdk</span></pre><p id="cb4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.用自制软件安装<code class="du li lj lk ll b">kubectl</code>。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="08d7" class="lq je hi ll b be lr ls l lt lu">$ brew install kubernetes-cli</span></pre><p id="62af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.用自制软件安装<code class="du li lj lk ll b">helm</code>。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="3456" class="lq je hi ll b be lr ls l lt lu">$ brew install helm</span></pre><p id="3c60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，将<code class="du li lj lk ll b">gcloud</code> CLI与您的Google帐户连接起来。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="3a8d" class="lq je hi ll b be lr ls l lt lu">$ gcloud auth login</span></pre><p id="048a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令启动浏览器，并要求您使用Google帐户凭据进行身份验证。</p><p id="d0c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，初始化<code class="du li lj lk ll b">gcloud</code>命令行界面。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="8138" class="lq je hi ll b be lr ls l lt lu">$ gcloud init</span></pre><p id="de05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个初始化过程可能会要求您创建一个Google Cloud项目。项目是组织所有Google云资源的唯一标识的名称空间。如果您已经有一个与您的帐户相关联的项目，创建一个新项目可能很重要。</p><p id="f516" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果需要，创建一个具有唯一标识符的Google Cloud项目。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="ed0c" class="lq je hi ll b be lr ls l lt lu">$ gcloud projects create PROJECT_ID</span></pre><p id="a746" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b">gcloud</code> CLI为您选择作为当前项目的项目管理Google云资源。</p><p id="5d39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您创建了一个项目，则需要将该项目设置为当前项目。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="a52f" class="lq je hi ll b be lr ls l lt lu">$ gcloud config set project PROJECT_ID</span></pre><p id="b2db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从列表中设置一个默认计算区和区域，其状态为UP。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="118a" class="lq je hi ll b be lr ls l lt lu">$ gcloud config set compute/region us-west1</span></pre><h1 id="c9ad" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">启动集群</h1><p id="594d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于创建Kubernetes集群的项目，需要启用容器服务。</p><p id="33af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启用Google容器服务。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="7bbb" class="lq je hi ll b be lr ls l lt lu">$ gcloud services enable container.googleapis.com</span></pre><p id="904b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以高可用性启动的Vault集群需要一个具有三个节点的Kubernetes集群。您可以手动创建这些节点或使用自动驾驶模式。</p><h1 id="bf2c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">自动驾驶仪</h1><p id="527a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在自动驾驶模式下创建一个名为<code class="du li lj lk ll b">learn-vault</code>的集群。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="22c4" class="lq je hi ll b be lr ls l lt lu">$ gcloud container clusters create-auto CLUSTER_NAME \<br/>    --region REGION \<br/>    --project=PROJECT_ID </span></pre><pre class="lv lm ll lw lx aw ly bi"><span id="c5f8" class="lz je hi ll b fi ma mb l mc lu">...<br/>Creating cluster learn-vault in us-west1...done.<br/>Created [https://container.googleapis.com/v1/projects/learn-hashicorp-UNIQUE_ID/zones/us-west1/clusters/learn-vault].<br/>To inspect the contents of your cluster, go to: <a class="ae lg" href="https://console.cloud.google.com/kubernetes/workload_/gcloud/us-west1/learn-vault?project=learn-hashicorp-UNIQUE_ID" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/kubernetes/workload_/gcloud/us-west1/learn-vault?project=learn-hashicorp-UNIQUE_ID</a><br/>kubeconfig entry generated for learn-vault.<br/>NAME         LOCATION  MASTER_VERSION   MASTER_IP      MACHINE_TYPE  NODE_VERSION     NUM_NODES  STATUS<br/>learn-vault  us-west1  1.21.5-gke.1302  34.82.120.195  e2-medium     1.21.5-gke.1302  3          RUNNING</span></pre><p id="4637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集群被创建、部署，然后进行运行状况检查。当集群准备就绪时，该命令会修改<code class="du li lj lk ll b">kubectl</code>配置，以便针对该集群执行您发出的命令。</p><p id="4445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显示集群的节点。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="180c" class="lq je hi ll b be lr ls l lt lu">$ kubectl get nodes<br/>NAME                                         STATUS   ROLES    AGE   VERSION<br/>gk3-learn-vault-default-pool-c4d4759d-w5g2   Ready    &lt;none&gt;   7m13s   v1.21.5-gke.1302<br/>gk3-learn-vault-default-pool-dbb32d2b-qcl7   Ready    &lt;none&gt;   7m13s   v1.21.5-gke.1302<br/>gk3-learn-vault-default-pool-bd170fcf-0vqg   Ready    &lt;none&gt;   7m13s   v1.21.5-gke.1302</span></pre><p id="9f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Autopilot显示一组较小的节点，但会根据需要提供更多的节点。</p><p id="9d0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集群准备就绪。</p><blockquote class="md me mf"><p id="40d4" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">注意:如果您需要配置集群底层基础设施的灵活性，您也可以创建一个标准的GKE集群</p></blockquote><h1 id="70f5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">安装保险库舵图</h1><p id="0510" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在Kubernetes上运行跳马的推荐方式是通过<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/platform/k8s/helm" rel="noopener ugc nofollow" target="_blank">头盔图</a>。</p><p id="e13a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加HashiCorp Helm存储库。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="3442" class="lq je hi ll b be lr ls l lt lu">$ helm repo add hashicorp https://helm.releases.hashicorp.com<br/>"hashicorp" has been added to your repositories</span></pre><p id="701a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新所有的库以确保<code class="du li lj lk ll b">helm</code>知道最新的版本。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="dff6" class="lq je hi ll b be lr ls l lt lu">$ helm repo update<br/>Hang tight while we grab the latest from your chart repositories...<br/>...Successfully got an update from the "hashicorp" chart repository<br/>Update Complete. ⎈Happy Helming!⎈</span></pre><p id="d40b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搜索所有的保险库舵图表版本。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="db12" class="lq je hi ll b be lr ls l lt lu">$ helm search repo vault --versions<br/>NAME            CHART VERSION   APP VERSION DESCRIPTION<br/>hashicorp/vault 0.18.0          1.9.0       Official HashiCorp Vault Chart<br/>hashicorp/vault 0.17.1          1.8.4       Official HashiCorp Vault Chart<br/>hashicorp/vault 0.17.0          1.8.4       Official HashiCorp Vault Chart<br/>hashicorp/vault 0.16.1          1.8.3       Official HashiCorp Vault Chart</span></pre><p id="f381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vault舵图包含在几种不同模式下运行Vault的所有必要组件。</p><blockquote class="md me mf"><p id="0492" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">默认行为:默认情况下，它使用文件存储后端以独立模式在单个pod上启动Vault。启用Raft集成存储的高可用性要求您覆盖这些默认值。</p></blockquote><p id="43a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在具有集成存储的HA模式下安装最新版本的Vault Helm chart。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="cc95" class="lq je hi ll b be lr ls l lt lu">$ helm install vault hashicorp/vault \<br/>    --set='server.ha.enabled=true' \<br/>    --set='server.ha.raft.enabled=true'</span></pre><p id="6d51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储库窗格和存储库代理注入器窗格部署在默认名称空间中。</p><p id="d5cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获取默认名称空间中的所有窗格。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="1c51" class="lq je hi ll b be lr ls l lt lu">$ kubectl get pods<br/>NAME                                    READY   STATUS    RESTARTS   AGE<br/>vault-0                                 0/1     Running   0          30s<br/>vault-1                                 0/1     Running   0          30s<br/>vault-2                                 0/1     Running   0          30s<br/>vault-agent-injector-56bf46695f-crqqn   1/1     Running   0          30s</span></pre><p id="e4b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署的<code class="du li lj lk ll b">vault-0</code>、<code class="du li lj lk ll b">vault-1</code>和<code class="du li lj lk ll b">vault-2</code>吊舱运行一个保险库服务器，并报告它们是<code class="du li lj lk ll b">Running</code>，但是它们没有准备好(<code class="du li lj lk ll b">0/1</code>)。这是因为在<a class="ae lg" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" rel="noopener ugc nofollow" target="_blank"> readinessProbe </a>中定义的状态检查返回一个非零退出代码。</p><p id="a3da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署的<code class="du li lj lk ll b">vault-agent-injector</code>吊舱是一个Kubernetes突变Webhook控制器。控制器截获pod事件，如果请求中存在特定的注释，就对pod应用突变。</p><p id="8900" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du li lj lk ll b">vault-0</code>盒上检索保险库的状态。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="5866" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-0 -- vault status<br/>Key                Value<br/>---                -----<br/>Seal Type          shamir<br/>Initialized        false<br/>Sealed             true<br/>Total Shares       0<br/>Threshold          0<br/>Unseal Progress    0/0<br/>Unseal Nonce       n/a<br/>Version            n/a<br/>HA Enabled         false<br/>command terminated with exit code 2</span></pre><p id="3698" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lg" href="https://developer.hashicorp.com/vault/docs/commands/status" rel="noopener ugc nofollow" target="_blank">状态命令</a>报告保险库未初始化且已<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/concepts/seal#why" rel="noopener ugc nofollow" target="_blank">密封</a>。要使Vault与Kubernetes进行身份验证并管理机密，需要对其进行初始化和解封。</p><h1 id="17e5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">初始化并解封一个存储区盒</h1><p id="a77e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">保险库开始<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/commands/operator/init" rel="noopener ugc nofollow" target="_blank">未初始化</a>并处于<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/concepts/seal#why" rel="noopener ugc nofollow" target="_blank">密封</a>状态。初始化之前，集成存储后端不准备接收数据。</p><p id="833b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用一个密钥份额和一个密钥阈值初始化保管库。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="ef50" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-0 -- vault operator init -key-shares=1 -key-threshold=1 -format=json &gt; cluster-keys.json</span></pre><p id="426d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b"><a class="ae lg" href="https://developer.hashicorp.com/vault/docs/commands/operator/init" rel="noopener ugc nofollow" target="_blank">operator init</a></code>命令生成一个根密钥，将其分解成密钥份额<code class="du li lj lk ll b">-key-shares=1</code>，然后设置解封保险库<code class="du li lj lk ll b">-key-threshold=1</code>所需的密钥份额数量。这些密钥份额以JSON格式<code class="du li lj lk ll b">-format=json</code>作为解封密钥写入输出。这里，输出被重定向到一个名为<code class="du li lj lk ll b">cluster-keys.json</code>的文件。</p><p id="bb0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显示在<code class="du li lj lk ll b">cluster-keys.json</code>中找到的解封密钥。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="711d" class="lq je hi ll b be lr ls l lt lu">$ cat cluster-keys.json | jq -r ".unseal_keys_b64[]"<br/>rrUtT32GztRy/pVWmcH0ZQLCCXon/TxCgi40FL1Zzus=</span></pre><blockquote class="md me mf"><p id="6c3f" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">不安全的操作:不要使用单个密钥共享和单个密钥阈值在生产环境中运行未密封的存储库。此处使用这种方法只是为了简化本演示的解封过程。</p></blockquote><p id="fc71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个名为<code class="du li lj lk ll b">VAULT_UNSEAL_KEY</code>的变量来捕获保险库解封密钥。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="5336" class="lq je hi ll b be lr ls l lt lu">$ VAULT_UNSEAL_KEY=$(cat cluster-keys.json | jq -r ".unseal_keys_b64[]")</span></pre><p id="4eec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始化后，Vault被配置为知道在何处以及如何访问存储，但不知道如何对其进行解密。<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/concepts/seal#unsealing" rel="noopener ugc nofollow" target="_blank">解封</a>是构建读取解密密钥以解密数据所需的根密钥的过程，允许访问保险库。</p><p id="761b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开启<code class="du li lj lk ll b">vault-0</code>舱上运行的保险库。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="53e7" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-0 -- vault operator unseal $VAULT_UNSEAL_KEY<br/>Key                     Value<br/>---                     -----<br/>Seal Type               shamir<br/>Initialized             true<br/>Sealed                  false<br/>Total Shares            1<br/>Threshold               1<br/>Version                 1.5.4<br/>Cluster Name            vault-cluster-4752e6ca<br/>Cluster ID              de2b0fe9-ce24-59e5-c766-a4e2ac7df643<br/>HA Enabled              true<br/>HA Cluster              n/a<br/>HA Mode                 standby<br/>Active Node Address     &lt;none&gt;<br/>Raft Committed Index    24<br/>Raft Applied Index      24</span></pre><p id="f2c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b">operator unseal</code>命令报告存储库已初始化且未密封。</p><blockquote class="md me mf"><p id="f9fc" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">不安全的操作:使用命令提供解封密钥会将密钥写入shell的历史记录中。此处使用这种方法只是为了简化本演示的解封过程。</p></blockquote><p id="e1b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du li lj lk ll b">vault-0</code>盒上检索保险库的状态。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="d771" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-0 -- vault status<br/>Key                     Value<br/>---                     -----<br/>Seal Type               shamir<br/>Initialized             true<br/>Sealed                  false<br/>Total Shares            1<br/>Threshold               1<br/>Version                 1.5.4<br/>Cluster Name            vault-cluster-4752e6ca<br/>Cluster ID              de2b0fe9-ce24-59e5-c766-a4e2ac7df643<br/>HA Enabled              true<br/>HA Cluster              https://vault-0.vault-internal:8201<br/>HA Mode                 active<br/>Raft Committed Index    29<br/>Raft Applied Index      29</span></pre><p id="cfcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vault服务器已初始化并解除密封。</p><h1 id="853a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">将其他保管库加入保管库群集</h1><p id="5f9b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在<code class="du li lj lk ll b">vault-0</code> pod上运行的Vault服务器是一个具有单个节点的Vault HA集群。要显示节点列表，您需要使用根令牌登录。</p><p id="2400" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显示在<code class="du li lj lk ll b">cluster-keys.json</code>中找到的根令牌。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="9afd" class="lq je hi ll b be lr ls l lt lu">$ cat cluster-keys.json | jq -r ".root_token"</span></pre><p id="892f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个名为<code class="du li lj lk ll b">CLUSTER_ROOT_TOKEN</code>的变量来捕获保险库解封密钥。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="ed0e" class="lq je hi ll b be lr ls l lt lu">$ CLUSTER_ROOT_TOKEN=$(cat cluster-keys.json | jq -r ".root_token")</span></pre><p id="2d16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du li lj lk ll b">vault-0</code> pod上的根令牌登录。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="e393" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-0 -- vault login $CLUSTER_ROOT_TOKEN</span></pre><pre class="lv lm ll lw lx aw ly bi"><span id="f6c1" class="lz je hi ll b fi ma mb l mc lu">Key                  Value<br/>---                  -----<br/>token                s.fgoUNVHDrdwlxftvM48A0yxa<br/>token_accessor       vmPnI3OT0mxrI7UEa8RfJvvr<br/>token_duration       ∞<br/>token_renewable      false<br/>token_policies       ["root"]<br/>identity_policies    []<br/>policies             ["root"]</span></pre><blockquote class="md me mf"><p id="7695" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">不安全的操作:login命令将根令牌存储在容器用户的文件中。后续命令使用该令牌执行。此处使用这种方法只是为了简化集群配置演示。</p></blockquote><p id="baa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列出<code class="du li lj lk ll b">vault-0</code>窗格的存储集群中的所有节点。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="e788" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-0 -- vault operator raft list-peers<br/>Node                                    Address                        State     Voter<br/>----                                    -------                        -----     -----<br/>09d9b35d-0336-7de7-cc94-90a1f3a0aff8    vault-0.vault-internal:8201    leader    true</span></pre><p id="6ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将显示存储集群中的一个节点。该集群可通过Helm chart创建的Kubernetes服务<code class="du li lj lk ll b">vault-0.vault-internal</code>进行寻址。其他pod上的Vault服务器需要加入该集群并被解封。</p><p id="a7e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将<code class="du li lj lk ll b">vault-1</code>上的Vault服务器加入Vault集群。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="0aa7" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-1 -- vault operator raft join http://vault-0.vault-internal:8200<br/>Key       Value<br/>---       -----<br/>Joined    true</span></pre><p id="35da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此Vault服务器密封地加入群集。要解封Vault服务器，需要提供给第一个Vault服务器的相同解封密钥<code class="du li lj lk ll b">VAULT_UNSEAL_KEY</code>。</p><p id="e868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用解封密钥解封<code class="du li lj lk ll b">vault-1</code>上的保险库服务器。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="d672" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-1 -- vault operator unseal $VAULT_UNSEAL_KEY<br/>Key                Value<br/>---                -----<br/>Seal Type          shamir<br/>Initialized        true<br/>Sealed             true<br/>Total Shares       1<br/>Threshold          1<br/>Unseal Progress    0/1<br/>Unseal Nonce       n/a<br/>Version            1.5.4<br/>HA Enabled         true</span></pre><p id="b2bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b">vault-1</code>上的Vault服务器现在是Vault集群中的一个功能节点。</p><p id="6a8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将<code class="du li lj lk ll b">vault-2</code>上的Vault服务器加入Vault集群。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="9bab" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-2 -- vault operator raft join http://vault-0.vault-internal:8200<br/>Key       Value<br/>---       -----<br/>Joined    true</span></pre><p id="3d56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用解封密钥在<code class="du li lj lk ll b">vault-2</code>解封保险库服务器。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="a690" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-2 -- vault operator unseal $VAULT_UNSEAL_KEY<br/>Key                Value<br/>---                -----<br/>Seal Type          shamir<br/>Initialized        true<br/>Sealed             true<br/>Total Shares       1<br/>Threshold          1<br/>Unseal Progress    0/1<br/>Unseal Nonce       n/a<br/>Version            1.5.4<br/>HA Enabled         true</span></pre><p id="5fd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b">vault-2</code>上的Vault服务器现在是Vault集群中的一个功能节点。</p><p id="52e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列出<code class="du li lj lk ll b">vault-0</code> pod的存储集群中的所有节点。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="1f67" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec vault-0 -- vault operator raft list-peers<br/>Node                                    Address                        State       Voter<br/>----                                    -------                        -----       -----<br/>09d9b35d-0336-7de7-cc94-90a1f3a0aff8    vault-0.vault-internal:8201    leader      true<br/>7078a8b7-7948-c224-a97f-af64771ad999    vault-1.vault-internal:8201    follower    true<br/>aaf46893-0a93-17ce-115e-f57033d7f41d    vault-2.vault-internal:8201    follower    true</span></pre><p id="3332" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将显示存储集群中的所有三个节点。</p><p id="2775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获取默认名称空间中的所有窗格。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="bb57" class="lq je hi ll b be lr ls l lt lu">$ kubectl get pods<br/>NAME                                    READY   STATUS    RESTARTS   AGE<br/>vault-0                                 1/1     Running   0          5m49s<br/>vault-1                                 1/1     Running   0          5m48s<br/>vault-2                                 1/1     Running   0          5m47s<br/>vault-agent-injector-5945fb98b5-vzbqv   1/1     Running   0          5m50s</span></pre><p id="0cac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b">vault-0</code>、<code class="du li lj lk ll b">vault-1</code>和<code class="du li lj lk ll b">vault-2</code>pod报告它们是<code class="du li lj lk ll b">Running</code>并准备就绪(<code class="du li lj lk ll b">1/1</code>)。</p><h1 id="dcdc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在保险库中设置一个秘密</h1><p id="47a0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">您部署的web应用程序希望Vault在路径<code class="du li lj lk ll b">secret/webapp/config</code>中存储用户名和密码。要创建这个密码，您需要使用根令牌登录，启用键-值密码引擎，并在定义的路径中存储一个密码用户名和密码。</p><p id="b259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，在<code class="du li lj lk ll b">vault-0</code> pod上启动一个交互式shell会话。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="7061" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec --stdin=true --tty=true vault-0 -- /bin/sh<br/>/ $</span></pre><p id="7ab4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的系统提示被替换为新的提示<code class="du li lj lk ll b">/ $</code>。</p><p id="2889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:本部分中的提示显示为<code class="du li lj lk ll b">$</code>，但命令旨在在<code class="du li lj lk ll b">vault-0</code>容器上的交互外壳中执行。</p><p id="c6e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在路径<code class="du li lj lk ll b">secret</code>启用kv-v2保密。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="c64f" class="lq je hi ll b be lr ls l lt lu">$ vault secrets enable -path=secret kv-v2<br/>Success! Enabled the kv-v2 secrets engine at: secret/</span></pre><p id="d491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用<code class="du li lj lk ll b">username</code>和<code class="du li lj lk ll b">password</code>在路径<code class="du li lj lk ll b">secret/devwebapp/config</code>创建一个秘密。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="4986" class="lq je hi ll b be lr ls l lt lu">$ vault kv put secret/devwebapp/config username='giraffe' password='salsa'<br/>Key              Value<br/>---              -----<br/>created_time     2020-12-11T19:14:05.170436863Z<br/>deletion_time    n/a<br/>destroyed        false<br/>version          1</span></pre><p id="e118" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证密码是否在路径<code class="du li lj lk ll b">secret/data/devwebapp/config</code>中定义。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="9abe" class="lq je hi ll b be lr ls l lt lu">$ vault kv get secret/devwebapp/config<br/>====== Metadata ======<br/>Key              Value<br/>---              -----<br/>created_time     2020-12-11T19:14:05.170436863Z<br/>deletion_time    n/a<br/>destroyed        false<br/>version          1</span></pre><pre class="lv lm ll lw lx aw ly bi"><span id="8f4d" class="lz je hi ll b fi ma mb l mc lu">====== Data ======<br/>Key         Value<br/>---         -----<br/>password    salsa<br/>username    giraffe</span></pre><p id="16ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您成功地为web应用程序创建了密码。</p><p id="42a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，退出<code class="du li lj lk ll b">vault-0</code>舱。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="1e86" class="lq je hi ll b be lr ls l lt lu">$ exit</span></pre><h1 id="e98e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">配置Kubernetes身份验证</h1><p id="1382" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">初始的<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/concepts/tokens#root-tokens" rel="noopener ugc nofollow" target="_blank">根令牌</a>是特权用户，可以在任何路径执行任何操作。web应用程序只需要能够读取在单个路径上定义的秘密。该应用程序应该进行身份验证，并被授予一个具有受限访问权限的令牌。</p><blockquote class="md me mf"><p id="9705" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">最佳实践:我们建议<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/concepts/tokens#root-tokens" rel="noopener ugc nofollow" target="_blank">根令牌</a>仅用于身份验证方法和策略的初始设置。之后，它们应该被撤销。本教程不会向您展示如何撤销根令牌。</p></blockquote><p id="0c91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vault提供了一种<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/auth/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes身份验证</a>方法，使客户端能够使用Kubernetes服务帐户令牌进行身份验证。</p><p id="5a72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，在<code class="du li lj lk ll b">vault-0</code> pod上启动一个交互式shell会话。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="211c" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec --stdin=true --tty=true vault-0 -- /bin/sh<br/>/ $</span></pre><p id="3643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的系统提示被替换为新的提示<code class="du li lj lk ll b">/ $</code>。</p><blockquote class="md me mf"><p id="162b" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">注意:这个部分中的提示显示为<code class="du li lj lk ll b">$</code>，但是这些命令将在<code class="du li lj lk ll b">vault-0</code>容器上的这个交互式shell中执行。</p></blockquote><p id="444a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启用Kubernetes身份验证方法。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="73ed" class="lq je hi ll b be lr ls l lt lu">$ vault auth enable kubernetes<br/>Success! Enabled kubernetes auth method at: kubernetes/</span></pre><p id="7e84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vault接受来自Kubernetes群集中任何客户端的服务令牌。在身份验证过程中，Vault通过查询令牌审查Kubernetes端点来验证服务帐户令牌是否有效。</p><p id="bb0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">配置Kubernetes身份验证方法以使用Kubernetes API的位置。当查询令牌审查API时，它将自动使用pod自己的身份向Kubernetes进行身份验证。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="5eb2" class="lq je hi ll b be lr ls l lt lu">$ vault write auth/kubernetes/config \<br/>    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"</span></pre><p id="d8f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">环境变量<code class="du li lj lk ll b">KUBERNETES_PORT_443_TCP_ADDR</code>被定义并引用Kubernetes主机的内部网络地址。</p><p id="e2aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使保险库服务器的客户端读取在<a class="ae lg" href="https://developer.hashicorp.com/vault/tutorials/kubernetes/kubernetes-google-cloud-gke#set-a-secret-in-vault" rel="noopener ugc nofollow" target="_blank">中定义的秘密数据，在保险库</a>中设置秘密的步骤需要为路径<code class="du li lj lk ll b">secret/data/devwebapp/config</code>授予读取能力。</p><p id="5a88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">写出名为<code class="du li lj lk ll b">devwebapp</code>的策略，为路径<code class="du li lj lk ll b">secret/data/devwebapp/config</code>上的机密启用<code class="du li lj lk ll b">read</code>功能</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="7c2e" class="lq je hi ll b be lr ls l lt lu">$ vault policy write devwebapp - &lt;&lt;EOF<br/>path "secret/data/devwebapp/config" {<br/>  capabilities = ["read"]<br/>}<br/>EOF</span></pre><p id="dc82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个名为<code class="du li lj lk ll b">devweb-app</code>的Kubernetes认证角色。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="259c" class="lq je hi ll b be lr ls l lt lu">$ vault write auth/kubernetes/role/devweb-app \<br/>        bound_service_account_names=internal-app \<br/>        bound_service_account_namespaces=default \<br/>        policies=devwebapp \<br/>        ttl=24h</span></pre><p id="b3da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该角色将Kubernetes服务帐户<code class="du li lj lk ll b">internal-app</code>(在下一步中创建)和名称空间<code class="du li lj lk ll b">default</code>与Vault策略<code class="du li lj lk ll b">devwebapp</code>连接起来。身份验证后返回的令牌在24小时内有效。</p><p id="1fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，退出<code class="du li lj lk ll b">vault-0</code>舱。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="70ae" class="lq je hi ll b be lr ls l lt lu">$ exit</span></pre><h1 id="2784" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">部署web应用程序</h1><p id="b85f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">web应用程序窗格要求创建在Vault Kubernetes身份验证角色中指定的<code class="du li lj lk ll b">internal-app</code> Kubernetes服务帐户。</p><p id="4032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个名为<code class="du li lj lk ll b">internal-app</code>的Kubernetes服务帐户。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="e844" class="lq je hi ll b be lr ls l lt lu">$ kubectl create sa internal-app</span></pre><p id="4124" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用web应用程序定义一个名为<code class="du li lj lk ll b">devwebapp</code>的pod。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="e0a1" class="lq je hi ll b be lr ls l lt lu">$ cat &gt; devwebapp.yaml &lt;&lt;EOF<br/>---<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: devwebapp<br/>  labels:<br/>    app: devwebapp<br/>  annotations:<br/>    vault.hashicorp.com/agent-inject: "true"<br/>    vault.hashicorp.com/role: "devweb-app"<br/>    vault.hashicorp.com/agent-inject-secret-credentials.txt: "secret/data/devwebapp/config"<br/>spec:<br/>  serviceAccountName: internal-app<br/>  containers:<br/>    - name: devwebapp<br/>      image: jweissig/app:0.0.1<br/>EOF</span></pre><p id="7338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个定义创建了一个pod，它具有使用<code class="du li lj lk ll b">internal-app</code> Kubernetes服务帐户运行的指定容器。pod中的容器不知道存储区群集。Vault Injector服务读取<a class="ae lg" href="https://developer.hashicorp.com/vault/docs/platform/k8s/injector#annotations" rel="noopener ugc nofollow" target="_blank">注释</a>以找到存储在Vault中的<code class="du li lj lk ll b">secret/data/devwebapp/config</code>和文件位置<code class="du li lj lk ll b">/vault/secrets/secret-credentials.txt</code>处的秘密路径，从而将该秘密与pod一起挂载。</p><p id="c76d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建<code class="du li lj lk ll b">devwebapp</code> pod。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="52dc" class="lq je hi ll b be lr ls l lt lu">$ kubectl apply --filename devwebapp.yaml</span></pre><p id="7fee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获取默认名称空间中的所有窗格。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="1c95" class="lq je hi ll b be lr ls l lt lu">$ kubectl get pods<br/>devwebapp                               2/2     Running   0          6s<br/>vault-0                                 1/1     Running   0          8m48s<br/>vault-1                                 1/1     Running   0          8m48s<br/>vault-2                                 1/1     Running   0          8m48s<br/>vault-agent-injector-56bf46695f-gdpsz   1/1     Running   0          8m48s</span></pre><p id="c526" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等待直到<code class="du li lj lk ll b">devwebapp</code> pod报告正在运行并准备就绪(<code class="du li lj lk ll b">2/2</code>)。</p><p id="2f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du li lj lk ll b">devwebapp</code>盒上显示写入文件<code class="du li lj lk ll b">/vault/secrets/secret-credentials.txt</code>的秘密。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="bffa" class="lq je hi ll b be lr ls l lt lu">$ kubectl exec --stdin=true --tty=true devwebapp -c devwebapp -- cat /vault/secrets/credentials.txt<br/>data: map[password:salsa username:giraffe]<br/>metadata: map[created_time:2020-12-11T19:14:05.170436863Z deletion_time: destroyed:false version:1]</span></pre><p id="8611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果显示容器上存在的未格式化的机密数据。</p><blockquote class="md me mf"><p id="67fd" class="if ig mg ih b ii ij ik il im in io ip mh ir is it mi iv iw ix mj iz ja jb jc hb bi translated">格式化数据:可以应用一个<a class="ae lg" href="https://developer.hashicorp.com/vault/tutorials/kubernetes/kubernetes-sidecar#apply-a-template-to-the-injected-secrets" rel="noopener ugc nofollow" target="_blank">模板</a>来构造该数据，以满足应用的需要。</p></blockquote><h1 id="d6a6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">打扫</h1><p id="5f23" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">摧毁集群。</p><pre class="kh ki kj kk fd lm ll ln bn lo lp bi"><span id="04e0" class="lq je hi ll b be lr ls l lt lu">$ gcloud container clusters delete learn-vault</span></pre><p id="e560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集群被摧毁了。</p><p id="0ecd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以通过Helm Charts跨DIY Kubernetes集群、AWS EKS、AWS EKS Anywhere、Azure AKS和Redhat Openshift托管产品设置Vault。</p></div></div>    
</body>
</html>