<html>
<head>
<title>Understanding kubernetes networking: pods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解kubernetes网络:pods</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727?source=collection_archive---------0-----------------------#2017-10-26">https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727?source=collection_archive---------0-----------------------#2017-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="753f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章试图揭开在kubernetes集群中运行的几层网络的神秘面纱。Kubernetes是一个包含许多智能设计选择的强大平台，但讨论事物交互的方式可能会令人困惑:pod网络、服务网络、集群IP、容器端口、主机端口、节点端口……我已经看到一些人目光呆滞。我们大多在工作中谈论这些事情，一次跨越所有层面，因为有些东西坏了，有人想修理它。如果你一次拿一块，弄清楚每一层是如何工作的，那么一切都会以一种相当优雅的方式变得有意义。</p><p id="45c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了保持重点，我将这篇文章分成三部分。这第一部分将着眼于容器和荚。第二个<a class="ae jd" rel="noopener" href="/@betz.mark/understanding-kubernetes-networking-services-f0cb48e4cc82">将检查服务</a>，这是允许pod短暂存在的抽象层。<a class="ae jd" rel="noopener" href="/@betz.mark/understanding-kubernetes-networking-ingress-1bc341c84078">的最后一个帖子</a>将查看入口，并从集群外部获取流量。首先是一些免责声明。这篇文章并不是对容器、kubernetes或pods的基本介绍。要了解更多关于容器如何工作的信息，请参见<a class="ae jd" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>中的<a class="ae jd" href="https://docs.docker.com/engine/docker-overview/#the-underlying-technology" rel="noopener ugc nofollow" target="_blank">概述</a>。在这里可以找到kubernetes的高级概述，在这里可以找到pods的概述。最后，基本熟悉<a class="ae jd" href="https://www.digitalocean.com/community/tutorials/an-introduction-to-networking-terminology-interfaces-and-protocols" rel="noopener ugc nofollow" target="_blank">网络</a>和<a class="ae jd" href="https://www.digitalocean.com/community/tutorials/understanding-ip-addresses-subnets-and-cidr-notation-for-networking" rel="noopener ugc nofollow" target="_blank"> IP地址空间</a>会有所帮助。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/0ca67633514f62ee8d1e6465ea02be8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DymPHFgLmQ3WoEbbyM52Q.png"/></div></div></figure><h1 id="2736" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">分离舱</h1><p id="3974" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">那么什么是豆荚呢？pod由一个或多个容器组成，这些容器并置在同一台主机上，并配置为共享网络堆栈和其他资源，如卷。pod是构建kubernetes应用程序的基本单元。“共享网络堆栈”实际上意味着什么？实际上，这意味着pod中的所有容器都可以在本地主机上互相访问。如果我有一个运行nginx并监听端口80的容器和另一个运行scrapyd的容器，那么第二个容器可以以http://localhost:80的形式连接到第一个容器。但是这到底是怎么回事呢？让我们看看在本地机器上启动docker容器时的典型情况:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/4ff863de357a6e4e11fb6593f93facf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Xo-WpbTTGKZhJt7TvFLZQ.png"/></div></div></figure><p id="dc90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上到下，我们有一个物理网络接口eth0。与之相连的是网桥docker0，与之相连的是虚拟网络接口veth0。请注意，docker0和veth0都在同一个网络上，在本例中为172.17.0.0/24。在这个网络上，docker0被分配172.17.0.1，并且是veth0的<a class="ae jd" href="https://en.wikipedia.org/wiki/Default_gateway" rel="noopener ugc nofollow" target="_blank">默认网关</a>，veth 0被分配172.17.0.2。由于启动容器时网络名称空间的配置方式，容器内部的进程只能看到veth0，并通过docker0和eth0与外界通信。现在让我们启动第二个容器:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/bdf4d11d8ce9d3642f9a41ad052941b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdgIoY6tuOqK-r6wgL7d5A.png"/></div></div></figure><p id="2bac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所示，第二个容器获得一个新的虚拟网络接口veth1，连接到同一个docker0网桥。*这个接口被分配了172.17.0.3，所以它与网桥和第一个容器在同一个逻辑网络上，两个容器只要能以某种方式发现对方容器的IP地址，就可以通过网桥进行通信。</p><p id="c27c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[ *丹·尼森鲍姆指出，这种描述省略了一些细节。背景见我们的<a class="ae jd" rel="noopener" href="/@dannissenbaum?source=post_header_lockup">简短讨论</a>。]</p><p id="d5c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【* 12/15/2018:我之前的更新真的是把这个错误的下层给弄了。容器和网桥之间的连接是通过一对链接的虚拟以太网设备建立的，一个在容器网络命名空间中，另一个在根网络命名空间中。关于这个主题的概述，请参见Kristen Jacobs本周在西雅图Kubecon 2018上发表的“从零开始的集装箱网络”演讲(底部有幻灯片链接)。我真的很喜欢Kristen的演示，我打算在以后的容器网络上不要脸地复制它。]</p><p id="4f7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[* 9/9/2019:<a class="ae jd" href="http://ifeanyi.co/posts/linux-namespaces-part-4/" rel="noopener ugc nofollow" target="_blank">Ifeanyi Ubah的这篇文章</a>在探索linux网络名称空间和veth对方面做了大量工作]</p><p id="af7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很好，但它不能让我们看到kubernetes pod的“共享网络堆栈”。幸运的是，名称空间非常灵活。Docker可以启动一个容器，而不是为它创建一个新的虚拟网络接口，指定它<a class="ae jd" href="https://docs.docker.com/engine/reference/run/#network-settings" rel="noopener ugc nofollow" target="_blank">共享一个现有的接口</a>。在这种情况下，上面的图看起来有点不同:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/c5a7b40961fd2c82f0157bf9b19fc4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akBBZKad2SAxSnJNaSHVmg.png"/></div></div></figure><p id="efc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，第二个容器看到veth0，而不是像上一个示例那样获得自己的veth1。这意味着:首先，两个容器都可以在172.17.0.2上从外部寻址，在内部，每个容器都可以访问本地主机上另一个容器打开的端口。这也意味着两个容器不能打开同一个端口，这是一个限制，但与在单个主机上运行多个进程的情况没有什么不同。这样，一组进程可以充分利用容器的解耦和隔离，同时在尽可能简单的网络环境中协作。</p><p id="6de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes通过为每个pod创建一个特殊的容器来实现这种模式，这个容器的唯一目的是为其他容器提供一个网络接口。如果您ssh到一个kubernetes集群节点，该节点上已经安排了pods并运行<code class="du ku kv kw kx b"><strong class="ih hj">docker ps</strong></code>,您将看到至少有一个容器是用<code class="du ku kv kw kx b"><strong class="ih hj">pause</strong></code>命令启动的。<code class="du ku kv kw kx b"><strong class="ih hj">pause</strong></code>命令暂停当前进程，直到收到一个信号，所以这些容器除了休眠什么也不做，直到kubernetes给它们发送一个SIGTERM。尽管缺少活动,“暂停”容器是pod的核心，它提供了虚拟网络接口，所有其他容器将使用该接口相互通信以及与外界通信。所以在一个假设的豆荚状物体中，最后一张图片看起来像这样:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/14adb35b7e3fe87e73a492b72be5f48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JLi1Rl0G0FAeu-hiTGSGQ.png"/></div></div></figure><h1 id="f500" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">豆荚网络</h1><p id="ed81" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这一切都很酷，但一个装满可以相互交流的容器的舱并不能给我们带来一个系统。在我讨论服务的下一篇文章中，原因将变得更加清楚，kubernetes设计的核心要求pods能够与其他pods通信，不管它们是运行在同一个本地主机上还是不同的主机上。为了了解这是如何发生的，我们需要更上一层楼，看看集群中的节点。这一部分将包含一些关于网络路由和路线的不幸的参考，一个我意识到全人类都希望避免的主题。找到一个关于IP路由的清晰、简短的教程是困难的，但是如果你想要一个像样的评论，维基百科关于主题的<a class="ae jd" href="https://en.wikipedia.org/wiki/Routing_table" rel="noopener ugc nofollow" target="_blank">文章并不可怕。</a></p><p id="e5e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kubernetes集群由一个或多个节点组成。一个节点是一个主机系统，无论是物理的还是虚拟的，都有一个容器运行时及其依赖项(主要是docker)和几个kubernetes系统组件，它连接到一个允许它访问集群中其他节点的网络。由两个节点组成的简单集群可能如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/66ce9698e90f6464d891f3435520c307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGG8e2tbP4bQbsS33gfwUw.png"/></div></div></figure><p id="e06c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你在像GCP或AWS这样的云平台上运行你的集群，这个图很好地近似了单个项目环境的默认网络架构。为了便于说明，我在本例中使用了专用网络10.100.0.0/24，因此路由器是10.100.0.1，两个实例分别是10.100.0.2和10.100.0.3。根据这种设置，每个实例都可以在eth0上相互通信。这很好，但是回想一下，我们上面看到的pod不在这个私有网络上:它挂在一个完全不同的网络上的桥上，这个网络是虚拟的，只存在于特定的节点上。为了使这一点更清楚，让我们把豆荚状的东西放回图片中:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/53b8bf7a94073ea78170d2feb0980f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiLtoAdCfcJygwePVJzZOA.png"/></div></div></figure><p id="e65d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左侧主机的接口eth0地址为10.100.0.2，其默认网关是位于10.100.0.1的路由器。地址为172.17.0.1的网桥docker0连接到该接口，地址为172.17.0.2的接口veth0连接到该接口。veth0接口是用pause容器创建的，由于共享的网络堆栈，它在所有三个容器中都是可见的。由于本地路由规则是在网桥创建时设置的，任何到达eth0的目的地址为172.17.0.2的数据包都将被转发到网桥，然后网桥会将它发送到veth0。到目前为止听起来还不错。如果我们知道该主机上有一个位于172.17.0.2的pod，我们可以向路由器添加规则，将该地址的下一跳设置为10.100.0.2，它们将从那里转发到veth0。太好了。现在让我们看看另一个主机。</p><p id="6220" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">右边的主机也有eth0，地址为10.100.0.3，使用相同的默认网关10.100.0.1，再次连接到它的是docker0网桥，地址为172.17.0.1。嗯。这将是一个问题。现在，这个地址实际上可能与主机1上的另一个网桥不同。我在这里做了同样的处理，因为这是一种病态的最坏情况，如果你安装了docker并让它做它该做的事情，它很可能会以这种方式工作。但是，即使选择的网络不同，这也凸显了更基本的问题，即一个节点通常不知道为另一个节点上的网桥分配了什么私有地址空间，我们需要知道是否要向它发送数据包，并让它们到达正确的位置。显然需要某种结构。</p><p id="b8d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes以两种方式提供了这种结构。首先，它为每个节点上的网桥分配一个总的地址空间，然后根据网桥所在的节点，在该空间内分配网桥地址。其次，它将路由规则添加到10.100.0.1处的网关，告诉它应该如何路由去往每个网桥的分组，即该网桥可以通过哪个节点的eth0到达。这种虚拟网络接口、网桥和路由规则的组合通常被称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Overlay_network" rel="noopener ugc nofollow" target="_blank">覆盖网络</a>。当谈到kubernetes时，我通常将这种网络称为“pod网络”，因为它是一种覆盖网络，允许pod在任何节点上来回通信。这是上面这幅画，画的是kubernetes:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/23a16ea6b5a91b242ac819c94b37d1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyGbXt7kStLd85ZT4it3oQ.png"/></div></div></figure><p id="6913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得一提的是，我已经将桥的名称从“docker0”改为“cbr0”Kubernetes不使用标准的docker桥设备，事实上“cbr”是“自定义桥”的缩写。我不知道所有关于它的定制，但这是运行在kubernetes上的docker和默认安装之间的重要区别之一。另一件要注意的事情是，在这个例子中分配给网桥的地址空间是10.0.0.0/14。这是从我们在谷歌云中的一个临时集群中提取的，这是一个真实的例子。您的集群可能会被分配一个完全不同的范围。不幸的是，目前没有办法使用<code class="du ku kv kw kx b"><strong class="ih hj">kubectl</strong></code>实用程序来暴露这一点，但是在GCP上，你可以运行<code class="du ku kv kw kx b"><strong class="ih hj">gcloud container</strong> <strong class="ih hj">clusters describe &lt;cluster&gt;</strong></code>命令并寻找<code class="du ku kv kw kx b"><strong class="ih hj">clusterIpv4Cidr</strong></code>属性。</p><p id="df07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，你不需要考虑这个网络是如何运作的。当一个pod与另一个pod对话时，它通常通过服务的抽象来完成，这是一种软件定义的代理，这将是本系列下一篇文章的主题。但是pod网络地址会在日志中弹出，在调试时以及在某些情况下，您可能需要显式路由该网络。例如，从kubernetes pod发往10.0.0.0/8范围内任何地址的流量默认情况下都不会被NAT，因此，如果您与该范围内的另一个专用网络上的服务进行通信，您可能需要设置规则来将数据包路由回pod。希望这篇文章能帮助你采取正确的步骤来使这样的场景正常工作。</p><p id="611b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[更新]第2部分已发布:</p><p id="f392" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/@betz.mark/understanding-kubernetes-networking-services-f0cb48e4cc82">了解kubernetes网络:服务</a></p></div></div>    
</body>
</html>