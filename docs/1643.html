<html>
<head>
<title>Use Google Cloud user credentials when testing containers locally</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在本地测试容器时使用Google Cloud用户凭证</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/use-google-cloud-user-credentials-when-testing-containers-locally-acb57cd4e4da?source=collection_archive---------0-----------------------#2020-11-03">https://medium.com/google-cloud/use-google-cloud-user-credentials-when-testing-containers-locally-acb57cd4e4da?source=collection_archive---------0-----------------------#2020-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/506799c1bd6a46ccf1431f55c5a5ece5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47wJHG1s65kK3Nf_E2cIDg.png"/></div></div></figure><p id="9cd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">容器打包如今非常流行:它允许执行环境的完全定制，并且是语言不可知的。越来越多的应用程序使用它。<br/>现在，为了验证生产环境的行为，<strong class="is hj">开发人员需要测试容器</strong>，而不仅仅是单元测试的工作量。</p><p id="6f4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在某些情况下，<strong class="is hj">容器化的应用程序可能需要访问Google Cloud API </strong>，从而获得认证。当<strong class="is hj">部署在Google云服务上时，</strong> <a class="ae jo" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">元数据服务器</strong> </a> <strong class="is hj">可到达</strong>，并提供<a class="ae jo" href="https://cloud.google.com/docs/authentication/production" rel="noopener ugc nofollow" target="_blank">应用默认凭证(ADC) </a>。</p><blockquote class="jp"><p id="f804" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">如何通过ADC本地认证进行测试？</p></blockquote><p id="64fe" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">根据定义，<strong class="is hj">集装箱运行在一个隔离的环境中</strong>。这意味着容器内部不知道您的本地配置，因此您的凭证不会被加载</p><h1 id="8f45" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">服务帐户密钥文件解决方案</h1><p id="01a1" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">如果你用这个查询<code class="du lh li lj lk b">google cloud container test authentication</code>继续谷歌搜索，<strong class="is hj">第一个链接会把你带到</strong> <a class="ae jo" href="https://cloud.google.com/run/docs/testing/local" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">云运行本地测试教程</strong> </a>。<br/>这是一个很棒的教程，它解释了<strong class="is hj">如何在本地测试的容器运行时环境中加载凭证。</strong></p><p id="29eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ll">但是</em> </strong>建议使用的<strong class="is hj"> JSON文件是一个服务账户密钥文件</strong>。必须在本地生成和存储！</p><p id="bb96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这个解决方案不够安全</strong>，正如<a class="ae jo" rel="noopener" href="/google-cloud/the-2-limits-of-iam-service-on-google-cloud-7db213277d9c">我以前的文章</a>中所描述的，我想<strong class="is hj">避免服务帐户密钥文件</strong>。此外，是<a class="lm ln ge" href="https://medium.com/u/816233db7d13?source=post_page-----acb57cd4e4da--------------------------------" rel="noopener" target="_blank"> Eran Chetzroni </a>的<a class="ae jo" rel="noopener" href="/@chetz/thanks-guillaume-for-a-great-article-i-was-wondering-if-there-is-an-easy-way-to-develop-locally-85f2b2a93153">大问题</a>激发了这篇文章。</p><h1 id="6b79" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">本地环境和用户凭据</h1><p id="a12b" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">当你在你的本地环境下编写你的应用程序时，你<strong class="is hj">使用符合你偏好的语言的谷歌授权库</strong>。这个库可以<strong class="is hj">直接在你的代码</strong>中使用，也可以<strong class="is hj">在服务特定的库</strong>中作为依赖使用，比如云存储客户端库。</p><p id="f222" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Google auth library试图通过按此顺序执行检查来获得有效的凭证</strong></p><ul class=""><li id="6698" class="lo lp hi is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw bi translated"><strong class="is hj">看环境变量</strong>的<code class="du lh li lj lk b">GOOGLE_APPLICATION_CREDENTIALS</code>值。如果存在，使用它，否则…</li><li id="52f1" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated"><strong class="is hj">看元数据服务器</strong>(仅限Google云平台)。如果它返回正确的HTTP代码，就使用它，否则…</li><li id="eefb" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated"><strong class="is hj">查看“知名”位置</strong>是否存在用户凭证JSON文件</li></ul><p id="3963" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“众所周知”的地点是</p><ul class=""><li id="8732" class="lo lp hi is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw bi translated">在linux上:<code class="du lh li lj lk b">~/.config/gcloud/application_default_credentials.json</code></li><li id="b62a" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated">在Windows上:<code class="du lh li lj lk b">%appdata%/gcloud/application_default_credentials.json</code></li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="9f93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了<strong class="is hj">在您的本地环境</strong>上获得您的默认用户凭证，您必须使用<code class="du lh li lj lk b">gcloud</code> SDK。您有两个命令来获得身份验证:</p><ul class=""><li id="9cf5" class="lo lp hi is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw bi translated"><code class="du lh li lj lk b">gcloud auth login</code>获得所有后续<code class="du lh li lj lk b">gcloud</code>命令的认证</li><li id="ef60" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated"><code class="du lh li lj lk b">gcloud auth application-default login</code> <strong class="is hj">在本地“众所周知”的位置创建您的ADC。</strong></li></ul><p id="cda1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两个命令都触发OAuth2认证流，同步或异步，并在本地存储刷新令牌。</p><h1 id="f406" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">将您的用户凭据加载到您的容器中</h1><p id="c0ed" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">现在，我们有了拼图的两块</p><ul class=""><li id="628e" class="lo lp hi is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw bi translated"><strong class="is hj">JSON凭证文件</strong>。当然，不是服务帐户凭证，因此<a class="ae jo" rel="noopener" href="/google-cloud/the-2-limits-of-iam-service-on-google-cloud-7db213277d9c">2个IAM限制适用于此处</a></li><li id="cfb0" class="lo lp hi is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw bi translated">运行容器时，<strong class="is hj">命令加载一个JSON凭证。<em class="ll">我就不多此一举了，</em> <a class="ae jo" href="https://cloud.google.com/run/docs/testing/local" rel="noopener ugc nofollow" target="_blank"> <em class="ll">云运行教程解决方案</em> </a> <em class="ll">很棒！</em></strong></li></ul><p id="7c95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，您必须像这样运行您的本地<code class="du lh li lj lk b">docker run</code>命令</p><pre class="mj mk ml mm fd mn lk mo mp aw mq bi"><span id="ff15" class="mr kf hi lk b fi ms mt l mu mv">ADC=<!-- -->~/.config/gcloud/application_default_credentials.json \<br/>docker run \<br/>&lt;YOUR PARAMS&gt; \<br/>-e GOOGLE_APPLICATION_CREDENTIALS=/tmp/keys/FILE_NAME.json \<br/>-v ${ADC}:/tmp/keys/FILE_NAME.json:ro \<br/>&lt;IMAGE_URL&gt;</span></pre><h1 id="e4a5" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">避免服务帐户密钥文件</h1><p id="151b" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">同样，这里有一个简单的<strong class="is hj">解决方案来防止在本地环境中使用服务帐户密钥文件</strong>。</p><p id="7cf9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，即使这个解决方案很棒，<strong class="is hj">也不要太想在本地环境之外使用它</strong>。JSON文件，即您的<strong class="is hj">用户凭证JSON文件或服务账户密钥文件，是“机密”</strong>，需要作为机密处理。</p><p id="9a7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，<strong class="is hj">永远不要将这些JSON文件添加到你的容器</strong>中，尤其是如果它是公共的。容器只是一种打包模式，它不加密/隐藏任何东西！</p><p id="4dba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">不要在本地和您自己的环境之外的其他环境中使用您的用户凭据</strong>(如生产、试运行等)。API访问将在您授权下代表您执行(并按原样登录)。<br/>而且，因为它是用户凭证，所以您可能会被2 IAM限制阻止<a class="ae jo" rel="noopener" href="/google-cloud/the-2-limits-of-iam-service-on-google-cloud-7db213277d9c">。</a></p><p id="b4af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，一如既往的，<strong class="is hj">玩安全的时候，明智的思考</strong>！</p></div></div>    
</body>
</html>