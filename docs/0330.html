<html>
<head>
<title>How to speed up your BigQuery query 31x by replacing a self-join with two UNNEST() operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过用两个UNNEST()操作替换自连接来加快BigQuery查询31x的速度</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-speed-up-your-bigquery-query-31x-by-replacing-a-self-join-with-two-unnest-operations-eeb1a21c30ef?source=collection_archive---------0-----------------------#2017-07-09">https://medium.com/google-cloud/how-to-speed-up-your-bigquery-query-31x-by-replacing-a-self-join-with-two-unnest-operations-eeb1a21c30ef?source=collection_archive---------0-----------------------#2017-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0fa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">本故事最初发表于</em><a class="ae je" href="https://datancoff.ee/2017/07/how-to-speed-up-your-bigquery-query-31x-by-replacing-a-self-join-with-two-unnest-operations/" rel="noopener ugc nofollow" target="_blank"><em class="jd">datan coff . ee</em></a><em class="jd">。</em></p><p id="7248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在<a class="ae je" href="https://github.com/GoogleCloudPlatform/dataflow-opinion-analysis" rel="noopener ugc nofollow" target="_blank">意见分析项目</a>中的一个趋势计算<a class="ae je" href="https://github.com/GoogleCloudPlatform/dataflow-opinion-analysis/blob/master/src/main/java/com/google/cloud/dataflow/examples/opinionanalysis/StatsCalcPipelineUtils.java" rel="noopener ugc nofollow" target="_blank">查询</a>最近开始惹麻烦了。它将运行270秒，并因错误“查询超出了第1层的资源限制”而中断。需要第8级或更高级别。”将计费层更改为推荐的第8层确实有所帮助，但是查询仍然需要380秒才能完成。经过一些研究后，我发现我在部分查询中使用的自连接是罪魁祸首。看一下这个查询底部的连接条件(在CalcStatCombiTopics临时表中):</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="fd66" class="jo jp hi jk b fi jq jr l js jt">INSERT INTO opinions.stattopic (...)<br/>WITH <br/>p AS (<br/> SELECT 20170630 AS SnapshotDateId<br/>),<br/>CalcStatSentiments AS (<br/> SELECT p.SnapshotDateId, t.Tag, ... s.SentimentHash,...<br/> FROM opinions.document d, p<br/> INNER JOIN opinions.sentiment s ON s.DocumentHash = d.DocumentHash, UNNEST(s.Tags) AS t<br/> INNER JOIN opinions.webresource wrOrig ON wrOrig.DocumentHash = d.DocumentHash<br/> INNER JOIN opinions.webresource wrRepost ON wrRepost.DocumentCollectionId = d.DocumentCollectionId<br/> AND wrRepost.CollectionItemId = d.CollectionItemId<br/> WHERE<br/> d.PublicationDateId = p.SnapshotDateId AND s.SentimentTotalScore &gt; 0<br/>),<br/>CalcStatTopics AS (<br/>…<br/>),<br/>CalcStatCombiTopics AS (<br/> SELECT <br/> css1.SnapshotDateId, CONCAT(css1.Tag,’ &amp; ‘,css2.Tag) AS Topic, [css1.Tag,css2.Tag] AS Tags, true AS GoodAsTopic, 2 AS TagCount,<br/> ...<br/> FROM<br/> CalcStatSentiments css1, CalcStatSentiments css2<br/> WHERE<br/> css1.SentimentHash = css2.SentimentHash AND<br/> css1.Tag &lt; css2.Tag<br/> GROUP BY css1.SnapshotDateId, css1.Tag, css2.Tag<br/>),<br/>…</span></pre><p id="36d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，我有一个表“opinions . perspective ”,它有一个标识列SentimentHash、一个重复的字段标签和一堆其他列。Tags列包含一个文本标记数组，我使用意见分析<a class="ae je" href="https://cloud.google.com/dataflow" rel="noopener ugc nofollow" target="_blank">云数据流</a> <a class="ae je" href="https://github.com/GoogleCloudPlatform/dataflow-opinion-analysis/blob/master/src/main/java/com/google/cloud/dataflow/examples/opinionanalysis/IndexerPipeline.java" rel="noopener ugc nofollow" target="_blank"> IndexerPipeline </a>从文本中提取这些标记。在BigQuery出现之前，我会使用一个单独的表来存储标签，并通过identity列SentimentHash将其链接到主情感表。然而，在BigQuery中，对于重复的字段，这要容易得多。</p><p id="048e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我计算趋势时，我为标签的组合建立频率统计(例如，有多少新闻文章是关于“气候变化”和“G-20”的)。为此，我展平了Tags字段，并创建了一个临时表CalcStatSentiments，其中包含每个标记的单独记录，以及SentimentHash和实际标记等字段。然后，我对CalcStatSentiments表进行自连接，以构建我所谓的“主题”(在CalcStatCombiTopics临时表中)。</p><p id="fe37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实证明，自连接不利于(您的健康)查询的性能，正如这篇<a class="ae je" href="http://www.lunametrics.com/blog/2016/05/12/self-joins-windowing-user-defined-functions-bigquery/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中所阐述的。它建议用窗口来代替自连接。我考虑过这样做，但实际上我需要以标记的排列而不是聚集统计来结束，对于聚集统计来说，窗口会工作得很好，所以我想出了另一种技术。</p><p id="2d31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">宣布谢尔盖的自加入淘汰技术</strong></p><p id="644a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不再仅仅展平我的Tags字段一次(在我的查询的CalcStatSentiments部分)，<strong class="ih hj"> <em class="jd">我现在第一次展平它，在结果集中携带Tags数组，然后第二次展平它以模拟交叉连接操作。</em> </strong></p><p id="2519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是它在新查询中的样子:</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="0d1c" class="jo jp hi jk b fi jq jr l js jt">WITH <br/>p AS (<br/> SELECT 20170630 AS SnapshotDateId<br/>),<br/>SentimentTags AS (<br/>  SELECT p.SnapshotDateId, s.SentimentHash, t.Tag, t.GoodAsTopic, s.Tags AS Tags<br/>  FROM p, opinions.sentiment s, UNNEST(s.Tags) AS t<br/>  WHERE<br/>    s.DocumentDateId = p.SnapshotDateId AND s.SentimentTotalScore &gt; 0<br/>),<br/>SentimentTagCombos AS (<br/>  SELECT st.SnapshotDateId, st.SentimentHash, st.Tag AS Tag1, stt.Tag AS Tag2 <br/>  FROM SentimentTags st, UNNEST(st.Tags) stt<br/>  WHERE st.Tag &lt; stt.Tag<br/>),<br/>...</span></pre><p id="5caa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不等式过滤器` WHERE st.Tag &lt; stt.Tag` ensures that I do not get duplicates in my tag combos. It works the same way as the inequality filter in the original version of my query.</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="414c" class="jo jp hi jk b fi jq jr l js jt">WHERE<br/> css1.SentimentHash = css2.SentimentHash AND<br/> css1.Tag &lt; css2.Tag</span></pre><p id="ce87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Once I calculated my Tag1 &amp; Tag2 combinations, I join my result set via the SentimentHash record ID to my main dataset and conclude all the calculations.</p><p id="3d52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">The result: instead of a query that takes 380 seconds to complete in billing tier 8, my modified query runs in 12 seconds in billing tier 1.</p><p id="647c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Conclusion:</p><p id="428b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Using self-joins = BAD. <br/>替换为dual UNNEST() =无价！(或者类似的东西)</p><p id="3680" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想比较语法，下面是一些查询。</p><p id="fa22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的性能优化查询:</p><figure class="jf jg jh ji fd ju"><div class="bz dy l di"><div class="jv jw l"/></div></figure><p id="66fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原始查询:</p><figure class="jf jg jh ji fd ju"><div class="bz dy l di"><div class="jv jw l"/></div></figure></div></div>    
</body>
</html>