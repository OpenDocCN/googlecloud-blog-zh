<html>
<head>
<title>App Engine waterfall trace : the phantom spans</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">App Engine瀑布追踪:幻影跨越</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/app-engine-waterfall-trace-the-phantom-spans-bf04c11863ea?source=collection_archive---------4-----------------------#2018-06-18">https://medium.com/google-cloud/app-engine-waterfall-trace-the-phantom-spans-bf04c11863ea?source=collection_archive---------4-----------------------#2018-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6c98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我❤瀑布潜伏期图表！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a62e8967bc4e7b0d1888b897154c806c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsjEQ9rv0wvU6qYlbt3hrQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">处理1个web请求时后端API调用延迟</figcaption></figure><p id="0b0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我所说的“瀑布”是一个柱状图，就像这个草图一样，其中X轴是经过的时间，每个跨度是一个在特定时间开始的活动，并且有一个持续时间。瀑布提供了对复合流程性能的即时洞察:时间实际花在了哪里？</p><p id="fb95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我们将看看对运行在<a class="ae jt" href="https://cloud.google.com/appengine/docs/standard/" rel="noopener ugc nofollow" target="_blank"> Google App Engine Standard </a>上的后端的web请求的服务器端延迟。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/554c0cea77c2416b351f6707278c3de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*PJrR-fX7oNr47U1nczPgaA.png"/></div></figure><p id="bd85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为2023年的<strong class="ih hj">秃鹰观察比赛</strong>构建一个简单的动态首页:</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://condors-fanclub.appspot.com/"><div class="er es jv"><img src="../Images/6aa3efa4ad54067621267e185f967f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f74Dua6l0SIu69uY8pKmTw.png"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx translated">该网站部署在应用引擎标准上</figcaption></figure><p id="f828" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从服务器的角度来看，该页面包含4个静态元素:</p><ul class=""><li id="aee2" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">带有标题的HTML文档的框架</li><li id="8aa7" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">一只秃鹰的照片</li><li id="8e3d" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">CSS文件</li><li id="1fa5" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">一个图标；</li></ul><p id="7f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和3个动态元素:</p><ul class=""><li id="9af6" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">“秃鹰”的定义，通过对维基百科服务<a class="ae jt" href="https://en.wikipedia.org/api/rest_v1/page/summary/Condor" rel="noopener ugc nofollow" target="_blank">的REST调用</a>来检索</li><li id="b8b1" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">竞赛的当前获胜者，以及他们发现的细节，从竞赛数据库中检索:一个<a class="ae jt" href="https://cloud.google.com/sql/docs/" rel="noopener ugc nofollow" target="_blank">云SQL </a>实例(MySQL风格)</li><li id="b6e8" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">页面视图计数器，我们通过编程从<a class="ae jt" href="https://cloud.google.com/datastore/docs/concepts/overview" rel="noopener ugc nofollow" target="_blank">数据存储</a>中读取。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/80092e7351845be6196b18ae08311c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qFvOFx2FiqfBuUn7zFQ7A.png"/></div></div></figure><p id="489c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，所有动态元素的数据都被取出<em class="kl">服务器端</em>；然后后端使用一个模板来生成要发送到浏览器的HTML文档。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es km"><img src="../Images/8e451882be9201de5367b249a66f250d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FU65UurNjS8gLTGxWd79bg.png"/></div></div></figure><p id="c9a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2023年的页面视图非常早，只收集了几个观察结果，迄今为止获奖的观察结果是7只秃鹰！这里只详细介绍了正在进行的高分的首页渲染，没有介绍数据是如何被参赛者馈入数据库的(那是另外一个流程)。</p><p id="45b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是<a class="ae jt" href="https://github.com/Deleplace/samples/tree/master/condors" rel="noopener ugc nofollow" target="_blank">app的源代码</a>。我选择了Go运行时，但是这在这里并不重要，因为请求处理的总延迟<strong class="ih hj">是由API调用的延迟</strong>决定的。</p><p id="1b3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相同的见解适用于所有App Engine标准运行时，因此请随意选择您最喜欢的一个:</p><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://cloud.google.com/appengine/docs/standard/go/"><div class="er es kn"><img src="../Images/6d53cec51b70f99cb78caf380f53e0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*RvMkbOfz-0BmVrOnlPjnWQ.png"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx translated">去</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://cloud.google.com/appengine/docs/standard/java/"><div class="er es ko"><img src="../Images/eae187753b2ee976ad1cf5bff72b5bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:146/format:webp/1*LeS_MeDIY_VeK25hfmvNOQ.png"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx translated">Java 语言(一种计算机语言，尤用于创建网站)</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://cloud.google.com/appengine/docs/standard/php/"><div class="er es kp"><img src="../Images/3839f7dc79febbc065e259267608dd07.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*12YShm0d5007DtagBF95yw.png"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx translated">服务器端编程语言（Professional Hypertext Preprocessor的缩写）</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://cloud.google.com/appengine/docs/standard/python/"><div class="er es kq"><img src="../Images/7c610e33d2203a5d4a6052d04ac0ba77.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*JboyHjUjNwoQCnqhUnNLfQ.png"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx translated">计算机编程语言</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://www.youtube.com/watch?v=C_9lpcfDCHs"><div class="er es kr"><img src="../Images/94a5befba5702e11fbc7a406f53402d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/1*-AsknbIKGVsFllPZr8kNGg.gif"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx translated">..而且现在还<a class="ae jt" href="https://cloud.google.com/appengine/docs/standard/nodejs/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>！！</figcaption></figure><p id="a145" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不管选择哪种语言，这里是瀑布在<a class="ae jt" href="https://cloud.google.com/trace/" rel="noopener ugc nofollow" target="_blank"> Stackdriver Trace </a>中的样子。要在自己的项目中寻找踪迹，打开云平台web控制台，进入<a class="ae jt" href="https://console.cloud.google.com/logs/viewer" rel="noopener ugc nofollow" target="_blank">日志&gt;日志</a>，点击请求的延迟，然后<code class="du ks kt ku kv b">View trace</code>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/36818ae0a8328c28cd99327541779f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9ajv3eLBh83dIDWe2Y9ag.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">单击以缩放</figcaption></figure><p id="3eae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅跟踪API调用(蓝色范围)。这里不跟踪GAE实例对传入请求的内部处理(即所有不是API调用的代码)，只跟踪总持续时间。</p><p id="f293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在早期版本的应用程序中可以观察到这种痕迹(如上),其中API调用是按顺序执行的。但事实证明，我们可以对此进行优化:由于3条信息(<em class="kl">定义</em>、<em class="kl">获胜者</em>、<em class="kl">浏览量</em>)彼此独立，我们可以同时获取它们<strong class="ih hj"/>(参见<a class="ae jt" href="https://github.com/Deleplace/samples/commit/f7afb6d962ca097ccb1e0ba5fd85c96e74b13963" rel="noopener ugc nofollow" target="_blank">提交</a>)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/433723315152cd55f5833a70a755f24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wa1RTkbKoe1oHU0JAT_tZA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">并发API调用减少了总延迟</figcaption></figure><p id="5392" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇，这是3倍的加速！该请求的处理时间是246毫秒，而不是773毫秒。你可以看到一些蓝色跨度的重叠。</p><p id="eff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这仅包括服务器时间，不包括用户和Google基础设施之间的网络时间。您的里程数可能会有所不同:处理时间有时会明显缩短或延长，原因并不明显，即使这不是一个加载请求(<a class="ae jt" rel="noopener" href="/google-cloud/understanding-and-profiling-app-engine-cold-boot-time-908431aa971d">冷启动</a>)。</p><p id="6814" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两天后，参赛者报告了大量观察结果，并创造了一项新的记录:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/eb214d497c9a953232a94e541562f733.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*I7u2Wp0Ow6AkQRwmEEJgHw.png"/></div></figure><p id="bc8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我要等<strong class="ih hj"> 3秒</strong>，那有点慢。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kz"><img src="../Images/95342cb358b516bca05f4577f76ed814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*C17oRE2XkV49a9uBP3rjsg.png"/></div></figure><p id="a77f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到1月底，记录甚至更高:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/12563a2a6d1fde16735cda1fc0042506.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*sMSaVq1dtxEJk4s7W8roBQ.png"/></div></figure><p id="74a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是为了查看页面，我们等待了令人望而却步的<strong class="ih hj"> 22秒</strong>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lb"><img src="../Images/8b52312eecb08d43b46e221f415bd794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pqii6K6GhK4DSthyAO1bbA.png"/></div></div></figure><p id="40e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">三月，页面宕机:<strong class="ih hj">服务器超时</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lc"><img src="../Images/2911a1e95cdaf75915449e251a66718e.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*BWBQVcXYl7Fvt6RxuViQ_A.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">哎哟:页面破损</figcaption></figure><p id="5282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是怎么回事？在最近的瀑布中，跨度持续时间显然与巨大的总延迟相比相形见绌，总延迟仍然无法解释。</p><p id="bd79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您仔细查看蓝色区域，您会发现对Wikipedia的urlfetch调用，以及一些自动读写页面视图计数器的数据存储调用(在一个事务中)。但奇怪的是，<strong class="ih hj">没有提到云SQL查询</strong>。这实际上是有效的<a class="ae jt" href="https://cloud.google.com/trace/docs/overview#how_does_stackdriver_trace_work" rel="noopener ugc nofollow" target="_blank">，如文档</a>所示:</p><blockquote class="ld le lf"><p id="0f84" class="if ig kl ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">Stackdriver Trace适用于所有App Engine APIs，但Cloud SQL除外。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><a href="https://cloud.google.com/trace/docs/overview#how_does_stackdriver_trace_work"><div class="er es lj"><img src="../Images/ad223cafe4d2329642db3bb5a09afa74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*6quvEshRPFSPSJ5wpVF0rQ.png"/></div></a><figcaption class="jp jq et er es jr js bd b be z dx translated">Stackdriver Trace <a class="ae jt" href="https://cloud.google.com/trace/docs/overview#how_does_stackdriver_trace_work" rel="noopener ugc nofollow" target="_blank">文档</a></figcaption></figure><p id="cf7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在每次数据检索之前和之后记录一条消息，我们很快就能发现罪魁祸首(例如1月3日和1月29日的瀑布):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/169f9b1ef87ad00a127cc1798aa3f3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-xcWZhni0mCppJsKKzwuA.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/8752a39e0bdcfb64ec2eb09cfce3e79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipI6tk7vd4vxf4pk-GSZmQ.png"/></div></div></figure><p id="fe11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从“在云SQL中查询观察获胜者”开始到结束所用的时间几乎占总时间的100%。</p><p id="2144" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录自定义消息既简单又有用。瀑布浏览器显示它们，这很好。</p><p id="e142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们检查了数据库访问层的源代码，结果发现我们做了过多的SQL查询:</p><ul class=""><li id="6d75" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated"><code class="du ks kt ku kv b">SELECT id FROM condors.observation WHERE YEAR(date)=?</code></li><li id="679a" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">对于每个id，<br/>、<code class="du ks kt ku kv b">SELECT id, date, region, user, nbcondors<br/> FROM condors.observation<br/> WHERE id=?</code></li></ul><p id="2899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，如果我们在数据库中有<strong class="ih hj"> <em class="kl"> N </em> </strong>个观察值，我们最终会执行(1+ <strong class="ih hj"> <em class="kl"> N </em> </strong>)个SQL查询。每个查询都会产生(相当高的)开销，以便与数据库进行网络往返，并让数据库处理查询并返回结果行。在应用程序代码中，循环是连续的。</p><p id="aad7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据库包含100个观察值时(1月初)，页面很慢。</p><p id="0ef9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据库包含3000个观察值时(三月份)，服务器放弃。</p><p id="9baa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，我们可以而且应该做得更好。不要嘲笑这个做作的，幼稚的例子！使用ORM或以编程方式构建的SQL查询的真实、复杂的后端确实存在这个问题。一般来说，这是很难解决的问题(一种尺寸不能适合所有人)，甚至一开始就不容易识别。请记住，SQL调用不会显示在Stackdriver跟踪查看器中。</p><p id="8303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有3种不同的策略来解决懒散问题:</p><ul class=""><li id="646a" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">也许同时启动SQL查询？好吧，这不会改变我们正在制造成千上万个这样的产品的事实，这会导致巨大的累积开销。不是一个好的选择。</li><li id="b11f" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">在一个SQL查询中检索2023年的所有观测数据？这最终消除了瓶颈，这很酷。但是我们仍然从数据库加载数千行，这是多余的，可能会导致内存占用问题和过大的网络负载。</li><li id="d282" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">最好的解决方案是从应用程序卸载赢家选择代码到数据库引擎:<br/> <code class="du ks kt ku kv b">SELECT id, date, region, user, nbcondors<br/> FROM condors.observation<br/> ORDER BY nbcondors DESC, date ASC LIMIT 1</code></li></ul><p id="9596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据经验，查询的开销如此之大，而数据库引擎又如此优化，因此为了最大限度地减少查询数量(非常重要)和返回的行数，将繁重的工作交给数据库通常是个好主意。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="ecfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果stack driver Trace<strong class="ih hj"><em class="kl"/></strong>支持云SQL调用开箱即用就好了，但目前还不支持(截至2018年6月)。</p><p id="b84a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一种变通方法，人们希望能够以编程方式插入定制的跨度，但是这部分依赖于所选择的运行时/语言和可用的库。这个区域有很多粗糙的边缘和阿尔法工具！有<a class="ae jt" href="https://cloud.google.com/trace/docs/client-libraries" rel="noopener ugc nofollow" target="_blank">客户端库</a>，但不是App Engine标准。如果用Java，<a class="ae jt" href="https://stackoverflow.com/questions/40002975/is-there-any-way-to-trace-cloud-sql-calls-in-app-engine" rel="noopener ugc nofollow" target="_blank">试试这个</a>。否则，看看<a class="ae jt" href="https://cloud.google.com/trace/docs/reference/v1/rest/" rel="noopener ugc nofollow" target="_blank"> REST API </a>。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="aaf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速响应后端的外卖！</p><ul class=""><li id="8a8a" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">节俭，响应时间很重要。不要拿不必要的东西。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/9f7305e89efb89a2bd2de5069ec0be13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWsdvkSCtkhqwSLQO11nSA.png"/></div></div></figure><ul class=""><li id="03a1" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">瀑布是一个非常棒的可视化工具</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/f8b1fe1f65a0fc8e36700a1c417cc931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*AGWul6imgtTkc4BMUyrRHQ.png"/></div></figure><ul class=""><li id="9772" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">如有疑问，测量并记录。瓶颈往往不是你的直觉所预期的！</li><li id="ea29" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">否则，测量并记录。瓶颈往往不是你的直觉所预期的！</li><li id="8bf4" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">尽量减少API调用的数量:DB请求、外部HTTP等。</li><li id="45a2" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">不太重要的是，尽量减少请求的负载(例如，只选择您需要的行和列)。</li><li id="6901" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">有时检索太多的数据是一种很好的折衷，但是需要较少的API调用。</li><li id="5990" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">使用<a class="ae jt" href="https://cloud.google.com/appengine/docs/standard/python/memcache/" rel="noopener ugc nofollow" target="_blank"> Memcache </a>！它比其他服务更快。</li><li id="452f" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">尽可能批处理API请求。对20个对象的1个请求比对1个对象的20个请求要高效得多。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/0d7472f5c67f96b7fc1734504e06b011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*AH2du-NcjRXfi6BBRUjthQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">批处理大大减少了延迟</figcaption></figure><ul class=""><li id="814a" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">考虑并发启动几个独立的API调用，而不是顺序启动。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/be12988005e1ad52af3a3e8782961559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wf68nFYbi8CzPO5HPD1FxA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">并发可以减少延迟</figcaption></figure><ul class=""><li id="91ef" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">考虑将工作(使用<a class="ae jt" href="https://cloud.google.com/appengine/docs/standard/go/taskqueue/" rel="noopener ugc nofollow" target="_blank">任务队列</a>)推迟到响应发送给最终用户之后执行。如果这封通知邮件能为您的表单处理节省500毫秒的响应时间，那么它可以等一等。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/4c104c840fc918b5d340cfcf2a9a8cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*D24yimp6HR-0NxdDoKFDtg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">推迟对HTTP响应不重要的事情</figcaption></figure><ul class=""><li id="dd0c" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">不要试图流响应:这在GAE标准上是不可能的。完整的响应被缓冲，然后发送到客户端。</li><li id="6598" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">了解系统跟踪了什么，没有跟踪什么:外部API调用、网络I/O、文件系统、内存分配、垃圾收集、锁……最佳粒度是指大部分延迟可以用我们可以理解的较小跨度来解释的粒度。可观察性信息越多通常越好。</li></ul></div></div>    
</body>
</html>