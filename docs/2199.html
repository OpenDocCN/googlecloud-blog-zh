<html>
<head>
<title>Setting up Config Connector with Terraform &amp; Helm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform &amp; Helm设置配置连接器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/setting-up-config-connector-with-terraform-helm-8ce2f45f48a4?source=collection_archive---------2-----------------------#2022-05-26">https://medium.com/google-cloud/setting-up-config-connector-with-terraform-helm-8ce2f45f48a4?source=collection_archive---------2-----------------------#2022-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ba9fe9f526ecbbbf0806c335f9d7b066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VKtfiUYjCdIceJP0.png"/></div></div></figure><div class=""/><p id="acdf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为代码的基础设施自首次采用以来已经走过了漫长的道路。多个云提供商和oss项目已经发布了他们自己的工具，以便从点击式方法转变为声明式方法来设置基础设施和应用程序，而Terraform在这场竞赛中处于领先地位。</p><p id="b562" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在处理安全性、最低权限的分配和单独服务帐户的创建时，为了在Git-repo中集中控制服务帐户和权限，您必须将帐户的电子邮件作为Terraform输出传递给部署脚本。这使得它变得不必要的困难和复杂，并且您可能会最终交叉引用跨项目的资源。</p><p id="0b91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果您可以创建必要的服务帐户，分配权限，并对其进行注释以无缝处理工作负载身份，并将其作为一个Helm版本进行部署，情况会怎样？嗯——向配置连接器问好。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="bf8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如谷歌所说，Config Connector是Kubernetes的一个插件，允许你通过Kubernetes管理谷歌云资源。它可以很容易地为任何满足最低要求的GKE集群启用。在本文中，我们将利用<strong class="is hu">cluster</strong><strong class="is hu">scoped</strong>config连接器，这基本上意味着我们只有一个服务帐户来提供所有名称空间中的所有GCP资源。还有一种可能性是使用一个<strong class="is hu">名称空间作用域的</strong>连接器，利用项目分离的力量来实现更好的IAM和资源管理(如果我应该就此发表一篇文章，请告诉我，我很乐意这样做)。</p><p id="09d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了启用集群的配置连接器，您必须利用<code class="du jv jw jx jy b">google-beta</code>提供程序，声明<code class="du jv jw jx jy b">addons_config</code>块，并将<code class="du jv jw jx jy b">config_connector_config</code>设置为enabled:</p><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="d4f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在准备设置服务帐户，该帐户将运行配置连接器声明的资源的供应。该帐户将需要项目中的IAM权限以及一个特定的IAM绑定，以允许config connector模拟GSA:</p><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="8c8d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经有了一个集群和一个服务帐户，我们需要指示集群内部的config connector operator使用那个特定的服务帐户进行配置。如果您使用我创建的GitHub repo，您必须应用两次基础设施——首先创建集群，然后立即创建剩余的资源。这里，我们通过使用<code class="du jv jw jx jy b">yamldecode</code>和<code class="du jv jw jx jy b">templatefile</code>函数来应用kubernetes清单，以便将清单保存为yaml，并将服务帐户变量与服务帐户的实际电子邮件地址进行交换:</p><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="75af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过运行<code class="du jv jw jx jy b">kubectl get crds</code>和<code class="du jv jw jx jy b">kubectl get configconnectors</code>检查已安装的CRD来验证安装:</p><pre class="jz ka kb kc fd kf jy kg kh aw ki bi"><span id="3951" class="kj kk ht jy b fi kl km l kn ko">&gt; k get configconnectors<br/>NAME                                         AGE     HEALTHY<br/>configconnector.core.cnrm.cloud.google.com   3m50s   true</span></pre><p id="0aa4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还会注意到config connector控制器已经启动并正在运行。这是确保配置连接器在集群中正常运行所需的所有资源都存在的工作负载。通过研究<code class="du jv jw jx jy b">configconnector-operator-system</code>名称空间中<code class="du jv jw jx jy b">configconnector-operator</code> StatefulSet的日志，您可以很容易地看到它执行了什么安装:</p><pre class="jz ka kb kc fd kf jy kg kh aw ki bi"><span id="74c1" class="kj kk ht jy b fi kl km l kn ko">&gt; kubectl logs configconnector-operator-0 -n <!-- -->configconnector-operator-system</span></pre><p id="5f19" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运营商负责创建<code class="du jv jw jx jy b">cnrm-system</code>命名空间，这是负责供应GCP资源的<code class="du jv jw jx jy b">cnrm-controller-manager</code>的家。如果你仔细看看控制器管理器的规范，你会注意到它运行的是<code class="du jv jw jx jy b">cnrm-controller-manager</code>服务帐户，这个帐户是用我们用Terraform创建的GCP服务帐户注释的。以下pod应该在<code class="du jv jw jx jy b">cnrm-system</code>名称空间中启动并运行:</p><pre class="jz ka kb kc fd kf jy kg kh aw ki bi"><span id="530f" class="kj kk ht jy b fi kl km l kn ko">&gt; kubectl get po -n cnrm-system<br/>NAME                                            READY   STATUS    <br/>cnrm-controller-manager-0                       2/2     Running<br/>cnrm-deletiondefender-0                         1/1     Running<br/>cnrm-resource-stats-recorder-6dfc78996c-szf25   2/2     Running<br/>cnrm-webhook-manager-778cdd84cb-ncs5q           1/1     Running<br/>cnrm-webhook-manager-778cdd84cb-x4xpk           1/1     Running</span></pre></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="0c03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们的配置连接器已经启动并运行，所以我们可以部署这个奇妙的应用程序，从给定的桶中获取文件内容。为了简单起见，它监听“/”端点，并根据为部署设置的<code class="du jv jw jx jy b">BUCKET_NAME</code>和<code class="du jv jw jx jy b">FILE_NAME</code>环境变量读取文件内容。我们将从舵图的<code class="du jv jw jx jy b">values.yaml</code>文件中传递这些:</p><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="fbd4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还将要求Helm创建和注释服务帐户，并将服务公开为负载平衡器，以便我们可以从集群外部访问它:</p><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="eb99" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该图表还将提供3种谷歌云平台资源:</p><ul class=""><li id="524c" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hu">利用工作负载标识的GCP服务帐户</strong></li></ul><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><ul class=""><li id="f733" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hu"> IAM政策</strong>授予我们的Kubernetes服务帐户作为我们的GCP服务帐户的用户的权限— <code class="du jv jw jx jy b">roles/iam.workloadIdentityUser</code></li></ul><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><ul class=""><li id="20e6" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hu"> IAM策略</strong>授予我们的GCP服务帐户读取我们之前创建的存储桶中的对象的权限— <code class="du jv jw jx jy b">roles/storage.objectViewer</code></li></ul><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="61e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图表将利用<code class="du jv jw jx jy b">helm</code>提供者安装，以<em class="ky">项目id </em>和<em class="ky">桶名</em>作为模板变量；</p><figure class="jz ka kb kc fd hk"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="e892" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装完成后，您应该会注意到集群中的<code class="du jv jw jx jy b">file-reader</code>名称空间包含一个副本集、部署、服务帐户和一个公开外部公共IP地址的服务。除此之外，图表将部署我们的GCP资源。如果您已经正确地设置了一切，它们将最终处于<strong class="is hu">就绪</strong>状态，这意味着控制器管理器能够成功地供应GCP资源:</p><pre class="jz ka kb kc fd kf jy kg kh aw ki bi"><span id="4b97" class="kj kk ht jy b fi kl km l kn ko">❯ k get IAMServiceAccounts,IAMPolicyMembers<br/>NAME                                                      <br/>iamserviceaccount.iam.cnrm.cloud.google.com/file-reader</span><span id="313b" class="kj kk ht jy b fi kz km l kn ko">NAME                                                                     <br/>iampolicymember.iam.cnrm.cloud.google.com/file-reader-app-chart-bucket<br/>iampolicymember.iam.cnrm.cloud.google.com/file-reader-app-chart-wi</span></pre><p id="ceae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以测试我们的应用程序，以验证我们可以访问这个存储桶:</p><pre class="jz ka kb kc fd kf jy kg kh aw ki bi"><span id="c30b" class="kj kk ht jy b fi kl km l kn ko">&gt; curl &lt;YOUR_EXTERNAL_IP&gt;<br/>"Two peanuts were walking down the street. One was a salted\n"</span></pre><p id="73bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在控制台中导航时，您应该注意到新的服务帐户<code class="du jv jw jx jy b">file-reader@&lt;YOUR_PROJECT_ID&gt;.iam.gserviceaccount.com</code>，它没有项目范围的权限，被允许访问<code class="du jv jw jx jy b">config-connector-&lt;YOUR_RANDOM_STRING&gt;</code>桶的对象，并且<code class="du jv jw jx jy b">&lt;YOUR_PROJECT_ID&gt;.svc.id.goog[file-reader/file-reader]</code>是该服务帐户的工作负载身份用户。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="4bfa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我相信Config Connector是公共基础设施声明和特定于应用程序的组件之间的一座神奇而强大的桥梁。在不久的将来，我一定会在生产中尝试一下。</p><p id="4e4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请务必查看包含所有源代码的GitHub repo:</p><div class="hh hi ez fb hj la"><a href="https://github.com/adriantr/config-connector" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hu fi z dy lf ea eb lg ed ef hs bi translated">GitHub-Adrian tr/Config-connector:带头盔和地形的配置连接器演示</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">github.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo hp la"/></div></div></a></div></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="3dea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有兴趣了解更多关于我们Strise.ai如何从谷歌云平台中获得乐趣以及我们的环境看起来如何？停下来喝杯咖啡或者在LinkedIn上联系我们！</p><p id="ed7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的——我们正在<a class="ae lp" href="https://www.strise.ai/about-us/careers" rel="noopener ugc nofollow" target="_blank">招聘</a>。</p></div></div>    
</body>
</html>