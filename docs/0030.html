<html>
<head>
<title>Accessing BigQuery from App Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从应用程序引擎访问BigQuery</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/accessing-bigquery-from-app-engine-d01823de81ee?source=collection_archive---------0-----------------------#2015-10-07">https://medium.com/google-cloud/accessing-bigquery-from-app-engine-d01823de81ee?source=collection_archive---------0-----------------------#2015-10-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7d9d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用OAuth 2.0服务帐户验证API调用</h2></div><p id="a51f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一位谷歌云平台客户今天问我如何列出谷歌应用引擎应用程序中所有可用的BigQuery数据集。</p><p id="71f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不知道什么是BigQuery或App Engine，这篇文章可能不适合你…现在还不适合！相反，你应该看看<a class="ae jt" href="https://cloud.google.com/bigquery/what-is-bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>和<a class="ae jt" href="https://cloud.google.com/appengine/docs" rel="noopener ugc nofollow" target="_blank"> App Engine </a>的文档。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/1d6d1211229d7c0fe47c03f1446c1674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSNMEV3dqzss2wzlwWKPDw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">BigQuery和App Engine是我最喜欢的谷歌云平台的两个产品。</figcaption></figure><p id="8c1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个问题的解决方案很简单，但是我认为有足够多的移动内容，比一篇博文所需要的要多。让我们假设列表将作为请求处理的一部分来显示，如下所示:</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="4f9b" class="kp kq hi kl b fi kr ks l kt ku">func <strong class="kl hj">handle</strong>(w http.ResponseWriter, r *http.Request) {<br/>    // create a new App Engine context from the request.<br/>    c := appengine.<strong class="kl hj">NewContext</strong>(r)</span><span id="a8aa" class="kp kq hi kl b fi kv ks l kt ku">    // obtain the list of dataset names.<br/>    <strong class="kl hj">names</strong>, err := <strong class="kl hj">datasets</strong>(c)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }</span><span id="1e3c" class="kp kq hi kl b fi kv ks l kt ku">    w.Header().Set("Content-Type", "text")</span><span id="3699" class="kp kq hi kl b fi kv ks l kt ku">    // print it to the output.<br/>    if len(names) == 0 {<br/>        fmt.Fprintf(w, "no datasets visible")<br/>    } else {<br/>        fmt.Fprintf(w, "datasets:\n\t" + strings.Join(<strong class="kl hj">names,</strong> "\n"))<br/>    }</span><span id="6809" class="kp kq hi kl b fi kv ks l kt ku">}</span></pre><p id="f650" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当一个新的HTTP请求到来时，上面定义的处理程序就会被执行。它将创建一个新的App Engine上下文，然后由<em class="kw">数据集</em>函数使用，返回一个列表，其中包含App Engine应用程序可见的所有BigQuery数据集的名称。最后，列表将被打印到输出端<em class="kw"> w </em>。</p><p id="2771" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了注册处理程序，以便它在每个HTTP请求上执行，我们添加了一个<em class="kw"> init </em> func。</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="6694" class="kp kq hi kl b fi kr ks l kt ku">func <strong class="kl hj">init</strong>() {</span><span id="d916" class="kp kq hi kl b fi kv ks l kt ku">    // all requests are handled by handler.<br/>    http.HandleFunc(“/”, <strong class="kl hj">handle</strong>)</span><span id="841d" class="kp kq hi kl b fi kv ks l kt ku">}</span></pre><p id="0112" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在到了有趣的部分，我们如何实现<em class="kw">数据集</em>函数？</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="276c" class="kp kq hi kl b fi kr ks l kt ku">func datasets(c context.Context) ([]string, error) {</span><span id="8eb7" class="kp kq hi kl b fi kv ks l kt ku">    // some awesome code ...</span><span id="9eb4" class="kp kq hi kl b fi kv ks l kt ku">}</span></pre><p id="b04f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们分三部分实现该函数的主体:</p><h2 id="585f" class="kp kq hi bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated"><strong class="ak"> 1。创建经过身份验证的HTTP客户端</strong></h2><p id="0d83" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">给定一个上下文(<a class="ae jt" href="https://godoc.org/golang.org/x/net/context#Context" rel="noopener ugc nofollow" target="_blank"> <em class="kw">)语境。Context </em> </a>)命名为<em class="kw"> c </em>我们可以使用这段代码创建一个经过身份验证的客户端。</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="ffcb" class="kp kq hi kl b fi kr ks l kt ku">// create a new HTTP client.<br/>client := &amp;http.Client{<br/>    Transport: &amp;oauth2.Transport{<br/>        Source: <strong class="kl hj">google.AppEngineTokenSource</strong>(c,<br/>            bigquery.BigqueryScope),<br/>        Base: &amp;<strong class="kl hj">urlfetch.Transport</strong>{Context: c},<br/>    },<br/>}</span></pre><p id="3c96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Go中，HTTP客户端使用传输进行通信，传输使用…传输！一路都是运输机！但是什么是HTTP传输呢？</p><p id="ee4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">HTTP客户端中的传输字段属于类型<a class="ae jt" href="http://golang.org/pkg/net/http#RoundTripper" rel="noopener ugc nofollow" target="_blank"> <em class="kw">往返者</em> </a>:</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="d11a" class="kp kq hi kl b fi kr ks l kt ku">type RoundTripper interface {<br/>        RoundTrip(*<a class="ae jt" href="https://golang.org/pkg/net/http/#Request" rel="noopener ugc nofollow" target="_blank">Request</a>) (*<a class="ae jt" href="https://golang.org/pkg/net/http/#Response" rel="noopener ugc nofollow" target="_blank">Response</a>, <a class="ae jt" href="https://golang.org/pkg/builtin/#error" rel="noopener ugc nofollow" target="_blank">error</a>)<br/>}</span></pre><p id="e7d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<a class="ae jt" href="http://golang.org/pkg/net/http#RoundTripper" rel="noopener ugc nofollow" target="_blank"> <em class="kw">往返器</em> </a>负责生成一个给定请求的响应，但是它也有能力改变请求和响应的设置。这对于监控、检测和身份验证非常有用。</p><p id="0693" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://godoc.org/golang.org/x/oauth2#Transport" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> oauth2。传输</em> </a>类型，给定一个请求，添加认证头并通过其基本传输转发请求。</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="c068" class="kp kq hi kl b fi kr ks l kt ku">&amp;oauth2.Transport{<br/>    Source: google.<strong class="kl hj">AppEngineTokenSource</strong>(c, <strong class="kl hj">bigquery.BigqueryScope</strong>),<br/>    Base: &amp;urlfetch.Transport{Context: c},<br/>}</span></pre><p id="57d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码片段创建了一个新的<a class="ae jt" href="https://godoc.org/golang.org/x/oauth2#Transport" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> oauth2。Transport </em> </a>使用App Engine项目的默认服务帐户对请求进行身份验证，然后使用由<a class="ae jt" href="https://cloud.google.com/appengine/docs/go/urlfetch/" rel="noopener ugc nofollow" target="_blank"><em class="kw">URL fetch</em></a><em class="kw">—</em>提供的HTTP传输方式从App Engine应用程序访问外部资源。</p><h2 id="418a" class="kp kq hi bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated"><strong class="ak"> 2。创建一个大查询服务并列出所有数据集</strong></h2><p id="a6ec" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">用“<a class="ae jt" href="http://google.golang.org/api/bigquery/v2" rel="noopener ugc nofollow" target="_blank">google.golang.org/api/bigquery/v2</a>”创建一个大查询服务非常简单。只需导入包，并使用<a class="ae jt" href="https://godoc.org/google.golang.org/api/bigquery/v2#New" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> bigquery为HTTP客户端创建一个新服务。新增</em> </a>。</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="8bab" class="kp kq hi kl b fi kr ks l kt ku">bq, err := <strong class="kl hj">bigquery.New</strong>(client)<br/>if err != nil {<br/>    return nil, fmt.Errorf("create service: %v", err)<br/>}</span></pre><p id="7615" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检查错误是否不为零很重要，因为该操作可能会像网络上的任何其他操作一样失败。一旦我们有了服务，我们就可以按照文档列出该项目中可见的所有数据集:</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="af8a" class="kp kq hi kl b fi kr ks l kt ku">// obtain the current application id, the BigQuery id is the same<br/>appID := appengine.AppID(ctx)</span><span id="d671" class="kp kq hi kl b fi kv ks l kt ku">datasets, err := <strong class="kl hj">bq.Datasets.List(appID).Do()</strong><br/>if err != nil {<br/>    return nil, fmt.Errorf("could not list datasets: %v", err)<br/>}</span></pre><h2 id="a6ca" class="kp kq hi bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">3.创建包含项目名称的列表</h2><p id="0ff9" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">我们得到了<em class="kw">列表</em>，一个<a class="ae jt" href="https://godoc.org/google.golang.org/api/bigquery/v2#DatasetList" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> bigquery。DatasetList </em> </a> <em class="kw">，</em>这样我们可以迭代<em class="kw">项目</em>中的所有项目，并在返回之前将它们的<em class="kw"> Id </em>添加到我们的列表中。</p><pre class="jv jw jx jy fd kk kl km kn aw ko bi"><span id="f98e" class="kp kq hi kl b fi kr ks l kt ku">var ids []string</span><span id="f4f1" class="kp kq hi kl b fi kv ks l kt ku">for _, d:= range datasets.Datasets {<br/>    ids = append(ids, d.Id)<br/>}</span><span id="b8e6" class="kp kq hi kl b fi kv ks l kt ku">return id, nil</span></pre><p id="955d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果代码可在<a class="ae jt" href="https://github.com/GoogleCloudPlatform/golang-samples/tree/master/appengine/bigquery" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="670a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这对你们很多人有帮助！欢迎在<a class="ae jt" href="http://twitter.com/francesc" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上提问或发送建议！</p></div></div>    
</body>
</html>