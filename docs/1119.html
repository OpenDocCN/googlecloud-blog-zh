<html>
<head>
<title>How to use Terraform without server ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有服务器如何使用Terraform？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-use-terraform-without-server-976d922f3f72?source=collection_archive---------1-----------------------#2019-08-20">https://medium.com/google-cloud/how-to-use-terraform-without-server-976d922f3f72?source=collection_archive---------1-----------------------#2019-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d231f1ab982e1242db5aef655a17124f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zCXRkCVsZGEO-wCik5GrQ.png"/></div></div></figure><p id="e0e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Terraform很时髦。很多运营都用它:多云支持、最新、大型社区和模板……它的优势是多方面的。然而，我是无服务器的忠实粉丝，我更喜欢<a class="ae jo" href="https://cloud.google.com/deployment-manager/" rel="noopener ugc nofollow" target="_blank">部署管理器</a>。我的行动没有，因为它粘着GCP。他们是对的。</p><p id="1585" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，我从来不喜欢Terraform，因为这种无休止的循环:</p><blockquote class="jp"><p id="ffc3" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">对于服务器的干净部署，请使用Terraform来部署此服务器。Terraform必须安装在服务器上；使用Terraform部署此服务器...</p></blockquote><p id="e78e" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">因此，我从来没有使用过Terraform…直到这个<a class="kf kg ge" href="https://medium.com/u/ef2e4caf305a?source=post_page-----976d922f3f72--------------------------------" rel="noopener" target="_blank"> Steren </a>的<em class="ke">无关</em>帖子</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/93e6306f04b8c0182c87e2338b3cee3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8VKD5KOFFH1Yqyai61jRg.png"/></div></div></figure><blockquote class="km kn ko"><p id="a570" class="iq ir ke is b it iu iv iw ix iy iz ja kp jc jd je kq jg jh ji kr jk jl jm jn hb bi translated"><strong class="is hj">什么？使用云构建不构建容器？太聪明了！</strong></p></blockquote><p id="ce4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这条推文，我想到了一个惊人的想法:<strong class="is hj"> <em class="ke">通过云构建在无服务器模式下使用Terraform！</em>T11】</strong></p><h1 id="6302" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">第一个(坏)主意</h1><p id="5b29" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">从哪里开始？我需要执行Terraform，尽管我(不)了解Terraform，但我需要保存tfstate文件。</p><blockquote class="km kn ko"><p id="9091" class="iq ir ke is b it iu iv iw ix iy iz ja kp jc jd je kq jg jh ji kr jk jl jm jn hb bi translated">第一步:docker形象存在吗？</p></blockquote><p id="2773" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，<a class="ae jo" href="https://hub.docker.com/r/hashicorp/terraform/" rel="noopener ugc nofollow" target="_blank"> Terraform安装包装在一个容器中，可在Docker Hub </a>上获得。因此，将它与云构建一起使用将会很容易。</p><blockquote class="km kn ko"><p id="9129" class="iq ir ke is b it iu iv iw ix iy iz ja kp jc jd je kq jg jh ji kr jk jl jm jn hb bi translated">第二步:如何管理tfstate文件？</p></blockquote><p id="254d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Steren tweet展示了如何在过程结束时<a class="ae jo" href="https://cloud.google.com/cloud-build/docs/configuring-builds/store-images-artifacts#storing_artifacts_in" rel="noopener ugc nofollow" target="_blank">将文件从云构建环境推送到Google云存储</a>。为了一开始就从存储中获取它们，使用<a class="ae jo" href="https://cloud.google.com/cloud-build/docs/cloud-builders" rel="noopener ugc nofollow" target="_blank">云构建器</a> <a class="ae jo" href="https://github.com/GoogleCloudPlatform/cloud-builders" rel="noopener ugc nofollow" target="_blank">图像</a>。<strong class="is hj">大功告成！</strong></p><p id="7224" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将测试并深入研究Terraform机制和文档… <strong class="is hj">糟糕的第一种方法！</strong></p><h1 id="7c08" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">Terraform已经成熟</h1><p id="002d" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">其实<strong class="is hj"> Terraform远比我预期的成熟</strong>。我发现<a class="ae jo" href="https://www.terraform.io/docs/backends/types/gcs.html" rel="noopener ugc nofollow" target="_blank">后端定义</a>存在。它允许远程检索和存储部署状态。</p><p id="a772" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">存在一个GCS实现，它非常容易使用。只需在您的<code class="du lv lw lx ly b"><a class="ae jo" href="https://github.com/guillaumeblaquiere/terraform-serverless-cloudbuild/blob/master/main.tf" rel="noopener ugc nofollow" target="_blank">main.tf</a></code>文件中定义后端存储桶和路径。</p><pre class="ki kj kk kl fd lz ly ma mb aw mc bi"><span id="d12e" class="md kt hi ly b fi me mf l mg mh">terraform {<br/>  backend "gcs" {<br/>    bucket  = "my-state-bucket"<br/>    prefix  = "terraform/state"<br/>  }<br/>}</span></pre><p id="5a36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的第二步是通过<strong class="is hj"> 4行配置解决的！太完美了！</strong></p><p id="574f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们关注Terraform命令。<strong class="is hj">在</strong> <code class="du lv lw lx ly b"><a class="ae jo" href="https://github.com/guillaumeblaquiere/terraform-serverless-cloudbuild/blob/master/cloudbuild.yaml" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">cloudbuild.yaml</strong></a></code>文件中只有2步定义:</p><ul class=""><li id="59f2" class="mi mj hi is b it iu ix iy jb mk jf ml jj mm jn mn mo mp mq bi translated">运行<code class="du lv lw lx ly b">init</code>命令来设置云构建短命环境</li></ul><pre class="ki kj kk kl fd lz ly ma mb aw mc bi"><span id="a8a9" class="md kt hi ly b fi me mf l mg mh">- name: 'hashicorp/terraform'  <br/>  args: ['init']</span></pre><ul class=""><li id="126f" class="mi mj hi is b it iu ix iy jb mk jf ml jj mm jn mn mo mp mq bi translated">运行<code class="du lv lw lx ly b">apply</code>命令，在自动批准模式下执行部署/更新</li></ul><pre class="ki kj kk kl fd lz ly ma mb aw mc bi"><span id="1121" class="md kt hi ly b fi me mf l mg mh">- name: 'hashicorp/terraform'<br/>  args: ['apply','-var=PROJECT_ID=$PROJECT_ID','-auto-approve']</span></pre><p id="5a3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lv lw lx ly b">apply</code>命令要求知道<code class="du lv lw lx ly b">PROJECT_ID</code>。诀窍是用云构建环境变量<code class="du lv lw lx ly b">PROJECT_ID</code>来评估地形变量。Terraform的<code class="du lv lw lx ly b"><a class="ae jo" href="https://github.com/guillaumeblaquiere/terraform-serverless-cloudbuild/blob/master/main.tf" rel="noopener ugc nofollow" target="_blank">main.tf</a></code>文件是这样处理<code class="du lv lw lx ly b">PROJECT_ID</code>变量的:</p><pre class="ki kj kk kl fd lz ly ma mb aw mc bi"><span id="900f" class="md kt hi ly b fi me mf l mg mh">variable "PROJECT_ID" {<br/>  type        = string<br/>}</span><span id="fa6b" class="md kt hi ly b fi mr mf l mg mh">provider "google" {<br/> //credentials = NOT NEEDED, use Cloud Build service account permissions<br/> project     = var.PROJECT_ID<br/> region      = "us-central1"<br/>}</span></pre><h1 id="ca03" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">利用云构建</h1><p id="141d" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">云构建和Terraform的结合<strong class="is hj">产生了比我最初期望的更多的东西</strong>:<em class="ke">在我不必管理的服务器上运行Terraform。</em></p><h2 id="1513" class="md kt hi bd ku ms mt mu ky mv mw mx lc jb my mz lg jf na nb lk jj nc nd lo ne bi translated">证明</h2><p id="8bf9" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">这是另一个以前没有提到的棘手问题，也是困扰我的运营部门的问题:安全性。事实上，在一个托管服务器上，专门用于部署几个不同的项目，您必须管理不同的服务帐户，对这些不同的项目有不同的权限。</p><p id="f48a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，您必须存储不同的JSON安全密钥文件。您必须轮换这些JSON密钥文件，以确保它们在虚拟机上的机密性/访问权限……大量的手动工作非常耗时，而且并不总是最先进的安全最佳实践。</p><p id="1468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云构建解决了这一点。您只需为项目使用云构建服务帐户的权限。<strong class="is hj">安全性现在由平台</strong>来保证。</p><h2 id="8d1f" class="md kt hi bd ku ms mt mu ky mv mw mx lc jb my mz lg jf na nb lk jj nc nd lo ne bi translated">自动化</h2><p id="040b" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">对于专用于部署的服务器，您必须连接到它，获取代码更新，并启动正确的命令来应用更改。<em class="ke">无人工失误。</em></p><p id="1f1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云构建伴随着<a class="ae jo" href="https://cloud.google.com/cloud-build/docs/running-builds/automate-builds" rel="noopener ugc nofollow" target="_blank">自动化并触发</a>。因此，对基础设施定义文件进行简单的<strong class="is hj">提交，几分钟后就会自动完成更新。</strong></p><h2 id="cdff" class="md kt hi bd ku ms mt mu ky mv mw mx lc jb my mz lg jf na nb lk jj nc nd lo ne bi translated">历史</h2><p id="a221" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">对于服务器上的本地执行，您只有一个历史文件(<code class="du lv lw lx ly b">terraform.tfstate.backup</code>)。而且，这个文件在1台服务器上的恢复能力如何？如何防止误删除/更新？</p><p id="34ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也是该解决方案的另一个优势，这要归功于Terraform后端功能。tfstate文件存储在<strong class="is hj"> Google云存储中，具有高弹性和持久性</strong>。为了保存更改的历史，Terraform文档建议在专用于状态存储的存储桶上激活版本控制</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/b4c1f5a7da239e5760d2e2092591af1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*400SWu1V6MQ6tFxem_wWBQ.png"/></div></div></figure><p id="1288" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以<strong class="is hj">拥有不止一个备份文件</strong>，从而更好地控制变更和历史。<em class="ke">这与云构建无关，您可以独立使用该功能</em></p><h2 id="5f39" class="md kt hi bd ku ms mt mu ky mv mw mx lc jb my mz lg jf na nb lk jj nc nd lo ne bi translated">便携性和技能</h2><p id="1f79" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">今天，许多团队已经使用Terraform，因为它的质量。团队有他们的过程，他们的技能，他们在产品上受过训练。</p><p id="d4c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，产品组合不会改变团队组织。从一个解决方案(需要管理的服务器)切换到另一个解决方案(采用云构建的无服务器)非常简单。Terraform脚本非常相似；团队中的地形技能仍然需要，内部定义的流程可以保留。</p><h2 id="e8be" class="md kt hi bd ku ms mt mu ky mv mw mx lc jb my mz lg jf na nb lk jj nc nd lo ne bi translated">版本管理</h2><p id="40e7" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">版本管理也是一个挑战。在向后不兼容的情况下，同一服务器上可能同时需要几个版本，这增加了管理成本和问题概率(副作用或人为错误)</p><p id="6bae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用云构建，您可以指定想要使用的Terraform构建版本。执行是隔离的(版本之间没有副作用),版本更新就像改变<code class="du lv lw lx ly b">cloudbuild.yaml</code>文件中的版本号一样简单。</p><h2 id="d30d" class="md kt hi bd ku ms mt mu ky mv mw mx lc jb my mz lg jf na nb lk jj nc nd lo ne bi translated">定价</h2><p id="0026" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">一次又一次，成本是一个重要的决策因素。云构建为每个项目提供<strong class="is hj">每天120分钟的免费构建，以及多达10个并发构建</strong>。</p><p id="e42e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，您没有任何平台管理成本:服务器更新/补丁、Terraform版本管理、要轮换的JSON关键文件等等</p><h2 id="a6d7" class="md kt hi bd ku ms mt mu ky mv mw mx lc jb my mz lg jf na nb lk jj nc nd lo ne bi translated">还有更多…</h2><p id="a980" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">我肯定我错过了一些关键的优势。如果你有，分享一下！</p><p id="6375" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我可以添加<a class="ae jo" href="https://cloud.google.com/cloud-build/docs/speeding-up-builds#using_kaniko_cache" rel="noopener ugc nofollow" target="_blank">云构建缓存</a>，它只在第一步下载<code class="du lv lw lx ly b">hashicorp/terraform</code>映像，并在第二步重用它，而不需要另外下载。</p><p id="9efc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个特性是添加其他步骤的能力，由于云构建器，可以在基础设施上部署特定的组件。在缺少可作为gcloud CLI命令使用的Terraform功能的情况下，此功能尤其有用。<strong class="is hj">这是一个很好的变通方法，直到Terraform实现了这些功能(尤其是针对Alpha/Beta服务)</strong>。</p><p id="9c73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，云构建者仍然有能力在使用秘密 作为地形变量之前<a class="ae jo" href="https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-secrets-credentials" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">解密秘密。</strong></a></p><p id="9b1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，<a class="ae jo" href="https://cloud.google.com/cloud-build/docs/send-build-notifications" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">通知特性</strong> </a>允许推或拉构建状态，并对该事件执行后处理。</p><h1 id="91ea" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">云构建+地形:终极组合</h1><p id="1a15" class="pw-post-body-paragraph iq ir hi is b it lq iv iw ix lr iz ja jb ls jd je jf lt jh ji jj lu jl jm jn hb bi translated">毫无疑问，Terraform的基础设施自动化和管理与云构建的灵活性和构建自动化相结合，产生了一个强大的产品组合<strong class="is hj">，我想向每个团队推荐这个产品组合</strong>。</p><p id="5b77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是简单、实惠、快捷的；最重要的是，<strong class="is hj">无服务器！</strong></p></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="8a9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我是Terraform世界的新手，如果您有不适合此设置的特定/复杂用例，我希望了解更多并讨论这些。同样的事情，如果我是不正确的，或者如果有更好的做法。</p><p id="e75c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的示例项目在这里可用<a class="ae jo" href="https://github.com/guillaumeblaquiere/terraform-serverless-cloudbuild" rel="noopener ugc nofollow" target="_blank">。<code class="du lv lw lx ly b"><a class="ae jo" href="https://github.com/guillaumeblaquiere/terraform-serverless-cloudbuild/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">README.md</a></code>帮助你测试它，并破坏你的部署。</a></p></div></div>    
</body>
</html>