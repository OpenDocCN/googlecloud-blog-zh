<html>
<head>
<title>Serverless Eventing: SinkBinding 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器事件:SinkBinding 101</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/serverless-eventing-sinkbinding-101-12d9ed31a76f?source=collection_archive---------3-----------------------#2020-04-20">https://medium.com/google-cloud/serverless-eventing-sinkbinding-101-12d9ed31a76f?source=collection_archive---------3-----------------------#2020-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/acfbdcf5ee2e6c66bb0ac4cf063bf9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yjRIDdE8NI9jTvjVhgjZYA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">无服务器事件</figcaption></figure><p id="8afd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您正在编写一个应用程序，试图以近乎实时的方式分析电视直播中的推文。在这种情况下，5小时前发的推文对你没有任何意义。你会怎么做？</p><p id="d1f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要创建一个应用程序，能够收集事件，并发送它们以供摄取或消费。这是生产者-消费者模式。一个进程创建一个事件并传输它，而另一个进程接收事件并对数据进行处理。</p><p id="4bca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://knative.dev/docs/eventing/" rel="noopener ugc nofollow" target="_blank"> Knative Eventing </a>允许通过<a class="ae jo" href="https://knative.dev/docs/eventing/samples/sinkbinding/" rel="noopener ugc nofollow" target="_blank"> SinkBinding </a>创建第一方事件源。用最简单的术语来说，SinkBinding负责将生产者与消费者匹配起来。在这种情况下，您的消费者就是“事件接收器”。</p><p id="3848" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消费者可以是任何使用PodSpec的Kubernetes资源。这可以是代理集、作业、有状态集，甚至是一个无效服务的部署。如果您不是Knative的新手，那么您可能更了解ContainerSource。ContainerSource正在回归Knative Eventing，但更好的解决方案是SinkBinding。</p><p id="34bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ContainerSource yaml包含接收器绑定和部署定义。虽然这更简单，但它也限制了Knative Eventing可以用作源的内容。通过将部署定义从接收器定义中分离出来，我们打开了可能性。</p><p id="e785" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在GitHub 有一个教程<a class="ae jo" href="https://github.com/TheJaySmith/serverless-eventing/tree/master/tutorials/twitter-sink-binding" rel="noopener ugc nofollow" target="_blank">。在这里，您将创建一个小的Python应用程序，它将每30秒提取25条tweets，然后将它们发送到一个Knative服务，该服务将简单地记录所有传入的消息。</a></p><p id="133b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将需要在Twitter 中创建一个<a class="ae jo" href="https://developer.twitter.com/en/apps" rel="noopener ugc nofollow" target="_blank">应用程序，以获得完成本教程所需的API密钥。GitHub资源库的README文件中详细介绍了所有内容。试一试，然后回来我们谈谈。</a></p><p id="9794" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，你试过了？不酷吗？现在你可能会问自己为什么这很重要。毕竟，难道不能编写这些应用程序来利用某种消息总线，比如RabbitMQ或Kafka吗？</p><p id="3332" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，但是我们在这里谈论的是无服务器。我们正在讨论寻找简化开发人员体验的方法，并要求开发人员或操作人员维护额外的工具来使应用程序工作，这使我们远离了无服务器的目标。</p><p id="bd40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">肯定有云提供商提供这些工具的完全托管版本，但完全托管！=无服务器。您已经将维护需求排除在外，但是现在我们必须绑定源和接收器。</p><p id="37ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Knative Eventing允许您以声明方式将源绑定到它们的接收器。如果你看代码，你不需要硬编码你想发送代码的地方或者你从哪里接收代码。您也不必导入特殊的库来连接到您的源或接收器。</p><p id="d3ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事件源的代码使用了<code class="du jp jq jr js b">K_SINK</code>环境变量。Knative使用这个变量来知道将流量路由到哪里。对于我的消费者，我创建了一个接收所有传入流量的端点。</p><p id="0ee2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在告诉Knative如何安排我的活动时，SinkBinding YAML就是我所需要的一切。这展示了如何简化将事件源绑定到它们的接收者。</p><p id="e7ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个非常简单的例子，事件直接从源发送到接收器。在未来的教程中，我们将向您展示当您想要为您的事件创建一个更健壮的路由时，经纪人和渠道的力量。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="e8ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ka">原载于2020年4月20日【https://thejaysmith.com】<a class="ae jo" href="https://thejaysmith.com/titles/blogroll/serverless-eventing-sinkbinding-101/" rel="noopener ugc nofollow" target="_blank"><em class="ka"/></a><em class="ka">。</em></em></p></div></div>    
</body>
</html>