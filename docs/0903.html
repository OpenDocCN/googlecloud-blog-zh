<html>
<head>
<title>BigQuery ML gets faster by computing a closed-form solution (sometimes)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery ML通过计算封闭形式的解(有时)变得更快</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-ml-gets-faster-by-computing-a-closed-form-solution-sometimes-1baa5a838eb6?source=collection_archive---------2-----------------------#2019-02-04">https://medium.com/google-cloud/bigquery-ml-gets-faster-by-computing-a-closed-form-solution-sometimes-1baa5a838eb6?source=collection_archive---------2-----------------------#2019-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d4ad" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我如何在不损失准确性的情况下获得50%的加速</h2></div><p id="49c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae jt" href="https://towardsdatascience.com/how-to-do-online-prediction-with-bigquery-ml-db2248c0ae5" rel="noopener" target="_blank">之前的一篇文章</a>中，我向您展示了如何在BigQuery中仅使用SQL来训练机器学习模型:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="dc5e" class="kd ke hi jz b fi kf kg l kh ki">CREATE OR REPLACE MODEL flights.arrdelay<br/>OPTIONS<br/>  (model_type='linear_reg', input_label_cols=['arr_delay']) AS<br/>SELECT<br/>  arr_delay,<br/>  carrier,<br/>  origin,<br/>  dest,<br/>  dep_delay,<br/>  taxi_out,<br/>  distance<br/>FROM<br/>  `cloud-training-demos.flights.tzcorr`<br/>WHERE<br/>  arr_delay IS NOT NULL</span></pre><p id="eeab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这花了我大约6分钟。但是当我现在在BigQuery上运行它时，它只花了我3分钟的时间，并且在一次迭代中就完成了:</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div class="er es kj"><img src="../Images/c2102c808778290e86094e1a72be8f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*ZjJmDKdHe2vYxVZfIxOgog.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">BigQuery ML只需一次迭代就可以训练航班模型！</figcaption></figure><p id="8c34" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">怎么了？为什么BigQuery ML突然变快了？发生了什么事？你会一直这样加速吗？得到的模型准确吗？</p><p id="15eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答:(a)它变得更快的主要原因是因为它使用了更快的算法(即，不是因为计算基础设施的改进)。(b)更快的算法包括通过计算“伪逆”来寻找封闭形式的解。(c)伪逆将仅对机器学习问题的子集起作用。(d)这个模型和你通过多次迭代得到的一样好。</p><p id="ef5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将进一步解释这些答案。随意浏览下一部分(伪逆背后的数学)，因为细节并不重要。</p><h2 id="f6ea" class="kd ke hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">伪逆(数学)</h2><p id="c348" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">进行线性回归时，实际上是在给定各种要素(X)及其对应的标注列(Y)的情况下，求解矩阵方程XW = Y以获得W的最佳值。</p><p id="692f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果X由N行m个特征组成，那么X是一个<em class="lp"> N×m </em>矩阵，W是一个<em class="lp"> m×1 </em>矩阵，Y是一个<em class="lp"> N×1 </em>矩阵。</p><p id="6fc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们正好有<em class="lp"> m </em>行和<em class="lp"> m </em>个特征，并且如果这些行都是线性独立的，那么这是一个线性方程组，您可以通过计算X的逆矩阵并将两边相乘来计算W的正确答案:</p><p id="afa4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">x⁻x w =<em class="lp">x⁻y</em></p><p id="873d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">矩阵与其逆矩阵的乘积是一个单位矩阵，所以你得到W的封闭解:</p><p id="3293" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">X⁻</p><p id="8961" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是通常你会有更多的数据，所以X不是一个方阵，你不能直接计算X的逆矩阵。相反，您可以通过将X乘以其自身的转置来得到X的平方:</p><p id="f8e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(<em class="lp"> Xᵀ </em> X) W = <em class="lp"> Xᵀ </em> Y</p><p id="c49c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我们对平方矩阵求逆，我们可以直接求解权重:</p><p id="cde3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">w =(<em class="lp">xᵀ</em>x)<em class="lp">⁻</em>t26】xᵀy</p><p id="380b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个东西:(<em class="lp">xᵀ</em>x)<em class="lp">⁻</em><em class="lp">xᵀ</em>叫做x的<a class="ae jt" href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse" rel="noopener ugc nofollow" target="_blank"> Moore-Penrose伪逆</a>，这就是bigquery正在计算的直接求权值。</p><h2 id="0085" class="kd ke hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">这会导致精确的解决方案吗？</h2><p id="4b1b" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">线性回归模型属于“<a class="ae jt" href="https://en.wikipedia.org/wiki/Convex_optimization" rel="noopener ugc nofollow" target="_blank">凸优化</a>类问题。这意味着只有全局最小值，没有局部最小值。BigQuery使用的称为<a class="ae jt" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Iterative_method" rel="noopener ugc nofollow" target="_blank">小批量梯度下降</a>的常规迭代方法收敛于这个全局最小值，伪逆直接求解它。因此，这两种方法将产生等效的模型(而不是相同的模型，因为如果您的一些要素是线性相关的，则解决方案不是唯一的)。只要你让迭代方法运行到收敛，在精度方面没有折衷。</p><h2 id="8398" class="kd ke hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">可能的速度提升是多少？</h2><p id="368f" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">如果表达式(<em class="lp">xᵀ</em>x)<em class="lp">⁻</em>t8】xᵀ能够被快速有效地计算，那么直接求解该解比使用迭代的梯度下降方法更好。这就是BigQuery现在所做的。</p><p id="93f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在航班问题中，行数是600万，功能数是660，我们得到了50%的加速。如果您有更大的数据集，您应该会看到更多的加速。这是因为计算<em class="lp"> Xᵀ </em> X可以以令人尴尬的并行方式完成，BigQuery擅长在非常大的数据集上并行化这种计算。因此，行数越多，相对于梯度下降法，加速就越快。此外，特征数量越少，要求逆的矩阵就越小，加速就越快。</p><p id="19fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，行数/特征数的比值越大，伪逆就越快。</p><h2 id="6e0a" class="kd ke hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">BigQuery什么时候可以计算伪逆？</h2><p id="6131" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">只有当您要最小化的误差是均方误差时，伪逆才能帮助您找到最佳权重。这是线性回归的情况，但仅当不修改误差函数时，例如通过使用L1正则化。多类逻辑回归(误差函数是交叉熵)就不是这样了。有一种方法可以将一个二元分类问题转化为线性回归问题，但是目前BigQuery没有实现这一点。</p><p id="9641" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其次，考虑我们要求逆的矩阵的大小。x的大小为<em class="lp"> N×m </em>，其中m是在对分类变量进行一次性编码后的基数或特征数。因此，<em class="lp"> Xᵀ </em>的大小为<em class="lp"> m×N </em>而<em class="lp"> Xᵀ </em> X的大小为<em class="lp"> m×m </em>。这意味着当你计算伪逆时，你需要对一个大小为<em class="lp"> m×m </em>的矩阵求逆。这是一个内存操作，必须在单个BigQuery工作线程上进行。因此，只有在单个worker上计算一个<em class="lp"> m×m </em>矩阵的逆矩阵比普通的分布式迭代方法更快时，BigQuery才会选择这样做。在航班问题中，基数由三个分类特征(14 + 322 + 322(承运人、始发地、目的地))和三个数字特征组成。因此，总基数是661，对一个661x661的矩阵求逆对于一个工人来说已经足够快了。目前，从伪逆方法翻转到迭代方法的特征数量阈值高达数千个，尽管这将随着硬件规格的变化而变化。</p><p id="fd2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第三，考虑我在开始矩阵求逆时提出的警告——行必须是线性独立的，这样矩阵才能表现良好，足以让你求逆。因此，只有当数据集足够大时，BigQuery才会计算伪逆。如果你的行数比你的特征数多一个数量级，那么你应该落入伪逆领域。</p><h2 id="c596" class="kd ke hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">如果我不想呢？</h2><p id="d895" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">您可以强制BigQuery不使用伪逆。通过明确指定优化策略，强制其使用迭代小批量梯度下降:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d1d3" class="kd ke hi jz b fi kf kg l kh ki">CREATE OR REPLACE MODEL flights.arrdelay<br/>OPTIONS<br/>  (model_type='linear_reg', input_label_cols=['arr_delay'], <strong class="jz hj">optimize_strategy='batch_gradient_descent'</strong>) AS<br/>SELECT<br/>  arr_delay,<br/>  carrier,<br/>  origin,<br/>  dest,<br/>  dep_delay,<br/>  taxi_out,<br/>  distance<br/>FROM<br/>  `cloud-training-demos.flights.tzcorr`<br/>WHERE<br/>  arr_delay IS NOT NULL</span></pre><p id="ce5b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我这样做时，模型花费了6.5分钟，并在7次迭代中收敛。</p><p id="910f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不过，如果可能的话，最好让BigQuery使用封闭形式的解决方案。为什么你会放弃减少50%的训练时间而不损失准确性呢？我能想到的几乎唯一的原因是当你有一个可怕的数据集，其中许多行是相同的——这是因为这种不适定矩阵的<a class="ae jt" href="https://www.google.com/search?q=ill+posed+matrix+inversion" rel="noopener ugc nofollow" target="_blank">反演</a>仍然是一个研究问题，但你确实清理了你的数据集，不是吗？</p><h2 id="90a5" class="kd ke hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">摘要</h2><p id="f30d" class="pw-post-body-paragraph ix iy hi iz b ja lk ij jc jd ll im jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">BigQuery ML现在将使用伪逆计算封闭形式的解决方案。这比普通的迭代方法更快，但只有在以下情况下才会选择:</p><ul class=""><li id="6b3d" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">您正在进行没有L1正则化的线性回归</li><li id="09ef" class="lq lr hi iz b ja lz jd ma jg mb jk mc jo md js lv lw lx ly bi translated">您拥有不到几千个要素(考虑到分类要素的基数)</li><li id="e2e4" class="lq lr hi iz b ja lz jd ma jg mb jk mc jo md js lv lw lx ly bi translated">行数比要素数多一个数量级</li></ul><p id="1600" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">得到的模型与BigQuery使用常规的、迭代的小批量梯度下降方法得到的模型具有相同的精度。</p><ul class=""><li id="8790" class="lq lr hi iz b ja jb jd je jg ls jk lt jo lu js lv lw lx ly bi translated">实际的加速取决于行数和特性数。行数越多，或者功能越少，速度就越快。</li><li id="8972" class="lq lr hi iz b ja lz jd ma jg mb jk mc jo md js lv lw lx ly bi translated">您可以通过显式指定<em class="lp">optimize _ strategy = ' batch _ gradient _ descent '</em><strong class="iz hj">来关闭此功能。</strong>不过不要。</li></ul><p id="f807" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想知道这是否会是一个问题，请尝试对数据进行计数(DISTINCT ),看看有多少重复行。</p><p id="759d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lp">感谢明歌·邓、阿米尔·霍玛蒂和费利佩·霍法的有益反馈和指点。</em></p></div></div>    
</body>
</html>