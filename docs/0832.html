<html>
<head>
<title>Using BigQuery SQL MERGE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BigQuery SQL合并</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-bigquery-sql-merge-e4cebf9f91fc?source=collection_archive---------0-----------------------#2018-12-04">https://medium.com/google-cloud/using-bigquery-sql-merge-e4cebf9f91fc?source=collection_archive---------0-----------------------#2018-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ac80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BigQuery可以完成一些非常复杂的数据处理，但是最好的特性往往隐藏在文档深处。</p><p id="695a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个博客中，我们将转换和合并输入数据和一些排序数据。我们将逐步构建SQL，并使用其中的一些特性。这可以帮助你展示什么是可能的！</p><blockquote class="jd"><p id="d75f" class="je jf hi bd jg jh ji jj jk jl jm jc dx translated"><strong class="ak"> <em class="jn">想自己跑？请参见最后的“测试”!</em>T3】</strong></p></blockquote><h1 id="5100" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">挑战</h1><p id="bce7" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">我们用这种结构存储我们的<strong class="ih hj"> staging </strong>事务表:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="de4c" class="la jp hi kw b fi lb lc l ld le">STRUCT&lt;<br/>  id STRING,          -- globally unique<br/>  version TIMESTAMP,  -- transaction version, greatest is current<br/>  ... other fields (eg, customer name, product name, order id)<br/>&gt;</span></pre><p id="d2f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事务通常是唯一的(只有一个版本)，但有时会有多个版本。对于我们的分析，我们想要分析正常情况下每个事务的最新版本。我们不关心事务中的所有数据字段——不管怎样，您将看到SQL是如何工作的！</p><p id="52dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用以下结构存储我们的<strong class="ih hj">分析</strong>事务表:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="54fd" class="la jp hi kw b fi lb lc l ld le">STRUCT&lt;<br/>  id STRING,</span><span id="0c47" class="la jp hi kw b fi lf lc l ld le">  -- transaction with most recent version<br/>  latest STRUCT&lt;version TIMESTAMP, ... other fields&gt;,</span><span id="4ecf" class="la jp hi kw b fi lf lc l ld le">  -- older transactions (if any) sorted newest to oldest<br/>  history ARRAY&lt;STRUCT&lt;version TIMESTAMP, ... other fields&gt;&gt;<br/>&gt;</span></pre><p id="3b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这为我们提供了一种方便的方法来分析每个事务的最新的事务，同时如果我们需要历史记录的话，还可以使用big query array工具。</p><p id="109c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">暂存数据在<strong class="ih hj">transactions . staging _ data</strong>表中，分析表在<strong class="ih hj"> transactions.data </strong>表中。我们将构建一个BigQuery SQL来将<strong class="ih hj"> staging_data </strong>表合并到<strong class="ih hj"> data </strong>表中。该SQL可以多次运行而不会产生影响。</p><h1 id="b3b8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz lh kb kc kd li kf kg kh lj kj kk kl bi translated">SQL</h1><p id="2ab0" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">SQL将被编写为好像它将被划分到不同的表中，但是它可以被合并到一个单独的SQL中，并以with结尾。</p><h2 id="78c0" class="la jp hi bd jq lk ll lm ju ln lo lp jy iq lq lr kc iu ls lt kg iy lu lv kk lw bi translated">GroupedStagingTransactions</h2><p id="c624" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">使用<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_agg" rel="noopener ugc nofollow" target="_blank"> ARRAY_AGG </a>根据id聚合暂存交易。注意使用“数据”将整行作为一个结构来引用。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3ff0" class="la jp hi kw b fi lb lc l ld le">SELECT<br/>  id,<br/>  ARRAY_AGG(data) AS trans<br/>FROM<br/>  transactions.staging_data data<br/>GROUP BY<br/>  1</span></pre><h2 id="c371" class="la jp hi bd jq lk ll lm ju ln lo lp jy iq lq lr kc iu ls lt kg iy lu lv kk lw bi translated">分组交易</h2><p id="e0dd" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">使用<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#select-modifiers" rel="noopener ugc nofollow" target="_blank">选择修饰符</a> EXCEPT和AS结构、<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array" rel="noopener ugc nofollow" target="_blank">数组</a>函数和<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#expression-subqueries" rel="noopener ugc nofollow" target="_blank">表达式子查询</a>删除ID列。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4f13" class="la jp hi kw b fi lb lc l ld le">SELECT<br/>  id,<br/>  ARRAY(SELECT AS STRUCT<br/>      * EXCEPT (id)<br/>    FROM<br/>      d.trans<br/>  ) AS trans<br/>FROM<br/>  GroupedStagingTransactions d</span></pre><h2 id="c183" class="la jp hi bd jq lk ll lm ju ln lo lp jy iq lq lr kc iu ls lt kg iy lu lv kk lw bi translated">加入交易</h2><p id="a1b5" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">使用<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#array_concat" rel="noopener ugc nofollow" target="_blank"> ARRAY_CONCAT </a>和一个<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays#constructing-arrays" rel="noopener ugc nofollow" target="_blank">数组构造</a>来连接现有数据。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="83c0" class="la jp hi kw b fi lb lc l ld le">SELECT<br/>  staging.id,<br/>  IF(data IS NULL,<br/>    staging.trans,<br/>    ARRAY_CONCAT(staging.trans, [data.latest], data.history)<br/>  ) AS trans<br/>FROM<br/>  GroupedTransactions AS staging<br/>  LEFT JOIN transactions.data AS data<br/>  ON staging.id = data.id</span></pre><h2 id="dd89" class="la jp hi bd jq lk ll lm ju ln lo lp jy iq lq lr kc iu ls lt kg iy lu lv kk lw bi translated">分类交易</h2><p id="44e2" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">使用更多的<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#expression-subqueries" rel="noopener ugc nofollow" target="_blank">表达式子查询</a>和一个SELECT DISTINCT和SELECT AS结构来提取不同历史记录的数组。</p><p id="682d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">观察子查询中的子查询以及与<strong class="ih hj">分析</strong>表相同的输出。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8f4a" class="la jp hi kw b fi lb lc l ld le">SELECT<br/>  t.id,<br/>  (SELECT<br/>     rec<br/>   FROM<br/>     t.trans AS rec<br/>   ORDER BY<br/>     version DESC<br/>   LIMIT 1<br/>  ) AS latest,<br/>  ARRAY(SELECT DISTINCT AS STRUCT<br/>     *<br/>   FROM<br/>     T.trans<br/>   WHERE<br/>     version &lt; (SELECT MAX(version) FROM t.trans)<br/>   ORDER BY<br/>     version DESC<br/>  ) AS history<br/>FROM<br/>  JoinedTransactions t</span></pre><h2 id="c056" class="la jp hi bd jq lk ll lm ju ln lo lp jy iq lq lr kc iu ls lt kg iy lu lv kk lw bi translated">合并数据</h2><p id="2b93" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">在主表中更新或插入数据。使用顶层结构值来简化值的更新/插入。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="48d0" class="la jp hi kw b fi lb lc l ld le">MERGE transactions.data<br/>USING SortedTransactions staging<br/>ON<br/>  staging.id = data.id<br/>WHEN MATCHED THEN<br/>  UPDATE SET<br/>    latest = staging.latest,<br/>    history = staging.history<br/>WHEN NOT MATCHED BY TARGET THEN<br/>  INSERT (<br/>    id,<br/>    latest,<br/>    history)<br/>  VALUES (<br/>    staging.id,<br/>    staging.latest,<br/>    staging.history)</span></pre><h2 id="e4a4" class="la jp hi bd jq lk ll lm ju ln lo lp jy iq lq lr kc iu ls lt kg iy lu lv kk lw bi translated">单个SQL语句</h2><p id="7ecc" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">使用WITH将所有SQL放在一条语句中。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="47b3" class="la jp hi kw b fi lb lc l ld le">MERGE transactions.data<br/>USING (<br/>  WITH<br/>  GroupedStagingTransactions AS (<br/>    SELECT<br/>      id,<br/>      ARRAY_AGG(data) AS trans<br/>    FROM<br/>      transactions.staging_data data<br/>    GROUP BY<br/>      1<br/>  ),<br/>  GroupedTransactions AS (<br/>    SELECT<br/>      id,<br/>      ARRAY(SELECT AS STRUCT<br/>          * EXCEPT (id)<br/>        FROM<br/>          d.trans<br/>      ) AS trans<br/>    FROM<br/>      GroupedStagingTransactions d<br/>  ),<br/>  JoinedTransactions AS (<br/>    SELECT<br/>      staging.id,<br/>      IF(data.id IS NULL,<br/>        staging.trans,<br/>        ARRAY_CONCAT(staging.trans, [data.latest], data.history)<br/>      ) AS trans<br/>    FROM<br/>      GroupedTransactions AS staging<br/>      LEFT JOIN transactions.data AS data<br/>      ON staging.id = data.id<br/>  )<br/>  SELECT<br/>    t.id,<br/>    (SELECT<br/>      rec<br/>     FROM<br/>       t.trans AS rec<br/>     ORDER BY<br/>       version DESC<br/>     LIMIT 1<br/>    ) AS latest,<br/>    ARRAY(SELECT DISTINCT AS STRUCT<br/>       *<br/>     FROM<br/>       T.trans<br/>     WHERE<br/>       version &lt; (SELECT MAX(version) FROM t.trans)<br/>     ORDER BY<br/>       version DESC<br/>    ) AS history<br/>  FROM<br/>    JoinedTransactions t<br/>) AS staging<br/>ON<br/>  staging.id = data.id<br/>WHEN MATCHED THEN<br/>  UPDATE SET<br/>    latest = staging.latest,<br/>    history = staging.history<br/>WHEN NOT MATCHED BY TARGET THEN<br/>  INSERT (<br/>    id,<br/>    latest,<br/>    history)<br/>  VALUES (<br/>    staging.id,<br/>    staging.latest,<br/>    staging.history)</span></pre><h1 id="a7d6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz lh kb kc kd li kf kg kh lj kj kk kl bi translated">测试它</h1><p id="56fc" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">用一些生成的数据创建<strong class="ih hj">transactions . staging _ data</strong>表。使用<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays#using-generated-values" rel="noopener ugc nofollow" target="_blank"> GENERATE_ARRAY </a>、<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#from-clause" rel="noopener ugc nofollow" target="_blank"> UNNEST </a>和<a class="ae lg" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#rand" rel="noopener ugc nofollow" target="_blank"> RAND </a>进行帮助。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a7b9" class="la jp hi kw b fi lb lc l ld le">CREATE TEMP FUNCTION GetNewTransaction(id STRING)<br/>AS (STRUCT(id,CURRENT_TIMESTAMP() AS version,<br/>  TRUE AS active,<br/>  CONCAT('customer-', CAST(FLOOR(RAND()*100) AS STRING))<br/>    AS customer_name,<br/>  CONCAT('product', CAST(FLOOR(RAND()*100) AS STRING))<br/>    AS product_name,<br/>  CAST(FLOOR(RAND() * 10000)/100.0 AS NUMERIC)<br/>    AS amount<br/>));</span><span id="669f" class="la jp hi kw b fi lf lc l ld le">CREATE OR REPLACE TABLE transactions.staging_data AS<br/>SELECT<br/>  GetNewTransaction(CAST(r AS STRING)).*<br/>FROM<br/>  UNNEST(GENERATE_ARRAY(1, 100000)) AS r;</span></pre><p id="e899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从<strong class="ih hj"> staging_data </strong>模式创建<strong class="ih hj"> transactions.data </strong>表(空)。限制0是一个很好的方法来做到这一点！</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="312e" class="la jp hi kw b fi lb lc l ld le">CREATE OR REPLACE TABLE transactions.data AS<br/>WITH TransactionWithoutKey AS (<br/> SELECT<br/>   * EXCEPT (id)<br/> FROM<br/>   transactions.staging_data<br/> LIMIT 0<br/>)<br/>SELECT<br/>  staging_data.id,<br/>  t AS latest,<br/>  [t] AS history<br/>FROM<br/>  transactions.staging_data<br/>  CROSS JOIN TransactionWithoutKey t<br/>LIMIT<br/>  0;</span></pre><h1 id="ec8a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz lh kb kc kd li kf kg kh lj kj kk kl bi translated">最后的想法</h1><p id="8dab" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">有几样东西可以扩展—</p><ul class=""><li id="78cc" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated"><strong class="ih hj">分区。</strong>随着数据量的增加，性能会降低。使用日期分区或集群分区会有所帮助。</li><li id="2d71" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated"><strong class="ih hj">删节。</strong>没有支持删除的机制。</li></ul><p id="1863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这能让您了解BigQuery中一些强大的技术。</p></div></div>    
</body>
</html>