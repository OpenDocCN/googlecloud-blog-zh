<html>
<head>
<title>Knative and Cloud Run, portability in action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Knative和Cloud Run，将便携性付诸实践</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/knative-and-cloud-run-portability-in-action-1a655c914318?source=collection_archive---------2-----------------------#2020-01-23">https://medium.com/google-cloud/knative-and-cloud-run-portability-in-action-1a655c914318?source=collection_archive---------2-----------------------#2020-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/baca99209bb3995df65a9fa8c3d80ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fTmdlB7UxLZEmVxlUDfyA.png"/></div></div></figure><p id="727e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://cloud.google.com/run/docs/" rel="noopener ugc nofollow" target="_blank">云跑</a>已经宣布将于19日在三藩市举行。一年前，Knative已经由谷歌在同一事件中推出。两者都承诺同样的事情:<strong class="is hj">在任何安装了<a class="ae jo" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>和<a class="ae jo" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank"> Knative </a>的Kubernetes集群</strong>上的无服务器和可移植性。</p><p id="7f09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Next19，我有机会站在舞台上宣布这个消息，演讲题目是:<a class="ae jo" href="https://www.youtube.com/watch?v=16vANkKxoAU" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">容器一次，无服务器随处</strong> </a></p><blockquote class="jp"><p id="0fb2" class="jq jr hi bd js jt ju jv jw jx jy jn dx translated">无服务器的地方，真的吗？是真的吗？可能吗？</p></blockquote><p id="260b" class="pw-post-body-paragraph iq ir hi is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">让我们验证这一点</p><h1 id="fc68" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">云运行</h1><p id="7a22" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">Cloud Run是这个承诺的服务名:完全符合Knative的API，它有两种版本:托管的和基于GKE的。</p><p id="f0e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lh">GKE版本是Anthos</em><a class="ae jo" href="https://cloud.google.com/run/docs/gke/setup" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="lh">云运行的一部分</em> </strong> </a> <em class="lh">，它允许在Anthos管理的任何兼容集群中部署云运行服务:在GKE上，在本地，在其他云提供商上。</em></p><h2 id="bb4d" class="li kf hi bd kg lj lk ll kk lm ln lo ko jb lp lq ks jf lr ls kw jj lt lu la lv bi translated">托管版本</h2><p id="723d" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">托管版本符合Knative API，但是底层实现是特定于平台的。部署可以在控制台上完成，也可以通过命令行用<code class="du lw lx ly lz b"><a class="ae jo" href="https://cloud.google.com/sdk/install" rel="noopener ugc nofollow" target="_blank">gcloud</a></code>完成。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="ade2" class="li kf hi lz b fi mi mj l mk ml">gcloud beta run deploy hello --region us-central1 \<br/>    --image gcr.io/cloudrun-hello-go/hello \<br/>    --platform managed --allow-unauthenticated</span></pre><p id="5989" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几秒钟后，服务部署完毕，并显示可访问的URL。测试一下！</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="eb41" class="li kf hi lz b fi mi mj l mk ml">curl https://hello-&lt;project hash&gt;.run.app/</span><span id="1327" class="li kf hi lz b fi mm mj l mk ml"># Result<br/>This created the revision hello-00001 of the Cloud Run service hello in the GCP project &lt;project&gt;</span></pre><p id="607b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">好的</strong>。让我们在GKE部署同样的东西</p><h2 id="f2c7" class="li kf hi bd kg lj lk ll kk lm ln lo ko jb lp lq ks jf lr ls kw jj lt lu la lv bi translated">GKE版本的Anthos</h2><p id="b964" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">对于在GKE上的部署，您必须<strong class="is hj">使用Cloud Run插件</strong>部署您的GKE集群。这个附加组件在GKE集群上安装所有需要的组件，比如Istio和Knative。</p><p id="e1a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从<a class="ae jo" href="https://cloud.google.com/run/docs/gke/setup#create_cluster" rel="noopener ugc nofollow" target="_blank">部署一个符合云运行</a>的GKE集群开始。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="73c0" class="li kf hi lz b fi mi mj l mk ml">gcloud beta container clusters create cloudrun-cluster<strong class="lz hj"> </strong>\<br/>--addons=HorizontalPodAutoscaling,HttpLoadBalancing,CloudRun \<br/>--machine-type=n1-standard-2 \<br/>--zone=us-central1-a \<br/>--enable-stackdriver-kubernetes</span></pre><p id="9d3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后用<code class="du lw lx ly lz b">gcloud</code>命令行部署服务</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="b297" class="li kf hi lz b fi mi mj l mk ml">gcloud beta run deploy hello --cluster-location us-central1-a \<br/>    --image gcr.io/cloudrun-hello-go/hello \<br/>    --platform gke --connectivity external \<br/>    --cluster cloudrun-cluster</span></pre><p id="b52c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考验的时候到了！但是<strong class="is hj">在Kubernetes集群上测试Knative服务不像使用托管版本</strong>那么容易。有两件事要做:</p><ul class=""><li id="74a6" class="mn mo hi is b it iu ix iy jb mp jf mq jj mr jn ms mt mu mv bi translated">用于获取外部IP的<strong class="is hj">入口网关</strong>。这代表为接受入站流量而部署的负载平衡器。</li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="53a0" class="li kf hi lz b fi mi mj l mk ml">kubectl get svc istio-ingressgateway --namespace istio-system \<br/>   -o jsonpath='{.status.loadBalancer.ingress[0].ip}'</span></pre><ul class=""><li id="353e" class="mn mo hi is b it iu ix iy jb mp jf mq jj mr jn ms mt mu mv bi translated"><strong class="is hj">部署主机名</strong>。<em class="lh">在部署结束时提供。</em>它用于将流量路由到正确的服务和pod。</li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="91b7" class="li kf hi lz b fi mi mj l mk ml">kubectl get route.serving.knative.dev hello \<br/>    -o jsonpath='{.status.url}' | sed 's/http:\/\///g'</span></pre><p id="635d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，将所有这些放在一起，像这样请求端点</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="f9b4" class="li kf hi lz b fi mi mj l mk ml">curl -H "Host: $(kubectl get route.serving.knative.dev hello \<br/>   -o jsonpath='{.status.url}' | sed 's/http:\/\///g')" \<br/>   $(kubectl get svc istio-ingressgateway --namespace istio-system \<br/>   -o jsonpath='{.status.loadBalancer.ingress[0].ip}')</span><span id="ec04" class="li kf hi lz b fi mm mj l mk ml"># Result<br/>This created the revision hello-&lt;hash&gt; of the Cloud Run service hello in the GCP project &lt;project&gt;</span></pre></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="3592" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">伟大的<strong class="is hj">GKE上的云运行和托管的云运行是兼容的</strong>。<em class="lh">幸好(！！！)</em>，它们是2个Google云服务，使用了相同的CLI命令(对服务定义/特性做了一些更改)</p><h1 id="3a46" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">YAML教的普遍性</h1><p id="2e28" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">Google云环境的可移植性意味着<strong class="is hj">使用云提供商不可知的服务定义和部署</strong>。</p><p id="a6cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes使用<code class="du lw lx ly lz b"><strong class="is hj">YAML</strong></code> <strong class="is hj">文件格式向主节点</strong>声明集群的所有元素。当然，Knative也使用这种格式来定义服务。</p><h2 id="3f6a" class="li kf hi bd kg lj lk ll kk lm ln lo ko jb lp lq ks jf lr ls kw jj lt lu la lv bi translated">最小YAML</h2><p id="658d" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated"><a class="ae jo" href="https://knative.dev/docs/serving/getting-started-knative-app/" rel="noopener ugc nofollow" target="_blank">主动发球</a>有自己的发球定义。对于我们的测试，我定义了一个简单最小的<code class="du lw lx ly lz b"><a class="ae jo" href="https://github.com/guillaumeblaquiere/cloudrun-hello-go/blob/master/hello.yaml" rel="noopener ugc nofollow" target="_blank">hello.yaml</a></code>文件。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="474a" class="li kf hi lz b fi mi mj l mk ml">apiVersion: serving.knative.dev/v1<br/>kind: Service<br/>metadata:  <br/>  name: hello<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>      - image: gcr.io/cloudrun-hello-go/hello</span></pre><p id="bea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lh">注:你会在</em> <a class="ae jo" href="https://knative.dev/docs/serving/getting-started-knative-app/#configuring-your-deployment" rel="noopener ugc nofollow" target="_blank"> <em class="lh">中找到很多例子</em></a><em class="lh"/><code class="du lw lx ly lz b"><em class="lh">metadata.namespace</em></code><em class="lh">的值集。它是可选的。如果未设置，则部署时使用当前的</em> <code class="du lw lx ly lz b"><em class="lh">namespace</em></code> <em class="lh">，也可以用</em> <code class="du lw lx ly lz b"><em class="lh">--namespace</em></code> <em class="lh"> param显式定义。</em></p><h2 id="19f5" class="li kf hi bd kg lj lk ll kk lm ln lo ko jb lp lq ks jf lr ls kw jj lt lu la lv bi translated">云运行管理</h2><p id="3a89" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">2020年初，谷歌在测试版<strong class="is hj">中发布了使用YAML文件来定义和部署服务</strong>的功能(<em class="lh">和</em> <em class="lh">这是Alpha测试人员</em>反复提出的要求之一)。</p><p id="c04d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du lw lx ly lz b">gcloud</code>命令行应用<code class="du lw lx ly lz b">yaml</code>。<em class="lh">对于云运行托管版本，没有其他方法可以与完全托管的集群进行交互。</em></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="686b" class="li kf hi lz b fi mi mj l mk ml">gcloud beta run services replace hello.yaml --platform managed \<br/>  --region us-central1 </span></pre><p id="2f12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该命令行应用<code class="du lw lx ly lz b">yaml</code>文件<strong class="is hj">来创建或更新(如果存在)服务</strong>，但不允许定制访问模式。<code class="du lw lx ly lz b">replace</code>命令只是<strong class="is hj">应用</strong> <code class="du lw lx ly lz b"><strong class="is hj">yaml</strong></code> <strong class="is hj">配置，而不与Google IAM服务</strong>交互以允许未经授权的用户。顺便说一下，测试可以用以下两种方法进行:</p><ul class=""><li id="5829" class="mn mo hi is b it iu ix iy jb mp jf mq jj mr jn ms mt mu mv bi translated">通过在报头中添加id令牌来执行经过身份验证的请求</li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="10f3" class="li kf hi lz b fi mi mj l mk ml">curl -H "Authorization: Bearer $(gcloud auth print-identity-token)"\<br/>    https://hello-&lt;project hash&gt;.run.app/</span></pre><ul class=""><li id="dfe7" class="mn mo hi is b it iu ix iy jb mp jf mq jj mr jn ms mt mu mv bi translated">允许所有未经身份验证的用户使用IAM命令，然后执行未经身份验证的请求</li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="3c4a" class="li kf hi lz b fi mi mj l mk ml">gcloud beta run services add-iam-policy-binding hello-yaml \<br/>    --member allUsers --role roles/run.invoker --region us-central1</span><span id="ca09" class="li kf hi lz b fi mm mj l mk ml">curl https://hello-&lt;project hash&gt;.run.app/</span></pre><p id="c512" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果是一样的</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="3205" class="li kf hi lz b fi mi mj l mk ml"># Result<br/>This created the revision hello-yaml-00001 of the Cloud Run service hello-yaml in the GCP project &lt;project&gt;</span></pre><p id="3576" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj">托管平台上，已经正确应用了</strong> <code class="du lw lx ly lz b"><strong class="is hj">hello.yaml</strong></code> <strong class="is hj">文件，部署了</strong>服务。继续使用其他平台</p><h2 id="e8c4" class="li kf hi bd kg lj lk ll kk lm ln lo ko jb lp lq ks jf lr ls kw jj lt lu la lv bi translated">GKE和云一起奔向安索斯</h2><p id="4abb" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">回到安装了云运行附加组件的GKE平台。当然，谷歌的目标是<strong class="is hj">在托管平台和GKE平台上提供同样的体验</strong>，同样的<code class="du lw lx ly lz b">replace</code>命令也适用于GKE集群。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="fa8e" class="li kf hi lz b fi mi mj l mk ml">gcloud beta run services replace hello.yaml --platform gke <br/>  --cluster-location us-central1-a --cluster k8s-cluster</span></pre></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="f365" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这一次，<strong class="is hj">我不想粘着谷歌</strong>。<em class="lh">这是云运行托管版本所必需的，因为我没有其他解决方案来与托管集群进行交互。</em></p><p id="69ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这一次，我们有一个Kubernetes集群，我们可以使用专用工具。<code class="du lw lx ly lz b"><strong class="is hj">kubectl</strong></code> <strong class="is hj">是与Kubernetes集群交互的标准CLI工具。</strong></p><p id="1062" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes是一个声明性模型。由此，<strong class="is hj">我们将</strong> <code class="du lw lx ly lz b"><strong class="is hj">apply</strong></code> <strong class="is hj">配置给主节点，它执行适当的动作</strong>。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="d3b3" class="li kf hi lz b fi mi mj l mk ml">kubectl apply -f hello.yaml</span></pre><p id="3d8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，服务已经创建，为了测试它，我们可以重用以前的GKE命令行。<em class="lh">不要忘记将服务的名称改为</em> <code class="du lw lx ly lz b"><em class="lh">hello-yaml</em></code></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="b60f" class="li kf hi lz b fi mi mj l mk ml">curl -H "Host: $(kubectl get route.serving.knative.dev hello-yaml \<br/>   -o jsonpath='{.status.url}' | sed 's/http:\/\///g')" \<br/>   $(kubectl get svc istio-ingressgateway --namespace istio-system \<br/>   -o jsonpath='{.status.loadBalancer.ingress[0].ip}')</span><span id="bcf2" class="li kf hi lz b fi mm mj l mk ml"># Result<br/>This created the revision hello-yaml-&lt;hash&gt; of the Cloud Run service hello-yaml in the GCP project &lt;project&gt;</span></pre><p id="2ce1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完美！但是，<strong class="is hj">由于安装了Cloud Run附加组件，该集群GKE并不真正与GCP无关。我们能用更中性的东西吗？</strong></p><h2 id="22a9" class="li kf hi bd kg lj lk ll kk lm ln lo ko jb lp lq ks jf lr ls kw jj lt lu la lv bi translated">GKE与Istio和Knative</h2><p id="84db" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">为此，我们将<strong class="is hj">部署一个没有安装Google插件的新集群</strong>。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="3989" class="li kf hi lz b fi mi mj l mk ml">gcloud beta container clusters create k8s-cluster<strong class="lz hj"> </strong>\<br/>--machine-type=n1-standard-2 \<br/>--zone=us-central1-a \<br/>--enable-stackdriver-kubernetes</span></pre><p id="dedf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在安装Knative之前，需要I <a class="ae jo" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> stio </a></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="a6e1" class="li kf hi lz b fi mi mj l mk ml"># <a class="ae jo" href="https://istio.io/docs/setup/#downloading-the-release" rel="noopener ugc nofollow" target="_blank">Download Istio</a><br/>curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.3.1 sh -</span><span id="82a7" class="li kf hi lz b fi mm mj l mk ml"># Go into directory<br/>cd istio-1.3.1</span><span id="37d5" class="li kf hi lz b fi mm mj l mk ml"># <a class="ae jo" href="https://istio.io/docs/setup/install/kubernetes/" rel="noopener ugc nofollow" target="_blank">Install Istio</a><br/>for i in install/kubernetes/helm/istio-init/files/crd*yaml; \<br/>    do kubectl apply -f $i; done</span><span id="4cec" class="li kf hi lz b fi mm mj l mk ml"># Activate the permissive mode (enough for the test)<br/>kubectl apply -f install/kubernetes/istio-demo.yaml</span></pre><p id="78a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，<a class="ae jo" href="https://knative.dev/docs/install/knative-with-any-k8s/" rel="noopener ugc nofollow" target="_blank">在任何Kubernetes集群上安装Knative </a>。</p><p id="2431" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和以前一样，<strong class="is hj">使用Kubectl来应用服务配置</strong></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="7f45" class="li kf hi lz b fi mi mj l mk ml">kubectl apply -f hello.yaml</span></pre><p id="e59f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，测试一下</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="0a0f" class="li kf hi lz b fi mi mj l mk ml">curl -H "Host: $(kubectl get route.serving.knative.dev hello-yaml \<br/>   -o jsonpath='{.status.url}' | sed 's/http:\/\///g')" \<br/>   $(kubectl get svc istio-ingressgateway --namespace istio-system \<br/>   -o jsonpath='{.status.loadBalancer.ingress[0].ip}')</span><span id="b7aa" class="li kf hi lz b fi mm mj l mk ml"># Result<br/>This created the revision hello-yaml-&lt;hash&gt; of the Cloud Run service hello-yaml in the GCP project &lt;project&gt;</span></pre><p id="4192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！但是，<strong class="is hj">还是在谷歌云环境下。</strong>这些测试是否存在偏差？我们去别的地方测试吧。</p><h1 id="ecbf" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">所有kubernetes集群？</h1><p id="3c17" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">这里是最后一个挑战:这个简单的YAML是否仍然符合谷歌云环境。为了验证这一点，我选择在亚马逊网络服务的<a class="ae jo" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> EKS产品上验证这一点。</a></p><p id="47e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在Medium 上跟随<a class="ae jo" rel="noopener" href="/faun/create-your-first-application-on-aws-eks-kubernetes-cluster-874ee9681293">这篇教程，部署一个Kubernetes集群需要大约20分钟的时间，还需要一些手动操作。您还可以使用</a><a class="ae jo" href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started-eksctl.html" rel="noopener ugc nofollow" target="_blank"> eksctl，通过一行CLI </a>来部署您的集群，这更加简单快捷，但不是通过GUI。</p></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="f041" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您的集群被部署，并且节点链接到您的主节点时，我的意思是当命令<code class="du lw lx ly lz b">kubectl get nodes</code>返回3行带有<code class="du lw lx ly lz b">READY</code>状态的代码时，<strong class="is hj">您可以用与之前在GKE上相同的方式安装Istio和Knative </strong>。</p><p id="ec22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和以前一样，<strong class="is hj">使用Kubectl来应用服务配置</strong></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="a7e1" class="li kf hi lz b fi mi mj l mk ml">kubectl apply -f hello.yaml</span></pre><p id="9135" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且，测试一下。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="1183" class="li kf hi lz b fi mi mj l mk ml">curl -H "Host: $(kubectl get route.serving.knative.dev hello-yaml \<br/>   -o jsonpath='{.status.url}' | sed 's/http:\/\///g')" \<br/>   $(kubectl get svc istio-ingressgateway --namespace istio-system \<br/>   -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')</span><span id="d5b9" class="li kf hi lz b fi mm mj l mk ml"># Result<br/>This created the revision hello-yaml-&lt;hash&gt; of the Cloud Run service hello-yaml</span></pre><p id="d08f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lh">注意:</em></strong><em class="lh">Istio Ingress Gateway在EKS环境上提供了一个</em> <code class="du lw lx ly lz b"><em class="lh">hostname</em></code> <em class="lh">，而不是像在GKE上那样提供一个</em> <code class="du lw lx ly lz b"><em class="lh">IP</em></code> <em class="lh">。从一个提供者到另一个提供者，底层实现可能略有不同。</em></p><h1 id="a772" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">无处不在的服务器</h1><p id="19f7" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated"><strong class="is hj">最后，是的</strong>，相同的<code class="du lw lx ly lz b">hello.yaml</code>文件已经被部署在4个不同的Knative兼容环境中，服务以完全相同的方式工作。</p><p id="e752" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，在这些示例中，为了更容易测试，<strong class="is hj"/><code class="du lw lx ly lz b"><strong class="is hj">hello</strong></code><strong class="is hj">容器是独立于平台的，并且允许避免集成约束</strong>:不需要IAM角色来访问特定资源，如数据库、存储或其他无服务器产品。</p><p id="992f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不管怎么说，太牛逼了！Knative项目非常棒，确保了很好的兼容性。带有<code class="du lw lx ly lz b">kubectl</code>的Kubernetes CLI命令对于部署和请求服务是相同的！<strong class="is hj">容器一次，无服务器随地”是真的，而便携性，成为现实！</strong></p><p id="42b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是未来的良好基础。<strong class="is hj">事件、调试和其他重要的东西正在Kubernetes、Knative和Cloud Run </strong>平台中到来。敬请期待，下一个版本将会很棒！</p></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="cbbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lh">Github</em><em class="lh">上有</em> <a class="ae jo" href="https://github.com/guillaumeblaquiere/cloudrun-hello-go" rel="noopener ugc nofollow" target="_blank"> <em class="lh">的源代码。代码是一个</em> </a><a class="ae jo" href="https://github.com/GoogleCloudPlatform/cloud-run-hello" rel="noopener ugc nofollow" target="_blank"> <em class="lh">云-运行-你好</em> </a> <em class="lh">的分支，但是没有HTML模板。</em></p></div></div>    
</body>
</html>