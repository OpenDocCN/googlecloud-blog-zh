<html>
<head>
<title>Breaking up very large BigQuery jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解非常大的BigQuery作业</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/breaking-up-very-large-bigquery-jobs-ea1ccc720a7?source=collection_archive---------1-----------------------#2020-07-06">https://medium.com/google-cloud/breaking-up-very-large-bigquery-jobs-ea1ccc720a7?source=collection_archive---------1-----------------------#2020-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="746c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过BigQuery脚本使用整数范围分区</h2></div><p id="c715" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我最近在处理一个BigQuery用例，它需要一个非常大的、<a class="ae jt" href="https://cloud.google.com/bigquery/docs/best-practices-performance-patterns#data_skew" rel="noopener ugc nofollow" target="_blank">偏斜的、</a>、多对多的连接，导致扇出超过1800亿条记录。受2000个<a class="ae jt" href="https://cloud.google.com/bigquery/docs/slots" rel="noopener ugc nofollow" target="_blank">插槽</a>限制的随需应变项目经常会在查询完成之前超时。<a class="ae jt" href="https://cloud.google.com/bigquery/query-plan-explanation" rel="noopener ugc nofollow" target="_blank">查询计划</a>将此问题识别为字节溢出到磁盘和流水线重新分区阶段，其中一个重新分区阶段的输出是另一个重新分区阶段的输入。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/8979e74417915d2c5cf3dd5831b8e694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aitftMFKimQ7t0vE"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated"><em class="kk">流水线再分配:级0A读取级09的输出</em></figcaption></figure><p id="1a2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个关于如何解决这些问题的快速教程；使用BigQuery的<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting" rel="noopener ugc nofollow" target="_blank">脚本</a>和i <a class="ae jt" href="https://cloud.google.com/bigquery/docs/creating-integer-range-partitions" rel="noopener ugc nofollow" target="_blank">整数范围分区</a>特性来有效地分解大型查询。</p><h2 id="00dd" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated"><strong class="ak">设置</strong></h2><p id="19cc" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">BigQuery的OpenStreetMap (OSM)公共数据集提供了一个方便的示例数据集来执行具有高扇出的昂贵连接，例如地理空间距离上的连接。为了使数据集更易于管理，我过滤了丹麦(国家代码:DK)节点上的数据，丹麦有高度集中的OSM节点条目。</p><pre class="jv jw jx jy fd ll lm ln lo aw lp bi"><span id="bad5" class="kl km hi lm b fi lq lr l ls lt">CREATE TABLE `mydataset.osm_nodes_dk`<br/>AS <br/>(<br/>  SELECT *<br/>  FROM `bigquery-public-data.geo_openstreetmap.planet_nodes`<br/>  WHERE EXISTS (<br/>    SELECT 1<br/>    FROM unnest(all_tags)<br/>    WHERE key = 'addr:country'<br/>    AND value = 'DK'<br/>  )<br/>)</span></pre><p id="aebb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目标是将每个实体连接到数据集中所有相关的实体，这样服务就可以比较每个匹配对的内容。随着表大小的增加，用于相互比较的查询作业的规模呈指数增长。</p><p id="fa02" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lu">作者注:相似性搜索，以及他们创建的固有的</em> <a class="ae jt" href="https://cloud.google.com/bigquery/docs/best-practices-performance-patterns#cross_joins_cartesian_product" rel="noopener ugc nofollow" target="_blank"> <em class="lu">交叉连接</em> </a> <em class="lu">，并不是地理空间数据所独有的，可以在零售、通过相关产品代码匹配销售或</em> <a class="ae jt" rel="noopener" href="/google-cloud/a-journey-into-bigquery-fuzzy-matching-1-of-1-soundex-b5b89087eae2"> <em class="lu">模糊文本匹配</em> </a> <em class="lu">等领域中看到。</em></p><pre class="jv jw jx jy fd ll lm ln lo aw lp bi"><span id="08ce" class="kl km hi lm b fi lq lr l ls lt">select<br/>    a.id,<br/>    a.geometry,<br/>    a.all_tags,<br/>    b.id as comp_id,<br/>    b.geometry as comp_geo,<br/>    b.all_tags as comp_tags<br/>FROM<br/>    `mydataset.osm_nodes_dk` a<br/>INNER JOIN<br/>    `mydataset.osm_nodes_dk` b<br/>ON<br/>    ST_DISTANCE(a.geometry, b.geometry) &lt;= 5000</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lv"><img src="../Images/ce91397e41b8c5bdcbe77456db2ae123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c0x1SZxwfydxf3UJ"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">54分钟和24TB的泄漏</figcaption></figure><p id="bfb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个基本查询适用于几百万条记录，但当表的大小增长到几十或几亿条记录时，这个查询就会失败。正如以这种方式查询完整的<code class="du lw lx ly lm b">bigquery-public-data.geo_openstreetmap.planet_nodes</code>表所看到的。</p><h2 id="2489" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">拆分大型查询作业</h2><p id="9d7c" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">为了防止磁盘溢出，理想的做法是在与整个表集进行比较时，一次有效地寻址表的一块。寻址整数范围分区很容易编写脚本，并且在查询谓词中使用时可以立即删除记录。</p><p id="3e07" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">BigQuery表被限制在<a class="ae jt" href="https://cloud.google.com/bigquery/quotas#partitioned_tables" rel="noopener ugc nofollow" target="_blank"> 4000个分区</a>；该DDL语句将创建该表的分区版本。添加的range_id列将是一个介于0和3999之间的确定值，并且应该在数据允许的范围内均匀分布。下面使用的技术借用了这个<a class="ae jt" rel="noopener" href="/google-cloud/partition-on-any-field-with-bigquery-840f8aa1aaab">博客</a>。</p><pre class="jv jw jx jy fd ll lm ln lo aw lp bi"><span id="c098" class="kl km hi lm b fi lq lr l ls lt">CREATE TABLE `mydataset.osm_dk_irp`<br/>PARTITION BY RANGE_BUCKET(range_id, GENERATE_ARRAY(0, 3999, 1))<br/>AS (<br/>  SELECT *, <br/>      ABS(MOD(FARM_FINGERPRINT(CAST(id as STRING)), 4000)) range_id <br/>  FROM `mydataset.osm_nodes_dk`<br/>)</span></pre><p id="e952" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作业代码在<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting#while" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">中汇编全部结果，而</strong>循环</a>；其中每次迭代过滤一个由增量变量确定大小的分区块。在执行完整作业之前，应该测试增量大小，使其不小于避免溢出和深度流水线重分区所需的大小。</p><pre class="jv jw jx jy fd ll lm ln lo aw lp bi"><span id="36e1" class="kl km hi lm b fi lq lr l ls lt">DECLARE max_partition int64 DEFAULT 3999;<br/>DECLARE increment int64 DEFAULT 50;<br/>DECLARE start int64 DEFAULT 0;</span><span id="7ae2" class="kl km hi lm b fi lz lr l ls lt">CREATE OR REPLACE TABLE `mydataset.osm_irp_join`<br/>(<br/>  id INT64,<br/>  geometry GEOGRAPHY,<br/>  all_tags ARRAY&lt;STRUCT&lt;key STRING, value STRING&gt;&gt;,<br/>  comp_id INT64,<br/>  comp_geo GEOGRAPHY,<br/>  comp_tags ARRAY&lt;STRUCT&lt;key STRING, value STRING&gt;&gt;<br/>);</span><span id="8c3c" class="kl km hi lm b fi lz lr l ls lt">WHILE start &lt;= max_partition DO<br/>  <br/>  INSERT INTO mydataset.osm_irp_join<br/>    SELECT<br/>      a.id,<br/>      a.geometry,<br/>      a.all_tags,<br/>      b.id as comp_id,<br/>      b.geometry as comp_geo,<br/>      b.all_tags as comp_tags<br/>    FROM <br/>      `mydataset.osm_dk_irp` a<br/>    INNER JOIN <br/>      `mydataset.osm_dk_irp` b    <br/>      ON <br/>        ST_DISTANCE(a.geometry, b.geometry) &lt;= 5000<br/>    WHERE <br/>      a.range_id between start and start + increment - 1;</span><span id="c2a6" class="kl km hi lm b fi lz lr l ls lt">  SET start = start + increment;</span><span id="4857" class="kl km hi lm b fi lz lr l ls lt">END WHILE;</span><span id="7fa2" class="kl km hi lm b fi lz lr l ls lt">--SELECT * FROM `mydataset.osm_irp_join`</span></pre><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ma"><img src="../Images/3d55edee0ff1846fb458e6e58b0c91a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*waiebrpX4NV7aaKe"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated"><em class="kk">脚本作业运行时间不到14分钟，速度提高70%</em></figcaption></figure><p id="ae2c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仔细查看其中一个子作业的结果，没有溢出任何字节，只有一个重新分区阶段。该作业只需重组数据一次，并且可以完全在内存中完成。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mb"><img src="../Images/973d502b651cd1a61665cf205c2a9402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cFCrv-jIQHgFkiQR"/></div></div></figure><h2 id="e5a1" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated"><strong class="ak">选择增量大小</strong></h2><p id="b739" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我建议您使用不同的增量大小运行一些测试，以了解增量大小将如何影响您的性能。这些屏幕截图比较了该作业中分区范围为50、250和500的单个查询。随着增量大小的增加，总吞吐量应该会增加，但当字节溢出到磁盘时，总吞吐量可能会大幅下降。</p><p id="d1a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lu">提示:BigQuery on-demand不是一个干净的房间，等待时间和</em> <a class="ae jt" href="https://cloud.google.com/bigquery/docs/release-notes#December_10_2019" rel="noopener ugc nofollow" target="_blank"> <em class="lu">突发</em> </a> <em class="lu">等不可预测的因素会影响您的结果。</em></p><ul class=""><li id="aa4d" class="mc md hi iz b ja jb jd je jg me jk mf jo mg js mh mi mj mk bi translated">50分36秒(1.38秒/秒)，溢出0个字节</li><li id="35de" class="mc md hi iz b ja ml jd mm jg mn jk mo jo mp js mh mi mj mk bi translated">250: 2分钟(每秒2.08秒)，溢出0个字节</li><li id="6d90" class="mc md hi iz b ja ml jd mm jg mn jk mo jo mp js mh mi mj mk bi translated">500分钟:7分钟(每秒1.19秒)，溢出4.04 TB</li></ul><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mq"><img src="../Images/2c7f72f496eeea9621fc394a8182a9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t-2z-mNwmJue48Ak"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated"><em class="kk">增量500 (7分钟)</em></figcaption></figure><h2 id="5427" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated"><strong class="ak">最终想法</strong></h2><p id="78bc" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">BigQuery动态重分发数据的能力允许它完成非常复杂的查询，而不需要任何额外的用户努力。但是，在有些情况下，被打乱的数据量会淹没可用的片段，从而导致溢出、连续的重新分区和查询时间变慢。</p><p id="3a6b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里描述的技术应该与重写大型查询一起考虑，以使用像<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/analytic-function-concepts" rel="noopener ugc nofollow" target="_blank">分析函数</a>这样的特性，并调用<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reservations-workload-management#getting-started-with-bigquery-reservations" rel="noopener ugc nofollow" target="_blank">预留API </a>来分配适当数量的专用槽。</p></div></div>    
</body>
</html>