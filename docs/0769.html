<html>
<head>
<title>Dialogflow fulfillment with C# and App Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C#和App Engine实现对话流</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/dialogflow-fulfillment-with-c-and-app-engine-18eb7db071de?source=collection_archive---------1-----------------------#2018-09-24">https://medium.com/google-cloud/dialogflow-fulfillment-with-c-and-app-engine-18eb7db071de?source=collection_archive---------1-----------------------#2018-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class="ev ex if ig ih ab cb"><figure class="ii ij ik il im in io paragraph-image"><div role="button" tabindex="0" class="ip iq di ir bf is"><img src="../Images/eec48aac45071245d6ef2cee3f8baf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*qekeTye0yYkwNQqTrdc46g.jpeg"/></div></figure><figure class="ii ij iv il im in io paragraph-image"><div role="button" tabindex="0" class="ip iq di ir bf is"><img src="../Images/1d711936ba3af725c73446888d523e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*Qa2RQl3VgBual_IJgh8ADQ.png"/></div></figure><figure class="ii ij iw il im in io paragraph-image"><div role="button" tabindex="0" class="ip iq di ir bf is"><img src="../Images/1b5e28e9945a4a5029ccc31b6c163190.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*eMkiv4EGJGTsR0H1l5WFGw.png"/></div></figure></div><p id="fa4d" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><a class="ae jv" href="https://dialogflow.com/" rel="noopener ugc nofollow" target="_blank"> Dialogflow </a>是一个开发者平台，用于在许多平台上构建基于语音或文本的对话应用，如Google Assistant、Facebook Messenger、Twilio、Skype等。今年早些时候，我们使用Dialogflow构建了一个谷歌助手应用程序，并将其扩展为使用谷歌云的功能。你可以在谷歌云博客<a class="ae jv" href="https://cloud.google.com/blog/products/gcp/google-home-meets-net-containers-using-dialogflow" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多信息，在GitHub <a class="ae jv" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/tree/master/applications/googlehome-meets-dotnetcontainers" rel="noopener ugc nofollow" target="_blank">这里</a>查看应用代码，在这里<a class="ae jv" href="https://youtu.be/dd19Gw4WDkU?list=PLQjaCpWNuxVmS_FV4q1aSrZMDuv5-U_FH" rel="noopener ugc nofollow" target="_blank">是我关于应用的一个视频。</a></p><p id="f237" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">Dialogflow提供了开箱即用的特性，例如用于匹配用户输入和响应的<a class="ae jv" href="https://dialogflow.com/docs/intents" rel="noopener ugc nofollow" target="_blank">意图</a>，从对话中提取相关信息的<a class="ae jv" href="https://dialogflow.com/docs/entities" rel="noopener ugc nofollow" target="_blank">实体</a>，维护对话状态的<a class="ae jv" href="https://dialogflow.com/docs/contexts" rel="noopener ugc nofollow" target="_blank">上下文</a>。它还提供了一种通过<a class="ae jv" href="https://dialogflow.com/docs/fulfillment" rel="noopener ugc nofollow" target="_blank">实现</a>来扩展其功能的方法。</p><h1 id="96b7" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">完成</h1><p id="d560" class="pw-post-body-paragraph ix iy hi iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hb bi translated">实现是一个HTTPS webhook，Dialogflow可以将请求转发给它。从那时起，您的代码负责处理请求并生成响应。这对于定制逻辑或向应用程序引入更多智能/数据非常有用。在我们的应用程序中，我们使用fulfillment通过谷歌自定义搜索来搜索图像，使用<a class="ae jv" href="https://cloud.google.com/vision/" rel="noopener ugc nofollow" target="_blank"> Vision API </a>通过机器学习来分析图像，并使用<a class="ae jv" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>执行丰富的数据分析。</p><p id="db52" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">实现fulfillment webhook的一个简单方法是通过Dialogflow控制台中的<a class="ae jv" href="https://dialogflow.com/docs/getting-started/integrate-services-actions-on-google" rel="noopener ugc nofollow" target="_blank">内嵌编辑器</a>。内联编辑器使您能够编写一个Node.js函数来处理Dialogflow请求，并使用Firebase 将其部署到<a class="ae jv" href="https://firebase.google.com/docs/functions/" rel="noopener ugc nofollow" target="_blank">云函数(详见</a><a class="ae jv" href="https://codelabs.developers.google.com/codelabs/actions-1/" rel="noopener ugc nofollow" target="_blank">本代码实验室</a>)。虽然内联编辑器很简单，但它只允许一个webhook，而且对开发人员不友好。理想情况下，您应该在本地开发代码，并使用某种版本控制。</p><p id="8516" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">您可以设置一个本地环境，并使用Firebase将该功能部署到云功能中。虽然这是一个更现实的设置，但它仍然受到云功能限制的约束，Node.js是唯一可以使用的语言。</p><h1 id="946e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">实现的应用程序引擎</h1><p id="94dd" class="pw-post-body-paragraph ix iy hi iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hb bi translated">在我们的应用中，我们采用了不同的方法来实现webhook。我们决定使用C#而不是Node.js，并且为了更大的灵活性，我们将我们的应用程序容器化并部署到App Engine。</p><p id="e284" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">由于它是一个容器，我们也可以部署到Kubernetes引擎，但我们选择了App Engine，因为:</p><ol class=""><li id="f10d" class="kz la hi iz b ja jb je jf ji lb jm lc jq ld ju le lf lg lh bi translated">App Engine以最少的麻烦为我们提供了开箱即用的HTTPS端点，而Kubernetes Engine HTTPS设置并不简单。</li><li id="5e34" class="kz la hi iz b ja li je lj ji lk jm ll jq lm ju le lf lg lh bi translated">App Engine中的版本控制允许我们轻松地更新和部署我们的应用程序，测试它，并在我们准备好的时候将所有流量转发到新版本。</li></ol><h1 id="a596" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">用C#实现HelloWorld</h1><p id="edcb" class="pw-post-body-paragraph ix iy hi iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hb bi translated">为了让您了解如何使用C#在AppEngine上编写Dialogflow fulfillment，让我们编写一个HelloWorld fulfillment webhook。</p><p id="0728" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">首先，您需要首先创建一个ASP.NET核心web应用程序:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="2f52" class="lw jx hi ls b fi lx ly l lz ma">dotnet new web -n fulfillment</span></pre><p id="d3de" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">并将<a class="ae jv" href="https://www.nuget.org/packages/Google.Cloud.Dialogflow.V2" rel="noopener ugc nofollow" target="_blank"> Dialogflow NuGet包</a>添加到项目中。这个包将允许我们解析来自Dialogflow的请求并生成响应:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="480e" class="lw jx hi ls b fi lx ly l lz ma">dotnet add package Google.Cloud.Dialogflow.V2 --version 1.0.0-beta02</span></pre><p id="9c62" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在，我们可以编辑Startup.cs文件并添加逻辑来处理Dialogflow请求。我们需要首先参考Dialogflow NuGet库及其一些依赖项:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="6f1b" class="lw jx hi ls b fi lx ly l lz ma">using Google.Cloud.Dialogflow.V2;<br/>using Google.Protobuf;<br/>using System.IO;</span></pre><p id="67e1" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然后，我们需要创建一个Protobuf jsonParser，我们将使用它来解析HTTP请求的主体:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="0b3c" class="lw jx hi ls b fi lx ly l lz ma">private static readonly JsonParser jsonParser = new JsonParser(JsonParser.Settings.Default.WithIgnoreUnknownFields(true));</span></pre><p id="835f" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">最后，让我们更改Configure方法来解析来自Dialogflow的请求，并简单地回显一条带有目的名称的Hello消息:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="640a" class="lw jx hi ls b fi lx ly l lz ma">app.Run(async (context) =&gt; { <br/>   WebhookRequest request; <br/>   using (var reader = new StreamReader(context.Request.Body))<br/>   { <br/>      request = jsonParser.Parse&lt;WebhookRequest&gt;(reader); <br/>   } </span><span id="e505" class="lw jx hi ls b fi mb ly l lz ma">   var response = new WebhookResponse <br/>   { <br/>     FulfillmentText = "Hello from " + request.QueryResult.Intent.DisplayName <br/>    }; <br/>   <br/>   await context.Response.WriteAsync(response.ToString()); <br/>});</span></pre><p id="8bbd" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">注意HTTP请求体是如何被解析为WebhookRequest的。这是Dialogflow发送给我们的代码的请求。作为响应，我们用FulfillmentText创建一个WebhookResponse并发回。Dialogflow将使用FulfillmentText来表达我们的要求。</p><h1 id="4beb" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">部署到应用引擎</h1><p id="e0a7" class="pw-post-body-paragraph ix iy hi iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hb bi translated">现在，我们准备将代码部署到App Engine。我们需要先发布应用程序:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="0be9" class="lw jx hi ls b fi lx ly l lz ma">dotnet publish -c Release</span></pre><p id="3b89" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这将在bin/Release/netcoreapp2.0/publish/文件夹中创建一个DLL。在此文件夹中，为App Engine创建一个app.yaml文件，内容如下:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="0e07" class="lw jx hi ls b fi lx ly l lz ma">env: flex<br/>runtime: aspnetcore</span></pre><p id="b071" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这将告诉App Engine这是一个ASP.NET核心应用程序，它应该部署到App Engine flex。</p><p id="a334" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">最后，部署到App Engine，我们称这个初始版本为v0:</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="d916" class="lw jx hi ls b fi lx ly l lz ma">gcloud app deploy --version v0</span></pre><p id="03d0" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">部署完成后，您将拥有一个形式为<a class="ae jv" href="https://meteatamel.wordpress.com/2018/09/24/dialogflow-fulfillment-with-c-and-app-engine/%3Cyourprojectid&amp;gt" rel="noopener ugc nofollow" target="_blank">https://your projectid</a>. appspot . com的HTTPS端点，您可以在Dialogflow中使用fulfillment webhook。</p><h1 id="7572" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">使用Dialogflow测试</h1><p id="c862" class="pw-post-body-paragraph ix iy hi iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hb bi translated">我们终于准备好测试我们的实现webhook了。在对话流控制台中，指定实现url:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ip iq di ir bf is"><div class="er es mc"><img src="../Images/9ea1c35db112a7b60c2914a8d25478b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ctu2nB5vg93g3pcolHAuIw.png"/></div></div></figure><p id="c22c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然后，用一些训练短语创造一个意图:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ip iq di ir bf is"><div class="er es md"><img src="../Images/46186d735c3654ec9f899110c67c2824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PcKbFPrIcloIC8yY"/></div></div></figure><p id="a780" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">最后，确保为意图启用了fulfillment webhook:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es me"><img src="../Images/62f1688749dd069824c7e400ed2759e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*_RbR0HJMyEvNgBgx165yvQ.png"/></div></figure><p id="f3df" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们可以使用Dialogflow控制台中的模拟器来测试其意图:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/f064c35516cfff78ab98d7990d4b9af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*SrmDR_5zXFASksHUy86NWQ.png"/></div></figure><p id="dc4d" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">当我们说“你好。这触发了webhook，我们的webhook代码简单地回显了intent名称，在本例中是“hello c# intent”。</p><p id="d6db" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">显然，现实世界中的webhook不仅仅是简单的回复。例如，您需要跟踪用户会话，并根据这些会话获取或创建对话(参见GitHub上我们应用程序的<a class="ae jv" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/applications/googlehome-meets-dotnetcontainers/GoogleHomeAspNetCoreDemoServer/Dialogflow/DialogflowApp.cs#L96" rel="noopener ugc nofollow" target="_blank"> DialogflowApp </a>)。你还需要找到一种方法将意图与服务器上的处理程序相匹配(参见GitHub上我们应用程序的<a class="ae jv" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/applications/googlehome-meets-dotnetcontainers/GoogleHomeAspNetCoreDemoServer/Dialogflow/Conversation.cs#L98" rel="noopener ugc nofollow" target="_blank">对话</a>)。</p><p id="763a" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">希望这篇博文提供了使用C#和App Engine开始使用fulfillment webhook的基础知识。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="3670" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><em class="mn">原载于2018年9月24日</em><a class="ae jv" href="https://meteatamel.wordpress.com/2018/09/24/dialogflow-fulfillment-with-c-and-app-engine/" rel="noopener ugc nofollow" target="_blank"><em class="mn">meteatamel.wordpress.com</em></a><em class="mn">。</em></p></div></div>    
</body>
</html>