<html>
<head>
<title>Continuous Delivery in Google Cloud Platform — Cloud Run with Kubernetes Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google云平台中的持续交付—使用Kubernetes引擎的云运行</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-run-with-kubernetes-engine-49b73577ef0f?source=collection_archive---------0-----------------------#2019-05-20">https://medium.com/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-run-with-kubernetes-engine-49b73577ef0f?source=collection_archive---------0-----------------------#2019-05-20</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><p id="61c9" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这是我正在撰写的关于GCP持续交付系列的第三篇文章(参见<a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5">第一部分:应用引擎</a> &amp; <a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-compute-engine-a95bf4fd1821">第二部分:计算引擎</a>)，我必须说:最难写的。不是因为这个主题不有趣、过时或者已经被广泛探索过。相反，Kubernetes周围有一个伟大的氛围！此外，新工具经常发布，概念和更好的实践发展很快，这使得在Kubernetes上讲述一个引人注目而又简明的持续交付历史变得特别具有挑战性。</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et jf"><img src="../Images/a29d6fc9173e0c1f325b5c4947100837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ki0pzJfj5xuxghh_Q3hSgw.png"/></div></div></figure><p id="c790" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">也就是说，我将像在以前的文章中一样描述一个简单的逐步连续交付设置，在本例中由最近推出的<a class="ae je" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank">云运行</a>提供支持。给点脉络，我给你讲个(非常！)缩短了在Kubernetes上建造的贵重工具的历史。相信我:Kubernetes在微服务架构方面给人留下了深刻的印象，但将其付诸实施并不是一件容易的事情。</p></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="c37f" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">Kubernetes上的经典CD</strong></h1><p id="a4fb" class="pw-post-body-paragraph ig ih hj ii b ij kw il im in kx ip iq ir ky it iu iv kz ix iy iz la jb jc jd hc bi translated">让我们从Kelsey Hightower在<a class="ae je" href="https://www.youtube.com/watch?v=XL9CQobFB8I" rel="noopener ugc nofollow" target="_blank">Google Cloud Next’17</a>和<a class="ae je" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build" rel="noopener ugc nofollow" target="_blank">Google Kubernetes引擎文档</a>中详细介绍的已知Kubernetes连续交付流程开始。它使用2个git存储库:一个保存应用程序代码；另一个保存环境配置。这种模型被称为<strong class="ii hk"> GitOps </strong>并以代码的形式启用<strong class="ii hk">环境，这是一种部署模型，允许DevOps团队自动部署并在需要时安全地回滚更改。下图总结了其在GKE的实施情况:</strong></p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et lb"><img src="../Images/7afebc541c6036579ac5b6fca2fd373e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORPRxbCRcL-Y-65ApxC_2g.png"/></div></div></figure><p id="aa29" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">组件2和4负责跟踪所有候选版本和成功部署的版本。基本上，当新代码被推送到Git存储库(1)时，<a class="ae je" href="https://cloud.google.com/cloud-build/" rel="noopener ugc nofollow" target="_blank"> Cloud Build </a>生成一个新映像并将其推送到(2)容器注册表(3)，<strong class="ii hk">标记有触发构建的提交的SHA指纹</strong>。之后，它通过设置一个新的容器映像来更新第二个Git存储库(4)中的部署清单——顺便说一下，这个repo没有人工交互。它导致第二个云构建(5)向集群部署新版本。</p><p id="e4ec" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><strong class="ii hk">优点</strong>:完整/可靠的部署历史和简单的回滚策略(强烈推荐阅读GKE文档中的<a class="ae je" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build" rel="noopener ugc nofollow" target="_blank">分步指南)。</a></p><p id="35b0" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><strong class="ii hk">缺点</strong>:复杂性:2个存储库，3个分支……许多人声称有一种更直接的方式从代码推进到产品，<a class="ae je" href="https://github.com/kubernetes/kubernetes/issues/33664" rel="noopener ugc nofollow" target="_blank">正如在这个帖子</a>中可以看到的。虽然有可能通过<a class="ae je" href="https://stackoverflow.com/questions/40366192/kubernetes-how-to-make-deployment-to-update-image" rel="noopener ugc nofollow" target="_blank">解决方案</a>实现，但没有达成共识。</p></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="b03b" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">集群管理演进:走向无服务器</strong></h1><p id="7c1f" class="pw-post-body-paragraph ig ih hj ii b ij kw il im in kx ip iq ir ky it iu iv kz ix iy iz la jb jc jd hc bi translated">上面的工作流只暴露了集群管理的复杂性之一。还有其他一些，比如网络、安全和监控，不在本文的讨论范围之内。它们降低了Kubernetes的用户体验，并掩盖了该平台提供的其他好处。</p><p id="2e84" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">为了最小化这样的负面影响，最近在K8s之上开发了两个相关的开源项目:<a class="ae je" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>和<a class="ae je" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank"> Knative </a>。Istio 让人们可以连接、保护、控制和观察服务，从而轻松创建一个部署了负载平衡、服务对服务认证、监控等服务的网络，只需很少或不需要修改服务代码。Knative 使用Istio，抽象出复杂的细节，让开发者专注于重要的事情。Knative通过将成功的现实世界实施中共享的最佳实践进行整理而构建，解决了构建、部署和管理云原生服务的“枯燥而困难”的部分，实现了真正的无服务器方法。</p><p id="be5f" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">正如第一段所提到的，围绕Kubernetes的新工具经常发布。从2019年3月开始，谷歌云Kubernetes引擎用户可以利用<a class="ae je" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank">云运行</a>来无缝集成Kubernetes+Istio+Knative。利用其中的精华，Cloud Run使得从代码到工作集群变得不费力。</p><p id="ee6d" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">以下部分描述了如何将其用于连续交付管道。下图总结了建议的架构:</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et lc"><img src="../Images/463828355f9737d165ba4d827d039b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFaD-r603Zp8Vhrq39lQjA.png"/></div></div></figure></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="aa76" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">集群、容器和构建设置</strong></h1><p id="89cd" class="pw-post-body-paragraph ig ih hj ii b ij kw il im in kx ip iq ir ky it iu iv kz ix iy iz la jb jc jd hc bi translated">云控制台或<em class="ld"> gcloud </em> CLI工具可以遵循以下说明。我会用<em class="ld"> gcloud </em>让事情变得更简单。</p><blockquote class="le lf lg"><p id="b761" class="ig ih ld ii b ij ik il im in io ip iq lh is it iu li iw ix iy lj ja jb jc jd hc bi translated"><strong class="ii hk">在继续之前，如果您希望运行示例，请确保您已经创建了一个GCP项目，并在您的机器上安装了</strong><a class="ae je" href="https://cloud.google.com/sdk/install" rel="noopener ugc nofollow" target="_blank"><strong class="ii hk">Google Cloud SDK</strong></a><strong class="ii hk">。不要忘记运行</strong> <code class="dv lk ll lm ln b"><strong class="ii hk">gcloud auth login</strong></code> <strong class="ii hk">、</strong> <code class="dv lk ll lm ln b"><strong class="ii hk">gcloud config set project &lt;your-project-id&gt;</strong></code> <strong class="ii hk">、</strong> <code class="dv lk ll lm ln b"><strong class="ii hk"><em class="hj">gcloud components install kubectl</em></strong></code> <strong class="ii hk">和</strong> <code class="dv lk ll lm ln b"><strong class="ii hk">gcloud services enable container.googleapis.com containerregistry.googleapis.com cloudbuild.googleapis.com</strong></code> <strong class="ii hk">来正确使用gcloud CLI。</strong></p></blockquote><p id="0c53" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">首先，创建您的Kubernetes引擎集群:</p><pre class="jg jh ji jj fe lo ln lp lq aw lr bi"><span id="9ef8" class="ls jz hj ln b fj lt lu l lv lw">gcloud beta container clusters create &lt;<!-- -->cluster-name&gt; <!-- -->\<br/>--addons=HorizontalPodAutoscaling,HttpLoadBalancing,Istio,CloudRun \<br/>--machine-type=n1-standard-2 \<br/>--cluster-version=latest \<br/>--zone=&lt;your-preferred-gcp-zone&gt; \<br/>--enable-stackdriver-kubernetes --enable-ip-alias \<br/>--scopes cloud-platform</span></pre><p id="1134" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">注意集群中安装了4个附加组件，包括<strong class="ii hk"> Istio </strong>和<strong class="ii hk">云运行</strong>—<strong class="ii hk">Knative Serving</strong>组件也被安装，因为云运行依赖于它。它们使节点变得更重，因此生产环境可能需要更高的CPU和网络资源。</p><p id="ad58" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">一旦集群可用，就应该创建一个应用程序来部署在其上。由于Cloud Run是一个托管计算平台，使您能够运行可通过HTTP请求调用的无状态容器，因此Nginx提供的Angular应用程序似乎是一个合适的选择——与本系列之前的文章非常相似。</p><blockquote class="le lf lg"><p id="a636" class="ig ih ld ii b ij ik il im in io ip iq lh is it iu li iw ix iy lj ja jb jc jd hc bi translated">可以使用一个更简单的例子，但是我通常喜欢超越“Hello world ”,演示稍微复杂一点的情况。他们更接近我们真正的挑战！</p></blockquote><p id="4586" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">Angular CLI提供了一种创建前端web应用程序的简单方法。安装该工具的步骤超出了本文的范围，可以在这里找到<a class="ae je" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"/>。安装完成后，<code class="dv lk ll lm ln b">cd</code>到您的首选文件夹，然后输入<code class="dv lk ll lm ln b">ng new &lt;app-name&gt;</code>。等待几秒钟。创建好app后，输入<code class="dv lk ll lm ln b">cd &lt;app-name&gt;</code>和<code class="dv lk ll lm ln b">ng serve</code>。将你的浏览器指向<code class="dv lk ll lm ln b">http://localhost:4200</code>，确保应用程序正在运行。</p><p id="7ec5" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们将使用<a class="ae je" href="https://cloud.google.com/cloud-build/" rel="noopener ugc nofollow" target="_blank">云构建</a>来部署应用程序，因此向应用程序的根文件夹添加一个<code class="dv lk ll lm ln b">cloudbuild.yaml</code>文件，其内容如下:</p><figure class="jg jh ji jj fe jk"><div class="bz dz l di"><div class="lx ly l"/></div></figure><p id="8327" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">特别注意最后一步:它负责部署一个<strong class="ii hk">云运行服务</strong>，该服务将运行Nginx+Angular App容器。注意命令<code class="dv lk ll lm ln b">gcloud beta run deploy…</code>带有一个<code class="dv lk ll lm ln b">--cluster</code>参数。在前面的步骤中创建集群时，我们添加了<strong class="ii hk">云运行</strong>插件，还记得吗？这个桥梁允许我们使用Cloud Run的无服务器抽象将服务部署到您自己的集群中。</p><p id="6749" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">需要创建一个容器映像，因此还需要一个<code class="dv lk ll lm ln b">Dockerfile</code>。详情请参考<a class="ae je" href="https://github.com/ricardolsmendes/gcp-cloudrun-gke-angular" rel="noopener ugc nofollow" target="_blank">https://github.com/ricardolsmendes/gcp-cloudrun-gke-angular</a>。请注意Nginx端口被设置为8080——根据其<a class="ae je" href="https://cloud.google.com/run/docs/reference/container-contract" rel="noopener ugc nofollow" target="_blank">容器运行时合同</a>，这是一个云运行需求。此外，服务器的错误和访问日志文件需要存储在自定义文件夹中。这是使Nginx与Knative Serving兼容的一个棘手的解决方法。</p><p id="0e90" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">为了使云构建能够部署应用，向<code class="dv lk ll lm ln b">&lt;your-project-number&gt;@cloudbuild.gserviceaccount.com</code>服务帐户授予<strong class="ii hk">云运行管理员</strong>和<strong class="ii hk"> Kubernetes引擎开发人员</strong>角色。</p></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="3457" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">云运行:无痛部署到Kubernetes </strong></h1><p id="8747" class="pw-post-body-paragraph ig ih hj ii b ij kw il im in kx ip iq ir ky it iu iv kz ix iy iz la jb jc jd hc bi translated">部署时间到了！从你的本地机器运行<code class="dv lk ll lm ln b">gcloud builds submit --config cloudbuild.yaml .</code>(确保你在应用的根文件夹中)。</p><p id="07f9" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">当构建完成时，<code class="dv lk ll lm ln b">gke-angular</code>服务应该在集群中启动并运行。发出HTTP请求是确保这一点的简单方法。但是，等等，我们应该把请求发送到什么地址呢？Istio提供了一种<code class="dv lk ll lm ln b">LoadBalancer</code>类型的<code class="dv lk ll lm ln b">istio-ingressgateway</code>服务。这种服务在正确设置后，允许我们从互联网访问集群服务。要获得它的地址，运行<code class="dv lk ll lm ln b">kubectl get svc istio-ingressgateway --namespace istio-system</code>。复制<code class="dv lk ll lm ln b">external-ip</code>值。现在运行<code class="dv lk ll lm ln b">curl -v -H "Host: gke-angular.example.com" &lt;external-ip&gt;</code>。如果一切按预期运行，下面的内容将是响应的一部分:</p><pre class="jg jh ji jj fe lo ln lp lq aw lr bi"><span id="3b1d" class="ls jz hj ln b fj lt lu l lv lw">StatusCode        : 200<br/>StatusDescription : OK<br/>Content           : &lt;!doctype html&gt;<br/>                    &lt;html lang="en"&gt;<br/>                    &lt;head&gt;<br/>                      &lt;meta charset="utf-8"&gt;<br/>                      &lt;title&gt;app-name&lt;/title&gt;<br/>                      &lt;base href="/"&gt;<br/>                      &lt;meta name="viewport" ...</span></pre><p id="d0fe" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">然而，如果你试图从浏览器访问<code class="dv lk ll lm ln b">external-ip</code>，你会收到一个<code class="dv lk ll lm ln b">HTTP 404 ERROR</code>。浏览器的请求缺少<code class="dv lk ll lm ln b">Host</code>报头，因此入口网关无法将请求路由到<code class="dv lk ll lm ln b">gke-angular</code>服务。<strong class="ii hk"> Knative Serving </strong>附带了一个名为<code class="dv lk ll lm ln b">knative-ingress-gateway</code>的入口网关(运行<code class="dv lk ll lm ln b">kubectl get gateway --namespace knative-service</code>了解更多信息)，可以帮助我们解决这个问题。使用以下内容在应用程序的根文件夹中创建一个<code class="dv lk ll lm ln b">knative/gke-angular-routing.yaml</code>文件[1]并运行<code class="dv lk ll lm ln b">kubectl apply -f ./knative/gke-angular-routing.yaml</code>。</p><figure class="jg jh ji jj fe jk"><div class="bz dz l di"><div class="lx ly l"/></div></figure><p id="3dd4" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">输出应该如下框所示，现在可以从浏览器访问该应用程序。</p><pre class="jg jh ji jj fe lo ln lp lq aw lr bi"><span id="17a5" class="ls jz hj ln b fj lt lu l lv lw">virtualservice.networking.istio.io/gke-angular-route created</span></pre><blockquote class="lz"><p id="8d89" class="ma mb hj bd mc md me mf mg mh mi jd dy translated">阅读关于<a class="ae je" href="https://istio.io/docs/concepts/traffic-management/" rel="noopener ugc nofollow" target="_blank"> Istio交通管理</a>的内容，以便更好地了解幕后发生的事情！</p></blockquote></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="4755" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">自动部署新版本</h1><p id="93e6" class="pw-post-body-paragraph ig ih hj ii b ij kw il im in kx ip iq ir ky it iu iv kz ix iy iz la jb jc jd hc bi translated">让我们<strong class="ii hk">自动</strong>部署新版本的应用程序。因为我们在根文件夹中有一个<code class="dv lk ll lm ln b">cloudbuild.yaml</code>文件，所以只需设置一个触发器，在每次新代码发布到受监控的Git存储库时启动构建过程。这是一项<a class="ae je" href="https://cloud.google.com/source-repositories/" rel="noopener ugc nofollow" target="_blank">源代码库</a>的工作，正如我们在本系列的第一篇文章<a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5">中看到的。源存储库的设置应该与GAE完全一样。</a></p><p id="7adf" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">修改代码中的一些东西，例如<code class="dv lk ll lm ln b">app.component.ts</code>中的标题，并将新代码推送到由云构建监控的Git存储库。等待几分钟并刷新浏览器，以确保新版本已经部署。</p><p id="5926" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">运行<code class="dv lk ll lm ln b">kubectl get revisions.serving.knative.dev</code>。输出应该类似于:</p><pre class="jg jh ji jj fe lo ln lp lq aw lr bi"><span id="ad36" class="ls jz hj ln b fj lt lu l lv lw">NAME                SERVICE NAME                GENERATION   READY<br/>gke-angular-2bfpn   gke-angular-2bfpn-service   1            True<br/>gke-angular-8pdtp   gke-angular-8pdtp-service   5            True<br/>gke-angular-l4vm9   gke-angular-l4vm9-service   4            True<br/>gke-angular-lkxrx   gke-angular-lkxrx-service   3            True<br/>gke-angular-r82gx   gke-angular-r82gx-service   2            True<br/><strong class="ln hk">gke-angular-rm2vj   gke-angular-rm2vj-service   6            True</strong></span></pre><p id="b3fd" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">上面的列表是所有已部署版本(或修订版)的历史记录。最后一个是当前/活动的。要获得更多细节，包括用于创建它的容器图像摘要，运行<code class="dv lk ll lm ln b">kubectl get revisions.serving.knative.dev gke-angular-rm2vj --output yaml</code>。</p></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="71c2" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">结论</strong></h1><p id="4886" class="pw-post-body-paragraph ig ih hj ii b ij kw il im in kx ip iq ir ky it iu iv kz ix iy iz la jb jc jd hc bi translated">Kubernetes对于基于微服务的架构来说是一个极好的平台，但是它有一个陡峭的学习曲线。幸运的是，最近在此基础上构建的新工具，比如Istio和Knative，使得处理集群管理负担变得更加容易。Google Cloud Run允许其用户通过提供一个无服务器环境来利用所有这些工具，该环境能够以很少的步骤在集群中运行代码，使开发人员专注于重要的事情:价值交付。</p><p id="932a" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在GKE上运行云允许工程师构建可靠、安全和可定制的解决方案。我希望这篇文章作为实用的入门指南有所帮助。实际的挑战需要更多，但是随着业务需要和团队经验的增加，可以按需进行改进。</p><p id="4978" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">Github上有示例代码:<a class="ae je" href="https://github.com/ricardolsmendes/gcp-cloudrun-gke-angular" rel="noopener ugc nofollow" target="_blank">https://github.com/ricardolsmendes/gcp-cloudrun-gke-angular</a>。随便叉一下玩玩。</p></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="9ecb" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">打扫</h1><p id="2d90" class="pw-post-body-paragraph ig ih hj ii b ij kw il im in kx ip iq ir ky it iu iv kz ix iy iz la jb jc jd hc bi translated">由于集群基础架构会增加您项目的成本，请不要忘记在测试此解决方案后将其删除。仔细检查<strong class="ii hk">负载平衡器</strong>和<strong class="ii hk">防火墙规则</strong>，这些规则在删除集群时可能不会自动删除。<strong class="ii hk">如果他们还活着，手动删除，避免额外费用！</strong></p></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><h1 id="2ea4" class="jy jz hj bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="050f" class="mj mk hj ii b ij kw in kx ir ml iv mm iz mn jd mo mp mq mr bi translated">跨多个Knative服务路由[Go]:<a class="ae je" href="https://knative.dev/docs/serving/samples/knative-routing-go/" rel="noopener ugc nofollow" target="_blank">https://Knative . dev/docs/serving/samples/Knative-routing-Go/</a></li></ol></div><div class="ab cl jr js gq jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hc hd he hf hg"><p id="7d89" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这是关于谷歌云平台<strong class="ii hk">持续交付的3篇文章系列的第3篇</strong>:</p><p id="e7d8" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5"> App引擎</a> | <a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-compute-engine-a95bf4fd1821">计算引擎</a> | <strong class="ii hk"> Kubernetes引擎</strong></p></div></div>    
</body>
</html>