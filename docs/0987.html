<html>
<head>
<title>Profiling Dataflow Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析数据流管道</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/profiling-dataflow-pipelines-ddbbef07761d?source=collection_archive---------0-----------------------#2019-05-01">https://medium.com/google-cloud/profiling-dataflow-pipelines-ddbbef07761d?source=collection_archive---------0-----------------------#2019-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="27d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">更新2012年2月22日:</em> </strong> <em class="jd">数据流现在支持全面可用的概要分析—参见文档</em> <a class="ae je" href="https://cloud.google.com/dataflow/docs/guides/profiling-a-pipeline" rel="noopener ugc nofollow" target="_blank"> <em class="jd">此处</em> </a> <em class="jd">！</em></p><p id="f1b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://cloud.google.com/dataflow/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Dataflow </a>是一个完全托管的服务，用于执行使用<a class="ae je" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Beam SDK </a>编写的批处理和流数据管道。除了为用户管理和协调端到端的管道执行之外，Dataflow还提供了许多开箱即用的功能，如<a class="ae je" href="https://cloud.google.com/dataflow/docs/guides/deploying-a-pipeline#autoscaling" rel="noopener ugc nofollow" target="_blank">自动扩展</a>、<a class="ae je" href="https://cloud.google.com/blog/products/gcp/no-shard-left-behind-dynamic-work-rebalancing-in-google-cloud-dataflow" rel="noopener ugc nofollow" target="_blank">动态工作重新平衡</a>(又名液体分片)和<a class="ae je" href="https://cloud.google.com/dataflow/docs/guides/using-stackdriver-monitoring" rel="noopener ugc nofollow" target="_blank">本机堆栈驱动程序集成</a>，进一步增强了Dataflow的零旋钮故事。这使得Dataflow成为在谷歌云平台上转换和丰富数据的理想执行平台。</p><h2 id="649c" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">太好了——数据流管道到底是什么？</h2><p id="4f8e" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">数据流管道可以被描述为一系列的<a class="ae je" href="https://beam.apache.org/documentation/programming-guide/#transforms" rel="noopener ugc nofollow" target="_blank"> <em class="jd">转换</em> </a> <em class="jd"> s </em>，当这些元素从源移动到目标时，这些转换被应用于数据元素的分布式集合。这些转换通常由管道(<em class="jd">又名用户代码</em>)的作者提供，并描述应用于数据元素的业务规则，以使它们成为可用的形式。</p><p id="4092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，数据管道的整体性能高度依赖于这些转换背后的用户代码的性能。</p><p id="866b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你听过多少次有人抱怨— <em class="jd">“我的工作运行缓慢”？</em></p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/b42a5c9a15894c300d2b11625dd56246.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*5mrHFJXzLZqzbW0cawxPmg.gif"/></div></figure><blockquote class="kn"><p id="3bbb" class="ko kp hi bd kq kr ks kt ku kv kw jc dx translated">可能比我们想的要多得多！！</p></blockquote><h2 id="28ca" class="jf jg hi bd jh ji ky jk jl jm kz jo jp iq la jr js iu lb ju jv iy lc jx jy jz bi translated">好——所以管道运行缓慢。我该如何解决这个问题？</h2><p id="4af2" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">Dataflow和Apache Beam SDK以<a class="ae je" href="https://beam.apache.org/releases/javadoc/2.12.0/org/apache/beam/sdk/metrics/Metrics.html" rel="noopener ugc nofollow" target="_blank">指标</a>和集成的Stackdriver日志记录的形式提供了许多工具来帮助解决管道问题。然而，由于各种原因，这些可能并不总是足够的:</p><ul class=""><li id="1f98" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">当作者试图添加详细的日志记录和指标来识别瓶颈时，容易出现反复试验。</li><li id="ddc8" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">过多的日志记录会增加管道性能的开销。</li><li id="0d0b" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">在用户代码与梁模型交互的地方，度量可能是相关的。然而，瓶颈步骤中的用户代码对用户来说可能仍然是不透明的。</li></ul><p id="4fe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是数据流剖析能有所帮助的地方。</p><p id="fc68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据流剖析是一个过程，它允许我们在用户代码的粒度上获得关于管道执行的更多见解。换句话说，概要分析帮助我们双击在组成管道的<em class="jd">转换</em>中执行的实际用户代码。</p><h2 id="14eb" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">太棒了——那么我们如何分析数据流管道呢？</h2><p id="64d4" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">剖析数据流管道的一个更简单的方法是利用数据流与<a class="ae je" href="https://cloud.google.com/profiler/" rel="noopener ugc nofollow" target="_blank"> Stackdriver Profiler </a>的本机集成。Stackdriver Profiler在可用于分析性能的交互式火焰图中可视化管道的调用层次结构和资源消耗。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/54467998ba1845c895745a8b5576a45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxf7xYKJTsZnZ6pVWhvkjA.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">堆栈中的火焰图驱动程序探查器可视化数据流管道调用堆栈</figcaption></figure><p id="8c3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dataflow与Stackdriver profiler的本机集成使得为任何Dataflow作业启用分析变得极其容易。</p><p id="d7cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于使用Apache Beam的Java SDK编写的管道，可以通过传递一个接受属性的<em class="jd">映射</em>的附加参数来启用分析:</p><pre class="kg kh ki kj fd ma mb mc md aw me bi"><span id="2005" class="jf jg hi mb b fi mf mg l mh mi">mvn clean compile exec:java \<br/>-Dexec.mainClass=MyClass\<br/>-Dexec.args=” \<br/>— runner=DataflowRunner \<br/>— project=my-project \<br/>— jobName=my-job \<br/>— stagingLocation=gs://my-staging-bucket \<br/>— tempLocation=gs://my-temp-bucket \<br/>……. &lt;&lt;other pipeline specific flags&gt;&gt; …..<br/><strong class="mb hj"><em class="jd">--profilingAgentConfiguration=’{ \”APICurated\”: true }’</em></strong></span></pre><p id="1245" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">注意:</em></strong><em class="jd">Do</em><strong class="ih hj"><em class="jd">not</em></strong><em class="jd">set—saveProfilesToGcs =&lt;GCS-bucket-for-profiles&gt;当使用上述配置时，将禁用性能分析！</em></p><p id="c84c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将布尔属性<em class="jd">a精确化</em>设置为<em class="jd">真</em>作为<em class="jd">映射</em>输入添加到<em class="jd">profilingAgentConfiguration</em>属性中，这是启用管道分析所需的全部工作。</p><p id="2124" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦管道开始执行，浏览到<em class="jd"> Google Cloud控制台，点击导航菜单和Profiler特性</em>。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es mj"><img src="../Images/e98ced559a8dda1cebd84607c930c663.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*aSPoilVrshOJJJpBFlSZTg.png"/></div></figure><p id="b480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后单击服务下拉菜单，搜索我们要分析的数据流作业:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mk"><img src="../Images/9794997574954d993279e4123d935327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpOxi5rUIHLf2NOLfPw8Wg.png"/></div></div></figure><h2 id="a9f7" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">太棒了——我们发现并解决了瓶颈。有没有一个简单的方法来比较改变前后的性能？</h2><p id="a2d5" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">绝对的！ Stackdriver Profiler让<a class="ae je" href="https://cloud.google.com/profiler/docs/comparing-profiles" rel="noopener ugc nofollow" target="_blank">比较作业</a>变得超级简单。只需使用<em class="jd">相同的</em> <em class="jd">作业名</em>执行作业，并使用Stackdriver Profiler的“比较对象”下拉菜单选择不同的版本<em class="jd">(即job_id)。</em></p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ml"><img src="../Images/8df49055bfe28aae107d05324c3373b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*4IL8GG3RHDh_hUmLWH9ufA.png"/></div></figure><h2 id="cf74" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">有没有其他我们可以利用的分析旋钮？</h2><p id="b010" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated"><em class="jd">是的！</em>数据流使用的分析引擎公开了许多其他的旋钮:</p><pre class="kg kh ki kj fd ma mb mc md aw me bi"><span id="b411" class="jf jg hi mb b fi mf mg l mh mi"><strong class="mb hj">APICurated</strong> =<em class="jd"> Boolean flag to enable profiling</em> // Default: false<br/><strong class="mb hj">Interval</strong> = <em class="jd">Profile output frequency           </em>// Default: 60 secs<br/><strong class="mb hj">Duration</strong> = <em class="jd">Trace duration per interval        </em>// Default: 10 secs<br/><strong class="mb hj">Delay</strong> = <em class="jd">Delay tracing by seconds</em>              // Default: 0 secs<br/><strong class="mb hj">MaxCounts</strong> = <em class="jd">Max number of profiles collected</em>  // Default: unlimited<br/><strong class="mb hj">NativeStacks</strong> = <em class="jd">Boolean flag to enable native stack unwind</em> // Default: false</span></pre><p id="f3fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在大多数情况下，仅仅将<em class="jd">精确的</em>标志设置为<em class="jd">真的</em>应该是唯一需要的改变。</p><h2 id="7a92" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">还有其他分析工具吗？</h2><p id="abdf" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated"><em class="jd">当然！</em>尽管Stackdriver Profiler非常易于使用，但在某些情况下，可能需要更深入地研究执行调用树。在这些罕见的情况下，我们可以利用<a class="ae je" href="https://github.com/google/pprof" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="jd"> pprof </em> </strong> </a>，这是一个用于可视化和分析概要文件数据的开源工具。Pprof分析由数据流管道转储的配置文件数据，并具有Stackdriver Profiler中目前不存在的几个功能。其中包括:</p><ul class=""><li id="a37f" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">图形视图(<em class="jd"> pprof -graphviz </em>)</li><li id="18d8" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">树形视图(<em class="jd">pprof-graphviz-call _ tree</em>)</li><li id="8c96" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">自上而下/自下而上树形视图</li><li id="8ced" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">其他输出格式(pdf等。)</li></ul><h2 id="2fbe" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">如何提取pprof所需的配置文件信息？</h2><p id="d622" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">这非常简单，通过在执行管道时向命令行传递一个附加属性来实现。因此，例如，使用Apache Beam的Java SDK编写的数据流管道可以通过传递一个属性将概要文件转储到GCS，如下所示:</p><pre class="kg kh ki kj fd ma mb mc md aw me bi"><span id="e2c3" class="jf jg hi mb b fi mf mg l mh mi">mvn clean compile exec:java \<br/>-Dexec.mainClass=MyClass\<br/>-Dexec.args=” \<br/>— runner=DataflowRunner \<br/>— project=my-project \<br/>— jobName=my-job \<br/>— stagingLocation=gs://my-staging-bucket \<br/>— tempLocation=gs://my-temp-bucket \<br/>……. &lt;&lt;other pipeline specific flags&gt;&gt; …..<br/><strong class="mb hj"><em class="jd">--saveProfilesToGcs=gs://YOUR BUCKET HERE/profiler</em></strong></span></pre><p id="280b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">就这些！</em>一旦作业开始执行，数据流服务将定期写入配置文件(*wall*和*cpu*)文件<em class="jd">(大约每60秒cpu和wall时间各一个文件)</em></p><h2 id="cd1b" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">太好了——我如何使用pprof分析这些文件？</h2><p id="04da" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">一旦收集到足够的配置文件信息<em class="jd">(大约10分钟)</em>或任务完成<em class="jd">(如果是批处理管道)</em>，本地下载配置文件并使用pprof可视化cpu或墙时间配置文件。Pprof有许多命令行选项来帮助分析。例如:</p><pre class="kg kh ki kj fd ma mb mc md aw me bi"><span id="a08e" class="jf jg hi mb b fi mf mg l mh mi">pprof --call_tree --web “http:” &lt;LOCAL PATH FOR PROFILES&gt;/*cpu*</span></pre><p id="549c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我们可能会讨论更多关于使用这些工具的细节，但这个概述应该有望向每个人介绍一些非常有用的故障排除和性能调整工具，这些工具应该是每个数据流管道开发人员工具包的一部分。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es mm"><img src="../Images/1912454dbc48b0b5ef6d49e2740784aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/1*JCikDPTZ7WWOshtydOZ2Tg.gif"/></div></figure><h2 id="d811" class="jf jg hi bd jh ji jj jk jl jm jn jo jp iq jq jr js iu jt ju jv iy jw jx jy jz bi translated">其他详细信息和注释:</h2><p id="7df0" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">虽然这一概述仅涵盖了从CPU消耗角度进行的分析，但我们希望在后续博客中描述数据流管道的内存利用分析过程。内存分析目前没有集成到Stackdriver Profiler中，更多的是一个手动过程。</p></div></div>    
</body>
</html>