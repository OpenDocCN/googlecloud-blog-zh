<html>
<head>
<title>The 2 limits of Google Cloud IAM service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云IAM服务的两大局限</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/the-2-limits-of-iam-service-on-google-cloud-7db213277d9c?source=collection_archive---------0-----------------------#2020-08-18">https://medium.com/google-cloud/the-2-limits-of-iam-service-on-google-cloud-7db213277d9c?source=collection_archive---------0-----------------------#2020-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/04b8cae88d7ee67e031469379e3b0664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqD784A2qaAu7j2BUi1AmQ.png"/></div></div></figure><p id="5480" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安全性在云环境中至关重要，<strong class="is hj"> IAM(身份和访问管理)服务有助于任何云提供商</strong> <em class="jo">(例如，你可以在Azure、AWS和GCP上找到IAM服务)。</em></p><p id="7edb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Google Cloud上，这个IAM服务使用OAuth和OpenID协议。它允许<strong class="is hj">认证和授权账户</strong>(用户账户或服务账户)。<br/> <em class="jo">仅针对Google Cloud组件进行授权；您不能在IAM服务中为自己的应用程序添加自定义授权/权限。</em></p><p id="cb2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">身份验证部分使用OAuth协议来生成凭证。您可以使用<strong class="is hj">您自己的凭证(用户帐户</strong>，在浏览器中进行交互式认证)或<strong class="is hj">技术凭证(服务帐户)</strong>。</p><p id="7fd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务帐户凭证被自动加载到Google Cloud环境中<em class="jo">(稍后我会解释如何加载)</em>。然而，您也可以<strong class="is hj">生成一个服务帐户密钥文件</strong>来在任何地方使用这个凭证。这是一种丑陋的做法，尤其是为了保守秘密……秘密！</p><h1 id="a5ab" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">难看的服务帐户密钥文件</h1><p id="ef97" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">服务帐户密钥文件在某些情况下是有用的，但如果使用不当，它们也是丑陋的(T21)。<br/>首先想想<strong class="is hj">是什么:一个文件</strong>。一个简单的文件。</p><p id="3dd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文件是计算中最常见的对象。您可以复制它，通过电子邮件发送它，提交到Git存储库中。有时这个库是公开的，你会收到一封来自谷歌云的邮件，通知你你的秘密文件泄露了。</p><p id="c490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">在我的公司里，我们遇到过两次这种问题，都是那些用比特币矿工</em>  <em class="jo">默默创造虚拟机的</em> <strong class="is hj"> <em class="jo">坏演员。希望我们能尽快解决这个问题，并限制成本。此外，这是没有更大问题(例如机密数据泄露)的开发项目。我将发布另一篇文章，介绍我们如何解决这个问题并提高安全性。</em></strong></p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="ae2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，<strong class="is hj">这个文件可以在开发者</strong>之间共享，比起<strong class="is hj">保持这个秘密文件的安全</strong>，更专注于特性的开发。你也可以让外部开发人员在你的公司工作一段时间，然后<strong class="is hj">带着仍然在他们电脑</strong>中的密钥文件去其他地方。</p><p id="899c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，如果用户没有意识到这个关键文件的保密性，<strong class="is hj">你很快就失去了对它的控制</strong>。这导致了第二个问题:Google建议<strong class="is hj">定期轮换服务帐户密钥文件</strong>，至少每90天一次。</p><blockquote class="kz la lb"><p id="7dab" class="iq ir jo is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated">如果不控制密钥文件，如何执行密钥轮换？</p></blockquote><p id="6c5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，总的来说，<strong class="is hj">服务账户密钥文件是管理</strong>的噩梦。当应用程序默认凭证不足以解决您的身份验证时，它们在特定情况下非常有用。在所有其他情况下…</p><blockquote class="lf"><p id="6f75" class="lg lh hi bd li lj lk ll lm ln lo jn dx translated">为了避免任何秘密的泄露，千万不要储存秘密</p></blockquote><h1 id="2f22" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka lp kc kd ke lq kg kh ki lr kk kl km bi translated">从未储存的秘密</h1><p id="1084" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">基于此，<strong class="is hj"> IAM服务允许永远不必存储机密</strong>，如服务帐户密钥文件，并在您的本地环境和Google Cloud上无缝工作。</p><p id="291c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，<strong class="is hj">原理是使用环境上下文被IAM服务认证</strong>。这种策略被称为<a class="ae ls" href="https://cloud.google.com/docs/authentication/production#automatically" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> ADC(应用默认凭证)</strong> </a>，Google Cloud客户端库支持多种语言的这种认证模式。该库根据环境检索凭证，并且<strong class="is hj">在应用程序</strong>中使用它作为默认凭证。</p><p id="e7ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，在Python中，<code class="du lt lu lv lw b">google-auth</code>库允许你这样做</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="6f9e" class="mf jq hi lw b fi mg mh l mi mj">import google.auth<br/>credentials, project_id = google.auth.default()</span></pre><p id="6386" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你从不提及你的环境或账户，你让图书馆做它的工作。 <strong class="is hj"> <em class="jo">同样适用于组件库(像Google Storage) </em> </strong> <em class="jo">:在那种情况下使用默认构造函数()或者关键字</em> <code class="du lt lu lv lw b"><em class="jo">defaultCredential</em></code> <em class="jo">。</em></p><h2 id="7a92" class="mf jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated"><strong class="ak">本地环境上的ADC</strong></h2><p id="65fd" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您可以使用您的用户凭证，与您在Google Cloud控制台中使用的凭证相同。</p><ul class=""><li id="06a5" class="mx my hi is b it iu ix iy jb mz jf na jj nb jn nc nd ne nf bi translated">要在<code class="du lt lu lv lw b">gcloud</code>命令行中使用您的用户帐户凭证，请像这样获取您的凭证</li></ul><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="4132" class="mf jq hi lw b fi mg mh l mi mj">gcloud auth login</span></pre><ul class=""><li id="d4c6" class="mx my hi is b it iu ix iy jb mz jf na jj nb jn nc nd ne nf bi translated">要在代码中使用您的用户凭据并使用ADC，请使用以下命令配置您的本地环境</li></ul><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="c9de" class="mf jq hi lw b fi mg mh l mi mj">gcloud auth application-default login</span></pre><p id="35cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这两种情况下，你都必须进入你的浏览器，选择你的谷歌账户，如果有很多的话。你可能需要重新认证你自己，也许有两个因素的机制。<strong class="is hj">最后通过gcloud SDK授权使用您的账户。</strong></p><p id="fedc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">本地仅存储刷新令牌，从不存储您的认证凭证登录/密码或机密。</em></p><h2 id="c853" class="mf jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated"><strong class="ak">谷歌云环境下的ADC</strong></h2><p id="540c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">所有谷歌云服务都接入</strong> <a class="ae ls" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">元数据服务器</strong> </a>。该内部服务器提供关于环境的信息，<strong class="is hj">包括用于服务</strong>的服务账户。因此，Google Cloud客户端库可以检测到这个服务器，并且<strong class="is hj">通过这个元数据服务器</strong>获得凭证。</p><p id="b509" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有些产品允许你<strong class="is hj">自定义你想在服务中使用的服务账号</strong>，比如<a class="ae ls" href="https://cloud.google.com/functions/docs/securing/function-identity" rel="noopener ugc nofollow" target="_blank">云功能</a>和<a class="ae ls" href="https://cloud.google.com/run/docs/securing/service-identity" rel="noopener ugc nofollow" target="_blank">云运行</a>。其他不是，<strong class="is hj">是默认使用的服务账号</strong>。但是，<strong class="is hj">在任何情况下，服务帐户都是加载的并且是可用的。</strong></p><h1 id="9957" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">ADC的极限</h1><p id="6243" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当您使用您的用户凭证或在Google Cloud产品上运行您的代码时，ADC工作得很好。</p><blockquote class="lf"><p id="7a80" class="lg lh hi bd li lj lk ll lm ln lo jn dx translated">当您必须将内部环境连接到Google Cloud时会发生什么？</p><p id="51d9" class="lg lh hi bd li lj lk ll lm ln lo jn dx translated">您的CI/CD(例如gitlab CI或Github Action)？</p><p id="5dad" class="lg lh hi bd li lj lk ll lm ln lo jn dx translated">还是托管在其他云提供商上的其他应用？</p></blockquote><p id="7d8f" class="pw-post-body-paragraph iq ir hi is b it ng iv iw ix nh iz ja jb ni jd je jf nj jh ji jj nk jl jm jn hb bi translated">没有神奇的解决方案，<strong class="is hj">你需要一个凭证文件进行认证</strong>，其中存储了一个秘密(一个私钥):服务帐户密钥文件。服务帐户密钥文件主要是在这种情况下设计和使用的。</p><h2 id="5066" class="mf jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated">其他ADC限制</h2><p id="183d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">然而，即使使用Google Cloud环境上的本地用户帐户凭证或服务帐户凭证，仍然存在2个主要限制；</p><ol class=""><li id="bcb3" class="mx my hi is b it iu ix iy jb mz jf na jj nb jn nl nd ne nf bi translated">无法<strong class="is hj">将范围</strong>添加到应用引擎上的应用引擎默认服务帐户<strong class="is hj"/></li><li id="790a" class="mx my hi is b it nm ix nn jb no jf np jj nq jn nl nd ne nf bi translated">无法<strong class="is hj">生成签名身份令牌</strong>以使用<strong class="is hj">本地用户凭证</strong>访问私有云运行和云功能。</li></ol><p id="e78d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">对于这两种情况，最好使用服务帐户模拟(以避免生成密钥文件)，但这并不总是最安全的解决方案。</em></p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><h1 id="c587" class="jp jq hi bd jr js nr ju jv jw ns jy jz ka nt kc kd ke nu kg kh ki nv kk kl km bi translated">1.应用引擎限制</h1><p id="30bb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj"> App Engine已经是Google Cloud的第一款产品</strong>和<strong class="is hj">已经超过12岁了</strong>！它允许您部署一组(微)服务来服务web应用程序。但是，<strong class="is hj">作为老的第一个产品，有一些遗留问题限制了你以后的发展。</strong></p><p id="86c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">App Engine有2个限制:</p><ol class=""><li id="3962" class="mx my hi is b it iu ix iy jb mz jf na jj nb jn nl nd ne nf bi translated"><strong class="is hj">App Engine上的所有服务都有相同的默认服务账号</strong>，并且<strong class="is hj">你不能自定义</strong>(在App Engine上或每个服务)。这是一个问题，因为你在App Engine上的所有服务都将拥有相同级别的权限，而且它<strong class="is hj">违反了最小特权原则</strong>。</li><li id="9b73" class="mx my hi is b it nm ix nn jb no jf np jj nq jn nl nd ne nf bi translated"><strong class="is hj"> App Engine默认服务账号无法作用域</strong>。更确切地说，凭证的范围允许你访问所有的谷歌云服务，而不是更多。<em class="jo">在我的公司用例中，我们正在将App Maker应用程序(该服务将于2021年1月停止)迁移到App Engine。现有的App Maker应用程序使用了大量GSuite文档(尤其是Sheet)</em>。<strong class="is hj">要访问工作表API，您需要用<code class="du lt lu lv lw b">https://www.googleapis.com/auth/spreadsheets</code>范围来限定您的凭证</strong>的范围。<strong class="is hj">而你不能</strong></li></ol><p id="cc8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">最好的方法是使用服务帐户模拟</strong>(从而避免服务帐户密钥文件)。换句话说，您<strong class="is hj">不会直接使用ADC </strong>来访问服务，但是您将<strong class="is hj">使用它们来代表另一个服务帐户</strong>生成凭证。使用IAM服务，您可以管理哪些服务帐户可以被模拟或不可以被模拟。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><h2 id="aacf" class="mf jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated"><strong class="ak">权衡取舍</strong></h2><ol class=""><li id="9d93" class="mx my hi is b it kn ix ko jb nw jf nx jj ny jn nl nd ne nf bi translated"><strong class="is hj">您使用同一个ADC(App Engine默认服务帐户)来模拟您想要的所有服务帐户</strong>。<em class="jo">这意味着，如果应用引擎中的“服务1”由于应用引擎默认凭证而能够模拟“服务帐户1”，则“服务1”也能够模拟“服务帐户2”(最初为“服务2”创建的)T26。最后，<strong class="is hj">就好像所有服务都可以访问所有“可模拟”的服务帐户</strong>。而那个<strong class="is hj">打破了最小特权原则。</strong></em></li><li id="16d2" class="mx my hi is b it nm ix nn jb no jf np jj nq jn nl nd ne nf bi translated"><strong class="is hj">云功能默认服务账号也是App Engine默认服务账号</strong>。如果您在部署期间没有自定义您的云函数身份，<strong class="is hj">您的函数</strong> <strong class="is hj">将自动拥有与App Engine服务</strong>相同的权限。</li></ol><p id="0a40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">附加问题:Python和Java Google Auth库本身包含模拟方法。</em> <strong class="is hj"> <em class="jo">其他语言就不是这样了。</em> </strong></p><h2 id="8d0e" class="mf jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated"><strong class="ak">好处</strong></h2><p id="430d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当您在App Engine上使用模拟时，您也可以在本地环境中使用您的用户凭据。因此，y <strong class="is hj">我们在App Engine和您本地的代码是相同的</strong>，您本地测试的代码与将在App Engine上运行的代码完全相同。</p><h2 id="0046" class="mf jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated"><strong class="ak">备选方案</strong></h2><p id="657d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">您还可以为每个服务</strong>生成服务帐户密钥文件，并用您的代码加载它们。<br/> <em class="jo">它的</em> <strong class="is hj"> <em class="jo">没用把密钥文件存储在</em> </strong> <a class="ae ls" href="https://cloud.google.com/secret-manager" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="jo">秘密管理器</em> </strong> <em class="jo"> </em> </a> <em class="jo">里面并检索它们，在运行时，用App Engine默认的服务账户凭证，因为我们回到了#1权衡。而在这种情况下，</em> <strong class="is hj"> <em class="jo">冒名顶替是一个好得多的解决方案。</em> </strong></p><p id="530c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的公司，我们<em class="jo">很遗憾</em> <strong class="is hj">仅将服务帐户密钥文件用于App Engine关键服务，而非所有</strong>。</p><h2 id="4c55" class="mf jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated"><strong class="ak">提示</strong></h2><p id="8a92" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果您部署在App Engine之外的另一个组件上，如云函数和云运行，您可以使用ADC。然而，<strong class="is hj">在您的本地环境中，您的个人用户帐户会有范围问题</strong>。</p><p id="115c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要解决这个问题，<strong class="is hj">在创建凭证时对其进行范围限定</strong>，如下定义范围</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="c8ec" class="mf jq hi lw b fi mg mh l mi mj">gcloud auth application-default login \<br/>  --scopes='<a class="ae ls" href="https://www.googleapis.com/auth/spreadsheets" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/spreadsheets</a>',\<br/>'<a class="ae ls" href="https://www.googleapis.com/auth/cloud-platform" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-platform</a>'</span></pre><h1 id="f007" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.私有云功能和云运行限制</h1><p id="e165" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">第二个问题是当<strong class="is hj">您的本地代码试图调用部署在私有模式</strong>下的云功能或云运行上的服务时。<em class="jo">该模式暗示呼叫者出示签名的身份令牌。</em></p><p id="6853" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要用简单的curl调用私有部署的服务，您可以这样做</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="2d19" class="mf jq hi lw b fi mg mh l mi mj">curl -H "Authorization: Bearer \<br/>  $(gcloud auth print-identity-token)" https://service.url.run.app</span></pre><p id="5424" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Gcloud SDK能够使用您的用户凭据生成签名身份令牌。然而，<strong class="is hj">Google Auth客户端库并没有为用户帐户凭证</strong>实现这一功能，以直接从您的应用代码<em class="jo">访问部署的服务(例如，一个正在本地开发的服务调用另一个在Google Cloud上私有部署的服务)。</em></p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="141a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模拟可以像前面一样工作。<strong class="is hj">但是，我不喜欢这个解决方案，因为你必须在你的代码中执行一个钩子</strong></p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="397c" class="mf jq hi lw b fi mg mh l mi mj">If "I'm using user account credential"<br/>  then "impersonate a service account"<br/>  else "use ADC"</span></pre><p id="a499" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，你的代码<strong class="is hj">在本地和云中的运行方式</strong>并不完全相同。因此，您可能在Google Cloud上遇到了本地没有检测到的问题。<strong class="is hj">它并不真正安全</strong>(一个bug的观点，而不是安全的观点)</p><p id="2445" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，您可以<strong class="is hj">在任何情况下模拟服务帐户，但是这增加了您的应用程序的复杂性</strong>(因此降低了可维护性)。</p><p id="7da8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最新的选择是<strong class="is hj">使用服务账户密钥文件，仅用于本地开发，并且仅具有</strong> <code class="du lt lu lv lw b"><strong class="is hj">run.invoker</strong></code> <strong class="is hj">的作用，以限制泄露</strong>时的影响。</p><p id="0ff7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">我创建了一个</em> <a class="ae ls" href="https://github.com/guillaumeblaquiere/token-generator" rel="noopener ugc nofollow" target="_blank"> <em class="jo">开源项目</em> </a> <em class="jo">，和</em> <a class="ae ls" rel="noopener" href="/google-cloud/easily-generate-google-signed-id-token-with-token-generator-d25b7e235f2e"> <em class="jo">一篇文章</em> </a> <em class="jo">，关于这个主题帮助本地测试，附带一个服务账号密钥文件。</em></p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><h1 id="47ee" class="jp jq hi bd jr js nr ju jv jw ns jy jz ka nt kc kd ke nu kg kh ki nv kk kl km bi translated">怎么办？</h1><p id="2935" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">IAM服务提供了很多可能性，也提供了很多在安全方面做错事的案例。</p><p id="d761" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">一个解决方案可以适用于任何用例</strong>:每次生成一个服务帐户密钥文件。<strong class="is hj">这也是最糟糕、最危险的解决方案。</strong></p><p id="38a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">安全性意味着权衡和理解我们想要达到的目标</strong>。这并不总是容易和自动的。没有唯一的解决方案。</p><p id="b79b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最好的起点是<strong class="is hj">考虑ADC的所有用例，除了3种情况:</strong></p><ul class=""><li id="0304" class="mx my hi is b it iu ix iy jb mz jf na jj nb jn nc nd ne nf bi translated">您的工作负载/应用运行在Google Cloud之外(API、网站后端、CI/CD等)</li><li id="8c87" class="mx my hi is b it nm ix nn jb no jf np jj nq jn nc nd ne nf bi translated">您想要在App Engine上自定义每个服务的服务帐户</li><li id="5ccd" class="mx my hi is b it nm ix nn jb no jf np jj nq jn nc nd ne nf bi translated">您希望使用您的用户帐户从代码(而不是从gcloud CLI)本地调用私有云运行或云功能</li></ul><blockquote class="kz la lb"><p id="203c" class="iq ir jo is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated"><strong class="is hj">这是真的</strong>即使一些例子、教程，甚至Google Cloud文档上的<strong class="is hj">代码样本带有服务帐户密钥文件！</strong></p></blockquote></div></div>    
</body>
</html>