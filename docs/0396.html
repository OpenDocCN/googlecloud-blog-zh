<html>
<head>
<title>Serverless Transfer Learning with Cloud ML Engine and Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云ML引擎和Keras的无服务器迁移学习</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/serverless-transfer-learning-with-cloud-ml-engine-and-keras-335435f31e15?source=collection_archive---------0-----------------------#2017-10-02">https://medium.com/google-cloud/serverless-transfer-learning-with-cloud-ml-engine-and-keras-335435f31e15?source=collection_archive---------0-----------------------#2017-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="12d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用深度学习的图像分类在今天广为人知，但你只听到少量图像分类成功的消息。我想这是因为它需要大量的数据和时间来获得好的结果。</p><p id="8be7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">迁移学习</strong>以一种成熟的方式解决了这样一个问题。<br/>迁移学习是一种使用预先训练好的网络并在网络末端稍加改变的技术，因此您只需重新训练改变的部分。该网络仍然具有提取图像特征的能力，并且可以针对专用图像分类进行微调，还需要更少的时间和更少的数据集来重新训练。然而，在培训和操作方面仍然存在许多麻烦，因此本文将向您展示如何在<a class="ae jd" href="https://cloud.google.com/ml-engine/" rel="noopener ugc nofollow" target="_blank">云ML引擎</a>上轻松使用迁移学习。</p><p id="7922" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；</strong>博士看我的<a class="ae jd" href="https://github.com/hayatoy/cloudml-magic/blob/master/examples/Keras_Fine_Tuning.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>:)</p><h1 id="ba46" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用Keras进行迁移学习</h1><p id="38f6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>是构建迁移学习模型最简单的方法。如上所述，迁移学习模型使用预训练网络，Keras已经有一些很棒的<a class="ae jd" href="https://keras.io/applications/" rel="noopener ugc nofollow" target="_blank">预训练模型</a>。</p><p id="1967" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Keras中的Inception-v3<br/></strong>在Keras中使用预先训练好的模型相当容易，只有下面两行。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d4b3" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">from</strong> keras.applications.inception_v3 <strong class="km hj">import</strong> InceptionV3<br/>model <strong class="km hj">=</strong> InceptionV3(weights<strong class="km hj">=</strong>’imagenet’)</span></pre><p id="dfbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个模型是用ImageNet的数据集预先训练的，它有一百万张图像和1000个类。</p><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kv"><img src="../Images/52bd7e582245b746e1abbbd7bf9b8ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCXqy5c-MwRzJlo7rYPyRQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">通过谷歌研究博客发布的《盗梦空间-v3》图表</figcaption></figure><p id="ee1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用这个模型对下面两幅图像进行分类。因为Inception-v3模型接受RGB 299x299图像作为输入，所以您必须在分类之前转换您的图像。Keras也有一些有用的模块可以做到这一点。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4785" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">from</strong> keras.preprocessing <strong class="km hj">import</strong> image<br/><strong class="km hj">from</strong> keras.applications.inception_v3 <strong class="km hj">import</strong> preprocess_input, decode_predictions<br/><strong class="km hj">import</strong> numpy <strong class="km hj">as</strong> np<br/><br/><em class="lh"># Make input data from Jpeg file</em><br/>img_path <strong class="km hj">=</strong> 'seagull.jpg'<br/>img <strong class="km hj">=</strong> image<strong class="km hj">.</strong>load_img(img_path, target_size<strong class="km hj">=</strong>(299, 299))<br/>x <strong class="km hj">=</strong> image<strong class="km hj">.</strong>img_to_array(img)<br/>x <strong class="km hj">=</strong> np<strong class="km hj">.</strong>expand_dims(x, axis<strong class="km hj">=</strong>0)<br/>x <strong class="km hj">=</strong> preprocess_input(x)<br/><br/><em class="lh"># Classify image</em><br/>preds <strong class="km hj">=</strong> model<strong class="km hj">.</strong>predict(x)<br/><br/><em class="lh"># Print predicted classes</em><br/><strong class="km hj">print</strong>('Predicted:')<br/><strong class="km hj">for</strong> p <strong class="km hj">in</strong> decode_predictions(preds, top<strong class="km hj">=</strong>5)[0]:<br/>    <strong class="km hj">print</strong>("Score {}, Label {}"<strong class="km hj">.</strong>format(p[2], p[1]))</span></pre><p id="0601" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要分类的图像和结果；</p><figure class="kh ki kj kk fd kw er es paragraph-image"><div class="er es li"><img src="../Images/93bfdad99690ef70a422024add0b047e.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*GnRMG7gylnjEbwmd3w-grg.jpeg"/></div></figure><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="81f9" class="kq jf hi km b fi kr ks l kt ku">Predicted:<br/><strong class="km hj">Score 0.965535342693, Label Indian_elephant</strong><br/>Score 0.0246694963425, Label tusker<br/>Score 0.000626200810075, Label African_elephant<br/>Score 0.000182053816388, Label Mexican_hairless<br/>Score 0.000138055766001, Label hippopotamus</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div class="er es li"><img src="../Images/240e5ba084aaf581c305c09465f89211.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*hJK2YZwlmu-HbEDSJuWVmw.jpeg"/></div></figure><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="23db" class="kq jf hi km b fi kr ks l kt ku">Predicted:<br/><strong class="km hj">Score 0.278156191111, Label albatross</strong><br/>Score 0.0422638729215, Label drake<br/>Score 0.0255650430918, Label goose<br/>Score 0.0211290325969, Label red-breasted_merganser<br/>Score 0.019902639091, Label lakeside</span></pre><p id="e034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模型对大象进行了正确的分类，但未能对海鸥进行分类。原因很简单，因为用于训练模型的<a class="ae jd" href="http://image-net.org/challenges/LSVRC/2012/browse-synsets" rel="noopener ugc nofollow" target="_blank">数据集</a>不包括“gull ”,所以它将相似的候选分类。你永远得不到清单之外的结果，这就是为什么需要迁移学习。</p><p id="5f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可视化中间层输出</strong> <br/>在进行迁移学习之前，让我们来可视化中间层输出。要显示图层列表，请运行下面的代码。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="907c" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">import</strong> pandas <strong class="km hj">as</strong> pd<br/>pd<strong class="km hj">.</strong>DataFrame(model<strong class="km hj">.</strong>layers)<strong class="km hj">.</strong>tail()</span></pre><p id="5bc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出如下。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2065" class="kq jf hi km b fi kr ks l kt ku">308  &lt;keras.layers.merge.Concatenate object at 0x7f...<br/>309  &lt;keras.layers.core.Activation object at 0x7fb7...<br/>310  &lt;keras.layers.merge.Concatenate object at 0x7f...<br/>311  &lt;keras.layers.pooling.GlobalAveragePooling2D o...<br/>312  &lt;keras.layers.core.Dense object at 0x7fb7a1a5b...</span></pre><p id="2ab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想要可视化层311的输出，<code class="du lj lk ll km b">GlobalAveragePooling2D</code>，所以让我们构建一个模型来输出中间层的输出。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1639" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">from</strong> keras.models <strong class="km hj">import</strong> Model<br/><br/><em class="lh"># The model which outputs intermediate layer features</em><br/>intermediate_layer_model <strong class="km hj">=</strong> Model(inputs<strong class="km hj">=</strong>model<strong class="km hj">.</strong>input, <br/>                                 outputs<strong class="km hj">=</strong>model<strong class="km hj">.</strong>layers[311]<strong class="km hj">.</strong>output)</span></pre><p id="f416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要提取要素并进行可视化，请运行以下代码。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ec9a" class="kq jf hi km b fi kr ks l kt ku">features <strong class="km hj">=</strong> intermediate_layer_model<strong class="km hj">.</strong>predict(x)<br/>pd<strong class="km hj">.</strong>DataFrame(features<strong class="km hj">.</strong>reshape(<strong class="km hj">-</strong>1,1))<strong class="km hj">.</strong>plot(figsize<strong class="km hj">=</strong>(12, 3))</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lm"><img src="../Images/5782b1e41a14f77948a60d2381d9a945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9KVZRl8wT5iAcXtEuDLuw.png"/></div></div></figure><p id="8805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll km b">GlobalAveragePooling2D</code>的输出是2048尺寸特征。Inception-v3模型在网络末端使用密集层对1000个类进行分类，密集层使用这些特征作为输入。但是现在，我们想分类“其他”类。所以我们去掉这一层，再放一层。</p><p id="8c31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">添加密集层进行微调</strong> <br/>让我们添加密集层，如果我们想分类两个类，代码应该是这样的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8617" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">from</strong> keras.layers <strong class="km hj">import</strong> Dense<br/><br/><em class="lh"># Connect Dense layers at the end</em><br/>x <strong class="km hj">=</strong> intermediate_layer_model<strong class="km hj">.</strong>output<br/>x <strong class="km hj">=</strong> Dense(1024, activation<strong class="km hj">=</strong>'relu')(x)<br/>predictions <strong class="km hj">=</strong> Dense(2, activation<strong class="km hj">=</strong>'softmax')(x)<br/><br/><em class="lh"># Transfer Learning model</em><br/>transfer_model <strong class="km hj">=</strong> Model(inputs<strong class="km hj">=</strong>intermediate_layer_model<strong class="km hj">.</strong>input, outputs<strong class="km hj">=</strong>predictions)</span></pre><p id="4e68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，模型会训练其所有变量。但是我们只想训练我们添加的密集层，所以让我们冻结未训练的层。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a6b1" class="kq jf hi km b fi kr ks l kt ku"><em class="lh"># Freeze all layers</em><br/><strong class="km hj">for</strong> layer <strong class="km hj">in</strong> transfer_model<strong class="km hj">.</strong>layers:<br/>    layer<strong class="km hj">.</strong>trainable <strong class="km hj">=</strong> False<br/><br/><em class="lh"># Unfreeze last dense layers</em><br/>transfer_model<strong class="km hj">.</strong>layers[312]<strong class="km hj">.</strong>trainable <strong class="km hj">=</strong> True<br/>transfer_model<strong class="km hj">.</strong>layers[313]<strong class="km hj">.</strong>trainable <strong class="km hj">=</strong> True<br/><br/>transfer_model<strong class="km hj">.</strong>compile(loss<strong class="km hj">=</strong>'categorical_crossentropy',<br/>                       optimizer<strong class="km hj">=</strong>'adam',<br/>                       metrics<strong class="km hj">=</strong>['accuracy'])</span></pre><p id="9740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搞定了。现在，我们可以针对专用的两类分类对该模型进行微调。</p><p id="10e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两类分类的微调<br/>让我们对下面的图片进行分类。我制作的数据集名为<strong class="ih hj">歌剧院-国会大厦</strong>数据集，包括歌剧院和国会大厦各100张图片。您可以下载代码来创建这个数据集。<br/>T10】https://github.com/hayatoy/deep-learning-datasets</p><figure class="kh ki kj kk fd kw er es paragraph-image"><div class="er es ln"><img src="../Images/c99ad3503103c133537bf916b0676e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*iHxe57geQ_CkXsdYnu-ZWw.png"/></div></figure><p id="adec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加载数据集</strong> <br/>数据集被压缩为NumPy格式，存储在GitHub中，可以如下使用。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c350" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">import</strong> requests<br/><br/>url <strong class="km hj">=</strong> 'https://github.com/hayatoy/deep-learning-datasets/releases/download/v0.1/tl_opera_capitol.npz'<br/>response <strong class="km hj">=</strong> requests<strong class="km hj">.</strong>get(url)<br/>dataset <strong class="km hj">=</strong> np<strong class="km hj">.</strong>load(BytesIO(response<strong class="km hj">.</strong>content))<br/><br/>X_dataset <strong class="km hj">=</strong> dataset['features']<br/>y_dataset <strong class="km hj">=</strong> dataset['labels']</span></pre><p id="f760" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将数据集分为训练数据集和测试数据集，这里我将80%的数据集分为训练数据集，20%的数据集分为测试数据集。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1517" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">from</strong> keras.utils <strong class="km hj">import</strong> np_utils<br/><strong class="km hj">from</strong> sklearn.model_selection <strong class="km hj">import</strong> train_test_split<br/><br/>X_dataset <strong class="km hj">=</strong> preprocess_input(X_dataset)<br/>y_dataset <strong class="km hj">=</strong> np_utils<strong class="km hj">.</strong>to_categorical(y_dataset)<br/>X_train, X_test, y_train, y_test <strong class="km hj">=</strong> train_test_split(<br/>    X_dataset, y_dataset, test_size<strong class="km hj">=</strong>0.2, random_state<strong class="km hj">=</strong>42)</span></pre><p id="7972" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便问一下，如果正常的Inception-v3模型对数据集进行分类会是什么结果？让我们看看进展如何。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f898" class="kq jf hi km b fi kr ks l kt ku">x <strong class="km hj">=</strong> X_dataset[0]<br/>x <strong class="km hj">=</strong> np<strong class="km hj">.</strong>expand_dims(x, axis<strong class="km hj">=</strong>0)<br/><br/>preds <strong class="km hj">=</strong> model<strong class="km hj">.</strong>predict(x)<br/><strong class="km hj">print</strong>('Predicted:')<br/><strong class="km hj">for</strong> p <strong class="km hj">in</strong> decode_predictions(preds, top<strong class="km hj">=</strong>5)[0]:<br/>    <strong class="km hj">print</strong>("Score {}, Label {}"<strong class="km hj">.</strong>format(p[2], p[1]))</span></pre><p id="d831" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据集的第一幅图像是歌剧院。这是结果..残骸。同样，因为原始ImageNet数据集不包括歌剧院。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b613" class="kq jf hi km b fi kr ks l kt ku">Predicted:<br/><strong class="km hj">Score 0.110657587647, Label wreck</strong><br/>Score 0.0671983659267, Label lakeside<br/>Score 0.0309968702495, Label seashore<br/>Score 0.0249739717692, Label breakwater<br/>Score 0.0229569561779, Label fountain</span></pre><p id="fa48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">微调模型为Opera-Capitol </strong> <br/>训练转移学习模型，只需调用<code class="du lj lk ll km b">fit</code> <strong class="ih hj"> </strong>函数即可。之后，让我们来评估一下这个模型是如何正确预测的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="46be" class="kq jf hi km b fi kr ks l kt ku">transfer_model<strong class="km hj">.</strong>fit(X_train, y_train, epochs<strong class="km hj">=</strong>20,<br/>                   validation_data<strong class="km hj">=</strong>(X_test, y_test))<br/>loss, acc <strong class="km hj">=</strong> transfer_model<strong class="km hj">.</strong>evaluate(X_test, y_test)<br/><strong class="km hj">print</strong>('Loss {}, Accuracy {}'<strong class="km hj">.</strong>format(loss, acc))</span></pre><p id="5eb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试数据的评估结果为..</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0cd9" class="kq jf hi km b fi kr ks l kt ku">Loss 0.112133163214, Accuracy 0.975</span></pre><p id="214e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准确率达到了97.5%！</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="5853" class="je jf hi bd jg jh lv jj jk jl lw jn jo jp lx jr js jt ly jv jw jx lz jz ka kb bi translated">在云ML引擎上训练模型</h1><p id="108b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">迁移学习模式大约需要。如果您在云ML引擎上运行，在没有GPU的本地机器上进行10到20分钟的培训..只有一分钟。(加上几分钟的准备时间)</p><p id="fd7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">制作包</strong> <br/>要在Cloud ML引擎上训练你的模型，你必须先把你的代码做一个包。在本例中，我们使用<strong class="ih hj"> keras </strong>、<strong class="ih hj"> h5py </strong>和<strong class="ih hj"> Pillow </strong>作为外部库，因此您必须将这些库包含在您的<code class="du lj lk ll km b">setup.py</code>中。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="70dd" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">from</strong> setuptools <strong class="km hj">import</strong> setup<br/><strong class="km hj">if</strong> __name__ <strong class="km hj">==</strong> '__main__':<br/>    setup(name<strong class="km hj">=</strong>'trainer',<br/>          packages<strong class="km hj">=</strong>['trainer'],<br/>          install_requires<strong class="km hj">=</strong>['keras','h5py','Pillow'])</span></pre><p id="35bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">云ML引擎从Jupyter笔记本</strong> <br/>打包，上传到Google云存储，运行ML引擎的工作真的很累。你不想在ML引擎上运行你的Jupyter笔记本代码吗？我为此做了扩展！<br/><a class="ae jd" href="https://github.com/hayatoy/cloudml-magic" rel="noopener ugc nofollow" target="_blank">https://github.com/hayatoy/cloudml-magic</a></p><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ma"><img src="../Images/08a15877c09715a298342831d5fc38ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gnjo5yH0xRRLSOcley3B3g.png"/></div></div></figure><h1 id="b739" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">云ML引擎的在线预测</h1><p id="139b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在你想为你训练过的模型服务，怎么做呢？实现HTTP服务器，在服务器上设置TensorFlow或Keras，负载平衡等..那是触摸工作。在Cloud ML Engine上，你只需要把你的模型上传到GCS (Google云存储)上。它服务于您的模型，接受REST API的预测请求，当然还有自动缩放。</p><p id="2ca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">构建一个转换图像的图形</strong> <br/>由于Keras模型只接受原始图像数组作为输入，我们应该将Jpeg或Png格式转换为原始图像数组，否则REST API请求的有效负载会太大。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6c24" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">with</strong> tf<strong class="km hj">.</strong>Graph()<strong class="km hj">.</strong>as_default() <strong class="km hj">as</strong> g_input:<br/>    input_b64 <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>placeholder(shape<strong class="km hj">=</strong>(1,),<br/>                               dtype<strong class="km hj">=</strong>tf<strong class="km hj">.</strong>string,<br/>                               name<strong class="km hj">=</strong>'input')<br/>    input_bytes <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>decode_base64(input_b64[0])<br/>    image <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>image<strong class="km hj">.</strong>decode_image(input_bytes)<br/>    image_f <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>image<strong class="km hj">.</strong>convert_image_dtype(image, dtype<strong class="km hj">=</strong>tf<strong class="km hj">.</strong>float32)<br/>    input_image <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>expand_dims(image_f, 0)<br/>    output <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>identity(input_image, name<strong class="km hj">=</strong>'input_image')<br/><br/><em class="lh"># Convert to GraphDef</em><br/>g_input_def <strong class="km hj">=</strong> g_input<strong class="km hj">.</strong>as_graph_def()</span></pre><p id="e00b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来我们将Keras模型转换为<code class="du lj lk ll km b">tf.GraphDef</code>，这样我们就可以连接上图了。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7af6" class="kq jf hi km b fi kr ks l kt ku">sess <strong class="km hj">=</strong> K<strong class="km hj">.</strong>get_session()<br/><br/><strong class="km hj">from</strong> tensorflow.python.framework <strong class="km hj">import</strong> graph_util<br/><br/><em class="lh"># Make GraphDef of Transfer Model</em><br/>g_trans <strong class="km hj">=</strong> sess<strong class="km hj">.</strong>graph<br/>g_trans_def <strong class="km hj">=</strong> graph_util<strong class="km hj">.</strong>convert_variables_to_constants(sess, <br/>                      g_trans<strong class="km hj">.</strong>as_graph_def(),<br/>                      [transfer_model<strong class="km hj">.</strong>output<strong class="km hj">.</strong>name<strong class="km hj">.</strong>replace(':0','')])</span></pre><p id="342d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是组合图，它接受base64编码的Jpeg或Png文件，然后输出迁移学习模型的分类结果。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6dae" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">with</strong> tf<strong class="km hj">.</strong>Graph()<strong class="km hj">.</strong>as_default() <strong class="km hj">as</strong> g_combined:<br/>    x <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>placeholder(tf<strong class="km hj">.</strong>string, name<strong class="km hj">=</strong>"input_b64")<br/><br/>    im, <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>import_graph_def(g_input_def,<br/>                              input_map<strong class="km hj">=</strong>{'input:0': x},<br/>                              return_elements<strong class="km hj">=</strong>["input_image:0"])<br/><br/>    pred, <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>import_graph_def(g_trans_def,<br/>             input_map<strong class="km hj">=</strong>{transfer_model<strong class="km hj">.</strong>input<strong class="km hj">.</strong>name: im,<br/>             'batch_normalization_1/keras_learning_phase:0': False},<br/>             return_elements<strong class="km hj">=</strong>[transfer_model<strong class="km hj">.</strong>output<strong class="km hj">.</strong>name])</span></pre><p id="c292" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将模型上传到GCS之前，我们必须将模型转换成<code class="du lj lk ll km b">SavedModel</code>格式。下面的代码将图形转换成<code class="du lj lk ll km b">SavedModel</code>格式，并直接保存到GCS。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0d06" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">with</strong> tf<strong class="km hj">.</strong>Session() <strong class="km hj">as</strong> sess2:<br/>  inputs <strong class="km hj">=</strong> {"inputs": tf<strong class="km hj">.</strong>saved_model<strong class="km hj">.</strong>utils<strong class="km hj">.</strong>build_tensor_info(x)}<br/>  outputs <strong class="km hj">=</strong> {"outputs":tf<strong class="km hj">.</strong>saved_model<strong class="km hj">.</strong>utils<strong class="km hj">.</strong>build_tensor_info(pred)}<br/>  signature <strong class="km hj">=</strong>tf<strong class="km hj">.</strong>saved_model<strong class="km hj">.</strong>signature_def_utils<strong class="km hj">.</strong>build_signature_def(<br/>            inputs<strong class="km hj">=</strong>inputs,<br/>            outputs<strong class="km hj">=</strong>outputs,<br/>  method_name<strong class="km hj">=</strong>tf<strong class="km hj">.</strong>saved_model<strong class="km hj">.</strong>signature_constants<strong class="km hj">.</strong>PREDICT_METHOD_NAME<br/>        )<br/><br/>  <em class="lh"># save as SavedModel</em><br/>  b <strong class="km hj">=</strong> tf<strong class="km hj">.</strong>saved_model<strong class="km hj">.</strong>builder<strong class="km hj">.</strong>SavedModelBuilder('gs://{BUCKET}/mdl')<br/>  b<strong class="km hj">.</strong>add_meta_graph_and_variables(sess2,<br/>                  [tf<strong class="km hj">.</strong>saved_model<strong class="km hj">.</strong>tag_constants<strong class="km hj">.</strong>SERVING],<br/>                  signature_def_map<strong class="km hj">=</strong>{'serving_default': signature})<br/>  b<strong class="km hj">.</strong>save()</span></pre><p id="0de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将模型注册到ML引擎。只需键入以下两个命令。这可能需要几分钟..所以喝杯茶就完事了。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a2b0" class="kq jf hi km b fi kr ks l kt ku">gcloud ml-engine models create OperaCapitol<br/>gcloud ml-engine versions create v1 \<br/>          --model OperaCapitol \<br/>          --runtime-version 1.2 \<br/>          --origin gs://<strong class="km hj">{</strong>BUCKET<strong class="km hj">}</strong>/mdl</span></pre><h1 id="5dbc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">通过在线预测对图像分类</h1><p id="c11b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">要通过在线预测对一个图像进行分类，只需调用它的REST API即可。如果您在Python环境中请求，使用discovery api库要容易得多。下面是如何初始化在线预测的发现api。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f899" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">from</strong> oauth2client.client <strong class="km hj">import</strong> GoogleCredentials<br/><strong class="km hj">from</strong> googleapiclient <strong class="km hj">import</strong> discovery<br/><strong class="km hj">from</strong> googleapiclient <strong class="km hj">import</strong> errors<br/><br/>PROJECTID <strong class="km hj">=</strong> 'PROJECTID'<br/>projectID <strong class="km hj">=</strong> 'projects/{}'<strong class="km hj">.</strong>format(PROJECTID)<br/>modelName <strong class="km hj">=</strong> 'OperaCapitol'<br/>modelID <strong class="km hj">=</strong> '{}/models/{}'<strong class="km hj">.</strong>format(projectID, modelName)<br/><br/>credentials <strong class="km hj">=</strong> GoogleCredentials<strong class="km hj">.</strong>get_application_default()<br/>ml <strong class="km hj">=</strong> discovery<strong class="km hj">.</strong>build('ml', 'v1', credentials<strong class="km hj">=</strong>credentials)</span></pre><p id="219b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们对一个图像进行分类。转换器图形没有任何调整大小的功能，你必须自己调整图像到299x299。另外，不要忘记将图像编码为base64。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c3fa" class="kq jf hi km b fi kr ks l kt ku"><strong class="km hj">with</strong> open('opera.jpg', 'rb') <strong class="km hj">as</strong> f:<br/>    b64_x <strong class="km hj">=</strong> f<strong class="km hj">.</strong>read()<br/><strong class="km hj">import</strong> base64<br/><strong class="km hj">import</strong> json<br/><br/>b64_x <strong class="km hj">=</strong> base64<strong class="km hj">.</strong>urlsafe_b64encode(b64_x)<br/>input_instance <strong class="km hj">=</strong> dict(inputs<strong class="km hj">=</strong>b64_x)<br/>input_instance <strong class="km hj">=</strong> json<strong class="km hj">.</strong>loads(json<strong class="km hj">.</strong>dumps(input_instance))<br/>request_body <strong class="km hj">=</strong> {"instances": [input_instance]}<br/><br/>request <strong class="km hj">=</strong> ml<strong class="km hj">.</strong>projects()<strong class="km hj">.</strong>predict(name<strong class="km hj">=</strong>modelID, body<strong class="km hj">=</strong>request_body)<br/><strong class="km hj">try</strong>:<br/>    response <strong class="km hj">=</strong> request<strong class="km hj">.</strong>execute()<br/><strong class="km hj">except</strong> errors<strong class="km hj">.</strong>HttpError <strong class="km hj">as</strong> err:<br/>    <strong class="km hj">print</strong>(err<strong class="km hj">.</strong>_get_reason())<br/>response</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div class="er es li"><img src="../Images/87035bdacd2c4d0cc51b516f209dc00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*OvN0EAWdOtmAZXMWjntTzw.jpeg"/></div></figure><p id="f1b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是网上预测的回应。“输出”清单分别代表歌剧院和国会大厦的信心。<br/> 99.7%为歌剧院，没错！</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8912" class="kq jf hi km b fi kr ks l kt ku">{u'predictions': [<br/>    {u'outputs': [0.9974665641784668, 0.00253341649658978]}<br/>]}</span></pre><p id="2294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到这篇文章的代码；<br/><a class="ae jd" href="https://github.com/hayatoy/cloudml-magic" rel="noopener ugc nofollow" target="_blank">https://github.com/hayatoy/cloudml-magic</a></p><p id="34ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">享受云ML引擎！</p></div></div>    
</body>
</html>