<html>
<head>
<title>Making Newtonsoft.Json and Protocol Buffers play nicely together.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作Newtonsoft。Json和协议缓冲区配合得很好。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/making-newtonsoft-json-and-protocol-buffers-play-nicely-together-fe92079cc91c?source=collection_archive---------0-----------------------#2018-04-04">https://medium.com/google-cloud/making-newtonsoft-json-and-protocol-buffers-play-nicely-together-fe92079cc91c?source=collection_archive---------0-----------------------#2018-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="908e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在尝试将一些<a class="ae jd" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议消息</a>序列化到json时遇到了一个问题。当<a class="ae jd" href="https://www.newtonsoft.com/json" rel="noopener ugc nofollow" target="_blank"> Newtonsoft。Json </a>反序列化了我的协议消息，它与原始消息不匹配。我找到了一个简单的工作，可能对你也有用。</p><h1 id="fae3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">协议缓冲区</h1><p id="3706" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据——比如XML，但是更小、更快、更简单。一旦定义了数据的结构化方式，就可以使用生成的源代码轻松地编写和读取结构化数据。协议缓冲区也知道如何像json一样读写自己。下面是一个协议消息定义示例:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="91ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在为一个新的<a class="ae jd" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Google Stackdriver </a> API编写样本。几乎所有Google的云API都使用协议缓冲区作为它们的网络格式。</p><p id="9b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有一个名为<code class="du ko kp kq kr b">AlertPolicy</code>的协议消息。我想把它作为json序列化到磁盘上，这样就可以很容易地备份和恢复我所有的警报策略。协议缓冲库可以很容易地为我序列化一个<code class="du ko kp kq kr b">AlertPolicy</code>，但是它不能序列化一个<code class="du ko kp kq kr b">IEnumerable&lt;AlertPolicy&gt;</code>。更一般地说，协议缓冲库知道如何将协议消息序列化为json，但是被序列化的根对象必须是协议消息。</p><p id="6db9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我看了Newtonsoft.Json。</p><h1 id="9324" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">纽顿软件。Json</h1><p id="1e17" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="https://www.newtonsoft.com/json" rel="noopener ugc nofollow" target="_blank">牛顿软件。Json </a>是用<a class="ae jd" href="https://www.microsoft.com/net/" rel="noopener ugc nofollow" target="_blank">序列化和反序列化<a class="ae jd" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> json </a>最流行的库。网</a>。这也是最受欢迎的一个原因:这个库使得对象与json之间的相互转换变得很简单。将对象转换成json字符串只需要一行代码，<code class="du ko kp kq kr b">JsonConvert.SerializeObject(yourObject)</code>:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="816d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，我试着用Newtonsoft.Json序列化我的<code class="du ko kp kq kr b">IEnumerable&lt;AlertPolicy&gt;</code>。我发现的问题是，当我反序列化<code class="du ko kp kq kr b">IEnumerable&lt;AlertPolicy&gt;</code>并将其与我最初的<code class="du ko kp kq kr b">IEnumerable&lt;AlertPolicy&gt;</code>进行比较时，一大块数据丢失了。</p><p id="d91a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="71ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="53e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，牛顿软件。Json允许我指定一个定制的JSON转换器。我实现了一个定制的JsonConverter，它使用Protocol Buffers的json序列化函数来避免丢失数据。因此，30行代码之后，我有了一个序列化所有协议消息的解决方案:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="2003" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是这样调用它的:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="b9db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，耶！我可以将这个<code class="du ko kp kq kr b">ProtoMessageConverter</code>用于任何包含协议消息对象的对象，一切都会正确地序列化和反序列化。你也可以。完整的样本代码保存在github.com的T4。</p></div></div>    
</body>
</html>