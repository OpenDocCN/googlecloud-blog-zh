<html>
<head>
<title>Build a blog application on Google App Engine: Image module (part 6)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google App Engine上构建一个博客应用程序:图像模块(第6部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-image-module-part-6-f5eb3eeb49ee?source=collection_archive---------1-----------------------#2018-12-07">https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-image-module-part-6-f5eb3eeb49ee?source=collection_archive---------1-----------------------#2018-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ebe5432f07ecf7c7f588529c5ec451f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxmpaK__KFAXbDL7Pud5XA.jpeg"/></div></div></figure><p id="cc67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是关于如何使用<strong class="is hj"> Google Datastore </strong>在Node.js中构建一个小型博客应用程序并将其部署到<strong class="is hj"> Google App Engine </strong>的多部分教程的第六部分。如果你错过了开头，<a class="ae jo" rel="noopener" href="/google-cloud/build-a-blog-application-on-google-app-engine-setup-part-1-38dab981b779">跳到第一部分</a>，在那里我解释了如何建立这个项目，在那里你可以找到其他部分的链接。</p><p id="84fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将创建<em class="jp">图片</em>模块，它将允许我们在<strong class="is hj"> Google云存储</strong>中<strong class="is hj">上传</strong>和<strong class="is hj">删除</strong>特色图片。</p><p id="bcee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是首先，让我们做一个快速重构。让我们把我们在上一篇文章中创建的<strong class="is hj">文件上传中间件</strong>移到<em class="jp">图像</em>模块中。通过这样做，中间件将可以从一个地方供其他模块使用。打开“<em class="jp"> admin.routes.ts </em>”文件，删除顶部导入<code class="du jq jr js jt b">multer</code>的行以及以<code class="du jq jr js jt b">const uploadInMemory = multer(...)</code>开头的块</p><p id="10bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="jp">图像</em>模块中新建一个文件，命名为“<em class="jp">middleware . ts</em>”。添加以下内容:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="d803" class="kc kd hi jt b fi ke kf l kg kh">// modules/images/middlewares.ts</span><span id="9d85" class="kc kd hi jt b fi ki kf l kg kh">import multer from "multer";</span><span id="9b30" class="kc kd hi jt b fi ki kf l kg kh">export interface ImagesMiddleware {<br/>  uploadInMemory: multer.Instance;<br/>}</span><span id="00dc" class="kc kd hi jt b fi ki kf l kg kh">export default (): ImagesMiddleware =&gt; ({<br/>  /**<br/>   * Multer handles parsing multipart/form-data requests.<br/>   * This instance is configured to store images in memory<br/>   */<br/>  uploadInMemory: multer({<br/>    storage: multer.memoryStorage(),<br/>    limits: {<br/>      fileSize: 5 * 1024 * 1024 // no larger than 5mb<br/>    },<br/>    fileFilter: (req, file, cb) =&gt; {<br/>      // Validate image type<br/>      if (["image/jpeg", "image/png"].indexOf(file.mimetype) &lt; 0) {<br/>        const err = new Error(<br/>          `File type not allowed: ${req.file.mimetype}`<br/>        );<br/>        return cb(err, false);<br/>      }<br/>      return cb(null, true);<br/>    }<br/>  })<br/>});</span></pre><p id="ab07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，现在我们已经将<code class="du jq jr js jt b">uploadInMemory()</code>中间件移动到它自己的层，打开我们的<em class="jp"> Images </em>模块的"<em class="jp"> index.ts </em>"条目文件，并将其内容替换为:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="816a" class="kc kd hi jt b fi ke kf l kg kh">// modules/images/index.ts</span><span id="4c8e" class="kc kd hi jt b fi ki kf l kg kh">import { Context } from "./models";</span><span id="7f61" class="kc kd hi jt b fi ki kf l kg kh">import initImagesMiddleware, {<br/>  ImagesMiddleware<br/>} from "./middlewares";</span><span id="e5d2" class="kc kd hi jt b fi ki kf l kg kh">export interface ImagesModule {<br/>  middlewares: ImagesMiddleware;<br/>}</span><span id="1a17" class="kc kd hi jt b fi ki kf l kg kh">export default (context: Context): ImagesModule =&gt; {<br/>  const middlewares = initImagesMiddleware();</span><span id="d014" class="kc kd hi jt b fi ki kf l kg kh">  return {<br/>    middlewares<br/>  };<br/>};</span></pre><p id="312f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们回到"<em class="jp"> admin.routes.ts </em>"文件，并使用来自<em class="jp"> Images </em>模块的新的<code class="du jq jr js jt b">uploadInMemory()</code>中间件。</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="8020" class="kc kd hi jt b fi ke kf l kg kh">// modules/admin/admin.routes.ts</span><span id="ba36" class="kc kd hi jt b fi ki kf l kg kh">...<br/>router.get("/edit-post/:id", routesHandlers.editPost);<br/>router.post(<br/>  "/create-post",<br/>  [images.middlewares.uploadInMemory.single("image")],<br/>  routesHandlers.createPost<br/>);<br/>router.post(<br/>  "/edit-post/:id",<br/>  [images.middlewares.uploadInMemory.single("image")],<br/>  routesHandlers.editPost<br/>);<br/>...</span></pre><p id="9f10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们有一个中间件，它将<strong class="is hj"> <em class="jp">解析</em> </strong>任何进入请求的图像文件。我们现在需要一个中间件，它将<strong class="is hj"> <em class="jp">上传</em>这个文件到</strong> <strong class="is hj">谷歌云存储</strong>。为此，我们将创建一个抽象层来上传和删除GCS中的文件。我们开始吧！</p><p id="48b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="jp">图像</em>模块中，创建一个新文件“<em class="jp">Google-cloud-storage . ts</em>”，并添加以下内容:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="4894" class="kc kd hi jt b fi ke kf l kg kh">// modules/images/google-cloud-storage.ts</span><span id="f0ad" class="kc kd hi jt b fi ki kf l kg kh">import { Context } from "./models";</span><span id="7e4d" class="kc kd hi jt b fi ki kf l kg kh">export interface GoogleCloudStorage {<br/>  uploadFile(<br/>    fileName: string,<br/>    mimetype: string,<br/>    buffer: Buffer<br/>  ): Promise&lt;any&gt;;<br/>}</span><span id="5032" class="kc kd hi jt b fi ki kf l kg kh">export default ({<br/>  config,<br/>  logger,<br/>  storage<br/>}: Context): GoogleCloudStorage =&gt; {<br/>  const bucketId = config.gcloud.storage.bucket;<br/>  const bucket = storage.bucket(bucketId);</span><span id="857f" class="kc kd hi jt b fi ki kf l kg kh">  /**<br/>   * Returns the public, anonymously accessible URL to a given Cloud <br/>   * Storage object. The object's ACL has to be set to public read.<br/>   *<br/>   * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} objectName -- Storage object to retrieve<br/>   */<br/>  const getPublicUrl = (objectName: string) =&gt;<br/>    `<a class="ae jo" href="https://storage.googleapis.com/${bucketId}/${objectName}`" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/${bucketId}/${objectName}`</a>;</span><span id="8db3" class="kc kd hi jt b fi ki kf l kg kh">  const uploadFile = (<br/>    fileName: string,<br/>    mimetype: string,<br/>    buffer: Buffer<br/>  ) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      const gcsname =<br/>        Date.now() + fileName.replace(/\W+/g, "-").toLowerCase();<br/>      const googleStorageFile = bucket.file(gcsname);</span><span id="811d" class="kc kd hi jt b fi ki kf l kg kh">      const stream = googleStorageFile.createWriteStream({<br/>        metadata: {<br/>          contentType: mimetype,<br/>          cacheControl: "public, max-age=31536000" // cahe 1 year<br/>        },<br/>        validation: "crc32c",<br/>        predefinedAcl: "publicRead"<br/>      });</span><span id="10f8" class="kc kd hi jt b fi ki kf l kg kh">      stream.on("error", reject);</span><span id="3522" class="kc kd hi jt b fi ki kf l kg kh">      stream.on("finish", () =&gt; {<br/>        resolve({<br/>          cloudStorageObject: gcsname,<br/>          cloudStoragePublicUrl: getPublicUrl(gcsname)<br/>        });<br/>      });</span><span id="c00d" class="kc kd hi jt b fi ki kf l kg kh">      stream.end(buffer);<br/>    });<br/>  };</span><span id="65d5" class="kc kd hi jt b fi ki kf l kg kh">  return {<br/>    uploadFile<br/>  };<br/>};</span></pre><p id="5f02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们快速浏览一下代码。首先，我们导入一会儿将要添加的<code class="du jq jr js jt b">Context</code>类型。然后我们声明我们的<code class="du jq jr js jt b">GoogleCloudStorage</code>接口，它现在只有一个方法:<code class="du jq jr js jt b">uploadFile()</code>。</p><p id="f6e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，<em class="jp">上下文</em>是该层的必需输入，我们已经从其中析构了<em class="jp">配置</em>、<em class="jp">记录器</em>和<em class="jp">存储</em>对象。然后，我们从配置对象中读取<code class="du jq jr js jt b">bucketId</code>，并<strong class="is hj">创建一个Google云存储桶实例</strong> ( <code class="du jq jr js jt b">bucket</code>)，我们将在其中上传文件<strong class="is hj">。</strong></p><p id="8e42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们为文件生成一个<strong class="is hj">唯一名称</strong>(通过获取当前日期并删除任何非单词字符)，最后我们<strong class="is hj">创建一个存储文件对象</strong> ( <code class="du jq jr js jt b">googleStorageFile</code>)，我们将能够向其中写入(<em class="jp">流</em>)数据。</p><p id="ee37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们<strong class="is hj">创建Express中间件</strong>，它将利用我们新的<code class="du jq jr js jt b">GoogleCloudStorage</code>层并将文件保存在Google Storage中。打开“<em class="jp">middleware . t</em>s”文件，添加以下内容:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="75b9" class="kc kd hi jt b fi ke kf l kg kh">// modules/images/middlewares.ts</span><span id="597e" class="kc kd hi jt b fi ki kf l kg kh">import { Request, Response, NextFunction } from "express"; // Add<br/>import multer from "multer";<br/>import { GoogleCloudStorage } from "./google-cloud-storage"; // Add</span><span id="a814" class="kc kd hi jt b fi ki kf l kg kh">export interface ImagesMiddleware {<br/>  uploadInMemory: multer.Instance;<br/>  uploadToGCS(req: Request, _: Response, next: NextFunction): void;<br/>}</span><span id="d796" class="kc kd hi jt b fi ki kf l kg kh">export default (<br/>  googleCloudStorage: GoogleCloudStorage // Add the dependency<br/>): ImagesMiddleware =&gt; ({<br/>  /**<br/>   * Multer handles parsing multipart/form-data requests.<br/>   * This instance is configured to store images in memory<br/>   */<br/>  uploadInMemory: multer({ ... }),<br/>  /**<br/>   * Middleware to upload a file in memory (buffer) to Google Cloud <br/>   * Storage Once the file is processed we add a <br/>   * "cloudStorageObject" and "cloudStoragePublicUrl" property<br/>   */<br/>  uploadToGCS(req, _, next) {<br/>    if (!req.file) {<br/>      return next();<br/>    }</span><span id="2462" class="kc kd hi jt b fi ki kf l kg kh">    const { originalname, mimetype, buffer } = req.file;<br/>    googleCloudStorage<br/>      .uploadFile(originalname, mimetype, buffer)<br/>      .then(<br/>        ({ cloudStorageObject, cloudStoragePublicUrl }: any) =&gt; {<br/>          (&lt;any&gt;req.file).cloudStorageObject = cloudStorageObject;<br/>          (&lt;any&gt;(<br/>            req.file<br/>          )).cloudStoragePublicUrl = cloudStoragePublicUrl;</span><span id="ed75" class="kc kd hi jt b fi ki kf l kg kh">          next();<br/>        }<br/>      )<br/>      .catch((err: any) =&gt; {<br/>        next(err);<br/>      });<br/>  }<br/>});</span></pre><p id="b2c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先从Express导入一些类型。然后，在我们的中间件中，我们首先检查请求对象上是否有文件，如果没有，我们通过调用<code class="du jq jr js jt b">next()</code>退出中间件。代码的其余部分非常简单，重要的部分是当文件完成上传时，我们<strong class="is hj">向文件对象添加两个属性</strong>:<code class="du jq jr js jt b">cloudStorageObject</code>和<code class="du jq jr js jt b">cloudStoragePublicUrl</code>。这些是我们将保存在数据存储<strong class="is hj">中的属性，以便在需要时显示或删除图像</strong>。</p><p id="c336" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们快速添加我们缺少的类型。在同一文件夹中创建一个“<em class="jp"> models.ts </em>”文件，并添加以下内容:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="bfc4" class="kc kd hi jt b fi ke kf l kg kh">// modules/images/models.ts</span><span id="a110" class="kc kd hi jt b fi ki kf l kg kh">import Storage from "<a class="ae jo" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/storage";<br/>import { Logger } from "winston";</span><span id="ae38" class="kc kd hi jt b fi ki kf l kg kh">export type Config = {<br/>  gcloud: {<br/>    projectId: string;<br/>    storage: {<br/>      bucket: string;<br/>    };<br/>  };<br/>};</span><span id="2de5" class="kc kd hi jt b fi ki kf l kg kh">export type Context = {<br/>  logger: Logger;<br/>  config: Config;<br/>  storage: Storage;<br/>};</span></pre><p id="895d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们<strong class="is hj">初始化</strong>我们的<em class="jp"> google-cloud-storage </em>层，然后<strong class="is hj">将</strong>层提供给我们的中间件层。从我们的<em class="jp">图像</em>模块中打开“<em class="jp"> index.ts </em>”文件，并添加以下内容:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="1953" class="kc kd hi jt b fi ke kf l kg kh">// modules/images/index.ts</span><span id="0064" class="kc kd hi jt b fi ki kf l kg kh">import { Context } from "./models";</span><span id="3c46" class="kc kd hi jt b fi ki kf l kg kh">import initImagesMiddleware, {<br/>  ImagesMiddleware<br/>} from "./middlewares";</span><span id="47aa" class="kc kd hi jt b fi ki kf l kg kh">import initGCS, { // Add this import<br/>  GoogleCloudStorage<br/>} from "./google-cloud-storage";</span><span id="b111" class="kc kd hi jt b fi ki kf l kg kh">export interface ImagesModule {<br/>  middlewares: ImagesMiddleware;<br/>  GCS: GoogleCloudStorage; // Add this line<br/>}</span><span id="005a" class="kc kd hi jt b fi ki kf l kg kh">export default (context: Context): ImagesModule =&gt; {<br/>  const GCS = initGCS(context); // Add this<br/>  const middlewares = initImagesMiddleware(GCS); // Edit</span><span id="4b70" class="kc kd hi jt b fi ki kf l kg kh">  return {<br/>    middlewares,<br/>    GCS<br/>  };<br/>};</span></pre><p id="0685" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在需要为我们的<em class="jp">图像</em>模块提供<strong class="is hj">上下文</strong>。打开主“<em class="jp"> modules.ts </em>”文件:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="b6bd" class="kc kd hi jt b fi ke kf l kg kh">// modules.ts</span><span id="d53d" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="59e1" class="kc kd hi jt b fi ki kf l kg kh">export default (context: Context): AppModules =&gt; {<br/>  const utils = initUtilsModule();<br/>  const images = initImagesModule(context); // Edit this line<br/>  ...</span></pre><p id="fbf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，最后要做的事情是将我们的<code class="du jq jr js jt b">uploadToGCS()</code> Express中间件添加到我们的管理路径中:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="e9ae" class="kc kd hi jt b fi ke kf l kg kh">// modules/admin/admin.routes.ts</span><span id="4989" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="92db" class="kc kd hi jt b fi ki kf l kg kh">router.post(<br/>  "/create-post",<br/>  [<br/>    images.middlewares.uploadInMemory.single("image"),<br/>    images.middlewares.uploadToGCS // Add this line<br/>  ],<br/>  routesHandlers.createPost<br/>);<br/>router.post(<br/>  "/edit-post/:id",<br/>  [<br/>    images.middlewares.uploadInMemory.single("image"),<br/>    images.middlewares.uploadToGCS // Add this line<br/>  ],<br/>  routesHandlers.editPost<br/>);</span><span id="47c6" class="kc kd hi jt b fi ki kf l kg kh">...</span></pre><p id="2823" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！有了这个，我们应该能够<strong class="is hj">上传一个图像文件到我们的Google存储桶</strong>。但是我们仍然需要在我们的<em class="jp"> BlogPost </em>实体中保存我们在file对象上添加的两个属性(<code class="du jq jr js jt b">cloudStorageObject</code>和<code class="du jq jr js jt b">cloudStoragePublicUrl</code>)。为此，我们将使用一个<strong class="is hj"> gstore中间件</strong>，它将在blog post实体被保存到数据存储之前<em class="jp">执行。</em></p><h1 id="60f6" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">gstore中间件</h1><p id="2cc5" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">中间件(或称<em class="jp">钩子</em>)是在之前<em class="jp">或</em>之后<em class="jp">执行的函数。目标函数被调用(<a class="ae jo" rel="noopener" href="/@sebelga/simplify-your-code-adding-hooks-to-your-promises-9e1483662dfa">阅读我的另一篇关于钩子的文章</a>)。我们可以根据需要添加任意数量的中间件，它们都将按照<em class="jp">序列</em>执行。在我们当前的用例中，每次调用一个<code class="du jq jr js jt b">blogPost.save()</code>方法。在<code class="du jq jr js jt b">gstore-node</code>中，使用<code class="du jq jr js jt b">pre()</code>和<code class="du jq jr js jt b">post()</code>方法在模式上声明了<strong class="is hj">钩子。</strong></em></p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="8fda" class="kc kd hi jt b fi ke kf l kg kh">// Middleware example</span><span id="7790" class="kc kd hi jt b fi ki kf l kg kh">function doSomething() {<br/>  ... logic that returns a Promise<br/>}</span><span id="e093" class="kc kd hi jt b fi ki kf l kg kh">function doSomethingElse() {<br/>  ... logic that returns a Promise<br/>}</span><span id="0242" class="kc kd hi jt b fi ki kf l kg kh">/*<br/> * We add the 2 middleware to our schema.<br/> * They will be executed before the entity is saved in the<br/> * Datastore. If they throw an error, the entity won't be saved.<br/> */<br/>myGstoreSchema.pre('save', [doSomething, doSomethingElse]);</span></pre><p id="9a25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建第一个中间件<strong class="is hj">来提取我们添加的两个<em class="jp">文件</em>属性</strong>，并将它们放在将保存在数据存储中的实体数据上。</p><p id="ab0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="jp"> blog-post </em>模块文件夹中创建一个文件“<em class="jp"> blog-post.db.hooks.ts </em>”，并添加以下内容:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="ea3b" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/blog-post.db.hooks.ts</span><span id="a32d" class="kc kd hi jt b fi ki kf l kg kh">import { Context, Modules } from "../models";</span><span id="3a6c" class="kc kd hi jt b fi ki kf l kg kh">export default (<br/>  { gstore }: Context,<br/>  { images, utils }: Modules<br/>) =&gt; {<br/>  /**<br/>   * Middleware to initialize the entityData<br/>   * before saving it in the Datastore<br/>   */<br/>  function initEntityData(): Promise&lt;any&gt; {<br/>    this.entityData = addCloudStorageData(this.entityData);</span><span id="e1f3" class="kc kd hi jt b fi ki kf l kg kh">    // A gstore middleware must always return a Promise<br/>    return Promise.resolve();<br/>  }</span><span id="588b" class="kc kd hi jt b fi ki kf l kg kh">  /**<br/>   * If the entity has a "file" property attached to it<br/>   * we retrieve its publicUrl and cloudStorageObject<br/>   */<br/>  function addCloudStorageData(entityData: any) {<br/>    if (entityData.file) {<br/>      return {<br/>        ...entityData,<br/>        posterUri: entityData.file.cloudStoragePublicUrl || null,<br/>        cloudStorageObject:<br/>          entityData.file.cloudStorageObject || null<br/>      };<br/>    } else if (entityData.posterUri === null) {<br/>      /**<br/>       * Make sure that if the posterUri is null<br/>       * the cloud storage object is also null<br/>       */<br/>      return { ...entityData, cloudStorageObject: null };<br/>    }<br/>    return entityData;<br/>  }</span><span id="921b" class="kc kd hi jt b fi ki kf l kg kh">  return {<br/>    initEntityData<br/>  };<br/>};</span></pre><p id="21e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们看到的第一件事是，我们的数据库钩子层需要提供<em class="jp">上下文</em>和<em class="jp">模块</em>。然后我们有一个<code class="du jq jr js jt b">initEntityData()</code>函数，它将成为<strong class="is hj">中间件，在一个BlogPost实体被保存到数据存储</strong>之前执行<em class="jp">。<code class="du jq jr js jt b">gstore-node</code>在被保存的实体上设置中间件作用域(<code class="du jq jr js jt b">this</code>)。然后我们调用<code class="du jq jr js jt b">addCloudStorageData()</code>方法从实体中添加</em>或<em class="jp">移除</em>属性“posterUri”和“cloudStorageObject”。</p><p id="20e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们将这个中间件附加到<em class="jp"> BlogPost </em>模式。我们可以打开我们的"<em class="jp"> blog-post.db.ts </em>"文件，并将其添加到那里，但是如果我们这样做，我们会将业务(<em class="jp">域</em>)逻辑添加到我们的数据库层。相反，我们将使用我们的<em class="jp"> Utils </em>模块中的一些助手。<br/>打开“<em class="jp"> blog-post.db.ts </em>”文件，添加以下内容:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="85d4" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/blog-post.db.ts</span><span id="79a2" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="b747" class="kc kd hi jt b fi ki kf l kg kh">type FunctionReturnPromise = (...args: any[]) =&gt; Promise&lt;any&gt;;</span><span id="e62e" class="kc kd hi jt b fi ki kf l kg kh">export interface BlogPostDB {<br/>  ...<br/>  deletePost(id: number): Promise&lt;DeleteResult&gt;;<br/>  addPreSaveHook(<br/>    handler: FunctionReturnPromise | FunctionReturnPromise[]<br/>  ): void;<br/>  addPreDeleteHook(<br/>    handler: FunctionReturnPromise | FunctionReturnPromise[]<br/>  ): void;<br/>  addPostDeleteHook(<br/>    handler: FunctionReturnPromise | FunctionReturnPromise[]<br/>  ): void;<br/>}</span><span id="1425" class="kc kd hi jt b fi ki kf l kg kh">export default (context: Context, modules: Modules): BlogPostDB =&gt; {<br/>  ...</span><span id="0995" class="kc kd hi jt b fi ki kf l kg kh">  const ancestor = ["Blog", "default"];</span><span id="4ba3" class="kc kd hi jt b fi ki kf l kg kh">  const {<br/>    addPreSaveHook,<br/>    addPreDeleteHook,<br/>    addPostDeleteHook<br/>  } = utils.gstore.initDynamicHooks(schema, context.logger);</span><span id="9fba" class="kc kd hi jt b fi ki kf l kg kh">  ...</span><span id="28a6" class="kc kd hi jt b fi ki kf l kg kh">  /**<br/>   * DB API<br/>   */<br/>  return {<br/>    ...</span><span id="c8e9" class="kc kd hi jt b fi ki kf l kg kh">    deletePost(id) {<br/>      return BlogPost.delete(id, ancestor);<br/>    },<br/>    addPreSaveHook, // Add this line<br/>    addPreDeleteHook, // Add this line<br/>    addPostDeleteHook // Add this line<br/>  };<br/>};</span></pre><p id="eaa4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了，我们现在有3种方法将中间件附加到我们的gstore模式，数据库层<strong class="is hj">不需要知道它们</strong>。现在打开"<em class="jp"> blog-post.domain.ts </em>"文件，进行如下修改，将<code class="du jq jr js jt b">initEntityData</code>中间件添加到我们的模式中:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="779b" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/blog-post.domain.ts</span><span id="6858" class="kc kd hi jt b fi ki kf l kg kh">import marked from 'marked';<br/>import Boom from 'boom';<br/>import initDBhooks from './blog-post.db.hooks'; // Add this line<br/>...</span><span id="1afe" class="kc kd hi jt b fi ki kf l kg kh">export default (<br/>  context: Context,<br/>  { blogPostDB, images, utils }: Modules<br/>): BlogPostDomain =&gt; {<br/>  /**<br/>   * Add "pre" and "post" hooks to our Schema<br/>   */<br/>  const { initEntityData } = initDBhooks(context, {<br/>    images,<br/>    utils<br/>  });<br/>  blogPostDB.addPreSaveHook([initEntityData]);</span><span id="0625" class="kc kd hi jt b fi ki kf l kg kh">  ...<br/>};</span></pre><p id="d303" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们快到了！当我们初始化我们的<em class="jp"> BlogPost </em>模块时，我们没有提供所需的<em class="jp">模块</em>依赖。让我们纠正一下:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="2995" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/index.ts</span><span id="8488" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="ee22" class="kc kd hi jt b fi ki kf l kg kh">const blogPost = initBlogPost(context, modules); // Edit this line</span></pre><p id="5a08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们将依赖关系转发到我们的<code class="du jq jr js jt b">blogPostDomain</code>初始化:</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="a220" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/index.ts</span><span id="67b5" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="bc6e" class="kc kd hi jt b fi ki kf l kg kh">const blogPostDomain = initDomain(context, {<br/>  blogPostDB,<br/>  ...modules<br/>});</span></pre><p id="8c28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！现在，您应该能够<strong class="is hj">创建帖子并上传特色图片</strong>。如果您导航到您的<a class="ae jo" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Cloud控制台</a>，打开存储&gt;浏览器，进入您为此项目定义的存储桶，您应该会看到上传到那里的图像。</p><p id="1442" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">厉害！但是，如果你现在编辑帖子并上传一张新图片，会发生什么呢？试试看。你现在应该在谷歌存储桶中有2张图片。旧的和新的。这显然不是我们想要的。<br/>为了解决这个问题，我们需要:</p><ul class=""><li id="f7cd" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">一种从谷歌存储器中删除文件的方法。</li><li id="0f46" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated"><strong class="is hj">一个中间件，它将调用这个方法</strong>来删除与一篇博文相关的任何特色图片。</li></ul><p id="2d54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先在我们的<em class="jp"> GoogleCloudStorage </em>接口中创建一个<code class="du jq jr js jt b">deleteFile()</code>方法。</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="13e2" class="kc kd hi jt b fi ke kf l kg kh">// modules/images/google-cloud-storage.ts</span><span id="cbdd" class="kc kd hi jt b fi ki kf l kg kh">import async from "async"; // Add this line<br/>import arrify from "arrify"; // Add this line<br/>import { Context } from "./models";</span><span id="5443" class="kc kd hi jt b fi ki kf l kg kh">export interface GoogleCloudStorage {<br/>  uploadFile(<br/>    fileName: string,<br/>    mimetype: string,<br/>    buffer: Buffer<br/>  ): Promise&lt;any&gt;;<br/>  deleteFile(objects: string | Array&lt;string&gt;): Promise&lt;any&gt;; // Add<br/>}</span><span id="225c" class="kc kd hi jt b fi ki kf l kg kh">export default ({<br/>  config,<br/>  logger,<br/>  storage<br/>}: Context): GoogleCloudStorage =&gt; {<br/>  <br/>  ...</span><span id="0f33" class="kc kd hi jt b fi ki kf l kg kh">  const uploadFile = () =&gt; { ... };</span><span id="13fb" class="kc kd hi jt b fi ki kf l kg kh">  /**<br/>   * Delete one or many objects from the Google Storage Bucket<br/>   * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string | array} objects -- Storage objects to delete<br/>   */<br/>  const deleteFile = (objects: string | Array&lt;string&gt;) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      const storageObjects = arrify(objects);<br/>      const fns = storageObjects.map(o =&gt; processDelete(o));</span><span id="e4e6" class="kc kd hi jt b fi ki kf l kg kh">      async.parallel(fns, err =&gt; {<br/>        if (err) {<br/>          return reject(err);<br/>        }</span><span id="9cb6" class="kc kd hi jt b fi ki kf l kg kh">        logger.info(<br/>          "All object deleted successfully from Google Storage"<br/>        );</span><span id="5670" class="kc kd hi jt b fi ki kf l kg kh">        return resolve();<br/>      });<br/>    });</span><span id="55a2" class="kc kd hi jt b fi ki kf l kg kh">    // ----------</span><span id="1ab0" class="kc kd hi jt b fi ki kf l kg kh">    function processDelete(fileName: string) {<br/>      return (cb: async.AsyncFunction&lt;null, Error&gt;) =&gt; {<br/>        logger.info(`Deleting GCS file ${fileName}`);</span><span id="09ff" class="kc kd hi jt b fi ki kf l kg kh">        const file = bucket.file(fileName);<br/>        file.delete().then(<br/>          () =&gt; cb(null),<br/>          err =&gt; {<br/>            if (err &amp;&amp; err.code !== 404) {<br/>              return cb(err);<br/>            }<br/>            cb(null);<br/>          }<br/>        );<br/>      };<br/>    }<br/>  };</span><span id="46f6" class="kc kd hi jt b fi ki kf l kg kh">  return {<br/>    uploadFile,<br/>    deleteFile // Add this line<br/>  };<br/>};</span></pre><p id="c9b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完美。我们现在需要<strong class="is hj">创建一个中间件</strong>，它将调用<code class="du jq jr js jt b">deleteFile()</code>方法，并确保在一个新的图像被保存到Google存储之前<strong class="is hj">任何之前保存的图像都被删除<em class="jp">。<br/>打开"<em class="jp"> blog-post.db.hooks.ts </em>"文件，添加以下内容:</em></strong></p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="21f9" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/blog-post.db.hooks.ts</span><span id="374a" class="kc kd hi jt b fi ki kf l kg kh">import { Entity } from 'gstore-node'; // Add this line<br/>import { Context, Modules } from '../models';<br/>import { BlogPostType } from './models'; // Add this line</span><span id="9de2" class="kc kd hi jt b fi ki kf l kg kh">export default (<br/>  { gstore }: Context,<br/>  { images, utils }: Modules<br/>) =&gt; {<br/>  /**<br/>   * If the entity exists (it has an id) and we pass "null" as <br/>   * posterUri or the entityData contains a "file", we fetch the <br/>   * entity to check if it already has an feature image.<br/>   * We use the Dataloader instance to fetch the entity.<br/>   */<br/>  function deletePreviousImage(): Promise&lt;any&gt; {<br/>    if (!this.entityKey.id) {<br/>      return Promise.resolve();<br/>    }</span><span id="596f" class="kc kd hi jt b fi ki kf l kg kh">    if (<br/>      this.posterUri === null ||<br/>      typeof this.entityData.file !== "undefined"<br/>    ) {<br/>      const dataloader = this.dataloader<br/>        ? this.dataloader<br/>        : this.context &amp;&amp; this.context.dataloader;</span><span id="535a" class="kc kd hi jt b fi ki kf l kg kh">      return dataloader<br/>        .load(this.entityKey)<br/>        .then((entity: Entity&lt;BlogPostType&gt;) =&gt; {<br/>          /**<br/>           * If there is no entity or cloudStorageObject<br/>           * there is nothing to do here...<br/>           */<br/>          if (!entity || !entity.cloudStorageObject) {<br/>            return;<br/>          }</span><span id="c6c4" class="kc kd hi jt b fi ki kf l kg kh">          /**<br/>           * Delete the object from Google Storage<br/>           */<br/>          return images.GCS.deleteFile(entity.cloudStorageObject);<br/>        });<br/>    }</span><span id="804b" class="kc kd hi jt b fi ki kf l kg kh">    return Promise.resolve();<br/>  }</span><span id="1f8e" class="kc kd hi jt b fi ki kf l kg kh">  ...</span><span id="d512" class="kc kd hi jt b fi ki kf l kg kh">  return {<br/>    initEntityData,<br/>    deletePreviousImage,<br/>  };<br/>};</span></pre><p id="9cd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们将这个中间件附加到我们的BlogPost模式中。</p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="ed49" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/blog-post.domain.ts</span><span id="1ea6" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="1454" class="kc kd hi jt b fi ki kf l kg kh">export default (<br/>  context: Context,<br/>  { blogPostDB, images, utils }: Modules<br/>): BlogPostDomain =&gt; {<br/>  /**<br/>   * Add "pre" and "post" hooks to our Schema<br/>   */<br/>  const { initEntityData, deletePreviousImage } = initDBhooks(<br/>    context,<br/>    { images, utils }<br/>  );<br/>  blogPostDB.addPreSaveHook([deletePreviousImage, initEntityData]);</span><span id="e258" class="kc kd hi jt b fi ki kf l kg kh">  ...</span><span id="53e0" class="kc kd hi jt b fi ki kf l kg kh">};</span></pre><p id="94f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太棒了。您现在可以编辑帖子，更新特色图片，旧图片(如果有)将在更新实体时从谷歌存储中删除。<br/>当<strong class="is hj">删除帖子</strong>时，我们需要做一些非常类似的事情。为此，我们将<strong class="is hj">添加另一个中间件，它将在删除一个BlogPost实体</strong>之前正确执行<em class="jp">。<br/>打开“<em class="jp"> blog-post.db.hook.ts </em>”文件，添加以下内容:</em></p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="5b86" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/blog-post.db.hooks.ts</span><span id="da27" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="690e" class="kc kd hi jt b fi ki kf l kg kh">export default (<br/>  { gstore }: Context,<br/>  { images, utils }: Modules<br/>) =&gt; {<br/>  ...</span><span id="0862" class="kc kd hi jt b fi ki kf l kg kh">  /**<br/>   * Delete image from GCS before deleting a BlogPost<br/>   */<br/>  function deleteFeatureImage() {<br/>    // We fetch the entityData to see if there is a<br/>    // cloud storageobject<br/>    return this.datastoreEntity().then(<br/>      (entity: Entity&lt;BlogPostType&gt;) =&gt; {<br/>        if (!entity || !entity.cloudStorageObject) {<br/>          return;<br/>        }<br/>        return images.GCS.deleteFile(entity.cloudStorageObject);<br/>      }<br/>    );<br/>  }</span><span id="5f6c" class="kc kd hi jt b fi ki kf l kg kh">  return {<br/>    initEntityData,<br/>    deletePreviousImage,<br/>    deleteFeatureImage<br/>  };<br/>};</span></pre><p id="49d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经使用了<code class="du jq jr js jt b">gstore-node</code>助手函数<code class="du jq jr js jt b">datastoreEntity()</code>，它将为我们从数据存储中获取实体数据(记住在被删除的实体上设置<em class="jp">这个</em>的作用域<strong class="is hj">)。然后我们删除云存储对象(如果有的话)。现在让我们将这个中间件附加到我们的模式中:</strong></p><pre class="ju jv jw jx fd jy jt jz ka aw kb bi"><span id="e204" class="kc kd hi jt b fi ke kf l kg kh">// modules/blog/blog-post/blog-post.domain.ts</span><span id="ef34" class="kc kd hi jt b fi ki kf l kg kh">...</span><span id="9eab" class="kc kd hi jt b fi ki kf l kg kh">/**<br/> * Add "pre" and "post" hooks to our Schema<br/> */<br/>const {<br/>  initEntityData,<br/>  deletePreviousImage,<br/>  deleteFeatureImage // Add this<br/>} = initDBhooks(context, { images, utils });</span><span id="777d" class="kc kd hi jt b fi ki kf l kg kh">blogPostDB.addPreSaveHook([deletePreviousImage, initEntityData]);<br/>blogPostDB.addPreDeleteHook(deleteFeatureImage); // Add this</span><span id="ff1c" class="kc kd hi jt b fi ki kf l kg kh">...</span></pre><p id="e71f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！<strong class="is hj">你现在可以删除一篇文章，以及上传到谷歌存储器的任何特色图片</strong>。</p><p id="afac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一篇很长的文章，所以如果你在读这篇文章，这意味着我没有让你迷失方向:)</p><p id="d111" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像往常一样，如果您有任何问题或看到任何错误，请在评论中联系我们。</p><p id="5af0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了<em class="jp">图像</em>模块，我们的应用程序开始看起来非常非常好！博客缺少了一个重要的部分:<strong class="is hj">允许用户评论文章</strong>。</p><p id="4009" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们将在本教程的下一部分中看到的内容。让我们去吧！</p></div></div>    
</body>
</html>