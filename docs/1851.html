<html>
<head>
<title>Scaling up Spanner Change Watcher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩大扳手更换观察器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/scaling-up-spanner-change-watcher-82315fbc8962?source=collection_archive---------1-----------------------#2021-04-13">https://medium.com/google-cloud/scaling-up-spanner-change-watcher-82315fbc8962?source=collection_archive---------1-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud Spanner Change Watcher是Google Cloud Spanner的一个<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher" rel="noopener ugc nofollow" target="_blank">开源库</a>，用于查看和发布来自云Spanner数据库的更改。该库支持不同的标准实现来观察表的变化。本文中的示例需要1.1.0或更高版本的扳手变化观察器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/5ea3e6661905a239ecd25ee94bea5a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*iNlSTFEy1xpftvwji_PIXA.png"/></div></figure><p id="61e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Spanner Change Watcher时，最重要的一个方面是如何使监视表变化的查询尽可能高效。为提交时间戳列添加辅助索引是最常用的选项之一。这带来的缺点是，由于索引值将单调增加，它可能<a class="ae jd" href="https://cloud.google.com/spanner/docs/schema-design#primary-key-prevent-hotspots" rel="noopener ugc nofollow" target="_blank">成为写入热点</a>。向二级索引添加一个<a class="ae jd" href="https://cloud.google.com/spanner/docs/schema-design#fix_hash_the_key" rel="noopener ugc nofollow" target="_blank">分片列是减轻这一缺点的常用策略。</a></p><p id="6be7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，将shard列添加到已经被一个或多个应用程序使用的现有数据库可能是一个挑战，因为它可能还需要修改现有的应用程序。本文将向您展示如何:</p><ol class=""><li id="c3d4" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">无需修改任何现有应用程序，即可向现有数据库添加分段列。</li><li id="3e75" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">添加一个辅助索引，并使用它来有效地查询表中的数据修改。</li><li id="533d" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">添加一个可选的Processed (boolean)列，指示行是否已被处理，并在处理完行后使用该列从辅助索引中删除行。</li></ol><h1 id="6768" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">添加计算碎片列</h1><p id="431a" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">此示例假设您的数据库尚未包含逻辑碎片列。如果是这样，您也可以使用该列，而不是添加一个计算碎片列。</p><p id="4f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个好的shard列应该包含一个值，确保写操作在多个Cloud Spanner服务器上平均分布。shard列中不同值的数量应该至少与您的Cloud Spanner实例中的<a class="ae jd" href="https://cloud.google.com/spanner/docs/instances#node_count" rel="noopener ugc nofollow" target="_blank">服务器一样多。<strong class="ih hj">碎片列中有太多</strong>不同的值<strong class="ih hj">不推荐</strong>，因为轮询更改的最有效方式是在轮询查询中包含所有可能的碎片值，或者为每个碎片设置一个单独的监视器。</a></p><p id="39c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，哈希值的模对于shard列来说是一个很好的值。云扳手支持<a class="ae jd" href="https://cloud.google.com/spanner/docs/hash_functions" rel="noopener ugc nofollow" target="_blank">多种哈希函数</a>。这个例子使用了<a class="ae jd" href="https://cloud.google.com/spanner/docs/hash_functions#farm_fingerprint" rel="noopener ugc nofollow" target="_blank"> FARM_FINGERPRINT </a>函数，但是任何可用的散列函数都可以。然后，通过取散列的模19，不同值的数量减少到37(因此碎片值的范围是[-18，18])。</p><p id="aaab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们的数据库已经包含下表:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">基础歌手表</figcaption></figure><p id="a3af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下计算碎片列可以添加到表定义中，而无需更改任何现有的应用程序:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">基于全名添加计算的ShardId列</figcaption></figure><p id="66ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cloud Spanner将为表中的每一行自动填充这个shard列，而无需更改任何现有的突变或现有应用程序生成的DML语句。这个示例通过散列两个数据列来计算碎片，但是您可以使用任何列组合来计算碎片，只要输入对于大多数行来说足够不同以生成随机散列值。</p><h1 id="40bc" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">添加(空筛选的)二级索引</h1><p id="8004" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们现在可以为shard和commit时间戳列添加一个辅助索引，而不必担心创建一个<a class="ae jd" href="https://cloud.google.com/spanner/docs/schema-design#primary-key-prevent-hotspots" rel="noopener ugc nofollow" target="_blank">热点</a>。我们将创建二级索引作为一个经过空值过滤的索引。这将使我们能够自动从二级索引中删除不再需要的行，这可以为只接收或主要接收插入而不接收或很少接收更新的表保持较小的二级索引。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">为分片和提交时间戳创建空过滤索引</figcaption></figure><p id="74dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果给定行的<code class="du lj lk ll lm b">ShardId</code>或<code class="du lj lk ll lm b">LastModified</code>为空，则该行不会包含在二级索引中。在这个例子中，<code class="du lj lk ll lm b">ShardId</code>将总是非空的，因为它是歌手全名的计算哈希值。然而，我们可以选择让一个后台任务或<a class="ae jd" href="https://cloud.google.com/spanner/docs/use-cloud-functions" rel="noopener ugc nofollow" target="_blank">云函数</a>将最近没有更新的行的<code class="du lj lk ll lm b">LastModified</code>设置为null。这将自动从辅助索引中删除这些行，并保持索引较小。</p><p id="73ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这对于大多数突变都是插入的表尤其有效。数据表将继续增长，而索引可以保持较小，方法是删除超过X时间前插入的条目，而无需删除实际数据。</p><h1 id="5210" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用扳手更换观察器中的索引</h1><p id="83f6" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">我们的歌手表和索引的定义如下所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">完整的表和索引定义</figcaption></figure><p id="85c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将在<a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher" rel="noopener ugc nofollow" target="_blank"> Spanner Change Watcher </a>中设置一个表观察器，它将监视这个表的变化，并强制观察器使用我们已经创建的二级索引。这是通过在观察器上设置两个值来实现的:</p><ol class=""><li id="a33b" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">设置一个<code class="du lj lk ll lm b">ShardProvider</code>:shard provider可以用来只观察表的特定部分(shard)。在这种情况下，我们将使用<code class="du lj lk ll lm b"><a class="ae jd" href="https://github.com/cloudspannerecosystem/spanner-change-watcher/blob/master/google-cloud-spanner-change-watcher/src/main/java/com/google/cloud/spanner/watcher/NotNullShardProvider.java" rel="noopener ugc nofollow" target="_blank">F</a>ixedShardProvider</code>,它将向每个投票查询添加一个<code class="du lj lk ll lm b">WHERE ShardId IS NOT NULL AND ShardId IN (...)</code>子句。在这个例子中，我们将设置分片提供者来监视所有可能的分片值，因此值列表将等于-18和18之间的所有整数。创建一个包含所有可能的shard值的ShardProvider似乎很奇怪，但这实际上有助于为Cloud Spanner生成一个性能良好的轮询查询。</li><li id="0845" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">设置表提示:表提示可用于强制Cloud Spanner使用特定的二级索引进行查询。</li></ol><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">扳手更换观察器的示例设置</figcaption></figure><p id="b1a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的表监视器将使用<code class="du lj lk ll lm b">ShardId</code>和<code class="du lj lk ll lm b">LastModified</code>上的二级索引来轮询<code class="du lj lk ll lm b">Singers</code>表的变化。轮询查询将包括以下WHERE子句:</p><p id="79ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b">WHERE ShardId IS NOT NULL AND ShardId IN (-18, -17, ..., 17, 18) AND LastModified &gt; @lastCommitTimestamp</code>。</p><p id="7be9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<code class="du lj lk ll lm b">WHERE</code>子句意味着<code class="du lj lk ll lm b">ShardId</code>和<code class="du lj lk ll lm b">LastModified</code>都不能为空，这就是为什么我们也知道可以使用我们的空过滤索引。</p><h1 id="53cc" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">从二级索引中删除条目</h1><p id="4c81" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">通过定期从索引中删除不再需要的条目，我们可以保持表监视器使用的辅助索引较小。这是通过将超过一定时间没有更新的行的值<code class="du lj lk ll lm b">LastModified</code>设置为null来实现的。重要的是，我们只有在知道这些行不会被其他进程同时更新时才这样做，因为这可能导致这些行的事务性更新不会被更改监视器拾取。</p><p id="129f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的示例脚本将把过去24小时内没有更新的所有行的<code class="du lj lk ll lm b">LastModified</code>设置为null。这个脚本应该作为<a class="ae jd" href="https://cloud.google.com/spanner/docs/dml-partitioned" rel="noopener ugc nofollow" target="_blank">分区DML </a>执行，以确保它不会超出Cloud Spanner的事务限制。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div></figure><h1 id="4250" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用经过处理的列</h1><p id="0889" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">上面的例子假设对于一段时间没有更新的行，可以将<code class="du lj lk ll lm b">LastModified</code>设置为null。如果希望保留旧行的<code class="du lj lk ll lm b">LastModified</code>值，可以引入一个额外的<code class="du lj lk ll lm b">Processed</code>列来指示更新是否已经被处理并且不再需要被表观察器考虑。该<code class="du lj lk ll lm b">Processed</code>列可用于在行被处理后自动将<code class="du lj lk ll lm b">ShardId</code>列设置为空。由于空过滤索引将只包含所有包含的列都不为空的条目，所以我们将列设置为空并不重要。这两种情况都将导致从辅助索引中删除该行。</p><p id="bcf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的表和索引定义将创建一个表，该表为尚未标记为已处理的行自动计算一个<code class="du lj lk ll lm b">ShardId</code>。因此，索引将只包含未标记为已处理的行。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">具有已处理列的表定义</figcaption></figure><p id="16dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述表格和索引定义可与<code class="du lj lk ll lm b">FixedShardProvider</code>结合使用。然而，它确实需要修改现有的<strong class="ih hj">更新语句，以将</strong> <code class="du lj lk ll lm b"><strong class="ih hj">Processed</strong></code> <strong class="ih hj">列更新为假</strong>(或空)。不需要修改现有的insert语句，因为这些语句会将null插入到<code class="du lj lk ll lm b">Processed</code>列中。<code class="du lj lk ll lm b">CASE WHEN Processed</code>子句将null和false都视为FALSE值，并将<code class="du lj lk ll lm b">ShardId</code>设置为非null。</p><h2 id="821c" class="ln kb hi bd kc lo lp lq kg lr ls lt kk iq lu lv ko iu lw lx ks iy ly lz kw ma bi translated">设置变更观察者</h2><p id="8e19" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">该表的变更监视器的设置方式与不包含<code class="du lj lk ll lm b">Processed</code>列的版本完全相同。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="6ce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">表监视器不会考虑任何<code class="du lj lk ll lm b">ShardId</code>为空的行，这样做很有效，因为它可以使用只包含相关行的二级索引。</p><h2 id="2e1d" class="ln kb hi bd kc lo lp lq kg lr ls lt kk iq lu lv ko iu lw lx ks iy ly lz kw ma bi translated">从二级索引中删除条目</h2><p id="4594" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">从二级索引中删除不再需要的条目与前面的示例略有不同。现在通过将<code class="du lj lk ll lm b">Processed</code>列设置为真来删除条目。这将自动将<code class="du lj lk ll lm b">ShardId</code>列更新为空。<code class="du lj lk ll lm b">LastModified</code>列将保持不变。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ld le l"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">标记已处理行的查询</figcaption></figure><h1 id="4e4d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">基准应用程序</h1><p id="fdf0" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">Cloud Spanner Change Watcher示例目录还包括一个小型基准测试应用程序，可用于测试和基准测试不同的配置。基准应用程序的默认配置<strong class="ih hj">是为必须处理高写吞吐量的变更观察者推荐的基本配置</strong>，与本文中的示例相同。这种配置能够在单个节点云Spanner实例上每张表每秒处理大约3，000–5，000个突变。</p><p id="e155" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以更改基准测试应用程序的输入参数，在您自己的Cloud Spanner实例上尝试不同的配置。<a class="ae jd" rel="noopener" href="/@knutolavloite/benchmark-spanner-change-watcher-e5b6cc2ac618">关于基准应用程序的更多信息可以在本文</a>中找到。</p><h1 id="36a7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="5008" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">在接收大量写操作的表的提交时间戳列上创建二级索引，可以创建一个<a class="ae jd" href="https://cloud.google.com/spanner/docs/schema-design#primary-key-prevent-hotspots" rel="noopener ugc nofollow" target="_blank">热点</a>。添加一个shard列作为索引的第一列可以缓解这个问题。如果您的数据库不包含逻辑碎片列，您可以添加一个作为计算列，用于计算表中一个或多个数据列的哈希值。计算列将由Cloud Spanner自动填充，这意味着您不需要修改任何现有的应用程序来使用这样的列。</p><p id="79ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在shard和commit timestamp列上创建一个二级索引作为空过滤索引，还可以通过将索引中的一个值设置为null来删除二级索引中不再需要的旧条目。上述示例显示了如何通过将提交时间戳值设置为null来实现这一点。</p><p id="47d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果您希望保留旧条目的提交时间戳值，那么您也可以引入一个单独的<code class="du lj lk ll lm b">Processed</code>列来指示该行是否已被处理。该列可用于自动将计算碎片列设置为null，这也会自动从辅助索引中删除该行。</p></div></div>    
</body>
</html>