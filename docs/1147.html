<html>
<head>
<title>A Journey into BigQuery Fuzzy Matching — 3 of [1, ∞) — NYSIIS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery模糊匹配之旅——3/1，∞) — NYSIIS</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-journey-into-bigquery-fuzzy-matching-3-of-1-nysiis-d4d75c61af42?source=collection_archive---------0-----------------------#2019-09-13">https://medium.com/google-cloud/a-journey-into-bigquery-fuzzy-matching-3-of-1-nysiis-d4d75c61af42?source=collection_archive---------0-----------------------#2019-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ead9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个正在进行的系列的一部分，一定要检查其他文章！</p><ul class=""><li id="4fd6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">【BigQuery模糊匹配之旅—1/1，∞) — Soundex </li><li id="c691" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">【BigQuery模糊匹配之旅——2/1，∞) —更多Soundex和Levenshtein距离</li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="98c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前两篇文章中，我们讨论了Soundex和它撒下的大网，这导致了许多误报。这个问题已经存在了一段时间，正如Soundex所表明的那样，它伴随着妥协，工程师们一直在寻找调整算法的方法，以针对不同的用途进行编码。让我们看看如何实现其中的一个，<a class="ae jm" href="https://en.wikipedia.org/wiki/New_York_State_Identification_and_Intelligence_System" rel="noopener ugc nofollow" target="_blank"> NYSIIS </a>！</p><h1 id="275e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">纽约时报</h1><p id="e9eb" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">纽约州身份识别和情报系统开发于20世纪70年代，此后成为纽约州刑事司法服务部门的一部分(该算法通常仍被称为NYSIIS)。它扩展了欧洲和西班牙姓氏的语音编码，因此通常比标准的Soundex具有更高的匹配准确度。算法逻辑很好<a class="ae jm" href="https://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/language/Nysiis.html" rel="noopener ugc nofollow" target="_blank">在线文档</a>。</p><p id="965c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下供参考:</p><blockquote class="lc ld le"><p id="7f6e" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">1 —转码名称的第一个字符:</p><p id="1a6a" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">MAC<em class="hi">→</em>MCC<br/>KN<em class="hi">→</em>NN<br/>K<em class="hi">→</em>C<br/>PH<em class="hi">→</em>FF<br/>PF<em class="hi">→</em>FF<br/>SCH<em class="hi">→</em>SSS。</p><p id="cdc5" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">2 —对名称的最后几个字符进行代码转换:</p><p id="694c" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">EE，即<em class="hi"> → </em> Y <br/> DT，RT，RD，NT，ND <em class="hi"> → </em> D。</p><p id="1d96" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">3-密钥的第一个字符=名称的第一个字符。</p><p id="40c7" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">4-在以下规则中，对名称的字符执行扫描，从第二个字符开始，每次递增一个字符:</p><p id="7697" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">EV <em class="hi"> → </em> AF、else A、E、I、O、U<em class="hi">→</em>A<br/>Q<em class="hi">→</em>G<br/>Z<em class="hi">→</em>S<br/>M<em class="hi">→</em>N<br/>KN<em class="hi">→</em>N、else K<em class="hi">→</em>C<br/>SCH<em class="hi">→</em>SSS<br/>PH</p><p id="de91" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">5-如果最后一个字符是S，则删除它。</p><p id="7ad3" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">6-如果最后一个字符是AY，则替换为y。</p><p id="ca2e" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">7-如果最后一个字符是A，则删除它。</p><p id="9b03" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">8-折叠所有重复字符串</p><p id="5eeb" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">9-添加名称的原始第一个字符作为密钥的第一个字符</p></blockquote><p id="9790" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，这个比原来的Soundex多了几个步骤。为了简单一点，让我们把它分成不同的部分。</p><p id="cfdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第1步和第2步是最容易合并到SQL UDF中的。特定于NYSIIS的一系列辅助UDF函数我们将用<em class="lf"> dq_hf_nysiis_ </em>作为前缀，这样我们以后可以很容易地找到它们。一般的帮助函数将继续以<em class="lf"> dq_hf_gh_ </em>为前缀。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="a082" class="ls ka hi lo b fi lt lu l lv lw">CREATE OR REPLACE FUNCTION<br/>dq.dq_hf_nysiis_step1_transcodefirstlast (instring string) AS (<br/>/*<br/> * (Helper) Data Quality Function - NYSIIS<br/> * input: String to transcode.<br/> * returns: String with the first characters and last<br/> *   characters transcoded for the first step in NYSIIS.<br/> */<br/>CONCAT(<br/>  CASE<br/>    WHEN STARTS_WITH(instring, "MAC") <br/>      THEN CONCAT("MCC", SUBSTR(instring, 4, LENGTH(instring)-5))<br/>    WHEN STARTS_WITH(instring, "KN") <br/>      THEN CONCAT("NN", SUBSTR(instring, 3, LENGTH(instring) - 4))<br/>    WHEN STARTS_WITH(instring, "K") THEN <br/>      CONCAT("C", SUBSTR(instring, 2, LENGTH(instring) - 3))<br/>    WHEN STARTS_WITH(instring, "PH") <br/>      THEN CONCAT("FF", SUBSTR(instring, 3, LENGTH(instring) - 4))<br/>    WHEN STARTS_WITH(instring, "PF") <br/>      THEN CONCAT("FF", SUBSTR(instring,3, LENGTH(instring) - 4))<br/>    WHEN STARTS_WITH(instring, "SCH") <br/>      THEN CONCAT("SSS", SUBSTR(instring, 4, LENGTH(instring) - 5))<br/>  ELSE<br/>    SUBSTR(instring, 1, LENGTH(instring) - 2)<br/>  END<br/>  ,<br/>  CASE<br/>    WHEN (SUBSTR(instring, -2) = "EE") <br/>      OR (SUBSTR(instring, -2) = "IE" ) <br/>      THEN "Y"<br/>    WHEN (SUBSTR(instring, -2) = "DT") <br/>      OR (SUBSTR(instring, -2) = "RT")<br/>      OR (SUBSTR(instring, -2) = "RD") <br/>      OR (SUBSTR(instring, -2) = "NT")<br/>      OR (SUBSTR(instring, -2) = "ND") <br/>      THEN "D"<br/>  ELSE<br/>    SUBSTR(instring, -2)<br/>  END<br/>)<br/>);</span></pre><p id="c7bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这里开始，我们希望继续操作第二个字符，但是仍然希望保留键的第一个字符。因为我们还没有可以存储变量的过程化脚本语言，所以我们需要弄清楚如何通过表达式来维护它。让我们将它们分开，存储在一个数组中，并根据需要传递。下面是一个通用的帮助器函数，它将创建这样一个数组，并检查处理单个字符串的能力。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="5049" class="ls ka hi lo b fi lt lu l lv lw">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_gh_SplitFirstCharacter(instring STRING) AS(<br/>/*<br/> * (Helper) Data Quality Function<br/> * dq_hf_gh_SplitFirstCharacter<br/> * input: Any string to split.<br/> * returns: Array with the first character, followed by<br/> *   the remaining characters.<br/> */<br/>IF<br/>  (LENGTH(instring) &lt;= 1,<br/>    [instring, ''],<br/>    [SUBSTR(instring, 1, 1),<br/>      SUBSTR(instring, 2, LENGTH(instring))]) );</span></pre><p id="2351" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们进入第四步，这是最重要的一步。虽然出于性能原因，我希望在SQL UDF中实现这一点，但是有太多的条件逻辑使得这成为可能，所以就用JavaScript吧！让我们创建一个封装该逻辑的助手函数。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="25aa" class="ls ka hi lo b fi lt lu l lv lw">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_nysiis_step4_transcodemain (inarray ARRAY&lt;STRING&gt;)<br/>  RETURNS ARRAY&lt;STRING&gt;<br/>  LANGUAGE js AS """<br/>/*<br/> * (Helper) Data Quality Function - NYSIIS<br/> * dq_hf_nsiis_step4_transcodemain<br/> * input: ARRAY[0] is the first character of the string.<br/> *        ARRAY[1] is the rest of the string.<br/> * output: ARRAY[0] is the first character of the original string.<br/> * output: ARRAY[1] has the main transcoding of the string remainder.<br/> */<br/>instring = inarray[1];<br/>var i;<br/>var toReturn = "";<br/>for(i = 0; i &lt; instring.length; i++){<br/>  switch(instring.charAt(i)){<br/>    case 'E':<br/>      if(i + 1 &lt; instring.length &amp;&amp; instring.charAt(i + 1) == 'V'){<br/>        toReturn += 'AF';<br/>        i++;<br/>      }<br/>      else{<br/>        toReturn += 'A';<br/>      }<br/>      break;<br/>    case 'A':<br/>      toReturn += 'A';<br/>      break;<br/>    case 'I':<br/>      toReturn += 'A';<br/>      break;<br/>    case 'O':<br/>      toReturn += 'A';<br/>      break;<br/>    case 'U':<br/>      toReturn += 'A';<br/>      break;<br/>    case 'Q':<br/>      toReturn += 'G';<br/>      break;<br/>    case 'Z':<br/>      toReturn += 'S';<br/>      break;<br/>    case 'M':<br/>      toReturn += 'N';<br/>      break;<br/>    case 'K':<br/>      if (i + 1 &lt; instring.length &amp;&amp; instring.charAt(i + 1) == 'N'){<br/>        toReturn += 'N';<br/>        i++;<br/>      }<br/>      else{<br/>        toReturn += 'C';<br/>      }<br/>      break;<br/>    case 'S':<br/>      if(i + 2 &lt; instring.length &amp;&amp; instring.charAt(i + 1) == 'C' &amp;&amp;<br/>        instring.charAt(i + 2) == 'H'){<br/>          toReturn += 'SSS';<br/>          i++;<br/>          i++;<br/>      }<br/>      else{<br/>        toReturn += 'S';<br/>      }<br/>      break;<br/>    case 'P':<br/>      if(i + 1 &lt; instring.length &amp;&amp; instring.charAt(i + 1) == 'H'){<br/>        toReturn += 'FF';<br/>        i++;<br/>      }<br/>      else{<br/>        toReturn += 'P';<br/>      }<br/>      break;<br/>    case 'H':<br/>      if((i - 1 &gt; -1 &amp;&amp; ['a', 'e', 'i', 'o', 'u']<br/>        .indexOf(instring.charAt(i - 1).toLowerCase()) == -1) ||<br/>        (i + 1 &lt; instring.length &amp;&amp; ['a', 'e', 'i', 'o', 'u']<br/>        .indexOf(instring.charAt(i + 1).toLowerCase()) == -1)){<br/>          toReturn += toReturn.charAt(toReturn.length - 1);<br/>      }<br/>      else{<br/>        toReturn += 'H';<br/>      }<br/>      break;<br/>    case 'W':<br/>      if(i - 1 &gt; -1 &amp;&amp; ['a', 'e', 'i', 'o', 'u'].<br/>        indexOf(instring.charAt(i - 1).toLowerCase()) !== -1){<br/>          toReturn += toReturn.charAt(toReturn.length - 1);<br/>      }<br/>      else{<br/>        toReturn += 'W';<br/>      }<br/>      break;<br/>    default:<br/>      toReturn += instring.charAt(i);<br/>      break;<br/>  }<br/>}<br/>outArray = [inarray[0], toReturn];<br/>return outArray;<br/>"""</span></pre><p id="13e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在处于最后冲刺阶段。让我们删除同时重复的字符(借用之前实现Soundex的helper函数)，并将数组重构为一个字符串。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e6f4" class="ls ka hi lo b fi lt lu l lv lw">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_nysiis_DedupCombine (inarray ARRAY&lt;STRING&gt;) AS(<br/>/*<br/> * (Helper) Data Quality Function<br/> * dq_hf_nysiis_DedupCombine<br/> * input: Array with starting character, and converted string.<br/> * returns: String with the first character combined with<br/>            the string removed of repeating characters.<br/> */<br/>CONCAT(<br/>  inarray[OFFSET(0)],<br/>  dq.dq_hf_gh_RemoveDuplicateChars(<br/>    inarray[OFFSET(1)]))<br/>)</span></pre><p id="4023" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤5、6和7是我们需要做的最后几个代码转换，所以让我们将其封装在自己的UDF中。要做到这一点，我们首先要创建一个通用的助手函数，它将在字符串末尾寻找一个字符模式，并用另一个字符模式替换它。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2ff2" class="ls ka hi lo b fi lt lu l lv lw">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_gh_ReplaceEndWith(<br/>    instring STRING,<br/>    tofind STRING,<br/>    toreplace STRING) AS(<br/>/*<br/> * (Helper) Data Quality Function<br/> * dq_hf_gh_ReplaceEndWith<br/> * input: Any string to clean up.<br/>          Any string to look for.<br/>          Any string to replace at the end.<br/> * returns: Looks for the tofind string at the end and<br/>     then replaces it with the toreplace string.<br/> */<br/>IF<br/>  (ENDS_WITH(instring, tofind),<br/>    CONCAT(SUBSTR(instring, 1, LENGTH(instring) - LENGTH(tofind)), toreplace),<br/>    instring) );</span></pre><p id="8616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一位将利用新函数根据步骤5、6和7替换字符。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="213f" class="ls ka hi lo b fi lt lu l lv lw">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_nysiis_step8_clean_up_ends(instring STRING) AS(<br/>/*<br/> * (Helper) Data Quality Function<br/> * dq_hf_nysiis_step8_clean_up_ends<br/> * input: String to check the ends of.<br/> * returns: String after removing the S at the end,<br/> *   replacing AY with Y,<br/> *   and removing A.<br/> */<br/>dq.dq_hf_gh_ReplaceEndWith(<br/>  dq.dq_hf_gh_ReplaceEndWith(<br/>    dq.dq_hf_gh_ReplaceEndWith(instring,'S',''),<br/>  'AY','Y'),<br/>'A','')<br/>);</span></pre><p id="1cd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把这些按顺序包装起来，创建我们闪亮的新的NYSIIS函数。我们在逻辑中增加的一个额外的例子是长度为1的字符串。在这些情况下，唯一完成的代码转换是步骤1中的<em class="lf"> K → C </em>，如果不是，就返回原始字母。放在这里是有意义的，这样就把整个流程短路了，不浪费处理时间。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="893a" class="ls ka hi lo b fi lt lu l lv lw">CREATE OR REPLACE FUNCTION<br/>  dq.dq_fm_NYSIIS(instring STRING) AS (<br/>/*<br/> * Data Quality Function - Fuzzy Matching<br/> * dq_fm_NYSIIS<br/> * input: String to encode.<br/> * returns: NYSIIS code of the string.<br/> */<br/>IF (LENGTH(instring) = 1,<br/>  IF (instring = "K", "C", instring), (<br/>    dq.dq_hf_nysiis_step8_clean_up_ends(<br/>      dq.dq_hf_nysiis_DedupCombine(<br/>        dq.dq_hf_nysiis_step4_transcodemain(<br/>          dq.dq_hf_gh_SplitFirstCharacter(<br/>            dq.dq_hf_nysiis_step1_transcodefirstlast(<br/>              UPPER(instring)) <br/>          )<br/>        )<br/>      )<br/>    )<br/>  )<br/>)<br/>);</span></pre><p id="fec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这应该会导致一个绿色的勾号，也应该会引发喜悦！</p><p id="a59c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们试一试。首先，让我们测试一下算法是否有效。我取了一系列的名字，通过web上的NYSIIS的一个<a class="ae jm" href="http://www.dropby.com/NYSIIS.html" rel="noopener ugc nofollow" target="_blank">实现手动运行它们来得到结果。我对它们进行了比较，看看我们的BigQuery实现是否与预期的NYSIIS代码匹配。我试图建立一系列的名字来测试尽可能多的代码转换步骤。</a></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="13f4" class="ls ka hi lo b fi lt lu l lv lw">WITH<br/>  input_data AS (<br/>  SELECT<br/>    ["MACKENZIE,MCANSY","MCKENZIE,MCANSY",<br/>    "MORRISON,MARASA[N]","KNOLL,NNAL",<br/>    "KNIGHT,NNAGT","KIERNAN,CARNAN",<br/>    "SCHMIDT,SSNAD","SCOTT,SCAT",<br/>    "PFEIFFER,FFAFAR","PHAN,FFAN",<br/>    "PROCTER,PRACTA[R]","SVEE,SVY",<br/>    "LAMBERT,LANBAD","MINARD,MANAD",<br/>    "BRYANT,BRYAD","LUND,LAD",<br/>    "EVANS,EVAN","DEVOE,DAF",<br/>    "TOKAREV,TACARA[F]","SHUE,SH",<br/>    "MCKNIGHT,MCNAGT","GWYTHER,GWYTAR",<br/>    "BORENS,BARAN","LURAY,LARY",<br/>    "HUA,H","DOUGLAS,DAGL",<br/>    "LOUIS,L","BANANA,BANAN",<br/>    "CATHERINE,CATARA[N]","Katherine,CATARA[N]",<br/>    "Katarina,CATARA[N]","Jessica,JASAC",<br/>    "joshua,JAS","Wojszynski,WAJSYN[SC]"] AS names),<br/>  main_data AS (<br/>  SELECT<br/>    UPPER(SPLIT(names)[OFFSET(0)]) AS name,<br/>    SPLIT(names)[OFFSET(1)] AS expected_nysiis_code,<br/>    dq.dq_fm_NYSIIS(SPLIT(names)[OFFSET(0)])<br/>      AS output_nysiis_code<br/>  FROM<br/>    input_data,<br/>    UNNEST(names) AS names)<br/>SELECT<br/>  *,<br/>  REGEXP_REPLACE(expected_nysiis_code, r'[\[\]]', '') =<br/>    output_nysiis_code AS nysiis_code_match<br/>FROM<br/>  main_data</span></pre><p id="2645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到以下结果，并且它们是匹配的！</p><figure class="lj lk ll lm fd ly er es paragraph-image"><div class="er es lx"><img src="../Images/a8345ba1de17199cbd1e882995ab11ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*soWXptkBlWn6Pc7Lx_2VZA.png"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">再次取得巨大成功！</figcaption></figure><p id="56ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以总的来说，实现看起来是有效的。如果您想知道<code class="du mf mg mh lo b">expected_nysiis_code</code>列上的括号是什么，那是因为最初的NYSIIS算法有6个字符的限制，这是现在大多数工具中的默认长度。但是，没有理由不使用全部内容，所以括号中的字母只是前六个字符后的附加字母。</p><p id="f172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个系列的第一部分的最后，当我们实现Soundex时，我们注意到有时它不会那么准确。例如，Wozniak、Wiggins、Wegonge和Weiscmowsky都有相同的Soundex代码W252。那么纽约时报给了我们什么呢？</p><figure class="lj lk ll lm fd ly er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mi"><img src="../Images/36aa108d89a965fdb7a7e6021ec41184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPmdHda2uR_RzoQRMCp4kQ.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">啊，这还差不多！</figcaption></figure><p id="0693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来我们得到了比Soundex返回的更精确的答案。这很好，因为这意味着我们的名字越来越精确，因此应该得到更好的分组。</p><p id="baca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，这个脚本比我希望的要长一些，也更复杂一些。总的来说，我尽可能多地使用SQL UDFs和标准SQL。它有助于更清晰的查询，允许更好的调试和自省，但它也运行在核心数据处理引擎中，而JavaScript UDF<a class="ae jm" href="https://developers.googleblog.com/2015/08/breaking-sql-barrier-google-bigquery.html" rel="noopener ugc nofollow" target="_blank">需要在Google V8 </a>上运行。虽然这些都是经过高度优化的引擎，但出于性能原因，我更愿意尽量减少外部流程。这里我们必须使用JavaScript，因为我们确实需要像变量和for循环这样的东西，而BigQuery还没有自己的过程化脚本逻辑。但是，如果有一天真的发生了，也许有必要重新审视这一切，看看我们能否重构和优化这一切。</p><p id="7bba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这里开始，我想为多标准匹配组添加其他属性，如邮政编码，敬请关注！</p></div></div>    
</body>
</html>