<html>
<head>
<title>Collecting browser console logs in Stackdriver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Stackdriver中收集浏览器控制台日志</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/collecting-browser-console-logs-in-stackdriver-fa388a90d32b?source=collection_archive---------1-----------------------#2019-12-02">https://medium.com/google-cloud/collecting-browser-console-logs-in-stackdriver-fa388a90d32b?source=collection_archive---------1-----------------------#2019-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7a70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TL；DR:这篇文章解释了如何通过将浏览器控制台日志导出到Google Stackdriver Logging中的一个中心位置来提高浏览器JavaScript的可支持性，为什么要这样做，并讨论了实现选项。</p><p id="d3ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">背景</strong></p><p id="9682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着ES2015模块、Angular和TypeScript等更好的工具可用于开发大规模基于浏览器的应用程序，大型应用程序已经开发出来，为它们提供良好的支持变得越来越重要。不幸的是，如今在一个中心位置收集浏览器日志和错误并不是一种常见的做法。商业支持的web应用程序的典型支持经验是:最终用户遇到问题，提交错误报告，开发人员或支持工程师查看服务器日志，发现服务器上没有错误，然后工程师请求最终用户发送浏览器日志。最终用户可能有也可能没有支持合同，可能知道也可能不知道如何发送浏览器日志。更糟糕的是，console.log()消息可能会被编译工具剥离。最糟糕的是，最终用户可能甚至懒得报告问题，而只是转向竞争产品。这导致了令人沮丧的用户体验，并且开发者对于最终用户所遇到的问题一无所知。</p><p id="4c39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，浏览器控制台日志和未处理的错误可以相当容易和经济地收集在一个中心位置，例如谷歌云平台上的<a class="ae jd" href="https://cloud.google.com/logging/" rel="noopener ugc nofollow" target="_blank"> Stackdriver Logging </a>。没有在一个中心位置收集日志是一个错失的机会。本文将解释如何通过一个示例应用程序来实现这一点，该应用程序定义了新的log()和error()方法，将日志和错误发送到运行Node.js的后端服务器，然后在服务器上将它们记录下来。它还可以选择重新定义浏览器控制台日志和错误函数来调用这些实现。这是可选的，因为一些开发人员可能不希望将消息记录到控制台，因此主动从他们的代码库中删除对console.log()的调用。不依赖于Stackdriver专有的API，但是演示了使用Stackdriver的简易性。</p><p id="8581" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见<a class="ae jd" href="https://github.com/GoogleCloudPlatform/stackdriver-errors-js" rel="noopener ugc nofollow" target="_blank"> stackdriver-errors-js </a>获取从浏览器JavaScript到stackdriver错误报告API的错误报告代码。该项目的优点是它不需要后端服务器。但是，它不发送信息性日志消息，只发送错误。</p><p id="2cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了日志和错误，您可能还想将其他有趣的事件记录到服务器上。例如，浏览器历史。像Angular这样的现代JavaScript框架使得开发一大组视图成为可能，这些视图在用户看来就像单个页面应用程序中的多个页面。但是在web服务器请求日志中没有用户导航到不同视图的记录，这是理解应用程序使用模式的另一个新的空白。这篇文章没有涉及到这个问题，但是这里描述的相似的原则也适用。</p><p id="c928" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">接近</strong></p><p id="60b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的示意图显示了收集控制台日志和错误的方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/23d83e6bfcc88863d218811da581ba9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0Vj2jE6T5iaiNprYBNVdw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">浏览器日志传送到Stackdriver的示意图</figcaption></figure><p id="7b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图中，红色表示示例应用程序代码，蓝色表示Google云平台服务，绿色表示开源或web浏览器。</p><p id="ecec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将日志写入Stackdriver或另一个中央位置的可能方法，按从多到少的顺序排列如下</p><ol class=""><li id="7c96" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">创建一个新的API，比如说日志收集器，</li></ol><ul class=""><li id="bd77" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">将日志发送到我们的服务器并保存到Stackdriver中</li><li id="91e8" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">添加一些缓冲，以便不需要对每个日志消息进行远程调用</li><li id="8c27" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">为了方便和代码可维护性，使它可以作为ES6模块安装</li><li id="3bc3" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">监听<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror" rel="noopener ugc nofollow" target="_blank">global event handlers . on error</a>来收集未捕获的错误</li><li id="e82e" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">这种方法的缺点是我们无法捕捉通过console.log()记录的消息。</li></ul><p id="aa6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.重新定义控制台日志记录功能</p><ul class=""><li id="8b4e" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">这可以与上面的方法相结合。</li><li id="1d1e" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">JavaScript的灵活特性使得在对象上重新定义函数变得容易</li><li id="ca75" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">遵循与上面相同的关于缓冲和发送到我们的服务器的要点。</li><li id="cca5" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">这假设我们有自己的服务器，即它不是一个静态的网站。您可以在另一台服务器上运行收集器进程，并配置跨源资源共享(CORS)以允许从静态网站发送日志。</li></ul><p id="4509" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.使用Stackdriver APIs写入Stackdriver</p><ul class=""><li id="6274" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">您可以直接从浏览器使用stack driver API<a class="ae jd" href="https://cloud.google.com/logging/docs/reference/libraries" rel="noopener ugc nofollow" target="_blank">客户端日志库</a>，尽管它们主要用于Node.js。但是，您需要为此使用OAuth 2.0并代表用户执行API。如果您不能为您的应用程序的用户注册和提供对GCP的访问，这不是一个可行的方法。更多详情参见GCP <a class="ae jd" href="https://cloud.google.com/docs/authentication" rel="noopener ugc nofollow" target="_blank">认证概述</a>。</li></ul><p id="8249" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将结合第一种和第二种方法:定义新的log()和error()方法，重新定义控制台日志和错误函数，并将日志和错误发送到Node.js服务器，在那里记录它们。演示应用程序使用标准console.log()和console.error()函数将<a class="ae jd" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank">云运行</a>与日志记录结合使用，这些函数由云运行定向到Stackdriver。如果您不使用Cloud Run，那么您可以按照<a class="ae jd" href="https://cloud.google.com/logging/docs/setup/nodejs" rel="noopener ugc nofollow" target="_blank">为Node.js设置Stackdriver日志记录</a>中的步骤轻松设置Stackdriver日志记录。Stackdriver日志记录与Node.js Bunyan和Winston日志记录框架相集成，这也可以使您免受专有API的影响。类似的Stackdriver集成也适用于其他语言。</p><p id="24fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">样本App </strong></p><p id="a6fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例应用程序创建日志收集器，并驱动一个带有web表单的简单页面，允许用户在文本字段中输入自己的名字和喜欢的颜色。执行此操作的浏览器类型脚本如下所示(文件<a class="ae jd" href="https://gist.github.com/alexamies/037d7c11432ea2301de9995515c6deea" rel="noopener ugc nofollow" target="_blank"> public/app.ts </a>)。TypeScript编译器使用(文件public/app.js)生成非常相似的JavaScript。</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="8e19" class="ko kp hi kk b fi kq kr l ks kt">import { fromEvent } from "rxjs"; import { LogCollector, LogCollectorBuilder } from "./index.js";</span><span id="b3e9" class="ko kp hi kk b fi ku kr l ks kt">// Start the log collector<br/>const buildId = "v0.01";<br/>const builder = new LogCollectorBuilder().setBuildId(buildId).setReplaceConsole(true);<br/>const logCollector = builder.makeLogCollector();<br/>logCollector.start();</span><span id="c3fb" class="ko kp hi kk b fi ku kr l ks kt">// Handle events for the name form<br/>const nameForm = document.getElementById("nameForm");<br/>const nameTF = document.getElementById("nameTF") as HTMLInputElement;<br/>if (nameForm) {<br/>  const events = fromEvent(nameForm, "submit");<br/>  events.subscribe( (event) =&gt; {<br/>    event.preventDefault();<br/>    const name = nameTF.value as string;<br/>    logCollector.log(`Your name is ${name}`);<br/>    return false;<br/>  });<br/>}</span><span id="a363" class="ko kp hi kk b fi ku kr l ks kt">// Handle events for the favorite color form<br/>const favColorForm = document.getElementById("favColorForm");<br/>const favColorTF = document.getElementById("favColorTF") as HTMLInputElement;<br/>if (favColorForm) {<br/>  const events = fromEvent(favColorForm, "submit");<br/>  events.subscribe( (event) =&gt; {<br/>    event.preventDefault();<br/>    const favColor = favColorTF.value as string;<br/>    console.log(`Your favorite color is ${favColor}`);<br/>    // recklessly generate a null pointer error<br/>    let nullValue: string | null = "";<br/>    nullValue = null;<br/>    nullValue!.toUpperCase();<br/>    return false;<br/>  });<br/>}</span></pre><p id="eeac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该代码首先导入LogCollector类(这是本文的重点)和rxjs模块(用于响应表单提交的用户事件)。我使用Webpack来解析导入语句，并将它们捆绑到文件public/dist/bundle.js中。构建id用于标识应用程序的版本。在实例化LogCollector的实例后，会调用start方法来启动日志刷新服务器，该服务器会以固定的时间间隔将缓冲的日志发送到服务器。该脚本对表单事件的响应演示了控制台日志方法，并有意生成一个未捕获的类型错误，以显示如何收集未捕获的错误。</p><p id="227e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript应用程序驱动一个带有文本字段的HTML页面，如下所示。当开发人员单击按钮时，他或她可以在Chrome或其他浏览器中打开开发人员工具控制台，并看到记录的消息，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kv"><img src="../Images/36cc8f00511d94d5f171ed74d91efd3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLP7brdLDrqQw3sUsO3Njg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">浏览器控制台中web表单和日志的屏幕截图</figcaption></figure><p id="33a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">日志收集的代码包含在文件<a class="ae jd" href="https://gist.github.com/alexamies/037d7c11432ea2301de9995515c6deea" rel="noopener ugc nofollow" target="_blank"> public/index.ts </a>中导出的JavaScript模块中:</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="c737" class="ko kp hi kk b fi kq kr l ks kt">export { LogCollectorBuilder } from './lib/LogCollectorBuilder';<br/>export { LogCollector } from './lib/LogCollector';</span></pre><p id="9a81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该模块导出两个类，它们包含在各自的文件中。大部分实现都在文件lib/LogCollector.ts中的LogCollector:类中:</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="8535" class="ko kp hi kk b fi kq kr l ks kt">const defaultLog = console.log.bind(console);</span><span id="a2e4" class="ko kp hi kk b fi ku kr l ks kt">export class LogCollector {<br/>  private buildId: string;<br/>  private logs = new Array&lt;string&gt;();<br/>  private errors = new Array&lt;string&gt;();</span><span id="4299" class="ko kp hi kk b fi ku kr l ks kt">  constructor(buildId: string, replaceConsole: boolean) {<br/>    this.buildId = buildId;<br/>    if (replaceConsole) {<br/>      console.log = (msg: string, ...args: object[]) =&gt; {<br/>        if (args &amp;&amp; args.length) {<br/>          defaultLog(msg, args);<br/>        } else {<br/>          defaultLog(msg);<br/>        }<br/>        this.log(msg, args);<br/>      };<br/>    }<br/>....<br/>}</span></pre><p id="21f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构造函数可以选择替换console.log和console.error函数。有单独的可调用日志收集器方法log()和error，它们将日志和错误消息存储到缓冲区:</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="a1f9" class="ko kp hi kk b fi kq kr l ks kt">public log(msg: string, ...args: object[]) {<br/>  let message = msg;<br/>  if (args) {<br/>    message += args.join(", ");<br/>  }<br/>  this.logs.push(`browser app ${this.buildId}: ${message}`);<br/>}</span></pre><p id="4e9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LogCollectorBuilder类是用于创建日志收集器实例的生成器类。</p><p id="a736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TypeScript文件被编译成JavaScript，JavaScript也被Webpack打包成一个文件dist/bundle.js。</p><p id="985f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在模块内部，日志消息和错误存储在字符串数组中。然后每隔10秒左右，用一个AJAX调用将日志记录到服务器。为简单起见，这忽略了一个事实，即本机控制台函数接受一个可变的参数列表，而不仅仅是一个消息参数。</p><p id="58eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未捕获的异常通过监听<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror" rel="noopener ugc nofollow" target="_blank">global event handlers . on error</a>来收集</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="f0ff" class="ko kp hi kk b fi kq kr l ks kt">window.onerror = (msg, url, lineNo, columnNo, error) =&gt; {<br/>  if (error &amp;&amp; error.stack) {<br/>    errors.push(`Uncaught error: ${msg} in url ${url}\n${error.stack}`);<br/>  } else {<br/>    errors.push(`Uncaught error: ${msg}\n url ${url}\n Line: ${lineNo}`);<br/>  }<br/>};</span></pre><p id="1e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">server Node.js应用程序包括一个处理程序，用于接收这些数据并将它们记录在服务器上，包含在文件app.ts:</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="d474" class="ko kp hi kk b fi kq kr l ks kt">import * as express from "express";</span><span id="a918" class="ko kp hi kk b fi ku kr l ks kt">const app = express();<br/>app.use(express.static("public"));<br/>app.use(express.json());</span><span id="27a6" class="ko kp hi kk b fi ku kr l ks kt">app.post("/log", (req: express.Request, res: express.Response) =&gt; {<br/>  if ("logs" in req.body) {<br/>    const logs = req.body["logs"];<br/>    if (logs &amp;&amp; logs instanceof Array) {<br/>      logs.forEach( (log) =&gt; {<br/>        if (typeof log === "string") {<br/>          console.log(log);<br/>        } else {<br/>          sendError(`Log has wrong type: ${log}`, res);<br/>        }<br/>      });<br/>    }<br/>...</span></pre><p id="fdb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当应用程序在我们的本地环境中使用Node.js时，可以在服务器命令行上看到日志:</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="7b63" class="ko kp hi kk b fi kq kr l ks kt">npm run start<br/>&gt; browser-logs@0.0.1 start<br/>&gt; node app.js<br/>App listening on port 8080<br/>browser app v0.01: Your name is Alex<br/>browser app v0.01: Your favorite color is red<br/>Uncaught error: Uncaught TypeError: Cannot read property 'toUpperCase' of null in url webpack:///./node_modules/rxjs/_esm5/internal/util/hostReportError.js?<br/>TypeError: Cannot read property 'toUpperCase' of null<br/>at SafeSubscriber.eval [as _next] (webpack:///./app.js?:57:15)<br/>at SafeSubscriber.__tryOrUnsub<br/>...</span></pre><p id="3082" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未捕获的浏览器异常可以在上面的输出中看到。</p><p id="3898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序可以在云中运行，而无需更改代码，例如，通过部署到Cloud Run。可以使用下面的命令构建Node.js应用程序的Docker映像。首先将shell变量PROJECT_ID设置为适当的值。</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="5db2" class="ko kp hi kk b fi kq kr l ks kt">gcloud builds submit --tag gcr.io/$PROJECT_ID/logging-demo</span></pre><p id="c1e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用命令将应用程序部署到云运行</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="f4ad" class="ko kp hi kk b fi kq kr l ks kt">gcloud run deploy --image gcr.io/$PROJECT_ID/logging-demo --platform managed</span></pre><p id="f8d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们可以看到日志条目出现在Stackdriver控制台中，如下所示</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kw"><img src="../Images/ac3770cf291150ae01aca6d65c73303a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8D4q2Ohv0JDkVKO_getIA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Stackdriver日志记录用户界面中显示的浏览器日志</figcaption></figure><p id="434d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://cloud.google.com/error-reporting/docs/" rel="noopener ugc nofollow" target="_blank"> Stackdriver错误报告</a>中也可以跟踪错误，它给出了错误第一次和最后一次出现的详细信息，并绘制了错误频率的时间表。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/222592ccbc2ecafb858960ebecea2743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atfNf3pd1D_LhEsDORHA9w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Stackdriver错误报告用户界面中显示的浏览器错误</figcaption></figure><p id="a978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript <a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="noopener ugc nofollow" target="_blank">错误</a>对象包含一个堆栈跟踪，在Chrome和Firefox上实现。记录多行有效负载的错误，例如多行堆栈跟踪，将导致Stackdriver错误报告记录错误。不报告单行错误。</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="aea9" class="ko kp hi kk b fi kq kr l ks kt">├── app.js<br/>├── app.ts<br/>├── Dockerfile<br/>├── package.json<br/>├── public<br/>│   ├── app.js<br/>│   ├── app.scss<br/>│   ├── app.ts<br/>│   ├── dist<br/>│   │   ├── bundle.css<br/>│   │   └── bundle.js<br/>│   ├── index.html<br/>│   ├── index.js<br/>│   ├── index.ts<br/>│   ├── lib<br/>│   │   ├── LogCollectorBuilder.js<br/>│   │   ├── LogCollectorBuilder.ts<br/>│   │   ├── LogCollector.js<br/>│   │   └── LogCollector.ts<br/>│   ├── package.json<br/>│   ├── tsconfig.json<br/>│   ├── tslint.json<br/>│   └── webpack.config.js<br/>├── README.md<br/>├── tsconfig.json<br/>└── tslint.json</span></pre><p id="50ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">接下来的步骤</strong></p><ol class=""><li id="11ae" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">从浏览器使用<a class="ae jd" href="https://github.com/GoogleCloudPlatform/stackdriver-errors-js" rel="noopener ugc nofollow" target="_blank">客户端JavaScript库进行堆栈驱动错误报告</a></li><li id="2422" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">使用<a class="ae jd" href="https://github.com/census-instrumentation/opencensus-web" rel="noopener ugc nofollow" target="_blank"> opencensus-web </a>通过收集到堆栈驱动程序跟踪测量来自web客户端的性能数据。</li><li id="29eb" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">日志收集模块不具备浏览器控制台API的所有功能。有关详细信息，请参阅下面链接中的控制台文档。</li></ol><p id="5d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">资源</strong></p><ol class=""><li id="c22c" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae jd" href="https://cloud.google.com/logging/docs/setup/nodejs" rel="noopener ugc nofollow" target="_blank">在谷歌云平台为Node.js </a>设置Stackdriver日志</li><li id="7d55" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated"><a class="ae jd" href="https://developers.google.com/web/tools/chrome-devtools/console" rel="noopener ugc nofollow" target="_blank">谷歌网络基础的Chrome控制台文档</a></li><li id="d151" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">Mozilla开发者连接上的Mozilla控制台文档</li></ol></div></div>    
</body>
</html>