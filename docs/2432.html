<html>
<head>
<title>Configure Datastream for only certain DML’s on PostgreSQL as source.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅将PostgreSQL上的某些DML的数据流配置为源。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/configure-google-cloud-datastream-for-only-certain-dmls-on-postgresql-as-source-16e4ad789ef8?source=collection_archive---------0-----------------------#2022-10-18">https://medium.com/google-cloud/configure-google-cloud-datastream-for-only-certain-dmls-on-postgresql-as-source-16e4ad789ef8?source=collection_archive---------0-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="8ac1" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这是PostgreSQL和BigQuery在数据流上解决真实世界场景系列的第1部分，如果有兴趣查看所有策划的场景<a class="ae jh" href="https://mahtodeepak.medium.com/solving-real-world-scenarios-on-datastream-for-postgresql-and-bigquery-b79334a065fc" rel="noopener">请点击我。</a></p></blockquote><p id="082a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">PostgreSQL是被广泛采用的托管数据库之一，许多客户要求将事务更改直接传输到BigQuery。在Google Cloud上，来自CloudSQL for PostgreSQL的连续流是不同客户的常见问题之一，是BigQuery等下游平台上进一步整合分析的一部分。<br/>通过最近发布的Datastream for BigQuery，它使用逻辑复制从不同的PostgreSQL兼容源提供初始回填和连续复制。有了Datastream，CloudSQL和BigQuery之间的集成变得更加容易，这是一种丰富、简单、无服务器和可扩展的方法。它目前正在公开预览中，以测试从事务性工作负载到BigQuery的流更改的不同用例。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/5213473c5a20e155adacc3581214a63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfZYDFvmEb8nHEsOeenT3A.png"/></div></div></figure><p id="49d1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">主要是插入、更新和删除是需要包含在流中的事务性表上的常见更改。但是我们可能有一个功能需求，只对特定的表列表进行流插入或者只进行插入和更新。目前，Datastream不提供支持选择性数据操作事件的特性来在BigQuery上捕获和发布。</p><p id="2e42" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在当前的博客中，我们将演练如何使用PostgreSQL逻辑复制特性为特定事件配置流，如仅插入或仅插入、在特定表列表上插入和更新。</p><p id="2f3e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们将CloudSQL for PostgreSQL配置为带有示例表集的源。</p><pre class="jm jn jo jp fd jx jy jz bn ka kb bi"><span id="bcbc" class="kc kd hi jy b be ke kf l kg kh">drop table if exists sample_insert_only;<br/>create table sample_insert_only<br/>as<br/>select col1 , col1+1 as col2 , col1+2 as col3 , md5(random()::text) as col4 from generate_series(1,1000) as col1;<br/>alter table sample_insert_only add constraint pk_sample_insert_only primary key(col1);<br/>drop table if exists sample_insert_update_only;<br/>create table sample_insert_update_only<br/>as<br/>select col1 , col1+1 as col2 , col1+2 as col3 , md5(random()::text) as col4 from generate_series(1,1000) as col1;<br/>alter table sample_insert_update_only add constraint pk_sample_insert_update_only primary key(col1);<br/>drop table if exists sample_all_dml;<br/>create table sample_all_dml<br/>as<br/>select col1 , col1+1 as col2 , col1+2 as col3 , md5(random()::text) as col4 from generate_series(1,1000) as col1;<br/>alter table sample_all_dml add constraint pk_sample_all_dml primary key(col1);</span></pre><p id="1df5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">下面是需要发布的表格列表和dml的摘要。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ki"><img src="../Images/ab27b0b3c94db47cd7a6e7e30bf9d9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_K92JuX8hyvgJVu5XJ5NA.png"/></div></div></figure><p id="119e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">数据流<a class="ae jh" href="https://cloud.google.com/datastream/docs/configure-your-source-postgresql-database#csqlforpostgresql" rel="noopener ugc nofollow" target="_blank">文档</a>详细介绍了如何为托管实例配置源和启用逻辑解码。</p><p id="7ff4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">作为启用选择性发布的一部分，我们将创建三个不同的发布，并根据源PostgreSQL数据库中的发布要求添加表，即是否必须仅插入或仅插入并更新。</p><h2 id="4d3f" class="kj kd hi bd kk kl km kn ko kp kq kr ks ji kt ku kv jj kw kx ky jk kz la lb lc bi translated">创建发布并配置发布属性</h2><pre class="jm jn jo jp fd jx jy jz bn ka kb bi"><span id="5463" class="kc kd hi jy b be ke kf l kg kh">CREATE PUBLICATION pub_bq_pg_insert FOR TABLE sample_insert_only <br/>WITH (publish = 'insert');<br/>CREATE PUBLICATION pub_bq_pg_insert_update FOR TABLE sample_insert_update_only <br/>WITH (publish = 'insert,update');<br/>CREATE PUBLICATION pub_bq_pg_all_dml FOR TABLE sample_all_dml <br/>WITH (publish = 'insert,update,delete') ;</span></pre><p id="d5e2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">从psql控制台创建的发布和添加到其中的表的摘要。我们可以向同一个<a class="ae jh" href="https://www.postgresql.org/docs/14/sql-alterpublication.html" rel="noopener ugc nofollow" target="_blank">发布</a>添加多个表，其更改将基于发布属性发布。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ld"><img src="../Images/712e4cf6ad151e3515290f2095e56fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1paXce6B7fczyWfwOFBqQ.png"/></div></div></figure><p id="5791" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">数据流创建的每个流都将使用pgoutput插件从活动的复制槽中获取。接下来，我们将创建三个不同的复制插槽。</p><h2 id="c30b" class="kj kd hi bd kk kl km kn ko kp kq kr ks ji kt ku kv jj kw kx ky jk kz la lb lc bi translated">为每个发布创建复制槽</h2><pre class="jm jn jo jp fd jx jy jz bn ka kb bi"><span id="6bb9" class="kc kd hi jy b be ke kf l kg kh">SELECT PG_CREATE_LOGICAL_REPLICATION_SLOT('pg_rep_bq_insertonly', 'pgoutput');<br/>SELECT PG_CREATE_LOGICAL_REPLICATION_SLOT('pg_rep_bq_insertupdonly', 'pgoutput');<br/>SELECT PG_CREATE_LOGICAL_REPLICATION_SLOT('pg_rep_bq_all_dml', 'pgoutput');</span></pre><p id="e91e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们已经配置了必要的连接配置文件，并在GCE(Google Compute Engine)上启用了cloudsqlproxy来连接CloudSQL作为源。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es le"><img src="../Images/5a3fdb3d7fb3a6db3536e2b149e47d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFTK8ucPQYsLaAl-8tUAIw.png"/></div></div></figure><p id="2ea6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">接下来，我们将根据发布需求创建三个不同的流。我们已经完成了基于发布模式创建三个不同流的所有必要步骤，并完成了数据的初始回填。</p><h2 id="c033" class="kj kd hi bd kk kl km kn ko kp kq kr ks ji kt ku kv jj kw kx ky jk kz la lb lc bi translated">在数据流中创建流，将PostgreSQL作为源，将BigQuery作为目标。</h2><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lf"><img src="../Images/b362c5c1e190720eb8d6d6c99f7468eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Iee7ZRqYs4EfJVk83JYP9Q.gif"/></div></div></figure><p id="b4e6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们看看不同的流如何基于为表配置的发布事件将更改推送到BigQuery。<br/>在数据流stream 1-insert only-stream上，只订阅了insert。让我们在源端应用所有dml，并检查它在目标端是如何被使用的。</p><pre class="jm jn jo jp fd jx jy jz bn ka kb bi"><span id="8d8e" class="kc kd hi jy b be ke kf l kg kh">insert into sample_insert_only<br/>(select col1 , col1+1 as col2 , col1+2 as col3 , md5(random()::text) as col4 <br/>from generate_series(1001,2000) as col1);<br/>update sample_insert_only<br/>set col4 = 'updated'<br/>where col1 &lt; 11;<br/>delete from sample_insert_only<br/>where col1 between 11 and 20;</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lg"><img src="../Images/9ad4823db009b7fb9a17bcc351511272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJxvxeiZhL3MLksgcS7cPw.png"/></div></div></figure><p id="2f82" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">虽然我们已经推送了所有dml，但只有与Insert相关的事件被推送到数据流和流1的BigQuery目标。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lf"><img src="../Images/b7611c37b11a8fde5a0725d851bf0ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GFEOPQygdCjULjSXqBDSOg.gif"/></div></div></figure><p id="fb44" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在数据流stream 2-insertupdateonly-stream上，只订阅了插入和更新。让我们在源端应用所有dml，并检查它在目标端是如何被使用的。</p><pre class="jm jn jo jp fd jx jy jz bn ka kb bi"><span id="3ffd" class="kc kd hi jy b be ke kf l kg kh">insert into sample_insert_update_only(select col1 , col1+1 as col2 , <br/>col1+2 as col3 , md5(random()::text) as col4 <br/>from generate_series(1001,2000) as col1);<br/>update sample_insert_update_only<br/>set col4 = 'updated-one'<br/>where col1 &lt; 11;<br/>delete from sample_insert_update_only<br/>where col1 between 11 and 20;</span></pre><p id="84c3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">虽然我们推送了所有的dml，但只有与插入和更新相关的事件被推送到数据流和流2的BigQuery目标。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lf"><img src="../Images/603904d68e5b2c75e69f76d5eb08c8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UAsDBe-BRKNwpB09zLcNNQ.gif"/></div></div></figure><p id="27dc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">最后一个流3订阅所有事件，且它也将捕获删除，包括插入和删除。</p><pre class="jm jn jo jp fd jx jy jz bn ka kb bi"><span id="45c9" class="kc kd hi jy b be ke kf l kg kh">insert into sample_all_dml<br/>(select col1 , col1+1 as col2 , col1+2 as col3 , md5(random()::text) as col4 <br/>from generate_series(1001,2000) as col1);<br/>update sample_all_dml<br/>set col4 = 'updated-one'<br/>where col1 &lt; 11;<br/>delete from sample_all_dml<br/>where col1 between 11 and 20;</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lh"><img src="../Images/52fdc65b8615e45c2bf9f3a55f95450a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7Ke_gi15lkn8mBynbP1V2Q.gif"/></div></div></figure><h2 id="fea9" class="kj kd hi bd kk kl km kn ko kp kq kr ks ji kt ku kv jj kw kx ky jk kz la lb lc bi translated">学问</h2><p id="f30a" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it ji lk iw ix jj ll ja jb jk lm je jf jg hb bi translated">使用PostgreSQL发布，我们可以根据BigQuery作为目标数据流的功能需求来改变要发布的事件。在一个出版物中，我们可以包含多个表，用于根据配置发布特定的dml。<br/>在此过程中，我们根据自定义更改创建了多个复制槽，我们应该对其进行测试，以验证任何开销或对源的影响，以及为逻辑复制发布者调整的工作器的必要配置。</p><h2 id="1b55" class="kj kd hi bd kk kl km kn ko kp kq kr ks ji kt ku kv jj kw kx ky jk kz la lb lc bi translated">进一步阅读</h2><blockquote class="if ig ih"><p id="5ac3" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">查看<a class="ae jh" rel="noopener" href="/google-cloud/configure-streams-from-partition-table-in-postgresql-to-non-partition-in-bigquery-using-datastream-3238fe3321d9">第2部分</a>，解决PostgreSQL和BigQuery数据流上的真实场景，其中包括“使用数据流配置从PostgreSQL中的分区表到BigQuery中的非分区的流”</p></blockquote></div></div>    
</body>
</html>