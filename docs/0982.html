<html>
<head>
<title>Making requests to Cloud Run with the Service Account</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用服务帐户向云运行发出请求</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/making-requests-to-cloud-run-with-the-service-account-620014dc1486?source=collection_archive---------1-----------------------#2019-04-26">https://medium.com/google-cloud/making-requests-to-cloud-run-with-the-service-account-620014dc1486?source=collection_archive---------1-----------------------#2019-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cloud Run是Google云平台上新的计算无服务器解决方案。它可以运行任何部署为Docker image的web应用程序。它的一个很好的功能是内置的自动认证，即你可以隐藏公共互联网的服务，并通过IAM控制访问。这样，您可以向具体的用户或组授予访问权限。由于云运行的主要用途之一是微服务，并且通过访问控制功能，可以方便地将其用于内部微服务(您希望它是私有的)，其中一种方法是使用服务帐户。</p><p id="460b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://cloud.google.com/run/docs/securing/authenticating#service-to-service" rel="noopener ugc nofollow" target="_blank">官方文档</a>中，描述了如何使用服务对服务的身份验证，并提供了从Google Cloud发出请求的代码示例，其中身份验证凭证是从元数据服务器获得的，因此不需要服务帐户。如果您想要在GCP以外的地方请求云运行服务，则需要服务帐户。现在在文档中，有描述如何做的步骤，但是没有代码示例。</p><p id="aae0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在这篇文章中，我想描述如何设置私有的云运行服务，以及如何使用服务帐户进行请求。作为一个应用程序，我创建了Docx到PDF的转换器，类似于它在Cloud Next '19 keynote中的演示。服务也可以用作Pub Sub HTTP目标，并用于异步处理，我将在下一篇文章中对此进行描述。</p><p id="2461" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个例子的完整代码在Github资源库<a class="ae jd" href="https://github.com/zdenulo/gcp-docx2pdf/tree/master/cloud_run_pubsub" rel="noopener ugc nofollow" target="_blank">https://Github . com/zde nulo/GCP-docx 2 pdf/tree/master/cloud _ run _ pubsub</a>中。</p><p id="70f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于web服务，没有什么特别的，Libreoffice可以通过Docker安装和使用，这很酷。Web服务被定制为接受来自发布订阅的json消息，最小POST请求需要采用以下格式:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="c506" class="jn jo hi jj b fi jp jq l jr js">{<br/>   "message":{<br/>      "attributes":{<br/>         "bucketId":"BUCKET-ID",<br/>         "objectId":"FILE-PATH"<br/>      }<br/>   }<br/>}</span></pre><p id="0b7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务需要一个需要转换的Docx文件存储在云存储中，因此bucket和filename(路径)是必需的输入。</p><p id="42ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了构建和部署服务，Cloud Build与配置文件cloudbuild.yaml一起使用</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="9ded" class="jn jo hi jj b fi jp jq l jr js">steps:<br/>  # build the container image<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  args: ['build', '-t', 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}:${TAG_NAME}', '.']<br/>  # push the container image to Container Registry<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  args: ['push', 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}']<br/>  # Deploy container image to Cloud Run<br/>- name: 'gcr.io/cloud-builders/gcloud'<br/>  args: ['beta', 'run', 'deploy', '${_SERVICE_NAME}', '--image', 'gcr.io/$PROJECT_ID/${_SERVICE_NAME}:${TAG_NAME}', '--region', 'us-central1', '--memory', '1Gi', '--update-env-vars', '${_ENV_VARIABLES}']<br/>images:<br/>- gcr.io/$PROJECT_ID/${_SERVICE_NAME}</span></pre><p id="0301" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务期望设置环境变量OUTPUT_BUCKET(这是保存PDF的存储桶的名称),这是在部署期间完成的。此外，还需要定义云运行服务的名称。</p><p id="1d49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用以下命令启动构建和部署:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="80e6" class="jn jo hi jj b fi jp jq l jr js">gcloud builds submit --config=cloudbuild.yaml --substitutions=_SERVICE_NAME="&lt;service name&gt;",TAG_NAME="v0.1",_ENV_VARIABLES="OUTPUT_BUCKET=&lt;name of output bucket&gt;"</span></pre><p id="aa88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，云运行服务部署为私有。</p><p id="f470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是创建服务帐户并分配特定的角色。要创建名为cr-test的服务帐户，我将执行以下命令:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e71c" class="jn jo hi jj b fi jp jq l jr js">~&gt;gcloud iam service-accounts create cr-test --display-name="Cloud Run Test"<br/>Created service account [cr-test].</span></pre><p id="4669" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，正如官方文档所说，我将向服务帐户角色添加云运行调用者，这是向云运行服务发出请求所必需的:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="085f" class="jn jo hi jj b fi jp jq l jr js">~&gt; gcloud beta run services add-iam-policy-binding sa-run --member=serviceAccount:cr-test@adventures-on-gcp.iam.gserviceaccount.com --role=roles/run.invoker<br/>Updated IAM policy for service [sa-run].<br/>bindings:<br/>- members:<br/>  - serviceAccount:cr-test@adventures-on-gcp.iam.gserviceaccount.com<br/>  role: roles/run.invoker<br/>etag: BwWHWbhxA2c=</span></pre><p id="6770" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是向服务帐户添加IAM策略绑定。这样，服务帐户将显示在IAM部分，如果需要，您可以为其分配多个角色。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1821" class="jn jo hi jj b fi jp jq l jr js">gcloud projects add-iam-policy-binding &lt;PROJECT-ID&gt; --member=serviceAccount:cr-test@adventures-on-gcp.iam.gserviceaccount.com --role=roles/run.invoker</span></pre><p id="db43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是创建一个私钥文件(在我的例子中，我将其命名为cr-test-secret.json ),并将其下载到本地，以便从本地计算机向云运行服务发出请求:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="d438" class="jn jo hi jj b fi jp jq l jr js">gcloud iam service-accounts keys create cr-test-secret.json --iam-account=cr-test@adventures-on-gcp.iam.gserviceaccount.com</span></pre><p id="d5e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用服务帐户凭证在Python中发出请求的代码在api_request.py文件中，只有几行，BUCKET_NAME和API_URL需要适当设置。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="7652" class="jn jo hi jj b fi jp jq l jr js">from google.oauth2 import service_account<br/>from google.auth.transport.requests import AuthorizedSession<br/><br/>SERVICE_FILENAME = 'cr-test-secret.json'<br/>BUCKET_NAME = ''  # name of the bucket where Docx file is saved<br/>API_URL = ''  # change to url of you Cloud Run service<br/><br/>audience = API_URL<br/>credentials = service_account.IDTokenCredentials.from_service_account_file(SERVICE_FILENAME, target_audience=audience)<br/><br/>session = AuthorizedSession(credentials)<br/><br/>data = {"message": {"attributes": {"bucketId": BUCKET_NAME, "objectId": "demo.docx"}}}<br/><br/>r = session.post(API_URL, json=data)<br/>print(r.text)</span></pre><p id="ec30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里最重要的是要注意使用service_accounts模块中的哪个类。我通常使用<strong class="ih hj">credentials . from _ service _ account()</strong>但是在这种情况下，需要使用<strong class="ih hj"> IDTokenCredentials </strong>类。如文档中所述，两者之间的区别在于“这些凭证在很大程度上类似于凭证类，但是它们不使用OAuth 2.0访问令牌作为承载令牌，而是使用Open ID Connect ID令牌作为承载令牌。当与需要ID令牌但不能接受访问令牌的服务进行通信时，这些凭据非常有用。</p><p id="e691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AuthorizedSession基本上是一个“请求”库的包装器，以正确的头发出请求。</p></div></div>    
</body>
</html>