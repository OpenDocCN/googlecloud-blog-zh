<html>
<head>
<title>Understand Cloud Load Balancer Like a Senior Engineer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像高级工程师一样理解云负载平衡器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/understand-cloud-load-balancer-like-a-senior-engineer-d4f55f3111fc?source=collection_archive---------0-----------------------#2021-11-01">https://medium.com/google-cloud/understand-cloud-load-balancer-like-a-senior-engineer-d4f55f3111fc?source=collection_archive---------0-----------------------#2021-11-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="8e2a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">软件负载平衡器(SLB)</h1><p id="26ae" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">大多数云负载平衡器开发者今天使用的是软件负载平衡器。它们不仅用于平衡网络流量，而且几乎可以平衡任何计算资源，包括CPU资源、内存和磁盘空间资源、网络资源等。</p><p id="2e27" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有时人们只是称它们为代理，尤其是在云原生或服务网格的上下文中，因为代理将网络转发作为其主要功能。代理/负载平衡器主要负责三个功能:</p><ul class=""><li id="943a" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated"><strong class="jf hj">端点发现</strong></li><li id="2b7c" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">健康检查</strong></li><li id="9bd1" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated"><strong class="jf hj">负载均衡</strong></li></ul><h1 id="8835" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">L4/L7负载平衡</h1><p id="24cc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">业界的负载均衡解决方案基本上是两种:第四层负载均衡器和第七层负载均衡器。第4层和第7层是指OSI模型中的层。第4层是传输层，第7层是应用层。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/a5686175e5fc7c4690a19f834744d570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbCBQtXq-YQrkWE95UN0WQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">来自维基百科的OSI模型</figcaption></figure><h1 id="4d83" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">L4负载平衡器</h1><p id="009a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">L4负载平衡并不意味着负载平衡器将在第4层工作。事实上，大多数L4负载平衡器仍然工作在第2层和第3层。有时，您可能会听到人们谈论第2层负载平衡或第3层负载平衡。现在都叫第四层负载均衡。</p><p id="e498" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">L4负载平衡器在上游和下游之间保持相同的TCP连接。这将确保来自同一来源的流量总是被路由到同一后端。引擎盖下发生了什么？让我们重温一下OSI模型的七层。</p><p id="edb6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第一层是物理层，传输比特流。这一层中的设备，包括网卡和各种电缆光纤，可以直接与交叉线通信。</p><p id="ac27" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第二层是数据链路层，它传输数据帧。WIFI (802.11)、以太网(802.3)、PPP都在这里工作。交换机在这一层工作，维护一个地址表，将每台设备的MAC地址与LAN端口相关联。同一局域网中的设备可以通过交换机进行通信。</p><p id="24c4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第三层是网络层，传输数据包。OSPF、IS-IS、BGP和其它路由协议都在这一层工作。在路由器的帮助下，设备可以通过IPv4/IPv6寻址进行通信。网络数据包现在可以在整个广域网上传输。</p><p id="9e82" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第四层称为传输层，它传输数据段。TCP / UDP协议在这里工作，它们知道主机的端口号。IP标识主机在互联网上的位置，而端口标识在该主机上监听该端口的程序。</p><p id="7bac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">前三层称为媒体层，前四层称为主机层。在前三层，网卡可以处理流量，并将它们转发到下一跳。从第4层开始，流量将冲击Linux内核网络堆栈，其性能比NIC处理更差(我们确实有一些旁路内核选项，但这超出了今天讨论的范围)。一般来说，低层在处理数据包时表现更好。这就是为什么L4负载平衡主要在第2层和第3层工作。</p><h2 id="666e" class="lk ig hi bd ih ll lm ln il lo lp lq ip jo lr ls it js lt lu ix jw lv lw jb lx bi translated">第2层负载平衡</h2><p id="9ed5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">实际上有两种方式来执行转发行为:数据包封装和重写。</p><p id="8cc8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在第2层，它主要是重写。如果你仔细看看标准的802.3框架结构，它会是这样的</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ly"><img src="../Images/e1433ee7a2bc5a8f4746ef736a56ad76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVOU8BWsZfqduTx0Fl3W3w.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">802.3框架结构</figcaption></figure><p id="6dd5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们现在可以忽略其他字段，专注于源MAC地址和目的MAC地址。交换机将媒体访问控制地址与局域网端口相关联，并根据地址表转发数据帧。问题是，如果我们只依靠交换机转发流量，数据包就永远不会穿过子网。所以路由器实际上会封装和去封装数据包。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lz"><img src="../Images/852e7e5c9740ed01860637369c529c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9McLTtC8fTLTMgCvO8mNAA.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">L2包重写</figcaption></figure><p id="b73c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦路由器收到网络数据包，它首先将其解封装，删除原始的第2层报头和尾部(以太网报头包含源和目的MAC地址)，然后使用路由表来确定下一跳地址，并重新封装数据包。路由器将使用自己的媒体访问控制地址作为新的源媒体访问控制地址，下一跳地址作为新的目的媒体访问控制地址，并用新的第2层报头和尾部封装数据包。</p><p id="e7ee" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第2层负载平衡器也以同样的方式工作。例如，谷歌使用网络缩放器作为第2层负载平衡器，后来被<a class="ae ma" href="https://research.google/pubs/pub44824/" rel="noopener ugc nofollow" target="_blank">磁悬浮</a>取代。虚拟IP地址(VIP)将提供给所有真实的服务器和负载平衡器。当用户向VIP发送请求时，它首先命中L2负载均衡器，该负载均衡器确定将请求转发到的真实服务器，并修改数据帧中的目的MAC地址。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/246e9fe496bf60f93bcbd4d6583fb10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pcJmlZWhrtCRbwvy1dj13Q.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">L2·DSR(直接服务器返回)</figcaption></figure><p id="f09b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由于第2层负载平衡器仅在转发期间更改帧的目的MAC地址，而不涉及更高层的协议(不修改有效负载的内容)，因此在更高层(第3层)看来，所有数据都保持不变。</p><p id="ab2e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由于请求数据包的目的IP与服务器IP匹配，因此服务器可以直接传输响应，而无需再次通过负载平衡器。这就是所谓的<strong class="jf hj"> L2 DSR(第2层直接服务器返回)</strong>。</p><h2 id="4d38" class="lk ig hi bd ih ll lm ln il lo lp lq ip jo lr ls it js lt lu ix jw lv lw jb lx bi translated">第3层负载平衡</h2><p id="b2d4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">第3层可以处理更复杂的负载平衡任务。网络地址转换(NAT)和IP封装是两种最常见的形式。</p><p id="76c8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您的家庭路由器每天使用<strong class="jf hj">网络地址转换(NAT) </strong>将私有IP地址转换为公共IP地址。类似地，第3层负载平衡器也可以重写IP报头，以修改源和目的IP地址，并将流量重定向到适当的后端服务器。代价是负载平衡器本身必须处理所有流量，从而导致性能瓶颈。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mc"><img src="../Images/da75c6b3128b790ed2ea401a9db4c07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sb-O6bR2a88UvENpbyMuWQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">专用网络和互联网之间的网络地址转换(来自wikepedia)</figcaption></figure><p id="6487" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">另一个选择是<strong class="jf hj"> IP封装</strong>。它将现有的IP报头和有效载荷视为完整的有效载荷，然后添加新的IP报头。例如，谷歌和谷歌云使用Maglev作为<a class="ae ma" href="https://cloud.google.com/load-balancing/docs/network" rel="noopener ugc nofollow" target="_blank"> L4 TCP/UDP外部负载平衡器</a>。</p><p id="53a5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">根据<a class="ae ma" href="https://research.google/pubs/pub44824/" rel="noopener ugc nofollow" target="_blank"> Maglev论文</a>(2016年发表)，每个后端服务器都将拥有一个或多个虚拟IP地址(VIP)。当Maglev向VIP发送数据包时，它会选择一个与该VIP相关联的服务端点，并使用<strong class="jf hj">通用路由封装(GRE) </strong>通过添加一个指向该端点的外部IP报头来封装数据包。后端服务器将解封装并使用客户端请求包，然后发回响应。谷歌也在第三层使用DSR。因此响应包将服务器VIP作为源地址，用户的IP作为目的地址。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es md"><img src="../Images/1f408afbd8d211219e386caa44e6fa81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QeZN2q_gQHDZ3kqqw0XCBQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">第3层直接服务器返回</figcaption></figure><p id="ea9a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">DSR负载平衡器仅处理入站流量。当你在google.com上搜索某个东西时，你的请求可能只需要几千字节，但是响应可能需要几百甚至几千字节，尤其是当结果中有一些图表的时候。借助DSR，我们可以节省99%的负载平衡带宽。</p><h2 id="d020" class="lk ig hi bd ih ll lm ln il lo lp lq ip jo lr ls it js lt lu ix jw lv lw jb lx bi translated">第4层负载平衡</h2><p id="af8c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">第4层负载平衡将在环路中包含端口号。第4层负载平衡器将使用IP:Port，而不是IP地址。事实上，这种情况很常见，很容易在您的家用路由器上找到。我们讨论了NAT如何在第3层将私有地址转换为公有地址。但是，如果您家里有多台设备，但只有一个对外的公共地址，那么如何将多个私有地址映射到一个公共地址呢？</p><p id="76d4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">原来家庭路由器上的NAT模式实际上是NAPT(网络地址和端口转换)，它将来自不同私有IP地址的请求映射到同一公共IP的不同端口。可用的端口号范围从0到65535，这对于大多数住宅场景来说绰绰有余。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es me"><img src="../Images/420aa1a90c539a632a72a3d91bddad6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9WfNhd_Z3WBHTjhr.jpg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">网络地址和端口转换(来自wikepedia)</figcaption></figure><p id="2c48" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您回忆一下本文开头关于OSI模型中七层的段落，您会很容易地发现端口号不包含在IP协议(网络层)中，而是包含在TCP/UDP协议(传输层)中。因此，重写端口将发生在第4层。</p><h2 id="ef96" class="lk ig hi bd ih ll lm ln il lo lp lq ip jo lr ls it js lt lu ix jw lv lw jb lx bi translated">谷歌云L4负载均衡器</h2><p id="f7c6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通常，云公司有一个更具描述性的产品名称，而不是第4层或第7层。如果你访问谷歌云用户指南页面，它们被称为TCP/UDP负载平衡器和HTTP(s)负载平衡器。</p><p id="c0e0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">负载平衡器可以分为内部负载平衡器和外部负载平衡器。外部负载平衡器需要公共IP地址，而内部负载平衡器只能在虚拟私有云(VPC)内工作。Google Cloud使用<a class="ae ma" href="https://research.google/pubs/pub44824/" rel="noopener ugc nofollow" target="_blank"> Maglev </a>作为<a class="ae ma" href="https://cloud.google.com/load-balancing/docs/network" rel="noopener ugc nofollow" target="_blank">外部TCP/UDP网络负载均衡器</a>，它包含了上面提到的所有2/3/4层负载均衡功能。</p><p id="418e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">谷歌云<a class="ae ma" href="https://cloud.google.com/load-balancing/docs/internal" rel="noopener ugc nofollow" target="_blank">内部TCP/UDP负载均衡器</a>建立在<a class="ae ma" href="https://research.google/pubs/pub48645/" rel="noopener ugc nofollow" target="_blank">仙女座</a>网络虚拟化堆栈之上。所有第3/4层活动现在都由SDN(软件定义网络)管理。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/deb30446aa474e4df7a7d531f49b07c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpdsgxhMjyixF5y1xnjqvw.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">仙女座架构(来自Cloud Next’18)</figcaption></figure><p id="3016" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">准确地说，第4层内部负载平衡是Andromeda提供的虚拟化网络功能(VNF)之一。</p><p id="608d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Andromeda使用health checker服务检查后端虚拟机的端点，并通过health reporter将端点相关信息传递给虚拟机控制器(VMC)。VM控制器将该信息编程到OpenFlow前端(OFE)。</p><p id="0156" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">OpenFlow前端将通过OpenFlow协议向VM Host内部的虚拟交换机(Open vSwitch，OVS)通告路由信息。当客户端虚拟机向后端虚拟机发送请求时，数据包将首先通过虚拟交换机，然后离开虚拟机主机。然后，虚拟交换机将挑选一个健康的后端虚拟机，并将流量定向到那里，就像真正的负载平衡器一样。换句话说，没有中间体负载平衡器。流量在虚拟机之间流动，可以避免阻塞点，提高网络性能。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mg"><img src="../Images/f22646665bc78200d431457fa0031dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eJPO5tvcjhjaf7uGk4_hA.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">使用Andromeda的内部负载平衡器(来自Cloud Next’18)</figcaption></figure><h1 id="24e3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">L7负载平衡器</h1><p id="27c8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">L4负载平衡器主要通过转发TCP流量来工作，但是在客户端和服务器之间维护相同的TCP通道。而L7负载平衡器充当代理，在客户端和负载平衡器之间建立一个连接，在负载平衡器和服务器之间维护另一个连接。L7负载平衡器可以被视为客户端和真实后端服务器之间的附加服务器，它接受来自客户端的请求，并在将请求路由到真实服务器之前根据请求的内容做出初始决定。</p><p id="c78f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有些要求L4负载平衡器不支持，而L7负载平衡器支持。例如，L7负载平衡器可以根据URL路径将流量重定向到不同的服务，这是微服务环境中的常见用例。</p><p id="985d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">通过评估HTTP(s)请求内容，L7负载平衡器可以提供更高级的功能。然而，代价是效率，因为L7负载平衡器将不得不经历另一轮TCP握手。在微服务架构中，L7负载平衡器/代理将是流量管理的基石。</p><h2 id="9e99" class="lk ig hi bd ih ll lm ln il lo lp lq ip jo lr ls it js lt lu ix jw lv lw jb lx bi translated">谷歌云L7负载平衡</h2><p id="07f4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Google Cloud内部HTTP(S)负载平衡(L7负载平衡)是基于Envoy代理的托管服务。</p><p id="6ca9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">特使代理可以用作边车代理。在微服务场景中，服务被分成不同的独立单元。Sidecar代理(Envoy)位于工作负载旁边(它们可以在相同的虚拟机或Kubernetes Pods中运行)。代理中介所有入站/出站(HTTP、REST、gRPC、Redis等)流量。因此，服务实例只知道本地代理，而不知道整个网络。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mh"><img src="../Images/897a412da93a2bb9e5d7da6237ee3784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiiiZaA7nrC0PxaMvzkK6A.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">Sidecar代理(来自Cloud Next’19)</figcaption></figure><p id="fbe7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">除了sidecar代理之外，Envoy还可以用作L7负载平衡器。这里有一个由<a class="ae ma" href="https://cloud.google.com/load-balancing/docs/l7-internal#load_balancing_using_path-based_routing" rel="noopener ugc nofollow" target="_blank">谷歌云指南</a>提供的用例样本。在此图中，内部HTTP(S)负载平衡是一个基于开源特使代理的托管服务。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mi"><img src="../Images/dd8f1272a7b460505cc063ea0d135ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0FvGXNrFeVuqZuakGLVaQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">来自Google Cloud的例子:基于第7层负载平衡的内部(微)服务</figcaption></figure><blockquote class="mj mk ml"><p id="31bd" class="jd je mm jf b jg kb ji jj jk kc jm jn mn kd jq jr mo ke ju jv mp kf jy jz ka hb bi translated">一个常见的用例是服务之间的负载平衡流量。在本例中，内部客户端可以通过使用路径为<code class="du mq mr ms mt b">/video</code>和<code class="du mq mr ms mt b">/images</code>的相同基本URL来请求视频和图像内容。</p><p id="a1a4" class="jd je mm jf b jg kb ji jj jk kc jm jn mn kd jq jr mo ke ju jv mp kf jy jz ka hb bi translated">内部HTTP(S)负载平衡器的URL映射指定对路径<code class="du mq mr ms mt b">/video</code>的请求应该发送到视频后端服务，而对路径<code class="du mq mr ms mt b">/images</code>的请求应该发送到图像后端服务。在以下示例中，视频和图像后端服务通过使用计算引擎虚拟机来提供，但它们也可以通过使用GKE pod来提供。</p><p id="5831" class="jd je mm jf b jg kb ji jj jk kc jm jn mn kd jq jr mo ke ju jv mp kf jy jz ka hb bi translated">当内部客户端向负载平衡器的内部IP地址发送请求时，负载平衡器根据此逻辑评估请求，并将请求发送到正确的后端服务。</p></blockquote><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mu"><img src="../Images/2e5fcfae41d51cc0c33053e78718494f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UAfUiaRVfoL6uEr1LmDpkQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">特使处理HTTP请求</figcaption></figure><p id="d7bb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Envoy的ListenerFilter拦截入站流量，确定协议，然后将其传递给第4层的<a class="ae ma" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/http_conn_man#config-http-conn-man" rel="noopener ugc nofollow" target="_blank"> http_connection_manager </a>进行处理。一旦数据包被<code class="du mq mr ms mt b">codec</code>解码，它们将被传递给<a class="ae ma" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_filters" rel="noopener ugc nofollow" target="_blank"> L7 HTTP过滤器</a>。<code class="du mq mr ms mt b"><a class="ae ma" href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router" rel="noopener ugc nofollow" target="_blank">envoy.filters.http.router</a></code>必须是过滤器链中的最后一个。它会根据URL路径和路由配置定位目标集群，然后根据负载均衡策略选择目标地址。</p><p id="e4d9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在前面的示例用例中，视频和图像后端服务部署在负载平衡器特使之后，每个服务都有一个sidecar特使。这是我对负载平衡器特使的配置。它将按循环顺序挑选可用的后端。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mv"><img src="../Images/43aa22630717b4c88f8ad5d253689543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oxJj7cDlPLd0m4DVGYeGw.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">负载平衡器特使配置</figcaption></figure><h1 id="3fa2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">总结</strong></h1><ul class=""><li id="b9ff" class="kg kh hi jf b jg jh jk jl jo mw js mx jw my ka kl km kn ko bi translated">云负载均衡器主要完成三项工作:端点发现、健康检查和负载均衡。</li><li id="e8f2" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">负载均衡解决方案基本上有两种类型:L4负载均衡器和L7负载均衡器。</li><li id="1331" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">第4层(传输层)负载平衡器在客户端和服务器之间保持相同的TCP连接。它包括所有第2 / 3 / 4层负载平衡技术。</li><li id="620d" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">Google Cloud内部TCP/UDP负载均衡器(L4负载均衡器)是Andromeda提供的虚拟化网络功能之一。</li><li id="4b1e" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">第7层(应用层)负载均衡器功能更强大，是服务网格流量管理的基础，但这是有代价的:效率。</li><li id="7c94" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">Google Cloud内部HTTP(S)负载均衡器(L7负载均衡器)基于开源的Envoy代理。</li></ul></div></div>    
</body>
</html>