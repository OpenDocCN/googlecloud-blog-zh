<html>
<head>
<title>Serverless ETL on Google Cloud, a case study: raw data into JSON Lines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Cloud上的无服务器ETL，案例研究:将原始数据转换成JSON行</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/serverless-etl-on-google-cloud-a-case-study-raw-data-into-json-lines-d20711cd3917?source=collection_archive---------0-----------------------#2020-01-02">https://medium.com/google-cloud/serverless-etl-on-google-cloud-a-case-study-raw-data-into-json-lines-d20711cd3917?source=collection_archive---------0-----------------------#2020-01-02</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="53e9" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">使用Google云存储的云函数和Node.js客户端构建数据处理管道。不需要设置服务器。</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/be39a2af05200fe8ffbdfd5ec33955de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZlhrpO0-78x15ZeVgIU2Q.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><a class="ae jo" href="https://unsplash.com/@ilzelucero?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊尔泽·卢塞罗</a>在<a class="ae jo" href="https://unsplash.com/@ilzelucero?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的背景照片</figcaption></figure><p id="81e8" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我正在做的一项任务是用<strong class="jr hk"> Tomcat </strong>和<strong class="jr hk"> Nginx </strong>访问日志数据填充BigQuery表。每天，web服务器都会向GCS上传新的日志文件，其中包含前24小时的原始数据。数据需要被转换成能够被<a class="ae jo" href="https://cloud.google.com/bigquery/docs/jobs-overview" rel="noopener ugc nofollow" target="_blank"> BigQuery作业</a>理解的格式，以便加载到表中。</p><p id="dc51" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">由于我要处理的数据的性质，我决定将<a class="ae jo" href="http://jsonlines.org/" rel="noopener ugc nofollow" target="_blank"> JSON行</a>或<em class="kl">换行符分隔的JSON </em>作为目标格式，而不是CSV。由于我们无法预测在这个ETL过程中将被转换的数据(例如，URL可以包含几个UTF-8字符，包括逗号)，我决定不依赖逗号作为分隔符来避免问题。</p><p id="25cc" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">因此目标已经确定:<strong class="jr hk">给定web服务器生成的标准访问日志，需要将它们转换成换行符分隔的JSON文件，以便适合BigQuery作业的输入参数。此类作业在数据仓库过程的后期运行。</strong></p><p id="13e3" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">例如，Tomcat日志以通用的日志格式生成:</p><pre class="iz ja jb jc fe km kn ko kp aw kq bi"><span id="e097" class="kr ks hj kn b fj kt ku l kv kw">127.0.0.1 - userid [29/Dec/2019:23:55:27 -0200] "GET /index.html HTTP/1.0" 200 950</span></pre><p id="c8bd" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这意味着:</p><pre class="iz ja jb jc fe km kn ko kp aw kq bi"><span id="4742" class="kr ks hj kn b fj kt ku l kv kw">remoteHost - remoteUser [datetime] "request" httpStatus bytesSent</span></pre><p id="a8a5" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">BigQuery作业需要它们作为JSON行格式的输入:</p><pre class="iz ja jb jc fe km kn ko kp aw kq bi"><span id="95f2" class="kr ks hj kn b fj kt ku l kv kw">{"remoteHost":"127.0.0.1","remoteUser":"userid","datetime":"2019-12-30T01:55:27.000Z","request":"GET /index.html HTTP/1.0","httpStatus":200,"bytesSent":950}</span></pre><p id="05db" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我将在本文中描述我是如何设计和编码一个解决方案来实现这个目标的，这个解决方案使用了云函数和Google云存储的Node.js客户端。<strong class="jr hk">虽然处理访问日志是我的主要目标，但总体策略可能适合更广泛的ETL过程——主要在<em class="kl">转换</em>阶段进行特定的更改。</strong>我将解释这个解决方案，并评论我为解决这个问题而编写的代码中最重要的部分。GitHub上提供了源代码和链接。</p></div><div class="ab cl kx ky gq kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hc hd he hf hg"><h1 id="a972" class="le ks hj bd lf lg lh li lj lk ll lm ln ip lo iq lp is lq it lr iv ls iw lt lu bi translated">架构概述</h1><p id="bac2" class="pw-post-body-paragraph jp jq hj jr b js lv ik ju jv lw in jx jy lx ka kb kc ly ke kf kg lz ki kj kk hc bi translated">请看看下图，它说明了设计的工作流程。使用了两个存储桶，以及两个云功能。</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et ma"><img src="../Images/d32b67d8559459e1ad4272d965644c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_3kGX8BmPFJLWsWaMUf4A.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">架构:Google Cloud上的ETL案例研究——使用云函数和Node.js将原始数据转换成JSON行</figcaption></figure><ol class=""><li id="3fa9" class="mb mc hj jr b js jt jv jw jy md kc me kg mf kk mg mh mi mj bi translated">分配给步骤3的功能在每次新的原始文件上传到分配给步骤2的<em class="kl">源</em>桶时执行。</li><li id="7fe3" class="mb mc hj jr b js mk jv ml jy mm kc mn kg mo kk mg mh mi mj bi translated">这样的执行产生一个JSON Lines格式的文件，该文件被上传到分配给步骤4的<em class="kl">目标</em>桶。</li><li id="db97" class="mb mc hj jr b js mk jv ml jy mm kc mn kg mo kk mg mh mi mj bi translated">然后，分配给步骤5的功能被触发。</li></ol><p id="6dbe" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">由于将JSON Lines格式的文件加载到BigQuery中(步骤5)是一个<a class="ae jo" href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json" rel="noopener ugc nofollow" target="_blank">有良好文档记录的过程</a>，所以本文主要关注原始数据到换行符分隔的JSON转换(步骤3)。</p><p id="3099" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><em class="kl">源</em>存储桶—旨在长期存储—具有<a class="ae jo" href="https://cloud.google.com/storage/docs/storage-classes" rel="noopener ugc nofollow" target="_blank">标准存储类别</a>，但其文件的存储类别在两天后会自动更改为存档，以降低成本。<em class="kl">target</em>bucket——短期存储——也有标准的存储类，但是文件在两天后就会被删除，因为在加载到BigQuery后不再需要它们。</p></div><div class="ab cl kx ky gq kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hc hd he hf hg"><h1 id="d2cd" class="le ks hj bd lf lg lh li lj lk ll lm ln ip lo iq lp is lq it lr iv ls iw lt lu bi translated">提取原始内容</h1><p id="c080" class="pw-post-body-paragraph jp jq hj jr b js lv ik ju jv lw in jx jy lx ka kb kc ly ke kf kg lz ki kj kk hc bi translated">日志文件由几行<strong class="jr hk"> </strong> — <strong class="jr hk"> </strong>组成，每一行代表一个HTTP服务器交付的资源。Google云存储客户端允许我们将给定文件中的所有内容下载到内存中，以供进一步处理，如下所示:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="mp mq l"/></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">使用Node.js从Google云存储中下载一个文件</figcaption></figure><p id="4664" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">当调用中没有参数时，<code class="dv mr ms mt kn b">file.download()</code>返回一个<em class="kl">承诺</em>。<em class="kl"> promise </em>用一个缓冲区数组解析，第一个元素包含所有文件内容。在继续之前，我们需要把它转换成一个字符串。由于日志是用UTF-8编码的，在这种情况下调用<code class="dv mr ms mt kn b">toString()</code>就足够了。</p><p id="1b31" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><strong class="jr hk"> <em class="kl">文件下载提示</em> </strong> <em class="kl"> : </em> <code class="dv mr ms mt kn b"><em class="kl">download()</em></code> <em class="kl">也可以用来将内容保存到本地文件中。</em><a class="ae jo" href="https://googleapis.dev/nodejs/storage/latest/File.html#download" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a><em class="kl">详见单据。</em></p><p id="df57" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><strong class="jr hk"> <em class="kl">流读提示</em> </strong> <em class="kl">:从云存储中读取数据还有第二种选择:</em> <code class="dv mr ms mt kn b"><a class="ae jo" href="https://googleapis.dev/nodejs/storage/latest/File.html#createReadStream" rel="noopener ugc nofollow" target="_blank"><em class="kl">createReadStream()</em></a></code> <em class="kl">。如果您有要在流管道上处理的数据，您可以尝试一下。</em></p></div><div class="ab cl kx ky gq kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hc hd he hf hg"><h1 id="49d9" class="le ks hj bd lf lg lh li lj lk ll lm ln ip lo iq lp is lq it lr iv ls iw lt lu bi translated">转换原始内容</h1><p id="b88d" class="pw-post-body-paragraph jp jq hj jr b js lv ik ju jv lw in jx jy lx ka kb kc ly ke kf kg lz ki kj kk hc bi translated">我处理这个问题的第一步是开发一个javascript函数，将原始日志行转换成JSON对象。基本上，它使用一个正则表达式来分解值，并将它们分配给JSON对象的属性。源代码可以在<a class="ae jo" href="https://github.com/ricardolsmendes/tomcat-access-log-js-parser/blob/master/src/tomcat-access-log-parser.js" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="b3a7" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><em class="kl">请注意，该函数返回一个JSON字符串，而不是一个JSON对象。这是预期的行为，因此可以对代码进行</em> <a class="ae jo" href="https://github.com/ricardolsmendes/tomcat-access-log-js-parser/blob/master/fallback/tomcat-access-log-parser-nashorn.js" rel="noopener ugc nofollow" target="_blank"> <em class="kl">调整</em> </a> <em class="kl">，以使用</em> <a class="ae jo" href="https://cloud.google.com/dataflow/docs/guides/templates/provided-batch#gcstexttobigquery" rel="noopener ugc nofollow" target="_blank"> <em class="kl">云数据流的存储文本到BigQuery模板</em> </a> <em class="kl">运行等效的批处理ETL流程。</em></p><p id="bba2" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在，让我们看看ETL代码的另一个重要部分:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="mp mq l"/></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">使用javascript将JSON对象转换成换行符分隔的JSON</figcaption></figure><p id="2cd8" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">借助正则表达式，将先前下载的原始内容拆分成一个字符串数组也很简单。</p><p id="601e" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">每个元素都意味着一个需要转换成换行符分隔的JSON的日志条目。我使用了<a class="ae jo" href="https://github.com/maxogden/ndjson" rel="noopener ugc nofollow" target="_blank"> ndjson库</a>来帮助解决这个问题。<code class="dv mr ms mt kn b">ndjson.serialize()</code>返回一个接受JSON对象并发出换行符分隔的JSON的<a class="ae jo" href="https://nodejs.org/api/stream.html#stream_implementing_a_transform_stream" rel="noopener ugc nofollow" target="_blank">转换流</a>。转换工作完成了！</p><p id="f798" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated"><strong class="jr hk"> <em class="kl">直通流提示:</em> </strong> <em class="kl">您可以使用不返回流的转换函数。但是，由于在下一步中拥有一个非常有用，请考虑在继续之前使用内置的类</em> <code class="dv mr ms mt kn b"><em class="kl">stream.PassThrough</em></code> <em class="kl">对转换后的数据进行装箱。</em></p><blockquote class="mu mv mw"><p id="f082" class="jp jq kl jr b js jt ik ju jv jw in jx mx jz ka kb my kd ke kf mz kh ki kj kk hc bi translated">等等，等等！你用过的那个 <code class="dv mr ms mt kn b"><em class="hj">LogParser</em></code> <em class="hj">级是什么？</em></p><p id="a9e9" class="jp jq kl jr b js jt ik ju jv jw in jx mx jz ka kb my kd ke kf mz kh ki kj kk hc bi translated"><em class="hj"> —好问题！它只是将原始日志行转换成JSON对象的函数的高级抽象，这一点在本节开始时已经提到。源代码可用</em> <a class="ae jo" href="https://github.com/ricardolsmendes/access-logs-js-parser/blob/master/src/log-parser.js" rel="noopener ugc nofollow" target="_blank"> <em class="hj">此处</em> </a> <em class="hj">。</em></p></blockquote></div><div class="ab cl kx ky gq kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hc hd he hf hg"><h1 id="1fe5" class="le ks hj bd lf lg lh li lj lk ll lm ln ip lo iq lp is lq it lr iv ls iw lt lu bi translated">加载JSON行内容</h1><p id="f01c" class="pw-post-body-paragraph jp jq hj jr b js lv ik ju jv lw in jx jy lx ka kb kc ly ke kf kg lz ki kj kk hc bi translated">第三步也是最后一步非常简单:将转换后的内容存储到一个新文件中。</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="mp mq l"/></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">使用Node.js将文件上传到Google云存储</figcaption></figure><p id="7f91" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">一旦我们在流中有了可用的JSON行，我们需要做的就是读取这样的数据，然后写入GCS文件。</p><p id="cbbe" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">云存储客户端自带<code class="dv mr ms mt kn b"><a class="ae jo" href="https://googleapis.dev/nodejs/storage/latest/File.html#createWriteStream" rel="noopener ugc nofollow" target="_blank">file.createWriteStream()</a></code>方法。顾名思义，它创建一个流来将内容写入GCS文件。作为一个流，它可以嵌套到<code class="dv mr ms mt kn b">ndjsonStream</code>，如上面的代码片段所示。由于写文件是异步的，将<code class="dv mr ms mt kn b">pipe()</code>调用包含在<em class="kl"> promise </em>范围内可能有助于云函数在进程结束时正确返回，所以我推荐这样做。</p><p id="8bf8" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">请注意<code class="dv mr ms mt kn b">createWriteStream()</code>接受多个<a class="ae jo" href="https://googleapis.dev/nodejs/storage/latest/global.html#CreateWriteStreamOptions" rel="noopener ugc nofollow" target="_blank">选项</a>。我使用了<code class="dv mr ms mt kn b">resumable: false</code>,因为我希望目标文件一次完全上传。<a class="ae jo" href="https://googleapis.dev/nodejs/storage/latest/File.html#createWriteStream" rel="noopener ugc nofollow" target="_blank">鉴于它们的大小通常小于10MB，该选项使它们上传的性能更好</a>。</p></div><div class="ab cl kx ky gq kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hc hd he hf hg"><h1 id="c767" class="le ks hj bd lf lg lh li lj lk ll lm ln ip lo iq lp is lq it lr iv ls iw lt lu bi translated">结束语</h1><p id="2b67" class="pw-post-body-paragraph jp jq hj jr b js lv ik ju jv lw in jx jy lx ka kb kc ly ke kf kg lz ki kj kk hc bi translated">本文描述的步骤旨在实现一个由GCP云函数和Javascript支持的无服务器ETL工作流。在这个过程的最后，使用第二个云函数将转换后的数据上传到BigQuery，如<a class="ae jo" href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json" rel="noopener ugc nofollow" target="_blank">https://Cloud . Google . com/big query/docs/loading-data-Cloud-storage-JSON</a>中所述。</p><p id="9818" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">关于性能:一个256MB内存的云函数实例平均需要8秒来处理一个1MB的文件(大约9000个日志条目)。在这种情况下，正如我所注意到的，大部分处理时间都被网络操作占用了。</p><p id="d25b" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">我希望这篇文章能帮助有类似需求的开发人员和数据工程师设计他们自己的过程，通过调整或改进我到目前为止所做的工作。</p><p id="570b" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">参考代码在GitHub上有:<a class="ae jo" href="https://github.com/ricardolsmendes/access-logs-dw-gcp-js" rel="noopener ugc nofollow" target="_blank">https://github.com/ricardolsmendes/access-logs-dw-gcp-js</a>(src/raw-to-nd JSON-GCS-file-converter . js)。使用它的云函数驻留在<a class="ae jo" href="https://github.com/ricardolsmendes/access-logs-ndjson-gcs-gcf" rel="noopener ugc nofollow" target="_blank">https://github . com/ricardolsmendes/access-logs-nd JSON-GCS-GCF</a>。</p><p id="140c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">2020快乐，仅此而已；)</p></div><div class="ab cl kx ky gq kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hc hd he hf hg"><h2 id="fc08" class="kr ks hj bd lf na nb nc lj nd ne nf ln jy ng nh lp kc ni nj lr kg nk nl lt nm bi translated">参考</h2><ul class=""><li id="66f3" class="mb mc hj jr b js lv jv lw jy nn kc no kg np kk nq mh mi mj bi translated"><strong class="jr hk">谷歌云功能&gt;存储触发</strong>:【https://cloud.google.com/functions/docs/calling/storage】T2</li><li id="1dfa" class="mb mc hj jr b js mk jv ml jy mm kc mn kg mo kk nq mh mi mj bi translated">【https://googleapis.dev/nodejs/storage/latest】Google云存储Node.js客户端API引用:<a class="ae jo" href="https://googleapis.dev/nodejs/storage/latest" rel="noopener ugc nofollow" target="_blank">T4</a></li><li id="d14b" class="mb mc hj jr b js mk jv ml jy mm kc mn kg mo kk nq mh mi mj bi translated"><strong class="jr hk">谷歌云存储的Node.js客户端</strong>:<a class="ae jo" href="https://github.com/googleapis/nodejs-storage" rel="noopener ugc nofollow" target="_blank">https://github.com/googleapis/nodejs-storage</a></li></ul></div></div>    
</body>
</html>