<html>
<head>
<title>BigQuery Explained: Working with Joins, Nested &amp; Repeated Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery解释:使用连接、嵌套和重复数据</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-explained-working-with-joins-nested-repeated-data-1941646ccb5b?source=collection_archive---------0-----------------------#2020-09-30">https://medium.com/google-cloud/bigquery-explained-working-with-joins-nested-repeated-data-1941646ccb5b?source=collection_archive---------0-----------------------#2020-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><blockquote class="im in io"><p id="ce71" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在谷歌云博客上关注BigQuery解释系列<a class="ae jo" href="https://cloud.google.com/blog/topics/developers-practitioners/bigquery-explained-blog-series" rel="noopener ugc nofollow" target="_blank">。有问题或者想聊天？在</a><a class="ae jo" href="https://twitter.com/rajesh_thallam" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae jo" href="https://www.linkedin.com/in/rajeshthallam/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系。</p></blockquote></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="639f" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在BigQuery解释系列文章的<a class="ae jo" rel="noopener" href="/google-cloud/bigquery-explained-querying-your-data-9e017f2714a3">中，我们研究了使用SQL在BigQuery中查询数据集，如何保存和共享查询，以及管理标准视图和物化视图。在本帖中，我们将重点关注嵌套和重复字段的连接和数据反规范化。让我们开始吧！</a></p><h1 id="ba9f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">连接</h1><p id="4b26" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">通常，数据仓库模式遵循一个<a class="ae jo" href="https://en.wikipedia.org/wiki/Star_schema" rel="noopener ugc nofollow" target="_blank">星形</a>或<a class="ae jo" href="https://en.wikipedia.org/wiki/Snowflake_schema" rel="noopener ugc nofollow" target="_blank">雪花形</a>模式，其中一个包含事件的集中式“事实”表被称为“维度”的附属表包围，这些附属表具有与事实表相关的描述性属性。事实表被<a class="ae jo" href="https://en.wikipedia.org/wiki/Denormalization" rel="noopener ugc nofollow" target="_blank">反规范化</a>，维度表被<a class="ae jo" href="https://en.wikipedia.org/wiki/Database_normalization" rel="noopener ugc nofollow" target="_blank">规范化</a>。星型模式<a class="ae jo" href="https://en.wikipedia.org/wiki/Star_schema#Benefits" rel="noopener ugc nofollow" target="_blank">支持数据仓库中的</a>分析查询，允许在连接数量有限的情况下运行更简单的查询，执行更快的聚合并提高查询性能。</p><p id="190c" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">这与在线事务处理系统(OLTP)形成对比，在OLTP中，模式是高度规范化的，并且广泛地执行连接来获得结果。数据仓库中的大多数分析查询仍然需要执行连接操作来将事实数据与维度属性或另一个事实表相结合。</p><p id="88c9" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们看看BigQuery中的连接是如何工作的。BigQuery支持ANSI SQL联接类型。根据<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#on_clause" rel="noopener ugc nofollow" target="_blank">连接条件</a>和<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#join_types" rel="noopener ugc nofollow" target="_blank">连接类型</a>对两个项目进行连接操作。<code class="du kv kw kx ky b">JOIN</code>操作中的项可以是大查询表、<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/subqueries" rel="noopener ugc nofollow" target="_blank">子查询</a>、<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#with_clause" rel="noopener ugc nofollow" target="_blank">WITH</a></code>语句或<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays" rel="noopener ugc nofollow" target="_blank">ARRAYs</a></code>(具有零个或多个相同数据类型值的有序列表)。</p><p id="f938" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">BigQuery支持以下<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#join_types" rel="noopener ugc nofollow" target="_blank">连接类型</a>:</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/798fbe3befd1c85c0244b773e1a8cbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*88k-osm6sNig_ITJ"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">BigQuery联接类型</figcaption></figure><p id="4c7a" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们来看一个零售商店的示例数据仓库模式，如下所示。顶部有零售交易的原始数据表被转换为数据仓库模式，订单详细信息存储在一个<code class="du kv kw kx ky b"><strong class="is hj">Transactions</strong></code>事实表中，而<code class="du kv kw kx ky b"><strong class="is hj">Product</strong></code>和<code class="du kv kw kx ky b"><strong class="is hj">Customer</strong></code>信息作为维度表。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lp"><img src="../Images/bb2792be321ab8ca096c0db0dcba9a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SVafEFeMH1w_1uRcevhdQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">零售店的数据仓库模式</figcaption></figure><p id="c124" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">为了找出每个客户在一个月里花了多少钱，您可以在<code class="du kv kw kx ky b"><strong class="is hj">Transactions</strong></code>事实表和<code class="du kv kw kx ky b"><strong class="is hj">Customer</strong></code>维度表之间执行<code class="du kv kw kx ky b">OUTER JOIN</code>来获得结果。我们将使用<code class="du kv kw kx ky b">WITH</code>子句动态生成示例交易和客户数据，并查看<code class="du kv kw kx ky b">JOIN</code>的运行情况。运行以下查询:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="18dd" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">使用<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#with-clause" rel="noopener ugc nofollow" target="_blank">WITH</a></code>子句允许命名子查询并在后续查询中使用它，例如这里的<code class="du kv kw kx ky b">SELECT</code>语句(也称为<a class="ae jo" href="https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL#Common_table_expression" rel="noopener ugc nofollow" target="_blank">公共表表达式</a>)。我们使用<code class="du kv kw kx ky b">Customer</code>和<code class="du kv kw kx ky b">Transactions</code>之间的<code class="du kv kw kx ky b">RIGHT OUTER JOIN</code>来获得所有客户及其总消费的列表。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ls"><img src="../Images/fd4c46588a36702936671a268fd0e75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/0*eP4agzrAl2Y2hz8F"/></div></figure><p id="ebad" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj">注意</strong><em class="ir">:</em><code class="du kv kw kx ky b">WITH</code>子句主要用于可读性，因为它们没有具体化。如果一个查询出现在多个<code class="du kv kw kx ky b">WITH</code>子句中，它将在每个子句中执行。</p><h2 id="3b63" class="lt jt hi bd ju lu lv lw jy lx ly lz kc jp ma mb kg jq mc md kk jr me mf ko mg bi translated">优化连接模式</h2><blockquote class="im in io"><p id="0f08" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">广播加入</strong></p></blockquote><ul class=""><li id="b8af" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">当将一个大表连接到一个小表时，BigQuery创建一个广播连接，其中小表被发送到处理大表的每个槽。</li><li id="0bef" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">尽管SQL查询优化器可以确定哪个表应该位于连接的哪一侧，但是建议对连接的表进行适当的排序。最佳实践是首先放置最大的表，其次是最小的表，然后依次减小大小。</li></ul><blockquote class="im in io"><p id="c7aa" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">散列连接</strong></p></blockquote><ul class=""><li id="f663" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">当连接两个大表时，BigQuery使用hash和shuffle操作来混合左表和右表，以便匹配的键在同一个槽中结束，从而执行本地连接。这是一个昂贵的操作，因为需要移动数据。</li><li id="7b51" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">在某些情况下，群集可能会加快散列连接的速度。正如在<a class="ae jo" rel="noopener" href="/google-cloud/bigquery-explained-storage-overview-70cac32251fa#1539">上一篇文章</a>中提到的，集群倾向于将数据放在同一个列文件中，从而提高混排数据的整体效率，尤其是在查询执行计划中有一些预聚合部分的情况下。</li></ul><blockquote class="im in io"><p id="094f" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">自加入</strong></p></blockquote><ul class=""><li id="e64e" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">在自联接中，表与其自身相联接。这通常是一个SQL反模式，对于大型表来说，这可能是一个开销很大的操作，并且可能需要不止一次地获取数据。</li><li id="6373" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">相反，建议避免自连接，而是使用<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/analytic-function-concepts" rel="noopener ugc nofollow" target="_blank">分析(窗口)函数</a>来减少查询产生的字节。</li></ul><blockquote class="im in io"><p id="6ec5" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">交叉连接</strong></p></blockquote><ul class=""><li id="a14d" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Join_(SQL)#Cross_join" rel="noopener ugc nofollow" target="_blank">交叉连接</a>是一种SQL反模式，会导致严重的性能问题，因为它们生成的输出数据比输入数据大，在某些情况下查询可能永远不会完成。</li><li id="2416" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">为了避免交叉连接的性能问题，请使用聚合函数来预聚合数据，或者使用通常比交叉连接性能更好的分析函数。</li></ul><blockquote class="im in io"><p id="e7f4" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">倾斜连接</strong></p></blockquote><ul class=""><li id="ee3b" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">当表中的数据被划分为大小不等的分区时，可能会发生数据倾斜。当连接需要混洗数据的大型表时，偏斜会导致插槽之间发送的数据量极度不平衡。</li><li id="b365" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">为了避免与偏斜联接(或不平衡联接)相关的性能问题，请尽可能早地预筛选表中的数据，或者将查询拆分为两个或多个查询。</li></ul><p id="08cd" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ir">参考big query</em></strong><a class="ae jo" href="https://cloud.google.com/bigquery/docs/best-practices-performance-patterns" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="ir">最佳实践</em> </strong> </a> <strong class="is hj"> <em class="ir">文档，了解更多此类优化查询性能的建议。</em> </strong></p><h1 id="e5fc" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">具有嵌套和重复结构的非规范化数据</h1><p id="8ec9" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">当对部分规范化的模式(如数据仓库中的星型或雪花型模式)执行分析操作时，必须连接多个表才能执行所需的聚合。但是，连接的性能通常不如非规范化结构。查询性能<a class="ae jo" href="https://cloud.google.com/solutions/bigquery-data-warehouse#denormalization" rel="noopener ugc nofollow" target="_blank">显示</a>在存在连接的情况下会有更急剧的下降。</p><p id="8453" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">非规范化数据的传统方法包括将一个事实及其所有维度写入一个扁平结构。相比之下，反规范化数据的首选方法是利用BigQuery对JSON或Avro输入数据中的<a class="ae jo" href="https://cloud.google.com/bigquery/docs/nested-repeated" rel="noopener ugc nofollow" target="_blank">嵌套和重复</a>结构的本机支持。使用嵌套和重复的结构来表示记录可以提供更自然的底层数据表示。</p><p id="4919" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">继续使用零售商店的相同数据仓库模式，以下是需要注意的关键事项:</p><ul class=""><li id="8742" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated"><code class="du kv kw kx ky b">Transactions</code>中的一个订单属于单个<code class="du kv kw kx ky b">Customer</code>并且</li><li id="1818" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated"><code class="du kv kw kx ky b">Transactions</code>中的一个订单可以有多个<code class="du kv kw kx ky b">Product</code>(或项目)。</li></ul><p id="bc5e" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">前面，我们看到这个模式被组织到多个表中。另一种方法是使用嵌套和重复的字段将所有信息组织在一个表中。</p><h2 id="e2cb" class="lt jt hi bd ju lu lv lw jy lx ly lz kc jp ma mb kg jq mc md kk jr me mf ko mg bi translated">嵌套和重复字段的初级读本</h2><p id="b213" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">BigQuery支持从支持基于对象的模式的源格式加载嵌套和重复的数据，如JSON、Avro、Firestore和Datastore导出文件。<code class="du kv kw kx ky b"><strong class="is hj">ARRAY</strong></code><code class="du kv kw kx ky b"><strong class="is hj">STRUCT</strong></code><strong class="is hj"/>或<strong class="is hj"> </strong> <code class="du kv kw kx ky b"><strong class="is hj">RECORD</strong></code> <strong class="is hj"> </strong>是复杂的数据类型，用来表示嵌套和重复的字段。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mv"><img src="../Images/8979604fa9564192e6117e8e79123b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjjsm5_ObzKkEcVbz449jg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">BigQuery嵌套和重复字段</figcaption></figure><blockquote class="im in io"><p id="1d75" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">嵌套字段</em> </strong></p></blockquote><ul class=""><li id="68fb" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">一个<code class="du kv kw kx ky b"><strong class="is hj">STRUCT</strong></code> <strong class="is hj">或</strong> <code class="du kv kw kx ky b"><strong class="is hj">RECORD</strong></code>包含有序字段，每个字段都有类型和字段名。您可以将一个或多个子列定义为<code class="du kv kw kx ky b">STRUCT</code>类型，称为嵌套<code class="du kv kw kx ky b">STRUCT</code> s ( <a class="ae jo" href="https://cloud.google.com/bigquery/docs/nested-repeated#limitations" rel="noopener ugc nofollow" target="_blank"> <em class="ir">到15层嵌套</em> </a>)。</li><li id="8761" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">让我们把<code class="du kv kw kx ky b">Transactions</code>和<code class="du kv kw kx ky b">Customer</code>数据放入嵌套结构中。注意<code class="du kv kw kx ky b">Transactions</code>中的一个订单属于一个<code class="du kv kw kx ky b">Customer</code>。这可以表示为下面的模式:</li></ul><pre class="la lb lc ld fd mw ky mx my aw mz bi"><span id="c9a6" class="lt jt hi ky b fi na nb l nc nd">[<br/>  {"name": "id", "type": "INTEGER", "mode": "REQUIRED"},<br/>  {"name": "time", "type": "TIMESTAMP", "mode": "REQUIRED"},<br/>  {"name": "customer", "type": "<strong class="ky hj">RECORD</strong>", "fields":<br/>    [<br/>      {"name": "id", "type": "INTEGER", "mode": "REQUIRED"},<br/>      {"name": "name",  "type": "STRING", "mode": "REQUIRED"},<br/>      {"name": "location",  "type": "STRING"}<br/>    ]<br/>  }<br/>]</span></pre><ul class=""><li id="ae0e" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">注意<code class="du kv kw kx ky b">customer</code>列属于<code class="du kv kw kx ky b">RECORD</code>类型，有序字段与<code class="du kv kw kx ky b">Transactions</code>字段— <code class="du kv kw kx ky b">id</code>和<code class="du kv kw kx ky b">time</code>一起嵌套在主模式中。</li><li id="532b" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">BigQuery在查询时自动展平嵌套字段。若要查询包含嵌套数据的列，每个字段都必须在包含它的列的上下文中进行标识。例如:<code class="du kv kw kx ky b">customer.id </code>是指<code class="du kv kw kx ky b">customer</code>列中的<code class="du kv kw kx ky b">id</code>字段。</li></ul><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lq lr l"/></div></figure><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ne"><img src="../Images/c6de5bbcc7cac1635e0ec3787e4d842a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*MAyDC3ovsCeMZAqk"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">嵌套字段</figcaption></figure><blockquote class="im in io"><p id="da65" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">重复字段</em> </strong></p></blockquote><ul class=""><li id="607e" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">一个<code class="du kv kw kx ky b"><strong class="is hj">ARRAY</strong></code>是相同数据类型的零个或多个元素的有序列表。不支持数组的数组。重复字段在单个字段或<code class="du kv kw kx ky b">RECORD</code>中添加一组数据。</li><li id="4118" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">我们来考虑一下<code class="du kv kw kx ky b">Transactions</code>和<code class="du kv kw kx ky b">Product</code>的数据。<code class="du kv kw kx ky b">Transactions</code>中的一个订单可以有多个<code class="du kv kw kx ky b">Product</code>(或项目)。当将列<code class="du kv kw kx ky b">Product</code>指定为模式中的重复字段时，可以将<code class="du kv kw kx ky b"><strong class="is hj">product</strong></code>列的模式定义为<code class="du kv kw kx ky b"><strong class="is hj">REPEATED</strong></code>。具有重复字段的模式如下所示:</li></ul><pre class="la lb lc ld fd mw ky mx my aw mz bi"><span id="260e" class="lt jt hi ky b fi na nb l nc nd">[<br/>  {"name": "id", "type": "INTEGER", "mode": "REQUIRED"},<br/>  {"name": "time", "type": "TIMESTAMP", "mode": "REQUIRED"},<br/>  {"name": "product", "type": "RECORD", "mode": "<strong class="ky hj">REPEATED</strong>", "fields":<br/>    [<br/>      {"name": "sku", "type": "STRING", "mode": "REQUIRED"},<br/>      {"name": "description",  "type": "STRING"},<br/>      {"name": "quantity",  "type": "INTEGER"},<br/>      {"name": "price",  "type": "FLOAT", "mode": "REQUIRED"}<br/>    ]<br/>  }<br/>]</span></pre><ul class=""><li id="1e36" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">重复字段中的每个条目都是一个<code class="du kv kw kx ky b">ARRAY</code>。例如，订单的<code class="du kv kw kx ky b">product</code>列中的每一项都是具有<code class="du kv kw kx ky b">sku</code>、<code class="du kv kw kx ky b">description</code>、<code class="du kv kw kx ky b">quantity</code>和<code class="du kv kw kx ky b">price</code>字段的<code class="du kv kw kx ky b">STRUCT</code>或<code class="du kv kw kx ky b">RECORD</code>类型。</li><li id="1520" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">当查询一个或多个重复字段时，BigQuery自动按“行”对数据进行分组。</li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es nf"><img src="../Images/9fea07d712461f775db74f68f83a7637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nFCmkYt5YbBkLXkQ"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">重复字段</figcaption></figure><ul class=""><li id="ce2a" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">为了展平重复的(和分组的)数据，您将使用带有重复列名称的<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#unnest" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">UNNEST()</strong></a></code>函数。只能在<code class="du kv kw kx ky b">FROM</code>子句或<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/operators#in_operators" rel="noopener ugc nofollow" target="_blank">IN</a></code>T21运算符中使用<code class="du kv kw kx ky b"><strong class="is hj">UNNEST</strong></code>函数。</li></ul><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lq lr l"/></div></figure><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ng"><img src="../Images/64c0130c87f19bd0a78203c9bf1653f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/0*ERS0YYF1iItKMpEb"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">使用UNNEST()展平嵌套元素</figcaption></figure><p id="7988" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ir">阅读更多关于处理</em> </strong> <code class="du kv kw kx ky b"><strong class="is hj">ARRAY</strong></code> <strong class="is hj"> <em class="ir"> s和</em></strong><strong class="is hj"><em class="ir">s</em></strong><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="ir">这里</em> </strong> </a> <strong class="is hj"> <em class="ir">。</em>T44】</strong></p><h2 id="e516" class="lt jt hi bd ju lu lv lw jy lx ly lz kc jp ma mb kg jq mc md kk jr me mf ko mg bi translated">具有嵌套重复字段的非规范化模式</h2><p id="45e7" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">让我们把所有这些放在一起，看看在单个表中组合了嵌套和重复元素以及<code class="du kv kw kx ky b">Customer</code>和<code class="du kv kw kx ky b">Product</code>信息的<code class="du kv kw kx ky b">Transactions</code>模式的另一种表示。该模式表示如下:</p><pre class="la lb lc ld fd mw ky mx my aw mz bi"><span id="2bae" class="lt jt hi ky b fi na nb l nc nd">[<br/>  {"name": "id", "type": "INTEGER", "mode": "REQUIRED"},<br/>  {"name": "time", "type": "TIMESTAMP", "mode": "REQUIRED"},<br/>  {"name": "customer", "type": "<strong class="ky hj">RECORD</strong>", "fields":<br/>    [<br/>      {"name": "id", "type": "INTEGER", "mode": "REQUIRED"},<br/>      {"name": "name",  "type": "STRING", "mode": "REQUIRED"},<br/>      {"name": "location",  "type": "STRING"}<br/>    ]<br/>  },<br/>  {"name": "product", "type": "RECORD", "mode": "<strong class="ky hj">REPEATED</strong>", "fields":<br/>      [<br/>        {"name": "sku", "type": "STRING", "mode": "REQUIRED"},<br/>        {"name": "description",  "type": "STRING"},<br/>        {"name": "quantity",  "type": "INTEGER"},<br/>        {"name": "price",  "type": "FLOAT", "mode": "REQUIRED"}<br/>      ]<br/>    }<br/>]</span></pre><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es nh"><img src="../Images/5f130c766fbf566a39e905422ef138e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MKZPdw_LKVoVtB_j-nMSA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">零售店的非规范化模式——另一种表示法</figcaption></figure><p id="d6d3" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在<code class="du kv kw kx ky b"><strong class="is hj">Transactions</strong></code>表中，外部包含<code class="du kv kw kx ky b"><strong class="is hj">order</strong></code>和<code class="du kv kw kx ky b"><strong class="is hj">customer</strong></code>信息，内部包含<code class="du kv kw kx ky b"><strong class="is hj">order</strong></code>的行项目，它们被表示为嵌套的、重复的元素。通过使用嵌套和重复的字段来表达记录简化了使用JSON或Avro 文件的<a class="ae jo" href="https://cloud.google.com/bigquery/docs/nested-repeated" rel="noopener ugc nofollow" target="_blank">数据加载。在创建了这样一个模式之后，您可以使用点符号对任何单个字段执行<code class="du kv kw kx ky b">SELECT</code>、<code class="du kv kw kx ky b">INSERT</code>、<code class="du kv kw kx ky b">UPDATE</code>和<code class="du kv kw kx ky b">DELETE</code>操作，例如<code class="du kv kw kx ky b">Order.sku</code>。</a></p><p id="d53b" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">我们将再次动态生成交易数据，并在具有嵌套和重复字段的<code class="du kv kw kx ky b"><strong class="is hj">Transactions</strong></code>模式上运行该查询，以查找订单上的总购买量以及客户姓名。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="a628" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">让我们解开这个查询，了解数据是如何反规范化的。</p><blockquote class="im in io"><p id="378d" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">非规格化数据表示</em> </strong></p></blockquote><ul class=""><li id="6e7e" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">使用<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#with-clause" rel="noopener ugc nofollow" target="_blank">WITH</a></code>语句生成交易数据，每一行由<code class="du kv kw kx ky b"><strong class="is hj">order</strong></code>信息、<code class="du kv kw kx ky b"><strong class="is hj">customer</strong></code>信息和一个嵌套字段组成，该嵌套字段包含表示为代表— <code class="du kv kw kx ky b">sku</code>、<code class="du kv kw kx ky b">quantity</code>和<code class="du kv kw kx ky b">price</code>的<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#struct-type" rel="noopener ugc nofollow" target="_blank">STRUCT</a></code>的一个<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#array-type" rel="noopener ugc nofollow" target="_blank">ARRAY</a></code>的各个项目。</li><li id="5e8e" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">使用<code class="du kv kw kx ky b">STRUCTs</code>的<code class="du kv kw kx ky b">ARRAY</code>，我们通过避免表<code class="du kv kw kx ky b">JOIN</code>获得了显著的性能优势。<code class="du kv kw kx ky b">STRUCT</code>的<code class="du kv kw kx ky b">ARRAY</code>可以被视为保留数据结构的预连接表。嵌套记录中的单个元素只能在需要时检索。与管理<code class="du kv kw kx ky b">JOIN</code>键和相关表相比，将所有业务上下文放在一个表中还有额外的好处。</li></ul><blockquote class="im in io"><p id="e5a7" class="ip iq ir is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">归一化数据用于分析</em> </strong></p></blockquote><ul class=""><li id="a3bc" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">在<code class="du kv kw kx ky b">SELECT</code>查询中，我们使用<code class="du kv kw kx ky b"><a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#unnest" rel="noopener ugc nofollow" target="_blank">UNNEST()</a></code>函数和点符号从嵌套记录中读取字段，如<code class="du kv kw kx ky b">price</code>。例如<code class="du kv kw kx ky b">orders.price</code></li><li id="d70e" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated"><code class="du kv kw kx ky b">UNNEST()</code>帮助将数组元素放回到行中</li><li id="7658" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated"><code class="du kv kw kx ky b">UNNEST()</code>总是跟在<code class="du kv kw kx ky b">FROM</code>子句中的表名后面(概念上类似于预连接的表)</li></ul><p id="30e4" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">运行上面的查询将返回包含订单、客户和订单总额的结果。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ni"><img src="../Images/cf2c9f2e38ddd6d79d93bcf9eecc4a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*wr6I7OXowsDgB59hMaiq8Q.png"/></div></figure><h2 id="b12e" class="lt jt hi bd ju lu lv lw jy lx ly lz kc jp ma mb kg jq mc md kk jr me mf ko mg bi translated">设计非规范化模式的准则</h2><p id="c801" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">以下是<a class="ae jo" href="https://cloud.google.com/solutions/bigquery-data-warehouse#designing_schema" rel="noopener ugc nofollow" target="_blank">在BigQuery中设计非规范化模式</a>的一般准则:</p><ul class=""><li id="0328" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">对大于10GB的维度表进行反规范化，除非有强有力的证据表明数据操作(如<code class="du kv kw kx ky b">UPDATE</code>和<code class="du kv kw kx ky b">DELETE</code>操作)的成本超过了优化查询的好处。</li><li id="69b3" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">保持小于10GB的维度表规范化，除非该表很少经过<code class="du kv kw kx ky b">UPDATE</code>和<code class="du kv kw kx ky b">DELETE</code>操作。</li><li id="6c38" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">充分利用非规范化表中的<a class="ae jo" href="https://cloud.google.com/bigquery/docs/nested-repeated" rel="noopener ugc nofollow" target="_blank">嵌套和重复字段</a>。</li></ul><p id="4e55" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ir">参考这篇</em> </strong> <a class="ae jo" href="https://cloud.google.com/solutions/bigquery-data-warehouse#designing_schema" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="ir">文章</em> </strong> </a> <strong class="is hj"> <em class="ir">了解更多关于数据仓库中非规范化和设计模式的信息。</em> </strong></p><h1 id="55be" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">接下来呢？</h1><p id="2ce7" class="pw-post-body-paragraph ip iq hi is b it kq iv iw ix kr iz ja jp ks jd je jq kt jh ji jr ku jl jm jn hb bi translated">在这篇文章中，我们使用了连接，回顾了优化连接模式和使用嵌套和重复字段的反规范化数据。</p><ul class=""><li id="a497" class="mh mi hi is b it iu ix iy jp mj jq mk jr ml jn mm mn mo mp bi translated">在BigQuery中使用<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#join_types" rel="noopener ugc nofollow" target="_blank">连接</a></li><li id="8387" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">在BigQuery中使用<a class="ae jo" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/analytic-function-concepts" rel="noopener ugc nofollow" target="_blank">分析(窗口)函数</a></li><li id="c56e" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">在BigQuery [ <a class="ae jo" href="https://www.youtube.com/watch?v=3TVeG_dpGxk" rel="noopener ugc nofollow" target="_blank">视频</a> ] [ <a class="ae jo" href="https://cloud.google.com/bigquery/docs/nested-repeated" rel="noopener ugc nofollow" target="_blank">文档</a>中处理嵌套和重复的数据</li><li id="10ea" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated">BigQuery <a class="ae jo" href="https://cloud.google.com/bigquery/docs/best-practices-performance-overview" rel="noopener ugc nofollow" target="_blank">查询性能的最佳实践</a>包括连接等等</li><li id="4e93" class="mh mi hi is b it mq ix mr jp ms jq mt jr mu jn mm mn mo mp bi translated"><a class="ae jo" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/courses/data-engineering/demos/nested.md" rel="noopener ugc nofollow" target="_blank">在您的<a class="ae jo" href="https://cloud.google.com/bigquery/docs/sandbox" rel="noopener ugc nofollow" target="_blank"> BigQuery沙箱</a>上查询带有嵌套和重复字段的BigQuery公共数据集</a>——<em class="ir">感谢</em> <a class="ae jo" href="https://github.com/jonesevan" rel="noopener ugc nofollow" target="_blank"> <em class="ir">伊万·琼斯</em> </a> <em class="ir">的演示</em>！(<em class="ir"> Codelab即将推出！</em>)</li></ul><p id="d2cc" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">在下一篇文章中，我们将看到BigQuery中的数据操作以及脚本、存储过程等等。</p><p id="d04d" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">敬请关注。感谢您的阅读！有问题或者想聊天？在<a class="ae jo" href="https://twitter.com/rajesh_thallam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae jo" href="https://www.linkedin.com/in/rajeshthallam/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p><p id="fe34" class="pw-post-body-paragraph ip iq hi is b it iu iv iw ix iy iz ja jp jc jd je jq jg jh ji jr jk jl jm jn hb bi translated">感谢艾丽西娅·威廉姆斯对这篇文章的帮助。</p></div></div>    
</body>
</html>