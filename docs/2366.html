<html>
<head>
<title>Developing a Serverless Web Application Completely on Google Cloud (2 of 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完全在Google Cloud上开发无服务器的Web应用程序(第2页，共2页)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/developing-a-serverless-web-application-completely-on-google-cloud-2-of-2-dd523e768791?source=collection_archive---------5-----------------------#2022-09-16">https://medium.com/google-cloud/developing-a-serverless-web-application-completely-on-google-cloud-2-of-2-dd523e768791?source=collection_archive---------5-----------------------#2022-09-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b4e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不用下载任何东西，用Firebase和NodeJS构建一个无服务器的web应用程序！</p><p id="ef4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗨！欢迎回来。我们现在将探索如何在Google Cloud上使用<strong class="ih hj">云存储</strong>、<strong class="ih hj"> Firebase </strong>、<strong class="ih hj">应用引擎</strong>和<strong class="ih hj">云功能</strong>！</p><h1 id="3b0f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据库和存储</h1><h2 id="2015" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">以原生模式和云存储上传到Firestore</h2><p id="bad2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">您的应用程序仅通过验证是不完整的。让我们让应用程序与内容和更多功能更具交互性。我们将创建一个帖子页，用户可以张贴带标题的图片。为了存储用户信息并以结构化的方式保存它们，我们将使用Cloud Firestore，这是一个无服务器的文档数据库，无需维护即可轻松扩展以满足任何需求。对于存储静态文件，如图像，我们将使用云存储。</p><p id="b032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们回到firebase-config.js。在这里，我们希望分别从firebase firestore和Storage库中添加getFirestore和getStorage。这些将允许我们从您的应用程序访问这些云服务。然后，您必须包装您初始化的firebase应用程序，以获得指向您的云Firestore和存储的存储和数据库。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="df65" class="kb je hi kz b fi ld le l lf lg">//firebase-config.js<br/><em class="lh">// Import the functions you need from the SDKs you need</em><br/><strong class="kz hj">import</strong> { initializeApp } <strong class="kz hj">from</strong> "firebase/app";<br/><em class="lh">// TODO: Add SDKs for Firebase products that you want to use</em><br/><em class="lh">// https://firebase.google.com/docs/web/setup#available-libraries</em><br/><strong class="kz hj">import</strong> { getAuth, GoogleAuthProvider } <strong class="kz hj">from</strong> 'firebase/auth';<br/><strong class="kz hj">import</strong> { getFirestore } <strong class="kz hj">from</strong> "firebase/firestore";<br/><strong class="kz hj">import</strong> { getStorage } <strong class="kz hj">from</strong> "firebase/storage";<br/><br/><em class="lh">// Your web app's Firebase configuration</em><br/><strong class="kz hj">const</strong> firebaseConfig = {<br/>  apiKey: "[YOUR API]",<br/>  authDomain: "[YOUR AUTH DOMAIN]",<br/>  projectId: "[YOUR PROJECT ID]",<br/>  storageBucket: "[YOUR STORAGE BUCKET]",<br/>  messagingSenderId: "[YOUR MESSAGING SENDER ID]",<br/>  appId: "[YOUR APP ID]"<br/>};<br/><br/><em class="lh">// Initialize Firebase</em><br/><strong class="kz hj">const</strong> app = initializeApp(firebaseConfig);<br/><em class="lh">// Adding Storage and Database</em><br/><strong class="kz hj">export</strong> <strong class="kz hj">const</strong> storage = getStorage(app);<br/><strong class="kz hj">export</strong> <strong class="kz hj">const</strong> db = getFirestore(app);<br/><em class="lh">// Adding Authentication</em><br/><strong class="kz hj">export</strong> <strong class="kz hj">const</strong> auth = getAuth(app); <br/><strong class="kz hj">export</strong> <strong class="kz hj">const</strong> provider = <strong class="kz hj">new</strong> GoogleAuthProvider();</span></pre><p id="3295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们在Cloud Firestore中创建一个集合。这可以在Firebase Cloud Firestore页面或Google Cloud console Firestore页面上完成。点击“开始收集”并命名收集的帖子，将其他内容留空。这是我们存储用户帖子信息的地方。</p><p id="bd3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们必须添加一个功能，通过应用程序上传新的帖子信息。首先，从firebase-config文件导入db、storage和auth。从firestore导入addDoc和集合。从存储中导入ref，uploadBytesResumable，getDownloadURL。</p><p id="88aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建状态来存储不同的字段信息(标题、文件、postInfo、storagesrc、likes和mostrecentliker)。还可以创建一个名为percent的状态来存储上传百分比信息。最后，创建所需的助手函数并添加到应用程序中。代码应该是这样的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b428" class="kb je hi kz b fi ld le l lf lg">// PostPg.js<br/>import React, { useState } <strong class="kz hj">from</strong> "react";<br/>import { addDoc, collection } <strong class="kz hj">from</strong> 'firebase/firestore'<br/>import { <strong class="kz hj">ref</strong>, uploadBytesResumable, getDownloadURL } <strong class="kz hj">from</strong> "firebase/storage";<br/>import { db, auth, storage } <strong class="kz hj">from</strong> '../firebase-config'<br/>import { useNavigate } <strong class="kz hj">from</strong> "react-router-dom";<br/><br/>function <strong class="kz hj">PostPg</strong>({authState}) {<br/>   <em class="lh">//Using Navigate to navigate away from this page to Home once post is uploaded</em><br/>   <strong class="kz hj">let</strong> navigate = useNavigate();<br/>   <em class="lh">//Creating States for all the fields</em><br/>   <strong class="kz hj">const</strong> [title, setTitle] = useState("");<br/>   <strong class="kz hj">const</strong> [file, setFile] = useState("");<br/>   <strong class="kz hj">const</strong> [postInfo, setPostInfo] = useState("");<br/>   <strong class="kz hj">const</strong> [storagesrc, setStorageSrc] = useState("");<br/>   <strong class="kz hj">const</strong> likes = 0;<br/>   <strong class="kz hj">const</strong> mostrecentliker = "";<br/>   <strong class="kz hj">const</strong> [percent, setPercent] = useState(0); <em class="lh">//For storage upload %</em><br/><br/>   <em class="lh">//Reference the collection "posts" you just created in the console</em><br/>   <strong class="kz hj">const</strong> postsCollectionRef = collection(db, "posts")<br/><br/>   <em class="lh">//Create a function to add a Document to the posts collection</em><br/>   <strong class="kz hj">const</strong> postToCloud = <strong class="kz hj">async</strong> () =&gt; {<br/>       <strong class="kz hj">await</strong> addDoc(postsCollectionRef, {<br/>           title,<br/>           postInfo,<br/>           author: {name: auth.currentUser.displayName, id: auth.currentUser.uid},<br/>           storagesrc,<br/>           likes,<br/>           mostrecentliker<br/>       });<br/>       navigate("/");<br/>   };<br/><br/>   <em class="lh">//Create a helper function to target file</em><br/>   function <strong class="kz hj">getFile</strong>(<strong class="kz hj">event</strong>) {<br/>       setFile(<strong class="kz hj">event</strong>.target.files[0]);<br/>   }<br/><br/>   <em class="lh">//Create a function to add a static image to Cloud Storage</em><br/>   function <strong class="kz hj">uploadToCloud</strong>() {<br/>       <strong class="kz hj">const</strong> storageRef = <strong class="kz hj">ref</strong>(storage,`/postImg/${file.name}`) <em class="lh">//This reference to where files will save</em><br/>       <strong class="kz hj">const</strong> uploadTask = uploadBytesResumable(storageRef, file);<br/>       uploadTask.<strong class="kz hj">on</strong>(<br/>           "state_changed",<br/>           (snapshot) =&gt; {<br/>               <strong class="kz hj">const</strong> curPercent = Math.round((snapshot.bytesTransferred/snapshot.totalBytes)*100);<br/>               setPercent(curPercent); <em class="lh">//This is what shows the percent uploaded</em><br/>           },<br/>           (err) =&gt; console.log(err),<br/>           () =&gt; {<br/>               getDownloadURL(uploadTask.snapshot.<strong class="kz hj">ref</strong>).then((url) =&gt; {<br/>                   setStorageSrc(url) <em class="lh">//This sets the storagesrc as the url to this picture!</em><br/>               });<br/>           }<br/>       );<br/>   }<br/><br/>   <strong class="kz hj">return</strong> (<br/>       &lt;div className="PostPg"&gt;<br/>           &lt;div className="FieldInput"&gt;<br/>               &lt;label&gt;Title&lt;/label&gt;<br/>               &lt;input<br/>                   placeholder="Title..."<br/>                   onChange={(<strong class="kz hj">event</strong>) =&gt; {<br/>                       setTitle(<strong class="kz hj">event</strong>.target.<strong class="kz hj">value</strong>);<br/>                   }}<br/>               /&gt;<br/>           &lt;/div&gt;<br/>           &lt;div className="FieldInput"&gt;<br/>               &lt;label&gt;Info:&lt;/label&gt;<br/>               &lt;textarea<br/>                   placeholder="Info..."<br/>                   onChange={(<strong class="kz hj">event</strong>) =&gt; {<br/>                       setPostInfo(<strong class="kz hj">event</strong>.target.<strong class="kz hj">value</strong>);<br/>                   }}<br/>               /&gt;<br/>           &lt;/div&gt;<br/>           &lt;input type="file" onChange={getFile} accept="" /&gt;<br/>           &lt;button onClick={uploadToCloud}&gt;Upload Picture&lt;/button&gt;<br/>           &lt;div&gt; Upload Progress: {percent}% &lt;/div&gt;<br/>           &lt;button onClick={postToCloud}&gt; Submit Post &lt;/button&gt;<br/>       &lt;/div&gt;<br/>   );<br/> }<br/> export <strong class="kz hj">default</strong> PostPg;</span></pre><p id="3d7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过进行npm启动并转到开发构建来试验您目前所拥有的东西。花点时间通读代码，了解每个函数在做什么。也可以去谷歌云控制台上查看我们的Firestore页面，或者Firebase控制台上的云Firestore页面。您应该注意到每个帖子都在您的帖子集合中创建了一个新文档。你还会注意到，你的云存储中有一个新的postImg文件夹，所有的图片都保存在这里。</p><h1 id="4293" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">以本机模式和云存储从Firestore获取信息</h1><p id="2730" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">仅仅将信息和图像发送到云中还不足以创建一个交互式的web应用程序，我们还需要能够访问这些信息。让我们创建一个主页，让用户可以看到每个人发布的所有帖子。首先为文章列表创建一个状态，该状态将通过使用React中的useEffect来刷新。在useEffect中，我们将使用集合posts并将所有数据存储到一个名为posts的列表中。然后，我们可以在帖子列表中显示每个特定帖子的信息。它看起来会像这样。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="512a" class="kb je hi kz b fi ld le l lf lg">//HomePg.js<br/><strong class="kz hj">import</strong> React <strong class="kz hj">from</strong> "react";<br/><strong class="kz hj">import</strong> {getDocs, collection} <strong class="kz hj">from</strong> 'firebase/firestore';<br/><strong class="kz hj">import</strong> { db } <strong class="kz hj">from</strong> '../firebase-config';<br/><br/><strong class="kz hj">function</strong> <strong class="kz hj">HomePg</strong>({authState}) {<br/>   <strong class="kz hj">const</strong> [posts, setPosts] = useState([]);<br/><br/>   <em class="lh">// This function runs when the page is loaded to get the data. It stores the data in to the posts state (type list).</em><br/>   useEffect(()=&gt; {<br/>       <strong class="kz hj">const</strong> getData = <strong class="kz hj">async</strong> () =&gt; {<br/>           <strong class="kz hj">const</strong> data = <strong class="kz hj">await</strong> getDocs(collection(db, "posts"));<br/>           setPosts(data.docs.map((doc) =&gt; ({...doc.data(), id: doc.id })));<br/>       };<br/>       getData();<br/>   });<br/><br/>   <strong class="kz hj">return</strong> (<br/>       &lt;div className="HomePg"&gt;<br/>       {posts.map((post)=&gt; {<br/>           return (<br/>           &lt;div className="post" key={post.id}&gt;<br/>               &lt;h3&gt;{post.author.name} writes about {post.title}&lt;/h3&gt;<br/>               &lt;div className="textContainer"&gt;<br/>                   {post.postInfo}<br/>               &lt;/div&gt;<br/>               {(post.storagesrc !== null &amp;&amp; post.storagesrc !== undefined &amp;&amp; post.storagesrc !== "") &amp;&amp;<br/>                   &lt;div className="box"&gt;<br/>                       &lt;img src={post.storagesrc} alt="" &gt;&lt;/img&gt;<br/>                   &lt;/div&gt;<br/>               }<br/>           &lt;/div&gt;<br/>           )<br/>       })}<br/>       &lt;/div&gt;<br/>   );<br/>}<br/> <strong class="kz hj">export</strong> <strong class="kz hj">default</strong> HomePg;</span></pre><p id="58bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到如何访问每个帖子的信息。您还可以看到如何添加逻辑的示例，以便仅当storagesrc字段中有适当的值时才显示图像。</p><p id="b99e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你有了显示所有帖子的后端逻辑，但是让我们添加一些收尾工作。为您自己的帖子添加一个只有登录后才会显示的赞按钮和一个删除按钮。添加这些最终特性将使您的代码看起来像这样。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="cde6" class="kb je hi kz b fi ld le l lf lg">//HomePg.js<strong class="kz hj"><br/>import</strong> React, { useEffect, useState } <strong class="kz hj">from</strong> "react";<br/><strong class="kz hj">import</strong> { getDocs, collection, deleteDoc, doc, updateDoc, increment } <strong class="kz hj">from</strong> 'firebase/firestore';<br/><strong class="kz hj">import</strong> { db, auth } <strong class="kz hj">from</strong> '../firebase-config';<br/><br/><strong class="kz hj">function</strong> <strong class="kz hj">HomePg</strong>({authState}) {<br/>   <strong class="kz hj">const</strong> [posts, setPosts] = useState([]);<br/><br/>   <em class="lh">// This function runs when the page is loaded to fetch the data.</em></span><span id="a0c8" class="kb je hi kz b fi li le l lf lg"><em class="lh">// It stores the data into the posts state (type list).</em><br/>   useEffect(()=&gt; {<br/>       <strong class="kz hj">const</strong> getData = <strong class="kz hj">async</strong> () =&gt; {<br/>           <strong class="kz hj">const</strong> data = <strong class="kz hj">await</strong> getDocs(collection(db, "posts"));<br/>           setPosts(data.docs.map((doc) =&gt; ({...doc.data(), id: doc.id })));<br/>       };<br/>       getData();<br/>   });<br/><br/>   <em class="lh">//Delete your own posts function</em><br/>   <strong class="kz hj">const</strong> deletePost = <strong class="kz hj">async</strong> (id) =&gt; {<br/>       <strong class="kz hj">const</strong> thisSpecificDoc = doc(db, "posts", id);<br/>       <strong class="kz hj">await</strong> deleteDoc(thisSpecificDoc);<br/>   }<br/><br/>   <em class="lh">//Like your friends post = It adds one like and also takes note of your email</em><br/>   <strong class="kz hj">const</strong> likePost = <strong class="kz hj">async</strong> (id, emails) =&gt; {<br/>       <strong class="kz hj">const</strong> thisSpecificDoc = doc(db, "posts", id);<br/>       <strong class="kz hj">await</strong> updateDoc(thisSpecificDoc,{likes: increment(1), mostrecentliker:emails});<br/>   }<br/><br/>   <strong class="kz hj">return</strong> (<br/>       &lt;div className="HomePg"&gt;<br/>       {posts.map((post)=&gt; {<br/>           return (<br/>           &lt;div className="post" key={post.id}&gt;<br/>               &lt;div className="like"&gt;<br/>                   {auth.currentUser != null &amp;&amp;<br/>                       &lt;div&gt; {post.author.id !== auth.currentUser.uid &amp;&amp;<br/>                           &lt;button onClick={() =&gt; {likePost(post.id, auth.currentUser.email)}}&gt; &amp;#10084; &lt;/button&gt; }<br/>                           &lt;div&gt; {post.likes} &lt;/div&gt;<br/>                       &lt;/div&gt;<br/>                   } <br/>               &lt;/div&gt;<br/>               &lt;div className="delete"&gt;<br/>                   {auth.currentUser != null &amp;&amp;<br/>                       &lt;div&gt; {post.author.id === auth.currentUser.uid &amp;&amp;<br/>                           &lt;button onClick={() =&gt; {deletePost(post.id)}}&gt; Delete &lt;/button&gt;}<br/>                       &lt;/div&gt;<br/>                   } <br/>               &lt;/div&gt;<br/>               &lt;h3&gt;{post.author.name} writes about {post.title}&lt;/h3&gt;<br/>               &lt;div className="textContainer"&gt;<br/>                   {post.postInfo}<br/>               &lt;/div&gt;<br/>               {(post.storagesrc !== null &amp;&amp; post.storagesrc !== undefined &amp;&amp; post.storagesrc !== "") &amp;&amp;<br/>                   &lt;div className="box"&gt;<br/>                       &lt;img src={post.storagesrc} alt="" &gt;&lt;/img&gt;<br/>                   &lt;/div&gt;<br/>               }<br/>           &lt;/div&gt;<br/>           )<br/>       })}<br/>       &lt;/div&gt;<br/>   );<br/>}<br/> <strong class="kz hj">export</strong> <strong class="kz hj">default</strong> HomePg;</span></pre><p id="1e94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让应用程序看起来更好，我不太喜欢使用css，所以我不会为CSS提供任何代码。</p><p id="0943" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜你！您已经成功创建了照片/帖子共享应用程序。请注意发布太多的帖子和上传太多的照片会产生费用。推送您最近的所有更改，将其保存在您的云存储库中。</p><h1 id="c72d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在应用程序引擎上部署项目</h1><h2 id="ea6e" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">构建和部署项目</h2><p id="a46e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">您觉得自己刚刚创建的应用程序已经足够好，可以向公众发布了，但是有什么简单的部署方法呢？使用App Engine，用户可以通过零服务器管理和零配置部署来部署NodeJS应用程序。让我们通过启用云构建API并使用您的项目初始化您的App Engine应用程序来准备部署。请注意，每个项目只能运行一个App Engine应用程序，并且App Engine应用程序是区域性的。如果延迟对您的应用程序很重要，请选择离您的用户最近的地区，因为该地区在将来是不可更改的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5029" class="kb je hi kz b fi ld le l lf lg">gcloud app create <em class="lh">--region=us-central</em></span></pre><p id="c014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们构建您的React应用程序。您可以通过运行下面的代码轻松地做到这一点。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5b8d" class="kb je hi kz b fi ld le l lf lg">npm <strong class="kz hj">run</strong> build</span></pre><p id="8ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个命令保持您的应用程序不变，但是创建了一个名为build的压缩小软件包。现在，您可以尝试部署应用程序的生产版本。在尝试在App Engine上部署之前，让我们指定URL路径如何对应于应用程序的请求处理程序、静态文件和运行时。在my-app目录中创建一个app.yaml文件。应该是这样的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2b8d" class="kb je hi kz b fi ld le l lf lg">env: standard<br/>runtime: nodejs10<br/>service: react-prod<br/>handlers:<br/> - url: /static<br/>   static_dir: build/static<br/> - url: /(.*\.(json|ico|js))$<br/>   static_files: build/\1<br/>   upload: build/.*\.(json|ico|js)$<br/> - url: .*<br/>   static_files: build/index.html<br/>   upload: build/index.html</span></pre><p id="e973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保存app.yaml文件后，返回到Cloud Shell并运行my-app目录中的deploy。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="368a" class="kb je hi kz b fi ld le l lf lg">gcloud app deploy</span></pre><p id="2d09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将为您提供正在部署的服务的详细信息，还会为您提供应用程序将要部署到的目标url。请记住将此链接添加到授权域列表中，以确保身份验证部分正常工作。您可以运行app browse再次获取此链接。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a11b" class="kb je hi kz b fi ld le l lf lg">gcloud app browse -s react-prod</span></pre><p id="31a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你去谷歌云控制台的应用引擎页面，你应该会看到你的应用运行状态服务，流量分配为100%。</p><h2 id="48aa" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">应用程序的版本控制</h2><p id="b26d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">App Engine允许您控制应用程序的版本和流量。继续并再次运行部署命令。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="082d" class="kb je hi kz b fi ld le l lf lg">gcloud app deploy</span></pre><p id="17b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序引擎应该显示您的react-prod有两个不同的版本。按下版本下的数字<strong class="ih hj"> 2 </strong>(或从左侧导航栏进入版本页面)。这应该显示最新版本拥有100%的流量分配。您可以通过点击其复选框并点击迁移流量返回到第一个版本。这将把所有流量发送到应用程序的第一个版本。如果您想要缓慢推出最新版本，您将选择两个版本，然后单击流量分割，让旧版本获得90%的流量，新版本获得10%的流量</p><h1 id="7d34" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用云函数</h1><h2 id="89eb" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">创建响应事件的独立函数</h2><p id="d878" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">Google Cloud Functions是一个无服务器的执行环境，用于构建和连接云服务。您可以使用它来创建无需任何基础设施管理即可执行的功能。让我们创建一个向第25个人发送电子邮件来喜欢特定帖子的功能。进入谷歌云控制台，进入云功能页面。</p><p id="e435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在点击创建功能，选择第一代环境，并命名为电子邮件-发件人-功能。接下来选择Cloud Firestore作为触发类型，并选择事件类型更新。文档路径将是posts/{docid}。我们在这里使用通配符，因为我们希望能够查找所有帖子的任何更新。不要选中失败时重试。</p><p id="2f56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您单击“下一步”时，将要求您创建代码。选择Node.js 16作为运行时，helloFirestore作为入口点。然后创建以下两个文件。您会注意到您没有sgMail API密钥(sendgrid)，我们稍后会回来编辑它。</p><p id="a6ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">package.json</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7acc" class="kb je hi kz b fi ld le l lf lg">{<br/> "name": "Sample Example",<br/> "version": "1.0.0",<br/> "engines": {<br/>   "node": "&gt;8.0.0"<br/> },<br/> "description": "Cloud Function that sends email with logic",<br/> "main": "index.js",<br/> "scripts": {<br/>   "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/> },<br/> "author": "Brian Jung",<br/> "dependencies": {<br/>   "@google-cloud/firestore": "^0.19.0",<br/>   "@sendgrid/mail": "^6.3.1"<br/> }<br/>}</span></pre><p id="294a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">索引. js</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0506" class="kb je hi kz b fi ld le l lf lg"><strong class="kz hj">const</strong> sgMail = require('@sendgrid/mail');<br/>sgMail.setApiKey('[YOUR SGMAIL API KEY]');<br/><br/>exports.helloFirestore = (event, context) =&gt; {<br/>  <strong class="kz hj">const</strong> eventId = event.context.eventId;<br/>  <strong class="kz hj">const</strong> emailRef = db.collection('sentEmails').doc(eventId);<br/><br/>  <strong class="kz hj">return</strong> shouldSendWithLease(emailRef).then(send =&gt; {<br/>    <strong class="kz hj">if</strong> (send) {<br/>      <em class="lh">//Send email if the like field returns 25</em><br/>      <strong class="kz hj">if</strong> (event.value.fields.likes.integerValue == 25) {<br/>         <strong class="kz hj">const</strong> msg = {<br/>            to: event.value.fields.mostrecentliker.stringValue, <em class="lh">// This is email of most recent liker</em><br/>            <strong class="kz hj">from</strong>: '[YOUR EMAIL HERE]', <em class="lh">// Use the email address or domain you verified above</em><br/>            subject: 'You Liked a Post',<br/>            text: 'You were the 25th person to like a specific post!',<br/>            html: '&lt;strong&gt;You were the 25th person to like a specific post!&lt;/strong&gt;',<br/>         };<br/>         sgMail.send(msg)<br/>         <strong class="kz hj">return</strong> markSent(emailRef)<br/>      };<br/>    }<br/>  });<br/><br/>};<br/>    <br/><strong class="kz hj">const</strong> leaseTime = 60 * 1000; <em class="lh">// 60s</em><br/><br/><strong class="kz hj">function</strong> <strong class="kz hj">shouldSendWithLease</strong>(emailRef) {<br/>  <strong class="kz hj">return</strong> db.runTransaction(transaction =&gt; {<br/>    <strong class="kz hj">return</strong> transaction.get(emailRef).then(emailDoc =&gt; {<br/>      <strong class="kz hj">if</strong> (emailDoc.exists &amp;&amp; emailDoc.data().sent) {<br/>        <strong class="kz hj">return</strong> false;<br/>      }<br/>      <strong class="kz hj">if</strong> (emailDoc.exists &amp;&amp; admin.firestore.Timestamp.now() &lt; emailDoc.data().lease) {<br/>        <strong class="kz hj">return</strong> Promise.reject('Lease already taken, try later.');<br/>      }<br/>      transaction.set(<br/>          emailRef, {lease: <strong class="kz hj">new</strong> Date(<strong class="kz hj">new</strong> Date().getTime() + leaseTime)});<br/>      <strong class="kz hj">return</strong> true;<br/>    });<br/>  });<br/>}<br/><br/><strong class="kz hj">function</strong> <strong class="kz hj">markSent</strong>(emailRef) {<br/>  <strong class="kz hj">return</strong> emailRef.set({sent: true});<br/>}</span></pre><p id="8316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">package.json文件告诉NodeJS运行时，您需要firestore和sendgrid依赖项。index.js是您的主文件，它查看触发该函数的事件。它专门查看字段“likes”的值，并将其与数字25进行比较。如果它们相等，该函数将使用sendgrid向第25个喜欢该帖子的人发送电子邮件，或者在我们的示例中，发送mostrecentliker的字符串值(我们存储了最近喜欢该帖子的用户的电子邮件)。</p><p id="102f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Firestore和Cloud Functions trigger之间的消息传递系统是一项名为Pub/Sub的谷歌云服务。发布/订阅至少提供一次传递，但可能会多次通知您的函数。这段代码是幂等的，保证第25个用户只收到一封邮件。点击阅读更多关于<a class="ae lj" href="https://cloud.google.com/blog/products/serverless/cloud-functions-pro-tips-building-idempotent-functions" rel="noopener ugc nofollow" target="_blank">幂等的内容。</a></p><p id="1ef0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们几乎已经设置好了一切！在谷歌云控制台中，进入市场并寻找SendGrid电子邮件API。Google Cloud Marketplace是您可以连接第三方工具来使用您的云解决方案的地方。我们将使用SendGrid，一种电子邮件发送服务。在SendGrid电子邮件API页面，购买免费选项。您需要创建一个SendGrid帐户，并获取SendGrid API密钥，将其保存到您可以访问的安全位置。回到云功能，编辑你的邮件发送功能。转到代码，用您刚刚创建的API密钥更改[您的SGMAIL API密钥]。</p><p id="ee01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜你！如果你去你的App Engine部署网站，喜欢一个帖子，直到它达到25个喜欢，你会收到一封来自云功能的电子邮件，标题是“你喜欢了一个帖子”。</p><h1 id="b167" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">清理</h1><p id="aee3" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">请随意继续使用Google Cloud。感谢您阅读本指南，我希望您学到了一些关于应用程序开发的新知识。</p><h2 id="ad19" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">禁用您的应用程序</h2><p id="4874" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">首先，我们将禁用SendGird电子邮件API。返回云市场并转到SendGrid电子邮件API页面。向下滚动到定价，你会看到一个管理订单按钮。按下按钮，您将被重定向到特定产品的订单。按下订单右端的“更多”按钮(提示:它看起来像三个点)，然后按下“禁用自动续订”，并取消订单。</p><p id="7cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，前往应用引擎页面。转到设置并单击禁用应用程序。在“应用程序ID”栏中，输入您想要停用的应用程序的ID，然后点按“停用”。这将禁用你的应用引擎服务，并停止你的firestore。</p><h2 id="ee12" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">删除您的项目</h2><p id="8bae" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">要释放云项目中的所有Google云资源，请删除您的项目。转到IAM -&gt;管理资源页面。突出显示您的项目，然后单击删除。在“项目标识号”域中，输入要删除的项目标识号，然后单击“删除”。</p></div></div>    
</body>
</html>