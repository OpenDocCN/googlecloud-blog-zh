<html>
<head>
<title>🐤 Canary Deployment on GCP with Cloud Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🐤部署云的GCP金丝雀部署</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/draft-canarying-on-gcp-with-cloud-deploy-91b3e4d0ee9a?source=collection_archive---------1-----------------------#2022-09-15">https://medium.com/google-cloud/draft-canarying-on-gcp-with-cloud-deploy-91b3e4d0ee9a?source=collection_archive---------1-----------------------#2022-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d42a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">在过去的几个月里，我一直在为金丝雀开发一个有点“复杂”的解决方案🐤多应用的部署(💎🐍️🧊)知识库，试图回答这个问题:我如何通过几个阶段将<em class="jm"> N </em>个应用程序投入生产，并确保(过于简化)<strong class="ih hj">最终用户得到n个和N-1个版本的组合，</strong>比如说<strong class="ih hj"> 90%的生产</strong>流量<strong class="ih hj"> </strong> / <strong class="ih hj"> 10%的金丝雀</strong>流量？我如何让代码<a class="ae jn" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">变干</a>以便让我的下一个应用变得超级简单？</p><p id="d035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jm">不耐烦？参见</em><a class="ae jn" href="https://github.com/palladius/clouddeploy-platinum-path" rel="noopener ugc nofollow" target="_blank"><em class="jm">【https://github.com/palladius/clouddeploy-platinum-path】</em></a><em class="jm">(</em><a class="ae jn" href="https://www.youtube.com/watch?v=0GfV5iMGG64" rel="noopener ugc nofollow" target="_blank"><em class="jm">视频</em> </a> <em class="jm"> ) </em></p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/58722f65799550ecd33ea9116a41a03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E_NPN-722fGpRhFI"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">真正的金丝雀在<a class="ae jn" href="https://goo.gl/maps/4cgTQJfDonHi5XFN9" rel="noopener ugc nofollow" target="_blank"> Cripta Rasponi </a>(意大利拉韦纳圣方济各广场)</figcaption></figure><h1 id="5554" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">问题是</h1><p id="1a99" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">许多谷歌云用户指出了如何使用<a class="ae jn" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank">云构建</a> + <a class="ae jn" href="https://cloud.google.com/deploy" rel="noopener ugc nofollow" target="_blank">云部署</a>来执行部署策略的愿望。虽然云构建和云部署一直在发展，但我想展示一下Google Cloud的CI/CD工具<em class="jm">今天</em>能做些什么。</p><p id="7ef4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将演示如何构建一个<strong class="ih hj">多应用交付管道</strong>，它有四个目标，并使用两种构建策略(纯构建，以及通过单元测试后的提升)。更重要的是，我们将展示如何使用两种不同的全新技术(<strong class="ih hj">网关API </strong>和<strong class="ih hj">基于Envoy的HTTP负载平衡器</strong>)来实现<strong class="ih hj"> canary/prod </strong> <strong class="ih hj">流量分流</strong>。</p><h1 id="03aa" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">什么是…🐤金丝雀部署？蓝色怎么样🔵/🟢green？</h1><blockquote class="lh li lj"><p id="7108" class="if ig jm ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">🐤Canary deployment 是让你的新版本只对有限的用户开放的实践，目的是在推送错误的情况下能够快速失败/回滚，同时让大多数用户满意。这可以通过多种方式实现(5%的客户端浏览器，美国用户对欧洲用户，..).</p></blockquote><p id="97ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等等——这不是和蓝绿色一样吗？</p><p id="f142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">蓝</strong>的情况下🔵-🟢 <strong class="ih hj">绿色部署</strong>，当一个新版本的环境(绿色)被部署时，流量进入一个生产环境(蓝色)。然后将测试(绿色)的新版本。一旦情况稳定下来，用户将被推到绿色环境，而蓝色环境则保持待命状态，以防出现任何问题。如果出现问题，用户可以被推回到蓝色版本，确保无缝过渡和最大限度的正常运行时间，而没有人会注意到。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es ln"><img src="../Images/ff66a6ba54824caccb5325fb170cfdf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g_C775j_3INMVU97"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">谷歌苏黎世典型的蓝绿色部署</figcaption></figure><p id="4bdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，虽然blue/green在任何时候都有两个版本N和版本N-1的环境，并且能够在它们之间切换，但canary更多的是两个版本之间随着时间推移的“淡化机制”。</p><p id="17fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">哪个好？</strong>答案一如既往的是“<em class="jm">看情况</em>”。不过我的理解是，在Kubernetes ( <code class="du lo lp lq lr b">Deployments</code> + <code class="du lo lp lq lr b">RollingUpdates</code>)出来之前，蓝/绿是做流量分流的老办法。如果两者都可以，你可能会选择金丝雀，除非一个强大的隔离成本约2倍的价格对你更好。</p><h1 id="61de" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">两个金丝雀解决方案</h1><h2 id="c46c" class="ls kf hi bd kg lt lu lv kk lw lx ly ko iq lz ma ks iu mb mc kw iy md me la mf bi translated">简单的解决方案(A): GKE单一集群，分离式</h2><p id="a068" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">第一个解决方案非常简单，kubernetes-native。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mg"><img src="../Images/a648bd7a82b6d0d5ec39839acc3e77ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*j62CDHXygRicoWtXrG-iRg.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">简单的解决方案:kubernetes-原生荚果分裂</figcaption></figure><p id="7e2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">属性:</p><ul class=""><li id="51f8" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated"><strong class="ih hj">单簇</strong></li><li id="6f66" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">K8s本机(服务/部署/pod)</li><li id="1ca1" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated"><strong class="ih hj">金丝雀</strong>通过荚果分裂</li><li id="63c3" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">最大努力:80/20</li><li id="53a8" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">App:【仅T2】(节点。JS)</li></ul><p id="ea9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个解决方案非常简单:prod中的4个<a class="ae jn" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank">吊舱</a>和canary中的1个<a class="ae jn" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank">吊舱</a>。在这里，Cloud Deploy帮助您构建和部署您的第N个和第N+1个版本到交付管道，</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mv"><img src="../Images/abaa423db423f96f84e8dc6f9fe5df3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*gIgmdPyZgbk4ocjhcSVSMg.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">针对4个目标的4个版本</figcaption></figure><p id="c780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">..GKE负载平衡器将始终以80/20的比例指向您最近部署的两个版本。这种解决方案不是很复杂，因为它依赖于5个吊舱是活着的并且具有相似的负载，这可能并不总是真实的。如果您想要90%/10%的比率，您需要安排9/1 pod或18/2、27/3、..几乎没有灵活性。</p><h2 id="e73f" class="ls kf hi bd kg lt lu lv kk lw lx ly ko iq lz ma ks iu mb mc kw iy md me la mf bi translated">复杂解决方案(B):基于Envoy的GXLB、双GKE单集群、网关API、流量分离</h2><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mw"><img src="../Images/054ed7606fe05ed3fc39874782ba30b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*6r9gAybBnNn5b0a4GDPrLA.png"/></div></figure><p id="4283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案在更高层引入了适当的流量分流，而不仅仅是pod。为了实现这一点，我们使用最新的<a class="ae jn" href="https://gateway-api.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">网关API </strong> </a> <strong class="ih hj"> </strong>(绿色香蕉将超越并取代棕色香蕉<a class="ae jn" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口API </a>)</p><p id="99f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">属性:</p><ul class=""><li id="68b6" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated"><strong class="ih hj">多集群</strong></li><li id="56c4" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">技术:GKE/GCP/网关API/NEGs。</li><li id="2e79" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">通过适当的流量分流</li><li id="60de" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">应用:<code class="du lo lp lq lr b">app01</code> (python)和<code class="du lo lp lq lr b">app02</code> (ruby)</li></ul><p id="43f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">增加一些复杂性(<a class="ae jn" href="https://github.com/palladius/clouddeploy-platinum-path/blob/main/doc/Ricc%20Canary%20deployment%202022.png?raw=true" rel="noopener ugc nofollow" target="_blank">更大的图像</a>):</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es mx"><img src="../Images/867b8770b906b70ad79e469b153cd9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikopE33dhKvOJ-_vnSQ7AA.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">黄色部分是“GCP ”,左边是中间的GKE星团。</figcaption></figure><p id="5528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一方面，我们的开发人员将发布推送到云部署，云部署又将它们推送到我们的三个GKE集群，另一方面，我们有两个基于HTTP(s) <a class="ae jn" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>的外部(*)负载平衡器，它们将流量分流到两个<a class="ae jn" href="https://cloud.google.com/load-balancing/docs/backend-service" rel="noopener ugc nofollow" target="_blank">后端服务</a>，后端服务通过<a class="ae jn" href="https://cloud.google.com/load-balancing/docs/negs" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">网络端点组</strong> </a>(对于朋友来说是<strong class="ih hj"> NEGs </strong>)将流量路由到适当选择的pod。NEG是一个神奇的实体，它允许您将一个网络对象链接到另一个对象(我将其视为云中的黄色虚拟CAT-6电缆)，这些对象可以是负载平衡器或pod选择器。在我们的例子中，需要neg将某个后端服务(例如“App01 canary”)连接到匹配某个pod选择器的pod(在我的例子中是<code class="du lo lp lq lr b">ricc-awesome-selector: canary-or-prod</code>)。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es my"><img src="../Images/70e97c87123be0c1732d11090dbd960a.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*6uTmz0boovk2R6hX5HGOFQ.png"/></div></figure><p id="de4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个解决方案最复杂的部分是AppX/StageY和它的pod之间的NEGs的编织。一般来说，对于Google Kubernetes引擎集群，每个组合都有三个neg，因为我们通常每个集群有三个区域，每个区域一个，我们使用的是区域neg。</p><p id="f38c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将:</p><ul class=""><li id="4d6f" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">使用<code class="du lo lp lq lr b">kubectl</code>获取附加到“svcneg/XXX”对象的3个负数。</li><li id="541d" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">使用一些<code class="du lo lp lq lr b"><a class="ae jn" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">jq</a></code>喷火提取三个对象</li><li id="c746" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">使用<code class="du lo lp lq lr b">gcloud</code>将它们连接到我想要的<em class="jm">后端服务</em>。</li></ul><p id="5891" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想头疼，看看这个意大利面条代码:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es mz"><img src="../Images/1fd39eafb623530df44051db3bfc77fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GveeSvFPcOWZ4-UvJd0wpA.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">这是库贝奈特人的沃贡诗歌:)</figcaption></figure><p id="6802" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">→阅读更多关于<a class="ae jn" href="https://cloud.google.com/load-balancing/docs/https#HTTP2-limitations" rel="noopener ugc nofollow" target="_blank">全球外部负载平衡器</a>和<a class="ae jn" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>的信息。</p><h1 id="6e11" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">高层建筑</h1><p id="d812" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">这是一个高层次的解决方案。这都是由谷歌云平台技术实现的(作为一名谷歌人，我坚持己见)😃)，利用这些技术:</p><ul class=""><li id="7a1c" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">Google<strong class="ih hj">Cloud Build</strong>for Build在git代码更改时触发。</li><li id="96bc" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">Google <strong class="ih hj"> Cloud Deploy ( </strong>包括<strong class="ih hj"> Skaffold) </strong>习惯性地管理多个管道、多个版本和工件，然后很容易部署/回滚到GKE。</li></ul><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es na"><img src="../Images/a9fa9e25eb6829ad2ad999b79c4d4bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ou8fxLQSYk-63ElcOA5Bpw.png"/></div></div></figure><ul class=""><li id="ddb5" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">Google <strong class="ih hj"> Kubernetes引擎</strong>来运行我们的服务。</li><li id="29b9" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">Google<strong class="ih hj">Artifact Registry</strong>安全地保存我们的图像及其版本。</li><li id="8d0b" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">一些谷歌云<strong class="ih hj">负载平衡</strong>资源，使金丝雀解决方案2发生(见下面的<a class="ae jn" href="https://docs.google.com/document/d/1ZiMLBvAu5iXjFt2xE7KRHA1SJQKz-KPMHMdtKCnydKs/edit?resourcekey=0-9XoJqN8fbOgQl3fE3CzlgA#bookmark=id.ykizmocnuze0" rel="noopener ugc nofollow" target="_blank">金丝雀解决方案</a>)。我们正在利用全新的基于<strong class="ih hj"> Envoy的负载均衡器:</strong>这是一个全局负载均衡器，在Google前端(GFEs)上作为托管服务实现。它使用开源的Envoy代理来支持高级流量管理功能，如流量镜像、基于权重的流量分割、基于请求/响应的报头转换等。</li><li id="c9ef" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated"><a class="ae jn" href="https://skaffold.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Skaffold </strong> </a>在这里表现最好:它讲述了如何<strong class="ih hj">构建</strong>应用程序，何时需要重新构建它(<a class="ae jn" href="https://skaffold.dev/docs/pipeline-stages/filesync/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> filesync </strong> </a>)，以及如何<strong class="ih hj">部署</strong>应用程序，所有这些都在一个YAML中完成。我们的版本大量使用了Kustomize:</li></ul><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nb"><img src="../Images/cd3cd9c6c5d6e8c430c7082d29a0ae8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*mqpqYbCXRv-ktahZy1bXTg.png"/></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">这是App02的“ska ffold . YAML ”( Ruby)</figcaption></figure><ul class=""><li id="e170" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated"><a class="ae jn" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a>。我们选择采用Kustomize将配置“干燥”成一个基本版本和4个小补丁(覆盖)。如果你不是kustomize专家，只是想剪切粘贴结果，你可以做:<code class="du lo lp lq lr b">cd apps ; make kustomize</code>。这将呈现12个YAMLs个应用程序x 4个目标):</li></ul><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es nc"><img src="../Images/838f043ee4da6fdc4895a9cdc42805d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*lCiGAEMLHoQVWvssUhDBRQ.png"/></div></figure><p id="7eb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(*) Envoy是一种开源代理服务，它允许实现神奇的行为，如“将3.14%的流量路由到此端点，将剩余流量路由到另一个端点”(流量分流)。</p><h1 id="b0f6" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">先决条件</h1><p id="9121" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">要运行此代码，您需要:</p><ul class=""><li id="7fdc" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated">使项目id启用计费。参见<a class="ae jn" href="https://cloud.google.com/docs/get-started" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> GCP入门</strong> </a>。你实际上可以获得300美元的免费试用，这应该让你在几分钟内开始运行。</li><li id="3b13" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">使用bash v5+支持数组的本地环境(任何Linux发行版都支持，对于Mac，您可能需要<code class="du lo lp lq lr b">brew install bash)</code></li><li id="fd4e" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">带有其他常用工具的本地环境，如<code class="du lo lp lq lr b">kubectl</code>、<code class="du lo lp lq lr b">jq</code>、<code class="du lo lp lq lr b">kustomize</code>(见下文)</li></ul><p id="f098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，这段代码已经在<a class="ae jn" href="https://cloud.google.com/shell" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">云壳</strong> </a>上进行了广泛的测试，所以云壳会解决你所有的本地env依赖。</p><h2 id="52ed" class="ls kf hi bd kg lt lu lv kk lw lx ly ko iq lz ma ks iu mb mc kw iy md me la mf bi translated">装置</h2><p id="9b4c" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">为了保持这篇博客的简短，我鼓励你按照回购<a class="ae jn" href="https://github.com/palladius/clouddeploy-platinum-path/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> README.md </strong> </a>进行说明。我没有偷懒，这么做主要也是为了变更管理。只是一些小技巧。</p><p id="6281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问:为什么我没有使用Terraform </strong>？</p><p id="0fac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我和许多专家谈过，他们说服我不要使用Terraform。为什么？每个bash脚本都旋转出一个主要组件(GKE，云构建，云部署，..)而这种依赖关系树可能隐藏在TF脚本中。我的代码中并不是所有的东西都可以是terraform，为了达到最终的结果，我需要一些本地的exec。我的下一步将是🧹代码，允许我90%的声明性和10%的命令性。</p><p id="4a22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:这些bash代码是什么？</p><p id="3f07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能已经注意到了，我喜欢我的狂欢。有些事情需要解释:</p><ul class=""><li id="28d1" class="mh mi hi ih b ii ij im in iq mj iu mk iy ml jc mm mn mo mp bi translated"><code class="du lo lp lq lr b">.env.sh.dist</code>包含供您复制的配置。前4行是你需要修改的，其余的都应该没问题。</li><li id="41b5" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated">包含我所有的库代码。</li><li id="d7bb" class="mh mi hi ih b ii mq im mr iq ms iu mt iy mu jc mm mn mo mp bi translated"><code class="du lo lp lq lr b">XX-blah-blah.sh</code>:该代码必须按数字顺序运行(00- &gt; 01- &gt; 02- &gt; 03)..).所有的脚本都有一个共同点:它们在开始时导入shell脚本，失败或成功返回，接触一个隐藏文件，这将允许回顾并查看哪些脚本失败了。</li></ul><p id="890f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">你如何确保代码在正确的时间内得到执行？</strong></p><p id="a43c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很高兴你问了。我依靠两种机制:(1)“set-e”在第一个错误时退出，以及(2)我创建的这个愚蠢的脚本:<code class="du lo lp lq lr b">proceed_if_error_matches . </code>它将捕获一个非常简单的错误regex:如果类似“cluster已经存在”的东西，我将把它解释为退出0，即使它是一个错误。这允许我在反复试验的情况下继续按顺序执行代码，直到代码结束。</p><h2 id="67e8" class="ls kf hi bd kg lt lu lv kk lw lx ly ko iq lz ma ks iu mb mc kw iy md me la mf bi translated">检查它是否工作</h2><p id="ccf9" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">这是通过<code class="du lo lp lq lr b">curl</code>相同的IP(解决方案A)或DNS(解决方案B)实现的，并按阶段查看后端请求的百分比。</p><p id="955d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">简单解法(一)举例。</strong></p><p id="0551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lo lp lq lr b">$ bin/troubleshoot-solution4</code>:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es nd"><img src="../Images/2d47b40502894ec4fa8d004bd49fef7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4uNljYbESpdrwOjrufOZQ.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">我们将同一个IP卷了20次，得到了15/5，接近我们预期的16/4。</figcaption></figure><p id="3fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">复杂解(B)例。</strong></p><p id="d1e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">手动卷曲一旦你知道IP:</p><pre class="jp jq jr js fd ne lr nf ng aw nh bi"><span id="d95e" class="ls kf hi lr b fi ni nj l nk nl">for i in $(seq 1 20) ; do<br/>   curl -H "host: <a class="ae jn" href="http://www.example.io" rel="noopener ugc nofollow" target="_blank">www.example.io</a>" <a class="ae jn" href="http://35.244.160.220/statusz" rel="noopener ugc nofollow" target="_blank">http://35.244.160.220/statusz</a><br/>done</span></pre><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es nm"><img src="../Images/8ed521194a3b6aec7c6451274ac98ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z50tjbyLZF5xLwASvwBivQ.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">如果你喜欢手工卷发</figcaption></figure><p id="5f70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">漂亮的包装脚本:<code class="du lo lp lq lr b">./16-solution2-test-by-curling-N-times.sh app01</code>:</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es nn"><img src="../Images/327010eeaf36018803e262129abb54dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VuD5OEq1hEYPUosRiKDCQ.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">如果你喜欢漂亮的包装纸。这里我们得到了17/3，而不是期望的16/4。</figcaption></figure><h2 id="526e" class="ls kf hi bd kg lt lu lv kk lw lx ly ko iq lz ma ks iu mb mc kw iy md me la mf bi translated">结论</h2><p id="dde4" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">我展示了一个在GCP多阶段部署金丝雀的工作框架。不仅如此，我还展示了Skaffold和Kustomize如何在它们之间以及与云构建/云部署配合得很好。</p><p id="8fa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然开始时学习曲线可能有点陡峭，但我相信您会有很多代码可以在Google Cloud上的CI/CD体验的“第二天”重用。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es no"><img src="../Images/70faffded5271b65b6e7c67df829d74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D4rqBceK4XSba7GZ"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">我在谷歌阿姆斯特丹办公室拍的照片</figcaption></figure></div></div>    
</body>
</html>