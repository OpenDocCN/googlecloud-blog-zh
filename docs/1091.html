<html>
<head>
<title>Serverless gRPC + ASP.NET Core with Knative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器gRPC +带Knative的ASP.NET核心</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/serverless-grpc-asp-net-core-with-knative-b37ce09ea067?source=collection_archive---------1-----------------------#2019-07-24">https://medium.com/google-cloud/serverless-grpc-asp-net-core-with-knative-b37ce09ea067?source=collection_archive---------1-----------------------#2019-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b74c941504d3d527b43da4df552cc1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*nv-x9HwUJDwaIYEg"/></div></figure><p id="14f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我最近在查看ASP.NET的核心更新。网芯3.0预览版3 帖子，这一节得到了我的关注:<em class="jl"> gRPC模板。</em></p><p id="c080" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">显然，。NET Core 3.0有了一个新的gRPC模板，可以很容易地用ASP.NET核心构建gRPC服务。我测试了gRPC和。NET之前，我有一些样品在我的<a class="ae jk" href="https://github.com/meteatamel/grpc-samples-dotnet" rel="noopener ugc nofollow" target="_blank"> grpc-samples-dotnet </a>回购。即使gRPC和。NET以前工作过，安装起来并不那么简单。我很想尝试一下新的gRPC模板，看看它有什么帮助。</p><p id="1579" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，我想超越一个简单的gRPC服务，看看如何将它变成一个无服务器的Knative服务，拥有Knative的所有好处，如自动缩放、修订等。</p><p id="b816" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想亲自尝试一下，我的Knative教程中有一个新的章节:<a class="ae jk" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/07.5-grpc.md" rel="noopener ugc nofollow" target="_blank">带Knative的无服务器gRPC</a>有详细的说明。在这篇博客文章中，我想强调一下在Google Kubernetes Engine (GKE)上部署无服务器、支持gRPC的ASP.NET核心服务的一些主要步骤。</p><h1 id="2eb7" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">使用新模板创建gRPC服务</h1><p id="2019" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">使用创建HelloWorld gRPC服务。有了gRPC模板，NET Core 3.0再简单不过了。这是命令:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="cd00" class="ky jn hi ku b fi kz la l lb lc">&gt; dotnet new grpc -o GrpcGreeter</span></pre><p id="a998" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该命令在后台执行一些操作:</p><ul class=""><li id="1c85" class="ld le hi io b ip iq it iu ix lf jb lg jf lh jj li lj lk ll bi translated">创建一个包含所有gRPC依赖项的ASP.NET核心项目。</li><li id="9bbe" class="ld le hi io b ip lm it ln ix lo jb lp jf lq jj li lj lk ll bi translated">创建名为<code class="du lr ls lt ku b">greet.proto</code>的gRPC服务定义文件。</li><li id="406f" class="ld le hi io b ip lm it ln ix lo jb lp jf lq jj li lj lk ll bi translated">根据服务定义文件自动生成所有gRPC存根。</li><li id="f9b1" class="ld le hi io b ip lm it ln ix lo jb lp jf lq jj li lj lk ll bi translated">基于自动生成的gRPC存根创建gRPC服务(<code class="du lr ls lt ku b">GreeterService.cs</code>)。</li><li id="1e9b" class="ld le hi io b ip lm it ln ix lo jb lp jf lq jj li lj lk ll bi translated">配置<code class="du lr ls lt ku b">Startup.cs</code>中的gRPC管道映射到<code class="du lr ls lt ku b">GreeterService.cs</code></li></ul><p id="4081" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最终结果是，您已经处理好了gRPC的所有细节，并且您可以简单地开始运行服务:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="6dd4" class="ky jn hi ku b fi kz la l lb lc">&gt; dotnet run <br/>info: Microsoft.Hosting.Lifetime[0] Now listening on: <a class="ae jk" href="http://localhost:50051" rel="noopener ugc nofollow" target="_blank">http://localhost:50051</a></span></pre><p id="5a02" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这比我以前必须做的要简单得多。干得好。网核心团队！</p><h1 id="32ae" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">将gRPC服务容器化</h1><p id="4904" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">下一步是将gRPC服务容器化，这样它就可以部署到Knative。<code class="du lr ls lt ku b">Dockerfile</code>看起来是这样的:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="7162" class="ky jn hi ku b fi kz la l lb lc">FROM mcr.microsoft.com/dotnet/core/sdk:3.0<br/><br/>WORKDIR /app<br/>COPY *.csproj .<br/>RUN dotnet restore<br/><br/>COPY . .<br/><br/>RUN dotnet publish -c Release -o out<br/><br/>ENV PORT 8080<br/><br/>ENV ASPNETCORE_URLS http://*:${PORT}<br/><br/>CMD ["dotnet", "out/GrpcGreeter.dll"]</span></pre><p id="fe31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在用。NET Core 3.0作为基本映像，并确保该服务运行在端口8080上，而不是默认的gRPC端口50051上。没什么特别的。</p><h1 id="34ba" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">部署Knative服务</h1><p id="c478" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">一旦构建并推送了映像，就在一个<code class="du lr ls lt ku b">service.yaml</code>文件中定义Knative服务:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="2b6f" class="ky jn hi ku b fi kz la l lb lc">apiVersion: serving.knative.dev/v1beta1<br/>kind: Service<br/>metadata:<br/>  name: grpc-greeter<br/>  namespace: default<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        # Replace {username} with your actual DockerHub<br/>        - image: docker.io/{username}/grpc-greeter:v1<br/><strong class="ku hj">          ports:<br/>          - name: h2c<br/>            containerPort: 8080</strong></span></pre><p id="0741" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个指向图像的简单的Knative服务定义。唯一特殊的部分是<strong class="io hj">端口</strong>部分，在这里我们定义了一个<strong class="io hj"> h2c </strong>端口8080。这告诉Knative容器正在端口8080上期待HTTP/2流量。</p><p id="c990" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">部署Knative服务:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="9635" class="ky jn hi ku b fi kz la l lb lc">&gt; kubectl apply -f service.yaml</span></pre><p id="525b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">确保带有gRPC服务的pod正在运行:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="5bb3" class="ky jn hi ku b fi kz la l lb lc">&gt; kubectl get pods </span><span id="9854" class="ky jn hi ku b fi lu la l lb lc">NAME grpc-greeter-5tpwl-deployment-6fb423289c5-r5qmt</span></pre><h1 id="0034" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">测试一下</h1><p id="d18f" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">要测试gRPC服务，您需要相应的支持gRPC的客户端。你可以参考我的教程中关于如何创建一个<code class="du lr ls lt ku b">GrpcGreeterClient.cs</code>的<a class="ae jk" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/07.5-grpc-csharp.md#create-a-grpc-client" rel="noopener ugc nofollow" target="_blank">创建一个gRPC客户端</a>部分。一旦你有了客户，只要指出你的服务。您应该会看到运行在Knative中的gRPC服务的回复:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="604c" class="ky jn hi ku b fi kz la l lb lc">&gt; dotnet run<br/>Greeting: Hello GreeterClient Press any key to exit...</span></pre><p id="bdb7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从表面上看，这看起来像是普通gRPC服务的响应。然而，这是一个Knative托管服务，这意味着你有0-n自动缩放，修订和所有其他在Knative中运行服务的好处。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="d2cc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">。NET Core 3.0使gRPC的入门变得非常容易，Knative将普通的gRPC转换成无服务器风格的服务，可以自动伸缩和响应事件。这是一个强大的组合，希望这篇博文和相应的教程能让你一窥如何使用。NET核心与gRPC和Knative。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="cff2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jl">原载于2019年7月24日</em><a class="ae jk" href="https://meteatamel.wordpress.com/2019/07/24/serverless-grpc-asp-net-core-with-knative/" rel="noopener ugc nofollow" target="_blank"><em class="jl">http://meteatamel.wordpress.com</em></a><em class="jl">。</em></p></div></div>    
</body>
</html>