<html>
<head>
<title>Kubernetes 101: Pods, Nodes, Containers, and Clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">kubernetes 101:pod、节点、容器和集群</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16?source=collection_archive---------0-----------------------#2018-01-02">https://medium.com/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16?source=collection_archive---------0-----------------------#2018-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5e66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes正迅速成为在云中部署和管理软件的新标准。然而，在Kubernetes提供的所有功能之外，还有一个陡峭的学习曲线。作为一名新人，试图解析官方文档可能会让人不知所措。系统由许多不同的部分组成，很难区分哪些部分与您的用例相关。这篇博客文章将提供Kubernetes的一个简化视图，但是它将试图给出最重要的组件以及它们如何组合在一起的高层次概述。</p><p id="2c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们看看硬件是如何表示的</p><h1 id="baff" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">五金器具</h1><h2 id="6b4c" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">节点</h2><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/d5c11f1ef272714c05caecd6497202fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyMd-QxYaOk_APwtuScsOg.png"/></div></div></figure><p id="34b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<a class="ae jd" href="https://kubernetes.io/docs/concepts/architecture/nodes/" rel="noopener ugc nofollow" target="_blank">节点</a>是Kubernetes中计算硬件的最小单位。它代表了集群中的一台机器。在大多数生产系统中，一个节点可能是数据中心的物理机，或者是托管在云提供商如<a class="ae jd" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>上的虚拟机。然而，不要让习俗限制你；理论上，你可以用<a class="ae jd" href="https://twitter.com/jkrippy/status/932800484703862784" rel="noopener ugc nofollow" target="_blank">几乎</a> <a class="ae jd" href="https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/" rel="noopener ugc nofollow" target="_blank">任何东西</a>做一个节点。</p><p id="dea0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将机器视为“节点”允许我们插入一个抽象层。现在，我们不用担心任何单个机器的独特特征，而是可以简单地将每台机器视为一组可以利用的CPU和RAM资源。这样，任何机器都可以替代Kubernetes集群中的任何其他机器。</p><h2 id="8eb5" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">集群</h2><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lc"><img src="../Images/680eb38ad983303f965d9d97b2a0e16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KoMzLETQeN-c63x7xzSKPw.png"/></div></div></figure><p id="60fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管使用单个节点可能有用，但这不是Kubernetes的方式。通常，您应该将集群作为一个整体来考虑，而不是担心单个节点的状态。</p><p id="82aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Kubernetes中，节点将它们的资源汇集在一起，形成一个更强大的机器。当您将程序部署到集群上时，它会智能地将工作分配给各个节点。如果添加或删除了任何节点，集群将根据需要改变工作。对于程序或程序员来说，实际上是哪台机器在运行代码并不重要。</p><p id="ed84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这种类似hivemind的系统让你想起《星际迷航》中的博格人，你并不孤单；“博格”是Kubernetes基于的谷歌内部项目<a class="ae jd" href="http://blog.kubernetes.io/2015/04/borg-predecessor-to-kubernetes.html" rel="noopener ugc nofollow" target="_blank">的名字。</a></p><h2 id="bfa3" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">持久卷</h2><p id="3b4c" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">因为在集群上运行的程序不能保证在特定的节点上运行，所以数据不能保存到文件系统中的任意位置。如果一个程序试图将数据保存到一个文件中以备后用，但随后被重新定位到一个新的节点上，那么该文件将不再位于程序所期望的位置。因此，与每个节点相关联的传统本地存储被视为保存程序的临时缓存，但是不能期望本地保存的任何数据会持久。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es li"><img src="../Images/9b97f8bc2b35467d4d4633875ad61d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kF57zE9a5YCzhILHdmuRvQ.png"/></div></div></figure><p id="6784" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了永久存储数据，Kubernetes使用了<a class="ae jd" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷</a>。虽然所有节点的CPU和RAM资源都由群集有效地汇集和管理，但持久性文件存储却不是。相反，本地或云驱动器可以作为永久卷附加到集群。这可以被认为是将外部硬盘插入集群。永久卷提供了一个可以挂载到集群的文件系统，无需与任何特定的节点相关联。</p><h1 id="9af2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">软件</h1><h2 id="8ca8" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">容器</h2><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lj"><img src="../Images/81df7971d4ea3f5893ad7fb139b8afd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILinzzMdnD5oQ6Tu2bfBgQ.png"/></div></div></figure><p id="0f71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行在Kubernetes上的程序被打包成Linux容器。容器是一个被广泛接受的标准，因此已经有许多<a class="ae jd" href="https://hub.docker.com/explore/" rel="noopener ugc nofollow" target="_blank">预构建的映像</a>可以部署在Kubernetes上。</p><p id="6c91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器化允许您创建自包含的Linux执行环境。任何程序及其所有依赖项都可以打包成一个文件，然后在互联网上共享。任何人都可以下载容器并将其部署到他们的基础设施上，只需要很少的设置。创建容器可以通过编程来完成，从而允许形成强大的CI和CD管道。</p><p id="b764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以将多个程序添加到一个容器中，但是如果可能的话，应该限制每个容器只能有一个进程。最好有许多小容器，而不是一个大容器。如果每个容器都有一个紧密的焦点，更新就更容易部署，问题也更容易诊断。</p><h2 id="2bd6" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">分离舱</h2><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lk"><img src="../Images/dd28a755ca9d0b37493bd68c8f875761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OD0MgDNu3Csq0tGpS8Obg.png"/></div></div></figure><p id="efba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与您过去可能用过的其他系统不同，Kubernetes不直接运行容器；相反，它将一个或多个容器包装到一个更高级的结构中，称为<a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank"> pod </a>。同一pod中的任何容器将共享相同的资源和本地网络。容器可以很容易地与同一个pod中的其他容器通信，就像它们在同一台机器上一样，同时保持与其他容器的一定程度的隔离。</p><p id="64c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">豆荚被用作Kubernetes的复制单位。如果您的应用程序变得太受欢迎，单个pod实例无法承担负载，Kubernetes可以配置为在必要时将pod的新副本部署到集群。即使在没有重负载的情况下，标准做法是在生产系统中随时运行一个pod的多个副本，以实现负载平衡和故障抵抗。</p><p id="3fb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">豆荚可以容纳多个容器，但你应该尽可能限制自己。因为单元是作为一个单元向上和向下扩展的，所以单元中的所有容器必须一起扩展，而不管它们各自的需求。这导致浪费资源和昂贵的账单。为了解决这个问题，pod应该保持尽可能小，通常只包含一个主进程及其紧密耦合的助手容器(这些助手容器通常被称为“侧车”)。</p><h2 id="f5c6" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">部署</h2><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ll"><img src="../Images/84615b438e3dda9746605ae1095b1427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTAVk3glVD95hb-X3HiCKg.png"/></div></div></figure><p id="54b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管pods是Kubernetes中的基本计算单元，但它们通常不会直接在集群上启动。相反，pod通常由另一个抽象层管理:T2部署T3。</p><p id="aeef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署的主要目的是声明一次应该运行多少个pod副本。当一个部署被添加到集群中时，它将自动启动所请求数量的pod，然后监视它们。如果一个pod失效，部署将自动重新创建它。</p><p id="2bb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用部署，您不必手动处理pod。您只需声明系统的期望状态，它将自动为您管理。</p><h2 id="4a14" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">进入</h2><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lm"><img src="../Images/7575da4e67c7356267addb334f3d2865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBJ-_g4Mk5OkfzLEHrRsRw.png"/></div></div></figure><p id="85af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上述概念，您可以创建一个节点集群，并在集群上启动pod部署。然而，还有最后一个问题需要解决:允许外部流量进入您的应用程序。</p><p id="d52a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，Kubernetes提供了pod与外界的隔离。如果您想与pod中运行的服务进行通信，您必须打开一个通信通道。这被称为入口。</p><p id="727e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有多种方法可以向集群添加入口。最常见的方法是添加一个<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>控制器，或者一个<a class="ae jd" href="https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/" rel="noopener ugc nofollow" target="_blank">负载平衡器</a>。这两个选项之间的确切权衡超出了本文的范围，但是您必须意识到，在使用Kubernetes进行实验之前，您需要处理入口问题。</p><h2 id="ef85" class="kc jf hi bd jg kd ke kf jk kg kh ki jo iq kj kk js iu kl km jw iy kn ko ka kp bi translated">下一步是什么</h2><p id="3a4d" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">上面描述的是Kubernetes的一个过于简化的版本，但是它应该给你开始实验所需要的基础知识。既然您已经了解了组成系统的各个部分，那么是时候使用它们来部署真正的应用程序了。查看<a class="ae jd" rel="noopener" href="/@sanche/kubernetes-110-your-first-deployment-bf123c1d3f8"> Kubernetes 110:您的第一次部署</a>开始。</p><p id="55de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在本地试验Kubernetes，<a class="ae jd" href="https://kubernetes.io/docs/getting-started-guides/minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>将在您的个人硬件上创建一个虚拟集群。如果你准备尝试云服务，<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes Engine </a>有一系列<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/" rel="noopener ugc nofollow" target="_blank">教程</a>帮助你入门。</p><p id="9358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你是容器和网络基础设施的新手，我建议你阅读一下<a class="ae jd" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank"> 12因素应用方法论</a>。本文描述了在Kubernetes这样的环境中设计软件时需要记住的一些最佳实践。</p><p id="ca7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，更多类似的内容，请务必在Medium和Twitter (@DanSanche21)上关注我。</p></div></div>    
</body>
</html>