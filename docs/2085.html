<html>
<head>
<title>Structured logging in Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云中的结构化日志记录</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/structured-logging-in-google-cloud-61ee08898888?source=collection_archive---------1-----------------------#2022-02-02">https://medium.com/google-cloud/structured-logging-in-google-cloud-61ee08898888?source=collection_archive---------1-----------------------#2022-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4696" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是<a class="ae jd" href="https://minherz.medium.com/how-cloud-logging-works-series-3aab7e7a1eed" rel="noopener">云日志如何工作</a>系列的一部分。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/941290ef5f81ab8cdaab72c81caf6218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DRs0cnmqq3wLILl1"/></div></div></figure><p id="7527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结构化日志记录这一术语已经使用了很长时间。随着市场上更多的日志分析和管理解决方案的出现，这已经成为一种被广泛接受的做法。许多使用专有格式<a class="ae jd" href="https://kubernetes.io/blog/2020/09/04/kubernetes-1-19-introducing-structured-logs/" rel="noopener ugc nofollow" target="_blank">的流行解决方案将</a>迁移到使用结构化日志记录。</p><blockquote class="jq jr js"><p id="13dd" class="if ig jt ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated"><strong class="ih hj">结构化日志记录</strong>是为应用程序日志实现一致的、预先确定的消息格式的实践，允许它们被视为数据集而不是文本。</p></blockquote><p id="42fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是结构化日志记录有许多不同的定义。结构化日志记录的根本思想是将每个日志条目描述为一个对象或一条记录，以便可以使用自动化工具对其进行处理和查询。结构化日志通常使用预先确定的文本或二进制格式(如Json、XML或协议缓冲区(protobuf ))来获取，然后作为对象进行解析和存储。</p><p id="9f59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud从一开始就使用结构化日志记录。Google Cloud中的日志由<a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry" rel="noopener ugc nofollow" target="_blank"> LogEntry </a>结构描述。正如我在<a class="ae jd" rel="noopener" href="/google-cloud/how-logs-are-stored-in-cloud-logging-b6869ced0fa">中提到的</a>，它以二进制格式存储为protobuf记录。可以使用<a class="ae jd" href="https://cloud.google.com/logging/docs/view/building-queries" rel="noopener ugc nofollow" target="_blank">日志浏览器</a>或通过<a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/entries/list" rel="noopener ugc nofollow" target="_blank">日志API</a>来查询和分析日志。可以将日志条目导出到<a class="ae jd" href="https://cloud.google.com/logging/docs/export/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>或使用<a class="ae jd" href="https://cloud.google.com/logging/docs/log-analytics" rel="noopener ugc nofollow" target="_blank">日志分析</a>进行更复杂的分析。</p><h1 id="cbde" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">日志结构布局</h1><p id="9d70" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">存储在结构化日志中的信息可以大致分为三类:</p><ul class=""><li id="435c" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated"><strong class="ih hj">关于日志条目</strong>的信息，描述该日志条目何时被创建和接收，它在其他日志条目中的顺序，通常被称为<em class="jt">严重性</em>的“日志级别”等。</li><li id="ba61" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj">创建日志的上下文</strong>描述关于日志生成环境的元数据、生成日志的源代码位置等。</li><li id="58b6" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj">日志的有效负载</strong>，包含开发者定义的数据和元数据。</li></ul><p id="c334" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在云日志中，<a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry" rel="noopener ugc nofollow" target="_blank"> LogEntry </a>结构的<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.log_name" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">logName</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.timestamp" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">timestamp</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.receiveTimestamp" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">receivedTimestamp</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.severity" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">severity</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.insert_id" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">insertId</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.trace_sampled" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">traceSampled</strong></a></code>字段存储日志条目的信息。在<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.resource" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">resource</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.http_request" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">httpRequest</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.operation" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">operation</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.trace" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">trace</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.span_id" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">spanId</strong></a></code>、<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.source_location" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">sourceLocation</strong></a></code>字段中捕获日志上下文。数据有效负载包括以字符串的键值对集合形式存储在<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.labels" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">labels</strong></a></code>字段中的调用者元数据，以及可以作为纯文本存储在<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.text_payload" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">textPayload</strong></a></code>字段中或者作为Json对象存储在<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.json_payload" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">jsonPayload</strong></a></code>字段中的应用程序数据。还有第三种选择，使用<code class="du lo lp lq lr b"><a class="ae jd" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#FIELDS.proto_payload" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">protoPayload</strong></a></code>字段将应用程序的日志数据存储为protobuf有效负载。protobuf有效负载通常由各种Google云服务使用。此外，它只能通过调用日志API来获取。</p><blockquote class="jq jr js"><p id="b732" class="if ig jt ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">记住<strong class="ih hj">结构化日志</strong>和<strong class="ih hj">结构化负载</strong>是<strong class="ih hj">不同的</strong>。前者可以离开后者而存在，但反之则不行。</p></blockquote><h1 id="9e97" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">如何写日志</h1><p id="ad23" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">当应用程序<a class="ae jd" rel="noopener" href="/google-cloud/how-cloud-logging-works-series-3aab7e7a1eed#967c">向远程目的地发送日志</a>时，方法会因日志管理解决方案、本地日志框架和应用程序环境而异。云日志公开了日志v2 API，可以通过REST或gRPC直接调用，或者使用专用的日志框架适配器调用。开发者也可以使用Google提供的日志客户端库(7种编程语言)。这些选项将日志直接接收到云日志后端。此外，还可以利用Google云平台中的日志代理，将日志摄取任务“委托”给代理。拥有日志代理的平台有<a class="ae jd" href="https://cloud.google.com/appengine/docs/flexible/python/writing-application-logs#writing_structured_logs" rel="noopener ugc nofollow" target="_blank"> AppEngine </a>、<a class="ae jd" href="https://cloud.google.com/stackdriver/docs/solutions/gke/managing-logs" rel="noopener ugc nofollow" target="_blank"> GKE </a>、Cloud Run、<a class="ae jd" href="https://cloud.google.com/functions/docs/monitoring/logging" rel="noopener ugc nofollow" target="_blank">云函数</a>、Cloud Build、DataProc和DataFlow。代理必须<a class="ae jd" href="https://cloud.google.com/logging/docs/agent/logging/installation" rel="noopener ugc nofollow" target="_blank">显式安装</a>在GCE实例上，然后可以<a class="ae jd" href="https://cloud.google.com/logging/docs/agent/logging/installation#configure-agent" rel="noopener ugc nofollow" target="_blank">配置</a>来支持日志捕获。当在带有日志代理的平台上运行应用程序时，只需将日志打印到<code class="du lo lp lq lr b">stdout</code>或<code class="du lo lp lq lr b">stderr</code>就可以将日志接收到云日志中。代理支持捕获纯文本和结构化负载。受支持的结构化有效负载应该格式化为单行Json字符串。有效载荷可以包括代理解析并存储到上下文信息字段中的<a class="ae jd" href="https://cloud.google.com/logging/docs/structured-logging#special-payload-fields" rel="noopener ugc nofollow" target="_blank">特殊字段</a>(例如<code class="du lo lp lq lr b"><strong class="ih hj">httpRequest</strong></code>)。以下信息<strong class="ih hj">不能使用特殊字段</strong>提供:</p><ul class=""><li id="f282" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated"><code class="du lo lp lq lr b"><strong class="ih hj">logName</strong></code>字段——将结构化有效载荷打印到<code class="du lo lp lq lr b">stdout</code>时，无法自定义日志的目的地或其名称</li><li id="3ac5" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><code class="du lo lp lq lr b"><strong class="ih hj">resource</strong></code>字段—代理自行填充资源字段。无法自定义该字段。</li></ul><p id="5544" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读<a class="ae jd" href="https://cloud.google.com/logging/docs/structured-logging" rel="noopener ugc nofollow" target="_blank">公共文档</a>关于支持的特殊字段和其他细节。</p><p id="94fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用日志代理接收日志有一定的好处。我将尝试捕捉下面的主要利弊。</p><h2 id="66b0" class="ls jy hi bd jz lt lu lv kd lw lx ly kh iq lz ma kl iu mb mc kp iy md me kt mf bi translated">使用日志代理接收日志的优势</h2><p id="8e39" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><strong class="ih hj">打印到stdout </strong> <strong class="ih hj">很简单</strong>。它不需要额外的库，也不需要关心通信延迟、可能的重试机制和错误处理。</p><p id="6890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">就是快</strong>。任何API调用都需要时间，这取决于网络延迟、后端延迟和其他因素。即使异步执行通信部分，应用程序也应该在完成API调用所需的时间内保持运行。打印到stdout就像调用(几乎)任何其他系统调用一样。</p><p id="6936" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">是无资源</strong>。API调用需要使用CPU、内存、网络等资源。在prem上运行时，哪个组件消耗硬件资源并不重要，因为同一主机上的所有应用程序都会受到影响。在云环境中，情况有所不同。诸如Cloud Run之类的受管环境将具有为部署分配的专用资源(例如CPU ),这些资源不同于日志记录代理所使用的资源。</p><h2 id="89cf" class="ls jy hi bd jz lt lu lv kd lw lx ly kh iq lz ma kl iu mb mc kp iy md me kt mf bi translated">使用日志代理时的注意事项</h2><p id="e7d1" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><strong class="ih hj">单行Json字符串的格式化</strong>要求并不像看起来那样容易实现。除非使用专门的库，否则正确格式化的负担就落在了应用程序开发人员的身上。虽然未能实现正确的格式不会导致有效载荷的丢失，但它可能会导致产生难以处理的有效载荷。</p><p id="f3ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">并非所有平台和环境</strong>都有日志代理。也没有一个通用的方法来识别所有平台的日志代理。在没有日志代理的平台上运行这样的应用程序会导致将日志打印到stdout，而不会将日志接收到云日志后端。</p><p id="9d6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">限制</strong>比如无法控制日志目的地，这对于在一个Google Cloud项目中运行但需要将日志接收到另一个项目中的应用程序来说可能是至关重要的。</p><h1 id="8e1b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">开发者工具</h1><p id="8c64" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我提到Google用7种语言维护<a class="ae jd" href="https://cloud.google.com/logging/docs/reference/libraries" rel="noopener ugc nofollow" target="_blank">日志客户端库</a>:Java、Python、NodeJS、Golang、C#、Ruby和PHP。这些库在Github上由<a class="ae jd" href="https://github.com/googleapis" rel="noopener ugc nofollow" target="_blank"> googleapis </a>组织维护。这些库有两种类型:</p><ul class=""><li id="062c" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated"><em class="jt">自动生成</em> —基于API的protobuf定义生成的客户端库；这些库为使用gRrpc传输层实现对API的低级调用提供了存根:</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mg"><img src="../Images/d506e3118ea3b0f222b2c87f81d511fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*OX7uv1Fa4d2UaYtg"/></div></figure><ul class=""><li id="b956" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">手写—由Google DevRel工程师开发和维护的客户端库，使用自动生成的存根，与自动生成的库相比，提供了最佳实践和改进的开发体验:</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mh"><img src="../Images/7ec7f839ded9eeead7d7b22ca586fa06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*bNcMumiU5zp9wx_T"/></div></figure><h2 id="8f28" class="ls jy hi bd jz lt lu lv kd lw lx ly kh iq lz ma kl iu mb mc kp iy md me kt mf bi translated">记录客户端库</h2><ul class=""><li id="b414" class="la lb hi ih b ii kv im kw iq mi iu mj iy mk jc lf lg lh li bi translated"><strong class="ih hj"> Python </strong>客户端库发布了第3版，扩展了对自动填充上下文元数据的支持，集成了标准Python日志记录和JSon格式化程序，可用于日志记录代理。在<a class="ae jd" href="https://cloud.google.com/blog/products/devops-sre/google-cloud-logging-python-client-library-v3-0-0-release" rel="noopener ugc nofollow" target="_blank">最新消息</a>帖子中阅读更多已发布功能的详细概述。</li><li id="0f62" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj"> Java </strong>客户端库扩展了对自动填充附加上下文元数据的支持，并在JUL和logback适配器中集成了日志代理。在<a class="ae jd" href="https://cloud.google.com/blog/products/devops-sre/google-cloud-logging-java-client-library-new-features" rel="noopener ugc nofollow" target="_blank">云博客</a>中了解更多。</li><li id="ae4e" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">版本9.9+中的NodeJS 客户端库开始支持一组类似的自动元数据填充，用于接收日志条目。最近在<a class="ae jd" href="https://cloud.google.com/blog/products/devops-sre/get-more-insights-with-the-new-version-of-the-nodejs-library" rel="noopener ugc nofollow" target="_blank">云博客</a>发布的帖子解释了细节。</li><li id="c181" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj">Go</strong>1 . 5 . 0版本中的客户端库通过添加关于源位置信息的元数据、对W3C上下文跟踪的支持以及提供对进程外日志摄取的支持，完成了对结构化日志的支持。在云博客的专栏中阅读更多信息。</li></ul></div></div>    
</body>
</html>