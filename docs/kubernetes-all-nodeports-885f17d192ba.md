# Kubernetes 所有节点端口

> 原文：<https://medium.com/google-cloud/kubernetes-all-nodeports-885f17d192ba?source=collection_archive---------0----------------------->

我正在为 Hyperledger Fabric 做一个更动态的舵图。这种动态性(可能)需要动态数量的节点端口。

***抛开*** *:我仍然不确定是否每个对等体的服务都需要其端口以这种方式暴露在集群之外。*

但是，当我采用这种方法时，列举集群公开的所有节点端口对我来说很有用。您可能会对该代码感兴趣。如果没有别的，它显示了为 Kubernetes 使用 [Go(lang)客户端是多么容易。](https://github.com/kubernetes/client-go)

两条路，当然

两者都源自客户回购中提供的集群外示例。

## 排序切片

第一个排序切片。首先，在编写了基于树的解决方案(参见“第二个”)之后，我写了这个简化版。

消费者 go-routine ( `#63–75`)在包含集群的节点端口列表(可能是未排序的)的通道上进行搜索，将它们插入一个片，并对该片进行排序。单个结果被放在一个`result`通道上，阻塞 go 例程，直到该消息的消费者读取它并返回结果，从而结束程序(`#103`)。因为通道读|写被阻塞，所以没有必要等待 go-routine。

生产者 go-routines ( `#78–99`)形成一个层级。因为 Kubernetes Go 客户端允许枚举所有集群的服务，而不考虑名称空间，所以为每个服务创建一个 Go 例程。每个服务可能会公开 n(？)NodePorts，虽然这个数字很小，但是对于 giggles，我们创建了一个 go-routine 来处理它们中的每一个(可能很浪费！？).

在我们检查服务之前，我们不知道它是否公开了节点端口，也不知道有多少。因此，当我们遍历服务和它们的端口时，我们为每个创建的 go-routine 增加一个 WaitGroup，并且每个 go-routine 推迟(减少)WaitGroup 的`Done`。

`Wait` ( `#97`)上的代码块。一旦所有 go-routines 完成，代码将继续等待，下一步是`close`通道。这就结束了消费者的(！)`range` ( `#71`)，它已经将端口(当它们到达时)附加到一个片上。切片被排序并返回。

## 行走的树木

最初，我使用树(而不是切片)作为端口排序的基础。网上有很多例子，但我喜欢 Golang 在类型上的方法，在这种情况下，会使代码变得复杂。我心中的纯粹主义者认为树只是节点，但是我们必须先实例化一个类型(不能是`nil`)然后才能对它使用方法，因此，我们将使用一个树类型，它的根属性是 Node 类型，然后是 nodes 类型:

并且:

除了在`main.go`的进口中引用`useful.go`，唯一的变化是消费者的日常行为。我们现在使用一个`Tree` ( `#66`)，我们将`Insert` ( `#69`)移植到它，我们将`Walk`它(`#73`)的值排序。

运行任何一种方法都应该(！)在您的`current-context`的节点端口中打印集群的一部分。