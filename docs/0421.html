<html>
<head>
<title>Whack a Pod Update</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重击一个Pod更新</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/whack-a-pod-update-c4fa33c84cf1?source=collection_archive---------0-----------------------#2017-10-31">https://medium.com/google-cloud/whack-a-pod-update-c4fa33c84cf1?source=collection_archive---------0-----------------------#2017-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些人问我关于在Minikube上运行what-a-Pod的问题。为了做到这一点，我需要对项目的各个部分进行一些修改。实际上，what-a-Pod假设您可以访问容器引擎、容器构建器和容器注册表。我认为你需要很多这些功能来运行它，我知道我不能指望Minikube的所有功能。所以事情必须改变。但是当我改变它的时候，我抓住机会做了一些调整…</p><h1 id="c418" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">变化1:消除YAML文件</h1><p id="c3f4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">所有的配置都存储在YAML的文件中。这无疑使kubectl更容易处理，因为您不必学习它的所有排列。你只需要记住kubectl apply -f文件名。这很好，但它导致了一种情况，在这种情况下，为了处理可变的项目设置，我让用户在设置过程中动态地创建大量的yaml文件，而不是直接用kubectl命令使用变量。</p><p id="e4a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，我还管理几个不同的集群。在集群之间切换意味着我每次都必须重新创建配置。如果我忘了做，我就搞砸了其他集群。将配置从yaml文件移动到从Makefile调用的kubectl命令中的设置，使我能够利用Makefile中的变量，而不是重新构建yaml文件。</p><p id="5346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一变化消除了大量Makefile代码和yaml。这导致较少的系统更改泄漏到代码库中，然后需要更新到映像中，然后推送到容器<br/>注册表中。但不是全部——我仍然在基于我正在创建的各种服务端点创建一个JavaScript配置文件，并且每次我推送到不同的集群时，js文件都需要更新、烘焙成一个映像并推送到容器注册表。</p><h1 id="398d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">变化2:从服务负载平衡器切换到入口</h1><p id="e17d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在演示亭运行后，我根据收到的反馈添加到what-a-Pod的一个功能是展示一些管道内部结构，以促进关于Kubernetes的更深入的对话。我制作了一个高级视图，展示了底层节点，增加了杀死和复活节点的能力(实际上是<em class="kh">警戒线</em>和<em class="kh">非警戒线</em>，因为杀死节点相对于游戏长度来说需要很长时间来重建)，并包括一种方法来显示我们的哪个pod实际上在服务请求。有一件事立刻变得很明显，那就是我不明白事情是如何进行的。我期望应答pod到处反弹，但是它没有——它一直粘在最后一个应答请求的pod上。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/6ee4e106c099cffbde0dc4b36f17a8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/0*EkYMcFDUSuXQzDQd."/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">在进入之前重击一个荚荚行为</figcaption></figure><p id="b68a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一天，凯尔西·海托华在办公室，我问他这件事。正如凯尔西所做的那样，他给了我一个经过深思熟虑的非常技术性的解释，解释了为什么会发生这种情况，并给出了一个处方:<strong class="ih hj">切换到入口</strong>。我能抓住第二部分。</p><p id="2024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/container-engine/docs/tutorials/http-balancer" rel="noopener ugc nofollow" target="_blank">在容器引擎</a>上切换到入口实际上非常容易。这是容器引擎大放异彩的地方之一，为您的集群做系统工作非常简单。</p><ol class=""><li id="ea2e" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">将服务从负载平衡器更改为节点端口</li><li id="1394" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">为入口请求一个全局IP作为其公共IP。</li><li id="dbdc" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">在Kubernetes上创建一个入口资源，将服务指向路径。</li></ol><p id="59d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我的容器端口、服务端口、节点端口和入口端口以及容器路径对齐有点困难。主要是因为我在容器上使用端口8080并输出到80，但文档一直是80。事情很相似，足以给我带来问题。但是经过一点点的试错(和RTFM)，我让它运行起来了。这有两大优势:</p><ol class=""><li id="27fb" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">我可以在同一个主机上服务所有的服务，这意味着我不再需要像上面提到的那样将JavaScript配置放入图像中——一切都可以在UI中用相对路径来处理。</li><li id="1c6c" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">答案框的行为改变了，正如我所料，它在所有的框中跳动。</li></ol><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/a182387b1fd0c6b774b8e7193edece6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/0*H1qGa8FlOifu5G8M."/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">进入后重击一个荚荚行为</figcaption></figure><p id="4991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有一个缺点，它在设置中添加了一个yaml文件，因为除了kubectl apply之外，Ingress不能通过直接的kubectl选项获得。为它给我买的东西付出的小小代价。</p><h1 id="87ef" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">变化3:使容器规范化</h1><p id="a8ba" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">切换到Ingress有一个额外的好处，就是让容器更少地根据它们运行的项目进行定制。拥有一台主机意味着前端的所有API调用都可以指向/path，而不是hostname/path。这反过来意味着游戏容器中不再有定制的JavaScript。事实上，每个项目定制的所有容器中只有一个文件:/apps/admin/containers/deployment . JSON。定制位将它指向正确的Docker存储库——在我的例子中，是在Google容器注册表中。我将它改为一个在部署过程中注入的env变量。这要容易得多，因为我已经用kubectl命令而不是yaml完成了整个工作。现在容器是规范的——如果你愿意，你可以通过从我的容器图片中提取来运行what-a-Pod。不要——你不应该相信我和我的Docker图片。但是如果你想的话你可以。</p><h1 id="0359" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">变化4:收缩容器</h1><p id="d155" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在我第一次构建各种各样的应用程序时，我用PHP编写了管理和颜色api组件，用HTML/JS/CSS编写了游戏/ui。对于我的基本容器图像，我使用了谷歌云平台的<a class="ae jd" href="https://github.com/GoogleCloudPlatform/php-docker" rel="noopener ugc nofollow" target="_blank">应用引擎PHP灵活Docker图像</a>。这很容易上手，GCP的SDK已经在上面了，我知道并且信任作者<a class="ae jd" href="https://twitter.com/tmatsuo" rel="noopener ugc nofollow" target="_blank">松尾隆</a>。这让我可以非常快速地构建一切。不利的一面是图像最终变得非常大:</p><ul class=""><li id="90c0" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc li la lb lc bi translated">游戏181 MB</li><li id="400d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">api 171 MB</li><li id="656d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">管理171 MB</li><li id="6dcb" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">总计523 MB</li></ul><p id="14bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到<a class="ae jd" href="https://hub.docker.com/r/library/php/tags/" rel="noopener ugc nofollow" target="_blank"> PHP的标准Docker镜像</a>的内存在150-160 MB的范围内，170-180并不算太差。但这仍然意味着疯子接手了一半的工作。我觉得我可以做得更好。不仅仅是为了获得更小的数量，更重要的是，更小的映像意味着更快的部署，并且可能更容易在Minikube上运行what-a-Pod。(因为这些Minikube机器可能会被安装在Wi-Fi经常出现问题的会议上。)</p><p id="d047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先我接手了游戏部分。游戏全是HTML/JS/CSS。因为没什么大不了的，所以我认为一个普通的NGINX服务器就能很好地处理它，事实也确实如此。这使得游戏容器从181 MB降到了49 MB。还不错。</p><p id="0151" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我负责管理服务。管理和api服务都只是API——其中之一或两者都可以在Go中重写。这样做可以让我消除许多依赖。事实上，我应该能够在基于暂存映像的最小Docker容器中运行这些。然后你只需交叉编译一个Go可执行文件并附加。查看Nick Gauthier的指南<a class="ae jd" href="https://blog.codeship.com/building-minimal-docker-containers-for-go-applications/" rel="noopener ugc nofollow" target="_blank">建造最小的码头集装箱</a>。在Go中重写管理服务也意味着我可以利用Kubernetes 的<a class="ae jd" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go。我期望它写起来超级简单(结果错了)。</a></p><p id="e59e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用Kubernetes的客户端完全重写了它。这使我的图像下降到4 MB。当我单独测试每个操作时，这个版本是有效的。但是当我运行游戏时，我开始在入口的负载平衡器上出现奇怪的错误。大部分翻译成“后端超时”。我摆弄了一下client-go的设置，但当我开始调整QPS的设置时，我在相关的库中遇到了错误。事实证明，我所做的重复轮询与限制客户端的设置不兼容。</p><p id="111e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我觉得client-go对我来说太聪明了。它在进行某种速率限制，文档不是那么容易被发现——也不是stackoverflowable(那是一个词吗？).我想了很久，决定绕过client-go，为Kubernetes API编写自己的客户端——认为至少这样我就能完全理解它。我只需要把我为之前版本写的PHP代码翻译成Go。这最终变得更加容易和快速，并且因为它不依赖于client-go，所以在构建容器时也更加轻便。我的管理容器从4 MB增加到2MB。</p><p id="5585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我采用了API服务，这非常简单。它有两个端点:一个只是给出了一个随机颜色，另一个给出了一个带有随机颜色和主机名的JSON对象，在Kubernetes上主机名是pod的名称。这个非常简单，将API容器从171 MB扩展到2MB。</p><p id="a54d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，通过切换到最简单的映像，我可以完成工作(在一种情况下是基于NGINX，在scratch Docker映像上运行Go可执行文件)，我能够实现Docker映像大小的以下缩减:</p><ul class=""><li id="6765" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc li la lb lc bi translated">游戏181 MB -&gt; 49 MB</li><li id="a22d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">api 171 MB -&gt;2 MB</li><li id="d65e" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">管理171 MB -&gt;2 MB</li><li id="e521" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc li la lb lc bi translated">总计523 MB -&gt;53 MB</li></ul><h1 id="42ca" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">变化五:Minikube和Xhyve</h1><p id="9083" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我已经做好了准备，要让what-a-Pod在Minikube上工作，我必须做大量的工作。事实证明，这真的很容易做到。我不得不:</p><ol class=""><li id="7f60" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">安装Minikube</li><li id="276e" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">启用入口</li><li id="9c80" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">创建一个我已经拥有的入口yaml的副本:<br/>没有GKE注释<br/>，引用主机“wap.io”</li><li id="a71a" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">编辑/etc/host以将Minikube的外部可用IP地址指向wap.io</li></ol><p id="91c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我启动了它，但是遇到了一点小麻烦。表演有点慢。您可以轻松地关闭集群中的所有pod，它们会停止运行并中断服务。我四处打听，我的同事<a class="ae jd" href="https://twitter.com/ahmetb?lang=en" rel="noopener ugc nofollow" target="_blank"> Ahmet Alp Balkan </a>告诉了我关于<a class="ae jd" href="https://github.com/zchee/docker-machine-driver-xhyve" rel="noopener ugc nofollow" target="_blank"> xhyve </a>的事情。Xhyve是一个hypervisor，它使得在Mac上运行Linux成为可能。它可以和Minikube一起使用，并且可以将吊舱部署速度提高400%。有了xhyve，现在的性能足够快，可以为重击一个pod提供合理的游戏体验。</p><p id="db01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不得不改变UI来处理与Minikube的细微差别。完整的高级用户界面允许你杀死一个节点。(不完全是，您可以取消调度一个节点，然后杀死其上的所有pod)。但是由于Minikube是一个单节点集群，您可能不应该取消它——因为应用程序的其余部分需要一个节点来运行——所以我在UI中禁用了这个功能。</p><h1 id="0133" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="4760" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">以一个目标开始的——在Minikube上运行what-a-Pod——以一点点牦牛毛屑结束。但是所有的改变似乎都是值得的。我希望这些更新能让你更容易尝试自己动手。所有的改动目前都可以在github 上的<a class="ae jd" href="https://github.com/tpryan/whack_a_pod" rel="noopener ugc nofollow" target="_blank">重击一个Pod获得。</a></p></div></div>    
</body>
</html>