<html>
<head>
<title>Search on Google Cloud Platform — App Engine and Search API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在谷歌云平台上搜索—应用引擎和搜索API</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/search-on-google-cloud-platform-app-engine-and-search-api-31cda6917bbf?source=collection_archive---------2-----------------------#2018-07-04">https://medium.com/google-cloud/search-on-google-cloud-platform-app-engine-and-search-api-31cda6917bbf?source=collection_archive---------2-----------------------#2018-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7d79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有几次遇到“在谷歌云平台上搜索”的话题，也就是人们问如何以不同的方式实现搜索的问题。不确定这是不是谷歌云测试或考试的一部分，但这是一个有趣的话题，GCP提供了不同的方法来做这件事，所以我决定就这个话题做系列报道。所以在每篇文章中，我都想描述一种实现方式，以及代码解释和负载测试。</p><p id="7694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任务描述是这样的:“假设你是eshop，你想实现你的产品描述功能的自动完成，所以当用户在搜索框中键入一些词，他们会得到包含这些词的产品。你如何在GCP上实现可伸缩性、快速性等……”</p><p id="55dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">文本搜索本身是一个主要话题，它提供了不同的功能和方法，我不认为自己是一个专家，所以如果我遗漏了什么，请原谅我。</p><p id="720f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获得Best Buy在github repository上拥有的一些真实数据，其中包含大约50000种产品的数据。为了真正模拟我在Kaggle数据集<a class="ae jd" href="https://www.kaggle.com/c/acm-sf-chapter-hackathon-big/data" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/c/acm-sf-chapter-hackathon-big/data</a>上发现的大eshop(需要注册才能获得产品文件。)包含了超过百万的产品，这已经是一个很有趣的数字了。我写了一个小脚本来提取所有必要的信息，因为它是xml格式的，并且在多个文件中。我不会得到所有的数据，因为每个产品大约有70个字段。</p><p id="fcd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有代码都在github.com<a class="ae jd" href="https://github.com/zdenulo/gcp-search" rel="noopener ugc nofollow" target="_blank">https://github.com/zdenulo/gcp-search</a>上，并且是用Python 3写的(有些代码只在Python 2中运行，就像这种情况)。</p><h1 id="0578" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">一般建筑</h1><p id="f2c8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了实现功能，我们需要一些输入字段前端输入文本将被搜索，然后显示结果。为此，我将使用jQuery自动完成库，该库通过输入查询向服务器发出请求，然后自动显示结果。</p><p id="d180" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将需要一些后端服务器，我将使用谷歌应用引擎(GAE)(标准和灵活的，主要是灵活的)，因为它很容易部署和自动伸缩。</p><p id="f350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，我们还需要一些存储空间，用于存储产品的数据，以供搜索之用，这是本系列的全部精髓。事实是，电子商店有更复杂的数据库架构，但我在这里简化了，因为我们只对搜索功能感兴趣。通常情况下，你会有常用的东西(与产品相关的属性)存储在数据库中的某个地方，只有在搜索引擎和参考之间的搜索(产品名称)的东西。</p><h1 id="4fa6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">提取信息。</h1><p id="21ec" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">从Kaggle网站下载product_data.tar.gz并解包后，运行脚本extract_product_data.py会将多个xml文件中的部分信息提取到一个csv文件中。每个产品有十几个字段，但我只保存了几个，也许我不会使用所有这些。显然，产品名称是最重要的。Csv文件不包括在存储库中，因为它大约有260MB大:)。</p><h1 id="6974" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">前端</h1><p id="1b88" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">前端简单明了。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c29b" class="kq jf hi km b fi kr ks l kt ku">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;title&gt;Autocomplete&lt;/title&gt;<br/>    &lt;link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css"&gt;<br/>    &lt;script src="https://code.jquery.com/jquery-1.12.4.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"&gt;&lt;/script&gt;<br/>    &lt;script&gt;<br/>        $(function() {<br/>            $("#search").autocomplete({<br/>                source: function (request, response) {<br/>                    $.ajax({<br/>                        dataType: "json",<br/>                        url: "/search",<br/>                        data: {query: request.term},<br/>                        success: function (data) {<br/>                            response(data);<br/>                        }<br/>                    })<br/>                },<br/>                minLength: 2<br/>            });<br/>        });<br/>    &lt;/script&gt;<br/>&lt;body&gt;<br/>&lt;div class="ui-widget"&gt;<br/>    &lt;form&gt;<br/>        &lt;input type="text" id="search" size="55" &gt;<br/>    &lt;/form&gt;<br/>&lt;/div&gt;<br/><br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="51ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上就像我之前写的那样，我使用jQuery自动完成库，它只需很少的设置就可以自动查询/搜索url，发送输入的查询并呈现接收到的结果。</p><h1 id="da4b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">搜索API</h1><p id="d10b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如我在开头所写的，我将使用的第一个服务/产品是搜索API，它集成在谷歌应用引擎标准中。</p><p id="021a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搜索API的一些高级概述:</p><ul class=""><li id="3cde" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">没有设置。喜欢的连单线，价值什么的都没有…惊艳:)。在应用程序的代码中，你需要用名字定义索引对象，基本上你需要为插入、查询等打包代码。</li><li id="2b98" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">API包含在GAE标准SDK中。不幸的是，搜索API不能在GAE标准之外使用(甚至不够灵活)。如果您想在GAE标准上创建应用程序并使用搜索API，应该考虑到这一点。</li><li id="d02f" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">我听说有计划将搜索API作为独立服务在GAE之外提供，但我不知道什么时候能实现。</li><li id="9d04" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">每天有0.25GB存储数据、1000次搜索查询和0.01GB添加到索引的数据的免费配额。</li><li id="7a87" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">定价如下:10，0 00次查询成本为0.5美元，存储成本为0.18美元/GB，数据索引成本为2美元/GB。</li><li id="af8f" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">根据你的情况和预算，它可能有点贵，使用memcache服务来缓存结果，你可以减少搜索查询的数量。</li><li id="29e9" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">关于伸缩性，每分钟最多有100分钟的查询执行时间(我承认我不明白这是什么意思)</li><li id="2b42" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">数据需要保存在结构化文档中(有几种字段类型，如文本、数字、日期、地理、HTML、Atom)。文档可以包含多个字段。一个文档最多可以有1MB。</li><li id="e5cd" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">文件需要存储在“索引”，每个项目可以有多个索引。对索引执行搜索查询。</li><li id="8e30" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">您可以为文档提供id，也可以自动生成。使用文档id，您可以更新文档的字段值。</li><li id="f4aa" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">单个索引可以有10GB的最大大小，可以通过向GCP提交请求增加到200GB，每个项目/应用程序可以有无限的索引。</li><li id="5e1f" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">每分钟添加的最大文档数为15000(每秒250)，但一次最多可插入200个文档(一个请求)。这对我们大约100万的产品上传有一定的时间影响。</li></ul><h2 id="d50b" class="kq jf hi bd jg lj lk ll jk lm ln lo jo iq lp lq js iu lr ls jw iy lt lu ka lv bi translated">搜索API查询</h2><p id="3b55" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有许多有趣的搜索功能:</p><ul class=""><li id="fb0f" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">查询多个字段(使用布尔运算符)</li><li id="feb9" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">地理查询，即根据纬度和经度在某个半径范围内搜索文档。当然，文档需要有Geo字段才能工作。</li><li id="c70d" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">如果你有文本“google”的文档，搜索查询是“goo ”,它会返回结果，但是如果你搜索“ogl ”,它不会。</li><li id="eb6c" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">您可以从结果中创建片段，结果是包含查询字符串和周围文本的文本。</li><li id="b0d7" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">分面搜索—搜索查询可以返回子类别和文档数量，这可用于进一步细化搜索。</li><li id="f31e" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">可以根据不同的属性对查询结果进行排序，比如搜索词频率。</li></ul><h1 id="4e9c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">GAE网络应用</h1><p id="74fa" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我使用App Engine，因为这是使用搜索API的唯一方法，但除此之外，它是轻量级的，易于部署，自动伸缩。</p><p id="15ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">web应用程序的代码在文件夹<a class="ae jd" href="https://github.com/zdenulo/gcp-search/tree/master/gae_search_api/webapp" rel="noopener ugc nofollow" target="_blank"> gae_search_api/webapp </a>中。如前所述，应用程序运行在GAE标准(Python 2)上，我将解释最重要的部分。</p><p id="c5c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">py包含了SearchEngine类，我将用它来包装所有与搜索相关的操作。</p><p id="5c97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/zdenulo/gcp-search/blob/master/gae_search_api/webapp/search_api.py" rel="noopener ugc nofollow" target="_blank"> search_api.py </a>包含使用Search API实现SearchEngine类，这里是完整代码。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0095" class="kq jf hi km b fi kr ks l kt ku">from search_base import SearchEngine<br/><br/>from google.appengine.api import search<br/><br/><br/>class SearchAPI(SearchEngine):<br/>    """GAE Search API implementation, can be used only withing GAE"""<br/><br/>    def __init__(self, client=None):<br/>        self.client = search.Index('products')  # setting Index<br/><br/>    def search(self, query):<br/>        """Making search with SearchAPI and returning result"""<br/>        try:<br/>            search_results = self.client.search(query)<br/>            results = search_results.results<br/>            output = []<br/>            for item in results:<br/>                out = {<br/>                    'value': item.field('name').value,<br/>                    'label': item.field('name').value,<br/>                    'sku': item.field('sku').value<br/>                }<br/>                output.append(out)<br/>        except Exception:<br/>            output = []<br/>        return output<br/><br/>    def insert(self, item):<br/>        """Inserts document in the Search Index"""<br/>        doc = search.Document(<br/>            fields=[<br/>                search.TextField(name='name', value=item['name']),<br/>                search.TextField(name='sku', value=item['sku']),<br/>            ]<br/>        )<br/>        self.client.put(doc)<br/><br/>    def insert_bulk(self, items):<br/>        docs = []<br/>        for item in items:<br/>            doc = search.Document(<br/>                fields=[<br/>                    search.TextField(name='name', value=item['name']),<br/>                    search.TextField(name='sku', value=item['sku']),<br/>                ]<br/>            )<br/>            docs.append(doc)<br/>        self.client.put(docs)<br/><br/>    def delete_all(self):<br/>        while True:<br/>            document_ids = [<br/>                document.doc_id<br/>                for document<br/>                in self.client.get_range(ids_only=True)]<br/><br/>            # If no IDs were returned, we've deleted everything.<br/>            if not document_ids:<br/>                break<br/><br/>            # Delete the documents for the given IDs<br/>            self.client.delete(document_ids)</span></pre><p id="e06e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有太多要解释的，除了我只插入了两个产品字段name和sku，我在文档中使用它们作为文本字段</p><p id="7f2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Web应用程序(文件<a class="ae jd" href="https://github.com/zdenulo/gcp-search/blob/master/gae_search_api/webapp/main.py" rel="noopener ugc nofollow" target="_blank"> main.py </a>)是用Flask编写的，它实现了一些通用的URL，比如保存产品数据(因为我们只能在GAE应用程序中使用搜索API)、搜索和删除，当然还有自动完成的html页面。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="90e0" class="kq jf hi km b fi kr ks l kt ku">import logging<br/><br/>from flask import Flask, render_template, request<br/>from flask.json import jsonify<br/><br/>from google.appengine.ext import deferred<br/><br/>from search_api import SearchAPI<br/><br/>app = Flask(__name__)<br/><br/>search_client = SearchAPI()<br/><br/><br/>@app.route('/')<br/>def index():<br/>    return render_template('index.html')<br/><br/><br/>@app.route('/search')<br/>def search():<br/>    """based on user query it executes search and returns list of item in json"""<br/>    query = request.args.get('query', '')<br/>    results = search_client.search(query)<br/>    return jsonify(results)<br/><br/><br/>@app.route('/upload', methods=['POST'])<br/>def upload():<br/>    """gets list of products and saves into search index"""<br/>    json_data = request.get_json()<br/>    search_client.insert(json_data)<br/>    return 'ok'<br/><br/><br/>@app.route('/upload_bulk', methods=['POST'])<br/>def upload_bulk():<br/>    """gets list of products and saves into search index"""<br/>    json_data = request.get_json()<br/>    logging.info("received {} items".format(len(json_data)))<br/>    search_client.insert_bulk(json_data)<br/>    return 'ok'<br/><br/><br/>@app.route('/delete')<br/>def delete():<br/>    """deletes all items in search"""<br/>    deferred.defer(search_client.delete_all)<br/>    return 'ok'</span></pre><p id="ab5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要上传GAE web应用，你需要安装<a class="ae jd" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank"> Cloud SDK </a>。在应用程序上传之前，您需要首先在本地安装一些库(这些库将随应用程序一起上传)。</p><p id="5eca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在webapp文件夹中执行命令:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4240" class="kq jf hi km b fi kr ks l kt ku">&gt;pip install -r requirements.txt -t lib</span></pre><p id="bd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在文件夹<a class="ae jd" href="https://github.com/zdenulo/gcp-search/tree/master/gae_search_api/load_data" rel="noopener ugc nofollow" target="_blank"> load_data </a>中，有脚本<a class="ae jd" href="https://github.com/zdenulo/gcp-search/blob/master/gae_search_api/load_data/upload.py" rel="noopener ugc nofollow" target="_blank"> upload.py </a>从csv文件中读取数据并向GAE应用程序发出请求。我们被限制为每个请求插入200个文档，因为我正在进行批量导入，每秒250个文档，所以我在一个请求中发送200个产品，并稍作停顿。我不记得上传所有数据花了多长时间，但是大概3个小时或者更久。我估计每生上传一次是没问题的。</p><p id="7038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您上传了应用程序和数据，您可以尝试在应用程序的url上搜索:</p><figure class="kh ki kj kk fd lx er es paragraph-image"><div class="er es lw"><img src="../Images/27fa67538ce138a8c98cd6069558b88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*c8948idE6PSHDc2H.png"/></div></figure><p id="5589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Search API返回包含单词“mouse”的产品名称的20个结果(默认数量)。它支持分页，即继续获得更多的结果，可以作为额外的功能实现。此外，这将是一个伟大的分面搜索的情况下，允许细化搜索结果。也许在其他文章中，我可以创建分面搜索的例子。</p><h1 id="4991" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">负载测试</h1><p id="6a89" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当然，在你的webapp上作为单个用户玩没有问题，看看搜索如何对多个用户做出反应会很有趣。这就是为什么我将使用分布式负载测试使用kubernetes和负载测试框架<a class="ae jd" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> Locust </a>基于本文<a class="ae jd" href="https://cloud.google.com/solutions/distributed-load-testing-using-kubernetes" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/solutions/distributed-load-testing-using-Kubernetes</a>本文中引用的Github库已经过时(Kubernetes版本)，所以我使用的是这个<a class="ae jd" href="https://github.com/fawaz-moh/distributed-load-testing-using-kubernetes" rel="noopener ugc nofollow" target="_blank">https://Github . com/fawaz-MOH/distributed-load-testing-using-Kubernetes</a>。</p><p id="7dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在负载测试文件夹中是设置负载测试所需的一切。这也是几个步骤的努力，我将尝试简单地解释如何设置它。首先，我们将创建Docker映像，它将包含用于负载测试的Locuts文件(我不会详细介绍)。然后，我们将在Google Kubernetes引擎上创建Kubernetes集群，部署Docker映像并启动负载测试，该测试将发出请求并统计响应时间。一步一步的过程在负载测试文件夹中的自述文件中有解释，所以我在这里不再赘述。</p><p id="a13c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我用蝗虫框架所做的是，我从产品名称中解析单词，并使用它们进行搜索查询。Locust配置允许设置孵化率(每秒添加的用户数)和最终用户数。所以每个用户都在1到5秒内发出请求。</p><p id="1f3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">群集默认有3个n1-standard-1虚拟机类型的节点，我使用preemptible来节省资金:)。这允许设置12个将发出请求的从设备。这里有一些图表和统计数据。</p><p id="232a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是每秒请求数的图表，因为它最终显示为大约630 RPS，这是一个不错的负载。整个负载测试持续了大约10分钟。</p><figure class="kh ki kj kk fd lx er es paragraph-image"><div class="er es ma"><img src="../Images/dee4b7000fe5b28e8795203e46f512bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*aUe9213ZYv45MYlY.png"/></div></figure><p id="ae24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">平均响应时间各不相同，您可以看到，由于创建新的实例来服务请求，开始时响应时间会更长。用户数量呈线性增长。</p><figure class="kh ki kj kk fd lx er es paragraph-image"><div class="er es ma"><img src="../Images/b61606122700815174195cfbfd59a989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*LPgzkDdI0afLk9ED.png"/></div></figure><p id="d8e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">统计数据也很有趣，在286119个请求中，只有3个错误，平均响应时间为57毫秒，平均181毫秒。</p><figure class="kh ki kj kk fd lx er es paragraph-image"><div class="er es ma"><img src="../Images/97f44b35ca54bb5c522d796bf523b9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*lnzY9e8fPEjr8ZH9.png"/></div></figure><p id="7466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也是GAE仪表板的屏幕截图，其中显示了一段时间内的实例数量。</p><figure class="kh ki kj kk fd lx er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es ma"><img src="../Images/5eccbec3b8816f2ea612d2e327644de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*0lTALLyAZO7fZHxB.png"/></div></div></figure><p id="66a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后摘录日志。</p><figure class="kh ki kj kk fd lx er es paragraph-image"><div class="er es ma"><img src="../Images/e5277b5d90b5184984d2e879ba2f1cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*vvia0ZTnNO-P6j8i.png"/></div></figure><p id="229d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个负载测试的目的是演示搜索API如何扩展到一个用户以上的负载，并与App Engine一起毫无问题地处理。这场比赛花了我16美元。</p><p id="8408" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">官方文档<a class="ae jd" href="https://cloud.google.com/appengine/docs/standard/python/search/" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/app engine/docs/standard/python/search/</a>中有更详细透彻的描述和示例。</p><p id="8fcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，Search API具有强大的搜索功能，不需要任何配置就可以很容易地直接在代码中使用它。不利之处可能是(视情况而定)较高的价格，并锁定在GAE标准之下。</p><p id="5adf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇文章中，我们将看看云数据存储，看看我们如何使用它来进行文本搜索查询。</p><p id="273e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在发布关于https://www.gcpweekly.com/<a class="ae jd" href="https://www.gcpweekly.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>的每周简讯。如果您想在每周一收到与GCP相关的新闻和文章，请订阅</p></div></div>    
</body>
</html>