<html>
<head>
<title>Profiling GKE startup time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析GKE启动时间</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/profiling-gke-startup-time-9052d81e0052?source=collection_archive---------2-----------------------#2017-06-01">https://medium.com/google-cloud/profiling-gke-startup-time-9052d81e0052?source=collection_archive---------2-----------------------#2017-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d9dc4b6b7d36750855f51f34b01f8003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8gFMHNLtQJj-DnrepTSjw.jpeg"/></div></div></figure><div class=""/><p id="4f84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时候作为一个开发者拥护者真的很尴尬。你不断被来自不同方向的信息轰炸，你真的无法传递。这项工作的关键是弄清楚要传递什么信息，以及如何提炼这些信息以便正确地消费。</p><p id="87e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个很好的例子，是几周前我在纽约遇到的<em class="jo"> FoodiePics </em>团队。当我还在NYC的时候，一家<em class="jo">完全独立的公司</em>名叫<em class="jo">培根，活了！</em>“也走近了我。这两家公司的区别，就在于<em class="jo">腊肉，活！</em>更像是Twitch，不过是给人做饭用的。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jp"><img src="../Images/d6b536b876b93cfd4927db02ce17f237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDY_ddHEqLqeMVbf_m2GVw.png"/></div></div></figure><p id="033b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">被两家专注于食品的初创公司接洽是一回事..听说他们都有冷启动问题是另一回事:我们能够帮助<em class="jo"> FoodiePics </em>团队介绍并改善他们在谷歌计算引擎上的冷启动时间，但是<em class="jo"> Bacon，Live！</em>团队使用的是<a class="ae ju" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank">谷歌容器引擎</a> (GKE)，这是一个完全独立的东西。</p><p id="5b46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您用过Kubernetes，那么您会知道它是一个非常棒的工具，可以帮助您以无缝和强大的方式管理、包含和部署图像到您的各种实例。但是你也会注意到，所有这些能量都有一些开销和非常厚的脚手架。这就是为什么帮助<em class="jo">培根，活下去！团队发现并解决他们的冷启动问题将会非常困难:事实证明，冷启动时间并不是Kubernetes向你轻易提出的事情。</em></p><p id="b861" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像我做的<em class="jo">诱饵和缝线</em> (GAE)和<em class="jo">食物图片</em> (GCE)，解决<em class="jo">熏肉的第一步，活！</em>的问题是弄清楚如何分析GKE的冷启动时间，然后弄清楚在没有任何特定代码运行的情况下它有多快。</p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">忙到没时间看书？看看上面的视频！</figcaption></figure><h1 id="028f" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">基线Pod冷启动性能</h1><p id="fd1e" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">很少会有平台发布性能信息，所以当我看到Kubernetes网站<a class="ae ju" href="http://blog.kubernetes.io/2016/07/kubernetes-updates-to-performance-and-scalability-in-1.3.html" rel="noopener ugc nofollow" target="_blank">在大约一年前</a>发布的关于1K节点集群的pod启动延迟接近3秒的消息时，我非常高兴:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es le"><img src="../Images/ddb6c849f626ffd759828018ccf5b90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*m-b9gT7JGQd4Npp4T6RXWQ.png"/></div></figure><p id="e85b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是说，对于1.3版本的节点，第99个百分位数略高于2.5秒，这给了我们一个很好的目标；让我们看看能否验证这些数字。</p><p id="0dbd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在四处挖掘之后，无论是云控制台、<a class="ae ju" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>还是<a class="ae ju" href="https://github.com/kubernetes/heapster" rel="noopener ugc nofollow" target="_blank"> Heapster </a>(对于Kubernetes)都没有给出任何关于pod启动时间的直接数字。然而，有一个地方出现了一些启动时间信息<a class="ae ju" href="https://kubernetes.io/docs/user-guide/kubectl/kubectl_get/" rel="noopener ugc nofollow" target="_blank"> kubectl get pod </a>。原来，调用"<em class="jo"> kubectl get pod -o json" </em>将返回一个json文件，其中包含一些与pod启动阶段相关的时间戳信息:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lf"><img src="../Images/15883665f76403ea90a67a60c4da00f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvENuOTGfhuRqTxK-WYHow.png"/></div></div></figure><p id="d642" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，您可以看到pod状态发出“已计划”、“已初始化”和“就绪”阶段，每个阶段都有一个时间戳，告诉我们(相对)它是何时发生的。对于上面的示例，您可以看到从“初始化”到“就绪”大约需要1秒钟，这是pod的容器开始初始化自己的时间点。这些信息基本上告诉您挂载卷和下载映像数据需要多长时间(但是我们马上就会谈到这一点)。</p><p id="8852" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在的目标是对一批初创公司的数据进行分析，这样我们就可以清楚地了解我们非常简单的用例中pods的启动时间。幸运的是，kubectl给了我们一些控制权，允许我们查找、查询和删除pod:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/15cb5a306e127ae44e8e88df1963015a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PU_QY-YpJK8bloKZQn6-YA.png"/></div></div></figure><p id="f3fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，通过杀死节点，让它们恢复运行，并读取状态时间戳，我们可以清楚地了解每个pod恢复运行需要多长时间。这样做100次左右，我们最终会得到这样的结果:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lh"><img src="../Images/d6577e7dd42a3ecbb2b22e84cae85c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qruxQEfwVqinKpsrCKr3ow.png"/></div></div></figure><p id="062a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，pod从<em class="jo"> PodScheduled </em>移动到<em class="jo"> Initialized </em>所花费的时间是不存在的，并且由于我们使用了这样一个基本容器，所以它移动到“<em class="jo"> Ready </em>所花费的时间在0到3毫秒之间。</p><h1 id="2fe0" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">集装箱！=虚拟机</h1><p id="7f01" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">Kubernetes的基本原则之一是将应用程序容器从运行它们的系统细节中分离出来。谷歌云平台通过虚拟机(VM)向Kubernetes提供一组同质的原始资源，反过来，Kubernetes (k8s)调度容器使用这些资源。一旦提供了这些资源，k8s就可以下载、安装和引导映像。</p><p id="9c7e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一阶段，它可能与带有容器/快照的GCE的工作方式非常相似，但是有一个微妙的区别，这是性能差异的主要原因:<strong class="is hu">引导pod不需要引导VM。</strong></p><p id="daaf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常，当启动GCE实例时，VM本身需要实际启动，并且在您自己的代码可以初始化自己并开始运行之前处于健康状态。如果你启动一个新的，那么整个过程又要重新开始。</p><p id="e923" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，对于Kubernetes pods，情况并非如此:引导一个新的pod只需要初始化它的容器(这是经过编排的，而不是重新引导内核本身。(这在很大程度上是因为容器<em class="jo">共享</em>一个内核)</p><p id="a7e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，当我们谈论pod启动时间时，我们真正关心的是容器初始化需要多长时间。</p><h1 id="358c" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">计时容器</h1><p id="1b42" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">Kubernetes pod由一系列容器组成，这些容器为实例本身提供端点和服务。一旦所有容器都已初始化，并且运行状况检查通过，pod就被视为“就绪”。为了便于正确引导，初始化过程将容器分成两个主要组:</p><p id="41ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">首先是初始化容器</strong>。它们按照安装脚本定义的顺序依次执行。</p><p id="f74a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">第二种是平行集装箱</strong>；剩余容器的列表，以随机的并行顺序执行它们。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es li"><img src="../Images/21b42d81b79a72981d479385019ec920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*s8NYQuB8_Z9-PJEGRmwKXw.png"/></div></figure><p id="2d1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个设置有一些有趣的怪癖，也有可能出现问题。例如，如果一个容器在初始化阶段花费了很长时间，它将阻塞其他所有东西的加载。我有预感这可能是<em class="jo">培根直播的问题！但是为了证明这一点，我必须找出正确的方法来在初始化阶段分析每个容器。</em></p><h1 id="b909" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">初始化容器计时</h1><p id="d470" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">获得容器的启动时间比我预期的要困难得多。我也没想去经历和逼<em class="jo">培根，活！</em>重建他们的所有映像以进行分析(尽管他们认为从长远来看这是个好主意..)，所以需要一些不那么侵扰的东西。经过一番挖掘和反复试验，我意识到使用kubernetes <em class="jo"> get pod </em>命令可能有一个“足够好”的解决方案:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/d267847cf1de6983631c58c6c4e47877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6nXE9fc164HSRXgiOIWbw.png"/></div></div></figure><p id="2036" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将返回pod状态，<strong class="is hu">并且当您定义了初始化容器</strong>时，状态字段将列出初始化容器的状态。例如，状态“Init:1/2”表示两个Init容器中的一个已成功完成:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lk"><img src="../Images/1065919f86be79f8f68a24484a27d3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/0*9_aVjDPinPm6_XhO."/></div></figure><p id="377b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着我们可以大约每10毫秒左右连续轮询<em class="jo"> get pod </em>命令，并且可以了解每个阶段启动需要多长时间。下面的图表展示了我做的一个小原型，突出了它的工作原理:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ll"><img src="../Images/f0ab4c59a705feae5a76af9d11a3ea4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*imvPiQXF1wSbhNoGpXJZMA.png"/></div></figure><p id="6ded" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，您可以清楚地看到统计信息收集容器和数据库初始化容器是花费时间最多的容器。由于这些是<em class="jo">初始化</em>容器，这意味着所有随后的服务都会延迟大约4-12秒，因为这些阶段会阻塞其他工作组的初始化。</p><h1 id="6cc9" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">对并行容器计时</h1><p id="c77a" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">对并行容器进行计时要复杂得多，因为每个容器都可以按照自己想要的顺序启动和停止，并且有自己对“启动和运行”的定义。我尝试了很多不同的方法来以一种可靠的、不要接触太多东西的方式获得这些数据，并最终确定了以下技术:</p><p id="ba24" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于每个容器，公开一个名为“/health”的新入口点，它返回字符串“Success”。从外部位置重复轮询此端点会产生三种不同的状态:</p><ul class=""><li id="a253" class="lm ln ht is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">错误—服务尚未启动和运行(下面的红色条)</li><li id="9a33" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">400 / 500 —服务正在启动，但端点尚不可用(下面的黄色条)</li><li id="83a1" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">“成功”</li></ul><p id="a0f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目标是将/health添加到每个容器中，并让脚本轮询每个容器以获得启动时间。我们可以创建一个图表，显示开始需要多长时间，以及每个阶段需要多长时间:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ll"><img src="../Images/c40f0fc79c6eef8cb79221efed94a39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*lqeOTdHgroSAYoTge4-U8w.png"/></div></div></figure><p id="e6c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的图表揭示了一些事情。首先，在初始化容器时会有一些小的(读:无关紧要的)延迟时间。其次，在这个例子中，我们看到容器初始化阶段在这个例子中花费了最多的时间。</p><h1 id="381e" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">用侧写器做饭。</h1><p id="a0c2" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">唷！Kubernetes pods和引导时间有许多工作上的细微差别，这很有意义:一旦您达到k8s为您的应用程序节省大量运营成本的阶段，您可以打赌，您必须参与一些基本级别的复杂性。</p><p id="3cda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一点上，我们能够计时一般的pod启动时间、映像获取时间和容器初始化时间。好到可以开始看一看<em class="jo">培根直播！</em>的业绩困境。但是既然这篇文章已经够长了，我就把那个话题推到下一篇；)</p></div></div>    
</body>
</html>