<html>
<head>
<title>Deploying OpenStreetMaps services through Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Kubernetes部署OpenStreetMaps服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploying-openstreetmaps-services-through-kubernetes-615c27a7653c?source=collection_archive---------2-----------------------#2016-08-16">https://medium.com/google-cloud/deploying-openstreetmaps-services-through-kubernetes-615c27a7653c?source=collection_archive---------2-----------------------#2016-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1da0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让一些东西走出你小小的本地实验室去面对外面的世界，既令人兴奋又令人害怕。这很可怕，因为你不知道到底会发生什么，同样，出于同样的原因，这也很令人兴奋。</p><p id="986f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，推出一个比静态网站稍微复杂一点的服务也是令人望而生畏的。诚然，有了云平台，如<a class="ae jd" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云</a>和他们的<a class="ae jd" href="https://cloud.google.com/free-trial/" rel="noopener ugc nofollow" target="_blank">极其慷慨的试用程序</a>(免费运行300美元的虚拟机、SQL数据库等)，事情变得更容易了。我再也不用向ISP索要静态IP地址，也不用摆弄路由器来确保端口转发配置正确。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/95055936d2a662debe83c0e99053d30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IiPNGhVsHNJuhLW8Y1lHA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">免费试用，登上谷歌云</figcaption></figure><p id="408d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于Docker服务编写了我的<a class="ae jd" rel="noopener" href="/@duizendnegen/writing-a-custom-openstreetmaps-service-with-docker-468a4498fb6e#.rofnpn5yi">基于OpenStreetMaps的列车跟踪服务</a>，自然我想用同样的技术部署这些容器。使用Docker 直接部署仍然处于测试阶段，但是一个不同的服务已经在很长一段时间内动摇了它:在Google <a class="ae jd" href="https://cloud.google.com/container-engine/" rel="noopener ugc nofollow" target="_blank">容器引擎</a>中的<a class="ae jd" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>。</p><h1 id="c5e1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">架构介绍</h1><p id="c11c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">部署策略与所选择的架构紧密相关。如果你开发一个SaaS应用程序，不选择<a class="ae jd" href="https://en.wikipedia.org/wiki/Multitenancy" rel="noopener ugc nofollow" target="_blank">多租户架构</a>而是选择定制的东西是相当令人惊讶的。另一方面，当从许多现有的开源软件中拼凑出一些东西时，能够选择和混合编程语言、操作系统和数据库是一种福气。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/13a086b66e70d578810b8ca71b944bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcVOhppJ-7nqm9vrT22RJQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">粗略的架构模型，概述外部依赖关系和内部系统组成</figcaption></figure><p id="9095" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该系统由用于存储路线数据和关系的Postgis和用于查询火车站的弹性搜索实例组成。这背后的OpenStreetMaps数据以最初由OpenRailwayMap 演示的方式从GeoFabrik定期导入。最后，MapBox使用其上传API 来利用其出色的图块处理能力。</p><h1 id="ada4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">学习码头公司</h1><p id="88e6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我在Docker的学习之路还远未结束。我会说我在前进的过程中吸收了新的信息。起初，仅仅能够启动一个容器并对其执行一些命令就感觉很棒，也足够了。对于Postgis和ElasticSearch服务的持久性来说，了解更多关于Docker卷的信息是必不可少的。事实证明这并不坏，如果你认为它是一个远程连接的硬盘驱动器，你可以随意连接和拆卸。让多个服务访问同一个卷仍然让我毛骨悚然，所以我偏离了这个方向。</p><p id="06db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Docker上已经变得合理的apt，运行Kubernetes需要额外的学习步骤。熟悉集装箱、服务和数量对这个项目至关重要。有趣的是，到目前为止我发现的最好的指南是《T2儿童图解指南》。</p><h1 id="6db5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创建容器</h1><p id="1058" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Kubernetes附带了一个<a class="ae jd" href="http://kubernetes.io/docs/user-guide/kubectl-overview/" rel="noopener ugc nofollow" target="_blank">优秀的CLI概述</a>，一个<a class="ae jd" href="http://kubernetes.io/docs/user-guide/docker-cli-to-kubectl/" rel="noopener ugc nofollow" target="_blank">Docker用户快速入门指南</a>和一个<a class="ae jd" href="http://kubernetes.io/docs/user-guide/kubectl-cheatsheet/" rel="noopener ugc nofollow" target="_blank">备忘单</a>。我急切地使用它们来找出如何让服务运行起来。我最常用的命令选项当然是<em class="ky"> -o yaml </em>，将待运行的命令输出到一个文件中以供检查和存储。事实上，我的开发实践是运行这些命令，然后用<em class="ky">ku bectl create-f&lt;filename&gt;</em>来运行捕获的指令。</p><p id="618b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在标记了我的API映像之后，我将它推送到<a class="ae jd" href="https://cloud.google.com/container-registry/docs/pushing" rel="noopener ugc nofollow" target="_blank"> Google的容器注册表</a>，并且，不需要额外的持久性，能够通过将一个部署与一个服务相结合来相对简单地发布它，仅仅通过配置运行这个部署的副本的数量就可以自动冗余。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="afb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获得一个带有附加卷的容器，并因此启动和运行更多的持久性功能需要更多的技巧。幸运的是这条路已经铺好了:我无意中发现了一篇关于如何在Google容器引擎中运行Postgres的优秀文章。这似乎意味着最好预先创建一个单独的磁盘，将它挂载到一个新启动的VM，用ext4格式化它，然后运行创建命令。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="2e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺序很重要:应该首先执行持久性命令，然后执行声明，因为没有这些，部署就不知道在哪里存储数据。最后，该服务向外界公开数据库。</p><p id="94e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对我的ElasticSearch实例使用了相同的方法，只有一些必需的环境变量不同。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kz la l"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/76054fb2885d8779322aca21135e2b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJtYbqS4lc4w1XYt-cepSw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">使用Mapbox上的演示Javascript前端使用API</figcaption></figure><h1 id="341a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">后续步骤</h1><p id="1511" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">更好的方法是使用内部网络，将所有提到的容器放在一个容器中，但是我至少对我在现场推动这些服务的成就感到有些自豪。下一步:一个改进的站对站路由服务，并更新部署。</p><p id="90bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ky">我错过了Kubernetes关于入职的精彩文章吗？是我把事情复杂化了还是我走了太多捷径？其他明显的疏忽？欢迎任何反馈。</em></p></div></div>    
</body>
</html>