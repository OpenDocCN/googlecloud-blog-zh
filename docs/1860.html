<html>
<head>
<title>What I learned from setting up CI for a COVID-19 Exposure Notification Open Source project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我从为新冠肺炎曝光通知开源项目设置CI中学到了什么</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/what-i-learned-from-setting-up-ci-for-a-covid-19-exposure-notification-open-source-project-fee53896fae1?source=collection_archive---------0-----------------------#2021-04-23">https://medium.com/google-cloud/what-i-learned-from-setting-up-ci-for-a-covid-19-exposure-notification-open-source-project-fee53896fae1?source=collection_archive---------0-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e28f1bfcb802b69746751193146e1da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*oOMaJJ3Gii576t-Z1-JMWQ.png"/></div></figure><p id="dc34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">去年早些时候，在冠状病毒爆发期间，新冠肺炎暴露通知系统投入使用。谷歌和苹果联合创建并发布了可互操作的系统，以帮助公共卫生当局通知并指导可能接触过新冠肺炎病毒感染者的用户使用他们的应用程序。作为向卫生当局提供隐私保护分析的另一个项目的一部分，我参与了为<a class="ae jk" href="https://github.com/google/exposure-notifications-private-analytics-ingestion" rel="noopener ugc nofollow" target="_blank"> ENPA谷歌回购</a>帮助设置持续集成(CI)。我们的项目团队由来自不同组织和背景的开发人员组成，包括Android、Google Cloud、Security等。ENPA项目包含Google ingestor管道代码，CI有助于确保代码开发期间的代码质量。以下是我在这个过程中学到的一些经验。</p><p id="d22b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">了解目标和非目标</strong></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es jl"><img src="../Images/4b283c2b33f7597405009269fc3b8d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*5Kd6-Zv9S4RdPsciA1rg6Q.jpeg"/></div></figure><p id="02b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">传达给我的总体目标非常直接:设置CI在每个pull请求打开时运行测试，这样任何测试失败都会阻止pull请求被合并到代码库的主要分支中。然而，我脑海中立即闪现出几个问题:这些是什么样的测试？它们需要秘密才能运行吗？如果我们想保持代码质量，有没有其他的东西，比如linter或者代码格式化程序，我们也应该运行？</p><p id="8f98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了回答这些问题并阐明需求，我安排了一次与项目领导的会议，并且<strong class="io hj">确定了我们的目标和非目标</strong>，这样我就可以决定要运行的CI作业以及如何运行它们。经过讨论，我们清楚地知道我们的目标是:</p><ol class=""><li id="5054" class="jq jr hi io b ip iq it iu ix js jb jt jf ju jj jv jw jx jy bi translated"><strong class="io hj">当开发人员对回购做出贡献时，确保</strong>代码质量；</li><li id="10e5" class="jq jr hi io b ip jz it ka ix kb jb kc jf kd jj jv jw jx jy bi translated"><strong class="io hj">通过利用系统化CI来加强</strong>代码质量。</li></ol><p id="06af" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们<em class="ke">不</em>需要:</p><ol class=""><li id="2f47" class="jq jr hi io b ip iq it iu ix js jb jt jf ju jj jv jw jx jy bi translated">从我们的repo向Maven Central发布工件；</li><li id="a4fe" class="jq jr hi io b ip jz it ka ix kb jb kc jf kd jj jv jw jx jy bi translated">使用Java 7、8等多个Java版本运行测试；</li><li id="ae5f" class="jq jr hi io b ip jz it ka ix kb jb kc jf kd jj jv jw jx jy bi translated">每晚在presubmit和综合测试套件上运行“轻量级”测试版本；虽然这是我们将来可能会考虑做的事情。</li></ol><p id="a975" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些<strong class="io hj">目标</strong>和<strong class="io hj">非目标</strong>帮助我区分优先级并理解我选择使用的CI平台需要足够适应所有这些当前和潜在的需求，但不需要过于复杂。我需要交付CI，最关键的是，当发出pull请求时，在Java 11中运行单元和集成测试。该设置需要能够在需要时支持连续作业。最重要的是，我们可以设置作业来运行<a class="ae jk" href="https://github.com/google/exposure-notifications-private-analytics-ingestion/blob/main/.github/header-checker-lint.yml" rel="noopener ugc nofollow" target="_blank">许可头检查</a>、<a class="ae jk" href="https://github.com/google/exposure-notifications-private-analytics-ingestion/blob/2802ed2a3f3b41ea95e9a74ae50fde2ee5b87ce0/.github/workflows/ci.yaml#L45" rel="noopener ugc nofollow" target="_blank"> linter </a>和<a class="ae jk" href="https://github.com/google/exposure-notifications-private-analytics-ingestion/blob/2802ed2a3f3b41ea95e9a74ae50fde2ee5b87ce0/.github/workflows/ci.yaml#L35" rel="noopener ugc nofollow" target="_blank">依赖性检查</a>，以进一步确保代码质量。</p><p id="04ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过预先定义目标和非目标，我能够理解什么是需要的。更重要的是，CI设置不需要什么。这让我能够快速交付有影响力的解决方案。</p><p id="5af0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">决定合适的竞争情报平台:面向未来，但不是包罗万象</strong></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/0fa36dce19c35578e2d1fb94014d4ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*BzARX3lb6TlfEA2Y.jpg"/></div></figure><p id="f2fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">基于我们的目标，我需要选择合适的CI工具来构建我们的渠道。对于单元测试、linter、依赖性检查和代码格式化程序，它们不需要运行服务帐户和测试秘密，我决定使用<a class="ae jk" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a>，因为从过去的经验来看，Github动作很容易配置。它们也很快而且免费。在开发ENPA之前，我已经将所有googleapis repos的预提交<a class="ae jk" href="https://github.com/googleapis/java-bigquery/blob/69974342628d1718ae79d810f9a89c264f77b878/.github/workflows/ci.yaml#L8" rel="noopener ugc nofollow" target="_blank">单元测试</a>工作迁移到Github Actions。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kg"><img src="../Images/7904011a36a7c88e5505f571c0f3acba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_zov7W2ypzIeH3tCpk6NA.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">BigQuery Java客户端库repo中的Github操作(<a class="ae jk" href="https://github.com/googleapis/java-bigquery/pulls" rel="noopener ugc nofollow" target="_blank">https://github.com/googleapis/java-bigquery</a>)</figcaption></figure><p id="594f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，对于集成测试，我需要做更多的研究。我所熟悉的大多数GCP Java客户端库都在谷歌的Kokoro上运行集成测试。例如，GCP <a class="ae jk" href="https://github.com/googleapis/java-bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery Java客户端库</a>拥有<a class="ae jk" href="https://github.com/googleapis/java-bigquery/tree/master/.kokoro" rel="noopener ugc nofollow" target="_blank">三种类型的</a>集成测试:持续测试、夜间测试和预提交测试，它们分别使用各自的触发器运行。此外，我们还有一个发布工作，处理GCP <a class="ae jk" href="https://repo1.maven.org/maven2/com/google/cloud/" rel="noopener ugc nofollow" target="_blank"> google-cloud-*工件</a>到<a class="ae jk" href="https://search.maven.org/" rel="noopener ugc nofollow" target="_blank"> Maven Central </a>的发布，以便GCP客户可以访问客户端库并使用它们与GCP API进行交互。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kp"><img src="../Images/adeb11b4fe6077efea3789b177f8f4b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ado9rINKf1iYHm0kfv0mrA.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">在Maven Central发布的google-cloud-bigquery工件</figcaption></figure><p id="d23d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用Kokoro的好处是，我们可以安全地在内部存储服务帐户和测试秘密。它还允许我们通过在发布时向我们提供OSS Sonatype签名密钥，安全地将<a class="ae jk" href="https://repo1.maven.org/maven2/com/google/cloud/" rel="noopener ugc nofollow" target="_blank"> google-cloud-*工件</a>发布到<a class="ae jk" href="https://search.maven.org/" rel="noopener ugc nofollow" target="_blank"> Maven Central </a>。Kokoro的一个主要缺点是设置复杂。我们需要在Google代码库中内部配置作业，在Github中定义构建配置，然后配置webhooks将内部作业连接到外部构建配置。当回购是私有的时，设置变得更加复杂和缓慢，这是我们在开发投入生产的第一个版本的大部分时间里的情况。另一方面，ENPA Google Ingestor repo不需要向Maven Central发布工件。因此，我们无需准备OSS签名密钥。考虑到建立Kokoro的所有必要条件和努力，我们决定反对它。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kq"><img src="../Images/9d83ce514ea295d79b86c1962287fbc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsvbIP6ATIn9MXgcb_DXZg.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">在googleapis repos中集成测试的Kokoro工作</figcaption></figure><p id="e771" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们调查了其他平台，最终决定采用<a class="ae jk" href="https://cloud.google.com/cloud-build" rel="noopener ugc nofollow" target="_blank">云构建</a>。云构建可以使用定制的工作流跨不同的编程语言进行构建和测试。这对于像ENPA这样的项目尤其重要，因为开发人员来自不同的团队和背景。我们需要迎合参与其中的开发人员的技能多样性，他们会选择自己喜欢的工具和语言。一些集成测试是用“mvn”运行的，而另一些是用“npm”运行的。该平台需要适应不同的测试环境。它还需要能够根据事件触发器运行不同类型的集成测试。例如，我们可能希望只在夜间运行处理100k数据份额的测试，但是为了更快的周转和更少的数据处理开销，我们希望在每个pull请求上运行处理10k数据份额的测试。</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kr"><img src="../Images/1b25265cf0f329b2aa97c10bc5f967f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASXOrpcVqkNNzVu46pR7Rg.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">Google/exposure-notifications-private-analytics-ingestion repo中集成测试的云构建作业</figcaption></figure><p id="ecd2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">选择合适的CI平台不仅帮助我们成功完成手头的任务，还帮助我们节省了宝贵的工程时间。</p><p id="4a59" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">思考测试基础设施和更大的图景</strong></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/1440b5f12c837e733ac0bcef29414469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*c2RnyLjuo3Y4QCKf.jpg"/></div></figure><p id="de7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我决定了云构建，我很快就投入了实施。我在我们的测试项目中创建了一个云构建管道，并允许默认的云构建服务帐户访问我们的测试秘密，以便运行集成测试。</p><p id="3efa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这在代码审查期间立即被拒绝。事实证明，我没有意识到每个GCP项目只能有一个Firebase项目的限制，而且我们将来可以针对不同的Firebase项目运行集成测试。这意味着我最初的解决方案需要为每个新的GCP测试项目重新创建一个新的CI管道！</p><p id="c3ed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更好的方法是将CI管道从测试项目中分离出来。将CI渠道放在专门的基础设施项目中；允许其服务帐户在各种测试项目中运行集成测试。这允许更大的灵活性，并且需要更少的配置工作。从长远来看，集中构建和测试配置也意味着更容易维护。</p><p id="372a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑全局和整个基础设施有助于对如何设置做出更合理的决策，以便我们可以更容易地长期维护它。</p><p id="4f9e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们已经有了满足我们基本需求的最小可行产品(MVP ),我们可以开始运行它，看看我们是否可以对CI渠道进行任何潜在的改进。</p><p id="ebfb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">应用通用软件工程原则和最佳实践</strong></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/6a854c3ba5854693b6dd1f39dfe3a7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*_AYf_0Cr_LcJD2mg.jpg"/></div></figure><p id="d822" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们开始运行新的CI渠道，我们就开始观察到一些需要改进的地方。</p><p id="e5e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，我们最初的CI管道运行`。/mvnw clean verify '用于每次集成测试。这意味着我们每次运行集成测试时都在下载maven包，因为默认情况下，Cloud Build使用空的本地Maven存储库启动容器。作为改进，我们<a class="ae jk" href="https://github.com/google/exposure-notifications-private-analytics-ingestion/blob/main/container-build.yaml" rel="noopener ugc nofollow" target="_blank">开始在Google云存储中缓存这些包</a>,这样我们的集成测试将需要三分钟而不是七分钟来运行。每次都从头开始运行当然有好处，但是在本地缓存这些包大大加快了我们的CI:</p><figure class="jm jn jo jp fd ij er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es ku"><img src="../Images/fcca2a6701c6444df0879aef79c6101e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cZljqM6EemP6oTRI"/></div></div></figure><p id="9559" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还使用Java 11 <a class="ae jk" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank"> gcr容器</a>来运行我们的npm firebase模拟器测试，因为firebase模拟器需要Java来运行，但这也意味着我们每次运行测试时都要安装npm。为了解决这个问题，我们可以开始构建或获取一个同时包含Java和npm的gcr映像。然而，通过这样做，我们需要承担维护新容器的责任。</p><p id="adf2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些改进都不会阻碍我们CI渠道的推广。如果您已经知道如何快速使其中一些工作，这是很好的，但否则，快速配置和部署一个工作的CI管道，然后迭代地改进它，比等待推出它有更大的影响。</p><p id="36e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">作为一般的经验法则，在进行改进或升级之前，尝试创建一个有效的CI渠道。快速失败，快速迭代经常失败。在测试之前配置一个高效且强大的CI管道是很诱人的，但事实是CI在代码提交中是不可或缺的。有必要运行一些东西来确保没有提交的代码破坏现有的代码库。启动和运行CI对于任何项目都是至关重要的。</p><p id="2b3a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">最后的想法</strong></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/1db05552668bccbdd788d0f9a1208e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/0*rhlzEGk0kCc6Fj8g.jpg"/></div></figure><p id="8727" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">DevOps没有一个部分是简单的。在与其他软件工程师和相关的利益相关者进行了详尽的讨论之后，我发现关注什么是重要的事情要少得多。没有什么比设置好所有可以工作的东西，然后又不得不完全修改它更糟糕的了——光是凭证和权限管理就令人难以置信。所以总是从理解目标和非目标开始。我发现在软件工程中是这样，现在在DevOps中也是这样。如果你有任何问题，欢迎在推特上给我发消息。</p><p id="bd86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ke">特别感谢</em><a class="ae jk" rel="noopener" href="/@hostirosti"><em class="ke">Robert Kubis</em></a><em class="ke">对这个项目和博文的指导和帮助。</em></p></div></div>    
</body>
</html>