<html>
<head>
<title>A Journey into BigQuery Fuzzy Matching — 1 of [1, ∞) — Soundex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery模糊匹配之旅—1/1，∞) — Soundex</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-journey-into-bigquery-fuzzy-matching-1-of-1-soundex-b5b89087eae2?source=collection_archive---------0-----------------------#2019-07-12">https://medium.com/google-cloud/a-journey-into-bigquery-fuzzy-matching-1-of-1-soundex-b5b89087eae2?source=collection_archive---------0-----------------------#2019-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="7916" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">“我的名字不是这样拼写的”</h1><p id="dffd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在人们周围做决定时，取一个正确的名字是很重要的。这适用于处理一个公司与一个人交往的方方面面。人力资源、定向营销和客户参与中的用例就是取对名字很重要的例子。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/08ddade7ff0570c25e0e56f17d0672d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXgJy3MHqSmZfhjU_60LfA.png"/></div></div></figure><p id="c7f9" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">回想一下上一次咖啡师在杯子上写你的名字是什么时候。</p><p id="a5b2" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">当它进入企业系统的上下文时，匹配相似名称的需要就更加重要了。当单个事务孤立地发生时，可能会有一点误差容限。当我的杯子上写着“布莱恩”而不是“布莱恩”时，我就能释怀了(通常情况下)。如果我以多种排列出现在CRM系统中，这将成为一个更大的问题。银行收购就是一个很好的例子。</p><p id="3bf7" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">我曾经是一家地区性零售银行的客户，拥有一个支票和储蓄账户。它被一家更大的地区性银行收购了。后来被一家大型银行控股公司收购，这家公司同时也进行了其他大型收购，其中一些我也是客户。其结果是，我将被直接推销给储蓄账户、支票账户和信用卡，而我已经通过另一项收购成为这些账户的客户，并且我的名字有所变化和拼写错误。单个实体缺乏统一的标识符是一个被称为<a class="ae ks" href="https://en.wikipedia.org/wiki/Master_data_management" rel="noopener ugc nofollow" target="_blank">主数据管理(MDM) </a>的问题，这个问题已经存在了一段时间。</p><p id="e4c5" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">很长一段时间以来，供应商一直试图开发应用程序来解决这个问题。MDM和身份解析系统并不新鲜。一种更常见的架构利用中间件来批量执行模糊匹配和合并，并将合并后的数据写入目标存储库。虽然这些算法已经过时间的考验，但最大的问题之一总是围绕着性能。您往往会受到运行中间件应用程序的基础设施的限制。</p><p id="03f5" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">我已经在<a class="ae ks" href="https://en.wikipedia.org/wiki/Enterprise_information_management" rel="noopener ugc nofollow" target="_blank">企业信息管理</a>领域工作了一段时间，也在销售数据集成(DI)/质量(DQ)和MDM工具的供应商那里工作过，这是我一直感兴趣的话题。</p><p id="b97c" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">我也开始欣赏将转换下推到数据库层的能力。随着Google BigQuery成为一个完全托管的Pb级数据平台，我想到了一个问题:我们是否可以在开始执行这些任务的同时，能够利用BigQuery带来的所有超酷的东西？</p><p id="07a1" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">所以，为什么不试一试。</p><p id="a04d" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">我不打算设计出一个完整的MDM系统(至少目前是这样)。作为整体DQ和/或MDM策略的一部分，您将需要一个清理和匹配策略的工具包来为您的特定问题提供解决方案，这正是我希望帮助提供的。我总是很想知道某件事是否有效，以及如何改进它的任何反馈。此外，我不知道我能得到多少，因为有一大堆算法可以解决不同的问题。生活充满了小小的冒险，让我们看看它会走向何方。</p><p id="38cd" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">一般来说，我总是会尽可能地坚持使用<a class="ae ks" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/" rel="noopener ugc nofollow" target="_blank"> BigQuery标准SQL </a>。我一直认为坚持使用本地方言和数据结构是最快的，因为它不需要额外的引擎，并且允许BigQuery以最佳方式完成它的工作，而且需要了解的语言越少，就越容易被采用。</p><p id="5807" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">所以让我们试一试。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="3680" class="if ig hi bd ih ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc bi translated">桑迪克斯</h1><p id="2807" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">该算法由<a class="ae ks" href="https://patents.google.com/patent/US1261167A/en" rel="noopener ugc nofollow" target="_blank">于1918年</a>首次申请专利，是常用的简单算法之一。我们的目标是处理名字，使那些有相同语音发音的名字有相同的代码。这是为了使人们可以识别和分组可能具有不同拼写的条目，这可以克服打字错误和拼写错误。</p><p id="2502" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">这是<a class="ae ks" href="https://en.wikipedia.org/wiki/Soundex" rel="noopener ugc nofollow" target="_blank">算法的样子，来自维基百科</a>:</p><blockquote class="lf lg lh"><p id="5d36" class="jd je li jf b jg kn ji jj jk ko jm jn lj kp jq jr lk kq ju jv ll kr jy jz ka hb bi translated">1-保留名称的第一个字母，删除所有其他出现的a、e、I、o、u、y、h、w。</p><p id="78a2" class="jd je li jf b jg kn ji jj jk ko jm jn lj kp jq jr lk kq ju jv ll kr jy jz ka hb bi translated">2 —用数字替换辅音，如下所示(第一个字母后):</p><p id="a7d6" class="jd je li jf b jg kn ji jj jk ko jm jn lj kp jq jr lk kq ju jv ll kr jy jz ka hb bi translated">b，f，p，v → 1 <br/> c，g，j，k，q，s，x，z → 2 <br/> d，t → 3 <br/> l → 4 <br/> m，n → 5 <br/> r → 6</p><p id="2654" class="jd je li jf b jg kn ji jj jk ko jm jn lj kp jq jr lk kq ju jv ll kr jy jz ka hb bi translated">3-如果在原始名称中有两个或两个以上相同数字的字母相邻(在步骤1之前)，则只保留第一个字母。</p><p id="7b2b" class="jd je li jf b jg kn ji jj jk ko jm jn lj kp jq jr lk kq ju jv ll kr jy jz ka hb bi translated">4-如果单词中的字母太少，无法分配三个数字，请添加零，直到有三个数字。如果超过3个字母，只保留前3个数字。</p></blockquote><p id="335f" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">对于字符替换，我发现只需包装成一系列的<code class="du lm ln lo lp b"><a class="ae ks" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#replace" rel="noopener ugc nofollow" target="_blank">REPLACE()</a></code>(用于单字符替换)和<code class="du lm ln lo lp b"><a class="ae ks" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#regexp_replace" rel="noopener ugc nofollow" target="_blank">REGEX_REPLACE()</a></code>(用于多字符替换)函数就可以了。这可以抽象成一个<a class="ae ks" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions" rel="noopener ugc nofollow" target="_blank">用户定义的函数(UDF) </a>，它可以处理这两种情况，但是实际上只有六种情况，并不能完全清理查询。</p><p id="bbb6" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">我遇到的另一个问题是删除重复的相邻字母。有一些解决方案可以消除字符串中的重复字符，但是它们必须是连续的，这是我的难点。这时，BigQuery engineering的聪明人之一Elliott Brossard提出了一个使用偏移量的解决方案。我们还将使用<a class="ae ks" href="https://twitter.com/ElliottBrossard/status/1145764485711290369" rel="noopener ugc nofollow" target="_blank">持久UDF</a>，一个新发布的功能，让我们的生活变得更加轻松。</p><pre class="kc kd ke kf fd lq lp lr ls aw lt bi"><span id="74cc" class="lu ig hi lp b fi lv lw l lx ly">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_gh_RemoveDuplicateChars(s STRING) AS ( <br/>/*<br/> * (Helper) Data Quality Function<br/> * dq_hf_gh_RemoveDuplicateCharacters<br/> * input: Any string to clean up.<br/> * returns: String with duplicate characters removed. This<br/> *   refers to consecutively repeated characters.<br/> */<br/>(SELECT<br/>  STRING_AGG(<br/>    IF<br/>      (c = SPLIT(s, '')[SAFE_OFFSET(off - 1)],<br/>        NULL,<br/>        c), '' ORDER BY off)<br/>FROM<br/>  UNNEST(SPLIT(s, '')) AS c<br/>  WITH OFFSET off) );</span></pre><p id="f46a" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">让我们用几根绳子做个快速测试。</p><pre class="kc kd ke kf fd lq lp lr ls aw lt bi"><span id="8f8f" class="lu ig hi lp b fi lv lw l lx ly">WITH<br/>  input_data AS (<br/>  SELECT ["hello", "parallelogram", "sapphire", "shhhhh"] AS words)<br/>SELECT<br/>  words, dq.dq_hf_gh_RemoveDuplicateChars(words)<br/>FROM<br/>  input_data, UNNEST(words) AS words</span></pre><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es lz"><img src="../Images/cff34ced7d06d9ca102c69f5839bd146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm9TT94tfwg891yo908RyA.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">重复数据删除…非常成功！</figcaption></figure><p id="a461" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">我们还需要创建几个助手函数。在这个实现中，如果翻译的第一个字母与开头的数字相同，我们需要删除第一个数字。这是因为我们不能单方面删除第一个数字。比如经过去重翻译，“冈萨雷斯”的全名是25242。g转化为2，所以我们需要删除它。然而，像“Ward”和“Hasnain”这样的名字分别翻译成63和255，W和H都不匹配数字，我们必须保留所有的数字。</p><p id="32f9" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">让我们创建几个助手函数。第一个是接受一个字母并返回对应的Soundex数字映射。如果没有找到匹配，它将返回7。</p><pre class="kc kd ke kf fd lq lp lr ls aw lt bi"><span id="537f" class="lu ig hi lp b fi lv lw l lx ly">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_soundex_GetSoundexNumber(inchar string) AS (<br/>/*<br/> * (Helper) Data Quality Function<br/> * dq_hf_soundex_GetSoundexNumber<br/> * input: Single letter.<br/> * returns: Equivalent Soundex code.<br/> */<br/>CASE<br/>  WHEN STRPOS('bfpv', LOWER(inchar)) &gt; 0 THEN '1'<br/>  WHEN STRPOS('cgjkqsxz', LOWER(inchar)) &gt; 0 THEN '2'<br/>  WHEN STRPOS('dt', LOWER(inchar)) &gt; 0 THEN '3'<br/>  WHEN STRPOS('l', LOWER(inchar)) &gt; 0 THEN '4'<br/>  WHEN STRPOS('mn', LOWER(inchar)) &gt; 0 THEN '5'<br/>  WHEN STRPOS('r', LOWER(inchar)) &gt; 0 THEN '6'<br/>  ELSE '7'<br/>END<br/>);</span></pre><p id="120a" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">然后我们创建另一个函数，如果找到匹配项，它将返回不带前导字符的字符串。</p><pre class="kc kd ke kf fd lq lp lr ls aw lt bi"><span id="8637" class="lu ig hi lp b fi lv lw l lx ly">CREATE OR REPLACE FUNCTION<br/>  dq.dq_hf_gh_CheckRemoveFirstChar (full_numbers string,<br/>    first_letter string) AS(<br/>/*<br/> * (Helper) Data Quality Function<br/> * dq_hf_gh_CheckRemoveFirstChar<br/> * input: String<br/> * returns: Input string without the first character if the<br/> *   stored first character is the same.<br/> */<br/>IF<br/>  (STARTS_WITH(full_numbers, first_letter),<br/>    SUBSTR(full_numbers, 2, LENGTH(full_numbers)),<br/>    full_numbers) );</span></pre><p id="94bc" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">因此，随着<code class="du lm ln lo lp b">dq_hf_RemoveDuplicateChars()</code>、<code class="du lm ln lo lp b">dq_hf_GetSoundexNumber()</code>和<code class="du lm ln lo lp b">dq_hf_CheckRemoveFirstChar()</code>UDF的工作，是时候在它的基础上添加其余的字符替换了。</p><pre class="kc kd ke kf fd lq lp lr ls aw lt bi"><span id="1890" class="lu ig hi lp b fi lv lw l lx ly">CREATE OR REPLACE FUNCTION dq.dq_fm_Soundex(instring string) AS (<br/>/*<br/> * Data Quality Function - Fuzzy Matching<br/> * dq_fm_Soundex<br/> * input: String to encode.<br/> * returns: Soundex code of the string.<br/> */<br/>CONCAT(SUBSTR(UPPER(instring), 0, 1),<br/>rpad(SUBSTR(`dq.dq_hf_gh_CheckRemoveFirstChar`(<br/>  REPLACE(`dq.dq_hf_gh_RemoveDuplicateChars`(<br/>    REPLACE(<br/>      REGEXP_REPLACE(<br/>        REPLACE(<br/>          REGEXP_REPLACE(<br/>            REGEXP_REPLACE(<br/>              REGEXP_REPLACE(<br/>                REGEXP_REPLACE(LOWER(instring),'[aeiouyhw]', '0'),<br/>              '[bfpv]', '1'),<br/>            '[cgjkqsxz]', '2'), <br/>          '[dt]', '3'), <br/>        'l', '4'), <br/>      '[mn]', '5'), 'r', '6')),<br/>    '0', ''), `dq.dq_hf_soundex_GetSoundexNumber`(substr(instring, 0, 1))),<br/>0, 3), 3,'0')))</span></pre><p id="2137" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">创建完成后，让我们给它取几个名字，试一试吧！</p><pre class="kc kd ke kf fd lq lp lr ls aw lt bi"><span id="49cd" class="lu ig hi lp b fi lv lw l lx ly">WITH<br/>  name_table AS (<br/>  SELECT<br/>    ["Suk","Suck","Souk",<br/>    "Price","Prise","Pryce",<br/>    "Welch","Welsh","Walch",<br/>    "Stamos","Stamoos",<br/>    "Ward","Werd","Whard",<br/>    "Gonzalez","Gonzolezz",<br/>    "McGovern","McGooovern","MacGavern"] AS lname)<br/>SELECT<br/>  lname,<br/>  dq.dq_fm_Soundex(lname) as soundex_code<br/>FROM<br/>  name_table,<br/>  UNNEST(lname) AS lname</span></pre><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es me"><img src="../Images/7debb24d17404fe8b2a5f28e39c87861.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*DFu-DkSu9u1mbYmJX_6EXQ.png"/></div></figure><p id="775e" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">现在，虽然Soundex使用和实现起来既快又容易，但它有时在精确度方面会受到影响。我们在这里使用的基本编码通常被称为“American Soundex”，因为在20世纪30年代，原始的Russell Soundex被修改为我们在这里显示的形式，并被美国人口普查局用于索引英语字母表中的姓名。不同语言的名字，如朝鲜语、日语或汉语，首先需要进行音译，这也带来了挑战。</p><p id="290e" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">即使在英语中，由于精确度的损失，我们有时仍然会遇到<a class="ae ks" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity" rel="noopener ugc nofollow" target="_blank">假阴性和假阳性</a>。就拿“沃兹尼亚克”、“威金斯”、“韦贡格”和“韦斯莫夫斯基”这些名字来说吧。至少从语音意义上来说，你不会期望它们被归为同一类。然而…</p><pre class="kc kd ke kf fd lq lp lr ls aw lt bi"><span id="1789" class="lu ig hi lp b fi lv lw l lx ly">WITH<br/>  name_table AS (<br/>  SELECT<br/>    ["wozniak","wiggins","wegonge","weiscmowsky"] AS lname)<br/>SELECT<br/>  lname,<br/>  dq.dq_fm_Soundex(lname) AS soundex_code<br/>FROM<br/>  name_table,<br/>  UNNEST(lname) AS lname</span></pre><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es mf"><img src="../Images/36291df2e3ab5616178b8beb294ee456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*9MmoUuKHTuc0jW5UC9VBZw.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">哼。*抓抓头*</figcaption></figure><p id="9a65" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated">因此，虽然Soundex仍然很有帮助，而且速度很快，但它肯定不是绝对可靠的。这是属性的一个维度，可用于快速创建实体的分组，这是模糊匹配难题的一大块。通常，在数据质量流中，许多不同的算法将根据用例以不同的权重相互结合使用，以便真正确定是否可以解决重复，希望这是BigQuery中的第一个难题。</p><p id="2472" class="pw-post-body-paragraph jd je hi jf b jg kn ji jj jk ko jm jn jo kp jq jr js kq ju jv jw kr jy jz ka hb bi translated"><a class="ae ks" rel="noopener" href="/google-cloud/a-journey-into-bigquery-fuzzy-matching-2-of-1-more-soundex-and-levenshtein-distance-e64b25ea4ec7">现在开始下一个… </a></p><div class="mg mh ez fb mi mj"><a rel="noopener follow" target="_blank" href="/@hoffa/new-in-bigquery-persistent-udfs-c9ea4100fd83"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">BigQuery中的新特性:持久性UDF</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">用户定义的函数是扩展BigQuery的一种强有力的方法，但直到现在，它一直是一个必须复制粘贴的累赘…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kl mj"/></div></div></a></div></div></div>    
</body>
</html>