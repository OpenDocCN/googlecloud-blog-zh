<html>
<head>
<title>A to Z of Google Cloud Platform a personal selection — T — Timeouts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云平台的a到Z个人选择— T —超时</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-t-timeouts-9d531f764dd7?source=collection_archive---------0-----------------------#2016-05-01">https://medium.com/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-t-timeouts-9d531f764dd7?source=collection_archive---------0-----------------------#2016-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d6b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超时一直在发生，并且发生在应用程序架构的不同层。我将主要讨论它们如何与GCE &amp; GAE相关，而不是您在应用程序中编写的处理超时的代码。</p><h2 id="ff09" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">GCE和超时</h2><p id="70d7" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">你有一个实例，它超时了，你从哪里开始呢？如果您希望直接访问互联网，这里的是一个很好的起点。这几段谈到了空闲的TCP连接，TCP保持活动，防火墙配置，所以我不会在这里赘述。</p><p id="1cfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在<a class="ae kd" rel="noopener" href="/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-g-global-load-balancing-82e1b8550298#.ao27o2ah6"> G </a>谈到了云负载平衡服务，在那里引入了<a class="ae kd" href="https://cloud.google.com/compute/docs/instance-groups/" rel="noopener ugc nofollow" target="_blank">实例组</a>的概念。通过对该组设置http健康检查，可以检查该组中的实例上的服务是否正常运行。但是要小心，因为直接针对实例组设置的检查不同于针对负载平衡服务设置的检查，并且它们调用的响应失败的健康检查的操作也不同。直接针对<a class="ae kd" href="https://cloud.google.com/compute/docs/instance-groups/#monitoring_groups" rel="noopener ugc nofollow" target="_blank">实例组</a>设置的健康检查将导致返回健康检查失败的实例删除该实例并启动一个新实例。而针对负载平衡服务设置的健康检查基本上停止将流量定向到健康检查失败的实例，但让实例运行。您不应该通过负载平衡服务设置与直接针对实例组(这里是dragons)相同的检查。</p><p id="7db2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上述两种情况下，您都设置了超时标志值。(我知道我已经转移到健康检查上了，但是我没有忘记这篇文章的核心是关于诚实的！)</p><p id="0fb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于设置<a class="ae kd" href="https://cloud.google.com/compute/docs/reference/latest/httpHealthChecks" rel="noopener ugc nofollow" target="_blank">健康检查</a>的gcloud命令类似于以下示例，然后您可以将该健康检查与负载平衡服务相关联，或者直接针对托管实例组:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="8081" class="jd je hi kj b fi kn ko l kp kq">$ gcloud compute http-health-checks create example-check — port 80 \</span><span id="6094" class="jd je hi kj b fi kr ko l kp kq"> — check-interval 10s \</span><span id="6b41" class="jd je hi kj b fi kr ko l kp kq"> — healthy-threshold 1 \</span><span id="e49a" class="jd je hi kj b fi kr ko l kp kq"> — timeout 5s \</span><span id="5a74" class="jd je hi kj b fi kr ko l kp kq"> — unhealthy-threshold 3</span></pre><p id="4b6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将每10秒运行一次简单的http检查。healthy-threshold指示在实例被标记为永久不健康之前，必须有多少后续健康检查返回健康状态。healthy-threshold表示有多少次连续失败会导致实例被标记为不正常。</p><p id="7ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超时是在返回失败之前等待请求响应的时间(在我们的示例中设置为5秒)。超时值不应大于检查间隔(可以有相同的值)。</p><p id="b862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以将您创建的健康检查资源与一个<a class="ae kd" href="https://cloud.google.com/compute/docs/load-balancing/network/target-pools#add_or_remove_a_health_check_from_a_target_pool" rel="noopener ugc nofollow" target="_blank">目标池</a>或<a class="ae kd" href="https://cloud.google.com/compute/docs/load-balancing/http/backend-service#create_a_backend_service" rel="noopener ugc nofollow" target="_blank">后端服务</a>相关联。如果您希望它与负载平衡服务相关联。要将支票与<a class="ae kd" href="https://cloud.google.com/compute/docs/instance-groups/#monitoring_groups" rel="noopener ugc nofollow" target="_blank">组</a>直接关联，您可以使用set-autohealing标志</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9703" class="jd je hi kj b fi kn ko l kp kq">$ gcloud beta compute instance-groups managed set-autohealing example-group \</span><span id="7ea0" class="jd je hi kj b fi kr ko l kp kq"> — http-health-check example-check \</span><span id="555e" class="jd je hi kj b fi kr ko l kp kq"> — initial-delay 120</span></pre><p id="6835" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> initial-delay </strong>标志允许实例开始和结束运行它们的启动脚本，以便受管实例组不会过早地重新创建该实例，即防止超时的无限循环。</p><h2 id="0451" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">应用程序引擎和超时</h2><p id="7a71" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">使用App Engine standard访问云存储时，您需要使用App Engine UrlFetch功能。云存储客户端库处理应用引擎端和云存储端的超时错误，自动执行重试，因此您的应用程序不需要添加逻辑来处理这一点。超时和重试机制的配置通过<a class="ae kd" href="https://cloud.google.com/appengine/docs/python/googlecloudstorageclient/retryparams_class" rel="noopener ugc nofollow" target="_blank"> RetryParams </a>类公开，您可以使用该类在应用程序范围的基础上更改任何或所有默认设置，或者针对Google云存储客户端库函数的特定调用(copy2、delete、listbucket、open、stat)查看<a class="ae kd" href="https://cloud.google.com/appengine/docs/python/googlecloudstorageclient/retryparams_class" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="1087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">App Engine将资源使用限制在一定范围内，以防止资源过度使用，并在同一集群中运行的应用之间提供更好的隔离。App Engine请求计时器(<a class="ae kd" href="https://cloud.google.com/appengine/docs/java/#Java_The_request_timer" rel="noopener ugc nofollow" target="_blank">Java</a>/<a class="ae kd" href="https://cloud.google.com/appengine/docs/python/#Python_The_request_timer" rel="noopener ugc nofollow" target="_blank">Python</a>/<a class="ae kd" href="https://cloud.google.com/appengine/docs/go/#Go_The_request_timer" rel="noopener ugc nofollow" target="_blank">Go</a>)确保请求具有有限的生命周期，并且不会陷入无限循环。目前，对前端实例的请求的截止时间是60秒。(后端实例没有相应的限制。) .如果请求未能在60秒内返回，将引发DeadlineExceededError。这需要被捕获，有很多方法可以减轻抛出DeadlineExceededError或超时的影响。这篇<a class="ae kd" href="https://cloud.google.com/appengine/articles/deadlineexceedederrors" rel="noopener ugc nofollow" target="_blank">文章</a>雄辩地解释了各种选项，所以如果你正在使用App Engine，我建议你暂停一下(看我在那里做了什么！)来读一读。</p></div></div>    
</body>
</html>