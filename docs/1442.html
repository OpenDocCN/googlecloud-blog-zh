<html>
<head>
<title>Firestore/Datastore: unlock the query filter capabilities in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firestore/Datastore:在Go中解锁查询过滤器功能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/firestore-datastore-unlocked-the-query-filter-capabilities-in-go-8cc5bf0e9af2?source=collection_archive---------0-----------------------#2020-05-26">https://medium.com/google-cloud/firestore-datastore-unlocked-the-query-filter-capabilities-in-go-8cc5bf0e9af2?source=collection_archive---------0-----------------------#2020-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1a8092b363cbc35f4476425fe55d91f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9aShHHCQMWyjL7fsc5Smzg.png"/></div></div></figure><p id="fdde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您必须存储面向文档的数据时，您希望将它们存储在<strong class="is hj">文档数据库</strong>中。Google云平台提出了两种类型的文档DB引擎:<a class="ae jo" href="https://cloud.google.com/datastore/docs/concepts/overview" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Datastore </strong> </a>和<a class="ae jo" href="https://cloud.google.com/firestore/docs" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Firestore </strong> </a>。这两种产品非常相似，但故事不同。Datastore来自App Engine，Firestore来自Firebase suite <em class="jp">(一部分文档仍在Firebase域下)</em>。</p><h1 id="b37e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">数据存储/Firestore概述</h1><p id="3afe" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">产品有<strong class="is hj">无服务器</strong>和<strong class="is hj">随流量自动缩放</strong>。您有到达平台的API，您可以创建具有<strong class="is hj">事务和批处理功能</strong>的文档。</p><p id="8b85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个强大的特性是在文档创建、更新或删除时触发事件的能力。您可以在这个事件上插入一个云函数来执行额外的处理。<em class="jp">例如，用于净化博客帖子消息。</em></p><p id="f573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个相似之处是，<strong class="is hj">对执行的操作数量</strong>(读/写/删除)和存储的数据量(包括索引大小)负责。</p><h1 id="9718" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">查询限制</h1><p id="9c52" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><strong class="is hj">两款产品在优势和定价上非常相似</strong>，但也有各自的弱点。最主要的一个是<strong class="is hj"/><a class="ae jo" href="https://firebase.google.com/docs/firestore/query-data/queries#query_limitations" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">查询限制</strong> </a>。</p><ul class=""><li id="58a4" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">不能用<code class="du lc ld le lf b">!=</code>排除一个值。<br/>您必须创建两个范围条件:<code class="du lc ld le lf b">&gt;</code>和<code class="du lc ld le lf b">&lt;</code>以获得相同的结果</li><li id="93a8" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">如果您使用<code class="du lc ld le lf b">&gt;</code>和/或<code class="du lc ld le lf b">&lt;</code>范围条件，它必须在同一个字段上。不可能有几个字段具有<code class="du lc ld le lf b">&gt;</code>或<code class="du lc ld le lf b">&lt;</code>条件</li><li id="52f6" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">IN</code>子句的等价物最多被限制为10个元素</li><li id="fdb5" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">当您在一个字段上筛选范围和在另一个字段上筛选相等时，您需要预先创建一个复合索引</li><li id="256a" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">不可能对嵌套字段进行筛选</li></ul><h1 id="d03a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">后处理解决方案</h1><p id="8d0b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在我的Go项目中，我处理了这些问题，我有<strong class="is hj">个困难来满足产品所有者的期望</strong>。</p><blockquote class="ll"><p id="d2bc" class="lm ln hi bd lo lp lq lr ls lt lu jn dx translated">消费者必须能够使用任何条件过滤任何字段</p></blockquote><p id="912d" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">这就是为什么我<strong class="is hj">开发了</strong> <a class="ae jo" href="https://pkg.go.dev/github.com/guillaumeblaquiere/jsonFilter" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> JsonFilter库</strong> </a> <strong class="is hj"> </strong>来post处理Datastore/Firestore结果<strong class="is hj">(但是，最终，也可以应用于任何struct数组)。</strong></p><p id="7c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">标准流程如下</p><ul class=""><li id="79c6" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">获取过滤字符串并根据查询的目标结构“编译”它</li><li id="5d42" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><em class="jp">将数据查询到Firestore/Datastore中，并将结果映射到struct数组中(不由库执行)</em></li><li id="4b24" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><strong class="is hj">应用过滤器来消除</strong>与过滤器不匹配的数组条目。</li></ul></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="a7ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们更深入地了解这个库的用法、过滤功能以及如何定制它。</p><h2 id="f732" class="mh jr hi bd js mi mj mk jw ml mm mn ka jb mo mp ke jf mq mr ki jj ms mt km mu bi translated"><a class="ae jo" href="https://pkg.go.dev/github.com/guillaumeblaquiere/jsonFilter?tab=doc#Filter.Init" rel="noopener ugc nofollow" target="_blank">过滤器编译</a></h2><p id="d2e0" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">过滤器串被提交给库，用于针对结构数组的结构类型的<strong class="is hj">编译(通常是Firestore/Datastore查询结果)。</strong></p><pre class="mv mw mx my fd mz lf na nb aw nc bi"><span id="d5f0" class="mh jr hi lf b fi nd ne l nf ng">type structExample struct {...}</span><span id="72d9" class="mh jr hi lf b fi nh ne l nf ng">...</span><span id="2232" class="mh jr hi lf b fi nh ne l nf ng">filter := jsonFilter.Filter{}<br/><br/>if filterValue != "" {<br/>   err := filter.Init(filterValue, structExample{})<br/>   if err != nil {<br/>      //<em class="jp">TODO error handling<br/></em>   }<br/>}</span></pre><p id="3707" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编译通过反射检查<strong class="is hj">包含在过滤器定义<strong class="is hj">中的字段是否存在于参数中的结构类型</strong>中。以及<strong class="is hj">类型是否符合</strong>；例如，您不能对字符串类型应用范围过滤器。<em class="jp">文档中描述了可能的错误。</em></strong></p><p id="bfb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">考虑复杂和嵌套类型(指针、对另一类型的引用、映射/数组/矩阵结构)</em></p><h2 id="5e57" class="mh jr hi bd js mi mj mk jw ml mm mn ka jb mo mp ke jf mq mr ki jj ms mt km mu bi translated">可定制的过滤器格式</h2><p id="5255" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">根据我的需要，我为过滤器定义了一种格式。这种格式<strong class="is hj">非常适合通过HTTP GET URL参数</strong>提供的字符串(我的用例)</p><pre class="mv mw mx my fd mz lf na nb aw nc bi"><span id="02b4" class="mh jr hi lf b fi nd ne l nf ng">key1=val1,val2:key2.subkey=val3</span></pre><p id="0425" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中:</p><ul class=""><li id="d632" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><code class="du lc ld le lf b">key1</code>是要过滤的JSON字段名。你可以使用组合过滤器来浏览你的JSON树，就像<code class="du lc ld le lf b">key2.subkey</code></li><li id="8a03" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">=</code>是操作员。<code class="du lc ld le lf b">!=</code> <code class="du lc ld le lf b">&gt;</code> <code class="du lc ld le lf b">&lt;</code>也可用</li><li id="aa6b" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">val1</code>、<code class="du lc ld le lf b">val2</code>、<code class="du lc ld le lf b">val3</code>是要比较的值</li><li id="ef54" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">这些值由逗号分隔<code class="du lc ld le lf b">,</code></li><li id="75e3" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">不同的字段由冒号分隔<code class="du lc ld le lf b">:</code></li></ul><p id="1c11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这种固执己见的<strong class="is hj">格式可能无法与</strong>的所有用例相匹配。您可能还想<strong class="is hj">限制嵌套字段的深度扫描</strong>。为此，<a class="ae jo" href="https://pkg.go.dev/github.com/guillaumeblaquiere/jsonFilter?tab=doc#Filter.SetOptions" rel="noopener ugc nofollow" target="_blank">您可以定制您的过滤器选项</a></p><pre class="mv mw mx my fd mz lf na nb aw nc bi"><span id="04ff" class="mh jr hi lf b fi nd ne l nf ng">filter := jsonFilter.Filter{}<br/><br/>	o := &amp;jsonFilter.Options{<br/>		MaxDepth:             		4,<br/>		EqualKeyValueSeparator:    	"=",<br/>  		GreaterThanKeyValueSeparator: 	"&gt;",<br/>		LowerThanKeyValueSeparator:   	"&lt;",<br/>		NotEqualKeyValueSeparator:    	"!=",<br/>		ValueSeparator:       		",",<br/>		KeysSeparator:        		":",<br/>		ComposedKeySeparator: 		".",<br/>	}<br/><br/>	filter.SetOptions(o)</span></pre><h2 id="735f" class="mh jr hi bd js mi mj mk jw ml mm mn ka jb mo mp ke jf mq mr ki jj ms mt km mu bi translated"><a class="ae jo" href="https://pkg.go.dev/github.com/guillaumeblaquiere/jsonFilter?tab=doc#Filter.ApplyFilter" rel="noopener ugc nofollow" target="_blank">应用过滤器</a></h2><p id="169e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">您可以<strong class="is hj">在struct </strong>的数组上应用过滤器(与编译/初始化步骤中提供的struct类型相同)。<em class="jp">通常，在应用过滤器之前，Firestore/Datastore查询结果必须映射到struct数组中。</em></p><p id="73d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该动作扫描数组中的所有元素，并由<strong class="is hj">驱逐不匹配的元素。</strong></p><pre class="mv mw mx my fd mz lf na nb aw nc bi"><span id="38ff" class="mh jr hi lf b fi nd ne l nf ng">results := getDummyExamples()</span><span id="7709" class="mh jr hi lf b fi nh ne l nf ng">if filterValue != "" {<br/>   ret, err := filter.ApplyFilter(results)<br/>   if err != nil {<br/>      //<em class="jp">TODO error handling<br/></em>   }<br/>   results = ret.([]structExample)<br/>}</span></pre><p id="16a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">就这些。所有不想要的值都从结果中删除</strong>，遵循以下规则:</p><ul class=""><li id="aef7" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">过滤器的每个元素必须返回OK以保持条目值</li><li id="e83a" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">等式<code class="du lc ld le lf b">=</code>，相当于sql子句中的:至少有一个值必须匹配。</li><li id="8efe" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">not equality <code class="du lc ld le lf b">!=</code>，相当于sql子句中的not:所有值不能匹配。</li><li id="cd3d" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">大于<code class="du lc ld le lf b">&gt;</code>和小于<code class="du lc ld le lf b">&lt;</code>:只能比较适用的一个数字。</li></ul></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h1 id="acc5" class="jq jr hi bd js jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn bi translated">解决的问题和限制</h1><p id="73ff" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">该库的目标是提出Firestore/Datastore默认提供的更高级的过滤器。它允许您解除限制:</p><ul class=""><li id="c0c0" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">允许过滤任何类型和嵌套类型(映射、数组、数组/对象的映射、映射/对象的数组等)</li><li id="2401" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">允许在数据集上使用几个过滤器<code class="du lc ld le lf b">IN</code></li><li id="e4ee" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">在<code class="du lc ld le lf b">IN</code>条件下使用超过10个元素</li><li id="9e3a" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">允许在数据集上使用多个过滤器<code class="du lc ld le lf b">NOT IN</code></li><li id="21b3" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">允许用<code class="du lc ld le lf b">&gt;</code>和<code class="du lc ld le lf b">&lt;</code>操作符比较几个范围</li><li id="0af3" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">不需要创建任何复合索引</li></ul><p id="0930" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由此，<strong class="is hj">所有的原生限制都被解决了！</strong></p><h2 id="55b8" class="mh jr hi bd js mi mj mk jw ml mm mn ka jb mo mp ke jf mq mr ki jj ms mt km mu bi translated">性能问题</h2><p id="d4f5" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">因为库扫描所有Firestore/Datastore结果，所以性能可能是个问题。<strong class="is hj">其实，它<em class="jp">应该</em>不会。</strong></p><p id="70b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，过滤器<strong class="is hj">应该只应用在一个小的struct </strong>数组上，并且过滤开销非常小。如果你阅读成千上万的文件，你将会付出很多代价！</p><p id="c04c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，由于需要恢复大量文档和过滤持续时间，您的API响应时间将会更长。</p><p id="ebee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">库是为方便消费者</strong>使用他们的过滤器而设计的，它有<strong class="is hj">不被用作核心数据库特性</strong>。</p><h1 id="a783" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">有什么愿望或想法吗？</h1><p id="0cec" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我有更新图书馆的想法，但我没有实施，因为我不需要它们。举个例子，</p><ul class=""><li id="a182" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">没有像*这样的通配符来替换任何JSON字段名或其一部分。</li><li id="b88f" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">过滤器值没有通配符，如*或正则表达式功能。</li></ul><p id="5faa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">根据我的需要，我将实现这些进化或其他</em>。</p><p id="37f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有特殊要求，我将很乐意讨论和改进这个库。不要犹豫<strong class="is hj">打开关于</strong> <a class="ae jo" href="https://github.com/guillaumeblaquiere/jsonFilter" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Github项目</strong> </a> <strong class="is hj"> </strong>的问题并为之做出贡献！</p></div></div>    
</body>
</html>