<html>
<head>
<title>The hidden superpowers of Stackdriver Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Stackdriver伐木公司隐藏的超能力</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/hidden-super-powers-of-stackdriver-logging-ca110dae7e74?source=collection_archive---------0-----------------------#2018-12-29">https://medium.com/google-cloud/hidden-super-powers-of-stackdriver-logging-ca110dae7e74?source=collection_archive---------0-----------------------#2018-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f6db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Stackdriver Logging是Google Cloud产品组合中最被低估的产品之一。首先，这是理所当然的，但第二，许多人不知道它的超能力。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/8bd5e7f469aeb48b160e4fcd438cc8b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BE959b9KbkIq-lZ8lW0How.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">【https://unsplash.com/photos/CqgbxNGsf6Y T2】号</figcaption></figure><p id="de1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这有点谷歌自己的错，因为一些惯用的客户端库没有公开这些特性。但是通过一点小技巧，你可以自己把它们添加到库中，正如<a class="ae jt" href="https://github.com/googleapis/google-cloud-go/commit/edf9523a34b344928c2061c06509556636e52cb3" rel="noopener ugc nofollow" target="_blank">我为这篇文章在google-cloud-go客户端库上做的</a>。</p><blockquote class="ju jv jw"><p id="4493" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">在本文中，我将使用<a class="ae jt" href="https://github.com/alexvanboxel/reactor" rel="noopener ugc nofollow" target="_blank">反应器</a>。<strong class="ih hj"> Reactor </strong>是一个用<strong class="ih hj"> golang </strong>编写的微服务，我写它是为了了解GCP的可观测性特性。您可以使用它来重现本文中描述的所有内容。按照<a class="ae jt" href="https://github.com/alexvanboxel/reactor" rel="noopener ugc nofollow" target="_blank">自述文件</a>中的说明，在本地或Kubernetes集群中设置它。本文假设安装在<strong class="ih hj"> GKE </strong>上。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/7e16bf6231825b93b664f7234dd38ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqVrI5Y7XlhzF1TRgP19Vw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">相关的跟踪和日志，以及额外的负载平衡器日志条目</figcaption></figure><h1 id="bef1" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">元数据和跟踪相关性</h1><p id="0b3a" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">第一个超能力是将日志与踪迹相关联。(你知道另一种具有这种能力的产品吗？如果你知道，请告诉我！).</p><p id="0d69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您使用OpenCensus进行追踪，这很容易实现，因为当前追踪和span id在上下文中是可用的。看看反应堆的内部记录器包(<code class="du lf lg lh li b">func <a class="ae jt" href="https://github.com/alexvanboxel/reactor/blob/master/pkg/rlog/rlog.go" rel="noopener ugc nofollow" target="_blank">addSpan</a></code>)。它展示了如何从上下文中提取span id，并将其添加到发送给stackdriver API的LogEntry中。</p><p id="241f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的跟踪是用<code class="du lf lg lh li b"><em class="jx">http://&lt;your_host&gt;/rr/split?molecule=[[H]]^[O]</em></code>调用reactor生成的。Reactor会对自己进行一些http调用，但是当您转到跟踪控制台时，您会注意到在跟踪之间您会看到<strong class="ih hj">日志条目</strong>。您唯一需要做的就是确保Trace和SpanID被添加到LogEntry中。</p><p id="3783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于reactor使用配置了Stackdriver export和h<strong class="ih hj">header propagation</strong>的OpenCensus Trace，因此它理解Stackdriver头格式。Reactor安装在Google Kubernetes引擎上，通过HTTP负载平衡器(使用k8s ingress)路由来电。因为负载平衡器生成第一个跨度，所以OpenCensus会选取它，并继续在负载平衡器跟踪中添加跨度。这就是为什么您还会在跟踪中看到<strong class="ih hj">负载平衡器日志</strong>(截图中的日志行3)。</p><h1 id="5485" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将k8s标准输出/错误与自定义日志记录相关联</h1><p id="6520" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在启动时，不可能直接记录到Stackdriver日志，因为您需要首先初始化客户端连接。当时登录到<strong class="ih hj"> stdout </strong>没有问题。因为Google Kubernetes引擎聚合了Stackdriver Logging中的日志，所以我们有机会将自定义日志与GKE捕获的标准日志连接起来。这是使用<a class="ae jt" href="https://cloud.google.com/monitoring/api/resources" rel="noopener ugc nofollow" target="_blank">监控资源</a>完成的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/4367df5990a81e6722c15b8d3e748be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1i7-KB5rAWB9k068mfZBg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">与容器stdout/err相关的自定义日志</figcaption></figure><p id="b30d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当集群启用了新的<strong class="ih hj">beta</strong>stack driver Kubernetes监控时，将在<a class="ae jt" href="https://cloud.google.com/monitoring/api/resources#tag_k8s_container" rel="noopener ugc nofollow" target="_blank"> k8s_container </a>资源下捕获容器标准输出和错误。</p><p id="3671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们登录到同一个资源时，对您的自定义日志和标准输出进行分组会更容易。它甚至可以在Kubernetes工作负载屏幕中开箱即用。如果您选择其中一个窗格并转到<em class="jx">查看日志</em>，您将同时看到自定义日志和stdout/err。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/dae595e36229dd465e0fd0bff433b25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EubfUVPEa3vuwxxhCjla9g.png"/></div></div></figure><h1 id="a88c" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">错误报告</h1><p id="d2bc" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">另一个超能力是从日志条目创建错误报告的能力。</p><p id="1733" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看为下面的调用生成的跟踪:<code class="du lf lg lh li b"><em class="jx">http://&lt;your_host&gt;/rr/split?molecule=broken</em></code> <em class="jx">。</em> Reactor对这个破碎的分子不是很满意，所以它向用户返回一个错误并记录一个错误。您会再次看到错误与跟踪以及负载平衡器日志条目混合在一起，作为一个警告。</p><p id="a885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您以特定的方式格式化您的日志条目，则会创建一个<strong class="ih hj">错误报告</strong>。要做到这一点，可以在源代码中添加一个发生错误的位置或一个完整的堆栈跟踪。有关如何格式化消息的更多详细信息，请参见此处的文档:<a class="ae jt" href="https://cloud.google.com/error-reporting/docs/formatting-error-messages" rel="noopener ugc nofollow" target="_blank">stack driver日志记录中的格式化错误</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/ff9ac6c3489e7429bb575bd635b68940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fLFQGzRMc2Ks94fRyPu-w.png"/></div></div></figure><p id="71d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">错误报告是一项伟大的服务。它记录了你所有的主要错误，包括许多有用的信息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/0a2178382491974489ca8a1efc58f9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cn3iaQ1NitcWIlcbOEe1Xg.png"/></div></div></figure><p id="afac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">信息包括:错误发生的<strong class="ih hj">第一次</strong>时间和<strong class="ih hj">最后一次</strong>时间、<strong class="ih hj">发生的次数</strong>以及最近几天所有发生的详细图表。它还显示了发生错误的所有<strong class="ih hj">版本</strong>，这是一个有用的指标，可以帮助您跟踪发生错误的第一个版本。它还显示了一些<strong class="ih hj">日志条目的最近样本</strong>。</p><p id="ce93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要记住的一件重要事情是，不是所有的异常都应该以错误报告结束。如果您的代码中出现错误，并且可以处理，不要这样记录，否则错误报告将充满错误，变得毫无用处。所以在记录你的错误时要明智。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ln"><img src="../Images/ad0eb3eacf4f8eadfcc96cf8d118d444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*e6IhBkc4d6ipiX-OXALUoA.png"/></div></figure><h1 id="1d9d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">InsertId</h1><p id="142d" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">当设计一个api时，你需要意识到当一个错误发生时，你不能向你的API客户泄露太多的信息。如果它能帮助API用户纠正错误，尽一切办法返回该信息，但确保不要泄漏敏感信息。</p><p id="8b78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在不能通过API返回敏感信息的情况下，您仍然可以记录这些信息并返回一个惟一的InsertId，特权用户可以使用它来搜索日志。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/748391f8257896a69683c99596261043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJG74_eD4yAjsYsbqgkKVw.png"/></div></div></figure><p id="8dc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，这并不意味着您可以全权记录所有内容。仍然考虑你记录什么信息来保护你的用户的隐私。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/e2d9f9a1f23367ce27040b46e8df1609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Sv1zaffkZJ3VewgwanfHg.png"/></div></div></figure><h1 id="ed05" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">BigQuery</h1><p id="2fc4" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果我们在谈论超能力，我们应该谈论其中最大的超能力:BigQuery。BigQuery的前身是Google内部创建的，用来处理它的大量日志，那么我们为什么不能利用它来处理我们自己的日志呢？</p><p id="fba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">日志接口使得将日志导出到BigQuery、云存储或Pub/Sub变得很容易。</p><p id="f17f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导出的日志为每个日志生成一个带有结构化行的分区表。BigQuery能够在一行中拥有不同的重复结构和列，这使得将丰富的日志条目表示为结构化数据变得非常容易。另外，您不必担心云日志的保留政策，因为BigQuery可以永久保留您的日志。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/83ed80249fb51d594965fd9a71c332f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*HcMDqQ6vSN4cl89cnL8Qjw.png"/></div></figure><h1 id="86b7" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">公开普查记录</h1><p id="f53f" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我认为用户仍然需要做太多的管道工作来获得大部分的日志超级能力，但是我有希望:目前开放的人口普查日志规范周期正在进行，希望它将把工具带给用户，他们不需要考虑管道。</p><p id="36d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我对开放式人口普查规范的愿望清单:</p><ul class=""><li id="3629" class="lr ls hi ih b ii ij im in iq lt iu lu iy lv jc lw lx ly lz bi translated">在启动时设置资源(MonitoredResource)，最好是自动检测或提供如何设置的明确指导(例如标准环境变量)。</li><li id="b7b2" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">启动时设置应用程序名称和版本。</li><li id="6373" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">请求上下文感知。</li><li id="c381" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">跨上下文感知。</li><li id="09d6" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">访问InsertId，这样就可以将它返回给用户。</li><li id="a114" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">用户知道，但有可能混淆用户(可插拔)。</li><li id="e206" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">带有命名参数的结构化格式化日志记录，这些参数可以作为标签在日志条目中公开。使得搜索其他值比搜索用户更容易。</li><li id="c268" class="lr ls hi ih b ii ma im mb iq mc iu md iy me jc lw lx ly lz bi translated">源代码位置感知</li></ul><p id="7862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们希望制定规范的人会阅读这篇文章，而不是通过将它们锁在抽象背后来剥夺我使用这些特性的能力。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="b53a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">享受开发超能力的乐趣吧，这会让在生产中运行你的代码的人高兴。</p></div></div>    
</body>
</html>