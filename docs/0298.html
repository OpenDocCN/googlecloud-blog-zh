<html>
<head>
<title>BigQuery partitioning with Beam streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于波束流的大查询划分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-partitioning-with-beam-streams-97ec232a1fcc?source=collection_archive---------1-----------------------#2017-06-01">https://medium.com/google-cloud/bigquery-partitioning-with-beam-streams-97ec232a1fcc?source=collection_archive---------1-----------------------#2017-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/6c5dc44c6cd7c770ded457292755ad58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn1-gNG5ZFiR3pjJXpfjjw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/photos/rHbob_bEsSs" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/rHbob_bEsSs</a></figcaption></figure><div class=""/><p id="efa2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你一直在使用谷歌大查询，你就会知道它能以创纪录的速度处理大量数据。它是GCP最成熟的产品之一，是工程师和非技术人员了解业务数据的窗口。如果你懂SQL，你可以使用BigQuery。</p><blockquote class="jt"><p id="b6dd" class="ju jv hy bd jw jx jy jz ka kb kc js dx translated">本文假设你对<a class="ae hv" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>和<a class="ae hv" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Beam </a> ( <a class="ae hv" href="https://cloud.google.com/dataflow/" rel="noopener ugc nofollow" target="_blank">云数据流</a>)有所了解</p></blockquote><p id="e6f2" class="pw-post-body-paragraph iv iw hy ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">但是成本呢？您只需为查询的数据量付费(在撰写本文时，大约每万亿美元)。一般来说，你不会花很多钱做典当分析。需要注意的是，当您开始将BigQuery与Tableau等提供实时仪表板的数据可视化工具集成时。我记得有一个案例，在一个实时仪表板上，一些查询一天被触发数千次，导致成本大幅上升。</p><p id="306c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，有一些技术可以限制查询所需的数据量。首先，从只选择你需要的<strong class="ix hz">列开始，所以千万不要用星号(*)。因为BigQuery使用列存储系统，所以它只会遍历您选择或搜索的列，只有这些列会被计费。</strong></p><h1 id="c8ad" class="ki kj hy bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">分区表</h1><p id="827a" class="pw-post-body-paragraph iv iw hy ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">但是大多数时候你知道你只需要搜索你的表的一部分。当然，如果你的数据有日期成分。如果你只对过去两周感兴趣，你不需要搜索整个数据集。为此，BigQuery引入了分区表。</p><p id="6849" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分区表是被分成不同碎片的表，这使得管理数据更加容易。目前，BigQuery只提供日分区表，这意味着数据每天都被分割成分区。</p><p id="dce5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些表有一个包含日值的伪列(<em class="ll"> _PARTITIONTIME </em>)。该day值表示该行所在的day分区，这样可以很容易地限制您包含和遍历的分区集。您可以在标准的<em class="ll">中使用它，其中</em>子句和BigQuery将自动包含正确的分区。请看下面的<em class="ll"> WHERE </em>子句:</p><figure class="ln lo lp lq fd hk er es paragraph-image"><div class="er es lm"><img src="../Images/7fd956aa64e8ea53d1ff45a1e417af62.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*XjFyu8XjCWNFP559nWbmrg.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/photos/24tsXm7qGQE" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/24tsXm7qGQE</a></figcaption></figure><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="1edd" class="lw kj hy ls b fi lx ly l lz ma">WHERE<br/>  _PARTITIONTIME <br/>  BETWEEN <br/>  TIMESTAMP("2017-06-01")<br/>  AND <br/>  TIMESTAMP("2017-06-14")</span></pre><p id="f773" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将只选择相关的表，并且只计算一小部分的成本，然后执行一个遍历整个数据集的查询。查看<a class="ae hv" href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多信息。</p><h1 id="916b" class="ki kj hy bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">插入数据</h1><p id="0ac6" class="pw-post-body-paragraph iv iw hy ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">不过，控制数据所在的分区可能有点棘手。您可以在<em class="ll"> _PARTITIONTIME </em>中插入一个值，而行将在正确的分区中结束，这是因为该列是一个<em class="ll">只读伪列</em>。但是如果您不做任何事情，这些行将会在当天的分区中结束。在一些流用例中，这可能已经足够了，但是对于像我这样的控制狂来说，这还不够好。</p><p id="1721" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">控制目标分区的方法是使用表装饰器。因此，如果您想将数据放入新年分区，您的目的地应该是<strong class="ix hz"> tablename$20170101 </strong>。<a class="ae hv" href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener ugc nofollow" target="_blank">文档</a>中有几个在加载作业中这样做的例子，但是在流<a class="ae hv" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank">光束</a>作业中如何做到呢？</p><h2 id="18a6" class="lw kj hy bd kk mb mc md ko me mf mg ks jg mh mi kw jk mj mk la jo ml mm le mn bi translated">自动分区流</h2><p id="196a" class="pw-post-body-paragraph iv iw hy ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">诀窍(也是一个很好的秘密)是使用TableDestination函数。这是您提供给<strong class="ix hz"> BigQueryIO的一个函数。用一个<strong class="ix hz">写</strong>。至</strong>法。这并不广为人知，因为所有的例子都只提供了一个固定的输出表。</p><p id="6598" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该函数的目的是将元素映射到表中。一旦<a class="ae hv" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Beam </a>管道遇到新窗口，它将调用函数来查看表名应该是什么。</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mo mp l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">获取固定窗口，并向BigQuery编写器提供TableReference函数。</figcaption></figure><p id="26e8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，当你建立你的光束管道，确保有一个窗口集，不相交的一天。我最喜欢的是1分钟的固定窗口，这样我们就不必等待数据到达BigQuery。当我们查看函数时，您会看到为什么需要一个窗口，然后将函数提供给。发挥作用。</p><p id="3233" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该函数执行从ValueInSingleWindow到TableDestination的转换。奇迹就发生在这里。因此，对于每个窗口，这个函数将被调用，您可以创建正确的表名。</p><figure class="ln lo lp lq fd hk"><div class="bz dy l di"><div class="mo mp l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://gist.github.com/alexvanboxel/0f38ceb5ccebbccebcd759576be428c2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/alexvanboxel/0 f 38 CEB 5 ccebbcbcd 759576 be 428 c 2</a></figcaption></figure><p id="d03c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有界窗口有一个有趣的方法，那就是maxTimestamp。如果您使用它并将其截断为一天，您就有了目标分区。而且不用担心，最大时间戳真的没问题，看例子:</p><blockquote class="jt"><p id="cbe5" class="ju jv hy bd jw jx jy jz ka kb kc js dx translated">max = 2017–01–01t 23:59:59.99999 &gt; &gt; &gt;表名$20170101</p></blockquote><p id="7334" class="pw-post-body-paragraph iv iw hy ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">因此，使用修饰后的(tablename$YYYYMMDD)表引用，数据将最终出现在正确的分区中。不过，在进行流式处理时，要确保表以正确的模式存在。</p><p id="7df4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这样了。现在，您可以将数据传输到正确的分区中，<em class="ll">不必担心</em>较晚的数据会到达不正确的分区。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="ada3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的例子你可以看看GitHub上的<strong class="ix hz">发布备份</strong>示例报告:</p><div class="hh hi ez fb hj mx"><a href="https://github.com/alexvanboxel/pubsub-backup" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hz fi z dy nc ea eb nd ed ef hx bi translated">alexvanboxel/pubsub-backup</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">通过在GitHub上创建一个帐户来为pubsub-backup开发做贡献。</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl hp mx"/></div></div></a></div><p id="54d4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它已经适应了阿帕奇梁2.0</p></div></div>    
</body>
</html>