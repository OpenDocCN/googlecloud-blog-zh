<html>
<head>
<title>Fast GCS Downloads with C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C++快速下载GCS</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/fast-gcs-downloads-with-c-e5c749bde05e?source=collection_archive---------1-----------------------#2021-03-08">https://medium.com/google-cloud/fast-gcs-downloads-with-c-e5c749bde05e?source=collection_archive---------1-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7e29" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">卡洛斯·奥赖安(谷歌)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/fbd6f76e27a29de8de51d84299fb2bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*9cVpDMg-Wl8zlUSiPdPSWQ.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">带有文本“快速GCS下载”的未更改的C++徽标。在<a class="ae jj" href="http://isocpp.org/" rel="noopener ugc nofollow" target="_blank">isocpp.org</a>了解更多关于标准C++的知识</figcaption></figure><p id="a1c4" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">有时候，你只是想知道:下载能有多快？我们都知道云存储服务可以水平扩展，但有时您只需要尽快将一个大文件下载到虚拟机。在本帖中，我们将讨论一个我们编写的小程序来帮助解决这些问题。它既可以作为较大工作负载的一部分，也有助于故障排除，因为它消除了一些可能的瓶颈。</p><p id="0724" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这个程序的思想很简单:要下载一个大文件，从GCS打开N个并行流，每个流下载文件的一个“片段”。然后将切片写在文件的右边部分。然而，还有一些额外的考虑:</p><ul class=""><li id="bd2d" class="kg kh hi jm b jn jo jq jr jt ki jx kj kb kk kf kl km kn ko bi translated">这种方法要求您的文件系统支持稀疏文件，这使得它不适合某些FUSE文件系统和某些文件类型。</li><li id="3ae2" class="kg kh hi jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko bi translated">在我们的测试中，解密每个流需要大约40%的GCE vCPU，虽然实际的百分比可能因虚拟机型号而异，但应该清楚的是，不能创建无限数量的流。这个程序(可能比较保守)为每个vCPU创建2个线程。如果您想改变这一点，程序从命令行接受不同数量的线程。</li><li id="2ae5" class="kg kh hi jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko bi translated">因为启动一个流需要几毫秒的时间，所以创建非常小的片是不值得的(想想100个片的极端情况，每个1字节长)。即使有足够的vCPUs来处理额外的工作，也是如此。</li></ul><p id="932f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">即使在相对较小的虚拟机上，该程序也可以实现非常高的吞吐量。例如，我们能够使用一个<em class="ku"> c2-standard-4 </em>虚拟机以超过1gb/s的速度下载一个32GiB的文件:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="8c64" class="la lb hi kw b fi lc ld l le lf">Downloading file-32GiB.bin from bucket xxxxxx to file /s/foo.bin</span><span id="7ed6" class="la lb hi kw b fi lg ld l le lf">This object size is approximately 32GiB. It will be downloaded in 8 slices, each approximately 4GiB in size.<br/>… … …<br/>…<br/>Download completed in 29643ms<br/>Effective bandwidth <strong class="kw hj">1105.42 MiB/s</strong></span><span id="4194" class="la lb hi kw b fi lg ld l le lf">File size and CRC32C match expected values</span></pre><p id="39ff" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">说了这么多，让我们进入代码并解释它在做什么。你可以在GitHub 上找到完整的程序。敏锐的读者可能会注意到这个程序使用了C++17的特性。我们认为在这个例子中会产生更多可读的代码。如果您使用的是C++11或C++14，不用担心，这个库支持这两个版本。</p><p id="0a29" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">程序需要做的第一件事是找出我们想要下载多大的对象，这只用两行代码就完成了:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="6024" class="la lb hi kw b fi lc ld l le lf">auto client = gcs::Client::CreateDefaultClient().value();<br/>auto metadata = client.GetObjectMetadata(bucket, object).value();</span></pre><p id="91df" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">注意<code class="du lh li lj kw b">.value()</code>的使用，C++客户端库从大多数函数中返回<code class="du lh li lj kw b">StatusOr&lt;T&gt;</code>。这是一种包含结果或错误的结果类型。<code class="du lh li lj kw b">.value()</code>成功时返回包含的值，出错时抛出异常。由于客户端库已经重试了大多数操作，像这样的简单程序可以记录这些错误并退出，没有必要实现重试循环，因为库已经包含了它。C++异常是表达控制流的一种自然方式。更复杂的应用程序可以在调用点检查错误代码，并在出错的情况下继续工作，也许是在某种降级模式下。</p><p id="b20a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">一旦我们有了关于目标对象大小的信息，我们就可以简单地计算执行这个下载的片大小和线程数量。我们使用一个小函数来计算每个切片的大小:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="1fee" class="la lb hi kw b fi lc ld l le lf">namespace po = boost::program_options;</span><span id="1fcd" class="la lb hi kw b fi lg ld l le lf">std::vector&lt;std::int64_t&gt; compute_slices(<br/>    std::int64_t object_size,<br/>    po::variables_map const&amp; vm) {<br/>auto const minimum_slice_size =<br/>    vm[“minimum-slice-size”].as&lt;std::int64_t&gt;();<br/>auto const thread_count = vm[“thread-count”].as&lt;int&gt;();<br/>std::vector&lt;std::int64_t&gt; result;<br/>// … explanation continues below …</span></pre><p id="8d39" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果对象足够大，该函数会使每个切片的大小大致相等:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="1d32" class="la lb hi kw b fi lc ld l le lf">… … …<br/>auto const thread_slice = object_size / thread_count;<br/>if (thread_slice &gt;= minimum_slice_size) {<br/>  std::fill_n(<br/>      std::back_inserter(result), thread_count, thread_slice);</span></pre><p id="6888" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">当然，我们需要处理对象大小不是线程数量的倍数的情况。我们给最后一个片额外的字节:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="61d5" class="la lb hi kw b fi lc ld l le lf">… … …<br/>  result.back() += object_size % thread_count;<br/>  return result;<br/>}</span></pre><p id="658a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">最后，如果对象尺寸太小，我们只需创建足够的最小尺寸的切片:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="e8ef" class="la lb hi kw b fi lc ld l le lf">… … …<br/>  for (; object_size &gt; 0; object_size -= minimum_slice_size) {<br/>    result.push_back(std::min(minimum_slice_size, object_size));<br/>  }<br/>  return result;<br/>}  // compute_slices()</span></pre><p id="89c5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">大部分工作是下载每个切片。这是在一个小函数中定义的，所以我们可以在不同的线程中调度工作。该函数接收桶的名称和要下载的对象，以及要从所述对象下载的字节范围。最后，它接收一个文件描述符，接收到的字节将存储在该文件描述符中:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="f2ea" class="la lb hi kw b fi lc ld l le lf">std::string task(<br/>    std::int64_t offset, std::int64_t length,<br/>    std::string const&amp; bucket, std::string const&amp; object,<br/>    int fd) {<br/>  // … explanation continues below …</span></pre><p id="39ec" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们在每个线程中创建一个单独的客户端，以最大限度地减少争用，然后开始所需范围的下载:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="171d" class="la lb hi kw b fi lc ld l le lf">… … …<br/>  auto client = gcs::Client::CreateDefaultClient().value();<br/>  auto is = client.ReadObject(<br/>      bucket, object, gcs::ReadRange(offset, offset + length));</span></pre><p id="1923" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们将以相对较大的块读取数据，在本例中为1mb，这将最小化<code class="du lh li lj kw b">pwrite()</code>的系统调用开销(见下文)。下载是流式的，所以除了通常的函数调用开销之外，读取块大小对下载性能没有太大影响。我们还需要跟踪这些数据需要写入文件的哪个位置:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="fd28" class="la lb hi kw b fi lc ld l le lf">… … …<br/>  std::vector&lt;char&gt; buffer(1024 * 1024L);<br/>  std::int64_t count = 0;<br/>  std::int64_t write_offset = offset;</span></pre><p id="09ca" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">然后我们只读取一个块，如果有错误，我们就停止。注意<code class="du lh li lj kw b">.read()</code>的用法；当您使用这个(C++ iostreams的标准)函数时，客户端库会最小化复制。这是读取未格式化数据的最有效方式:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="6486" class="la lb hi kw b fi lc ld l le lf">… … …<br/>  do {<br/>    is.read(buffer.data(), buffer.size());<br/>    if (is.bad()) break;</span></pre><p id="8c8c" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">利用缓冲区中的数据，我们更新一些计数器并写入目标文件描述符。注意我们用的是<code class="du lh li lj kw b">is.gcount()</code>；虽然客户端库总是等到缓冲区满了，但切片可能不是缓冲区大小的倍数，最终可能会收到一个“短”缓冲区:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="1fd5" class="la lb hi kw b fi lc ld l le lf">… … …<br/>    count += is.gcount();<br/>    check_system_call(“pwrite()”,<br/>        ::pwrite(fd, buffer.data(), is.gcount(), write_offset));<br/>    write_offset += is.gcount();</span></pre><p id="8203" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">最后，我们继续读取，直到切片被完全下载，然后返回一些信息性消息:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="30cd" class="la lb hi kw b fi lc ld l le lf">… … …<br/>  } while (not is.eof());<br/>  return fmt::format(<br/>      “Download range [{}, {}] got {}/{} bytes”, offset,<br/>      offset + length, count, length);<br/>} // task()</span></pre><p id="9732" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这是大部分的工作。我们确实需要调度这些线程:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="d08e" class="la lb hi kw b fi lc ld l le lf">auto slices = compute_slices(metadata.size(), vm);<br/>std::vector&lt;std::future&lt;std::string&gt;&gt; tasks(slices.size());<br/>std::int64_t offset = 0;<br/>std::transform(<br/>    slices.begin(), slices.end(), tasks.begin(),<br/>    [&amp;](auto length) {<br/>      auto f = std::async(<br/>          std::launch::async, task, offset, length, bucket,<br/>          object, fd);<br/>    offset += length;<br/>    return f;<br/>});</span></pre><p id="aa2f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">然后等待他们:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="9c15" class="la lb hi kw b fi lc ld l le lf">for (auto&amp; t : tasks) std::cout &lt;&lt; t.get() &lt;&lt; “\n”;</span></pre><p id="166a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">创建目标文件也只需要几行代码。可惜这是比较低级的代码。我们需要执行并发写入，但是没有一个标准C++工具(iostreams)或最常用的库(Boost.org)支持它们。所以我们只是求助于一些POSIX APIs:</p><pre class="iy iz ja jb fd kv kw kx ky aw kz bi"><span id="48d1" class="la lb hi kw b fi lc ld l le lf">auto constexpr kOpenFlags = O_CREAT | O_TRUNC | O_WRONLY;<br/>auto constexpr kOpenMode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;<br/>auto const fd = check_system_call(<br/>    “open()”, ::open(destination.c_str(), kOpenFlags, kOpenMode));<br/>… … …<br/>check_system_call(“close(fd)”, ::close(fd));</span></pre><p id="6f56" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">当然，有一些代码可以处理命令行解析并报告性能结果，但这没什么意思。</p><h1 id="6917" class="lk lb hi bd ll lm ln lo lp lq lr ls lt io lu ip lv ir lw is lx iu ly iv lz ma bi translated">感谢阅读！</h1><p id="459d" class="pw-post-body-paragraph jk jl hi jm b jn mb ij jp jq mc im js jt md jv jw jx me jz ka kb mf kd ke kf hb bi translated">如果你认为这很有趣，今天就在GitHub上给我们一颗星吧。你可以找到更多关于谷歌云<a class="ae jj" href="https://github.com/googleapis/google-cloud-cpp" rel="noopener ugc nofollow" target="_blank"> C++客户端库</a>的例子和文档。</p></div></div>    
</body>
</html>