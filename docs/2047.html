<html>
<head>
<title>Configure Google Cloud Armor using OpenAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenAPI配置谷歌云装甲</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/configure-google-cloud-armor-using-openapi-64ba16ac040e?source=collection_archive---------2-----------------------#2022-01-06">https://medium.com/google-cloud/configure-google-cloud-armor-using-openapi-64ba16ac040e?source=collection_archive---------2-----------------------#2022-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；我构建了一个简单的工具，用于根据OpenAPI 3规范生成云装甲安全策略。去这里看看<a class="ae jd" href="https://github.com/GoogleCloudPlatform/professional-services/tree/main/tools/openapi-to-cloud-armor" rel="noopener ugc nofollow" target="_blank">https://github . com/Google cloud platform/professional-services/tree/main/tools/open API-to-cloud-armor</a></strong></p><p id="6b6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Web应用程序防火墙(WAF)来保护您的应用程序免受威胁是一种最佳实践。像Google的Cloud Armor这样的托管、经济高效的服务为我们提供了保护，防止常见的攻击，如SQL注入、跨站点脚本，甚至是像最近log4shell ( <a class="ae jd" href="https://cloud.google.com/armor/docs/rule-tuning" rel="noopener ugc nofollow" target="_blank">链接</a>)这样的新漏洞。</p><p id="2748" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进一步提高安全性，基于应用程序API配置WAF规则是一个好主意。但这可能是一项繁琐的任务。理想情况下，您会希望API上的更改作为CI/CD管道的一部分自动传播到WAF规则。</p><p id="67c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有一个OpenAPI规范，无论是通过API优先的方法(<a class="ae jd" href="https://openapi-generator.tech/docs/generators/" rel="noopener ugc nofollow" target="_blank">链接</a>)，还是从您实现的代码中生成一个规范(<a class="ae jd" href="https://www.baeldung.com/spring-rest-openapi-documentation" rel="noopener ugc nofollow" target="_blank">链接</a>)，您都有一个很好的基础来做到这一点。OpenAPI规范包含可以在API上调用的各种操作，因此可以解析这些操作，以便基于HTTP方法和路径为WAF创建规则。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5191e17f10b8313a541951c46ee9fdff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Om4crrFNn9HUdxeOTrED1w.png"/></div></div></figure><p id="4987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我实现的O <a class="ae jd" href="https://github.com/GoogleCloudPlatform/professional-services/tree/main/tools/openapi-to-cloud-armor" rel="noopener ugc nofollow" target="_blank"> penAPI-to-Cloud-Armor转换器</a>运行于一个OpenAPI规范，并基于规范中的路径和HTTP方法创建一个Cloud Armor安全策略。该规则具有低优先级的默认拒绝，有效的路径和方法将导致允许。</p><p id="6ea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">云甲有一些<a class="ae jd" href="https://cloud.google.com/armor/quotas" rel="noopener ugc nofollow" target="_blank">限制和配额</a>我们需要在规则大小、规则数量和规则长度方面进行处理:</p><ul class=""><li id="0138" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">有一个配额，我们最多可以在一个项目中有20个使用表达式的规则。</li><li id="e8f8" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">使用表达式语言的规则只能有5个子表达式</li><li id="d480" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">每个表达式只能有一个正则表达式匹配</li><li id="f456" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">表达式不能超过2048个字符，子表达式不能超过1024个字符</li></ul><p id="024a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着对于大型规则，我们可能需要在规则结构方面做出一些妥协和优化。这意味着每个API操作一个规则的方法是行不通的，我们需要将方法和路径结合起来。因此，转换器可以在三种模式下运行，可以通过相应的标志进行选择:</p><ul class=""><li id="9c62" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj"> Methodwise </strong>为每个HTTP方法创建一个规则，以及一个包含该方法上允许的所有路径的正则表达式。假设规则的数量为4 (GET、PUT、POST、DELETE)是合理的，但是如果有很多路径，那么路径的正则表达式可能会超过子表达式的长度限制。</li><li id="7925" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj"> Pathwise </strong>为每条路径创建一个规则，并为路径上允许的所有方法创建一个or。这是最简单明了的规则。但是如果API中有许多路径，可能会导致规则配额耗尽。</li><li id="341f" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj"> Compressed </strong>创建一个规则，包含所有已定义的HTTP方法和路径。有一点风险，即路径可能被无效的方法访问，并且单个规则表达式超过了子表达式的长度限制。</li></ul><p id="5ec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我个人认为<strong class="ih hj">方式的</strong>模式是最有用的，因为它创建了一组有限的规则，子表达式长度限制应该适合大多数API。因此我把这个模式设为默认模式；-).</p><p id="bbc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用正则表达式检查路径。正则表达式减少了，因为路径<code class="du ke kf kg kh b">/user/login</code>可能已经包含在另一个操作的路径<code class="du ke kf kg kh b">/user/{userId}</code>中。目前没有进一步的压缩。</p><p id="b116" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了为流行的<a class="ae jd" href="https://raw.githubusercontent.com/openapitools/openapi-generator/master/modules/openapi-generator/src/test/resources/3_0/petstore.yaml" rel="noopener ugc nofollow" target="_blank"> Petstore API示例</a>生成安全策略，您只需执行以下命令:</p><pre class="jf jg jh ji fd ki kh kj kk aw kl bi"><span id="96cf" class="km kn hi kh b fi ko kp l kq kr">go run main.go -input https://raw.githubusercontent.com/openapitools/openapi-generator/master/modules/openapi-generator/src/test/resources/3_0/petstore.yaml</span></pre><p id="012f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由此产生的策略YAML将包含5个规则。优先级最低的最后一个规则是默认的拒绝规则。GET、POST、PUT和DELETE方法有4条规则，每个方法的不同路径都简化为一个正则表达式。以下仅是生成的YAML的GET方法的规则:</p><pre class="jf jg jh ji fd ki kh kj kk aw kl bi"><span id="f708" class="km kn hi kh b fi ko kp l kq kr">- action: allow<br/>  description: Generated rules for method GET<br/>  kind: compute#securityPolicyRule<br/>  priority: 1000<br/>  match:<br/>    expr:<br/>      expression: <strong class="kh hj">request.method=='GET' &amp;&amp; request.path.matches('/pet/[^/]*$|/store/inventory$|/store/order/[^/]*$|/user/[^/]*$')</strong></span></pre><p id="7513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在GitHub上找到转换器的完整代码。如果你给它一个旋转或整合到你的CI/CD管道，我会感谢你的反馈。</p><div class="ks kt ez fb ku kv"><a href="https://github.com/GoogleCloudPlatform/professional-services/tree/main/tools/openapi-to-cloud-armor" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">专业服务/工具/openapi-to-cloud-armor at main …</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">这个工具是OpenAPI规范到云装甲规则的简单转换器。你可以把它作为你的一部分…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">github.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj jo kv"/></div></div></a></div></div></div>    
</body>
</html>