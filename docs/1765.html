<html>
<head>
<title>BigQuery Fixed-Width Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery固定宽度比较</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-fixed-width-comparison-958b1fd02b37?source=collection_archive---------1-----------------------#2021-01-19">https://medium.com/google-cloud/bigquery-fixed-width-comparison-958b1fd02b37?source=collection_archive---------1-----------------------#2021-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f833" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">又是一天，又是一个挑战—一位客户想要解析和比较固定宽度的文本文件。这些文件经常被大型机使用，并用于数据交换。这是为了用遗留管道验证一些新的基于BigQuery的管道。</p><p id="8efa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些文件是-</p><ul class=""><li id="5185" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">换行符分隔(就像普通的Unix/Mac文本文件一样)</li><li id="a30d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">分成固定数量字符的字段</li><li id="fdca" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">根据需要用空格填充数字和字符串，以形成宽度</li><li id="6ba5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">可以有几个不同的记录类型(它可以非常依赖于一个众所周知的记录类型字段)</li></ul><p id="9a0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jr">可以用BigQuery解决这个吗？是的。我会告诉你怎么做。</em>T3】</strong></p><h1 id="3fd1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">概观</h1><p id="f27c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在这篇博文中，我们将-</p><ul class=""><li id="004b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">根据GCS中的固定宽度文件创建一个外部CSV表</li><li id="d900" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">使用配置表— <em class="jr">它也可以在GCS中</em></li><li id="77c3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">创建一个视图来提取要比较的字段</li><li id="7e2a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">与帮助函数进行比较</li></ul><h1 id="5d79" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">题外话:UTF-8对ISO-8859–1</h1><p id="ecd4" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">BigQuery有两种用于解释CSV文件的字符编码:UTF-8和ISO-8859–1。许多规范不会提到字符编码，因此了解它们的历史会很有用。</p><p id="2c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jr">注意:这是作者的节略摘要——可能会遗漏一些细节，但这会让你更好地理解任何进一步的研究。</em></p><h2 id="88f7" class="kv jt hi bd ju kw kx ky jy kz la lb kc iq lc ld kg iu le lf kk iy lg lh ko li bi translated">ASCII: 8位字符，7位标准</h2><p id="e463" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">ASCII <a class="ae lj" href="https://en.wikipedia.org/wiki/ASCII#Bit_width" rel="noopener ugc nofollow" target="_blank">以7位(128)字符集开始</a>，但使用8位(一个字节，或256字符集)编码。这留下了用于奇偶校验或其他目的的备用位。<em class="jr">如果所有字符都使用这个字符子集，那么ISO-8859–1和UTF-8是相同的。</em></p><h2 id="ff16" class="kv jt hi bd ju kw kx ky jy kz la lb kc iq lc ld kg iu le lf kk iy lg lh ko li bi translated">ISO-8859–1</h2><p id="bfa4" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">ISO-8859–1将任何剩余高位(剩余128个字符)解释为某个<a class="ae lj" href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="noopener ugc nofollow" target="_blank">扩展字符集</a>。无论如何，每个字节都是一个字符。这使得查找第N个字符变得容易得多——只需转到第N个字节。</p><p id="7608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jr">除非规范要求UTF-8，否则我建议使用ISO-8859–1。固定宽度文件格式的时代早于UTF-8的普及。</em></p><h2 id="147d" class="kv jt hi bd ju kw kx ky jy kz la lb kc iq lc ld kg iu le lf kk iy lg lh ko li bi translated">UTF-8</h2><p id="97c8" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">另一方面，UTF-8是当今大多数环境(浏览器、操作系统、语言等)使用的最成熟的Unicode标准。字符有<strong class="ih hj">可变长度</strong>，所以它们可能是一个字节、两个字节或更多。高位(那128个字符)用于确定<strong class="ih hj">字符中还有多少字节</strong>。这些更多的字节允许编码任何多种unicode字符。这使得查找第N个字符变得更加困难——您需要解释字节来查找它。</p><h1 id="de57" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建外部表</h1><p id="fa57" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">BigQuery脚本从固定宽度文件的映射开始。这使用了<a class="ae lj" href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv" rel="noopener ugc nofollow" target="_blank"> CSV外部表</a>格式，并利用了几乎所有固定宽度文件都有他们从不使用的字符这一事实——这将是我们的CSV分隔符。</p><p id="0dbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有行都有一个字符串作为行。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="6376" class="kv jt hi lp b fi lt lu l lv lw">CREATE OR REPLACE EXTERNAL TABLE temp.utf8_files (row STRING)<br/>OPTIONS (<br/>  -- Standard options<br/>  allow_jagged_rows = false,<br/>  allow_quoted_newlines = false,<br/>  format = CSV,<br/>  max_bad_records = 0,<br/>  ignore_unknown_values = false,<br/>  -- UTF8 or ISO-8859-1<br/>  -- ISO-8859-1 interprets the high-bits as single-byte,<br/>  -- while UTF-8 allows for multi-byte characters<br/>  encoding = UTF8,<br/>  -- Ensure this is never used in the fixed-width file.<br/>  -- This can be an ISO-8859-1 character.<br/>  field_delimiter = '*',<br/>  -- Skip any headers (sometimes necessary)<br/>  skip_leading_rows = 1,<br/>  -- Source of files in GSC<br/>  -- TEST refers to the feed type<br/>  uris = [<br/>    'gs://&lt;bucket&gt;/fixed-width/utf8/TEST/*'<br/>  ]<br/>);</span></pre><h1 id="57db" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建配置表</h1><p id="a431" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">因为您可能有许多不同的提要，所以在配置表中将其外部化会很有用。这个表可以是GCS中的一个外部表，或者在这种情况下，它只是用SQL来表示，以帮助测试。</p><p id="bd21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">配置字段-</p><ul class=""><li id="9bc9" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">进给_类型。</strong>这是配置名称(如何解释文件)。</li><li id="9fdb" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">记录开始，记录长度。</strong>记录类型的起始位置和长度</li><li id="3831" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">直肠型。</strong>这是匹配的记录类型。如果等于这个值，则配置的其余部分适用</li><li id="aeec" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">关键_开始，关键_长度。</strong>比较键的起始位置和长度。该键必须是唯一的，即主键。</li><li id="d61d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">行_开始，行_长度。</strong>要比较的行的起始位置和长度</li></ul><h2 id="87ee" class="kv jt hi bd ju kw kx ky jy kz la lb kc iq lc ld kg iu le lf kk iy lg lh ko li bi translated">配置SQL</h2><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="93e9" class="kv jt hi lp b fi lt lu l lv lw">CREATE OR REPLACE TABLE temp.config_data AS (<br/>  SELECT * FROM UNNEST([<br/>    STRUCT(<br/>        'TEST' AS feed_type,<br/>        1 AS rectype_start, 3 AS rectype_length,<br/>        'R00' AS rectype,<br/>        72 AS key_start, 50 AS key_length,<br/>        1 AS row_start, 1000 AS row_length),<br/>     STRUCT(<br/>        'TEST' AS feed_type,<br/>        1 AS rectype_start, 3 AS rectype_length,<br/>        'R01' AS rectype,<br/>        72 AS key_start, 50 AS key_length,<br/>        1 AS row_start, 1000 AS row_length),<br/>    STRUCT(<br/>        'TEST' AS feed_type,<br/>        1 AS rectype_start, 3 AS rectype_length,<br/>        'R02' AS rectype,<br/>        72 AS key_start, 50 AS key_length,<br/>        1 AS row_start, 1000 AS row_length),<br/>  ])<br/>);</span></pre><h1 id="6c77" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建固定宽度文件的视图</h1><p id="51c6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">既然BigQuery中提供了固定宽度的文件，那么以通用的方式向消费者提供数据将使将来的比较更加容易。</p><p id="d3ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，配置提要名称是从GCS目录名称中推断出来的。这允许您添加新的配置，只需将数据复制到正确的目录中，视图就可以工作了。</p><p id="9e8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该视图将返回以下字段。在应用了配置信息后，所有字段都是<em class="jr">。</em></p><ul class=""><li id="6afd" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">fname。行的文件名(在目录之后)。</li><li id="cb8c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">饲料_类型。</strong>饲料的种类。</li><li id="f223" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">直肠型。</strong>记录类型。</li><li id="0d50" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">键。</strong>唯一的比较键。</li><li id="1f62" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">排。</strong>比较值。</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1f63" class="kv jt hi lp b fi lt lu l lv lw">CREATE OR REPLACE VIEW temp.external_files AS<br/>WITH<br/>  SourceData AS (<br/>    SELECT<br/>      REGEXP_EXTRACT(_FILE_NAME,<br/>        'gs://&lt;bucket&gt;/fixed-width/utf8/[^/]+/(.*)') AS fname,<br/>      REGEXP_EXTRACT(_FILE_NAME,<br/>        'gs://&lt;bucket&gt;/fixed-width/utf8/([^/]+)') AS feed_type,<br/>      row<br/>    FROM<br/>      temp.utf8_files<br/>  )<br/>SELECT<br/>  fname,<br/>  s.feed_type,<br/>  SUBSTRING(row, c.rectype_start, c.rectype_length) AS rectype,<br/>  SUBSTRING(row, c.key_start, c.key_length) AS key,<br/>  SUBSTRING(row, c.row_start, c.row_length) AS row<br/>FROM<br/>  SourceData s<br/>  LEFT JOIN temp.config_data c ON (<br/>    c.feed_type=s.feed_type AND<br/>    SUBSTRING(row, c.rectype_start, c.rectype_length) = c.rectype<br/>  );</span></pre><h1 id="6863" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">做一下比较——差不多！</h1><p id="e4bf" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">比较两个不同的文件应该是容易的，使用用户定义的函数，这可以变得容易。</p><h2 id="e868" class="kv jt hi bd ju kw kx ky jy kz la lb kc iq lc ld kg iu le lf kk iy lg lh ko li bi translated">要比较的SQL(文件1，文件2)</h2><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="663d" class="kv jt hi lp b fi lt lu l lv lw">SELECT<br/>  rectype,<br/>  key,<br/>  CompareSet(ARRAY_AGG(f)) AS status<br/>FROM<br/>  temp.external_files f<br/>WHERE<br/>  fname IN (<br/>    'file1',<br/>    'file2'<br/>  )<br/>GROUP BY<br/>  rectype, key<br/>HAVING<br/>  status IS NOT NULL;</span></pre><p id="5ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果就这些就好了！</p><p id="713c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，CompareSet从external_files接收结构数组或行数组。如果行之间没有差异，则返回NULL。</p><p id="0975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的注释—<em class="jr">big query只读取文件1和文件2。作为外部表，它将是高效的。乐观主义者会为你工作得很好。</em></p><h2 id="f2b3" class="kv jt hi bd ju kw kx ky jy kz la lb kc iq lc ld kg iu le lf kk iy lg lh ko li bi translated">对比显示</h2><p id="42a3" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">CompareSet将首先检查行数是否不是2(什么？)或者，如果两个，来自同一个文件(什么？).如果出现这种情况，那么它只报告文件和奇数个键。如果键不是唯一的，有两个以上的文件，或者一方或另一方缺少数据，就会发生这种情况。</p><p id="34d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果行不同，那么我们调用另一个函数— CodePointDiff —来报告字符差异(列，特定的列差异)。注意<strong class="ih hj"> TO_CODE_POINTS </strong>功能。由于BigQuery使用了<strong class="ih hj"> UTF-8 </strong>，为了遍历(数组中的)字符，它必须被转换。参见<strong class="ih hj">题外话</strong>获得解释。</p><p id="d0ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则它就是空的——一切都好！它们匹配。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="adc1" class="kv jt hi lp b fi lt lu l lv lw">CREATE TEMP FUNCTION CompareSet(s ANY TYPE) AS (<br/>  CASE<br/>    -- If there isn't two rows OR two rows are the same filename,<br/>    -- then report this as a structural issue.<br/>    WHEN ARRAY_LENGTH(s) != 2 OR<br/>         s[SAFE_OFFSET(0)].fname = s[SAFE_OFFSET(1)].fname THEN<br/>      -- Report the unique set of row counts<br/>      (<br/>        SELECT<br/>          STRING_AGG(CONCAT(fname, ' has ', count, ' row(s)'), ', ')<br/>        FROM (<br/>          SELECT<br/>            fname,<br/>            COUNT(*) AS count<br/>          FROM<br/>            UNNEST(s)<br/>          GROUP BY<br/>            fname<br/>        )<br/>      )<br/> <br/>    -- Row content are different. Return where the difference is.<br/>    WHEN s[SAFE_OFFSET(0)].row != s[SAFE_OFFSET(1)].row THEN<br/>      CodePointDiff(<br/>        s[SAFE_OFFSET(0)].fname,<br/>        TO_CODE_POINTS(s[SAFE_OFFSET(0)].row),<br/>        s[SAFE_OFFSET(1)].fname,<br/>        TO_CODE_POINTS(s[SAFE_OFFSET(1)].row))</span><span id="ec82" class="kv jt hi lp b fi lx lu l lv lw">    -- Two items in the array, different filenames, same row.<br/>    -- No difference! All good.<br/>    ELSE<br/>       NULL<br/>  END<br/>);</span></pre><h2 id="528e" class="kv jt hi bd ju kw kx ky jy kz la lb kc iq lc ld kg iu le lf kk iy lg lh ko li bi translated">CodePointDiff显示</h2><p id="e4e8" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">这将报告<strong class="ih hj">字符</strong>的位置。对于较低的7位字符(通常出现在固定宽度的文件中)，这将对应于字节数。对于多字节UTF-8字符，它不会。</p><p id="647b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数将首先检查数组长度，然后找到行中第一个不同的字符，并将其与字符一起报告。</p><p id="454c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jr">注意，使用SAFE_OFFSET()可能很重要，因为有时BigQuery会执行SQL，即使它不需要执行。</em></p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="4d12" class="kv jt hi lp b fi lt lu l lv lw">-- Compare an array of codepoints for two strings. This is valid<br/>-- only where the source STRINGs are different.<br/>CREATE TEMP FUNCTION CodePointDiff(<br/>    lname STRING, l ARRAY&lt;INT64&gt;,<br/>    rname STRING, r ARRAY&lt;INT64&gt;) AS (<br/>  IF(<br/>    ARRAY_LENGTH(l) != ARRAY_LENGTH(r),<br/>    CONCAT("Length of ", lname, " is ", ARRAY_LENGTH(l),<br/>           ", ", rname, " ", ARRAY_LENGTH(r)),<br/>    (SELECT<br/>       CONCAT("Char ", idx+1,<br/>         " is different ",<br/>         lname,<br/>         "='",<br/>         CODE_POINTS_TO_STRING([ch]),<br/>         "' vs ",<br/>         rname,<br/>         "='",<br/>         CODE_POINTS_TO_STRING([ r[SAFE_OFFSET(idx)]]),<br/>         "'"<br/>       )<br/>     FROM<br/>       UNNEST(l) AS ch<br/>       WITH OFFSET idx<br/>     WHERE<br/>       ch != r[SAFE_OFFSET(idx)]<br/>     LIMIT 1<br/>    )<br/>  ));</span></pre><h1 id="f27d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="036b" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">这是一个比较固定宽度文件的BigQuery世界之旅，但希望对演示一些有趣的BigQuery技术有用！</p></div></div>    
</body>
</html>