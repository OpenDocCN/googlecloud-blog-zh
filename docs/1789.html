<html>
<head>
<title>Centrally Managing Artifact Registry Container Image Vulnerabilities on Google Cloud: Part One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google Cloud上集中管理工件注册表容器映像漏洞:第一部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/centrally-managing-artifact-registry-container-image-vulnerabilities-on-google-cloud-part-one-d86fb4791601?source=collection_archive---------1-----------------------#2021-02-04">https://medium.com/google-cloud/centrally-managing-artifact-registry-container-image-vulnerabilities-on-google-cloud-part-one-d86fb4791601?source=collection_archive---------1-----------------------#2021-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工件注册及其前身容器注册都提供了图像扫描来检测图像中的漏洞。这些扫描的结果与相关联的容器图像一起存储在项目级别。因此，任何负责管理组织中漏洞的安全工程师都需要访问每个项目。这可能与组织关于职责分离和最低特权的安全策略相冲突。</p><p id="a44a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多企业组织都有一个集中的解决方案，如安全指挥中心或他们自己的内部SIEM，用于集中管理他们所有的威胁、漏洞和安全事件。理想情况下，我们可以将所有映像漏洞集中到一个位置进行集中管理。</p><p id="7650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇两部分文章的第一部分中，我们将研究如何利用发布/订阅和云函数在一个集中的服务或位置存储项目级容器映像漏洞。出于演示目的，我们将使用一个Google云存储桶。在第二部分中，我们将对此进行扩展，了解如何使用自定义安全命令中心资源直接在SCC中创建和管理漏洞发现，并探索其他可能性，如大查询或第三方SIEM。</p><h1 id="b3d8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">入门指南</h1><p id="3aa3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">首先，这篇文章是为<a class="ae kg" href="https://cloud.google.com/resource-manager/docs/quickstart-organizations" rel="noopener ugc nofollow" target="_blank">谷歌云组织</a>而不是个人GCP账户设计的。不同之处在于，组织帐户在根处有一个组织节点，所有文件夹和项目都存在于该节点下。一个组织与一个域相关(例如my-company.com)。对于个人云账户，项目独立存在，不在上级组织下。</p><p id="7baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以按照免费版Google Cloud Identity的<a class="ae kg" href="https://cloud.google.com/identity/docs/setup" rel="noopener ugc nofollow" target="_blank">设置说明</a>使用您拥有的任何域名创建一个免费的组织帐户。</p><p id="eb6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章还假设你有基本的Google云平台知识，并且熟悉创建项目和使用云Shell和命令行工具。</p><h1 id="5d27" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">创建项目和GCS存储桶</h1><p id="e908" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将创建两个项目，一个共享项目将保存用于存储所有漏洞的GCS存储桶，另一个源项目将包含用于扫描漏洞的图像。实际上，您会有多个源项目，它们都将写入共享项目，如下图所示。此外，您通常不会在生产中使用GCS作为存储机制，但是对于本演示来说，它适合我们的目的。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/5201d68bb2dbecf094cbe3688ccc32f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-_8EZvdHRG5IadsyG6NmQ.jpeg"/></div></div></figure><p id="6a11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开<a class="ae kg" href="https://console.cloud.google.com" rel="noopener ugc nofollow" target="_blank">云控制台</a>，创建两个项目并为其设置账单，记下您为每个项目使用的id。我们将共享项目id称为<em class="kt"> &lt;项目id-共享&gt; </em>，源项目称为<em class="kt"> &lt;项目id-源&gt; </em>。接下来，我们在共享项目中创建GCS存储桶，我们将在其中存储漏洞。打开Cloud Shell并运行下面的命令，用您的项目id替换<em class="kt">&lt;project-id-shared&gt;</em>，并为<em class="kt"> &lt; bucket-name &gt; </em>选择一个全局唯一的值。</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="e549" class="kz je hi kv b fi la lb l lc ld">gsutil mb -l us-central1 -p <em class="kt">&lt;project-id-shared&gt;</em> gs://<em class="kt">&lt;bucket-name&gt;</em></span></pre><h1 id="b063" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">设置源项目、服务帐户、工件注册和发布/订阅</h1><p id="0a8c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">源项目是存储和扫描图像的地方。我们将利用漏洞扫描器自动创建的发布/订阅主题，然后触发云函数读取漏洞并将其写入共享项目的桶中。</p><p id="0672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Cloud Shell中，使用您的<em class="kt">&lt;project-id-source&gt;</em>值运行以下命令，以在源项目上启用所需的服务。</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="b00c" class="kz je hi kv b fi la lb l lc ld">gcloud config set project <em class="kt">&lt;project-id-source&gt;</em></span><span id="004d" class="kz je hi kv b fi le lb l lc ld">gcloud services enable cloudresourcemanager.googleapis.com</span><span id="b0e7" class="kz je hi kv b fi le lb l lc ld">gcloud services enable artifactregistry.googleapis.com</span><span id="6afc" class="kz je hi kv b fi le lb l lc ld">gcloud services enable cloudbuild.googleapis.com</span><span id="fb14" class="kz je hi kv b fi le lb l lc ld">gcloud services enable containerscanning.googleapis.com</span></pre><p id="6fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建运行云功能的服务帐户。它需要读取源项目中容器漏洞的权限和写入共享项目中存储桶的权限。为<em class="kt"> &lt;服务-账户-来源&gt; </em>提供自己的服务账户值。</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="a5f2" class="kz je hi kv b fi la lb l lc ld">gcloud iam service-accounts create <em class="kt">&lt;service-account-source&gt;</em> \<br/>--description="Service Account to create process image scan vulnerabilities" \<br/>--display-name="Image Vulnerability Processor"</span></pre><p id="b372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们添加了使用容器分析事件查看者角色读取漏洞的权限。请注意需要替换<em class="kt"> &lt;服务-帐户-来源&gt; </em>和<em class="kt"> &lt;项目-id-来源&gt; </em>值的电子邮件格式。我们还将在bucket上设置GCS对象创建者角色，这样我们就可以写入bucket。为了遵守最小特权原则，服务帐户不需要读取或删除对象，因此我们将权限限制为仅创建。</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="48df" class="kz je hi kv b fi la lb l lc ld">gcloud projects add-iam-policy-binding <em class="kt">&lt;project-id-source&gt;</em> --member=serviceAccount:<em class="kt">&lt;service-account-source&gt;</em>@<em class="kt">&lt;project-id-source&gt;</em>.iam.gserviceaccount.com --role=roles/containeranalysis.occurrences.viewer</span><span id="0368" class="kz je hi kv b fi le lb l lc ld">gsutil iam ch serviceAccount:<em class="kt">&lt;service-account-source&gt;</em>@<em class="kt">&lt;project-id-source&gt;</em>.iam.gserviceaccount.com:objectCreator gs://<em class="kt">&lt;bucket-name&gt;</em></span></pre><p id="46fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们在源项目中创建一个工件注册表，它将存储容器图像。为<em class="kt"> &lt; repo-name &gt; </em>提供自己的值。</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="ca41" class="kz je hi kv b fi la lb l lc ld">gcloud artifacts repositories create <em class="kt">&lt;repo-name&gt;</em> --location=us-central1 --repository-format=docker --project=<em class="kt">&lt;project-id-source&gt;</em></span></pre><p id="3bf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当Docker图像被推送到存储库时，它们将被我们之前启用的容器扫描API自动扫描。除了在控制台中显示发现的漏洞，容器扫描API还将每个漏洞发布到自动创建的发布/订阅主题。</p><p id="76fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些主题是在扫描第一张图像时创建的，这给我们带来了一个问题。要从一个主题触发云函数，该主题必须首先存在。在这种情况下，我们无法将云功能附加到主题上，直到我们推送第一张图片并对其进行扫描。幸运的是，解决方法很简单。我们可以自己预先创建主题，使我们能够创建和附加云功能。扫描图像时，它会检测到该主题已经存在，不会尝试重新创建它。</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="3e09" class="kz je hi kv b fi la lb l lc ld">gcloud pubsub topics create container-analysis-occurrences-v1 --project=<em class="kt">&lt;project-id-source&gt;</em></span></pre><h1 id="9527" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">创建云函数</h1><p id="a69a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们现在将创建由container-analysis-occurrences-v1主题触发的云函数，并将漏洞写入共享项目中的存储桶。虽然这可以使用命令行来完成，但是使用控制台要容易得多。</p><p id="07e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在控制台中，确保您在源项目中，并导航到发布/订阅。点击“容器-分析-出现次数-v1”，然后点击屏幕顶部的“+触发云函数”。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lf"><img src="../Images/a713fca4979e69ef9e027cd1f013b9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GFwSJEO2QcySSj_8LwMwQ.png"/></div></div></figure><p id="c038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将函数名称更改为“image-vuln-cf-trigger ”,其他内容保持默认，然后单击Save。</p><p id="3d2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">展开变量、网络和高级设置部分。对于服务帐户，选择我们之前创建的服务帐户，然后选择“环境变量”选项卡并添加一个名为“BUCKET_NAME”的运行时环境变量。该值应该是您之前创建的<em class="kt">&lt;&gt;</em>。</p><p id="1613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单击next并选择Python 3.7作为代码运行时。粘贴以下代码:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="f3fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将入口点设置为“image_vuln_pubsub_handler”。</p><p id="afc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，选择requirements.txt文件并粘贴如下内容:</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="cd54" class="kz je hi kv b fi la lb l lc ld">google-cloud-securitycenter</span><span id="97e4" class="kz je hi kv b fi le lb l lc ld">google-cloud-containeranalysis</span></pre><p id="4d31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单击部署。</p><h1 id="a000" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">将图像推送到工件注册表并触发扫描</h1><p id="1281" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们现在准备测试。我们将创建一个带有一些已知漏洞的简单Docker映像，并将它推送到我们的源项目中的工件注册表中。这将触发漏洞扫描，任何发现的漏洞将被写入发布/订阅主题，触发我们的云功能，并将被写入我们共享项目中的存储桶。</p><p id="9e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Cloud Shell中，打开代码编辑器，使用以下代码创建一个名为DOCKERFILE的文件:</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="e985" class="kz je hi kv b fi la lb l lc ld">FROM nginx</span></pre><p id="6e8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在命令行上运行:</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="57b9" class="kz je hi kv b fi la lb l lc ld">gcloud auth configure-docker us-central1-docker.pkg.dev</span><span id="1df9" class="kz je hi kv b fi le lb l lc ld">docker build --tag nginx .</span><span id="a926" class="kz je hi kv b fi le lb l lc ld">docker tag nginx us-central1-docker.pkg.dev/<em class="kt">&lt;project-id-source&gt;</em>/<em class="kt">&lt;repo-name&gt;</em>/nginx-test:staging</span><span id="1326" class="kz je hi kv b fi le lb l lc ld">docker push us-central1-docker.pkg.dev/<em class="kt">&lt;project-id-source&gt;</em>/<em class="kt">&lt;repo-name&gt;</em>/nginx-test:staging</span></pre><p id="e6a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以转到控制台，在源项目的工件注册表中查看推送的图像。单击映像名称，注意发现的漏洞(扫描可能正在进行)。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es li"><img src="../Images/068c6dd29d60ef7d42251f6b03b487ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05V7-_WGiTyUQ-rzm8A_Iw.png"/></div></div></figure><p id="0ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以点击并检查发现的每个漏洞。</p><p id="24ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，切换到共享项目，并转到storage来浏览您的bucket。在里面，您将看到一个包含所有漏洞事件的项目文件夹结构。</p><p id="e425" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，您会对每个使用容器扫描API的项目重复此操作，以将所有映像漏洞聚集到一个中心位置。</p><p id="5010" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文的第二部分中，我们将了解如何使用定制的SCC源将映像漏洞发现发布到Security Command Center，并讨论如何与您自己的SIEM集成。</p></div></div>    
</body>
</html>