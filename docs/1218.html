<html>
<head>
<title>Using system packages and custom binaries in Google Cloud Functions.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google Cloud函数中使用系统包和自定义二进制文件。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-system-packages-and-custom-binaries-in-google-cloud-functions-f2df7be926a3?source=collection_archive---------0-----------------------#2019-12-06">https://medium.com/google-cloud/using-system-packages-and-custom-binaries-in-google-cloud-functions-f2df7be926a3?source=collection_archive---------0-----------------------#2019-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7bc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud Functions是一个基于Google Cloud Platform的无服务器计算平台。它的主要原则是:“用NodeJS、Python或者Go写代码，部署好了就不用管其他的了”。这个流程非常适合小代码，一个响应HTTP请求或来自PubSub、云存储、Firestore等的各种事件的简单函数。虽然没有限制使用包管理器(npm，pip)为相关的编程语言安装任何第三方库，但有时即使这样也不够。</p><p id="4fd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">云函数建立在Ubuntu 18.04镜像之上，提供了一些有用的系统包，这是一个不常被提及的特性，也是我想在本文中重点讨论的主题。我个人在为一个客户做项目时遇到了这个问题，这个客户想要从Adobe文件格式进行转换，并要求使用云功能。</p><p id="342c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我提到的，云函数运行时已经预装了系统包<a class="ae jd" href="https://cloud.google.com/functions/docs/reference/python-system-packages" rel="noopener ugc nofollow" target="_blank">https://Cloud . Google . com/Functions/docs/reference/python-system-packages</a>。因为云函数运行时是基于Ubuntu 18.04镜像的，这就像让你的函数放在Ubuntu沙盒下面一样。</p><p id="1531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我设置了GitHub repo和一些用Python 3.7写的云函数作为例子<a class="ae jd" href="https://github.com/zdenulo/google-cloud-functions-system-packages" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/zde nulo/Google-Cloud-Functions-system-packages</a>。</p><h1 id="37c4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">探索运行时</h1><p id="97e2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了在Python程序中执行系统命令，我使用了<strong class="ih hj">子流程</strong>模块。一个通用的用例如下:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e7cc" class="kq jf hi km b fi kr ks l kt ku">import subprocess<br/><br/>cmd = "ls -ltr /".split(' ')<br/>p = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE)<br/>stdout, stderr = p.communicate()<br/>if stderr:<br/>    print(f"there was error {stderr}")<br/>if stdout:<br/>    print(f"result: {stdout}")</span></pre><p id="e17e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要执行的命令在变量<strong class="ih hj"> cmd </strong>中定义，然后在<strong class="ih hj"> stdout </strong>中输出常规输出，如果<strong class="ih hj"> stderr </strong>变量中有错误。</p><p id="7f17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用云函数<a class="ae jd" href="https://github.com/zdenulo/google-cloud-functions-system-packages/tree/master/cf_system" rel="noopener ugc nofollow" target="_blank"> cf_system </a>，我正在执行几个命令来找出什么是环境变量以及PATH变量中的可执行文件。例如，这些是环境变量:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ef4c" class="kq jf hi km b fi kr ks l kt ku">{'CODE_LOCATION': '/user_code',<br/> 'DEBIAN_FRONTEND': 'noninteractive',<br/> 'ENTRY_POINT': 'main',<br/> 'FUNCTION_IDENTITY': 'gcp@appspot.gserviceaccount.com',<br/> 'FUNCTION_MEMORY_MB': '256',<br/> 'FUNCTION_NAME': 'system',<br/> 'FUNCTION_REGION': 'us-central1',<br/> 'FUNCTION_TIMEOUT_SEC': '60',<br/> 'FUNCTION_TRIGGER_TYPE': 'HTTP_TRIGGER',<br/> 'GCLOUD_PROJECT': 'gcp',<br/> 'GCP_PROJECT': 'gcp',<br/> 'HOME': '/tmp',<br/> 'LC_CTYPE': 'C.UTF-8',<br/> 'NODE_ENV': 'production',<br/> 'PATH': '/env/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin',<br/> 'PORT': '8080',<br/> 'PWD': '/user_code',<br/> 'SUPERVISOR_HOSTNAME': '169.254.8.129',<br/> 'SUPERVISOR_INTERNAL_PORT': '8081',<br/> 'VIRTUAL_ENV': '/env',<br/> 'WORKER_PORT': '8091',<br/> 'X_GOOGLE_CODE_LOCATION': '/user_code',<br/> 'X_GOOGLE_CONTAINER_LOGGING_ENABLED': 'false',<br/> 'X_GOOGLE_ENTRY_POINT': 'main',<br/> 'X_GOOGLE_FUNCTION_IDENTITY': 'gcp@appspot.gserviceaccount.com',<br/> 'X_GOOGLE_FUNCTION_MEMORY_MB': '256',<br/> 'X_GOOGLE_FUNCTION_NAME': 'system',<br/> 'X_GOOGLE_FUNCTION_REGION': 'us-central1',<br/> 'X_GOOGLE_FUNCTION_TIMEOUT_SEC': '60',<br/> 'X_GOOGLE_FUNCTION_TRIGGER_TYPE': 'HTTP_TRIGGER',<br/> 'X_GOOGLE_FUNCTION_VERSION': '2',<br/> 'X_GOOGLE_GCLOUD_PROJECT': 'gcp',<br/> 'X_GOOGLE_GCP_PROJECT': 'gcp',<br/> 'X_GOOGLE_LOAD_ON_START': 'false',<br/> 'X_GOOGLE_SUPERVISOR_HOSTNAME': '169.254.8.129',<br/> 'X_GOOGLE_SUPERVISOR_INTERNAL_PORT': '8081',<br/> 'X_GOOGLE_WORKER_PORT': '8091'}</span></pre><p id="63c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是可执行文件列表的一部分:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0130" class="kq jf hi km b fi kr ks l kt ku">-rwxr-xr-x 1 root root    142608 Apr 24  2019 ffserver<br/>-rwxr-xr-x 1 root root    161944 Apr 24  2019 ffprobe<br/>-rwxr-xr-x 1 root root    137376 Apr 24  2019 ffplay<br/>-rwxr-xr-x 1 root root    272528 Apr 24  2019 ffmpeg<br/>-rwxr-xr-x 1 root root     43168 May  7  2019 apt-mark<br/>-rwxr-xr-x 1 root root     27391 May  7  2019 apt-key<br/>-rwxr-xr-x 1 root root     43168 May  7  2019 apt-get<br/>-rwxr-xr-x 1 root root     22616 May  7  2019 apt-config<br/>-rwxr-xr-x 1 root root     22688 May  7  2019 apt-cdrom<br/>-rwxr-xr-x 1 root root     80032 May  7  2019 apt-cache<br/>-rwxr-xr-x 1 root root     14424 May  7  2019 apt<br/>lrwxrwxrwx 1 root root         0 May  7  2019 ps2txt -&gt; ps2ascii<br/>-rwxr-xr-x 1 root root       669 May  7  2019 ps2ps2<br/>-rwxr-xr-x 1 root root       647 May  7  2019 ps2ps<br/>-rwxr-xr-x 1 root root      1097 May  7  2019 ps2pdfwr<br/>-rwxr-xr-x 1 root root      2752 May  7  2019 ps2epsi<br/>-rwxr-xr-x 1 root root       631 May  7  2019 ps2ascii<br/>-rwxr-xr-x 1 root root       395 May  7  2019 printafm<br/>-rwxr-xr-x 1 root root       404 May  7  2019 pphs<br/>-rwxr-xr-x 1 root root       516 May  7  2019 pfbtopfa<br/>-rwxr-xr-x 1 root root       498 May  7  2019 pf2afm<br/>-rwxr-xr-x 1 root root       909 May  7  2019 pdf2ps<br/>-rwxr-xr-x 1 root root       698 May  7  2019 pdf2dsc<br/>-rwxr-xr-x 1 root root       277 May  7  2019 gsnd<br/>-rwxr-xr-x 1 root root       350 May  7  2019 gslp</span></pre><p id="f9fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你从列表中看到的(不完整)，有各种各样的程序，如ffmpeg(视频/音频转换)或各种ps2* (postscript转换)，awk，sed，grep等等。在下一节中，我们将看到一些使用这些程序的实际例子。</p><p id="053f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在研究云函数系统和执行命令期间实现的最后一个案例是执行任意命令(管道不工作)。当我在我的云函数命令<strong class="ih hj">apt list-installed</strong>中为<strong class="ih hj">选项</strong>参数设置时，我会得到一个已安装包的列表。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a379" class="kq jf hi km b fi kr ks l kt ku">Listing...<br/>adduser/bionic,now 3.116ubuntu1 all [installed]<br/>adwaita-icon-theme/bionic,now 3.28.0-1ubuntu1 all [installed,automatic]<br/>apt/bionic-updates,now 1.6.11 amd64 [installed]<br/>aspell/bionic,now 0.60.7~20110707-4 amd64 [installed,automatic]<br/>aspell-en/bionic,now 2017.08.24-0-0.1 all [installed,automatic]<br/>at-spi2-core/bionic,now 2.28.0-1 amd64 [installed,automatic]<br/>base-files/bionic-updates,now 10.1ubuntu2.4 amd64 [installed]<br/>base-passwd/bionic,now 3.5.44 amd64 [installed]<br/>bash/bionic-updates,now 4.4.18-2ubuntu1.1 amd64 [installed]<br/>bsdutils/bionic-updates,now 1:2.31.1-0.4ubuntu3.3 amd64 [installed]<br/>bzip2/bionic,now 1.0.6-8.1 amd64 [installed]<br/>ca-certificates/bionic,bionic-updates,now 20180409 all [installed]<br/>coreutils/bionic,now 8.28-1ubuntu1 amd64 [installed]<br/>cpp/bionic-updates,now 4:7.4.0-1ubuntu2.2 amd64 [installed,automatic]<br/>cpp-7/bionic-updates,now 7.4.0-1ubuntu1~18.04 amd64 [installed,automatic]<br/>curl/bionic-updates,bionic-security,now 7.58.0-2ubuntu3.7 amd64 [installed</span></pre><p id="edf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能还有其他的东西需要寻找和发现，但是让我们来看一些实际的用例。</p><h1 id="f464" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">PDF文档到图像的转换。</h1><p id="1fee" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">该示例实现了以下过程:当PDF文件被上传到云存储桶时，它触发云函数，该云函数将PDF文档转换为PNG图像(一页到一幅图像),并将它们存储到输出存储桶，然后可以对其进行进一步处理，例如进行OCR。这是一个很好的图表，代表了整个过程。</p><figure class="kh ki kj kk fd kw er es paragraph-image"><div class="er es kv"><img src="../Images/ddfd67e68bd5d7476ca0315080191b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*0aHSs610GgsvaGfM.png"/></div></figure><p id="3f6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想用纯Python来做这件事，那是不可能的。幸运的是<a class="ae jd" href="https://www.ghostscript.com/" rel="noopener ugc nofollow" target="_blank"> Ghostscript </a>程序拯救了这一天。当然，它是预装在云函数中的，要将PDF转换为PNG(或其他图像格式),需要使用以下命令:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c904" class="kq jf hi km b fi kr ks l kt ku">gs -dSAFER -dNOPAUSE -dBATCH -sDEVICE=png16m -r600 -sOutputFile="output-%d.png" input.pdf'</span></pre><p id="821e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">全云功能代码:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4c00" class="kq jf hi km b fi kr ks l kt ku">def main(data, context=None):<br/>    gcs = storage.Client(project=os.environ['GCP_PROJECT'])<br/>    bucket_name = data['bucket']<br/>    file_name = data['name']<br/>    if file_name[-4:] != '.pdf':<br/>        logging.error("input file is not pdf")<br/>        return<br/>    input_filepath = os.path.join(TMP_FOLDER, file_name)<br/>    bucket = gcs.bucket(bucket_name)<br/>    blob = bucket.blob(file_name)<br/>    blob.download_to_filename(input_filepath)<br/><br/>    output_filename = file_name.rsplit('.', 1)[0]<br/>    output_filename += '-%d'<br/>    output_filename += '.png'<br/>    output_filepath = os.path.join(TMP_FOLDER, output_filename)<br/><br/>    cmd = f'gs -dSAFER -dNOPAUSE -dBATCH -sDEVICE=png16m -r600 -sOutputFile="{output_filepath}" {input_filepath}'.split(<br/>        ' ')<br/>    p = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE)<br/><br/>    stdout, stderr = p.communicate()<br/>    error = stderr.decode('utf8')<br/>    if error:<br/>        logging.error(error)<br/>        return<br/><br/>    for filename in os.listdir(TMP_FOLDER):<br/>        if filename[-4:] == '.png':<br/>            full_path = os.path.join(TMP_FOLDER, filename)<br/>            output_bucket = gcs.bucket(OUTPUT_BUCKET)<br/>            output_blob = output_bucket.blob(filename)<br/>            output_blob.upload_from_filename(full_path)<br/>            logging.info(f'uploaded file: {filename}')<br/>            os.remove(full_path)<br/><br/>    if os.path.exists(input_filepath):<br/>        os.remove(input_filepath)<br/>    return</span></pre><p id="daa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于云函数是由云存储中的事件触发的，在传入的数据中，提供了桶和文件的名称，因此在此基础上，从云存储中下载文件，然后通过调用<strong class="ih hj"> gs </strong>命令执行转换，并将结果保存到/tmp文件夹。将输出文件上传到输出存储桶后，将删除/tmp文件夹中的文件以及输入文件，以清理所有内容。由于云函数最多支持一个并发请求，因此在处理过程中不会出现来自不同请求的文件混合在同一个实例中的情况，但是同一个实例可以处理下一个请求，这意味着不会创建实例，而是使用现有的实例，这就是为什么会从/tmp文件夹中删除输入和输出文件。</p><p id="b776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是云功能用例的一个很好的例子:一个简单明了的例子，几行代码做一件事(实际上是3件事:下载、转换、上传)。</p><h1 id="c071" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在云函数中执行自定义程序</h1><p id="400a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在前面的例子中，我们在云函数环境中使用了预装的Ghostscript程序。但是当然，当我们想使用我们自己编译的程序时，总会有一些边缘情况，这些程序在系统中或者在我们正在使用的语言中是不可用的。对于这个例子，我们将使用文本到ASCII转换器，即在GET HTTP请求中，有一个文本参数，其中应该定义输入文本，因此，将返回ASCII测试。我知道这有一个Python库，但是为了举例，我将使用一个名为<a class="ae jd" href="http://www.figlet.org/" rel="noopener ugc nofollow" target="_blank"> figlet </a>的程序。这个例子的完整代码在这里<a class="ae jd" href="https://github.com/zdenulo/google-cloud-functions-system-packages/tree/master/cf_ascii" rel="noopener ugc nofollow" target="_blank">https://github . com/zde nulo/Google-cloud-functions-system-packages/tree/master/cf _ ascii</a>。Figlet是用C编写的程序，所以为了使用它，我需要编译它以获得二进制可执行文件。该过程如下:</p><p id="4969" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">源代码可以从本地计算机上的FTP://FTP . fig let . org/pub/fig let/program/UNIX/fig let-2 . 2 . 5 . tar . gz下载。</p><p id="2fd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后解包并编译(在Linux操作系统上):</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="fbe9" class="kq jf hi km b fi kr ks l kt ku">tar -zxvf figlet-2.2.5.tar.gz <br/>cd figlet-2.2.5/<br/>make</span></pre><p id="b644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切顺利，这将创建可执行的<strong class="ih hj"> figlet </strong>。在云函数中执行此文件时，可能会出现权限问题，尤其是在Windows上编译代码时，因此以防万一，请执行以下命令:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="450d" class="kq jf hi km b fi kr ks l kt ku">chmod a+x figlet</span></pre><p id="7097" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要执行的一个常见命令是:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="36d4" class="kq jf hi km b fi kr ks l kt ku">./figlet -d fonts hello</span></pre><p id="14cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">产生输出</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7ae0" class="kq jf hi km b fi kr ks l kt ku">_          _ _       <br/>| |__   ___| | | ___  <br/>| '_ \ / _ \ | |/ _ \ <br/>| | | |  __/ | | (_) |<br/>|_| |_|\___|_|_|\___/</span></pre><p id="1a6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在云函数中使用，需要将<strong class="ih hj"> figlet </strong>可执行文件以及<strong class="ih hj"> fonts </strong>文件夹复制到云函数文件夹中，并与云函数代码一起上传。代码本身基本上是一个执行figlet并返回输出的包装器。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8749" class="kq jf hi km b fi kr ks l kt ku">def main(request):<br/>    text = request.args.get('text', '')<br/>    if not text:<br/>        return 'missing text parameter', 404<br/>    logging.info(f'received url: {text}')<br/><br/>    cmd = f"./figlet -d fonts {text}".split(' ')<br/>    p = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE)<br/>    stdout, stderr = p.communicate()<br/>    error = stderr.decode('utf8')<br/>    if error:<br/>        return error, 403<br/>    out = stdout.decode('utf8')<br/>    response = make_response(out)<br/>    response.headers["content-type"] = "text/plain"<br/>    return response</span></pre><p id="4c1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以使用Cloud Run，但是因为我们是一次性编译，需要用几行代码来包装所有东西，所以Cloud Function也可以。因此，在本例中，使用C程序的源代码，在本地计算机上编译它，并上传二进制代码以及云函数代码及其使用位置。这样，我们就有了一个简单的API来读取输入文本并转换成ASCII文本。</p><p id="fd72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我展示了除了云函数运行时提供的程序之外，使用各种程序的可能性。我猜在90%的云功能中，你不需要这个，但对于那10%，它可能是有用的。</p><p id="9896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对谷歌云感兴趣，看看GCP周刊，这是我每周一发布的关于谷歌云的每周时事通讯。</p></div></div>    
</body>
</html>