<html>
<head>
<title>Keeping Secrets in ASP.NET’s appsettings.json</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP中的保密。NET的appsettings.json</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/keeping-secrets-in-asp-nets-appsettings-json-5694e533dc87?source=collection_archive---------0-----------------------#2018-08-31">https://medium.com/google-cloud/keeping-secrets-in-asp-nets-appsettings-json-5694e533dc87?source=collection_archive---------0-----------------------#2018-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我和一位同事<a class="ae jd" href="https://github.com/jsimonweb" rel="noopener ugc nofollow" target="_blank"> Jonathan </a>维护着一个<a class="ae jd" href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1" rel="noopener ugc nofollow" target="_blank">ASP.NET核心</a>应用程序。像许多ASP.NET项目一样，我们的应用程序需要SQL连接字符串和其他凭证来连接到后端服务。这些凭证允许访问敏感数据，而我们团队中的大多数人不需要访问这些数据。因此，这些凭据应该保密，只有在生产环境中运行的应用程序才可以看到。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/fbabcc8a9fff00ec807688bd7630d878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHtv99HTRc-Xb4fD4-oOkg.png"/></div></div></figure><p id="dacf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将应用程序的秘密存储在一个<a class="ae jd" href="https://cloud.google.com/storage/" rel="noopener ugc nofollow" target="_blank">谷歌云存储</a>对象中，这个对象<a class="ae jd" href="https://cloud.google.com/security/encryption-at-rest/" rel="noopener ugc nofollow" target="_blank">加密静态对象</a>。谷歌云存储为我们提供了所需的访问控制，但它并不完全符合我们的需求，因为我们容易犯以下错误:</p><ul class=""><li id="7bdf" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">竞赛条件</strong> </a>。在以下情况下，机密可能会丢失:</li><li id="44e1" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">1.我下载了秘密文件并添加了一个秘密。</li><li id="9e4f" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">2.Jonathan还下载了秘密文件并添加了一个秘密。</li><li id="4aad" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">3.我上传了我修改过的秘密文件。</li><li id="7e92" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">4.乔纳森上传了他修改过的秘密文件。</li><li id="5cfa" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">5.我添加的秘密丢失了。因为我们打开了<a class="ae jd" href="https://cloud.google.com/storage/docs/object-versioning" rel="noopener ugc nofollow" target="_blank">云存储的对象版本</a>，一旦我们发现发生了什么，我们仍然能够从这个场景中恢复，但是需要做一些工作来注意这个问题，然后修复它。</li><li id="cfe7" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">版本不匹配。</strong>Google云存储中存储的secrets文件有自己的版本历史。Google云存储中的版本1是否对应于应用程序的版本1？如何在不影响当前运行的应用程序的情况下，为下一版本的应用程序更改密码？跟踪版本和避免陷阱需要提前计划和仔细的工程设计。</li></ul><p id="6f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面列出的问题已经有了解决方案:版本控制。<a class="ae jd" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>、<a class="ae jd" href="https://subversion.apache.org/" rel="noopener ugc nofollow" target="_blank"> subversion </a>、<a class="ae jd" href="https://www.mercurial-scm.org/" rel="noopener ugc nofollow" target="_blank"> mercurial </a>等许多版本控制系统正是为了解决这些问题而设计的。我们不想重新发明<a class="ae jd" href="https://en.wikipedia.org/wiki/Wheel" rel="noopener ugc nofollow" target="_blank">轮子</a>。我们被诱惑在版本控制中保守秘密，但是了解到<strong class="ih hj">在版本控制中保守秘密是可怕的实践</strong>。如果我们将秘密存储在版本控制中，那么我们团队中的任何人都可以很容易地看到这些秘密。如果我们把代码放在GitHub的公共仓库里，那么全世界都可以看到我们的秘密。</p><h1 id="35d3" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">钥匙库</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/9d41d047c63b01968bd86784748df03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqyqdrY0lwqxxUgoBzsEyg.jpeg"/></div></div></figure><p id="42ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Scott Hanselman和其他人描述的一个合理的解决方案是使用一个内置了自己版本控制的密钥库。具有版本控制的密钥库可以防止某些竞争情况，并使其易于从意外损坏中恢复。密钥库提供严格的访问控制，因此不需要访问机密来完成工作的人看不到它。我们上面的第一个解决方案有效地使用了Google云存储作为一个密钥库。</p><p id="7b07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，密钥库仍然有一个缺点:多个版本历史。哪个版本的app需要哪个版本的秘密？树枝呢？<strong class="ih hj">版本不匹配</strong>必然会发生，导致应用程序崩溃，用户体验受损。</p><h1 id="5cf5" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">加密</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/ada7fdfb5bdfaf671920c3a253c10942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abwWj_fm9W26M6Yr2w1ZSw.png"/></div></div></figure><p id="5e49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个好的解决方案已经被贾斯汀·艾林伍德、约翰·雷西格和其他许多人讨论过了。基本上，解决方案是在一个文件中加密秘密，并在版本控制中只存储加密的文件。该解决方案结合了版本控制解决方案的全部功能和加密提供的访问控制。秘密仍然是安全的，因为只有有权使用私钥的人才能解密它们。</p><p id="72f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种解决方案避免了密钥库中出现的版本不匹配问题，因为只有一个版本历史:保存在版本控制中的版本历史。</p><p id="c398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这种解决方案仍然有几个缺点:</p><ol class=""><li id="3a47" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc le jw jx jy bi translated">秘密不像钥匙库那样被锁住。构建生产应用程序的任何人都必须能够解密这些秘密。应用程序构建器从不调用后端服务，因此不应该访问机密。此外，构建产品，无论是二进制文件还是docker映像，都包含明文形式的机密，因此构建产品必须像机密本身一样受到保护。</li><li id="d86a" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc le jw jx jy bi translated"><strong class="ih hj">关键文件必须小心管理、轮换和分发。</strong>谁需要密钥文件？关键文件都在哪里？当一个密钥文件被认为已经泄漏时，如何颁发新的密钥？</li></ol><h1 id="6902" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">更好的解决方案</strong></h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lf"><img src="../Images/451c405fdcaa57ca444d244c46977d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*3VN1JfjaEUPvH_Gdz_tbYA.png"/></div></figure><p id="26d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" href="https://cloud.google.com/kms/" rel="noopener ugc nofollow" target="_blank">谷歌云密钥管理服务(KMS) </a>，我们构建了<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/tree/9c52ba8b0eeac88200e9a0dcb34b90869535a4b4/kms/api/CloudKmsAspNetSample" rel="noopener ugc nofollow" target="_blank">一个解决方案</a>，克服了上述两个解决方案的缺点。机密被加密并存储在版本控制中，因此只有一个版本历史。只有一个版本历史记录时不会出现版本不匹配。但是与上面的解决方案不同，构建产品从不包含明文秘密。因此，在应用程序完全部署在其生产主机上之前，秘密一直是隐藏的。甚至构建和部署应用程序的代理也没有必要的密钥来解密这些秘密。</p><p id="f0bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，即使对秘密进行加密和解密，密钥也不会被传送到开发人员的机器上。加密和解密发生在谷歌的服务器上，用户必须使用自己的个人凭据进行加密或解密。</p><p id="7f72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">KMS也有内置的自动<a class="ae jd" href="https://cloud.google.com/kms/docs/key-rotation" rel="noopener ugc nofollow" target="_blank">密钥轮换</a>，所以如果一个密钥被意外泄露，只有<a class="ae jd" href="https://crypto.stackexchange.com/questions/41796/whats-the-purpose-of-key-rotation" rel="noopener ugc nofollow" target="_blank">有限的秘密快照会被泄露</a>。</p><p id="fdc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-2.1" rel="noopener ugc nofollow" target="_blank">ASP.NET核心的配置</a>设计得很好，让我们很容易实现一个<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/kms/api/CloudKmsAspNetSample/Services/EncryptedFileProvider.cs" rel="noopener ugc nofollow" target="_blank">自定义</a> <code class="du lg lh li lj b"><a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/kms/api/CloudKmsAspNetSample/Services/EncryptedFileProvider.cs" rel="noopener ugc nofollow" target="_blank">IFileProvider</a></code>解密内存中的文件。使用<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/kms/api/CloudKmsAspNetSample/Services/EncryptedFileProvider.cs" rel="noopener ugc nofollow" target="_blank">自定义</a> <code class="du lg lh li lj b"><a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/kms/api/CloudKmsAspNetSample/Services/EncryptedFileProvider.cs" rel="noopener ugc nofollow" target="_blank">IFileProvider</a></code>，从应用程序中访问机密就像访问<code class="du lg lh li lj b">appsettings.json</code>中的普通配置变量一样简单。</p><p id="653f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">秘密被写在一个叫做<code class="du lg lh li lj b">app<strong class="ih hj">secrets</strong>.json</code>的文件中，这个文件和<code class="du lg lh li lj b">appsettings.json</code>在同一个目录下。当然，<code class="du lg lh li lj b">appsecrets.json</code>绝不能被签入版本控制，所以有一个<code class="du lg lh li lj b"><a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/9c52ba8b0eeac88200e9a0dcb34b90869535a4b4/kms/api/CloudKmsAspNetSample/.gitignore" rel="noopener ugc nofollow" target="_blank">.gitignore</a></code>文件来防止这种情况发生:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="bad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/kms/api/CloudKmsAspNetSample/Encrypt-AppSecrets.ps1" rel="noopener ugc nofollow" target="_blank"> powershell脚本</a>使用<a class="ae jd" href="http://cloud.google.com/sdk" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a>对<code class="du lg lh li lj b">appsecrets.json</code>到<code class="du lg lh li lj b">appsecrets.json.encrypted</code>进行加密:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="50fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lg lh li lj b"><a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/kms/api/CloudKmsAspNetSample/CloudKmsAspNetSample.csproj" rel="noopener ugc nofollow" target="_blank">.csproj</a></code>中的3行代码确保加密文件与二进制文件一起交付:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="3352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lg lh li lj b"><a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/kms/api/CloudKmsAspNetSample/Program.cs" rel="noopener ugc nofollow" target="_blank">Program.cs</a></code>中的一条语句加载加密的秘密:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="fa93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，秘密可以像任何其他配置变量一样在应用程序中使用:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="de75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当部署到<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes引擎</a>、<a class="ae jd" href="https://cloud.google.com/compute/" rel="noopener ugc nofollow" target="_blank"> Google Compute引擎</a>和<a class="ae jd" href="https://cloud.google.com/appengine/docs/flexible/dotnet/" rel="noopener ugc nofollow" target="_blank">Google app Engine Flexible Environment</a>时，主机已经拥有了解密机密所需的Google凭证。当部署到另一个环境时，在主机上安装一个<a class="ae jd" href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys" rel="noopener ugc nofollow" target="_blank">服务帐户密钥</a>并设置环境变量<code class="du lg lh li lj b">GOOGLE_APPLICATION_CREDENTIALS</code>，然后该主机也可以访问这些秘密。</p><h1 id="1516" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">包扎</h1><p id="b8f3" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">借助版本控制和<a class="ae jd" href="https://cloud.google.com/kms/" rel="noopener ugc nofollow" target="_blank">谷歌云密钥管理服务(KMS) </a>，我们构建了一个易于使用、易于维护、与密钥库解决方案一样安全的系统。</p><p id="249c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://github.com/GoogleCloudPlatform/dotnet-docs-samples/tree/master/kms/api/CloudKmsAspNetSample" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleCloudPlatform/dotnet-docs-samples/</a>查看所有的源文件和项目文件。通过模糊实现安全性已经被证明是失败的，所以如果您看到我们的设计或实现有任何安全问题，请在这里留言或在github存储库中记录一个错误。</p><p id="2601" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然<a class="ae jd" href="https://cloud.google.com/kms/" rel="noopener ugc nofollow" target="_blank">谷歌云密钥管理服务(KMS) </a> API已经完全发布并得到支持，但是<a class="ae jd" href="https://www.nuget.org/packages/Google.Cloud.Kms.V1/" rel="noopener ugc nofollow" target="_blank">客户端库</a>仍然处于<strong class="ih hj">测试版</strong>。因此，您可能希望等到1.0客户端库发布后，再在生产中使用该解决方案。</p></div></div>    
</body>
</html>