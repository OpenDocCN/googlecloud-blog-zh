<html>
<head>
<title>Using HKDF in BigQuery via UDFs for Improved Security Hygiene</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过UDF在BigQuery中使用HKDF来提高安全性</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-hkdf-in-bigquery-via-udfs-for-improved-security-hygiene-f0a4d5b2b6df?source=collection_archive---------0-----------------------#2021-07-14">https://medium.com/google-cloud/using-hkdf-in-bigquery-via-udfs-for-improved-security-hygiene-f0a4d5b2b6df?source=collection_archive---------0-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="fd89" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">简介</strong></h1><p id="5f1d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">BigQuery本身支持加密/解密<a class="ae kb" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions" rel="noopener ugc nofollow" target="_blank">方法</a>，这允许用户不用明文存储敏感数据/列。此外，随着数据保护法的出现，如GDPR的“被遗忘的权利”<a class="ae kb" href="https://en.wikipedia.org/wiki/Right_to_be_forgotten" rel="noopener ugc nofollow" target="_blank">条款</a>，这些功能允许通过<a class="ae kb" rel="noopener" href="/google-cloud/bigquery-encryption-functions-part-i-data-deletion-retention-with-crypto-shredding-7085ecf6e53f">加密粉碎</a>轻松删除数据。</p><p id="f048" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">然而，使用BigQuery中的<a class="ae kb" rel="noopener" href="/google-cloud/end-to-end-crypto-shredding-part-ii-data-deletion-retention-with-crypto-shredding-a67f5300a8c8">crypto shredishing</a>，用自己的密钥加密每个用户的数据存在一些挑战。即:</p><ol class=""><li id="d34a" class="kh ki hi jf b jg kc jk kd jo kj js kk jw kl ka km kn ko kp bi translated">加密密钥以明文json或字节存储。攻击者可以通过访问单个密钥并解密来访问用户的所有数据。</li><li id="864d" class="kh ki hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">即使使用密钥轮换，当BQ数据集中的用户数量很大时，为每个用户创建两个密钥并轮换它们也可能很难组织。</li></ol><p id="2a44" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这个单密钥问题的解决方案如下:为每个数据集创建一个共享密钥，并使用接受两个密钥的密钥导出函数导出加密密钥。在我们的解决方案中，我们选择<a class="ae kb" href="https://en.wikipedia.org/wiki/HKDF" rel="noopener ugc nofollow" target="_blank"> HKDF </a>作为我们的密钥派生函数，我们使用BigQuery UDF来计算密钥，因为此时没有本地BigQuery功能。</p><p id="2c37" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在我们等待本地BigQuery解决方案来进行密钥派生的同时，我们将使用Javascript<a class="ae kb" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions#javascript-udf-structure" rel="noopener ugc nofollow" target="_blank">UDF</a>在BigQuery中提出一个短期的密钥派生解决方案。在密钥推导中，两个单独的密钥被组合/加密，以便创建最终密钥来执行加密/解密。这两个单独的键可以存储在单独的数据集/表中，用于单独的IAM权限。这样，就增加了一层额外的保护，并且主密钥不是以明文形式存储的。所述过程的示意图见下文。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/73ceb09c73a6f982f823bbc441b9184d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5nZlWbGtr2sn80eNmBOvA.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">使用Javascript UDF可以在BigQuery中实现密钥派生。位于不同表/数据集中的两个密钥可以被组合以导出最终的加密密钥。这增加了一层额外的保护，因为加密密钥不是以准备使用的明文形式存储的。</figcaption></figure><h1 id="d85a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">大查询UDF解决方案</strong></h1><p id="34df" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了使用Javascript UDF实现密钥派生，我们利用<a class="ae kb" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>来捆绑额外的节点依赖。方法在这个<a class="ae kb" rel="noopener" href="/swlh/how-to-package-a-javascript-library-for-use-in-bigquery-2bf91061f66f">博客</a>里有详细介绍，而且相当有效。我们测试的密钥派生库可以在这里找到<a class="ae kb" href="https://www.npmjs.com/package/futoin-hkdf" rel="noopener ugc nofollow" target="_blank">。我们的<code class="du ll lm ln lo b">package.json</code>看起来如下:</a></p><pre class="kw kx ky kz fd lp lo lq lr aw ls bi"><span id="9cac" class="lt ig hi lo b fi lu lv l lw lx">{<br/>  “name”: “hkdf.js-bigquery”,<br/>  “version”: “1.0.0”,<br/>  “scripts”: {<br/>    “build”: “webpack — config webpack.config.js”<br/>  },<br/>  “dependencies”: {<br/>    “futoin-hkdf”: “^1.3.3”<br/>  },<br/>  “devDependencies”: {<br/>    “webpack”: “^4.41.5”,<br/>    “webpack-cli”: “^3.3.10”<br/>  }<br/>}</span></pre><p id="ae3a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">通过运行<code class="du ll lm ln lo b">npm install</code>，可以下载依赖项。</p><pre class="kw kx ky kz fd lp lo lq lr aw ls bi"><span id="cd0a" class="lt ig hi lo b fi lu lv l lw lx">var path = require('path');</span><span id="b61e" class="lt ig hi lo b fi ly lv l lw lx">module.exports = {<br/>    entry: './node_modules/futoin-hkdf/hkdf.js',<br/>    output: {<br/>        path: path.resolve(__dirname, 'dist'),<br/>        filename: 'hkdf.js',<br/>        library: 'hkdf',<br/>        libraryTarget: 'var',<br/>    },<br/>    mode: 'production',<br/>};</span></pre><p id="9c78" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">然后我们运行<code class="du ll lm ln lo b">npm run-script build</code>来生成<code class="du ll lm ln lo b">hkdf.js</code>，然后可以将它上传到GCS bucket中，供BigQuery调用。</p><p id="c696" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在可以创建如下所示的密钥派生UDF:</p><pre class="kw kx ky kz fd lp lo lq lr aw ls bi"><span id="a2be" class="lt ig hi lo b fi lu lv l lw lx">CREATE or replace FUNCTION theo_test.DERIVE_KEY(masterKey STRING, domainKey STRING) RETURNS STRING</span><span id="bbce" class="lt ig hi lo b fi ly lv l lw lx">LANGUAGE js</span><span id="191a" class="lt ig hi lo b fi ly lv l lw lx">OPTIONS (library=["gs://theo-gcs/hkdf.js"])</span><span id="fab9" class="lt ig hi lo b fi ly lv l lw lx">AS</span><span id="2b82" class="lt ig hi lo b fi ly lv l lw lx">r"""</span><span id="e181" class="lt ig hi lo b fi ly lv l lw lx">const length = 32; //Needs to be 32 characters</span><span id="179d" class="lt ig hi lo b fi ly lv l lw lx">const info = 'optional-context';</span><span id="0dfd" class="lt ig hi lo b fi ly lv l lw lx">const hash = 'SHA-256';</span><span id="e1ab" class="lt ig hi lo b fi ly lv l lw lx">const encoding = 'base64';</span><span id="e157" class="lt ig hi lo b fi ly lv l lw lx">return hkdf(masterKey, length, {'salt': domainKey, 'info': info, 'hash': hash}).toString(encoding);</span><span id="f1ae" class="lt ig hi lo b fi ly lv l lw lx">""";</span></pre><p id="1fbf" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">此外，需要编写一个UDF来创建json，以便密钥派生的输出可以用作有效的AesGcmKey Tink密钥。</p><pre class="kw kx ky kz fd lp lo lq lr aw ls bi"><span id="0bac" class="lt ig hi lo b fi lu lv l lw lx">CREATE or replace FUNCTION theo_test.TO_TINK_no_json(keyId NUMERIC, key STRING ) RETURNS STRING AS (</span><span id="f80d" class="lt ig hi lo b fi ly lv l lw lx">CONCAT("{\"key\": [{\"keyData\": {\"keyMaterialType\": \"SYMMETRIC\", \"typeUrl\": \"type.googleapis.com/google.crypto.tink.AesGcmKey\",\"value\": \"",</span><span id="bb04" class="lt ig hi lo b fi ly lv l lw lx">key,</span><span id="d669" class="lt ig hi lo b fi ly lv l lw lx">"\"}, \"keyId\": ",</span><span id="686f" class="lt ig hi lo b fi ly lv l lw lx">keyId,</span><span id="b54d" class="lt ig hi lo b fi ly lv l lw lx">",\"outputPrefixType\": \"RAW\", \"status\": \"ENABLED\"}],\"primaryKeyId\": ",</span><span id="530d" class="lt ig hi lo b fi ly lv l lw lx">keyId,</span><span id="3e10" class="lt ig hi lo b fi ly lv l lw lx">"}"</span><span id="fd3d" class="lt ig hi lo b fi ly lv l lw lx">));</span></pre><p id="ce3e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">请注意，输出键的长度需要为32个字符，因为BigQuery中的AesGcmKey被识别为34字节的键。为了使这个键在BigQuery中作为Tink键使用，我们需要在一个bytearray中将[26，32]添加到Derive Key函数的输出中。关于制作有效Tink密钥的详细信息可以在这个Stackoverflow <a class="ae kb" href="https://stackoverflow.com/questions/67320913/how-to-pass-in-valid-values-into-cleartext-keyset-json-to-create-a-tink-key" rel="noopener ugc nofollow" target="_blank">问题</a>中找到。现在可以用密钥派生来回加密和解密值了！</p><p id="7732" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">加密:</strong></p><pre class="kw kx ky kz fd lp lo lq lr aw ls bi"><span id="8d70" class="lt ig hi lo b fi lu lv l lw lx">select AEAD.ENCRYPT(KEYS.KEYSET_FROM_JSON(</span><span id="ee4f" class="lt ig hi lo b fi ly lv l lw lx">theo_test.TO_TINK_no_json(100,</span><span id="6f9f" class="lt ig hi lo b fi ly lv l lw lx">to_base64((SELECT concat(CODE_POINTS_TO_BYTES([26,32]), from_base64(theo_test.DERIVE_KEY('my_key1','key_salt1')))</span><span id="96c2" class="lt ig hi lo b fi ly lv l lw lx">))</span><span id="4166" class="lt ig hi lo b fi ly lv l lw lx">)),</span><span id="17b1" class="lt ig hi lo b fi ly lv l lw lx">from_base64("test"), cast("foo" as Bytes));</span></pre><p id="ca66" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">解密:</strong></p><p id="6db5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">将你的加密结果粘贴到<code class="du ll lm ln lo b">Paste your encrypted value here!!!</code>字段中。还要注意，加密的值是置换的，因此它不会总是确定地相同！：</p><pre class="kw kx ky kz fd lp lo lq lr aw ls bi"><span id="2555" class="lt ig hi lo b fi lu lv l lw lx">select AEAD.DECRYPT_BYTES(KEYS.KEYSET_FROM_JSON(</span><span id="8c83" class="lt ig hi lo b fi ly lv l lw lx">theo_test.TO_TINK_no_json(100,</span><span id="2ad1" class="lt ig hi lo b fi ly lv l lw lx">to_base64((SELECT concat(CODE_POINTS_TO_BYTES([26,32]), from_base64(theo_test.DERIVE_KEY('my_key1','key_salt1')))</span><span id="39b4" class="lt ig hi lo b fi ly lv l lw lx">))</span><span id="0f21" class="lt ig hi lo b fi ly lv l lw lx">)),</span><span id="1dd6" class="lt ig hi lo b fi ly lv l lw lx">from_base64("Paste your encrypted value here!!!"), cast("foo" as Bytes));</span></pre><h1 id="1d30" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最后的想法</h1><p id="7303" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们希望这个解决方案能在短期内帮助客户。虽然UDF解决方案适用于密钥派生，但我们仍在等待原生的BigQuery优化解决方案，因为在UDF中使用第三方库有一些缺点。即:</p><ul class=""><li id="2cc2" class="kh ki hi jf b jg kc jk kd jo kj js kk jw kl ka lz kn ko kp bi translated">使用第三方开源库需要社区支持，并且可能需要审计来检查库的健壮性和安全性。此外，弄清楚如何将javascript库用于其他产品(如Dataflow)可能需要更多的开销。</li><li id="57e5" class="kh ki hi jf b jg kq jk kr jo ks js kt jw ku ka lz kn ko kp bi translated">在密钥派生结果前添加字节是不明智的，否则可能无法向前兼容，尤其是对于Tink和BigQuery加密的未来版本。</li><li id="75b7" class="kh ki hi jf b jg kq jk kr jo ks js kt jw ku ka lz kn ko kp bi translated">UDF是相当计算密集型的。我们建议通过域键进行聚类，看看这是否有助于扩展和计算大量的键派生。</li></ul><p id="f9b0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">请继续关注BigQuery加密的更多改进！</p><p id="ea03" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">特别感谢<a class="ae kb" href="https://pdeyhim.medium.com/" rel="noopener"> Parviz Deyhim </a>的评论，它是BQ中与加密粉碎相关的所有内容的绝佳资源！</p></div></div>    
</body>
</html>