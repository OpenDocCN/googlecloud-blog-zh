<html>
<head>
<title>Run &amp; Build GameServer(Rust)- GKE+Agones Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运行并构建游戏服务器(Rust)- GKE+Agones平台</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/run-build-gameserver-rust-gke-agones-platform-984329cb5121?source=collection_archive---------3-----------------------#2022-11-27">https://medium.com/google-cloud/run-build-gameserver-rust-gke-agones-platform-984329cb5121?source=collection_archive---------3-----------------------#2022-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="509a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Agones是一个在<a class="ae jd" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>上托管、运行和扩展<a class="ae jd" href="https://en.wikipedia.org/wiki/Game_server#Dedicated_server" rel="noopener ugc nofollow" target="_blank">专用游戏服务器</a>的库。它是一个开源平台，用于部署、托管、扩展和协调大型多人游戏的专用游戏服务器，构建在行业标准的分布式系统平台<a class="ae jd" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>之上。它用可以利用和共同开发的开源解决方案取代了定制或专有的集群管理和游戏服务器扩展解决方案，因此您可以专注于构建多人游戏的重要方面，而不是开发支持它的基础架构。</p><p id="5cd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Agones在构建时考虑到了云和内部基础架构，可以根据需要调整其策略以进行设备管理、自动扩展等，从而确保用于托管专用游戏服务器的资源对于其所处的环境来说是成本最优的。</p><p id="8f3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文将讲述如何在一个简单的Rust游戏服务器中使用Agones Rust SDK。我们将利用谷歌云平台(谷歌kubernetes引擎)上安装的Agones管理Kubernetes产品。</p><p id="ca59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是在您开始使用Rust SDK for Agones构建和运行一个简单的游戏服务器之前的一些先决条件。</p><ol class=""><li id="f406" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae jd" href="https://www.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="ac44" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Agones安装在GKE</li><li id="5d4c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">正确配置kubectl</li><li id="78f7" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Agones存储库的本地副本</li><li id="2cf4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">Docker映像的存储库，如<a class="ae jd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>或<a class="ae jd" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank"> GC容器注册表</a></li></ol><p id="29c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照以下步骤为您的Agones安装创建一个<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes引擎(GKE) </a>集群。</p><h1 id="22f7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">开始之前</h1><p id="c363" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">采取以下步骤来启用Kubernetes引擎API:</p><ol class=""><li id="8d2e" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">访问谷歌云平台控制台中的<a class="ae jd" href="https://console.cloud.google.com/kubernetes/list" rel="noopener ugc nofollow" target="_blank"> Kubernetes引擎</a>页面。</li><li id="a3a0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">创建或选择一个项目。</li><li id="0fd5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">等待API和相关服务被启用。这可能需要几分钟时间。</li><li id="f6b6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://support.google.com/cloud/answer/6293499#enable-billing" rel="noopener ugc nofollow" target="_blank">为您的项目启用计费</a>。</li></ol><h1 id="5b1e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">选择外壳</h1><p id="24ac" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们可以使用<a class="ae jd" href="https://cloud.google.com/shell/" rel="noopener ugc nofollow" target="_blank">谷歌云外壳</a>或者本地外壳。</p><p id="5c70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud Shell是一个Shell环境，用于管理托管在Google云平台(GCP)上的资源。Cloud Shell预装了<code class="du kv kw kx ky b"><a class="ae jd" href="https://cloud.google.com/sdk/gcloud/" rel="noopener ugc nofollow" target="_blank">gcloud</a></code>和<code class="du kv kw kx ky b"><a class="ae jd" href="https://kubernetes.io/docs/user-guide/kubectl-overview/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>命令行工具。<code class="du kv kw kx ky b">gcloud</code>为GCP提供主要的命令行接口，而<code class="du kv kw kx ky b">kubectl</code>为针对Kubernetes集群运行命令提供命令行接口。</p><p id="efd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您喜欢使用本地shell，那么您必须在您的环境中安装<code class="du kv kw kx ky b">gcloud</code>和<code class="du kv kw kx ky b">kubectl</code>命令行工具。</p><h2 id="3592" class="kz jt hi bd ju la lb lc jy ld le lf kc iq lg lh kg iu li lj kk iy lk ll ko lm bi translated">云壳</h2><p id="493f" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">要启动云壳，请执行以下步骤:</p><ol class=""><li id="d16a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">进入<a class="ae jd" href="https://console.cloud.google.com/home/dashboard" rel="noopener ugc nofollow" target="_blank">谷歌云平台控制台</a>。</li><li id="2f42" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">从控制台的右上角，单击<strong class="ih hj">激活谷歌云外壳</strong>按钮。</li></ol><figure class="lo lp lq lr fd ls er es paragraph-image"><div class="er es ln"><img src="../Images/de6606455ffe5a33f2e60532396112da.png" data-original-src="https://miro.medium.com/v2/resize:fit:140/format:webp/1*kv039Ge6-J7MrcmvWTd3NQ.png"/></div></figure><p id="b95d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.云Shell会话在控制台底部的框架中打开。使用这个shell来运行<code class="du kv kw kx ky b">gcloud</code>和<code class="du kv kw kx ky b">kubectl</code>命令。</p><p id="cfde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.使用以下命令在您的地理区域设置一个计算区域。一个示例计算区域是<code class="du kv kw kx ky b">us-west1-a</code>。</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="ecf3" class="lz jt hi ky b be ma mb l mc md">gcloud config set compute/zone [COMPUTE_ZONE]</span></pre><h1 id="d327" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建防火墙</h1><p id="7290" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们需要一个防火墙来允许UDP流量通过端口7000-8000到达标记为<code class="du kv kw kx ky b">game-server</code>的节点。这些防火墙规则适用于您将在下一节中创建的集群节点。</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="ada1" class="lz jt hi ky b be ma mb l mc md">gcloud compute firewall-rules create game-server-firewall \<br/>  --allow udp:7000-8000 \<br/>  --target-tags game-server \<br/>  --description "Firewall to allow game server udp traffic"</span></pre><h1 id="619f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建集群</h1><p id="cb9e" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">一个<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture" rel="noopener ugc nofollow" target="_blank">集群</a>由至少一个<em class="me">控制平面</em>机和多个称为<em class="me">节点</em>的工作机组成。在Google Kubernetes引擎中，节点是运行Kubernetes进程的<a class="ae jd" href="https://cloud.google.com/compute/docs/instances/" rel="noopener ugc nofollow" target="_blank">计算引擎虚拟机</a>实例，这些进程使节点成为集群的一部分。</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="9feb" class="lz jt hi ky b be ma mb l mc md">gcloud container clusters create [CLUSTER_NAME] --cluster-version=1.23 \<br/>  --tags=game-server \<br/>  --scopes=gke-default \<br/>  --num-nodes=4 \<br/>  --no-enable-autoupgrade \ <br/>  --enable-image-streaming \<br/>  --machine-type=e2-standard-4</span></pre><h1 id="c37d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">(可选)创建专用节点池</h1><p id="cc04" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">为要安装的Agones资源创建一个<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/node-pools" rel="noopener ugc nofollow" target="_blank">专用节点池</a>。如果您跳过这一步，Agones控制器将与您的游戏服务器共享默认节点池，这对于实验来说很好，但不建议用于生产部署。</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="bb3e" class="lz jt hi ky b be ma mb l mc md">gcloud container node-pools create agones-system \<br/>  --cluster=[CLUSTER_NAME] \<br/>  --no-enable-autoupgrade \<br/>  --node-taints agones.dev/agones-system=true:NoExecute \<br/>  --node-labels agones.dev/agones-system=true \<br/>  --num-nodes=1</span></pre><h1 id="4b51" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">(可选)创建度量节点池</h1><p id="fab5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">如果您想使用Prometheus with Grafana或Cloud Logging and Monitoring来监控Agones系统，请为<a class="ae jd" href="https://agones.dev/site/docs/guides/metrics/" rel="noopener ugc nofollow" target="_blank">指标创建一个节点池。</a></p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="440c" class="lz jt hi ky b be ma mb l mc md">gcloud container node-pools create agones-metrics \<br/>  --cluster=[CLUSTER_NAME] \<br/>  --no-enable-autoupgrade \<br/>  --node-taints agones.dev/agones-metrics=true:NoExecute \<br/>  --node-labels agones.dev/agones-metrics=true \<br/>  --num-nodes=1</span></pre><h1 id="a9f5" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设置集群凭据</h1><p id="44d2" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">最后，让我们告诉<code class="du kv kw kx ky b">gcloud</code>我们正在与这个集群对话，并获取auth凭证供<code class="du kv kw kx ky b">kubectl</code>使用。</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="8a08" class="lz jt hi ky b be ma mb l mc md">gcloud config set container/cluster [CLUSTER_NAME]<br/>gcloud container clusters get-credentials [CLUSTER_NAME]</span></pre><h1 id="dc1b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">使用舵安装Agones</h1><p id="96dd" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">使用<a class="ae jd" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>软件包管理器在<a class="ae jd" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群上安装Agones。</p><h1 id="794b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">先决条件</h1><ul class=""><li id="c54d" class="je jf hi ih b ii kq im kr iq mf iu mg iy mh jc mi jk jl jm bi translated"><a class="ae jd" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">掌舵</a>包管理器3.2.3+</li><li id="210e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc mi jk jl jm bi translated"><a class="ae jd" href="https://agones.dev/site/docs/installation/#usage-requirements" rel="noopener ugc nofollow" target="_blank">支持Kubernetes集群</a></li></ul><h1 id="7041" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">舵3</h1><p id="493a" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">使用我们的stable helm库安装发布名为<code class="du kv kw kx ky b">my-release</code>的图表:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="ee27" class="lz jt hi ky b be ma mb l mc md">helm repo add agones https://agones.dev/chart/stable<br/>helm repo update<br/>helm install my-release --namespace agones-system --create-namespace agones/agones</span></pre><p id="3094" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在生产环境中运行时，Agones应该安排在专用的节点池中，与游戏服务器的安排位置不同，以获得更好的隔离和弹性。默认情况下，Agones更喜欢被安排在标有<code class="du kv kw kx ky b">agones.dev/agones-system=true</code>的节点上，并且容忍节点污染<code class="du kv kw kx ky b">agones.dev/agones-system=true:NoExecute</code>。如果没有专用节点可用，Agones将在常规节点上运行，但不建议生产使用。</p><h1 id="685b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">名称空间</h1><p id="7d4c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">默认情况下，Agones被配置为与部署在<code class="du kv kw kx ky b">default</code>名称空间中的游戏服务器协同工作。如果您计划使用另一个名称空间，您可以通过参数<code class="du kv kw kx ky b">gameservers.namespaces</code>配置Agones。</p><p id="a910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如使用<code class="du kv kw kx ky b">default</code> <strong class="ih hj">和</strong> <code class="du kv kw kx ky b">xbox</code>命名空间:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="1f67" class="lz jt hi ky b be ma mb l mc md">kubectl create namespace xbox<br/>helm install my-release agones/agones --set "gameservers.namespaces={default,xbox}" --namespace agones-system</span></pre><p id="6aa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想在升级您的版本后添加一个新的名称空间:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="97e8" class="lz jt hi ky b be ma mb l mc md">kubectl create namespace ps4<br/>helm upgrade my-release agones/agones --reuse-values --set "gameservers.namespaces={default,xbox,ps4}" --namespace agones-system</span></pre><h1 id="fc0b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">卸载图表</h1><p id="f460" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">要卸载/删除<code class="du kv kw kx ky b">my-release</code>部署:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="f87a" class="lz jt hi ky b be ma mb l mc md">helm uninstall my-release --namespace=agones-systemRBAC</span></pre><p id="e71f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，<code class="du kv kw kx ky b">agones.rbacEnabled</code>设置为真。这将在Agones中启用RBAC支持，并且如果在您的集群中启用了RBAC，则必须为真。</p><p id="ed89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该图表将负责为Agones创建所需的服务帐户和角色。</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="9c88" class="lz jt hi ky b be ma mb l mc md">helm install my-release --namespace agones-system \<br/>  --set gameservers.minPort=1000,gameservers.maxPort=5000 agones</span></pre><p id="1d35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述命令将把Agones控制器部署到<code class="du kv kw kx ky b">agones-system</code>名称空间。此外，Agones将使用1000-5000的动态游戏服务器端口分配范围。或者，可以在安装图表时提供指定参数值的YAML文件。举个例子，</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="2f3f" class="lz jt hi ky b be ma mb l mc md">helm install my-release --namespace agones-system -f values.yaml agones/agones</span></pre><h1 id="6514" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">舵试验</h1><p id="ecb2" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">通过运行以下命令检查Agones安装:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="b821" class="lz jt hi ky b be ma mb l mc md">helm test my-release --cleanup</span></pre><pre class="mj lv ky lw bn lx ly bi"><span id="a591" class="lz jt hi ky b be ma mb l mk md">RUNNING: agones-test<br/>PASSED: agones-test</span></pre><p id="093a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个测试将创建一个<code class="du kv kw kx ky b">GameServer</code>资源，然后删除它。</p><h1 id="1d7b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">控制器TLS证书</h1><p id="4442" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">默认情况下，agones chart生成准入控制器使用的tls证书，虽然这很方便，但它需要agones控制器在每个<code class="du kv kw kx ky b">helm upgrade</code>命令后重新启动。</p><h1 id="19b6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">指南</h1><p id="d5b4" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">对于大多数用例，控制器无论如何都需要重启(例如:控制器映像更新)。但是，如果您确实需要避免重启，我们建议您关闭tls自动生成功能(<code class="du kv kw kx ky b">agones.controller.generateTLS</code>到<code class="du kv kw kx ky b">false</code>，并提供您自己的证书(<code class="du kv kw kx ky b">certs/server.crt</code>、<code class="du kv kw kx ky b">certs/server.key</code>)。</p><h1 id="9339" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">证书管理器</h1><p id="46a6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">另一种方法是使用<a class="ae jd" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> cert-manager.io </a>解决方案进行集群级证书管理。</p><p id="6e10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使用证书管理器解决方案，首先<a class="ae jd" href="https://cert-manager.io/docs/installation/kubernetes/" rel="noopener ugc nofollow" target="_blank">在集群上安装证书管理器</a>。然后，<a class="ae jd" href="https://cert-manager.io/docs/configuration/" rel="noopener ugc nofollow" target="_blank">配置</a>一个<code class="du kv kw kx ky b">Issuer</code> / <code class="du kv kw kx ky b">ClusterIssuer</code>资源，最后<a class="ae jd" href="https://cert-manager.io/docs/usage/certificate/" rel="noopener ugc nofollow" target="_blank">配置</a>一个<code class="du kv kw kx ky b">Certificate</code>资源来管理控制器<code class="du kv kw kx ky b">Secret</code>。确保根据您的系统要求配置<code class="du kv kw kx ky b">Certificate</code>，包括有效性<code class="du kv kw kx ky b">duration</code>。</p><p id="e990" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个使用自签名<code class="du kv kw kx ky b">ClusterIssuer</code>配置控制器<code class="du kv kw kx ky b">Secret</code>的例子，其中秘密名称为<code class="du kv kw kx ky b">my-release-cert</code>或<code class="du kv kw kx ky b">{{ template "agones.fullname" . }}-cert</code>:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="a8f2" class="lz jt hi ky b be ma mb l mc md">#!/bin/bash<br/># Create a self-signed ClusterIssuer<br/>cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: cert-manager.io/v1<br/>kind: ClusterIssuer<br/>metadata:<br/>  name: selfsigned<br/>spec:<br/>  selfSigned: {}<br/>EOF</span></pre><pre class="mj lv ky ml mm aw mn bi"><span id="81e5" class="kz jt hi ky b fi mo mp l mk md"># Create a Certificate with IP for the my-release-cert )<br/>cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: cert-manager.io/v1<br/>kind: Certificate<br/>metadata:<br/>  name: my-release-cert<br/>  namespace: agones-system<br/>spec:<br/>  dnsNames:<br/>    - agones-controller-service.agones-system.svc<br/>  secretName: my-release-cert<br/>  issuerRef:<br/>    name: selfsigned<br/>    kind: ClusterIssuer<br/>EOF</span></pre><p id="2bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生成证书后，我们将希望<a class="ae jd" href="https://cert-manager.io/docs/concepts/ca-injector/" rel="noopener ugc nofollow" target="_blank">将caBundle </a>注入控制器webhook，并通过设置以下内容禁用控制器密码创建:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="7419" class="lz jt hi ky b be ma mb l mk md">helm install my-release \<br/>  --set agones.controller.disableSecret=true \<br/>  --set agones.controller.customCertSecretPath[0].key='ca.crt',customCertSecretPath[0].path='ca.crt'<br/>  --set agones.controller.customCertSecretPath[1].key='tls.crt',customCertSecretPath[1].path='server.crt'<br/>  --set agones.controller.customCertSecretPath[2].key='tls.key',customCertSecretPath[2].path='server.key'<br/>  --set agones.controller.allocationApiService.annotations={'cert-manager.io/inject-ca-from': 'agones-system/my-release-cert'} \<br/>  --set agones.controller.allocationApiService.disableCaBundle=true \<br/>  --set agones.controller.validatingWebhook.annotations={'cert-manager.io/inject-ca-from': 'agones-system/my-release-cert'} \<br/>  --set agones.controller.validatingWebhook.disableCaBundle=true \<br/>  --set agones.controller.mutatingWebhook.annotations={'cert-manager.io/inject-ca-from': 'agones-system/my-release-cert'} \<br/>  --set agones.controller.mutatingWebhook.disableCaBundle=true \<br/>  --namespace agones-system --create-namespace  \<br/>  agones/agones</span></pre><h1 id="0eee" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">运行简单的游戏服务器</h1><p id="d0f5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">首先，运行预构建版本的简单游戏服务器，并记下创建的名称:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="3eb5" class="lz jt hi ky b be ma mb l mc md">kubectl create -f https://raw.githubusercontent.com/googleforgames/agones/release-1.27.0/examples/rust-simple/gameserver.yaml<br/>GAMESERVER_NAME=$(kubectl get gs -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')</span></pre><p id="4d16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">游戏服务器设置Agones SDK，调用<code class="du kv kw kx ky b">sdk.ready()</code>通知Agones准备好提供流量，每10秒打印一条消息，然后在一分钟后调用<code class="du kv kw kx ky b">sdk.shutdown()</code>表示游戏服务器将要退出。</p><p id="4012" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过运行以下命令来跟踪游戏服务器的生命周期</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="5d80" class="lz jt hi ky b be ma mb l mc md">kubectl logs ${GAMESERVER_NAME} rust-simple -f</span></pre><p id="3b36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将产生类似于</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="8a1e" class="lz jt hi ky b be ma mb l mk md">Rust Game Server has started!<br/>Creating SDK instance<br/>Setting a label<br/>Starting to watch GameServer updates...<br/>Health ping sent<br/>Setting an annotation<br/>Marking server as ready...<br/>...marked Ready<br/>Getting GameServer details...<br/>GameServer name: rust-simple-txsc6<br/>Running for 0 seconds<br/>GameServer Update, name: rust-simple-txsc6<br/>GameServer Update, state: Scheduled<br/>GameServer Update, name: rust-simple-txsc6<br/>GameServer Update, state: Scheduled<br/>GameServer Update, name: rust-simple-txsc6<br/>GameServer Update, state: RequestReady<br/>GameServer Update, name: rust-simple-txsc6<br/>GameServer Update, state: Ready<br/>Health ping sent<br/>Health ping sent<br/>Health ping sent<br/>Health ping sent<br/>Health ping sent<br/>Running for 10 seconds<br/>GameServer Update, name: rust-simple-txsc6<br/>GameServer Update, state: Ready<br/>...<br/>Shutting down after 60 seconds...<br/>...marked for Shutdown<br/>Running for 60 seconds<br/>Health ping sent<br/>GameServer Update, name: rust-simple-txsc6<br/>GameServer Update, state: Shutdown<br/>GameServer Update, name: rust-simple-txsc6<br/>GameServer Update, state: Shutdown<br/>...</span></pre><p id="4b1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切按预期进行，游戏服务器将在大约一分钟后自动退出。</p><p id="fda6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些情况下，游戏服务器会进入一种不健康的状态，在这种情况下，它会无限期地重新启动。如果发生这种情况，您可以通过运行</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="0fbd" class="lz jt hi ky b be ma mb l mc md">kubectl delete gs ${GAMESERVER_NAME}</span></pre><h1 id="4204" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">构建一个简单的游戏服务器</h1><p id="fcbc" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">将目录切换到本地agones/examples/rust-simple目录。为了试验SDK，在你最喜欢的编辑器中打开<code class="du kv kw kx ky b">main.rs</code>,通过将分配给<code class="du kv kw kx ky b">let _health</code>的线程中的行修改为</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="67f0" class="lz jt hi ky b be ma mb l mc md">thread::sleep(Duration::from_secs(20));</span></pre><p id="7831" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，通过运行以下命令构建一个新的docker映像</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="774c" class="lz jt hi ky b be ma mb l mc md">cd examples/rust-simple<br/>REPOSITORY=&lt;your-repository&gt; # e.g. gcr.io/agones-images<br/>make build-image REPOSITORY=${REPOSITORY}</span></pre><p id="d548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多阶段Dockerfile将下拉构建映像所需的所有依赖项。请注意，这通常需要几分钟才能完成。</p><p id="1f77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦构建了容器，就将其推送到您的存储库</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="3e3c" class="lz jt hi ky b be ma mb l mc md">docker push ${REPOSITORY}/rust-simple-server:0.4</span></pre><h1 id="b196" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">运行定制的游戏服务器</h1><p id="11c5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在是时候将新创建的gameserver容器部署到Agones集群中了。</p><p id="d06f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，您需要编辑<code class="du kv kw kx ky b">examples/rust-simple/gameserver.yaml</code>以指向您的新图像:</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="31bd" class="lz jt hi ky b be ma mb l mc md">containers:<br/>- name: rust-simple<br/>  image: $(REPOSITORY)/rust-simple-server:0.4<br/>  imagePullPolicy: Always</span></pre><p id="4806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，部署您的游戏服务器</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="50bd" class="lz jt hi ky b be ma mb l mc md">kubectl create -f gameserver.yaml<br/>GAMESERVER_NAME=$(kubectl get gs -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')</span></pre><p id="efed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，遵循游戏服务器的生命周期，运行</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="5b47" class="lz jt hi ky b be ma mb l mc md">kubectl logs ${GAMESERVER_NAME} rust-simple -f</span></pre><p id="4d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将产生类似于</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="9786" class="lz jt hi ky b be ma mb l mk md">Rust Game Server has started!<br/>Creating SDK instance<br/>Setting a label<br/>Starting to watch GameServer updates...<br/>Health ping sent<br/>Setting an annotation<br/>Marking server as ready...<br/>...marked Ready<br/>Getting GameServer details...<br/>GameServer name: rust-simple-z6lz8<br/>Running for 0 seconds<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: Scheduled<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: RequestReady<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: RequestReady<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: Ready<br/>Running for 10 seconds<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: Ready<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: Unhealthy<br/>Health ping sent<br/>Running for 20 seconds<br/>Running for 30 seconds<br/>Health ping sent<br/>Running for 40 seconds<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: Unhealthy<br/>Running for 50 seconds<br/>Health ping sent<br/>Shutting down after 60 seconds...<br/>...marked for Shutdown<br/>Running for 60 seconds<br/>Running for 70 seconds<br/>GameServer Update, name: rust-simple-z6lz8<br/>GameServer Update, state: Unhealthy<br/>Health ping sent<br/>Running for 80 seconds<br/>Running for 90 seconds<br/>Health ping sent<br/>Rust Game Server finished.</span></pre><p id="6f3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着健康检查时间间隔的延长，游戏服务器会自动被Agones标记为<code class="du kv kw kx ky b">Unhealthy</code>。</p><p id="a9c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，通过手动移除来清理游戏服务器</p><pre class="lo lp lq lr fd lv ky lw bn lx ly bi"><span id="8d69" class="lz jt hi ky b be ma mb l mc md">kubectl delete gs ${GAMESERVER_NAME}</span></pre></div></div>    
</body>
</html>