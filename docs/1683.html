<html>
<head>
<title>Profiling Apache Beam Python pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析Apache Beam Python管道</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/profiling-apache-beam-python-pipelines-d3cac8644fa4?source=collection_archive---------1-----------------------#2020-11-30">https://medium.com/google-cloud/profiling-apache-beam-python-pipelines-d3cac8644fa4?source=collection_archive---------1-----------------------#2020-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a993664d579a7d82a9415ae4c308a7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_aBnDnQEBeP5lpMw"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@veri_ivanova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维里·伊万诺娃</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="688f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">更新(2022年1月):</strong>如果你正在云数据流上运行，它现在内置了对使用带有Python管道的Google Cloud Profiler的支持。如果你正在使用数据流，我强烈建议尝试一下，而不是按照这里给出的说明。更多详情请访问<a class="ae iu" href="https://cloud.google.com/dataflow/docs/guides/profiling-a-pipeline#python" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/data flow/docs/guides/profiling-a-pipeline # python</a></p><p id="ca88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，我们的Apache Beam管道的第一个版本的性能并不像我们希望的那样好，有时并不容易找到我们可以优化性能的地方；有时它是一个解析JSON的函数，其他一些瓶颈将是一个外部源或接收器，或者我们有一个非常热的键，我们正在尝试按键分组。在谷歌云平台上，<a class="ae iu" rel="noopener" href="/google-cloud/profiling-dataflow-pipelines-ddbbef07761d">我们可以很容易地将数据流与云分析器(以前称为Stackdriver Profiler) </a>结合起来，检测用Java编写的管道。但是如果我们想要分析Python管道呢？</p><p id="fe5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以获取在数据流上运行的Python管道的配置文件，但输出不会与云分析器集成。不过，您可以使用这些概要文件和一些其他工具来识别瓶颈。在这篇文章中，我们将解释如何获取分析数据，以及如何处理这些数据来识别Python管道中的代码瓶颈。</p><p id="1f05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Apache Beam中包含的分析器为管道处理的每个数据包生成一个包含分析信息的文件。</p><p id="9640" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/apache/beam/blob/9054c7a8f3ca48b4ea75e5b01e18ca8e9f773354/sdks/python/apache_beam/options/pipeline_options.py#L913-L933" rel="noopener ugc nofollow" target="_blank">类</a> <code class="du jt ju jv jw b"><a class="ae iu" href="https://github.com/apache/beam/blob/9054c7a8f3ca48b4ea75e5b01e18ca8e9f773354/sdks/python/apache_beam/options/pipeline_options.py#L913-L933" rel="noopener ugc nofollow" target="_blank">ProfilingOptions</a></code> <a class="ae iu" href="https://github.com/apache/beam/blob/9054c7a8f3ca48b4ea75e5b01e18ca8e9f773354/sdks/python/apache_beam/options/pipeline_options.py#L913-L933" rel="noopener ugc nofollow" target="_blank">包含了我们可以用来分析Python管道的所有选项</a>:<em class="jx">profile _ CPU</em>，<em class="jx"> profile_memory </em>，<em class="jx"> profile_location </em>和<em class="jx"> profile_sample_rate </em>。</p><p id="a37d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">前两个，<em class="jx"> profile_cpu </em>和<em class="jx"> profile_memory </em>是布尔标志，用于获取关于cpu和内存消耗的数据。</p><p id="c7ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选项<em class="jx"> profile_sample_rate </em>是可选的，应该是0到1之间的一个数字。它是被分析的数据束的比率。默认值为1。</p><p id="47e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jx"> profile_location </em>选项为profiler生成的所有文件设置输出目录。它应该被设置到Google云存储(GCS)中的一个位置。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="9d10" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">用数据流从我们的Python管道中获取一些概要数据</h2><p id="49af" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">例如，要获得一些CPU分析数据，您应该在启动管道时添加以下选项:</p><pre class="lf lg lh li fd lj jw lk ll aw lm bi"><span id="48b5" class="kf kg hi jw b fi ln lo l lp lq">--profile_cpu \<br/>--profile_location=’gs://&lt;SOME_PATH_IN_GCS&gt;’</span></pre><p id="7761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在这里使用的工具将处理CPU时间数据，但不处理内存数据。所以我们将只使用选项<em class="jx"> profile_cpu </em>。</p><p id="ceed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">启动管道后，数据流应该开始在GCS中的位置写入文件:</p><pre class="lf lg lh li fd lj jw lk ll aw lm bi"><span id="d100" class="kf kg hi jw b fi ln lo l lp lq">$ gsutil ls &lt;SOME_PATH_IN_GCS&gt;<br/>gs://&lt;SOME_PATH_IN_GCS&gt;/2020–11–21_19_15_10-process_bundle-4005<br/>gs://&lt;SOME_PATH_IN_GCS&gt;/2020–11–21_19_15_10-process_bundle-4006<br/>gs://&lt;SOME_PATH_IN_GCS&gt;/2020–11–21_19_15_10-process_bundle-4008<br/>[...]</span></pre><p id="98c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:不要运行管道太长时间，否则您将在该位置生成数百万个文件。为了识别管道中的潜在瓶颈，运行管道的时间不应该超过几分钟。运行一个小时应该绰绰有余(当然，前提是您有管道处理的数据的代表性样本)。</p><p id="dcde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦您生成了一些文件，您可以将它们下载到本地目的地，这样您就可以使用分析工具来处理它们。在这里，我们将所有数据下载到<code class="du jt ju jv jw b">profiling</code>目录，并且我们将假设本文剩余部分中的概要分析数据位于那里。</p><pre class="lf lg lh li fd lj jw lk ll aw lm bi"><span id="6703" class="kf kg hi jw b fi ln lo l lp lq">gsutil -m cp "gs://&lt;SOME_PATH_IN_GCS&gt;/*" profiling/</span></pre><p id="15e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您终止管道来停止生成更多的文件，您可能已经下载了一些空的tmp文件。在尝试处理它们之前，我们需要删除它们:</p><pre class="lf lg lh li fd lj jw lk ll aw lm bi"><span id="4100" class="kf kg hi jw b fi ln lo l lp lq">rm profiling/*tmp*</span></pre></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="9508" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">我如何解释分析器产生所有输出？</h2><p id="0855" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">为了解析和分析分析器的输出，现在可以使用Python 的<a class="ae iu" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank"/><code class="du jt ju jv jw b"><a class="ae iu" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank">pstats</a></code><a class="ae iu" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank">模块。使用该模块，我们可以读取概要分析数据，对其进行聚合和排序，并生成一个更小的概要分析输出文件，这将使详细的分析更快。</a></p><p id="bd59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用以下脚本，您可以导入下载的数据，并生成汇总输出。这里我们按<code class="du jt ju jv jw b">'cumulative'</code>排序，它是在那个函数上花费的总的累计CPU时间:</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="531e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行这个脚本之后，您将拥有一个名为<code class="du jt ju jv jw b">dataflow.prof</code>的文件，您可以使用它来调查您的管道的CPU和内存消耗。</p><p id="51b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该文件比您从GCS下载的原始数据小得多。例如，对于这篇文章，我生成了大约1.2 GB的数据，输出文件的大小为427 KB。</p><p id="121e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以用不同的工具研究这个文件<code class="du jt ju jv jw b">dataflow.prof</code>。有一些工具，比如<a class="ae iu" href="https://github.com/jrfonseca/gprof2dot" rel="noopener ugc nofollow" target="_blank"> gprof2dot </a>、<a class="ae iu" href="https://github.com/nschloe/tuna" rel="noopener ugc nofollow" target="_blank"> tuna </a>或<a class="ae iu" href="https://jiffyclub.github.io/snakeviz/" rel="noopener ugc nofollow" target="_blank"> snakeviz </a>，允许您获得带有分析信息的图表，在某些情况下还可以交互地浏览图表。但是，由于这些图中包含大量不相关的函数调用，很难理解这些图中的分析数据。</p><p id="7e23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在这篇文章中，我们将使用Python来尝试过滤分析数据，并找到更相关的点，以确定我们可以提高管道性能的点。</p><p id="579e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从读取我们生成的文件开始，并打印一些总体统计数据。脚本非常简单:</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="1da8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出将类似于以下内容:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/3e3ece7e5633dbf28634b6a10e853b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHuZLXyEe6leLzaz8BROhQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们管道代码的概要统计</figcaption></figure><p id="1e7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">CPU时间仅在函数级可用。在右边，我们看到函数的数据:文件名，函数开始的行，以及括号中的函数名。</p><p id="0d2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在左侧，我们可以看到该函数被调用的次数、在该函数中花费的累计时间以及在该函数中花费的平均时间(<em class="jx">累计时间百分比</em>)。</p><p id="6021" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"/><code class="du jt ju jv jw b"><strong class="ix hj">tottime</strong></code><strong class="ix hj">和</strong> <code class="du jt ju jv jw b"><strong class="ix hj">cumtime</strong></code> <strong class="ix hj">有什么区别？</strong>这种差异非常重要，将决定我们必须如何分析输出。一方面，<code class="du jt ju jv jw b">tottime</code>只计算函数内部代码花费的时间，但是不计算函数内部代码调用其他函数花费的时间。</p><p id="72b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，<code class="du jt ju jv jw b">cumtime</code>与我们将要分析代码的方式更相关。<strong class="ix hj">它包括在函数内部花费的所有时间</strong>，也包括对任何其他函数的任何调用。这将帮助我们找到代码中的瓶颈，即使这些瓶颈是由于调用了不是我们代码的库。<strong class="ix hj">这可能是我们在分析数据管道时想要的信息</strong>。我们不仅对算法的复杂性感兴趣，还对调用其他函数所产生的额外时间感兴趣，比如连接到服务、解析消息等等。此外，如果由于某种原因我们的一个函数是递归的，我们想知道从第一次递归调用开始在函数中花费的总时间，而不是每次递归调用的时间。递归函数可能很方便，但也是一个性能猪。有了<code class="du jt ju jv jw b">tottime</code>,我们将无法检测那些使用递归函数的性能猪；我们需要使用<code class="du jt ju jv jw b">cumtime</code>来找到我们的代码消耗大部分CPU的地方。</p><p id="1be8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">统计数据的一个值得注意的方面是，大多数函数都与Beam SDK、其他库或Python本身相关。这是正常的，因为执行的大部分代码不是我们的代码。如果您试图在文件列表中找到您的代码，您会注意到它实际上位于<code class="du jt ju jv jw b">/usr/local/lib/python3.8/site-packages/</code>的子目录中。这是因为在创建worker时，您的代码只是作为另一个Python模块安装的。您需要保留您在代码中定义的任何模块的名称，以便能够将它们从安装在Dataflow worker中的其余Python模块中过滤出来。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="05b0" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">找到消耗大部分CPU的代码部分</h2><p id="a1ca" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated"><code class="du jt ju jv jw b">tottime</code>和<code class="du jt ju jv jw b">cumtime</code>之间的差异突然变得更加相关。统计数据中的噪音和外部文件数量惊人。如果我们使用<code class="du jt ju jv jw b">cumtime</code>,我们可以完全专注于我们的代码。如果有任何导致性能问题的外部调用，它将被计入<code class="du jt ju jv jw b">cumtime</code>。</p><p id="a759" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们如何过滤我们的代码？stats对象包含一个字典，我们可以用它来过滤掉我们的代码。在Python中，我们可以将<code class="du jt ju jv jw b">p.sort_stats('cumulative')</code>的输出作为一个字典(下面是Python代码):</p><pre class="lf lg lh li fd lj jw lk ll aw lm bi"><span id="ff8f" class="kf kg hi jw b fi ln lo l lp lq">stats_dict = p.sort_stats('cumulative').stats </span></pre><p id="152f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个字典的关键字是带有文件名、代码行和函数名的元组。如果我们知道模块的名字，我们就可以提取模块的密钥。例如，假设在我们的代码中有两个模块，分别叫做<code class="du jt ju jv jw b">dofns</code>和<code class="du jt ju jv jw b">pipeline</code>；我们希望提取关于模块的行，并按照这些函数所用的平均时间对输出进行排序。我们可以像下面这样做(使用上一步提取的stats_dict):</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="6a01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，我获得了以下输出:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/d6b69ad86e60140f8ba2b18df670b075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ngsEh7wlLO82p3CTGWkKQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">按平均时间过滤和排序后的输出</figcaption></figure><p id="195d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，我们看到代码花费的大部分时间是在文件<code class="du jt ju jv jw b">business_rules.py</code>中找到的<code class="du jt ju jv jw b">DoFn</code>。第一个结果并不奇怪:大部分时间都花在了那个<code class="du jt ju jv jw b">DoFn</code>的<code class="du jt ju jv jw b">process</code>方法上。第二个结果更有趣:在那个<code class="du jt ju jv jw b">process</code>方法中，我们正在解析时间戳，看起来大约有一半的处理时间用于解析过程。也许我们可以尝试改进解析过程。</p><p id="4a66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的例子强调了一个好的管道设计的重要性:<strong class="ix hj">我们应该把我们的代码分成小的函数，当我们试图找出需要改进代码性能的地方时，这将对我们有很大的帮助。</strong></p><p id="c93e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们没有在我们的<code class="du jt ju jv jw b">DoFn</code>类中定义这个<code class="du jt ju jv jw b">_parse_timestamp</code>方法，我们就不会知道为什么<code class="du jt ju jv jw b">business_rules</code> <code class="du jt ju jv jw b">DoFn</code>比<code class="du jt ju jv jw b">parse_messages</code> <code class="du jt ju jv jw b">DoFn</code>慢10倍。由于将工作划分为更小的函数，我们知道大约一半的时间专门用于解析时间戳。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="0c8e" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">我的代码调用了哪些外部函数？</h2><p id="dd8d" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我们发现我们的<code class="du jt ju jv jw b">business_rules</code> <code class="du jt ju jv jw b">DoFn</code>消耗了大部分CPU，这是由于解析时间戳造成的。在我们的代码中，我们使用一些外部代码来完成这项任务；也许是外部库导致了性能问题。我们能发现哪些对外部库的调用是通过这个函数完成的吗？这些调用消耗了多少？</p><p id="128b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们假设在前面的例子中，<code class="du jt ju jv jw b">_parse_timestamp</code>方法在索引为<code class="du jt ju jv jw b">1</code>的<code class="du jt ju jv jw b">mykeys</code>列表中；让我们试着找出所有被<code class="du jt ju jv jw b">mykeys[1]</code>调用的函数:</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="efc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个代码片段中，我们找到了stats字典中被<code class="du jt ju jv jw b">mykeys[1]</code>调用的所有条目，这是<code class="du jt ju jv jw b">_parse_timestamp</code>方法，然后我们按平均值<code class="du jt ju jv jw b">cumtime</code>对输出进行排序。</p><p id="5a73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行上述代码片段后，我们获得了以下输出:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/07550478e23e67b1a01faea7c9fc2ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p36QwdDNanyodwFuSQ0MJQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">试图找出是否有任何外部库对性能猪负责。</figcaption></figure><p id="a6b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们发现两个条目是Apache射束函数。因为这些与Beam的工作原理有关，我们对此无能为力，所以我们可以忽略它们。</p><p id="5dfc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是第一个条目实际上非常有趣:我们使用的是<code class="du jt ju jv jw b">dateutil</code>模块，它是<a class="ae iu" href="https://pypi.org/project/python-dateutil/" rel="noopener ugc nofollow" target="_blank">包python-dateutil </a>的一部分。该模块平均花费多少时间？答对了。我们在<code class="du jt ju jv jw b">_parse_timestamp</code>方法(. 00134秒/呼叫)中花费了96%的时间(. 00129秒/呼叫)。</p><p id="82ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，总的来说，花费在我们最昂贵的<code class="du jt ju jv jw b">DoFn</code>上的时间大约有一半是由于使用了python-dateutil解析器。如果我们能找到替代方案，我们可能会大大减少管道资源的使用。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="f297" class="kf kg hi bd kh ki kj kk kl km kn ko kp jg kq kr ks jk kt ku kv jo kw kx ky kz bi translated">结论</h2><p id="abc4" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">如果您的Apache Beam Python管道的性能不如您预期的好，您可以对其进行分析，以找出代码的哪些部分消耗了大部分CPU，以及导致这种情况的潜在原因是什么(例如低效的外部库或服务)。</p><p id="9e62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Google Cloud Platform中，您可以将概要分析输出写入GCS，然后使用Python脚本对其进行分析。</p><p id="42c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python profiler提供了两个主要的指标，可以用来测量代码的CPU使用率:<code class="du jt ju jv jw b">tottime</code>和<code class="du jt ju jv jw b">cumtime</code>。因为<code class="du jt ju jv jw b">cumtime</code>也测量调用外部库或服务后的等待时间，所以它可能是我们的评测更感兴趣的指标。通过关注<code class="du jt ju jv jw b">cumtime</code>，我们可以过滤掉所有不是我们代码的东西，然后通过<code class="du jt ju jv jw b">cumtime</code>对我们的代码进行排序。</p><p id="930f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章中的例子展示了一个好的管道设计的重要性。我们的代码应该<strong class="ix hj">划分成小函数</strong>。通常，大部分时间都花在我们的<code class="du jt ju jv jw b">DoFn</code>类的<code class="du jt ju jv jw b">process</code>方法中。如果我们不将<code class="du jt ju jv jw b">process</code>方法中的代码分割成更小的函数，就不可能知道<code class="du jt ju jv jw b">process</code>方法的哪一部分导致了性能问题。</p><p id="afbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，因为分析输出中包含的函数调用数量惊人，所以为我们的代码选择<strong class="ix hj">易于识别的模块名是很重要的。数据流工作者将把我们的代码和任何其他Python依赖项一起安装在通常的<code class="du jt ju jv jw b">site-packages</code>目录中。识别代码的唯一方法是通过模块和文件名，而不是路径。</strong></p><p id="9cc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总之，虽然<a class="ae iu" rel="noopener" href="/google-cloud/profiling-dataflow-pipelines-ddbbef07761d">不像Beam Java pipelines和Dataflow，我们不能使用像Cloud Profiler </a>这样简洁的工具，但这并不意味着我们不能分析Python管道。是的，我们可以，只需要一点点Python脚本。</p></div></div>    
</body>
</html>