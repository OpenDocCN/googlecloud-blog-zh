# PostgreSQL 扩展转向云微服务

> 原文：<https://medium.com/google-cloud/postgresql-extension-turned-cloud-microservce-abf6e187c6d?source=collection_archive---------1----------------------->

![](img/4e5be412ad70e9732e6a82602a47d3ef.png)

迁移数据库的一个挑战是整理您的环境，这样您就不会遇到兼容性问题。那么，当您想要迁移到云中的托管服务，比如 [Cloud SQL](https://cloud.google.com/sql) ，并且发现您最喜欢的扩展不受支持时，会发生什么呢？当然，我们希望支持所有的东西，但是支持每个单独的插件需要时间来确保它集成到云 SQL 中，而不会破坏任何东西。

具体来说，我们来聊聊 [pg_cron](https://github.com/citusdata/pg_cron) 。PostgreSQL 插件，它在你的数据库中给你一个 crontab。从用[吸尘器](https://www.postgresql.org/docs/current/sql-vacuum.html)修剪旧的未使用的数据，从不再需要的表格中截断数据，以及一系列其他周期性任务，一切都很方便。超级方便的插件。

暂时不支持 pg_cron，但是等等，不要走！根据您想要做的事情，重新实现功能并不需要很费力。甚至当我们确实支持 pg_cron 将业务逻辑从数据源中分离出来时，将事情分解到它们自己的服务中也是有意义的。今天我谈论的是 pg_cron，但是考虑将业务逻辑从数据库扩展转移到单独的服务中，可以让您灵活地将数据转移到任何需要的地方，而不用担心特定于数据的解决方案。

让我们通过一种方式来完成 pg_cron 任务。

# 工具

我们将用来生成 cron 任务的主要产品是[云调度器](https://cloud.google.com/scheduler)。长话短说，这是一个 GCP 产品的 crontab(主要是)。在控制台中创建一个新的[作业](https://console.cloud.google.com/cloudscheduler/jobs/new)，您将从熟悉的 cron 界面开始，该界面用于定义您希望作业何时触发，并且您可以定义您希望它处于哪个时区。

![](img/5eb80f8cdd2382deb37fb3beb3983f8b.png)

接下来是不同的部分。与普通的 cron 不同，在普通的 cron 中，您定义想要执行的内容的路径，在 Scheduler 中，您需要定义一个触发目标。您可以点击任意 HTTP URL，向预定义的[发布/订阅](https://cloud.google.com/pubsub)主题发送消息，或者向您创建的[应用引擎](https://cloud.google.com/appengine)实例发送 HTTP 消息。自然，您想使用哪种方法完全取决于您想移植的现有任务。

例如，如果您有一个作业需要触发多个不一定相关的操作？将消息发送到 Pub/Sub 并让其他服务订阅消息将到达的主题可能是最有意义的。这将反映一个委托模式。或者，如果作业需要触发一组相关的任务，那么构建一个 App Engine 应用程序作为端点，然后它可以处理捆绑包中的相关任务，这可能是最有意义的。最后，我要在这里展示的是，如果工作是一次性的，并且只需要完成一个小任务，那么构建一个[云功能](https://cloud.google.com/functions)，或者设置一个在[云运行](https://cloud.google.com/run)中运行的容器来处理这些一次性任务可能是有意义的，因为这些无服务器产品可以扩展到零，所以当它们不运行时不会花费您任何成本。

让我们看一个简单的例子，通过一种方式来实现这一点。

# 演练

为了便于讨论，假设您有一个 pg_cron 作业，它在备份完成后的每晚凌晨 1 点运行，从您的一个表中删除较旧的数据，以保持 30 天窗口内的操作数据。

`SELECT cron.schedule(‘0 1 * * *’, $$DELETE FROM records WHERE entry_time < now() — interval ‘1 month$$);`

第一步是获得 SQL 查询的功能，将旧数据从其他地方删除。正如我提到的，在 GCP 有很多方法可以做到这一点。为此，我将坚持使用[谷歌云功能](https://cloud.google.com/functions)。它们非常容易竖立，这种一次性功能是一个完美的使用案例。

有一个写得非常好的 [Codelab](https://codelabs.developers.google.com/codelabs/connecting-to-cloud-sql-with-cloud-functions?hl=en#0) 演示了如何创建一个云函数，它与云 SQL 实例进行对话。代码实验室需要做一些改变。第一个是 stmt 变量，从代码示例中的 insert 调用到 pg_cron 函数中的 delete 调用。第二，当 Codelab 告诉我们允许对我们的云函数进行未经验证的调用时，我们不想听。如果您确实允许未经身份验证的请求，不会发生灾难性的事情，因为我们只是删除我们希望删除的旧数据，但是如果有人碰巧得到了 URL，那么他们可以发送垃圾邮件，这可能会影响数据库的性能，并在云函数调用上花费您一些额外的钱。

关于这个设置需要注意的另一件事是，云 SQL 实例是用一个公共 IP 地址创建的。因为这篇文章的重点是将扩展转换为微服务，所以我不会讲太多细节，但是要知道，根据您对云 SQL 实例的需求，连接可能会变得有点棘手。在接下来的一篇文章中，我将更深入地介绍我们的无服务器云 SQL 产品的连接性。

好的，如果你在阅读这篇文章的时候正在做这个，去 Codelab 做我提到的修改，然后回来。我会等的。

都准备好了吗？太棒了，回到我们的故事。

现在我们已经设置了一个函数，当我测试/运行它时，它正确地从我们的数据库中删除了超过一个月的条目。接下来，我们必须设置我们的云调度器任务来调用我们的函数。

重温之前的[创作页面](https://console.cloud.google.com/cloudscheduler/jobs/new)，现在让我们开始工作吧。

![](img/d36903e21b1bc3fcec0d992546d2b6bd.png)

正如它在 UI 中所说的，频率是标准的 cron 格式，所以我们希望我们的清理脚本在每天凌晨 1:00 启动，所以将我们的频率字段设置为:
`0 1 * * *`

我在 us-west2 中创建了我的云 SQL 实例，所以我将我的时区设置为太平洋夏令时(PDT)。

![](img/615ecd3c084011f7f5dc15173b95a0eb.png)

因为我们将云函数设置为由 HTTP 触发，所以我们将调度器任务设置为命中 HTTP 端点。您可以从您创建的云函数的详细信息中获取 URL。

![](img/3ac397b98550dd4d18c8c1abb7391316.png)

现在，如果您已经将云功能设置为接受未经授权的连接，只是为了玩玩它(请不要在生产中这样做)，那么您就基本上一切就绪了。你可以点击底部的 Create，噗的一声，它就开始工作了。但是，如果您禁用了它，那么您将需要在您的请求中发送一个 Auth 头。您有两种选择，一种是 OAuth 令牌，另一种是 OIDC 令牌。一般来说，至少就 GCP 目标而言，如果你正在运行一个存在于`*.googleapis.com`上的 API，那么你将需要一个 OAuth 令牌，否则 OIDC 令牌是首选。所以在我们的例子中，云函数可以使用 OIDC 令牌。如果需要，您要指定的服务帐户可以与您在云功能服务帐户中使用的帐户相同。无论如何，您需要添加到服务帐户中以成功调用云函数的角色是云函数调用者角色。使用该角色创建一个新帐户，或者将该角色添加到现有服务帐户中，然后在 Scheduler 字段中指定服务帐户的完整电子邮件。“受众”字段是可选的，对于此服务，您可以忽略它。

应该就是这样！点击创建按钮，您的调度任务将被创建并按指定的时间表运行！当我测试这个的时候，我把我的频率设置为`5 * * * *`，让我的云函数输出一些东西到控制台。这样，我就可以检查日志记录，看看它是否正在启动。一旦你点击进入你创建的云功能的详细信息，就会有一个导航标签显示日志。单击它将显示该功能的项目日志的过滤视图。

![](img/31709fb223bc3068c1a38e8c4eb01ebc.png)

我建议通过创建一个简单的 *Hello World 来进行测试，以确保您不会向数据库发送垃圾邮件！*首先使用云功能，然后用你的调度程序触发它。

那就这样吧！用微服务替换 PostgreSQL 扩展。虽然我向您展示了如何为 pg_cron 和 Cloud Scheduler 做到这一点，但希望这能激发一些想法，将一些业务逻辑从数据库中分离出来，放到服务中。这是一个简单的例子，但是这有助于减轻主数据库的负载。

感谢阅读！如果您有任何问题或意见，请通过 [Twitter](https://twitter.com/GabeWeiss_) 联系我，我的 DMs 是开放的。