<html>
<head>
<title>Automating Application Dashboard Creation for Services on GKE/Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为GKE/Istio上的服务自动创建应用仪表板</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/automating-application-dashboard-creation-for-services-on-gke-istio-a55a5a79aa15?source=collection_archive---------1-----------------------#2020-01-07">https://medium.com/google-cloud/automating-application-dashboard-creation-for-services-on-gke-istio-a55a5a79aa15?source=collection_archive---------1-----------------------#2020-01-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="3be5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="c6dc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我越来越多地从客户和我尊敬的业内人士那里听到一个更有趣的概念，那就是“作为代码监控”。当然，这是“一切如代码”运动的一个子集，但它确实引起了我的共鸣。具体来说，我最近与许多人交谈过，他们对在推出新服务或新项目时自动设置监控配置感兴趣。这通常包括两个主要部分——警报和仪表板。通过使用相关的<a class="ae kb" href="https://cloud.google.com/monitoring/alerts/using-alerting-api" rel="noopener ugc nofollow" target="_blank"> API </a>或<a class="ae kb" href="https://www.terraform.io/docs/providers/google/r/monitoring_alert_policy.html" rel="noopener ugc nofollow" target="_blank"> Terraform </a>，在Stackdriver中自动创建警报策略已经有一段时间了。现在，相同的自动化可用于Stackdriver仪表板！</p><h1 id="5da2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">仪表板</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/3cd439bc03329707cfb07e3b352a1662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZtSss6lG3HOJp7zO"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">https://twitter.com/ronsoak<a class="ae kb" href="https://twitter.com/ronsoak" rel="noopener ugc nofollow" target="_blank">的功劳</a></figcaption></figure><p id="e6a6" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">我一直认为仪表板在监控中被过分强调了，因为它们对问题检测或问题解决没有真正的帮助。前者可以通过定义良好的SLO和警报来更好地解决，后者可以通过良好的可观察性和专门的查询功能来解决。然而，仪表板被几乎所有涉及服务可靠性的人广泛使用，并且是任何监控设置中的必备功能。Stackdriver仪表板非常受欢迎，我的大多数客户对话都包括帮助人们以这样或那样的方式可视化数据。我回答的最常见的一个问题是“我们的仪表板上应该放些什么？”</p><p id="b602" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">令人欣慰的是，这个问题的答案在SRE <a class="ae kb" href="https://landing.google.com/sre/sre-book/toc/" rel="noopener ugc nofollow" target="_blank">一书</a>中的<a class="ae kb" href="https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/" rel="noopener ugc nofollow" target="_blank">章节</a>中有很好的记录。如果你没有其他东西，就从“黄金信号”开始——流量、错误、延迟和饱和度。</p><p id="d5c1" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">我们可以以在GKE运行并由Istio服务网格管理的一组基本服务为例。我以前写过Istio对于可观察性和监控的价值，以及它与Stackdriver <a class="ae kb" rel="noopener" href="/google-cloud/istio-and-stackdriver-59d157282258">的集成。另外，我创建了一个使用Grafana </a><a class="ae kb" href="https://cloud.google.com/community/tutorials/visualizing-metrics-with-grafana" rel="noopener ugc nofollow" target="_blank">在这里</a>构建一个显示来自这样一个系统的“黄金信号”数据的仪表板的教程。总的来说，我们在寻找类似这样的东西(<strong class="jf hj">注意</strong>我在这里使用的是<a class="ae kb" href="https://cloud.google.com/stackdriver/docs/release-notes#December_04_2019" rel="noopener ugc nofollow" target="_blank">测试版</a>的云控制台监控):</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kx"><img src="../Images/6726f6995711f7cc80ea9b02dcbf5c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Z68KozduXEld55z"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">Stackdriver中的服务仪表板</figcaption></figure><p id="413c" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">让我们看看如何创建一个关注服务健康“黄金信号”的仪表板。</p><h1 id="c4cb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">应用仪表板</h1><h1 id="b560" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">请求费率</h1><p id="4925" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">第一个“黄金信号”是“流量”——本质上是衡量服务对多少用户活动做出响应的指标。幸运的是，Istio为网格中的每个服务都提供了这一点。该指标称为“服务器请求计数”，我的仪表板中的第一个图表“按服务列出的请求率”使用该指标，并按“目的地服务名称”标签对结果进行分组。下面是它的详细配置:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kx"><img src="../Images/66e6df4953277cd622865761ef9d5da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cN1yvlfFI8Y_P9_-"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">请求费率图表</figcaption></figure><h1 id="9135" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">错误</h1><p id="8ef4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下一个图表“按服务划分的错误”使用了相同的指标和分组选项；唯一的区别是数据被过滤，只统计响应代码不是200的请求。这是一种粗略的方法，因为它确实包括3xx重定向和4xx错误，这通常是客户端配置错误或行为不当的结果，但这足以说明这一点。下面是该图表的配置:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ky"><img src="../Images/4f4d47d97f79522c928bf176cf3222ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fB8byR5a4nSHrdtg"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">错误图表</figcaption></figure><h1 id="e39f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">潜伏</h1><p id="619f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后一个图表再次使用Istio指标—这一次，它是“服务器响应延迟”，按“目标服务名称”分组，并使用第99个百分位数的聚合。虽然这可能是一个好主意，但我不会为此过滤掉错误。它的配置如下:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kz"><img src="../Images/08c379ed4fbc12a5b96adbba95f00a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-4UBCZY8iHeFHB5D"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">潜伏期图表</figcaption></figure><h1 id="3162" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">自动化</h1><p id="fe30" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设数据是可用的，在Stackdriver中手动创建这样的仪表板并不困难，但是如果可能的话，应该自动化。随着Dashboards API的测试版发布，现在就是了！例如，用户还可以使用API在工作区之间复制仪表板，或者通过自动化创建额外的标准化。让我们来看看细节。</p><h1 id="e8e6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">应用程序接口</h1><p id="d47d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">API在这里被记录为<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards" rel="noopener ugc nofollow" target="_blank"/>，但是总体思想非常简单——我们简单地调用projects.dashboards.create方法，传递一个dashboards对象，该对象包含名称、描述和一组指定图表本身的小部件对象。</p><h1 id="3ef7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结构</h1><p id="1837" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因为小部件是我们创建仪表板的基本构件，所以让我们从这里开始。我们已经有了自己的图表定义，只需要将它们转换成API期望的JSON表示<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards" rel="noopener ugc nofollow" target="_blank"/>。我们首先定义仪表板本身，它需要:</p><ol class=""><li id="1ff5" class="la lb hi jf b jg ks jk kt jo lc js ld jw le ka lf lg lh li bi translated"><strong class="jf hj">名称</strong>，格式为“/projects/ &lt;项目ID或编号&gt;/dashboards/&lt;ID&gt;”—为了创建，我们可以不填</li><li id="1dae" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated"><strong class="jf hj">显示名称</strong> —实际创建仪表板时显示的名称</li><li id="2e19" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">一个“<strong class="jf hj"> root </strong>”对象——要显示的实际内容，它包含一个小部件</li><li id="9bdd" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">默认<strong class="jf hj">选项</strong>将在加载时应用于仪表板</li></ol><p id="be8c" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">根是我们定义仪表板实际内容的地方。对于我们的示例，我们需要创建一个包含两列和三个图表的仪表板。所以仪表板的根是一个有两列的<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards#gridlayout" rel="noopener ugc nofollow" target="_blank"> GridLayout </a>。然后它需要包含三个额外的<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards#widget" rel="noopener ugc nofollow" target="_blank">小部件</a>，每个小部件将指定一个<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards#xychart" rel="noopener ugc nofollow" target="_blank"> xyChart </a>。每个图表需要指定一个<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards#dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>对象，该对象又使用一个<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards#timeseriesfilter" rel="noopener ugc nofollow" target="_blank">时间序列过滤器</a>来实际查询数据。</p><h1 id="fac9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><p id="9f22" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们看看如何使用这些信息来实现我们的仪表板。</p><h1 id="04e1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">请求费率</h1><p id="25c1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是请求率图表的JSON定义。这是我手动创建的，但是您可以使用<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards/create" rel="noopener ugc nofollow" target="_blank"> API Explorer </a>来创建您自己的基线，并简单地用参数填充它。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lo"><img src="../Images/2ff510db90398ee890d83a509b4258c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNoj9Hu2PX47P_5eTWdP0A.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">请求费率图表定义</figcaption></figure><p id="32bf" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">定义中需要注意的一些事项:</p><ul class=""><li id="b4f9" class="la lb hi jf b jg ks jk kt jo lc js ld jw le ka lp lg lh li bi translated"><strong class="jf hj">过滤器</strong>指定资源和度量。这也是我们指定的地方，例如，集群名、服务名或其他属性(如果需要的话)。</li><li id="8aa9" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lp lg lh li bi translated">我们使用<a class="ae kb" href="https://cloud.google.com/blog/products/management-tools/stackdriver-tips-and-tricks-understanding-metrics-and-building-charts" rel="noopener ugc nofollow" target="_blank">默认对齐器和sum reducer </a>来简单地合计请求，并根据destination_service_name指标标签对它们进行分组。</li></ul><h1 id="1554" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">错误率</h1><p id="4e67" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来，我们需要定义我们的错误率图表。定义如下:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lq"><img src="../Images/1af946585a32d06374d406e36965faee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZMj05sbHZk7JtH0hytF7A.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">错误率图表定义</figcaption></figure><p id="aa79" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">注意，这次我们使用了一个额外的过滤器，只对响应代码不是200的请求进行计数。否则，此定义与请求计数图表相同。</p><h1 id="9581" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">潜伏</h1><p id="8618" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，我们定义了延迟图表:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lr"><img src="../Images/dc48a6ca1a32c516d6a3ddff1ea3ecb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmZkbZa6HH9yNULbMWKQcg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">延迟图表定义</figcaption></figure><p id="a0c7" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">我们使用第99个百分位数的缩减器，只过滤成功的请求。</p><h1 id="7442" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">仪表盘</h1><p id="5866" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">是时候把它们放在一起了——这是完整的仪表板<a class="ae kb" href="https://gist.github.com/yuriatgoogle/c3b50c13f88b5fd776034f6879024533" rel="noopener ugc nofollow" target="_blank">定义</a>:</p><figure class="kd ke kf kg fd kh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bb0c" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">请注意，我们指定了一个4列gridLayout，这实际上会产生一个3列仪表板。我们还将每个图表指定为布局中的一个小部件。我们将此作为POST请求主体提交给<a class="ae kb" href="https://monitoring.googleapis.com/v1/{parent}/dashboards" rel="noopener ugc nofollow" target="_blank"><strong class="jf hj">https://monitoring . Google APIs . com/v3/projects/$ { PROJECT _ ID }/dashboard</strong></a><strong class="jf hj">s</strong>(根据<a class="ae kb" href="https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards/create" rel="noopener ugc nofollow" target="_blank">文档</a>)，并获得此仪表板作为结果:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kx"><img src="../Images/82f06bee83ff95fde363925992edde7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Y3IwJoAMMY6g1Sw"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">通过API调用创建的服务仪表板</figcaption></figure><p id="57e5" class="pw-post-body-paragraph jd je hi jf b jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw kw jy jz ka hb bi translated">瞧啊。我们现在有了一种在工作区中自动创建仪表板的方法！</p><h1 id="4680" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">总之…</h1><p id="bbf7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我希望您发现这很有用，并开始使用基于这个简单示例的API来创建和自动化您自己的仪表板。在我的下一篇文章中，我将重复这个练习，并创建一个仪表板来可视化运行服务的Kubernetes集群的健康状况。直到那时——感谢阅读！</p></div></div>    
</body>
</html>