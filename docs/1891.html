<html>
<head>
<title>Transforming Nested JSONs into an ARRAY of STRUCTs in BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在BigQuery中将嵌套JSONs转换为结构数组</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/transforming-nested-jsons-into-an-array-of-structs-in-bigquery-514988506384?source=collection_archive---------0-----------------------#2021-06-03">https://medium.com/google-cloud/transforming-nested-jsons-into-an-array-of-structs-in-bigquery-514988506384?source=collection_archive---------0-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e1c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，您的数据作为嵌套的JSON字符串存放在BigQuery中。一个例子可能是一个a列，其中每一项都有一个键，关于该项的详细信息如下所示。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="86db" class="jm jn hi ji b fi jo jp l jq jr">{<br/>   "item_1": {<br/>      "cost": 100,<br/>      "name": "My Product",<br/>      "category": "My Category"<br/>   },<br/>   "item_2": {<br/>      "cost": 150,<br/>      "name": "My Other Product",<br/>      "category": "My Other Category"<br/>   }<br/>}</span></pre><p id="40d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种格式在SQL中很难使用。让我们考虑一下每个项目类别的平均成本。为了提取嵌套值，我们需要知道我们索引的实际键。例如，如果我们想要获取item_1的成本，我们可以利用<a class="ae js" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions#json_extract" rel="noopener ugc nofollow" target="_blank"> JSON_EXTRACT_SCALAR </a>函数:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="88f8" class="jm jn hi ji b fi jo jp l jq jr">SELECT JSON_EXTRACT_SCALAR(items, '$.item_1.cost')<br/>FROM my_table</span></pre><p id="e31d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是要获取所有的类别和成本字段，我们需要知道每个条目的键，这可能很繁琐，甚至不合理，这取决于条目的数量。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="56a8" class="jm jn hi ji b fi jo jp l jq jr">SELECT category, AVG(cost) as average_cost<br/>FROM<br/>   (SELECT <br/>      JSON_EXTRACT_SCALAR(items, '$.item_1.category') as category,<br/>      JSON_EXTRACT_SCALAR(items, '$.item_1.cost') as cost,<br/>   FROM my_table<br/>   UNION ALL<br/>   SELECT <br/>      JSON_EXTRACT_SCALAR(items, '$.item_2.category') as category,<br/>      JSON_EXTRACT_SCALAR(items, '$.item_2.cost') as cost,<br/>   FROM my_table)<br/>GROUP BY 1</span></pre><p id="683a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们真正想要的是重构我们的数据，这样我们就有了一个由<a class="ae js" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#struct_type" rel="noopener ugc nofollow" target="_blank">结构</a>组成的<a class="ae js" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#array_type" rel="noopener ugc nofollow" target="_blank">数组</a>，而不是嵌套的JSONs。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7a4e" class="jm jn hi ji b fi jo jp l jq jr">[<br/>   {<br/>      "cost": 100,<br/>      "name": "My Product",<br/>      "category": "My Category"</span><span id="9ec5" class="jm jn hi ji b fi jt jp l jq jr">   },<br/>   {<br/>      "cost": 150,<br/>      "name": "My Other Product",<br/>      "category": "My Other Category"<br/>   }<br/>]</span></pre><p id="87b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数组代表一个重复的字段，这意味着列表中的每个对象都有点像表中自己的记录(或行)。当我们的数据被重组到一个数组中时，我们可以很容易地利用<a class="ae js" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays" rel="noopener ugc nofollow" target="_blank"> UNNEST </a>函数将每个对象分割成它自己的行——然后我们可以使用标准SQL查询它。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2906" class="jm jn hi ji b fi jo jp l jq jr">SELECT category, cost<br/>FROM my_table, UNNEST(items) </span></pre><p id="390a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有一些共同的命名结构，我们可以通过使用带正则表达式的<a class="ae js" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions#split" rel="noopener ugc nofollow" target="_blank"> SPLIT </a>函数将每个JSON项分解成数组中它自己的对象。但是这可能并不适用于所有的用例。</p><p id="5e69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更好的选择可能是使用用户定义的函数来遍历JSON中的每个键。下面我定义了一个临时的<a class="ae js" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions#javascript-udf-structure" rel="noopener ugc nofollow" target="_blank"> Javascript UDF </a>，它获取对象中的所有键(例如item_1，item_2)并遍历每个键来选择JSON并将其添加到一个数组中。</p><p id="7847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不想为嵌套结构定义模式，所以我实际上只是将输出作为字符串数组。但是，我们可以使用BigQuery的JSON函数来获取我们感兴趣的字段并进行聚合，就像字符串本身是一个结构一样！</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="19f3" class="jm jn hi ji b fi jo jp l jq jr">CREATE TEMP FUNCTION unnest_json(str STRING)<br/>RETURNS ARRAY&lt;STRING&gt;<br/>LANGUAGE js AS r"""<br/>  var obj = JSON.parse(str);<br/>  var keys = Object.keys(obj);<br/>  var arr = [];<br/>  for (i = 0; i &lt; keys.length; i++) {<br/>    arr.push(JSON.stringify(obj[keys[i]]));<br/>  }<br/>  return arr;<br/>""";</span><span id="0e4d" class="jm jn hi ji b fi jt jp l jq jr">SELECT <br/>JSON_EXTRACT_SCALAR(itms,'$.category') as category,  AVERAGE(JSON_EXTRACT_SCALAR(itms,'$.cost')) as cost from my_table, UNNEST(unnest_json(items)) as itms<br/>GROUP BY 1</span></pre><p id="8334" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多BigQuery内容，关注我LinkedIn和Twitter @leighajarett！</p></div></div>    
</body>
</html>