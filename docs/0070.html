<html>
<head>
<title>Deploying Django, Postgres,Redis Containers To Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Django、Postgres、Redis集装箱部署到Kubernetes</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploying-django-postgres-redis-containers-to-kubernetes-9ee28e7a146?source=collection_archive---------0-----------------------#2016-02-26">https://medium.com/google-cloud/deploying-django-postgres-redis-containers-to-kubernetes-9ee28e7a146?source=collection_archive---------0-----------------------#2016-02-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/bbeb02406748f89abc60c54ae6af10b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*4DjXG8OvzS4NWO9TGBXLiQ.png"/></div></figure><p id="d133" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Django是最受欢迎的开源web框架之一，可能没有哪个Django用户比Instagram更引人注目了，insta gram在他们的<a class="ae jk" href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances" rel="noopener ugc nofollow" target="_blank">博客帖子中深入介绍了他们如何设置Django堆栈的细节。</a>虽然他们使用了多种技术，但最突出的部分是Django、PostgreSQL和Redis。这一系列博客文章将详细介绍如何在<a class="ae jk" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>上部署整个堆栈，尽管第一篇文章将只关注Django部分。</p><p id="f4ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇博文基于我在Django旧金山会议上的一次演讲。你可以看看这个<a class="ae jk" href="https://speakerdeck.com/waprin/deploying-django-on-kubernetes" rel="noopener ugc nofollow" target="_blank">滑梯</a>或者<a class="ae jk" href="https://www.youtube.com/watch?v=HKKUgWuIZro" rel="noopener ugc nofollow" target="_blank">看讲座</a>。</p><h1 id="ecd5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">先决条件</h1><p id="4a8f" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">这将是一个由多个部分组成的教程，假设您已经对Django有所了解，并且已经将它连接到数据库和缓存。如果你以前没有用过Django，我首先推荐你阅读它的优秀教程<a class="ae jk" href="https://docs.djangoproject.com/en/1.9/intro/tutorial01/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="af8e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对容器有一些了解也是有帮助的，特别是<a class="ae jk" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，你需要首先安装它。如果你感到困惑，请参考Docker文档。Docker只在Linux上运行，但你可以通过运行Linux虚拟机在Mac或Windows上使用它。您使用Docker Machine与Linux机器进行交互，Docker Machine是标准Docker工具包的一部分。</p><p id="34c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本教程的所有代码可以在以下位置找到:</p><p id="649e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jk" href="https://github.com/waprin/kubernetes_django_postgres_redis" rel="noopener ugc nofollow" target="_blank">https://github.com/waprin/kubernetes_django_postgres_redis</a></p><p id="a761" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个repo是我目前在容器引擎上的全栈Django/Postgres/Redis的最佳尝试，但对于第一篇博客文章，我们将专注于设置容器引擎(Google Cloud上的Kubernetes)并在其中部署Django。我们现在跳过Redis和Postgres，只使用内存缓存SQLite。如果您想跳过本课，请阅读repo中的整个README.md，以获得关于部署整个项目的简单说明。</p><p id="7053" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您有任何问题，请使用<a class="ae jk" href="https://github.com/waprin/kubernetes_django_postgres_redis/issues" rel="noopener ugc nofollow" target="_blank"> Github问题跟踪器</a>。如果您有任何改进，请提交一个拉取请求。你也可以在<a class="ae jk" href="https://twitter.com/waprin_io" rel="noopener ugc nofollow" target="_blank">推特</a>上烦我。</p><h1 id="bb6f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">Kubernetes简介</h1><p id="960d" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">传统上，您可能会将Django部署到某种虚拟机实例中。缺点是，如果您想在同一台机器上安装其他应用程序，可能会出现库冲突。不拍摄机器映像也很难再现应用程序状态，因为机器映像往往不可移植且启动缓慢。</p><p id="fdf7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">容器，最常使用的是<a class="ae jk" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>格式，是产生不可变的、快速启动的、与其他应用程序隔离的应用程序映像的好方法。但是当您想要将一组容器部署到一个集群时，您会面临一系列挑战。</p><ul class=""><li id="df84" class="ko kp hi io b ip iq it iu ix kq jb kr jf ks jj kt ku kv kw bi translated">如何在机器上安排一个容器？</li><li id="700f" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">一个容器如何与另一个容器对话，即使它在不同的机器上？</li><li id="40fd" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">我在哪里存储我的数据和秘密？</li><li id="660c" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">我如何手动和自动缩放它？</li><li id="5221" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">我如何确保我的容器保持健康，并在出现故障时被替换？</li><li id="251b" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">我如何安全地部署新容器并回滚坏容器？</li><li id="0fe2" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated">我如何处理名称空间和授权？</li></ul><p id="21d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Kubernetes是由Google发起的一个完全开源的项目，旨在帮助解决这些问题。它提供了一个容器调度器和大量的特性，为在虚拟机或裸机集群上构建基于容器的平台提供了工具。</p><p id="1765" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Google Cloud提供了一个名为Container Engine的产品，它提供了一个完全托管的Kubernetes，因此您永远不必管理自己的Kubernetes集群。如果你喜欢自己处理所有的操作，你可以在谷歌计算引擎、亚马逊EC2、其他云VPS提供商或者你自己的硬件上运行Kubernetes。您甚至可以使用vagger在本地运行单节点集群。</p><p id="fb44" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">确保Kubernetes在各种平台上顺利运行是一项巨大的社区工作。幸运的是，Kubernetes有一个充满活力的社区，并且一直在寻找新的贡献者来帮助改进它。</p><h1 id="374d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">Kubernetes的核心概念</h1><p id="481c" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在开始部署Django之前，最好回顾一下Kubernetes的一些核心概念。</p><ul class=""><li id="5194" class="ko kp hi io b ip iq it iu ix kq jb kr jf ks jj kt ku kv kw bi translated"><strong class="io hj">节点</strong> —节点是运行组成集群的Docker容器的Linux机器。通常这些将是云VPS实例，尽管对于那些在本地运行Kubernetes的，它们可能是实际的机器。</li><li id="bd62" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj"> Pods </strong> —这是编排的基本单位。一个<strong class="io hj"> </strong>舱<strong class="io hj"> </strong>有一个或多个容器在里面运行。一个<strong class="io hj"> </strong> Pod <strong class="io hj"> </strong>可以有任意数量的标签，服务和复制控制器使用这些标签来匹配Pod。</li><li id="9a63" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj">复制控制器</strong> —复制控制器根据提供的标签控制给定<strong class="io hj"> </strong> Pod <strong class="io hj"> </strong>的数量。您可能正好需要1个或10个给定的Pod，复制控制器将监控您的<strong class="io hj"/>Pod，并在出现故障时启动新的Pod。您可以手动或自动放大或缩小这些。</li><li id="81c8" class="ko kp hi io b ip kx it ky ix kz jb la jf lb jj kt ku kv kw bi translated"><strong class="io hj">服务</strong> —服务是一个Pod如何与另一个Pod对话，即使它们在不同的节点上。一项服务在Kubernetes创建的虚拟专用网络(10.0.0.0/8)上提供一个IP，该IP将循环到与给定的<strong class="io hj">标签匹配的不同<strong class="io hj"> Pods </strong>。</strong>可以使用环境变量或推荐的Kube-DNS插件来发现服务的IP。</li></ul><h1 id="1804" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤1:在本地运行应用程序</h1><p id="8871" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">首先，您需要设置一个Python开发环境。按照这些说明在<a class="ae jk" href="http://docs.python-guide.org/en/latest/starting/install/osx/" rel="noopener ugc nofollow" target="_blank"> OS X </a>、<a class="ae jk" href="http://docs.python-guide.org/en/latest/starting/install/linux/" rel="noopener ugc nofollow" target="_blank"> Linux </a>或<a class="ae jk" href="http://docs.python-guide.org/en/latest/starting/install/win/" rel="noopener ugc nofollow" target="_blank"> Windows </a>上进行设置。</p><p id="8dcb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我也是<a class="ae jk" href="https://virtualenvwrapper.readthedocs.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> virtualenvwrappers </a>的忠实粉丝，用一些漂亮的别名来创建一个virtualenv。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="eead" class="ll jm hi lh b fi lm ln l lo lp">$ mkvirtualenv guestbook<br/>$ git clone <a class="ae jk" href="https://github.com/waprin/kubernetes_django_postgres_redis" rel="noopener ugc nofollow" target="_blank">https://github.com/waprin/kubernetes_django_postgres_redis</a><br/>$ cd guestbook<br/>$ pip install -r requirements.txt</span></pre><p id="f6c6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Django应用程序已经配置为接受一个环境变量，该变量将指定我们是否要连接到一个名为NODB的真实数据库和缓存。在后面的帖子中，我们将禁用NODB，并与Postgers和Redis交谈，但现在，让我们保持简单。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e8b2" class="ll jm hi lh b fi lm ln l lo lp">$ export NODB=1</span></pre><p id="2f0c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以使用Django开发服务器来看看这个应用在本地工作站上的样子</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0bad" class="ll jm hi lh b fi lm ln l lo lp">$ python manage.py runserver</span></pre><p id="1f0d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以查看该应用程序，并在您的web浏览器中点击链接，发表一些留言簿帖子:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3758" class="ll jm hi lh b fi lm ln l lo lp"><a class="ae jk" href="http://locahost:8000" rel="noopener ugc nofollow" target="_blank">http://locahost:8000</a></span></pre><p id="e20f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该看到:</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/20bdd831213efbf8ebd01d126b0cb413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8ZolaNOQuzihkbo7pJrxQ.png"/></div></div></figure><p id="1b3d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您看到关于缺少表或无法连接到数据库的错误，您可能没有将NODB=1正确导出到您的环境中。</p><h1 id="b864" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤2:创建容器</h1><p id="a32b" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">要将我们的应用程序部署到Kubernetes，第一步是制作一个Docker映像进行部署。</p><p id="63ff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们有一个典型的Django应用程序，它由一个包含项目目录的根目录和项目中每个应用程序的目录组成。</p><p id="8e74" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要一个服务器来服务我们的Django应用程序，不建议将由“python manage.py runserver”创建的本地开发服务器用于生产。我们可以使用任何可以通过WSGI与Django对话的服务器，包括Apache，但是在这种情况下，我们将使用Gunicorn，它是服务Django应用程序的流行选择。</p><p id="dd56" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从Ubuntu这样的简单Linux发行版开始，我们需要使用apt-get安装几个Python依赖项和几个Python依赖项，比如pip。</p><p id="7745" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于初始设置，我的docker文件扩展了一个基本映像来完成这个任务。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="12e3" class="ll jm hi lh b fi lm ln l lo lp"><strong class="lh hj"><em class="lv"># </em></strong><a class="ae jk" href="https://github.com/GoogleCloudPlatform/python-docker" rel="noopener ugc nofollow" target="_blank"><strong class="lh hj"><em class="lv">https://github.com/GoogleCloudPlatform/python-docker</em></strong></a><strong class="lh hj"><em class="lv"><br/></em>FROM </strong>gcr.io<strong class="lh hj">/</strong>google_appengine<strong class="lh hj">/</strong>python</span></pre><p id="d378" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">尽管名字如此，这个基本Dockerfile文件并不特定于App Engine。你可以点击链接查看到底安装了什么。</p><p id="4b9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还需要安装我们的应用程序需要的任何依赖项，最简单的方法是在我们的容器中实际创建一个virtualenv，并运行一个“pip install ”,作为Docker构建步骤的一部分。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="bd08" class="ll jm hi lh b fi lm ln l lo lp"><strong class="lh hj"><em class="lv"># Create a virtualenv for the application dependencies.<br/># If you want to use Python 3, add the -p python3.4 flag.<br/></em>RUN </strong>virtualenv <strong class="lh hj">/</strong>env<br/><br/><strong class="lh hj"><em class="lv"># Set virtualenv environment variables. This is equivalent to running<br/># source /env/bin/activate. This ensures the application is executed within<br/># the context of the virtualenv and will have access to its dependencies.<br/></em>ENV </strong>VIRTUAL_ENV <strong class="lh hj">/</strong>env<br/><strong class="lh hj">ENV </strong>PATH <strong class="lh hj">/</strong>env<strong class="lh hj">/</strong>bin:$PATH<br/><br/><strong class="lh hj"><em class="lv"># Install dependencies.<br/></em>ADD </strong>requirements.txt <strong class="lh hj">/</strong>app<strong class="lh hj">/</strong>requirements.txt<br/><strong class="lh hj">RUN </strong>pip install <strong class="lh hj">-</strong>r <strong class="lh hj">/</strong>app<strong class="lh hj">/</strong>requirements.txt</span></pre><p id="f09d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您会注意到，由于我们部署的应用程序没有数据库，我们启用了NODB环境变量。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="4921" class="ll jm hi lh b fi lm ln l lo lp"><strong class="lh hj">ENV </strong>NODB 1</span></pre><p id="5096" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我们添加代码并启动Gunicorn:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2f38" class="ll jm hi lh b fi lm ln l lo lp"><strong class="lh hj">CMD </strong>export DJANGO_PASSWORD=$(cat <strong class="lh hj">/</strong>etc<strong class="lh hj">/</strong>secrets<strong class="lh hj">/</strong>djangouserpw); gunicorn <strong class="lh hj">-</strong>b :$PORT mysite.wsgi</span></pre><p id="c743" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在您可以忽略这些秘密，因为这是为了向数据库进行身份验证，设置NODB标志将避免这种需要。</p><p id="88c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要构建映像，您需要进行docker构建。在OS X，我首先确保我创建了一个VirtualBox机器:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="40a2" class="ll jm hi lh b fi lm ln l lo lp">$ docker-machine <strong class="lh hj">create --</strong><em class="lv">driver virtualbox default</em></span></pre><p id="adfe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我启动它，并确保创建它的环境变量已经初始化:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="28b1" class="ll jm hi lh b fi lm ln l lo lp">$ docker-machine start dev<br/>$ eval $(docker-machine env dev)</span></pre><p id="ea18" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我构建了我的图像，并对其进行了适当的标记</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ea74" class="ll jm hi lh b fi lm ln l lo lp">$ docker build -t waprin/my-guestbook-app .</span></pre><p id="c4dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我可以在本地运行我的映像:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7fff" class="ll jm hi lh b fi lm ln l lo lp">$ docker run -p 8080:8080 waprin/my-guestbook-app</span></pre><p id="b602" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我通过运行以下命令获得Docker主机的IP地址:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8698" class="ll jm hi lh b fi lm ln l lo lp">$ docker-machine ip</span></pre><p id="724f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，通过访问该IP，我可以看到我的应用程序</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1c52" class="ll jm hi lh b fi lm ln l lo lp"><a class="ae jk" href="http://192.168.99.100:" rel="noopener ugc nofollow" target="_blank">http://192.168.99.100</a>:8080</span></pre><h1 id="f4d3" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤3:创建Kubernetes集群</h1><p id="d828" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">对于本教程，我们将使用Google的托管Kubernetes服务，称为容器引擎。或者，你可以自己在谷歌计算引擎或其他云提供商如亚马逊网络服务上运行Kubernetes。容器引擎的优点是Google为您管理您的Kubernetes主服务器，大大简化了Kubernetes集群的操作。</p><p id="7150" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，你需要创建一个谷歌云账户，并使用<a class="ae jk" href="https://console.developers.google.com" rel="noopener ugc nofollow" target="_blank">云控制台</a>创建一个新项目。如果你是谷歌云的新手，你可以注册3个月300美元的免费试用。一旦您有了一个帐户，创建一个新的项目并记下项目ID，它有时但不总是与您给项目起的名字相同。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lw"><img src="../Images/c1bf29b3c32f5a726ff631963106a992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-qwfNpG2hAIT8SKHnBTUQ.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">这里kube-django-prac是项目的名称，也是项目ID</figcaption></figure><p id="5886" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Container Engine将为您创建Google Compute Engine实例，您将为这些实例的使用付费</p><p id="0a21" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然你可以从<a class="ae jk" href="https://console.developers.google.com" rel="noopener ugc nofollow" target="_blank">云控制台</a>创建一个容器引擎集群，但我更喜欢你使用<a class="ae jk" href="https://cloud.google.com/sdk/gcloud/" rel="noopener ugc nofollow" target="_blank"> gcloud命令行工具</a>。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c3ca" class="ll jm hi lh b fi lm ln l lo lp">gcloud components update # make sure it’s up to date<br/>gcloud config set project &lt;project-id&gt;</span><span id="6834" class="ll jm hi lh b fi mb ln l lo lp"># Create the cluster with 2 nodes<br/>gcloud container clusters create guestbook --scopes "https://www.googleapis.com/auth/userinfo.email","cloud-platform" --num-nodes 2 </span><span id="0498" class="ll jm hi lh b fi mb ln l lo lp"># Configure kubectl with the right context<br/>gcloud container clusters get-credentials guestbook</span></pre><p id="e9b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们创建了两个节点。请注意，对于Container Engine，您将为您正在创建的实例付费(但对于最多5个节点，没有额外费用)。</p><p id="3125" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完成本教程后，为了避免重复收费，请删除实例。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5544" class="ll jm hi lh b fi lm ln l lo lp"># Only run this when you're done the tutorial<br/>gcloud container clusters delete guestbook</span></pre><p id="1a45" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与Kubernetes集群交互的主要CLI将是kubectl。一开始，唯一存在的服务应该是Kubernetes，你不应该有任何pod。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="21dd" class="ll jm hi lh b fi lm ln l lo lp">$ kubectl get services</span><span id="38f1" class="ll jm hi lh b fi mb ln l lo lp">$ kubectl get pods</span></pre><h1 id="f6c8" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">步骤4:将我们的应用程序部署到Kubernetes</h1><p id="d4f4" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">现在我们有了一个应用程序容器和一个Kubernetes集群。</p><p id="d4d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，回到repo的根目录，将cd放入“kubernetes_config ”,其中包含所有不同的kubernetes配置。现在，我们将关注frontend.yaml，它代表我们的Django控制器。</p><p id="ab8e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们正在创建一个复制控制器，它将创建许多运行我们之前创建的映像的pod。我们指定启动3个副本，这意味着如果任何容器死亡，我们的复制控制器将用一个新的容器替换它。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6efb" class="ll jm hi lh b fi lm ln l lo lp"><em class="lv"><br/></em><strong class="lh hj">apiVersion: </strong>v1<br/><strong class="lh hj">kind: </strong>ReplicationController<br/><strong class="lh hj">metadata:<br/>  name: </strong>frontend<br/>  <strong class="lh hj">labels:<br/>    name: </strong>frontend<br/><strong class="lh hj">spec:<br/>  replicas: </strong>3<br/>  <strong class="lh hj">template:<br/>    metadata:<br/>      labels:<br/>        name: </strong>frontend<br/>    <strong class="lh hj">spec:<br/>      containers:<br/>      </strong>- <strong class="lh hj">name: </strong>guestbook<br/>        <em class="lv"># Replace  with your project ID or use `make template`<br/>        </em><strong class="lh hj">image: </strong>waprin/my-guestbook-app <br/><br/>        <em class="lv"># This setting makes nodes pull the docker image every time before<br/>        # starting the pod. This is useful when debugging, but should be turned<br/>        # off in production.<br/>        </em><strong class="lh hj">imagePullPolicy: </strong>Always<br/>        <strong class="lh hj">ports:<br/>        </strong>- <strong class="lh hj">containerPort: </strong>8080</span></pre><p id="e02a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们要做的第一个改变是使用我们之前创建的图像。在回购协议中，我使用:gcr.io/$GCLOUD_PROJECT/guestbook,，因为我将我的图像推送到谷歌容器注册表，它类似于公共Docker注册表，但在你的谷歌项目中是私有的，以防你想对你的图像保密。无论如何，让我们用我之前创建的图像替换它:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c223" class="ll jm hi lh b fi lm ln l lo lp"># replace with the image you tagged earlier<br/>$ docker push waprin/my-guestbook-app</span></pre><p id="f95f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后在frontend.yaml</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="792b" class="ll jm hi lh b fi lm ln l lo lp"># Replace with your image id in frontend.yaml<br/>image: waprin/my-guestbook-app</span></pre><p id="1dfa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">创建复制控制器后，我们可以自动或手动扩展它。自动缩放是一个测试特性，我将在本系列的后续文章中演示，但手动缩放将非常简单:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3101" class="ll jm hi lh b fi lm ln l lo lp">$ kubectl scale rc frontend --replicas=3</span></pre><p id="9246" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，您会注意到我们正在创建一项服务。由于我们希望向外部流量公开我们的web应用程序(与我们的数据库不同，我们的缓存服务将在后面介绍)，我们使用LoadBalancer类型为HTTP负载平衡器提供外部IP。这假设你的云提供商支持外部负载平衡器，谷歌和亚马逊都支持。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b4eb" class="ll jm hi lh b fi lm ln l lo lp"><strong class="lh hj">apiVersion: </strong>v1<br/><strong class="lh hj">kind: </strong>Service<br/><strong class="lh hj">metadata:<br/>  name: </strong>frontend<br/>  <strong class="lh hj">labels:<br/>    name: </strong>frontend<br/><strong class="lh hj">spec:<br/>  type: </strong>LoadBalancer<br/>  <strong class="lh hj">ports:<br/>  </strong>- <strong class="lh hj">port: </strong>80<br/>    <strong class="lh hj">targetPort: </strong>8080<br/>  <strong class="lh hj">selector:<br/>    name: </strong>frontend</span></pre><p id="05ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将image属性替换为推送的Docker映像后，让我们创建服务和复制控制器:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e6ea" class="ll jm hi lh b fi lm ln l lo lp">$ kubectl create -f kubernetes_configs/frontend.yaml</span></pre><p id="2e3d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">负载平衡器和外部IP可能需要几分钟的时间来配置。完成后，当你跑的时候</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8e3d" class="ll jm hi lh b fi lm ln l lo lp">$ kubectl get services</span></pre><p id="69eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您应该会看到类似这样的内容:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8c2c" class="ll jm hi lh b fi lm ln l lo lp">$ kubectl get services</span><span id="58b5" class="ll jm hi lh b fi mb ln l lo lp">NAME CLUSTER_IP EXTERNAL_IP PORT(S) SELECTOR AGE</span><span id="3f1f" class="ll jm hi lh b fi mb ln l lo lp">frontend 10.67.240.157 104.197.69.33 80/TCP name=frontend 1m</span><span id="11ba" class="ll jm hi lh b fi mb ln l lo lp">kubernetes 10.67.240.1 &lt;none&gt; 443/TCP &lt;none&gt; 10m</span></pre><p id="69b8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在您的web浏览器中访问外部IP应该访问您部署在云中的应用程序！</p><p id="c63c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，由于我们的应用程序控制器的每个实例都有自己版本的SQLite数据库和内存缓存，所以直到我们在下一篇文章中添加Postgres和Redis，应用程序才会正常运行。</p><h1 id="a8e1" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">包扎</h1><p id="af66" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">请注意，虽然我为谷歌云工作，但这不是谷歌的官方产品或公司声明。</p><p id="04f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你在学习本教程的过程中有任何问题，请联系我的Github追踪器或T2推特。下一篇文章将会通过Postgres和Redis，希望你能跟上！</p></div></div>    
</body>
</html>