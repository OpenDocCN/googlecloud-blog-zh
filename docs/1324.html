<html>
<head>
<title>Knative Eventing Delivery Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">失败的事件交付方法</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/knative-eventing-delivery-methods-79d4ebe30a68?source=collection_archive---------1-----------------------#2020-03-12">https://medium.com/google-cloud/knative-eventing-delivery-methods-79d4ebe30a68?source=collection_archive---------1-----------------------#2020-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="296b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当谈到它支持的不同事件交付方法时，Knative Eventing <a class="ae jd" href="https://knative.dev/docs/eventing/" rel="noopener ugc nofollow" target="_blank"> docs </a>有点令人困惑。它谈到了<strong class="ih hj">事件代理和触发器</strong>和<strong class="ih hj">T5，还谈到了<strong class="ih hj">源</strong>、<strong class="ih hj">服务</strong>、<strong class="ih hj">频道</strong>和<strong class="ih hj">订阅</strong>。用什么，什么时候用？不清楚。我们来分解一下。</strong></p><h2 id="d10e" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">交付方式</h2><p id="819b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">Knative有3种不同的方法:</p><ol class=""><li id="7482" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">简单交付</li><li id="47c7" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">具有可选回复的复杂交付</li><li id="afcd" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">代理和触发交付</li></ol><p id="1501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代理和触发器交付是你大部分时间应该关心的事情</strong>。然而，简单和复杂的交付已经流行了一段时间，仍然很好地了解了幕后发生的事情。</p><h2 id="f1a8" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">简单交付</h2><p id="6acf" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在简单交付中，事件源直接向服务发送消息。现在是1:1，完全没有交付保证:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/937b31df12cae0599c39d6c0290a5ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sPgdLEwFGfczX63ITV3Pw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">简单交付，源直接向服务发送事件</figcaption></figure><p id="06d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，下面是一个CronJobSource，它根据给定的cron时间表触发事件，将消息直接发送到Knative服务:</p><pre class="kt ku kv kw fd li lj lk ll aw lm bi"><span id="463f" class="je jf hi lj b fi ln lo l lp lq">apiVersion: sources.eventing.knative.dev/v1alpha1<br/>kind: CronJobSource<br/>metadata:<br/>  name: source<br/>spec:<br/>  schedule: "* * * * *"<br/>  data: '{"message": "Hello world from cron!"}'<br/>  sink:<br/>    apiVersion: serving.knative.dev/v1<br/>    kind: Service<br/>    name: service</span></pre><p id="581a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在我的Knative教程中看到完整的简单交付示例。</p><h2 id="eb0c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">复杂交付</h2><p id="b21f" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">复杂交付允许使用<strong class="ih hj">通道</strong>和1:n扇出<strong class="ih hj">订阅的交付保证。</strong></p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lr"><img src="../Images/fb16d875df8e155252a2952c583dc3cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*249mT9Xfq2vX3LdkADEEEw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">1:n扇出的复杂传输</figcaption></figure><p id="17a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">源向通道发送消息。它可以是内存通道，也可以是更持久的通道，如Kafka通道:</p><pre class="kt ku kv kw fd li lj lk ll aw lm bi"><span id="4149" class="je jf hi lj b fi ln lo l lp lq">apiVersion: sources.eventing.knative.dev/v1alpha1<br/>kind: CronJobSource<br/>metadata:<br/>  name: source<br/>spec:<br/>  schedule: "* * * * *"<br/>  data: '{"message": "Hello world from cron!"}'<br/>  sink:<br/>    apiVersion: messaging.knative.dev/v1alpha1<br/>    kind: InMemoryChannel<br/>    name: channel</span></pre><p id="b5f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，服务通过订阅连接到频道:</p><pre class="kt ku kv kw fd li lj lk ll aw lm bi"><span id="a3ed" class="je jf hi lj b fi ln lo l lp lq">apiVersion: messaging.knative.dev/v1alpha1<br/>kind: Subscription<br/>metadata:<br/>  name: subscription1<br/>spec:<br/>  channel:<br/>    apiVersion: messaging.knative.dev/v1alpha1<br/>    kind: InMemoryChannel<br/>    name: channel<br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1<br/>      kind: Service<br/>      name: service1</span></pre><p id="aae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复杂交付还允许服务用其他事件来回复事件:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ls"><img src="../Images/7e608362c038a3e86fd426b19e3fee63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZ74LSRen6wJrsj1UnQ2eA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">复杂交付，其中Service2用另一个事件回复一个事件</figcaption></figure><p id="ab45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，服务2用另一个事件回复传入事件，并通过另一个通道和订阅路由到服务3。回复被定义为订阅的一部分:</p><pre class="kt ku kv kw fd li lj lk ll aw lm bi"><span id="57c3" class="je jf hi lj b fi ln lo l lp lq">apiVersion: messaging.knative.dev/v1alpha1<br/>kind: Subscription<br/>metadata:<br/>  name: subscription2<br/>spec:<br/>  channel:<br/>    apiVersion: messaging.knative.dev/v1alpha1<br/>    kind: InMemoryChannel<br/>    name: channel1<br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1<br/>      kind: Service<br/>      name: service2<br/>  reply:<br/>    ref:<br/>      apiVersion: messaging.knative.dev/v1alpha1<br/>      kind: InMemoryChannel<br/>      name: channel2</span></pre><p id="1ed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在我的Knative教程中看到完整的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/complexdelivery.md" rel="noopener ugc nofollow" target="_blank">复杂交付示例</a>和<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/complexdeliverywithreply.md" rel="noopener ugc nofollow" target="_blank">带回复的复杂交付示例</a>。</p><h2 id="2a88" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">代理和触发交付</h2><p id="b82c" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">复杂的交付模式可行，但很难维持多个渠道、订阅和回复。它也没有过滤的概念，所以服务必须自己过滤所有的消息。</p><p id="005d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个更简单的模型是代理和触发器。Broker将通道、回复和过滤功能组合到一个资源中。触发器提供所有事件的声明性过滤。</p><p id="90af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个方法中，前面的例子变成了这样:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lt"><img src="../Images/99c653c0a382710b953cd250351aa0b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jflhzY16gQ5zi_zjZPV9uw.png"/></div></div></figure><p id="8c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代理被注入到服务和源的名称空间中。源向代理发送事件:</p><pre class="kt ku kv kw fd li lj lk ll aw lm bi"><span id="89e0" class="je jf hi lj b fi ln lo l lp lq">apiVersion: sources.eventing.knative.dev/v1alpha1<br/>kind: CronJobSource<br/>metadata:<br/>  name: source<br/>spec:<br/>  schedule: "* * * * *"<br/>  data: '{"message": "Hello world from cron!"}'<br/>  sink:<br/>    apiVersion: eventing.knative.dev/v1alpha1<br/>    kind: Broker<br/>    name: default</span></pre><p id="17bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经纪人有渠道做后盾。服务通过触发器注册对特定事件类型的兴趣:</p><pre class="kt ku kv kw fd li lj lk ll aw lm bi"><span id="3a6f" class="je jf hi lj b fi ln lo l lp lq">apiVersion: eventing.knative.dev/v1alpha1<br/>kind: Trigger<br/>metadata:<br/>  name: trigger1<br/>spec:<br/>  filter:<br/>    attributes:<br/>      type: dev.knative.cronjob.event<br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1<br/>      kind: Service<br/>      name: service1</span></pre><p id="5752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在幕后，trigger创建订阅。任何服务都可以回复传入的事件。通过对该类型事件感兴趣的代理和服务路由回的回复事件获得该事件:</p><pre class="kt ku kv kw fd li lj lk ll aw lm bi"><span id="0d7e" class="je jf hi lj b fi ln lo l lp lq">apiVersion: eventing.knative.dev/v1alpha1<br/>kind: Trigger<br/>metadata:<br/>  name: trigger3<br/>spec:<br/>  filter:<br/>    attributes:<br/>      type: dev.knative.samples.hifromknative<br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1<br/>      kind: Service<br/>      name: service3</span></pre><p id="5af7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在我的Knative教程中看到完整的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/brokertrigger.md" rel="noopener ugc nofollow" target="_blank">代理和触发器交付示例</a>。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="38e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我之前提到的，你通常只关心Knative Eventing中的Broker和Trigger，但我希望这篇文章澄清不同的交付方法以及在coverrs下会发生什么。</p><p id="e28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一如既往，如果你有任何问题，请随时在<a class="ae jd" href="https://twitter.com/meteatamel" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我！</p></div></div>    
</body>
</html>