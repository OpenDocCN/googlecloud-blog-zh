<html>
<head>
<title>Introduction to Stackdriver Distributed Tracing (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Stackdriver分布式跟踪简介(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/introduction-to-stackdriver-distributed-tracing-part-1-91ce73abb298?source=collection_archive---------0-----------------------#2018-04-10">https://medium.com/google-cloud/introduction-to-stackdriver-distributed-tracing-part-1-91ce73abb298?source=collection_archive---------0-----------------------#2018-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="46fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据我的经验，在GCP上开发应用和服务的人都非常清楚Stackdriver在<a class="ae jd" href="https://cloud.google.com/monitoring/docs/" rel="noopener ugc nofollow" target="_blank">监控</a>(也就是说，收集时间序列指标用于仪表板和警报)和<a class="ae jd" href="https://cloud.google.com/logging/docs/" rel="noopener ugc nofollow" target="_blank">日志</a>方面的能力。然而，我也注意到Stackdriver更多的以开发人员为中心的特性，如跟踪、错误报告和追踪，并不广为人知！这些都是非常强大的工具！我想感受一下使用它们的真实感受，我想我会从<a class="ae jd" href="https://cloud.google.com/trace/" rel="noopener ugc nofollow" target="_blank"> Trace </a>开始。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/8d34f3abed337a4d7ef8584610870ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oj3-iS0406_9plPG_3flzQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">使用gRPC跟踪</figcaption></figure><p id="756d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我以前使用过Trace，但是我想在这个特定的练习中添加一些东西，并实现对gRPC调用的跟踪。为了做到这一点…我需要学习如何使用gRPC(这是很好的cromulent用法)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">安比根斯！</figcaption></figure><p id="9769" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我要同时处理两个新的主题，所以我决定呆在自己的舒适区(至少对于第1部分来说)并在Node.js中完成这个练习。我在Go中做这个的尝试并不顺利，因为我很快就失去了$GOPATH和$GOHOME的踪迹，到处都安装了包，并且无法得到任何可以实际编译的东西。这是一个我以后可能会尝试重新审视的项目…</p><p id="d234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，回到我们的话题。为了让分布式跟踪跨gRPC调用工作，我需要做三件事:</p><ol class=""><li id="ee61" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">创建能够响应gRPC调用的东西(服务器)</li><li id="19b6" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">创建一些能够进行gRPC调用并响应用户请求的东西(客户端)</li><li id="c388" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">向这两者添加跟踪工具。</li><li id="4c21" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">利润…？</li></ol><p id="6f6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，gRPC背后的好人在他们的网站上维护了非常有用的<a class="ae jd" href="https://grpc.io/docs/quickstart/node.html" rel="noopener ugc nofollow" target="_blank"> Quickstart </a>文档，这是我完成#1和#2的依据。可以看到完成的(？)导致这个GitHub <a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing" rel="noopener ugc nofollow" target="_blank"> repo </a>，但是让我们走一遍练习。</p><p id="6ba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1 — gRPC服务器</strong></p><p id="5bc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器在单个中实现。js <a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing/blob/master/greeter_server.js" rel="noopener ugc nofollow" target="_blank">文件</a>，它只是Hello World的gRPC等价物。它的主要功能有两部分:</p><p id="641c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a.充当服务器的主要功能:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kk jv l"/></div></figure><p id="693c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b.sayHello()函数创建从服务器返回给客户机的消息。<strong class="ih hj">注意</strong>我添加了一个睡眠调用，所以gRPC调用会有一些真正的延迟，但这对我们的目的来说是完全不必要的。在一个真正的微服务架构中，这将是实际服务逻辑驻留的地方(或者至少是我放它的地方…).</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kk jv l"/></div></figure><p id="3893" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里看到整个文件<a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing/blob/master/greeter_server.js" rel="noopener ugc nofollow" target="_blank">。我们现在可以用<code class="du kl km kn ko b">node greeter_server.js</code>启动gRPC服务器，它将准备好让我们对它进行gRPC调用！让我们现在做那件事。</a></p><p id="7417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2 — gRPC客户端</strong></p><p id="3cfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing/blob/master/node-tracing.js" rel="noopener ugc nofollow" target="_blank">这里的</a>是整个文件——客户端和web服务器也被实现为一个单独的文件。js文件使用Express(因为我就知道这些)。这种方法非常简单:</p><p id="8726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a.定义基本路由/请求处理(使用Express):</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kk jv l"/></div></figure><p id="31b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b.设置gRPC客户端和用户属性，我们将使用它们来发出请求:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kk jv l"/></div></figure><p id="1619" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们只是进行了一个本地主机调用——如果gRPC要访问位于我们部署中其他位置的服务，我们将在这里提供该服务的地址。这部分练习的一个可能的后续工作是分别部署服务器和“客户机”,也许是作为GKE集群中的单独部署。</p><p id="2204" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c.发出gRPC请求并处理响应:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kk jv l"/></div></figure><p id="9885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里添加了一个非常基本的错误处理程序。如果gRPC请求成功，我们只需使用<code class="du kl km kn ko b">res.send</code>将消息发送到web接口，然后继续。</p><p id="8f1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！然后我们可以使用<code class="du kl km kn ko b">node node-tracing.js</code>(当然是在<code class="du kl km kn ko b">npm install --save</code>之后)运行这部分练习，我们开始运行。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kp"><img src="../Images/41e67814493defa7d39d48cf0c7d29eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*sh0NR8m6uTCZJEt89epDxA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">它既简单又美丽</figcaption></figure><p id="9755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3 —跟踪仪器</strong></p><p id="f354" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的应用程序已经运行了，让我们实际添加我们需要的跟踪工具来观察延迟。再次—有几个(简单！)所需的步骤。</p><p id="aa45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a.将<strong class="ih hj">代理代码</strong>添加到“<a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing/blob/master/greeter_server.js" rel="noopener ugc nofollow" target="_blank">服务器</a>和“<a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing/blob/master/node-tracing.js" rel="noopener ugc nofollow" target="_blank">客户端</a>文件中</p><p id="ccfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这方面的说明非常简单。只需遵循跟踪文档中的<a class="ae jd" href="https://cloud.google.com/trace/docs/setup/nodejs" rel="noopener ugc nofollow" target="_blank">步骤</a>。我们将简单地将代理代码添加到两个文件中——在每个文件的最开始。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kk jv l"/></div></figure><p id="595c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，您将需要指定GCP项目ID(如果您的代码不在GCP运行),以告诉代理将跟踪信息发送到哪里。</p><p id="4702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b.安装必要的<strong class="ih hj">包</strong>。</p><p id="7897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在代码中添加代理后，您还需要使用<code class="du kl km kn ko b">npm install --save @google-cloud/trace-agent.</code>安装代理。如果您从GitHub repo运行代码，使用<code class="du kl km kn ko b">npm install --save</code>安装其余的<a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">包</a>。</p><p id="6e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c.<strong class="ih hj">开始</strong>一切！</p><p id="848e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个练习，我在本地运行所有的东西，所以我需要在命令行使用<code class="du kl km kn ko b">gcloud auth application-default login</code>指定项目ID并获取应用程序默认凭证，然后在单独的终端窗口/选项卡中使用<code class="du kl km kn ko b">node greeter-server.js</code>和<code class="du kl km kn ko b">node node-tracing.js</code>启动服务器和客户端。</p><p id="3d04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4 —看痕迹！</strong></p><p id="9d29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦一切都启动并运行，您应该能够多次重新加载您的页面以创建一些跟踪。然后，转到Stackdriver跟踪屏幕。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kq"><img src="../Images/3530e9957643503f1c74c03279b608ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*dgAvd7AcZKuGWUZKYm57og.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">只需搜索痕迹！</figcaption></figure><p id="0bab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切都做得正确，您应该看到初始屏幕开始填充一些痕迹！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kr"><img src="../Images/179b361244bd3d960831c0e01ea33927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Dk3IfRm1v5hPPj_H4HSjQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">起作用了！</figcaption></figure><p id="fe6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单击左侧菜单中的第二个选项，转到跟踪列表。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kr"><img src="../Images/f306d925b1b47d00be6735d43cc36085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lNXR-3p37ce7Zj9CzBO_w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">跟踪列表！</figcaption></figure><p id="0094" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以按照<a class="ae jd" href="https://cloud.google.com/trace/docs/trace-overview" rel="noopener ugc nofollow" target="_blank">文档</a>中的说明来全面学习如何使用Trace，但是我在这里只强调要点。单击时间线中的一个条目来选择一个轨迹。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ks"><img src="../Images/45be9122d7db0832107cb7694c300bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5x77v6aire2MSsI7m8Euvw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">跟踪详细信息。</figcaption></figure><p id="07c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到，您获得了整个端到端流程的延迟，以及gRPC调用所导致的延迟的组成部分。因为我们的调用存在人为延迟，所以整个时间都花在等待gRPC响应上。如果您点击调用本身，您实际上可以看到完整的调用堆栈！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kt"><img src="../Images/e499f9c073cbf4c4fecb74baadfec18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*oUGjBkzBmD2vfOT8hWbrKQ.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">等待SayHello函数运行！</figcaption></figure><p id="e01e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您还记得的话，就是我们的“服务器”文件中的SayHello函数添加了延迟。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kk jv l"/></div></figure><p id="935b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多酷啊。我们可以使用Trace来找出代码中慢的部分在哪里！当试图确定应用程序中性能问题的根本原因时，这非常有帮助。</p><p id="b09f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在Node.js中将Stackdriver Trace与gRPC结合使用的练习到此结束。我将回到这个主题，并尝试不使用代理#sobrave来完成它—敬请关注。</p><p id="6410" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">资源</strong></p><p id="260c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个的灵感:<a class="ae jd" href="https://cloudplatform.googleblog.com/2017/04/distributed-tracing-for-Go.html?m=1" rel="noopener ugc nofollow" target="_blank">https://cloud platform . Google blog . com/2017/04/distributed-tracing-for-go . html？m=1 </a></p><p id="5310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈驱动跟踪文档:【https://cloud.google.com/trace/docs/ T2】</p><p id="69b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Node.js中的gRPC基础:【https://grpc.io/docs/quickstart/node.html T4】</p><p id="e3a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该项目的GitHub回购:<a class="ae jd" href="https://github.com/yuriatgoogle/node-tracing" rel="noopener ugc nofollow" target="_blank">https://github.com/yuriatgoogle/node-tracing</a></p></div></div>    
</body>
</html>