<html>
<head>
<title>Writing efficient queries for
Cloud Spanner interleaved tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为云扳手交叉表编写高效查询</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/writing-efficient-queries-for-cloud-spanner-interleaved-tables-44745e8f913e?source=collection_archive---------0-----------------------#2021-05-17">https://medium.com/google-cloud/writing-efficient-queries-for-cloud-spanner-interleaved-tables-44745e8f913e?source=collection_archive---------0-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ba52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们讨论如何为云扳手交叉表编写高效的查询。</p><h1 id="accd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a9e2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">您可以编写一个查询，用<code class="du kg kh ki kj b">SELECT AS STRUCT</code>子查询一次从父表和交叉表中选择行。这允许您高效地运行查询，同时在Cloud Spanner数据库上消耗较少的CPU资源。</p><h1 id="5cca" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">介绍</h1><p id="25b4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Cloud Spanner是Google提供的一个完全托管的、可水平扩展的关系数据库服务。Cloud Spanner的独特功能之一是<a class="ae kk" href="https://cloud.google.com/spanner/docs/schema-and-data-model#parent-child_table_relationships" rel="noopener ugc nofollow" target="_blank">表格交错</a>，它允许您定义表格之间的父子关系。交叉存取表中的数据在物理上位于同一位置，这可以提高读写性能。关于表格交错的更多细节，请查看由Christoph和Anand撰写的博客文章。</p><p id="32d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您设计具有表交叉的模式时，可能会遇到这样的情况:您希望同时从父表和子表中选择行。这是一个常见的用例，您的应用程序有一个API，需要从多个云扳手表中聚合用户信息。</p><h1 id="4250" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">查询交叉表</h1><p id="72cb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了进一步讨论这个话题，让我们用下面的表格和数据来思考:</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="64e8" class="kt je hi kj b fi ku kv l kw kx">CREATE TABLE Singers (<br/>  SingerId INT64 NOT NULL,<br/>  FirstName STRING(1024) NOT NULL,<br/>  LastName STRING(1024) NOT NULL,<br/>) PRIMARY KEY (SingerId);</span><span id="a823" class="kt je hi kj b fi ky kv l kw kx">CREATE TABLE Albums (<br/>  SingerId INT64 NOT NULL,<br/>  AlbumId INT64 NOT NULL,<br/>  Title STRING(1024) NOT NULL,<br/>) PRIMARY KEY (SingerId, AlbumId),<br/>  INTERLEAVE IN PARENT Singers ON DELETE CASCADE;</span><span id="6de1" class="kt je hi kj b fi ky kv l kw kx">CREATE TABLE Concerts (<br/>  SingerId INT64 NOT NULL,<br/>  ConcertId INT64 NOT NULL,<br/>  Price INT64 NOT NULL,<br/>) PRIMARY KEY (SingerId, ConcertId),<br/>  INTERLEAVE IN PARENT Singers ON DELETE CASCADE;</span><span id="8bc1" class="kt je hi kj b fi ky kv l kw kx"># Sample Data<br/>INSERT INTO Singers (SingerId, FirstName, LastName) VALUES (1, "Nick", "Porter");<br/>INSERT INTO Albums (SingerId, AlbumId, Title) VALUES (1, 1, "Total Junk"), (1, 2, "Nice Field");<br/>INSERT INTO Concerts (SingerId, ConcertId, Price) VALUES (1, 1, 3800), (1, 2, 5000), (1, 3, 4000);</span></pre><p id="4a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">歌手是最顶层的父表。专辑和演唱会是歌手下面的子表。</p><p id="be11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有这些表，从SingerId = 1的表中选择所有行的最佳方法是什么？</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kz"><img src="../Images/2a6d9c2089245aedd8b470bff5e2bbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wRZz0q9PFvTlBcsa"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图1:选择SingerId = 1的所有行</figcaption></figure><p id="ed63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单的方法是分别从父表和子表中选择行。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="1e89" class="kt je hi kj b fi ku kv l kw kx">SELECT * FROM Singers WHERE SingerId = 1;<br/>SELECT * FROM Albums WHERE SingerId = 1;<br/>SELECT * FROM Songs WHERE SingerId = 1;</span></pre><p id="e5c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在某些情况下可能没问题，但是随着交叉表数量的增加，查询的数量也会相应增加，这可能会降低性能。</p><p id="ccd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是使用JOIN子句连接父表和子表。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="b732" class="kt je hi kj b fi ku kv l kw kx">SELECT * FROM Singers s<br/>INNER JOIN Albums a ON s.SingerId = a.SingerId<br/>INNER JOIN Concerts c ON s.SingerId = c.SingerId<br/>WHERE s.SingerId = 1;</span></pre><p id="7ffd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，您可以使用一个查询来选择所有行，但是请注意，上面的查询对多个表使用了相同的SingerId作为连接条件。这种类型的连接变成了一个<a class="ae kk" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank">笛卡尔乘积</a>，它可能会产生一个很大的结果集。</p><p id="bc6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们对存储2行专辑和3行音乐会的表运行前面的查询，结果集将变成2 * 3 = 6行，如下所示:</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ll"><img src="../Images/3d1b473185fd15b03031d74d85bb1f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BTlQJUBSFgzX6HUS"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图2:使用JOIN的查询结果集</figcaption></figure><p id="e41d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对几十个交叉表使用JOIN并不是一个好主意，因为它可能会产生一个很大的数据集，并可能降低查询性能。</p><h1 id="b8f5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">解决方案:将子查询与SELECT AS STRUCT一起使用</h1><p id="21b5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">一次从多个表中选择行的解决方案是使用带有<a class="ae kk" href="https://cloud.google.com/spanner/docs/query-syntax#select_as_struct" rel="noopener ugc nofollow" target="_blank"> SELECT AS STRUCT </a>语句的子查询。使用这种方法的查询如下所示:</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="b97c" class="kt je hi kj b fi ku kv l kw kx">SELECT *,<br/>  ARRAY(SELECT AS STRUCT * FROM Albums WHERE SingerId = 1) as Albums,<br/>  ARRAY(SELECT AS STRUCT * FROM Concerts WHERE SingerId = 1) as Concerts,<br/>FROM Singers WHERE SingerId = 1;</span></pre><p id="ada4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个查询看起来有点复杂，所以让我们把它拆开来理解查询的每一部分。首先，看一下下面的子查询:</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="7800" class="kt je hi kj b fi ku kv l kw kx">SELECT AS STRUCT * FROM Albums WHERE SingerId = 1</span></pre><p id="73df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此SELECT语句从相册表中选择SingerId等于1的行。<a class="ae kk" href="https://cloud.google.com/spanner/docs/query-syntax#select_as_struct" rel="noopener ugc nofollow" target="_blank"> SELECT AS STRUCT </a>语句是一种以STRUCT类型获取结果集的方式，它通过存储多个字段的单个列生成结果，如下所示:</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="507f" class="kt je hi kj b fi ku kv l kw kx">+------------------------------------------------+<br/>| Value                                          |<br/>+------------------------------------------------+<br/>| {SingerId: 1, AlbumId: 1, Title: "Total Junk"} |<br/>| {SingerId: 1, AlbumId: 2, Title: "Nice Field"} |<br/>+------------------------------------------------+</span></pre><p id="ac2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，一个歌手可以有零个或多个专辑，所以我们可以用<code class="du kg kh ki kj b">ARRAY()</code>包装上面的语句，以构成<a class="ae kk" href="https://cloud.google.com/spanner/docs/subqueries#array_subquery_concepts" rel="noopener ugc nofollow" target="_blank">数组子查询</a>。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="b6a2" class="kt je hi kj b fi ku kv l kw kx">ARRAY(SELECT AS STRUCT * FROM Albums WHERE SingerId = 1)</span></pre><p id="d130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，您可以写下与交叉表数量一样多的<code class="du kg kh ki kj b">ARRAY(SELECT AS STRUCT ...)</code>子查询，并获得我们首先看到的查询。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="3c2b" class="kt je hi kj b fi ku kv l kw kx">SELECT *,<br/>  ARRAY(SELECT AS STRUCT * FROM Albums WHERE SingerId = 1) as Albums,<br/>  ARRAY(SELECT AS STRUCT * FROM Concerts WHERE SingerId = 1) as Concerts,<br/>FROM Singers WHERE SingerId = 1;</span></pre><p id="e50f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您在云控制台中运行这个查询时，您可以获得以下结果。</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lm"><img src="../Images/14676f5ebfb30020bf5ef92b8ac2b4d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6aJbJgVK_ZszWidq"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图3:使用SELECT AS STRUCT子查询的查询结果</figcaption></figure><p id="8d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这个结果似乎丢失了Albums和Concerts列的字段名，但实际上，当从编程语言访问STRUCT字段时，这两个列实际上都保留了它的名称和类型。</p><p id="5235" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如围棋的<a class="ae kk" href="https://godoc.org/cloud.google.com/go/spanner#Row.ToStruct" rel="noopener ugc nofollow" target="_blank">排。ToStruct </a>可以用下面的方法把上面的结果转换成Go的Struct。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="1639" class="kt je hi kj b fi ku kv l kw kx">type Singer struct {<br/>  SingerID  int64      `spanner:"SingerId"`<br/>  FirstName string     `spanner:"FirstName"`<br/>  LastName  string     `spanner:"LastName"`<br/>  Albums    []*Album   `spanner:"Albums"`<br/>  Concerts  []*Concert `spanner:"Concerts"`<br/>}</span><span id="2ae9" class="kt je hi kj b fi ky kv l kw kx">type Album struct {<br/>  SingerID int64  `spanner:"SingerId"`<br/>  AlbumID  int64  `spanner:"AlbumId"`<br/>  Title    string `spanner:"Title"`<br/>}</span><span id="215a" class="kt je hi kj b fi ky kv l kw kx">type Concert struct {<br/>  SingerID  int64 `spanner:"SingerId"`<br/>  ConcertID int64 `spanner:"ConcertId"`<br/>  Price     int64 `spanner:"Price"`<br/>}</span><span id="74b5" class="kt je hi kj b fi ky kv l kw kx">func decodeRow(row *spanner.Row) (*Singer, error) {<br/>  var singer Singer<br/>  err := row.ToStruct(&amp;singer)<br/>  return &amp;singer, err<br/>}</span></pre><p id="c335" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们比较一下使用JOIN和使用子查询的查询执行计划。</p><p id="1af0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了使用JOIN的查询的执行计划。</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ln"><img src="../Images/889f041d40f5435d8d24c7b5e0e8c5cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*72U4HaEoM-L6k-sz"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图4:使用JOIN的查询的执行计划</figcaption></figure><p id="74c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该查询连接了3个表，因此您可以注意到,<a class="ae kk" href="https://cloud.google.com/spanner/docs/query-execution-operators#cross-apply" rel="noopener ugc nofollow" target="_blank"> Cross Apply </a>操作符被使用了两次来连接表。</p><p id="3ad6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相比之下，下图显示了带有子查询的查询的执行计划。</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lo"><img src="../Images/ebe27e2816a38c36f0e6bc627fbe1d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KMFVpkZ3GzVnmKHP"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图5:带有子查询的查询的执行计划</figcaption></figure><p id="916a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到<code class="du kg kh ki kj b">ARRAY(SELECT AS STRUCT)</code>是作为一个子查询执行的，带有<a class="ae kk" href="https://cloud.google.com/spanner/docs/query-execution-operators#array_subqueries" rel="noopener ugc nofollow" target="_blank">数组子查询</a>操作符。</p><h1 id="14c2" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">基准</h1><p id="2c0b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们运行一个基准测试来了解上述方法的效率。</p><p id="1f56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个基准测试中，我们假设有5个表，一个父表和4个子表，并从这5个表中选择行。下图说明了这个基准测试场景:</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lp"><img src="../Images/c885c77c609aeaad9a0d18bb8fb87981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HSsxx8K_hnfmIj_X"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图6:从5个表中选择行的基准</figcaption></figure><p id="14fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，我们使用只包含主键的列的表。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="9228" class="kt je hi kj b fi ku kv l kw kx">CREATE TABLE `Parent` (<br/>  ParentId INT64 NOT NULL,<br/>) PRIMARY KEY (ParentId);</span><span id="c1b8" class="kt je hi kj b fi ky kv l kw kx">CREATE TABLE Child01 (<br/>  ParentId INT64 NOT NULL,<br/>  Child01Id INT64 NOT NULL,<br/>) PRIMARY KEY (ParentId, Child01Id),<br/>  INTERLEAVE IN PARENT `Parent` ON DELETE CASCADE;</span><span id="a201" class="kt je hi kj b fi ky kv l kw kx">CREATE TABLE Child02 (<br/>  ParentId INT64 NOT NULL,<br/>  Child02Id INT64 NOT NULL,<br/>) PRIMARY KEY (ParentId, Child02Id),<br/>  INTERLEAVE IN PARENT `Parent` ON DELETE CASCADE;</span><span id="2013" class="kt je hi kj b fi ky kv l kw kx">CREATE TABLE Child03 (<br/>  ParentId INT64 NOT NULL,<br/>  Child03Id INT64 NOT NULL,<br/>) PRIMARY KEY (ParentId, Child03Id),<br/>  INTERLEAVE IN PARENT `Parent` ON DELETE CASCADE;</span><span id="2613" class="kt je hi kj b fi ky kv l kw kx">CREATE TABLE Child04 (<br/>  ParentId INT64 NOT NULL,<br/>  Child04Id INT64 NOT NULL,<br/>) PRIMARY KEY (ParentId, Child04Id),<br/>  INTERLEAVE IN PARENT `Parent` ON DELETE CASCADE;</span></pre><p id="265b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个基准测试中，我们将比较两个事务；第一个由多个查询组成，从表中逐个选择行。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="2404" class="kt je hi kj b fi ku kv l kw kx">SELECT * FROM Parent WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>;<br/>SELECT * FROM Child01 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>;<br/>SELECT * FROM Child02 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>;<br/>SELECT * FROM Child03 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>;<br/>SELECT * FROM Child04 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>;</span></pre><p id="5b80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个由一个查询组成，该查询使用子查询一次从所有表中选择行。</p><pre class="kl km kn ko fd kp kj kq kr aw ks bi"><span id="1bb4" class="kt je hi kj b fi ku kv l kw kx">SELECT <br/>  *,<br/>  ARRAY(SELECT AS STRUCT * FROM Child01 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>) as c01,<br/>  ARRAY(SELECT AS STRUCT * FROM Child02 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>) as c02,<br/>  ARRAY(SELECT AS STRUCT * FROM Child03 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>) as c03,<br/>  ARRAY(SELECT AS STRUCT * FROM Child04 WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>) as c04,<br/>FROM Parent p WHERE ParentId = <a class="ae kk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>;</span></pre><p id="0420" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基准的其他条件如下:</p><ul class=""><li id="0869" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">云扳手的节点大小为1。</li><li id="5a01" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">每个表有1M行。</li><li id="6d5b" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">运行查询的事务是只读事务。</li><li id="4888" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">基准代码随机选择行键。</li><li id="c37e" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">客户机是32 vCPU GCE，运行在与云扳手实例相同的位置。</li></ul><p id="d21c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae kk" href="https://github.com/GoogleCloudPlatform/professional-services/tree/main/examples/spanner-interleave-subquery" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中访问基准代码。</p><h1 id="0ab7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">基准结果</h1><p id="f21f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">以下是基准测试结果:</p><figure class="kl km kn ko fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es me"><img src="../Images/04c6304fbc5c3a39d8a68525c8daff3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cQAvqCnWAnXbIxL3"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图7:从5个表中选择的基准测试结果</figcaption></figure><p id="fa66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些图表从上到下显示了Cloud Spanner的CPU利用率、每秒事务(TPS)和每次查询的延迟。图表的左侧显示了使用多个查询的结果，而图表的右侧显示了使用单个查询的结果。</p><p id="4270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图中可以看出，虽然两种方法的CPU利用率几乎相同，但使用单个查询处理的事务(10，000 TPS)是使用多个查询(4，000 TPS)的2.5倍。换句话说，使用建议的方法，Cloud Spanner在服务相同数量的TPS时消耗更少的CPU资源。</p><p id="1429" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从延迟来看，使用单个查询(1.8毫秒)看起来比使用多个查询(1.4毫秒)慢，但此图显示了每个查询*的延迟，因此当我们在事务级别了解延迟时，使用多个查询会更慢，因为单个事务中有5个查询，总延迟为1.4毫秒* 5个查询= 7毫秒</p><h1 id="38fc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">摘要</h1><p id="ca96" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们讨论了如何通过使用<code class="du kg kh ki kj b">ARRAY(SELECT AS STRUCT)</code>子查询为Cloud Spanner的交叉表编写高效的查询。请注意，基准测试结果可能会因各种条件(如模式、查询或交叉表的数量)而异，因此，如果您对这种方法的性能优势感兴趣，请在应用程序的模式和查询中尝试一下。</p><h1 id="5c12" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">确认</h1><p id="49e7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我要感谢Mourad El Azhari的全面审查和有益的评论，使这篇文章更加准确和可读！</p></div></div>    
</body>
</html>