<html>
<head>
<title>3 Ways to Optimize Cloud Run Response Times</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化云运行响应时间的3种方法</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/3-ways-to-optimize-cloud-run-response-times-4504ed0e6804?source=collection_archive---------0-----------------------#2020-10-23">https://medium.com/google-cloud/3-ways-to-optimize-cloud-run-response-times-4504ed0e6804?source=collection_archive---------0-----------------------#2020-10-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3710" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">规模季节</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6246bd259a72726a60dd6e1064911099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uwuy_aAKkCoeR-tyCTIRqw.gif"/></div></div></figure><h1 id="adf2" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">规模季节</h1><p id="1463" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">“规模季节”是一个博客和视频系列，旨在帮助企业和开发人员在设计模式中构建规模和弹性。在这一系列文章中，我们计划向您介绍一些创建具有弹性和可伸缩性的应用程序的模式和实践，这是许多现代架构实践的两个基本目标。</p><p id="96f7" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在第二季中，我们将介绍如何优化您的应用程序以缩短实例启动时间！如果你还没看过第一季，在这里看看吧<a class="ae lc" rel="noopener" href="/google-cloud/scale-and-resilience-arent-just-buzzwords-ce748360e80">。</a></p><ol class=""><li id="e7f4" class="ld le hi kd b ke kx kh ky kk lf ko lg ks lh kw li lj lk ll bi translated"><a class="ae lc" rel="noopener" href="/google-cloud/investigate-and-solve-compute-engine-cold-starts-like-a-detective-️-66a03736cb03">如何改善计算引擎启动时间</a></li><li id="52db" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated"><a class="ae lc" rel="noopener" href="/@swongful/improve-app-engine-startup-times-through-warmup-requests-b424504bde14">如何提高App引擎启动次数</a></li><li id="c88f" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated">如何缩短云运行启动时间(本文)</li></ol><p id="0332" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">Critter Junction在计算引擎、应用引擎和云运行之间创建了一个非常多样化的计算基础架构。我们在<a class="ae lc" rel="noopener" href="/google-cloud/where-to-scale-your-workloads-6420150bf825">第一季</a>中了解到，他们决定用<a class="ae lc" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> Cloud Run </a>做他们的布局应用。刷新一下，布局App是游戏的关键部分。你可以与其他玩家分享房屋布局。现在，他们希望优化云运行以实现可扩展性。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/c35b440d3782115333b7b7adc2e8e337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14FNiZrE7_dXcL3lrA2KVg.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">布局应用程序</figcaption></figure><h1 id="c48a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">看看这个视频</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h1 id="de42" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">回顾</h1><p id="eb90" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">自从将Node.js应用程序容器化后，他们决定在Cloud Run上运行它，因为它具有可移植性、无状态性和自动伸缩性，甚至可以扩展到零。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/0a424453beb3c999bf22a1c51ab8679c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28p8W3zM-im-qT26U3ePEA.png"/></div></div></figure><p id="246d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">与运行在App Engine 上的<a class="ae lc" rel="noopener" href="/@swongful/improve-app-engine-startup-times-through-warmup-requests-b424504bde14">在线网站不同，他们不需要在代码中编写预热包装器，因为Cloud Run可能会保留一些空闲实例来处理流量高峰。</a></p><h2 id="79be" class="lz jk hi bd jl ma mb mc jp md me mf jt kk mg mh jv ko mi mj jx ks mk ml jz mm bi translated">云运行时冷启动</h2><p id="fa14" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">事实是，云运行将在一段时间后终止未使用的云运行容器…这意味着冷启动仍然可能发生。</p><p id="cde9" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在查看了Layout应用程序的最新部署后，我们注意到了一些可以改进的地方，以最大限度地减少冷启动延迟。</p><ul class=""><li id="f1fe" class="ld le hi kd b ke kx kh ky kk lf ko lg ks lh kw mn lj lk ll bi translated">首先，他们碰巧使用了带有依赖库的动态语言，比如在Node.js中导入模块。</li><li id="9615" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">他们没有使用全局变量。</li><li id="9bd4" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">他们的容器基础映像大约有700兆字节。</li></ul><p id="69ef" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这意味着总的来说，他们在容器启动时面临更长的加载时间，或者在服务器开始监听请求之前需要额外的计算。相反，他们希望优化他们的服务启动速度，以最大限度地减少导致这些问题的延迟。</p><p id="5a96" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们深入了解其中的每一项。</p><h2 id="88a1" class="lz jk hi bd jl ma mb mc jp md me mf jt kk mg mh jv ko mi mj jx ks mk ml jz mm bi translated">#1创建更精简的服务</h2><p id="943c" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">首先，在云运行时，容器映像的大小不会影响冷启动或请求处理时间。</p><blockquote class="mo mp mq"><p id="bb16" class="kb kc mr kd b ke kx ij kg kh ky im kj ms kz km kn mt la kq kr mu lb ku kv kw hb bi translated"><strong class="kd hj"> <em class="hi">然而，大型容器映像意味着更慢的构建时间和更慢的部署时间。</em> </strong></p></blockquote><p id="7992" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当涉及到用动态语言编写的应用程序时，您需要格外小心。例如，如果您使用Node.js或Python，进程启动时发生的<em class="mr">模块加载</em>将增加冷启动期间的延迟。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/8d3579e1c9899190954b7ea0ad93c3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9EfwaNBupkZ-sTuc2xTu6g.png"/></div></div></figure><p id="d3bc" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">还要注意一些<em class="mr">在导入时运行初始化</em> <em class="mr">代码</em>的模块。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/ef385233fadb4fd656a27b533c61a28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7YJCGTfqBHqtp1tmRfheA.png"/></div></div></figure><p id="cf23" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><strong class="kd hj">要构建更精简的服务，您可以:</strong></p><ul class=""><li id="14cc" class="ld le hi kd b ke kx kh ky kk lf ko lg ks lh kw mn lj lk ll bi translated">如果你使用动态语言，尽量减少依赖的数量和大小。</li><li id="0ab2" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">不要在启动时计算，而是懒洋洋地计算。</li><li id="ffbb" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">缩短初始化时间，加快启动HTTP服务器的速度。</li><li id="47d3" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">并使用代码加载优化，如PHP的composer autoloader优化。</li></ul><h2 id="2fff" class="lz jk hi bd jl ma mb mc jp md me mf jt kk mg mh jv ko mi mj jx ks mk ml jz mm bi translated">#2使用全局变量</h2><p id="0ad9" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在云运行中，你不能假设服务状态在请求之间被保留。但是，Cloud Run确实重用了单个容器实例来服务正在进行的流量。</p><blockquote class="mo mp mq"><p id="d2d6" class="kb kc mr kd b ke kx ij kg kh ky im kj ms kz km kn mt la kq kr mu lb ku kv kw hb bi translated"><strong class="kd hj"> <em class="hi">这意味着你可以声明一个全局变量。当新的容器旋转起来时，它可以重新利用它的价值。</em> </strong></p></blockquote><p id="9aee" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">还可以在内存中缓存对象。将它从请求逻辑转移到全局范围意味着更好的性能。</p><p id="2e1e" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">现在，这对冷启动时间没有确切的帮助，但是一旦容器被初始化，缓存的对象可以帮助减少后续正在进行的请求的延迟。</p><p id="94f3" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">例如，如果您将每个请求的逻辑移动到全局范围，它应该使冷启动持续大约相同的时间(如果您添加热请求中没有的额外缓存逻辑，它将增加冷启动时间)，但是由该热实例服务的任何后续请求将会改善延迟。</p><pre class="iy iz ja jb fd mx my mz na aw nb bi"><span id="2a9f" class="lz jk hi my b fi nc nd l ne nf">// Global (instance-wide) scope</span><span id="a28d" class="lz jk hi my b fi ng nd l ne nf">// This computation runs at instance cold-start</span><span id="007b" class="lz jk hi my b fi ng nd l ne nf">const instanceVar = heavyComputation();</span><span id="aac0" class="lz jk hi my b fi ng nd l ne nf">/**</span><span id="d78c" class="lz jk hi my b fi ng nd l ne nf">* HTTP function that declares a variable.</span><span id="b02f" class="lz jk hi my b fi ng nd l ne nf">*</span><span id="0f6c" class="lz jk hi my b fi ng nd l ne nf">* @param {Object} req request context.</span><span id="9318" class="lz jk hi my b fi ng nd l ne nf">* @param {Object} res response context.</span><span id="1789" class="lz jk hi my b fi ng nd l ne nf">*/</span><span id="7f09" class="lz jk hi my b fi ng nd l ne nf">exports.scopeDemo = (req, res) =&gt; {</span><span id="a3db" class="lz jk hi my b fi ng nd l ne nf">// Per-function scope</span><span id="3ff8" class="lz jk hi my b fi ng nd l ne nf">// This computation runs every time this function is called</span><span id="2a05" class="lz jk hi my b fi ng nd l ne nf">const functionVar = lightComputation();</span><span id="bad7" class="lz jk hi my b fi ng nd l ne nf">res.send(`Per instance: ${instanceVar}, per function: ${functionVar}`);</span><span id="3b7c" class="lz jk hi my b fi ng nd l ne nf">};</span></pre><blockquote class="nh"><p id="cd02" class="ni nj hi bd nk nl nm nn no np nq kw dx translated">这在很大程度上归结为创建一个更精简的服务。</p></blockquote><h2 id="489f" class="lz jk hi bd jl ma nr mc jp md ns mf jt kk nt mh jv ko nu mj jx ks nv ml jz mm bi translated">#3使用较小的基本图像</h2><p id="5755" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你想通过一个精简的基础映像来构建一个最小的容器，比如:<a class="ae lc" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank"> alpine </a>、<a class="ae lc" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">distroles</a>或<a class="ae lc" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank"> scratch </a>。</p><p id="095d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这些图像将Critter Junction的图像大小从<strong class="kd hj"> 700 </strong> mb减少到<strong class="kd hj"> 65 </strong> mb！他们还确保只安装映像中严格需要的东西。</p><blockquote class="mo mp mq"><p id="17e7" class="kb kc mr kd b ke kx ij kg kh ky im kj ms kz km kn mt la kq kr mu lb ku kv kw hb bi translated"><strong class="kd hj"> <em class="hi">换句话说，不要安装你不需要的额外的包</em>。</strong></p></blockquote><p id="713c" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一旦Critter Junction能够移除依赖性，使用全局变量，交换到更精简的基础映像并移除额外的包，他们就能够减少任何云运行冷启动的延迟。</p><p id="5cd1" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这是第三季的收官之作！关于云运行的可伸缩性和性能，还有很多其他的最佳实践，所以一定要查看下面的链接。</p><p id="4261" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">记住——永远做架构设计。</p><h1 id="135c" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">后续步骤和参考:</h1><ul class=""><li id="067e" class="ld le hi kd b ke kf kh ki kk nw ko nx ks ny kw mn lj lk ll bi translated">在<a class="ae lc" href="https://medium.com/google-cloud" rel="noopener">谷歌云平台媒体</a>上关注这个博客系列。</li><li id="999e" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">参考:<a class="ae lc" href="https://cloud.google.com/run/docs/tips/general" rel="noopener ugc nofollow" target="_blank">云运行通用开发提示</a>。</li><li id="1223" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">关注《T4》系列视频，订阅谷歌云平台YouTube频道。</li><li id="b603" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">想要更多的故事？给我在<a class="ae lc" rel="noopener" href="/@swongful">中</a>，和<a class="ae lc" href="http://twitter.com/swongful" rel="noopener ugc nofollow" target="_blank">推特</a>上喊一声。</li><li id="0ff2" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw mn lj lk ll bi translated">与我们一起享受这个迷你系列的旅程，并了解更多关于可伸缩的GCP最佳实践。</li></ul></div></div>    
</body>
</html>