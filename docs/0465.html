<html>
<head>
<title>Kubernetes load-testing Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes负载测试云功能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-load-testing-cloud-functions-685087f0f66e?source=collection_archive---------1-----------------------#2017-12-17">https://medium.com/google-cloud/kubernetes-load-testing-cloud-functions-685087f0f66e?source=collection_archive---------1-----------------------#2017-12-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2fb0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">许多美丽的卷发</h2></div><p id="853c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想对云函数施加压力。用curl，ab容易，用wrk不难。如果能够在本地进行curl调用、指定集群和一些约束、按需启动集群并将负载添加到端点，那就太棒了。这只是第一步…</p><p id="2845" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您已经为<a class="ae jt" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank"> Google Cloud Functions </a>部署了一个HTTP触发的函数，您可以使用以下形式的curls来测试它:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="e2fd" class="kd ke hi jz b fi kf kg l kh ki">PROJECT=[YOUR-PROJECT-ID]<br/>FUNCTION=[YOUR-FUNCTION-NAME]<br/>TYPE="application/json"<br/>DATA=[YOUR-DATA-FILE]<br/>NAME=[YOUR-IMAGE-NAME] # 'curls_cloud_functions'</span><span id="7cb0" class="kd ke hi jz b fi kj kg l kh ki">curl \<br/>--silent \<br/>--request POST \<br/>--header "Content-Type:${TYPE}" \<br/>--data <a class="ae jt" href="http://twitter.com/payload" rel="noopener ugc nofollow" target="_blank">@</a>${DATA} \<br/>https://us-central1-${PROJECT}.cloudfunctions.net/${FUNCTION}</span></pre><p id="5ffc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用ApacheBench ('ab ')的一个等效测试是:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="7420" class="kd ke hi jz b fi kf kg l kh ki">ab \<br/>-n NUMBER_OF_TESTS_TOTAL \<br/>-c NUMBER_OF_TESTS_CONCURRENT \<br/>-t TIME_LIMIT_IN_SECONDS \<br/>-p ${DATA} \<br/>-T ${TYPE} \<br/>https://us-central1-${PROJECT}.cloudfunctions.net/${FUNCTION}</span></pre><p id="94d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">云功能提供基本的监控功能:</p><figure class="ju jv jw jx fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kk"><img src="../Images/29d0026c8b72967a5878d6bddf1c6c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZk4W86FuvWrbkn-pvAipA.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">云控制台:云功能(调用)</figcaption></figure><p id="2902" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还可以使用Stackdriver Metrics Explorer查看云函数指标。稍后我将提供一个这些指标的例子。</p><h2 id="cff7" class="kd ke hi bd kw kx ky kz la lb lc ld le jg lf lg lh jk li lj lk jo ll lm ln lo bi translated">busyboxplus</h2><p id="1c20" class="pw-post-body-paragraph ix iy hi iz b ja lp ij jc jd lq im jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">你们中的许多人可能都熟悉令人敬畏的<a class="ae jt" href="https://busybox.net/" rel="noopener ugc nofollow" target="_blank"> busybox </a>和相关的Docker <a class="ae jt" href="https://hub.docker.com/_/busybox/" rel="noopener ugc nofollow" target="_blank">映像</a>，其中包含一个小的可执行文件和许多有用的Linux实用程序。Busybox不包括curl。为此，你可以考虑<a class="ae jt" href="https://hub.docker.com/r/radial/busyboxplus/" rel="noopener ugc nofollow" target="_blank"> busyboxplus </a>。使用busyboxplus，我们可以运行curl命令，但是我们需要一种方法来访问数据文件。当使用Kubernetes时，我们需要一种不同的方法，但是，下面是如何使用busyboxplus容器并使文件可以被其中运行的curl访问:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="bfde" class="kd ke hi jz b fi kf kg l kh ki">docker run \<br/>--interactive \<br/>--tty \<br/>--rm \<br/>--volume=${PWD}/${DATA}:/${DATA} \<br/>radial/busyboxplus curl \<br/>  --silent \<br/>  --request POST \<br/>  --header "Content-Type:${TYPE}" \<br/>  --data @${DATA} \<br/>  <a class="ae jt" href="https://us-central1-${PROJECT}.cloudfunctions.net/${FUNCTION" rel="noopener ugc nofollow" target="_blank">https://us-central1-${PROJECT}.cloudfunctions.net/${FUNCTION</a>}</span></pre><p id="f7a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“volume”映射适用于本地Docker引擎，但不被远程Kubernetes集群支持。有多种方法可以让Kubernetes pods访问数据文件，但是探索这些替代方法并不是本文的目的。我们希望实现的是使curl命令的延迟最小化。因此，我将采用最简单的方法，将数据文件合并到派生的Docker映像中。创建Dockerfile文件:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d7e7" class="kd ke hi jz b fi kf kg l kh ki">FROM radial/busyboxplus</span><span id="9cc8" class="kd ke hi jz b fi kj kg l kh ki">ARG data</span><span id="8aa8" class="kd ke hi jz b fi kj kg l kh ki">COPY ./${data} /data</span></pre><p id="769b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现这一点:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2d4a" class="kd ke hi jz b fi kf kg l kh ki">TAG=$(date +%y%m%d%H%M)<br/>docker build \<br/>--tag=gcr.io/${PROJECT}/${NAME}:${TAG} \<br/>--build-arg data=${DATA} \<br/>.</span></pre><p id="012f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以在不指定本地相关卷标志的情况下运行该映像。请注意，我们还可以删除＄{ DATA }变量，因为图像现在包括了我们的“数据”文件:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="031b" class="kd ke hi jz b fi kf kg l kh ki">docker run \<br/>--interactive \<br/>--tty \<br/>--rm \<br/>gcr.io/${PROJECT}/${NAME}:${TAG} curl \<br/>  --silent \<br/>  --request POST \<br/>  --header "Content-Type:${TYPE}" \<br/>  --data @/data \<br/>  <a class="ae jt" href="https://us-central1-${PROJECT}.cloudfunctions.net/${FUNCTION" rel="noopener ugc nofollow" target="_blank">https://us-central1-${PROJECT}.cloudfunctions.net/${FUNCTION</a>}</span></pre><h2 id="4575" class="kd ke hi bd kw kx ky kz la lb lc ld le jg lf lg lh jk li lj lk jo ll lm ln lo bi translated">库伯内特发动机</h2><p id="b0ad" class="pw-post-body-paragraph ix iy hi iz b ja lp ij jc jd lq im jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">下一步是将这个图像推送到<a class="ae jt" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册(GCR) </a>，这样我们就可以从<a class="ae jt" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a>访问它。我假设您有一个正在运行的Kubernetes(引擎)集群，并且您已经启用了GCR:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="77e4" class="kd ke hi jz b fi kf kg l kh ki">gcloud docker -- push gcr.io/${PROJECT}/${NAME}:${TAG}</span></pre><blockquote class="lu lv lw"><p id="d236" class="ix iy lx iz b ja jb ij jc jd je im jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">这些指令应该适用于任何Kubernetes集群(不仅仅是那些运行在Kubernetes引擎上的集群)，并使用任何Docker容器注册中心(包括DockerHub)。这是你的选择。</p></blockquote><p id="4895" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们为这个容器创建一个简单的部署。下面使用您的环境变量完成了一个部署文件，并将其应用到您当前的默认集群:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="ef25" class="kd ke hi jz b fi kf kg l kh ki">CMD="\<br/>while true;<br/>do<br/>  curl \<br/>  --silent \<br/>  --request POST \<br/>  --header \"Content-Type:${TYPE}\" \<br/>  --data @/data ${ENDPOINT} \<br/>  <a class="ae jt" href="https://us-central1-dazwilkin-171214-ncr.cloudfunctions.net/parse-20171215124506'" rel="noopener ugc nofollow" target="_blank">https://us-central1-${PROJECT}.cloudfunctions.net/$</a>{FUNCTION};<br/>done"</span><span id="f9fa" class="kd ke hi jz b fi kj kg l kh ki">echo "<br/>apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: ${NAME}<br/>  name: ${NAME}<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: ${NAME}<br/>    spec:<br/>      containers:<br/>      - name: ${NAME}<br/>        command: ['/bin/sh']<br/>        args: ['-c','${CMD}']<br/>        image: 'gcr.io/${PROJECT}/${NAME}:${TAG}'<br/>" | kubectl apply --filename -</span></pre><p id="5a6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你会在上面看到，我已经为容器定义了一个简短的脚本。如果它运行一个单一的旋度，它会这样做，然后终止。因此，这个脚本只是在pod的生命周期内重复卷曲端点。</p><p id="ec3e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">单个吊舱能够将一些负载放在整个集装箱上:</p><figure class="ju jv jw jx fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mb"><img src="../Images/8cbec8a3f7148b007e5e75509b223ecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ff3_ctLVNeVup6TKVhkvxQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">云控制台:云功能(调用)</figcaption></figure><p id="0317" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只要部署存在，您将一直被收费。在任何时候，您都可以将pod的数量设置为零，以停止针对云函数运行测试。<strong class="iz hj"> NB </strong>您将继续为该集群付费:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1fc8" class="kd ke hi jz b fi kf kg l kh ki">kubectl scale --replicas=0 deployment/${NAME}</span></pre><p id="41a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，完全删除部署:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="3938" class="kd ke hi jz b fi kf kg l kh ki">kubectl delete deployment/${NAME}</span></pre><p id="5e2f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果您有钱，您也可以增加部署中的单元数量，从而增加云功能的负载:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="01be" class="kd ke hi jz b fi kf kg l kh ki">kubectl scale --replicas=10 deployment/${NAME}</span></pre><p id="5236" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我仍然是Kube UI的粉丝，但也鼓励我探索Kubernetes引擎的工具。以下是其“工作负载”页面的输出:</p><figure class="ju jv jw jx fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mc"><img src="../Images/92023404b82aeb2c350ce8b64a784a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-1eO7B7VfQE-1OVtN_RUQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">云控制台:Kubernetes引擎(工作负载)</figcaption></figure><figure class="ju jv jw jx fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es md"><img src="../Images/718d50e55b13c5385cbdcfe64e9176dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuDq3Lf9hWGLoDmlJbqENw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">云控制台:云功能(调用)</figcaption></figure><p id="93ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用stack driver“Metrics Explorer”，您可以选择“cloud_function”的“资源类型”，例如，“cloud functions/function/execution _ count”的指标类型:</p><figure class="ju jv jw jx fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es me"><img src="../Images/9e43007b3a326db60e8f9436458edb68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8MloZd3xxJCGxg7VEkCUA.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">Stackdriver:度量浏览器“云函数”</figcaption></figure><p id="7a3d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还可以过滤日志，例如，提取时间戳、执行时间和HTTP响应状态代码:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="3747" class="kd ke hi jz b fi kf kg l kh ki">ROOT="projects/${PROJECT}/logs"<br/>LOG="${ROOT}/cloudfunctions.googleapis.com%2Fcloud-functions"<br/>AFTER=$(\<br/>  date --utc --rfc-3339=ns --date='2 minutes ago' \<br/>  | sed 's/ /T/'\<br/>)<br/>BEFORE=$(\<br/>  date --utc --rfc-3339=ns \<br/>  | sed 's/ /T/'\<br/>)<br/>FILTER="\<br/>  resource.type=\"cloud_function\" \<br/>  logName=\"${LOG}\" \<br/>  resource.labels.function_name=\"${FUNCTION}\" \<br/>  textPayload:\"Function execution took\" \<br/>  timestamp&gt;=\"${AFTER}\" \<br/>  timestamp&lt;=\"${BEFORE}\""<br/>gcloud logging read "${FILTER}" \<br/>--project=$PROJECT \<br/>--format='value(timestamp,textPayload)'</span></pre><p id="0e14" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">旁白:为了处理这些日志中的数据，我们可以使用一个简单的Python脚本将带有命名捕获组的regex应用到每个日志行。假设您将该脚本命名为“parse.py ”,并对其进行chmod +x处理:</p><figure class="ju jv jw jx fd kl"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">parse.py</figcaption></figure><p id="552b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，抓取<a class="ae jt" href="https://unix.stackexchange.com/a/13779" rel="noopener ugc nofollow" target="_blank">这个</a> bash脚本，将其命名为‘stats . sh’并将其命名为chmod +x，然后，通过这些管道输出日志:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="b328" class="kd ke hi jz b fi kf kg l kh ki">gcloud logging read "${FILTER}" \<br/>--project=$PROJECT \<br/>--format='value(timestamp,textPayload)' \<br/>| ./parse.py \<br/>| ./stats.sh</span></pre><p id="0f7c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该会看到类似下面的内容，其中的数字表示日志数据中执行时间的总和、计数、平均值、中间值、最低值和最高值。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d2b3" class="kd ke hi jz b fi kf kg l kh ki">373495 14096 26.4965 11 5 352</span></pre><p id="42ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于结合了云功能端点URL(可能是内容类型和一些数据)的每个“测试”,我们必须:</p><ul class=""><li id="3e35" class="mh mi hi iz b ja jb jd je jg mj jk mk jo ml js mm mn mo mp bi translated">建立码头工人形象</li><li id="8f84" class="mh mi hi iz b ja mq jd mr jg ms jk mt jo mu js mm mn mo mp bi translated">把它推到GCR</li><li id="1e10" class="mh mi hi iz b ja mq jd mr jg ms jk mt jo mu js mm mn mo mp bi translated">修改Kubernetes部署</li><li id="18a9" class="mh mi hi iz b ja mq jd mr jg ms jk mt jo mu js mm mn mo mp bi translated">观察</li></ul><p id="5b3e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一个更好的方法来实现自动化。</p><h2 id="5a1a" class="kd ke hi bd kw kx ky kz la lb lc ld le jg lf lg lh jk li lj lk jo ll lm ln lo bi translated">集装箱建造商</h2><p id="7089" class="pw-post-body-paragraph ix iy hi iz b ja lp ij jc jd lq im jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">每个使用<a class="ae jt" href="https://cloud.google.com/container-builder/" rel="noopener ugc nofollow" target="_blank">谷歌容器生成器</a>的人都称赞它。使用一个简单明了的规范，并利用一个体面的<a class="ae jt" href="https://github.com/GoogleCloudPlatform/cloud-builders" rel="noopener ugc nofollow" target="_blank">步骤集</a>(表现为Docker镜像)，你可以将构建迁移到Google云平台。</p><blockquote class="lu lv lw"><p id="8826" class="ix iy lx iz b ja jb ij jc jd je im jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">从技术上讲，将构成Docker映像步骤的流程链接在一起是Container Builder的核心，因此它不仅限于构建流程。</p></blockquote><p id="d3d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于我们的简单用例，容器构建器可能有些多余，但是使用它可以自动完成上面描述的3个步骤。切入正题，这里有一个cloudbuild.yaml:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="42f9" class="kd ke hi jz b fi kf kg l kh ki">steps:<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  args: [<br/>    'build',<br/>      '--build-arg','data=${_DATA}',<br/>      '--tag','gcr.io/${PROJECT_ID}/${_NAME}:${_TAG}',<br/>      '.'<br/>  ]<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  args: ['push','gcr.io/${PROJECT_ID}/${_NAME}:${_TAG}']<br/>- name: 'gcr.io/cloud-builders/kubectl'<br/>  args: [<br/>    'set','image','deployment','${_NAME}',<br/>    '${_NAME}=gcr.io/${PROJECT_ID}/${_NAME}:${_TAG}'<br/>  ]<br/>  env:<br/>  - 'CLOUDSDK_COMPUTE_ZONE=${_ZONE}'<br/>  - 'CLOUDSDK_CONTAINER_CLUSTER=${_CLUSTER}'</span></pre><p id="d15b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您需要在使用前启用该服务:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="5dcb" class="kd ke hi jz b fi kf kg l kh ki">gcloud services enable cloudbuild.googleapis.com --project=$PROJECT</span></pre><p id="6b97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，如果您希望容器构建器在步骤#3中访问您的集群，您将需要将Kubernetes引擎开发人员角色(container.developer)添加到运行容器构建器的服务帐户，如这里的<a class="ae jt" href="https://cloud.google.com/container-builder/docs/configuring-builds/build-test-deploy-artifacts#deploying_artifacts" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae jt" href="https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/kubectl" rel="noopener ugc nofollow" target="_blank"/>所述:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="fce3" class="kd ke hi jz b fi kf kg l kh ki">NUM=$(gcloud projects describe $PROJECT --format='value(projectNumber)')</span><span id="c460" class="kd ke hi jz b fi kj kg l kh ki">gcloud projects add-iam-policy-binding ${PROJECT} \<br/>--member=serviceAccount:${<a class="ae jt" href="mailto:PROJECT@cloudbuild.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">NUM}@cloudbuild.gserviceaccount.com</a> \<br/>--role=roles/container.developer</span></pre><p id="2708" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该构建配置包含3个步骤:</p><ul class=""><li id="f876" class="mh mi hi iz b ja jb jd je jg mj jk mk jo ml js mm mn mo mp bi translated">云构建者/对接者构建映像</li><li id="3488" class="mh mi hi iz b ja mq jd mr jg ms jk mt jo mu js mm mn mo mp bi translated">云建设者/码头工人将图像推向GCR</li><li id="3441" class="mh mi hi iz b ja mq jd mr jg ms jk mt jo mu js mm mn mo mp bi translated">云构建者/kubectl然后修改我们现有的部署</li></ul><p id="9f03" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Container Builder要求用户定义的变量以“_”为前缀，因此，例如必须将_NAME赋给我们的环境变量$NAME。当我们使用“替换”提交构建时，我们会这样做。</p><blockquote class="lu lv lw"><p id="9098" class="ix iy lx iz b ja jb ij jc jd je im jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>云构建者/kubectl目前不支持<a class="ae jt" href="https://cloud.google.com/kubernetes-engine/docs/concepts/multi-zone-and-regional-clusters#regional" rel="noopener ugc nofollow" target="_blank">区域集群</a>。为此，您必须使用单区域集群。</p></blockquote><p id="1687" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">唯一复杂的是kubectl的第三步。我们必须为这个容器提供集群的区域和名称的环境变量。否则，我们假设(！)名为＄{ NAME }的现有部署，我们使用此脚本重新创建的映像对其进行了修改。</p><p id="887d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要强制更新，您可能需要:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="5b8f" class="kd ke hi jz b fi kf kg l kh ki">export TAG=$(date +%y%m%d%H%M)</span></pre><p id="3a79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，您还需要提供Kubernetes集群(名称)和区域的详细信息:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="141e" class="kd ke hi jz b fi kf kg l kh ki">CLUSTER=[YOUR-CLUSTER-NAME]<br/>ZONE=[YOUR-CLUSTER-ZONE]</span></pre><p id="33a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且，您可以使用以下方式触发构建:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="6c93" class="kd ke hi jz b fi kf kg l kh ki">gcloud container builds submit . \<br/>--config=cloudbuild.yaml \<br/>--substitutions=\<br/>_CLUSTER=${CLUSTER},\<br/>_DATA=${DATA},\<br/>_NAME=${NAME},\<br/>_TAG=${TAG},\<br/>_ZONE=${ZONE} \<br/>--project=$PROJECT</span></pre><p id="927b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一切顺利，这将成功完成，您可以确认您现在正在使用此新映像运行经过修改的部署＄{ NAME },该映像包含:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4ad2" class="kd ke hi jz b fi kf kg l kh ki">kubectl get deployment/${NAME} \<br/>--output=jsonpath='{.spec.template.spec.containers[0].image}'</span></pre><p id="6a5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并检查它是否正确，用:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="e92a" class="kd ke hi jz b fi kf kg l kh ki">ACTUAL=$(kubectl get deployment/${NAME} --output=jsonpath='{.spec.template.spec.containers[0].image}')<br/>EXPECT="gcr.io/${PROJECT}/${NAME}:${TAG}"</span><span id="4d90" class="kd ke hi jz b fi kj kg l kh ki">if [ ${ACTUAL} == ${EXPECT} ] <br/>then<br/>  echo "Correct" <br/>else <br/>  echo "Incorrect"<br/>fi</span></pre><figure class="ju jv jw jx fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mv"><img src="../Images/24e04f54f667d6c59478b0da0bc6df08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZzlR0_EhUL_I0EJI-8ykg.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">Kubernetes用户界面</figcaption></figure><h2 id="952c" class="kd ke hi bd kw kx ky kz la lb lc ld le jg lf lg lh jk li lj lk jo ll lm ln lo bi translated">结论</h2><p id="ff42" class="pw-post-body-paragraph ix iy hi iz b ja lp ij jc jd lq im jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">一个稍微曲折的旅程，但希望是一个有趣的。从在本地使用curl命令测试云函数(或任何其他端点)扩展到为Kubernetes集群运行相同的curl命令的简单方法。</p><p id="e185" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个过程中，我们探索了Container Builder，将其作为简化构建过程的一种方式，即使对于这样简单的情况也是如此。</p><h2 id="28da" class="kd ke hi bd kw kx ky kz la lb lc ld le jg lf lg lh jk li lj lk jo ll lm ln lo bi translated">整理</h2><p id="8d3b" class="pw-post-body-paragraph ix iy hi iz b ja lp ij jc jd lq im jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">您可以将部署设置为消耗零个pod:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="5ea2" class="kd ke hi jz b fi kf kg l kh ki">kubectl scale --replicas=0 deployment/${NAME}</span></pre><p id="e5cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以删除部署:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="7267" class="kd ke hi jz b fi kf kg l kh ki">kubectl delete deployment/${NAME}</span></pre><p id="71e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于操作是不可撤销的，所以您可以小心地删除Kubernetes集群:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="beec" class="kd ke hi jz b fi kf kg l kh ki">gcloud container clusters delete ${CLUSTER} \<br/>--project=${PROJECT} \<br/>--zone=${ZONE}</span></pre><p id="f956" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以删除整个GCP项目，但同样，在执行此不可恢复的步骤之前，请确保删除的是您自己的项目:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="9b1e" class="kd ke hi jz b fi kf kg l kh ki">gcloud projects delete $PROJECT --quiet</span></pre></div></div>    
</body>
</html>