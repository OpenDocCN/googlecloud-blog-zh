<html>
<head>
<title>Composer invoking long running services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Composer调用长期运行的服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/composer-invoking-long-running-services-4de2dfa5e33a?source=collection_archive---------0-----------------------#2021-12-26">https://medium.com/google-cloud/composer-invoking-long-running-services-4de2dfa5e33a?source=collection_archive---------0-----------------------#2021-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b2990c23f967ea353c1a8c1b960bf611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*340-H0Yv0c40K6Pi"/></div></div></figure><p id="492d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑一个场景，我们有一个任务，这是一个服务调用，由气流执行，可能需要几个小时。这是一个比我们所能保持的阻塞同步请求/响应调用更长的持续时间。同步REST调用不是一个好的解决方案。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/51c9b04cc5fb5523c86816daf7a071d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/0*GWemydSQMxLNTbpr"/></div></figure><p id="6f05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想要的是异步请求/响应解决方案。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/2857816a0ced09766b5d7eadc00f78d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/0*vYQIWUmomc6nlNK2"/></div></figure><p id="7f03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然可能有许多技术可供我们实现这一目标，但这里我们将使用GCP发布/订阅。现在让我们开始我们的探索。</p><p id="6417" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以想象，我们的DAG in Airflow中的一个任务将请求发起一个长执行持续时间的服务调用。我们可以使用PubSub来启动请求，但是在我们的故事中，我们将保持简单，使用REST请求来启动服务。这个REST请求会很快返回。它将仅用于启动服务，并且响应将仅指示服务现在正在进行其工作。</p><p id="5477" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们解决方案的核心是一份我们设计的存在于Airflow和服务提供商之间的合同。该合同规定，<em class="ju">当</em>后端服务完成其工作，<em class="ju">然后</em>它将发布一个消息到GCP的发布主题。在合同结束时，Airflow将创建对该主题的订阅，并将关注将要发布的消息，该消息将指示服务请求已完成。</p><p id="f8ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们应该假设将会有多个服务客户端，它们可能会同时发出请求。我们需要确保将正确的响应返回给正确的调用者客户端。为了实现这一点，让我们看看PubSub提供的特性。</p><p id="13be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一种选择是为每个请求创建一个<em class="ju">特有的</em>主题。当服务完成它的任务时，它会发布一条消息到那个主题。客户(气流)会订阅这个独特的主题。</p><p id="9f88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二种选择是让所有请求共享一个<em class="ju">主题。当一个服务完成时，它将再次向单个主题发布消息。这似乎有一个困惑，如果服务在完成它的工作时发布一个消息，正确的客户端如何知道它的<em class="ju">请求是完成的请求？答案是使用相关标识符(相关ID)的概念。这是消息传递和队列技术中的常见做法。当发出请求时，会提供一个关联id。当响应就绪时，发布一条消息，该消息包含最初提供的相关id值作为属性。这提供了请求和响应之间的耦合。在GCP技术中，当创建订阅时，我们可以提供一个<em class="ju">过滤器</em>，该过滤器丢弃(自动确认)发布到与订阅相关的主题的所有消息，除了那些匹配过滤器(关联id)的消息。换句话说，只有具有正确相关id的消息才会被传递到匹配的客户端。</em></em></p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jv"><img src="../Images/62e71925024c65c300c6ac818bd15f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/0*5wPRPUfUytACVtDY"/></div></figure><p id="a6c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于过滤器应用于订阅，这意味着每个客户端都有自己的与相关id相关联的订阅。这实际上似乎是一个很好的解决方案，因为有一个与订阅相关的概念，它们可以过期，这意味着订阅在一段时间没有使用后会自动删除。这意味着，如果在订阅达到其目的后删除失败，订阅将随着时间的推移自行清理。</p><p id="4338" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们看一下涉及的零件，我们现在有:</p><ul class=""><li id="8d7e" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">由管理人员创建并由服务发布到的GCP主题。</li><li id="9e91" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">由每个客户端在发送启动服务的请求之前创建的动态创建的订阅。对于匹配相关id的消息，订阅将有一个与之相关联的过滤器。</li></ul><p id="5190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现我们的目标，Airflow要执行的步骤现在看起来是:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/005984a9ba7d2b1e4ddaa9fce351e77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/0*kgVSOTnC8Kl6MDAp"/></div></figure><p id="8334" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从气流的角度依次看看每一个。</p><p id="5c03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们创建订阅时，我们将为它生成一个唯一的名称。每个订阅都是互不相同的，只有为给定消费者发布的消息最终才能在正确的对应订阅上获得。为此，我们将使用订阅的唯一名称作为关联id的值。这意味着两件事。首先，当订阅被创建时，它将有一个过滤器表达式，以便只接收具有特定属性值的消息。其次，消息的发布者必须确保其发布的消息中包含将通过过滤器的属性。</p><p id="a6af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Airflow提供了一个GCP发布订阅操作，允许我们创建订阅。该操作被称为<a class="ae kl" href="https://airflow.apache.org/docs/apache-airflow-providers-google/stable/_api/airflow/providers/google/cloud/operators/pubsub/index.html#airflow.providers.google.cloud.operators.pubsub.PubSubCreateSubscriptionOperator" rel="noopener ugc nofollow" target="_blank">PubSubCreateSubscriptionOperator</a>。这是<em class="ju">非常</em>接近我们需要的，但它有几个缺点。最严重的限制是该操作不允许为过滤器传递动态计算的值。气流操作符<em class="ju">不</em>支持过滤器表达式作为模板参数。幸运的是，有一个解决方案。除了一组GCP PubSub操作符，Airflow还提供了一个GCP PubSub Airflow钩子。这意味着我们可以编写一个调用GCP PubSub钩子的Python函数来实现我们的目标。</p><p id="fddc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是在Airflow中执行创建订阅任务的代码:</p><pre class="jp jq jr js fd km kn ko kp aw kq bi"><span id="44b8" class="kr ks hi kn b fi kt ku l kv kw">def _createSubscription():<br/>  subscriptionName = "airflow-test-" + str(uuid.uuid4())<br/>  hook = PubSubHook()<br/>  result = hook.create_subscription(<br/>    topic="mytopic",<br/>    subscription=subscriptionName,<br/>    expiration_policy={<br/>      "ttl": Duration(seconds=24*60*60)<br/>    },<br/>    labels={<br/>      "source": "dag"<br/>    },<br/>    filter_='attributes.correlid = "' + subscriptionName + '"'<br/>  )<br/>  return subscriptionName  # The return value is the subscription name</span><span id="9242" class="kr ks hi kn b fi kx ku l kv kw">create_subscription_task = PythonOperator(<br/>  task_id='CreateSubscription',<br/>  python_callable=_createSubscription<br/>)</span></pre><p id="9ebc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">拆开它，我们看到我们首先创建了一个订阅名称。还要注意订阅过滤器是动态构造的。该订阅将接收发布的消息，这些消息带有一个名为“correlid”的订阅名称值集的属性。</p><p id="f11f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看下一步，我们看到它调用了一个REST服务。这是我们预计需要很长时间才能完成的服务。REST调用本身将快速返回，但返回后执行将异步继续。</p><pre class="jp jq jr js fd km kn ko kp aw kq bi"><span id="b418" class="kr ks hi kn b fi kt ku l kv kw">rest_invoke_task = SimpleHttpOperator(<br/>  task_id='InvokeREST',<br/>  http_conn_id='rest_serve',<br/>  method='POST',<br/>endpoint="/serve?correlid={{task_instance.xcom_pull(task_ids='CreateSubscription', key='return_value')}}",<br/>  headers={},<br/> dag=dag<br/>)</span></pre><p id="bfb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用提供的名为SimpleHttpOperator的气流操作符进行REST调用。请特别注意端点参数的值。在这里，我们传递服务将发布的相关id的值，以指示其工作已经完成。相关id的值是从CreateSubscription任务中检索的。</p><p id="b8f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当REST调用者任务完成时，并不意味着后端服务已经完成。我们应该等待服务指示它已经这样做了。我们使用气流传感器来等待与订阅相关联的PubSub消息变得可用。PubSubPullSensor是一个气流操作符，在有合适的消息可用之前不会完成。这将由服务代码发布。当我们使用这个操作符时，请注意它不会在消息发布后立即解除阻止。相反，它似乎会定期轮询(证据似乎显示轮询间隔为每分钟一次)。这意味着DAG可能需要一分钟的时间才能意识到后端服务已经完成。下面是说明等待消息的代码片段。请注意，项目id是必需的，它是订阅所在的项目。在这个片段中，我们提供了气流环境中的一个变量，而不是硬编码。</p><pre class="jp jq jr js fd km kn ko kp aw kq bi"><span id="b538" class="kr ks hi kn b fi kt ku l kv kw">pubsubpullsensor_task = PubSubPullSensor(<br/>  task_id="WaitForCompletion",<br/>  project_id="{{var.value.GCP_PROJECT}}",<br/>  subscription=subscription,<br/>  max_messages=1<br/>)</span></pre><p id="9c86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当在DAG中完成该任务时，直到订阅上有可用的消息，该任务才会完成。</p><p id="a719" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，实现我们总体目标所需的所有任务都已完成。剩下的工作就是通过删除订阅进行清理。从技术上讲，我们不必删除订阅，因为它在创建时就被定义为在一天后自动过期。有一个预先提供的气流操作满足我们的需求。</p><pre class="jp jq jr js fd km kn ko kp aw kq bi"><span id="afed" class="kr ks hi kn b fi kt ku l kv kw">delete_subscription_task = PubSubDeleteSubscriptionOperator(<br/>  task_id='DeleteSubscription',<br/>  subscription=subscription<br/>)</span></pre><p id="e046" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以将这些任务与以下内容联系起来:</p><pre class="jp jq jr js fd km kn ko kp aw kq bi"><span id="ca9a" class="kr ks hi kn b fi kt ku l kv kw">create_subscription_task &gt;&gt; rest_invoke_task &gt;&gt; pubsubpullsensor_task &gt;&gt; delete_subscription_task</span></pre><p id="0c56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们运行该解决方案时，我们会看到最终的执行图，如下所示:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/e833721bc1e55efc155fe7e0b5c899a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j3Na1N71tXqcuoRh"/></div></div></figure><p id="8698" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能会惊讶地发现，有从CreateSubscription到其他任务的链接。这是因为CreateSubscription会生成下游需要的订阅名称。这意味着任务WaitForCompletion和DeleteSubscription对CreateSubscription有显式的依赖关系。</p><p id="8a88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的代码变成:</p><pre class="jp jq jr js fd km kn ko kp aw kq bi"><span id="b3ac" class="kr ks hi kn b fi kt ku l kv kw">from datetime import timedelta, datetime<br/>from airflow import DAG<br/>from airflow.operators.python_operator import PythonOperator<br/>from airflow.providers.http.operators.http import SimpleHttpOperator<br/>from airflow.providers.google.cloud.operators.pubsub import PubSubDeleteSubscriptionOperator<br/>from airflow.providers.google.cloud.sensors.pubsub import PubSubPullSensor<br/>from airflow.providers.google.cloud.hooks.pubsub import PubSubHook<br/>from google.cloud.pubsub_v1.types import Duration<br/>import uuid</span><span id="f0da" class="kr ks hi kn b fi kx ku l kv kw">default_args = {<br/>    'owner': 'airflow',<br/>    'depends_on_past': False,<br/>    'email_on_failure': False,<br/>    'email_on_retry': False,<br/>    'retries': 1,<br/>    'retry_delay': timedelta(minutes=5),<br/>}</span><span id="a1a0" class="kr ks hi kn b fi kx ku l kv kw">with DAG(<br/>    'test',<br/>    default_args=default_args,<br/>    schedule_interval="<a class="ae kl" href="http://twitter.com/daily" rel="noopener ugc nofollow" target="_blank">@daily</a>",<br/>    start_date=datetime(2021, 12, 10),<br/>) as dag:</span><span id="5248" class="kr ks hi kn b fi kx ku l kv kw">def _createSubscription():<br/>        hook = PubSubHook()<br/>        subscriptionName = "airflow-test-" + str(uuid.uuid4())<br/>        result = hook.create_subscription(<br/>            topic="mytopic",<br/>            subscription=subscriptionName,<br/>            expiration_policy={<br/>                "ttl": Duration(seconds=24*60*60)<br/>            },<br/>            labels={<br/>                "source": "dag"<br/>            },<br/>            filter_='attributes.correlid = "' + subscriptionName + '"'<br/>        )<br/>        return subscriptionName  # The return value is the subscription name</span><span id="b4e6" class="kr ks hi kn b fi kx ku l kv kw">create_subscription_task = PythonOperator(<br/>        task_id='CreateSubscription',<br/>        python_callable=_createSubscription<br/>    )</span><span id="6b9a" class="kr ks hi kn b fi kx ku l kv kw">subscription = create_subscription_task.output</span><span id="9184" class="kr ks hi kn b fi kx ku l kv kw"># Invoke the back end REST Service<br/>    rest_invoke_task = SimpleHttpOperator(<br/>        task_id='InvokeREST',<br/>        http_conn_id='rest_serve',<br/>        method='POST', <br/>        endpoint="/serve?correlid={{task_instance.xcom_pull(task_ids='CreateSubscription', key='return_value')}}",<br/>        headers={},<br/>        dag=dag,<br/>    )</span><span id="9e89" class="kr ks hi kn b fi kx ku l kv kw">sensor1_task = PubSubPullSensor(<br/>        task_id="WaitForCompletion",<br/>        project_id="test1-305123",<br/>        subscription=subscription,<br/>        max_messages=1<br/>    )</span><span id="ec81" class="kr ks hi kn b fi kx ku l kv kw">delete_subscription_task = PubSubDeleteSubscriptionOperator(<br/>        task_id='DeleteSubscription',<br/>        subscription=subscription<br/>    )</span><span id="9406" class="kr ks hi kn b fi kx ku l kv kw">create_subscription_task &gt;&gt; rest_invoke_task &gt;&gt; sensor1_task &gt;&gt; delete_subscription_task</span></pre><p id="9797" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">后端服务将负责在完成长时间运行的工作后发布消息。它将被传递相关id的值，该值应该作为属性包含在消息中。</p><p id="7c44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是这种应用的一个例子。</p><pre class="jp jq jr js fd km kn ko kp aw kq bi"><span id="5601" class="kr ks hi kn b fi kt ku l kv kw"># Sample Flask application that exposes a sample REST service<br/>#<br/># /serve?correlid=???<br/>#</span><span id="ac0f" class="kr ks hi kn b fi kx ku l kv kw">import flask as Flask<br/>import threading<br/>import time<br/>import os<br/>from google.cloud import pubsub_v1</span><span id="8f54" class="kr ks hi kn b fi kx ku l kv kw">app = Flask.Flask(__name__)</span><span id="8c82" class="kr ks hi kn b fi kx ku l kv kw"># Sample long running task that executes for an extended period of time.<br/>def long_running_task(**kwargs):<br/>    correlid = kwargs.get('correlid', {}) # Retrieve the correlid value from the passed in parameters.<br/>    print("Starting long running background task")</span><span id="62ce" class="kr ks hi kn b fi kx ku l kv kw"># Do some busy work for a period of time.<br/>    for i in range(10):<br/>        time.sleep(1)<br/>        print(str(i+1) + " of 10")<br/>    <br/>    # The long running work has been completed, publish an event that the work has completed.<br/>    publisherClient = pubsub_v1.PublisherClient()<br/>    topic_name = publisherClient.topic_path(os.getenv('GOOGLE_CLOUD_PROJECT'), os.getenv('GCP_TOPIC'))<br/>    future = publisherClient.publish(topic_name, b'Work Done!', correlid=correlid)<br/>    future.result()<br/>    # End of long_running_task</span><span id="fe8e" class="kr ks hi kn b fi kx ku l kv kw"># Define the Flask endpoint:  POST /serve?correlid=&lt;CORRELID&gt;<br/><a class="ae kl" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/serve", methods=['POST'])<br/>def serveRequest():<br/>    correlid = Flask.request.args.get('correlid')  # Get the requested Correlid<br/>    print("The Correlid was " + correlid)<br/>    data = Flask.request.data.decode('utf-8')</span><span id="ab63" class="kr ks hi kn b fi kx ku l kv kw"># Start the background thread that runs the long running task<br/>    thread = threading.Thread(target=long_running_task, kwargs={'correlid': correlid})<br/>    thread.start()</span><span id="27ec" class="kr ks hi kn b fi kx ku l kv kw"># Return the response to the REST request.<br/>    return Flask.make_response("Hello {}".format(data), 200)<br/>    # End of serveRequest</span><span id="05ec" class="kr ks hi kn b fi kx ku l kv kw">if __name__ == "__main__":<br/>    print(f"Project: {os.getenv('GOOGLE_CLOUD_PROJECT')}, Topic: {os.getenv('GCP_TOPIC')}, Port: {os.getenv('PORT')}")<br/>    app.run(host='0.0.0.0', port=int(os.environ.get("PORT", 5000)))</span></pre><p id="dbc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包含该解决方案所有构件的GitHub项目可在<a class="ae kl" href="https://github.com/kolban-google/composer-pubsub" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="0d3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以在这里找到一段描述这个故事的短片:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure></div></div>    
</body>
</html>