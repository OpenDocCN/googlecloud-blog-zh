<html>
<head>
<title>Memorystore Redis access through VPC peering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过VPC对等访问内存存储Redis</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/memorystore-redis-access-through-vpc-peering-3bb75e1746d4?source=collection_archive---------2-----------------------#2021-01-25">https://medium.com/google-cloud/memorystore-redis-access-through-vpc-peering-3bb75e1746d4?source=collection_archive---------2-----------------------#2021-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5f03a5e8152a135949458b9c77a544af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fz1YuYPLFjEV3ganlKioGA.png"/></div></div></figure><p id="1f55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一位GCP用户想创建一个附属于VPC的Memorystore Redis。这很容易。然后，用户希望在单独的项目中创建另一个VPC，并让该VPC中的虚拟机访问原始的Memorystore Redis。这能实现吗？如果能，如何实现？</p><p id="767d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章带领我们经历了一个旅程，在这里我们建立了这样一个环境并让它工作。这个故事带我们经历了到达那里的过程，并解释了其中的一些难题。</p><p id="25d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将从一个简单的基本对等网络图开始:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/0647e405169e1ad420ddb9495b680720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*8zQH6_y7Zz6yQNE9"/></div></figure><p id="3bea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们称之为基线。这并不代表我们最终想要的结果，但是让我们看看我们是否能实现这个环境。</p><ul class=""><li id="48a5" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">创建一个名为<code class="du kc kd ke kf b">project-i-1</code>的GCP项目。</li><li id="3cc3" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">删除名为<code class="du kc kd ke kf b">default</code>的VPC网络。</li><li id="a3f0" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">创建一个名为<code class="du kc kd ke kf b">vpc-1</code>的VPC网络。</li><li id="760e" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">vpc-1</code>中创建一个名为<code class="du kc kd ke kf b">subnet-1</code>的子网，IP地址为区域<code class="du kc kd ke kf b">us-central1</code>中的<code class="du kc kd ke kf b">10.1.0.0/16</code>。</li><li id="39e7" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">在附属于属于<code class="du kc kd ke kf b">vpc-1</code>的子网<code class="du kc kd ke kf b">subnet-1</code>的<code class="du kc kd ke kf b">project-i-1</code>中创建一个名为<code class="du kc kd ke kf b">vm-1</code>的虚拟机。在我的例子中，我们发现这被赋予了IP <code class="du kc kd ke kf b">10.1.0.2</code>。</li><li id="9d82" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">创建一个名为<code class="du kc kd ke kf b">project-i-2</code>的GCP项目。</li><li id="08a2" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">删除名为<code class="du kc kd ke kf b">default</code>的VPC网络。</li><li id="34d7" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">创建一个名为<code class="du kc kd ke kf b">vpc-2</code>的VPC网络。</li><li id="ce14" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">vpc-2</code>中创建一个名为<code class="du kc kd ke kf b">subnet-2</code>的子网，IP地址范围为区域<code class="du kc kd ke kf b">us-central1</code>中的<code class="du kc kd ke kf b">10.2.0.0/16</code>。</li><li id="ae16" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">project-i-2</code>中创建一个名为<code class="du kc kd ke kf b">vm-2</code>的虚拟机，连接到属于<code class="du kc kd ke kf b">vpc-2</code>的名为<code class="du kc kd ke kf b">subnet-2</code>的子网。在我的例子中，我们发现这被赋予了IP <code class="du kc kd ke kf b">10.2.0.2</code>。</li><li id="3001" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">project-i-1</code>中创建一个名为<code class="du kc kd ke kf b">vpc-1-to-vpc-2</code>的VPC对等定义，将<code class="du kc kd ke kf b">vpc-1</code>映射到<code class="du kc kd ke kf b">vpc-2</code>。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/58fb953cb2b3671a76b0e1e1330ed174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ip7eTT_znBaGJpK1"/></div></div></figure><ul class=""><li id="518f" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">project-i-2</code>中创建一个名为<code class="du kc kd ke kf b">vpc-2-to-vpc-1</code>的VPC对等定义，将<code class="du kc kd ke kf b">vpc-2</code>映射到<code class="du kc kd ke kf b">vpc-1</code>。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/5a102ed0996b49e984497a64fe43e18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5W3mqt2feK-0RIax"/></div></div></figure><ul class=""><li id="7181" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">检查两个项目中VPC喷丸的状态是否为“活动”。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/c5c4f2d169f16078aad0c24acca210b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H3c_2dtSTO1BzLGV"/></div></div></figure><ul class=""><li id="86a8" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">vpc-1</code>中创建一个防火墙规则，允许来自<code class="du kc kd ke kf b">0.0.0.0/0</code>的SSH端口<code class="du kc kd ke kf b">22</code>进入。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/823972291ea9afde242046367f7a6835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mEtgsINuLA3RNkt9"/></div></div></figure><ul class=""><li id="91bf" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">vpc-2</code>中创建防火墙规则，允许来自<code class="du kc kd ke kf b">10.0.0.0/8</code>的所有端口/协议进入。这包括<code class="du kc kd ke kf b">subnet-1</code>。</li></ul><p id="e120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我们可以SSH到<code class="du kc kd ke kf b">vm-1</code>并对<code class="du kc kd ke kf b">vm-2</code> ( <code class="du kc kd ke kf b">10.2.0.2</code>)执行ping，它将会成功。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/708e8521a7bc844823e38a1073d3683e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/0*1GLS5oCQy8_HEiA8"/></div></figure><p id="0dff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这说明我们有一个从<code class="du kc kd ke kf b">vm-1</code>到<code class="du kc kd ke kf b">vm-2</code>的网络路径，它跨越了项目和VPC。现在是时候扩展我们的故事并添加Memorystore Redis了。</p><ul class=""><li id="b70d" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">为项目<code class="du kc kd ke kf b">project-i-2</code>中的Redis启用Memorystore。</li><li id="7fe7" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">为Redis创建一个Memorystore实例。这在<code class="du kc kd ke kf b">10.34.175.91</code>创建了一个实例。这对你来说可能会有所不同。记下IP以备将来使用。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/5328ae7c72a81e90a9dab0597f738dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G2XX8pFPjUA4J26E"/></div></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/730591807ac288daccd6348d4486c706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-Hoa-3J48ih7JSsv"/></div></div></figure><ul class=""><li id="bad4" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">vpc-2</code>中创建一个防火墙规则，允许来自<code class="du kc kd ke kf b">0.0.0.0/0</code>的SSH(端口<code class="du kc kd ke kf b">22</code>)进入。</li><li id="66b4" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">宋承宪进入<code class="du kc kd ke kf b">vm-2</code>。</li><li id="226b" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">安装Redis命令行界面(CLI)。</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="121f" class="kw kx hi kf b fi ky kz l la lb">sudo apt-get install redis-tools</span></pre><ul class=""><li id="bd70" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">运行Redis cli</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="6e33" class="kw kx hi kf b fi ky kz l la lb">export SERVER=[REDIS-1 IP — 10.34.175.91]<br/>redis-cli -h $SERVER</span></pre><ul class=""><li id="8dfc" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">保存名称/值对。</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="56a8" class="kw kx hi kf b fi ky kz l la lb">set mykey myvalue</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/f1f98325878f3915a3d0def25a9f123f.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/0*4Ift75_RrGMkcOug"/></div></figure><p id="47a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如我们所见，这工作得很好。</p><ul class=""><li id="7a57" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">宋承宪进入<code class="du kc kd ke kf b">vm-1</code>。</li><li id="b041" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">安装Redis命令行界面(CLI)。</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="20e5" class="kw kx hi kf b fi ky kz l la lb">sudo apt-get install redis-tools</span></pre><ul class=""><li id="8a8c" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">运行Redis cli</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="49aa" class="kw kx hi kf b fi ky kz l la lb">export SERVER=[REDIS-1 IP — 10.34.175.91]<br/>redis-cli -h $SERVER</span></pre><p id="62a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">失败</strong>。我们似乎没有从连接到<code class="du kc kd ke kf b">vpc-1</code>的虚拟机到<code class="du kc kd ke kf b">10.34.175.91</code>的路径。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/d358b6cb1f0d90d276215423cc8e2cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w6qhZwYMifQVk0bx"/></div></div></figure><p id="5a33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看这个故事能不能解释。回顾一下，我们看到<code class="du kc kd ke kf b">vm-2</code>可以连接到Redis，但<code class="du kc kd ke kf b">vm-1</code>不能。先问为什么我们认为<code class="du kc kd ke kf b">vm-1</code> <em class="le">可能</em>能够连接Redis？我们有一种直觉，它可能会工作，因为<code class="du kc kd ke kf b">vpc-1</code>和<code class="du kc kd ke kf b">vpc-2</code>是对等的。这告诉我们的是，附属于<code class="du kc kd ke kf b">vpc-1</code>的事物有一个网络路径连接到<code class="du kc kd ke kf b">vpc-2</code>的事物。我们已经证明了，我们可以从<code class="du kc kd ke kf b">vm-1</code>ping<code class="du kc kd ke kf b">vm-2</code>。当我们创建Redis实例时，我们将<code class="du kc kd ke kf b">vpc-2</code>命名为允许向Redis发出请求的VPC。如果我们查看Redis服务器描述的输出，我们会看到一个名为<code class="du kc kd ke kf b">authorizedNetwork</code>的条目，它命名为<code class="du kc kd ke kf b">vpc-2</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/765e756f1f1e3801fc3a3b6ffd318787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M4QpYID3oepyeOrX"/></div></div></figure><p id="e05f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可能会让我们认为Redis连接到了<code class="du kc kd ke kf b">vpc-2</code>，并且<code class="du kc kd ke kf b">vpc-1</code>和<code class="du kc kd ke kf b">vpc-2</code>是对等的，因此连接到<code class="du kc kd ke kf b">vpc-1</code>的虚拟机应该能够到达Redis。不幸的是，故事没那么简单。如果我们深入挖掘，我们会发现Redis实际上连接到它自己的私有的<em class="le">未命名的</em> VPC，并且当我们创建Redis实例时，它实际上在Redis未命名的VPC和Redis所连接的VPC(在本例中为<code class="du kc kd ke kf b">vpc-2</code>)之间创建了一个VPC对等。</p><p id="8c59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个更合适的图表应该是这样的:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/b5811218e525497d0fa19754120dc5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NOHbWdfJdSRZWbZC"/></div></div></figure><p id="6477" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这充分解释了为什么<code class="du kc kd ke kf b">vm-2</code>能够访问Redis。名为<code class="du kc kd ke kf b">vpc-2</code>的VPC与Redis使用的未命名的VPC是对等的。由于<code class="du kc kd ke kf b">vm-2</code>附属于<code class="du kc kd ke kf b">vpc-2</code>，它与Redis VPC有对等连接，因此也与Redis本身有对等连接。</p><p id="5b51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还有最后一个概念… VPC对等是<em class="le">不</em>可传递的。尽管<code class="du kc kd ke kf b">vpc-2</code>与VPC Redis对等，<code class="du kc kd ke kf b">vpc-1</code>与<code class="du kc kd ke kf b">vpc-2</code>对等，但这并不意味着<em class="le">不是</em>与VPC Redis对等。此处记录了这种缺乏过渡性的情况<a class="ae lh" href="https://cloud.google.com/vpc/docs/vpc-peering#restrictions" rel="noopener ugc nofollow" target="_blank">。在那里，我们将发现以下内容:</a></p><blockquote class="li lj lk"><p id="10f5" class="iq ir le is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated">只有直接对等的网络才能通信。不支持可传递对等。换句话说，如果VPC网络N1与N2和N3对等，但是N2和N3没有直接连接，VPC网络N2不能通过VPC网络对等与VPC网络N3通信。</p></blockquote><p id="eb40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们无法从<code class="du kc kd ke kf b">vm-1</code>连接到Redis的一个看似合理的原因。这是否意味着我们根本<em class="le">不能</em>从<code class="du kc kd ke kf b">vm-1</code>连接到Redis？是和不是。我们不能直接连接，但我们可以通过一个简单的代理连接。我们的高层次故事将是在<code class="du kc kd ke kf b">vpc-2</code> VPC创建一个低端计算引擎。因为这个计算引擎连接到了<code class="du kc kd ke kf b">vpc-2</code> VPC，所以它可以直接访问Redis服务器。在这个计算引擎上，我们将安装名为<a class="ae lh" href="https://github.com/twitter/twemproxy" rel="noopener ugc nofollow" target="_blank">胡桃夹子</a>的开源包。胡桃夹子是一个认识Redis的代理。它将接收传入的Redis请求，并有效地将这些请求转发给Redis服务器。由于代理计算引擎<em class="le">只是</em>一个附属于<code class="du kc kd ke kf b">vpc-2</code>的计算引擎，它将对任何对等于<code class="du kc kd ke kf b">vpc-2</code>的其他VPC可用，在我们的故事中，这将包括<code class="du kc kd ke kf b">vpc-1</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/6ee27c29757c0668e51bf3713cf24079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mdNIfWRflPOM7XOj"/></div></div></figure><ul class=""><li id="4498" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">在附属于属于<code class="du kc kd ke kf b">vpc-2</code>的子网<code class="du kc kd ke kf b">subnet-2</code>的<code class="du kc kd ke kf b">project-i-2</code>中创建一个名为<code class="du kc kd ke kf b">redis-proxy</code>的虚拟机。在我的例子中，我们发现这被赋予了IP <code class="du kc kd ke kf b">10.2.0.3</code>。</li><li id="7dda" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">宋承宪进入<code class="du kc kd ke kf b">redis-proxy</code>。</li><li id="139c" class="jt ju hi is b it kg ix kh jb ki jf kj jj kk jn jy jz ka kb bi translated">安装<a class="ae lh" href="https://github.com/twitter/twemproxy" rel="noopener ugc nofollow" target="_blank">胡桃夹子</a>。</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="e7b1" class="kw kx hi kf b fi ky kz l la lb">sudo apt-get update<br/>sudo apt-get install nutcracker</span></pre><ul class=""><li id="0499" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">创建名为<code class="du kc kd ke kf b">nutcracker.yaml</code>的胡桃夹子配置文件。</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="1181" class="kw kx hi kf b fi ky kz l la lb">redis-1:<br/> listen: 0.0.0.0:6379<br/> redis: true<br/> servers:<br/> - [REDIS-1 IP]:6379:1</span></pre><ul class=""><li id="0807" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">启动胡桃夹子应用程序。</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="c41c" class="kw kx hi kf b fi ky kz l la lb">sudo nutcracker --conf-file nutcracker.yaml</span></pre><ul class=""><li id="b055" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated">在<code class="du kc kd ke kf b">vm-1</code>上，运行指向<code class="du kc kd ke kf b">redis-proxy</code>的Redis命令。</li></ul><pre class="jp jq jr js fd ks kf kt ku aw kv bi"><span id="b549" class="kw kx hi kf b fi ky kz l la lb">export SERVER=10.2.0.3<br/>redis-cli -h $SERVER<br/>get mykey</span></pre><p id="c49c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个测试成功了，把我们带到了故事的结尾。我们现在已经实现了与一个Memorystore Redis实例的交互，该实例被定义为一个VPC，它与托管Redis客户端应用程序的另一个VPC对等。</p><p id="39e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可能会考虑其他可能性来实现我们的功能目标，其中的核心是使用共享VPC的想法，并在主机项目中创建我们的Memorystore Redis，并通过服务项目使其可用。</p><p id="44d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为本文的配套，这里有一个视频演示了这里描述的故事:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure></div></div>    
</body>
</html>