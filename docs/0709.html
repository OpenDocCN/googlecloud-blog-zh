<html>
<head>
<title>Kubernetes: Run A Pod Per Node With Daemon Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:用守护进程集在每个节点上运行一个Pod</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-run-a-pod-per-node-with-daemon-sets-f77ce3f36bf1?source=collection_archive---------0-----------------------#2018-08-01">https://medium.com/google-cloud/kubernetes-run-a-pod-per-node-with-daemon-sets-f77ce3f36bf1?source=collection_archive---------0-----------------------#2018-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="32a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最初给这篇文章起的名字是“守护进程集”,并假设它足以让任何对阅读感兴趣的人理解这一点。但是很快我回想起我第一次在Kubernetes文档中看到Daemon Sets的时候，想起了我自己的好奇心和对这个主题的矛盾心理。然而，在某些情况下，守护进程集将使您摆脱非常特定的束缚。让我们探索更多。</p><p id="d5a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我们已经知道Kubernetes是在节点上运行的pod的混合物。很简单。但是，不保证一个pod将运行在哪个节点上，也不保证pod在节点上的间距是一致的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/484e3447d2676578be6585877b8f2031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWayD3oN336wmBd9uQzb0Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">没有节点到豆荚的承诺…直到恶魔集</figcaption></figure><p id="e1b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要将一个Pod与一个节点进行一对一绑定(例如<strong class="ih hj">监控或记录</strong> Pod ),那么您如何保证会有必要的Pod到节点布局呢？守护进程集，就是这样。守护进程集为创建的每个节点创建一个Pod。因此，如果一个新节点启动，守护进程集的Pod也将在该节点上运行。如果删除了一个节点，属于该节点的守护程序集的pod也会被删除。</p><p id="390b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看如何定义一个守护进程集，并看看它是如何工作的。</p><p id="9290" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt">如果您没有通读甚至没有阅读过本系列</em>  <em class="jt">的第一部分，您可能会对这段代码在哪里或者之前做了什么产生疑问。记住这里假设你正在使用</em><a class="ae ju" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a><em class="jt">和</em><a class="ae ju" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a><em class="jt">。</em></p><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-day-one-30a80b5dcb29"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:第一天</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ki l kj kk kl kh km jn jy"/></div></div></a></div><h1 id="c02e" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建Kubernetes守护进程集</h1><p id="89eb" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">如果你通读了我的其他一些帖子(你应该！)，下面这个yaml文件在别人看来是很熟悉的。您会注意到<code class="du lq lr ls lt b">.metadata</code>部分，就像您之前看到的一样，还有<code class="du lq lr ls lt b">.spec</code>部分。让守护进程与众不同的是<code class="du lq lr ls lt b">.kind</code>参数。如果设置为<code class="du lq lr ls lt b">Daemon Set</code>，那么Kubernetes将在您的Kubernetes集群中的每个节点下自动创建<code class="du lq lr ls lt b">.spec.template</code>中描述的Pod。</p><pre class="je jf jg jh fd lu lt lv lw aw lx bi"><span id="d3ae" class="ly ko hi lt b fi lz ma l mb mc"><strong class="lt hj">apiVersion: apps/v1<br/>kind: DaemonSet</strong> # it is a daemonset<br/><strong class="lt hj">metadata:<br/>  name: daemonset-pods</strong> # name of the daemon set<br/>  <strong class="lt hj">labels:</strong><br/>    # any Pods with matching labels are included in this Daemon Set<br/>    <strong class="lt hj">app: kubernetes-series<br/>    tier: monitor</strong><br/><strong class="lt hj">spec:<br/>  selector:</strong><br/>    # Pods will match with the following labels<br/>    <strong class="lt hj">matchLabels:<br/>      name: daemonset-pods<br/>  template:</strong><br/>    # Pod Template<br/>    <strong class="lt hj">metadata:</strong><br/>      # Pod's labels<br/>      <strong class="lt hj">labels:<br/>        name: daemonset-pods<br/>    spec:</strong><br/>      # the container(s) in this Pod<br/>      <strong class="lt hj">containers:<br/>        - name: daemon-container<br/>          image: gcr.io/PROJECT_NAME/daemon-container-daemon:latest</strong><br/>          # environment variables for the Pod<br/>          env:<br/>          <strong class="lt hj">- name: GCLOUD_PROJECT<br/>            value: PROJECT_NAME<br/>          ports:<br/>          - containerPort: 80</strong></span></pre><h1 id="207f" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">Kubernetes守护进程开始运行</h1><p id="5ee2" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">为了测试DaemonSet，我们将从创建我们的Kubernetes集群开始，正如我们在以前的许多文章中所做的那样。以下脚本在您的Google Cloud Shell中运行时，将创建一个Kubernetes集群，并将守护进程集yaml文件部署到您的集群。</p><pre class="je jf jg jh fd lu lt lv lw aw lx bi"><span id="f687" class="ly ko hi lt b fi lz ma l mb mc">$ git clone <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series.git" rel="noopener ugc nofollow" target="_blank">https://github.com/jonbcampos/kubernetes-series.git</a><br/>$ cd <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/tree/master/daemon/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/daemon/scripts</a><br/>$ sh <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/blob/master/daemon/scripts/startup.sh" rel="noopener ugc nofollow" target="_blank">startup.sh</a><br/>$ sh <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/blob/master/daemon/scripts/deploy.sh" rel="noopener ugc nofollow" target="_blank">deploy.sh</a><br/>$ sh <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/blob/master/daemon/scripts/check-endpoint.sh" rel="noopener ugc nofollow" target="_blank">check-endpoint.sh</a> endpoints</span></pre><p id="a5cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是，这是Kubernetes中的一个3节点集群。这很重要，因为一旦您运行部署脚本，您就可以在您的<code class="du lq lr ls lt b">GCP Kubernetes &gt; Workloads</code>视图中看到您将部署一个名为<code class="du lq lr ls lt b">daemonset-pods</code>的守护程序集Pod，具体来说是其中的3个。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/421a98b72a35425323508776a7806725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIrIGy0T8Ns8pQA07a5AGQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">部署在3个节点上的3个daemon set-pod</figcaption></figure><p id="f40f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我创建了一个非常粗糙的脚本，通过X个节点来扩展集群。您可以这样运行该脚本:</p><pre class="je jf jg jh fd lu lt lv lw aw lx bi"><span id="13f2" class="ly ko hi lt b fi lz ma l mb mc">$ cd <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/tree/master/daemon/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/daemon/scripts</a><br/>$ sh <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/blob/master/daemon/scripts/scale.sh" rel="noopener ugc nofollow" target="_blank">scale.sh</a> <strong class="lt hj">3</strong> # scale up by 3 nodes</span></pre><p id="226f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个脚本添加了一个名为<code class="du lq lr ls lt b">my-pool</code>的节点池，并告诉节点池向集群添加X个(本例中为3个)节点。如果您返回到您的工作流视图，您会立即看到新节点正在旋转…守护程序集的窗格也是如此。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/ad1f95abfb70978339a64cc6db5ae30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4OxGUFQJ2Jlveo4QRViQA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">最多可旋转6个节点和单元</figcaption></figure><p id="9de9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一切准备就绪后，我们的Kubernetes集群正式处于6个节点，有6个守护程序集单元，仍然是原来的3个<code class="du lq lr ls lt b">endpoints</code>单元。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/2c80fe196d74905873fffc90ca891488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuXWbZu8mN4-2DVtCQl-9g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">6/6节点到机架</figcaption></figure><h1 id="e38c" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="fa2f" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">看到Kubernetes如此轻松地处理一个问题，同时让您能够灵活地解决特定于您的应用程序的问题，总是一件美妙的事情。现在，您可以看到如何基于节点调度Pod，而不是Kubernetes默认的随机的Pod到节点分配。</p><h1 id="c890" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">拆卸</h1><p id="3a77" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">在您离开之前，请确保清理您的项目，这样您就不会为您用来运行群集的虚拟机付费。返回到云Shell并运行teardown脚本来清理您的项目。这将删除您的集群和我们构建的容器。</p><pre class="je jf jg jh fd lu lt lv lw aw lx bi"><span id="8f29" class="ly ko hi lt b fi lz ma l mb mc">$ cd <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/tree/master/daemon/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/daemon/scripts</a><br/>$ sh <a class="ae ju" href="https://github.com/jonbcampos/kubernetes-series/blob/master/daemon/scripts/teardown.sh" rel="noopener ugc nofollow" target="_blank">teardown.sh</a></span></pre></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="be0a" class="kn ko hi bd kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg mr li lj lk bi translated">本系列的其他文章</h1><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-cron-jobs-455fdc32e81a"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">库伯内特:克朗·乔布斯</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">有时候你的工作不是事务性的。我们不再等待用户点击按钮让系统亮起来…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ms l kj kk kl kh km jn jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-dns-proxy-with-services-d7d9e800c329"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:带服务的DNS代理</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">构建应用程序时，通常需要与外部服务进行交互来完成业务…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="mt l kj kk kl kh km jn jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-routing-internal-services-through-fqdn-d98db92b79d3"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:通过FQDN路由内部服务</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">我记得当我第一次进入Kubernetes时。一切都是崭新的、闪亮的、有规模的。当我继续的时候…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="mu l kj kk kl kh km jn jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-horizontal-pod-scaling-190e95c258f5"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:水平Pod缩放</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">通过Pod自动扩展，您的Kubernetes集群可以监控现有Pod的负载，并确定我们是否需要更多…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="mv l kj kk kl kh km jn jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a href="https://itnext.io/kubernetes-readiness-probe-83f8a06d33d3" rel="noopener  ugc nofollow" target="_blank"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:就绪探测</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">如果对这个特性有任何疑问，我写这篇文章是为了说明这不是一个…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">itnext.io</p></div></div><div class="kh l"><div class="mw l kj kk kl kh km jn jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-liveness-checks-4e73c631661f"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:活性检查</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">最近，我整理了一篇关于Kubernetes就绪性调查以及它对您的集群有多重要的文章…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="mx l kj kk kl kh km jn jy"/></div></div></a></div></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="3065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jonathan Campos 是一个狂热的开发者，也是学习新事物的爱好者。我相信我们应该不断学习、成长和失败。我总是开发社区的支持者，并且总是愿意提供帮助。因此，如果你对这个故事有任何问题或意见，请在下面提出。在<a class="ae ju" href="https://www.linkedin.com/in/jonbcampos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae ju" href="https://twitter.com/jonbcampos" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，并提及这个故事。</p></div></div>    
</body>
</html>