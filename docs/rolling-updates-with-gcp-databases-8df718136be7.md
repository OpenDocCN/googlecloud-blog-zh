# GCP 数据库滚动更新

> 原文：<https://medium.com/google-cloud/rolling-updates-with-gcp-databases-8df718136be7?source=collection_archive---------0----------------------->

@alexlatchford 在阅读了我的 GCP A to Z 系列中关于[滚动更新](/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-r-rolling-updates-fb6634c5f400#.squ70w7np)的帖子后，问我关于数据存储滚动更新的问题。因为我不能简单地提供一个简洁的回复作为评论，所以我的回答如下。(很抱歉迟迟未能扭转局面😀)

数据库就其本质而言是有状态的(是的，我知道在内存数据存储中，但你只是在卖弄学问😃)通常，在进行滚动更新时，您仍然希望一段时间内积累的数据可用，以便更新后的应用程序可以访问这些数据。

如果可能的话，通过使用间接接口来抽象对数据库的调用。这可以使用一个 [ORM](https://en.wikipedia.org/wiki/Object-relational_mapping) ， 我在这里谈到的[包装器](/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-w-wrappers-f5618cbce672#.t1wivet59)是的，你可以考虑使用 NoSQL 存储来减少改变模式的摩擦，因为毕竟这篇文章是关于滚动更新以及当你有一个有状态数据存储时如何处理它们，因此暗示我在谈论改变模式和添加或删除数据，就是调整你的数据库表中的列在关系数据库中的样子， 调整模式，以便您可以添加额外的数据，比如像 BigQuery 数据集或只是将“不同”类型的数据添加到您的“无模式”数据存储中

# 关系数据库

我完全理解在某些情况下，尤其是在关系数据库中，您希望使用存储过程并直接调用数据库，但是由于紧密耦合，做出这种选择确实会使滚动更新更难实现，您需要仔细考虑您的策略来解决这些用例，例如，如果您使用存储过程，可以通过对存储过程进行版本控制来实现。

您应该在更新前端之前对数据库进行更改，所以这基本上意味着您希望添加新的列和表，作为更改对该数据库的调用的第一步。如果需要，可以运行一个脚本，向新的列和表中添加额外的数据，然后确保数据保持同步，方法可能是在更新原始表时对它们使用触发器，直到您准备好更新前端应用程序并对数据库调用进行更改，以反映此时作为主要目标的新列或表。如果添加了额外的列，那么回滚到旧的代码集不会有太大问题，因为旧的列仍然存在(但是这意味着无论是什么问题导致了回滚，前滚时都要重新同步)。

添加新表后回滚我建议在一段时间内继续写回旧表，直到你满意更新进行得很顺利，在以后的更新中停止写回旧表，然后最终删除它。

那么，您实际上如何很好地实现这些更改呢？这取决于它们是什么以及您正在使用的实际数据库引擎。下面我列出了当你需要避免停机时处理数据库变化的 3 种方法。

添加列-。有些系统在这样做时可能会锁定，但是有一些解决方案允许您在不锁定列的情况下添加列。因为这是一个新的专栏，所以旧代码仍然有效。

更改列类型-创建与现有列具有相同模式的新表，但使用新的列类型。

一个很好的基于 ruby 的解决方案是 [this](https://github.com/soundcloud/lhm) ,它可以用来对大型表进行就地 MySQL 更改，是在线 ActiveRecord 迁移的瑰宝

对于**大型**关系数据库更改—备份和恢复到新数据库，对新目标进行修改，并在新数据库中重放您需要的事务，提交更改。

# 无模式数据库

现在这是一个很大的领域，我要简洁地跳过大部分，否则我永远不会完成这篇文章！

无模式或者如果你喜欢无 SQL 数据存储，但是让我们同意(或者同意不同意)无模式倾向于意味着动态类型化，因为有一个模式，即使它不像传统的 SQL 模式那样静态和预定义。不要被误导了，你可以直接把数据塞进去，而不去想模式就在那里等着你！

为较小的变化更新无模式数据库可能比处理关系数据库更容易。我为什么要说这个？让我们为一个销售从书籍到自行车的所有商品的网上购物网站想一个产品目录来帮助阐明这种说法。

对于关系数据库，当您在单独的表中为每种类型的产品建模时，您可能最终会得到一个连接丛林，或者有一个包含许多空值的表定义，因为例如自行车没有 ISBN 号，书籍没有框架类型。因此，要添加一个新产品，需要对数据库进行基本的更改，并暗示应用程序也要进行基本的更改，如上所述。

在无模式数据存储中，产品的“主体”或“细节”可以不同，这允许您只将不同的属性添加到现有的数据存储中，而不用担心现有的数据和模式定义，因为它们不会受到添加子模式或扩展模式的影响，从而允许您为新产品类型添加新的数据属性。这是一个非常非常简单的解释，但是我真的不想因为深入研究您可以处理的每个 no SQL/无模式数据库而偏离主题。如果您不熟悉无模式数据存储的建模数据，可以“google”来深入研究这一领域。这里的关键是，你的应用程序现在必须能够编写或检索每个产品的各种“主体”或“细节”,以及指示产品是什么以及需要向最终用户显示什么的键和标识符，这样你就可以采用一些技术来更新你的应用程序，作为滚动更新的一部分，我在这里[讨论过](/google-cloud/a-to-z-of-google-cloud-platform-a-personal-selection-r-rolling-updates-fb6634c5f400#.squ70w7np)

但是，如果您真的想对“核心”模式进行大的修改，那么您可能会发现这比对关系数据库进行同样的修改要困难得多，因为工具通常不太先进或不太容易使用(这是我的个人观点，我很确定有很多人对他们的无模式数据库有不同的看法)

基本上，添加列和数据集比删除数据或进行需要新数据库的重大更改更容易处理。这些问题不会因为您使用无模式数据库而消失！

# GCP 管理的数据库

由于这个“回复”有点长，我将假设您对 GCP 托管数据存储有基本的了解，如果没有，那么看看下面讨论的每个数据库的概念文档是获得基本了解的好方法。

## [BigQuery](https://cloud.google.com/bigquery/docs/concepts)

每个 BigQuery 表都有一个模式。BigQuery 允许您通过在末尾添加可空的或重复的列并使必需字段可空来更新模式。

[BigQuery 表](https://cloud.google.com/bigquery/docs/tables)仅可更新，因此您只能将数据追加到现有的表中，因此如果您需要更新或删除数据，您必须删除该表，然后用新数据重新创建该表。或者，您可以编写一个查询来修改数据并指定一个新的结果表。

## [数据存储](https://cloud.google.com/datastore/docs/concepts)

数据存储是无模式的，如上所述，这意味着您可以拥有具有不同属性的同类实体。

关于对数据存储库进行更新，GCP 有一些很棒的说明性建议

[此处](https://cloud.google.com/appengine/articles/update_schema)。Objectify 有一个[工具](https://github.com/objectify/objectify/wiki/SchemaMigration)来帮助它，它很好地反映了我在这篇文章前面概述的步骤，所以它涵盖了能够更新/创建一个新的模式，并在两者之间保持数据同步，直到您愿意单独运行更新的数据存储。

## [BigTable](https://cloud.google.com/bigtable/docs/concepts)

BigTable 将数据存储在大规模可伸缩的表中，每个表都是一个排序的键/值映射。该表由*行*和*列*组成，每一行通常描述一个实体，每一列包含每一行的单独值。每一行都由一个单独的*行键*索引，相互关联的列通常被组合成一个*列族*。每个列由列族和一个*列限定符*的组合来标识，该限定符是列族中的唯一名称。BigTable 与 Hbase api 兼容，使用 hbase shell 是管理表的最简单方法。遵循我在这里一直重复的关于在一段时间内保持旧数据结构和新数据结构的原则仍然适用。

# Kubernetes，持久状态和滚动更新

当我被特别问到关于 kubernetes 和数据库的滚动更新时，我会简单地回答一下。我必须首先解决实际的数据存储更新，这个回复帖子可能不太符合预期，对此我很抱歉，但我没有忘记🙂。

在 Kubernetes 1.3 中，“宠物集”的引入在某种程度上解决了处理像数据库这样的有状态服务的需求。

从文件中引用:

" *Pet Sets 是一个新特性，它提供了在 Kubernetes 内部部署容器(如宠物)的能力。Pet Sets 为 pet / pod 部署的各个方面提供了身份保证:DNS 名称、一致的存储和有序的 pod 索引。*

那么这到底意味着什么呢？

本质上是运行有状态工作负载的能力，那么数据库呢？

文件称这些是工作负载示例:

*   *像 Cassandra，Zookeeper，etcd，或者 Elastic 这样的集群软件，需要稳定的成员关系。*
*   【MySQL 或 PostgreSQL 等数据库需要在任何时候将单个实例连接到持久卷。

是的，数据库很好！

在此版本之前，您可以运行这些工作负载，但它要复杂得多，Pet Sets 旨在使管理这些有状态工作负载变得更容易，因为它提供了任何有状态分布式数据库工作负载都会发现非常有用的功能。

使用 Pet Set 并不是这种方法的全部，使用它来管理有状态服务有一些限制，这些限制记录在发布说明的 [Pet Set alpha 限制部分。最明显的是，“*更新现有的宠物集目前是一个手动过程，这意味着您要么需要使用新的映像版本部署新的宠物集，要么逐个孤立宠物，更新它们的映像，然后将它们重新加入集群”*在文档中，它还在](https://github.com/kubernetes/kubernetes.github.io/blob/release-1.3/docs/user-guide/petset.md#alpha-limitations)[中说明了何时使用宠物集](https://github.com/kubernetes/kubernetes.github.io/blob/release-1.3/docs/user-guide/petset.md#when-to-use-pet-set)部分"*仅当您的应用程序需要这些属性中的部分或全部时才使用宠物集()。将 pod 作为无状态副本进行管理要容易得多。”这可能是显而易见的，但我觉得值得重申*

这也可以在 alpha 限制部分找到:

*“目前所有的宠物都需要一个“管理服务”，或者一个负责宠物网络身份的服务。用户对此服务负责。*

*更新现有的宠物集目前是一个手动过程，这意味着您要么需要使用新的映像版本部署一个新的宠物集，要么一个接一个地孤立宠物，更新它们的映像，然后将它们重新加入集群。*

因此，我前面谈到的关于在进行滚动部署之前更新各种数据库类型的所有内容仍然适用。

公平地说，这是一个 alpha 版本，对于宠物套装来说还为时过早，阅读这些评论时应该记住这一点。

就我个人而言，我倾向于在 kubernetes 之外管理有状态的数据存储，因为这样更干净，抽象层次更少，尽管我确实同意，对于集群感知设置，如果您有足够的操作资源来轻松管理它，在 kubernetes 上部署会有一些优势(如果您继续阅读，我会在下面链接到几个这样做的示例)

对于具有简单数据库配置的简单设置来说，这很好，因为您可以在不增加太多复杂性的情况下利用这一点，但是任何不太简单的事情，我都会说不，这不是正确的做法。如果您有一些技术熟练的员工，他们有时间来管理这种设置，这很好，但有一个原因是托管数据库可以使事情变得更简单，这样您就可以专注于重要的事情，而不是转移资源来照看有大量旋钮和按钮的堆栈，这意味着在进行故障诊断时要检查大量旋钮和按钮。不管发生什么情况，东西总是会失败，所以你需要知道如何跟踪堆栈中的错误并修复它们，这可能会由于通过分布式容器编排设置来管理数据库而变得复杂(不管你使用什么工具，我都会这么说)。

GKE(云平台管理的 kubernetes 服务)还没有更新到 1.3，但如果尽管如此，你仍然想在 Kubernetes 上运行你的粗糙的旧分布式数据库，至少通过等到 GKE 支持 1.3 时，它的 alpha 版来减少操作开销。使用 GKE 将会为你处理很多 Kubernetes 的基本操作，至少你的操作开销会减少。

在你等待这一切发生的时候，这里有几个有趣的帖子是关于用 docker & kubernetes 、 [cassandra 使用 kubernetes](https://github.com/kubernetes/kubernetes/tree/release-1.3/examples/cassandra) 在 kubernetes [mongodb 上建立数据库的](https://www.mongodb.com/blog/post/running-mongodb-as-a-microservice-with-docker-and-kubernetes)

我怀疑，随着 Kubernetes 在运行有状态工作负载方面变得更加成熟，特别是 GKE 从中抽象出更多的细节，我的立场将会改变。但是今天我知道我站在哪一边了。我在这里的想法实际上适用于在任何分布式容器设置中运行有状态工作负载，您基本上需要自己管理这些工作负载。我在这里把重点放在 Kubernetes 上，因为这是促使这篇文章的原因！