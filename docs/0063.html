<html>
<head>
<title>MongoDB Replica Sets with Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Kubernetes的MongoDB副本集</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/mongodb-replica-sets-with-kubernetes-d96606bd9474?source=collection_archive---------0-----------------------#2016-02-08">https://medium.com/google-cloud/mongodb-replica-sets-with-kubernetes-d96606bd9474?source=collection_archive---------0-----------------------#2016-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="262a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj">这篇博文现在已经过时了！请查看更新版本</strong></p><p id="5409" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><a class="ae jh" href="http://blog.kubernetes.io/2017/01/running-mongodb-on-kubernetes-with-statefulsets.html" rel="noopener ugc nofollow" target="_blank"><strong class="il hj">http://blog . kubernetes . io/2017/01/running-MongoDB-on-kubernetes-with-stateful sets . html</strong></a></p></blockquote></div><div class="ab cl ji jj gp jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="hb hc hd he hf"><p id="c378" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">如果你关注了我的前两篇文章(<a class="ae jh" href="http://blog.sandeepdinesh.com/2015/07/running-mean-web-application-in-docker.html" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae jh" rel="noopener" href="/google-cloud/running-a-mean-stack-on-google-cloud-platform-with-kubernetes-149ca81c2b5d#.bjsnequp5"> 2 </a>)，你就成功地用Docker容器建立并运行了一个MEAN stack，并用Kubernetes使它可扩展。最终，我们得到了如下所示的服务堆栈:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="ab fe cl jx"><img src="../Images/fd47064b3cd7cf91aaf365538b0690df.png" data-original-src="https://miro.medium.com/v2/0*1oQV7CKeUSrUWt79."/></div></figure><p id="b875" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">今天，我想把重点放在栈的MongoDB数据库层。我假设你熟悉Kubernetes的核心概念；如果没有，你应该看看我以前的博客帖子。</p><p id="40ce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">使用Kubernetes，数据库系统比标准的单实例MongoDB设置更加健壮。如果MongoDB实例死亡，Kubernetes将自动构建一个新的实例。</p><p id="2b85" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">然而，这意味着我们将有几秒到几分钟的停机时间，而一个新的吊舱旋转起来。此外，如果数据遭到破坏(这不太可能，但有可能)，就没有备份。</p><p id="828b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">您可以通过运行一个<a class="ae jh" href="https://docs.mongodb.org/manual/core/replication-introduction/" rel="noopener ugc nofollow" target="_blank"> MongoDB副本集</a>来解决这个问题。但是在Kubernetes上怎么做呢？</p><p id="86fc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">只需一个简单的命令，就可以轻松扩展web pods:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="be3a" class="kf kg hi kb b fi kh ki l kj kk">$ kubectl scale rc web — replicas=5</span></pre><p id="86eb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">然而，扩展数据库要复杂得多。</p><p id="38e0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><em class="ik">注意:如果你对MySQL感兴趣，可以看看YouTube上的一个OSS项目</em><a class="ae jh" href="http://vitess.io/" rel="noopener ugc nofollow" target="_blank"><em class="ik">Vitess</em></a><em class="ik">，它可以让你在Kubernetes上运行一个自动分片的MySQL集群。</em></p><h1 id="d12b" class="kl kg hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">为什么扩展数据库很困难？</h1><p id="b21f" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jp lk iw ix jq ll ja jb jr lm je jf jg hb bi translated">如果你只是想学习如何做，跳过这一节。</p><p id="c5f6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">与web窗格不同，数据库窗格附加了一个gcePersistentDisk。如果您尝试扩展复制控制器，所有的pod将尝试装载同一个磁盘，这是不可能的。即使这是可能的(使用网络驱动器)，这也不是一件好事，因为一个实例中的数据损坏会破坏整个集合，并且I/O速度会非常慢。</p><p id="e2b6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">每个MongoDB pod都需要自己的gcePersistentDisk，这意味着每个pod都需要自己的复制控制器。每个pod还需要找到副本集的其他成员并注册自己。所有这些都需要自动化。</p><h1 id="0f93" class="kl kg hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">步骤0:清理(可选)</h1><p id="fcce" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jp lk iw ix jq ll ja jb jr lm je jf jg hb bi translated">如果前一篇博客文章中的复制控制器和服务仍在运行，要么创建一个新的集群，要么删除它们。</p><h1 id="3f3b" class="kl kg hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">步骤1:创建副本集</h1><p id="4c7a" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jp lk iw ix jq ll ja jb jr lm je jf jg hb bi translated">通常，你可以按照这些文档来创建一个副本集。这包括登录每个实例、运行几个命令和硬编码IP地址，这些在Kubernetes集群中都不好。</p><p id="9b94" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">幸运的是，你不需要做任何事情。</strong></p><p id="4461" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">我们将使用一个“边车”来自动配置我们的副本集。如您所知，一个pod可以包含多个容器。边车是帮助“主”容器的容器。在这种情况下，我们的sidecar将自动发现和配置我们的副本集，并配置主MongoDB容器。</p><p id="2ceb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">副本集将被称为:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="20c5" class="kf kg hi kb b fi kh ki l kj kk">rs0</span></pre><p id="d20f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">首先下载代码:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="4f3a" class="kf kg hi kb b fi kh ki l kj kk">$ git clone <a class="ae jh" href="https://github.com/leportlabs/mongo-k8s-sidecar.git" rel="noopener ugc nofollow" target="_blank">https://github.com/leportlabs/mongo-k8s-sidecar.git</a></span></pre><p id="3fca" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">现在转到示例目录:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="cba4" class="kf kg hi kb b fi kh ki l kj kk">$ cd mongo-k8s-sidecar/example/</span></pre><p id="cd9b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">在那里，您将找到一个Makefile，它将管理MongoDB副本集。</p><p id="7ac3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">要了解集群中当前有多少MongoDB副本，请运行:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="cbff" class="kf kg hi kb b fi kh ki l kj kk">$ make count</span></pre><p id="700f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">您应该会看到以下输出:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="eb57" class="kf kg hi kb b fi kh ki l kj kk">Current Number of MongoDB Replicas: 0</span></pre><p id="318f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">如果您没有看到这一点，请确保您的kubectl工具正在工作。</p><p id="88ac" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">现在，让我们添加一个副本:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="b589" class="kf kg hi kb b fi kh ki l kj kk">$ make add-replica DISK_SIZE=200GB ZONE=us-central1-f</span></pre><p id="6261" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">用集群的区域替换us-central1-f。</strong></p><p id="8f62" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">这将创建一个新磁盘来存储您的数据，然后启动一个复制控制器，该控制器将启动一个MongoDB实例和一个映射到这个新实例的服务。</p><p id="aa8d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">现在，运行:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="d097" class="kf kg hi kb b fi kh ki l kj kk">$ make count</span></pre><p id="373c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">您应该会看到以下内容:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="e7f8" class="kf kg hi kb b fi kh ki l kj kk">$ Current Number of MongoDB Replicas: 1</span></pre><p id="cde2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">太棒了。现在再创建两个实例(只需再次运行相同的make add-replica命令)。最佳做法要求奇数个副本，标准数量是三个。</p><p id="ae5e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">现在，您已经设置并运行了一个三实例复制副本！</p><p id="6f0a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">要删除复制副本，只需运行:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="1395" class="kf kg hi kb b fi kh ki l kj kk">$ make delete-replica</span></pre><blockquote class="if ig ih"><p id="adfc" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">除非你确切地知道你在做什么，否则总是使用这个Makefile来创建和销毁副本。</p></blockquote><h1 id="f4ba" class="kl kg hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">步骤2:连接到副本集</h1><p id="4700" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jp lk iw ix jq ll ja jb jr lm je jf jg hb bi translated"><em class="ik">要连接到副本集，请确保您设置了“slaveOk: true”和“replicaSet: 'rs0 '”。更多细节见下面要点中的选项变量(第51行)。</em></p><p id="33c9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">在我们有一个MongoDB实例的情况下，我们创建了一个名为“mongo”的服务，它映射到pod，并在我们的连接字符串中使用该服务，例如:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="04bb" class="kf kg hi kb b fi kh ki l kj kk">var url = ‘mongodb://mongo:27017/dbname_?’;</span></pre><p id="d4d2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">如果我们再次尝试同样的事情，它不会工作。Kubernetes服务只会给我们一个随机的MongoDB pod的IP地址，而不是所有的。根据MongoDB文档，给定一个IP地址，应该可以自动找到副本集的其他成员，但不幸的是，情况似乎并非如此。</p><p id="9621" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">有两种方法可以解决这个问题。</p><h2 id="bfbb" class="kf kg hi bd km ln lo lp kq lq lr ls ku jp lt lu ky jq lv lw lc jr lx ly lg lz bi translated">选项1(简单):</h2><p id="cd39" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jp lk iw ix jq ll ja jb jr lm je jf jg hb bi translated">默认情况下，Makefile将为每个MongoDB实例创建一个服务。如果我们有三个实例，只需将连接字符串的主机部分更改为包含所有三个服务。</p><p id="ad24" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">例如:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="52ac" class="kf kg hi kb b fi kh ki l kj kk">$ var url = ‘mongodb://mongo-1,mongo-2,mongo-3:27017/dbname_?’;</span></pre><p id="00cd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">这是做这件事最简单的方法。</p><h2 id="55c6" class="kf kg hi bd km ln lo lp kq lq lr ls ku jp lt lu ky jq lv lw lc jr lx ly lg lz bi translated">选项2(复杂):</h2><p id="3afc" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jp lk iw ix jq ll ja jb jr lm je jf jg hb bi translated">选项一的问题是，您必须为每个MongoDB实例创建一个新的服务，并且每当您向副本集添加更多副本时，您都需要进行代码更改！对于90%的用例来说，这可能不是问题，因为你不会经常添加副本。</p><p id="61b2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">这感觉不像Kubernetes或微服务的做事方式。您不必事先知道您正在运行多少个副本；那应该被抽象掉。</p><p id="767e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">因此，我们可以ping Kubernetes API来获取所有MongoDB实例的实际pod IP地址，而不是使用服务。为此，我编写了一个简单的微服务:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="f0c8" class="kf kg hi kb b fi kh ki l kj kk">$ git clone <a class="ae jh" href="https://github.com/thesandlord/kubernetes-pod-ip-finder.git" rel="noopener ugc nofollow" target="_blank">https://github.com/thesandlord/kubernetes-pod-ip-finder.git</a><br/>$ cd <a class="ae jh" href="https://github.com/thesandlord/kubernetes-pod-ip-finder.git" rel="noopener ugc nofollow" target="_blank">kubernetes-pod-ip-finder</a></span></pre><p id="fe80" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">要启动微服务:</p><pre class="js jt ju jv fd ka kb kc kd aw ke bi"><span id="9eb0" class="kf kg hi kb b fi kh ki l kj kk">$ kubectl create -f service.yaml<br/>$ kubectl create -f controller.yaml</span></pre><p id="e9f2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">这创建了一个简单的REST端点，您可以查询pod IP地址。</p><blockquote class="if ig ih"><p id="61b9" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">O <strong class="il hj">选项一是静态的，不太灵活，但是选项二有性能开销，需要定制代码。你总是可以从选项一开始，如果你需要更大的灵活性，可以转到选项二。</strong></p></blockquote><p id="c0d0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">这是一个使用此服务获取IP地址的示例应用程序，查看第66–72行，了解我如何使用此微服务获取IP地址:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h1 id="1166" class="kl kg hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结束语</h1><p id="d653" class="pw-post-body-paragraph ii ij hi il b im li io ip iq lj is it jp lk iw ix jq ll ja jb jr lm je jf jg hb bi translated">这样，与以前相比，您现在有了一个更适合生产的MongoDB设置！在我的测试中，即使关闭一个虚拟机也不会有任何影响；Kubernetes只是将pod和卷重新安排到另一台机器上！如果主副本宕机，MongoDB副本集需要<a class="ae jh" href="https://docs.mongodb.org/manual/core/replica-set-elections/#heartbeats" rel="noopener ugc nofollow" target="_blank"> 10秒来选举新的主副本</a>，但这是您可能经历的最糟糕的宕机时间。</p><p id="0173" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">还有，我的大部分样本代码只在Google云平台上工作。我希望PRs增加对其他云和本地部署的支持。感谢<a class="ae jh" href="https://github.com/cvallance" rel="noopener ugc nofollow" target="_blank">cvalance</a>合并我的边车PR。特别感谢<a class="ae jh" href="https://github.com/stephenitis" rel="noopener ugc nofollow" target="_blank"> Stephen </a>的所有帮助——我真的希望看到类似的关于使用<a class="ae jh" href="https://clusterhq.com/flocker/introduction/" rel="noopener ugc nofollow" target="_blank"> Flocker </a>而不是gcePersistentDisks来管理MongoDB卷的博客帖子，这样它甚至可以在本地工作！</p><p id="50bc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">如果有任何问题，发推文@ sandeepdinesh给我。</p></div></div>    
</body>
</html>