# 预测迁移到 GCS 归档的检索成本的一个奇怪技巧

> 原文：<https://medium.com/google-cloud/one-weird-trick-to-predict-retrieval-costs-in-google-cloud-storage-9824aaac1889?source=collection_archive---------0----------------------->

# 放弃

我是一名谷歌人，具体在谷歌云工作。这里陈述的所有观点都是我自己的，而不是谷歌公司的。

# 附加免责声明

我马上就要说重点了，但是我真的想把这个讲清楚。在这篇文章中，我将讨论谷歌云定价。 ***我不是谷歌云定价的权威。我可能把我的事实搞混了。事实可能会在我发表后改变，我可能会忘记更新。我可能会对定价规则之间微妙的相互作用感到困惑。我不能保证我在这里说的任何事情都是准确的。因此，请对照[谷歌云平台网站](https://cloud.google.com/)上的文档检查您自己的用例及计划，如果有任何不清楚的地方，请通过 GCP 控制台联系支持人员。***

# 介绍

随着新的归档存储类别的[发布(目前为每月每 TB 1.23 美元！)办公室里的一个热门话题是检索成本。最常见的情况是，这种询问来自已经在使用“更冷”存储层的客户，尤其是 Coldline，他们希望使用更冷的存储层。](https://cloud.google.com/blog/products/storage-data-transfer/archive-storage-class-for-coldest-data-now-available)

当我说“冷”时，让我澄清一下我的意思，因为这对任何类型的归档存储的长期成功都很重要。通常，归档存储以某种节省空间和成本的方式存储，但这是以易于访问为代价的。把它想象成在一个未完工的阁楼里保存东西。在那里储存物品“花费”很少(可用的平方英尺)，但是通过在梯子上上下下搬运物品“花费”很大(时间和精力)。

在 GCS 中，有四种存储类别(可以在给定的存储桶中混合使用，并且不受位置限制)。下面是它们的访问频率:

*   **标准**:定期访问。
*   **近线**:每月访问不到一次。
*   **Coldline** :每季度访问不到一次。
*   **存档**:一年访问不到一次。

注意这些指导方针很重要。关键是，你不应该认为这是“所有的数据都必须这样使用。”这是另一个话题，但是你基本上想要确信大多数数据会以这种方式使用，或者至少有足够多的数据会让你通过转换的盈亏平衡点。

换句话说，如果你一年去阁楼少于一次，大多数年，你有正确的东西存放在那里。

# 一个奇怪的把戏

好吧，你确定存档适合你。现在你可能会问，我会支付检索成本将现有的 GCS 数据转移到那里吗？我是这样分解的:

> 除非[对象生命周期管理](https://cloud.google.com/storage/docs/lifecycle)为您移动对象，否则移动**将**收取源存储类的检索费(可能还有提前删除费)。

具体来说，对象生命周期管理将通过[一个 SetStorageClass 操作](https://cloud.google.com/storage/pricing#operations-pricing)来执行操作。这将按*目的地*等级的 A 级价格 *** 计费。但是因为 SetStorageClass 不是重写，所以检索成本[和提前删除成本](https://cloud.google.com/storage/docs/lifecycle#early_deletion_behavior)都不适用(它不会创建新对象)。

有一点要注意，这只在一个方向有效:**更冷**。任何向更热的存储类别(如 Standard)的移动都需要通过复制或重写操作来创建新对象，因此检索(以及可能的早期删除)成本将适用。

# **场景**

**使用生命周期管理将数据从标准文件移至归档文件**

没有检索成本。在这种情况下，您需要为每个对象支付一次 SetStorageClass(A 类)操作的费用，按照目标类(Archive)的费率。

**使用重写 API 方法将数据从标准文件移至存档文件**

没有检索成本。在这种情况下，您将按照目标类(归档)的费率支付一次 storage . objects . rewrite(A 类)操作的费用。虽然您正在创建一个新的对象，但是 Standard 没有检索成本，所以操作是这里唯一的成本。

**使用生命周期管理将数据从 Coldline 转移到归档**

没有检索成本。在这种情况下，您需要为每个对象支付一次 SetStorageClass(A 类)操作的费用，按照目标类(Archive)的费率。由于 Lifecycle 直接改变了类，而不是创建一个新的对象，所以检索成本被免除了。

**使用重写 API 方法将数据从 Coldline 移至存档**

肯定是检索成本。在这种情况下要小心！你在制造一个新的物体。您将按照目标类(归档)的费率支付一次 storage . objects . rewrite(A 类)操作，并按照 Coldline 费率支付检索费。

![](img/2524cf830f8e14fe318f1b79b8b96d42.png)

"所有这些存档的东西都让我想放声歌唱！"

**目前，这仅适用于归档存储类。其他存储类别按照 SetStorageClass 的源存储类别费率对操作计费。因为这是不协调的，所以我坚持使用本文中的归档案例。*