<html>
<head>
<title>Using Google Container Builder Service from Gitlab CE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gitlab CE的Google容器构建器服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-google-container-builder-service-from-gitlab-ce-93d96dea06bb?source=collection_archive---------1-----------------------#2018-04-20">https://medium.com/google-cloud/using-google-container-builder-service-from-gitlab-ce-93d96dea06bb?source=collection_archive---------1-----------------------#2018-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c284" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是Gitlab的忠实粉丝，但说到容器注册，Google Cloud Container Builder更加灵活、快速、经济，而且开销非常少。无论是大量的构建还是大量的拉取(采用容器编排平台，Kubernetes)，或者管理具有拉取权限的docker映像，使用Google Cloud Platform Container Builder都很容易。漏洞扫描是现成的。</p><h2 id="b030" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">为Gitlab Runner创建Google云服务帐户</h2><p id="634a" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">从IAM &amp; admin部分创建一个具有合适名称的新服务帐户，并下载密钥。然后将容器生成器的<a class="ae kd" href="https://cloud.google.com/container-builder/docs/securing-builds/configure-access-control#roles" rel="noopener ugc nofollow" target="_blank">角色</a>分配给服务帐户。现在，我们给云容器构建器编辑、<br/>存储管理员、项目查看者角色。登录gitlab服务器并<a class="ae kd" href="https://cloud.google.com/sdk/gcloud/reference/auth/activate-service-account" rel="noopener ugc nofollow" target="_blank">激活服务账户</a> : <code class="du ke kf kg kh b">gcloud auth activate-service-account [ACCOUNT] --key-file=[KEY_FILE]</code></p><h2 id="8aa3" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">创造。gitlab-ci.yml</h2><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="c5cc" class="jd je hi kh b fi kq kr l ks kt">stages:</span><span id="bbab" class="jd je hi kh b fi ku kr l ks kt">- build</span><span id="21fd" class="jd je hi kh b fi ku kr l ks kt">build:</span><span id="62a2" class="jd je hi kh b fi ku kr l ks kt">stage: build</span><span id="da37" class="jd je hi kh b fi ku kr l ks kt">script:</span><span id="b620" class="jd je hi kh b fi ku kr l ks kt">- gcloud container builds submit . --config=cloudbuild.yaml --substitutions BRANCH_NAME=$CI_COMMIT_REF_NAME,_IMAGE_NAME=$IMAGE_NAME</span><span id="fa0b" class="jd je hi kh b fi ku kr l ks kt">only:</span><span id="24e3" class="jd je hi kh b fi ku kr l ks kt">- branches</span></pre><p id="a51d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建<code class="du ke kf kg kh b">$IMAGE_NAME</code>环境变量，这将是我们在提取docker图像时使用的名称。例如，<code class="du ke kf kg kh b">mycoolimage</code>是<code class="du ke kf kg kh b">gcr.io/myproject/mycoolimage</code>的<code class="du ke kf kg kh b">IMAGE_NAME</code>。</p><h2 id="9db8" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">创建cloudbuild.yaml</h2><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="a8ba" class="jd je hi kh b fi kq kr l ks kt">steps:</span><span id="2a50" class="jd je hi kh b fi ku kr l ks kt">- name: gcr.io/cloud-builders/docker</span><span id="509e" class="jd je hi kh b fi ku kr l ks kt">args: ['build', '-t', 'gcr.io/$PROJECT_ID/${_IMAGE_NAME}:${BRANCH_NAME}', '.']</span><span id="ece7" class="jd je hi kh b fi ku kr l ks kt">images: ['gcr.io/$PROJECT_ID/${_IMAGE_NAME}']</span></pre><h2 id="2101" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">注册跑步者</h2><p id="bb2f" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">为了简单起见，我们在gitlab服务器上安装了gcloud sdk，并使用项目的令牌创建了一个shell runner。</p><p id="3cb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在任何分支上的每次推送时，它都会触发标记名为branch的容器构建。</p><h2 id="e5f1" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">额外收获:删除GCR上未标记的或过去的码头图片</h2><p id="d5f7" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">当使用与先前相同的标签创建新的docker图像时，最后一个图像将被取消标签，而较新的图像将被分配标签。因此，当您有大量构建时，不可用的映像会堆积在云存储中。以下是移除它们的方法:</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="dc1e" class="jd je hi kh b fi kq kr l ks kt">for reg in $(gcloud container images list --repository=gcr.io/[PROJECT_NAME]);do for digest in $(gcloud container images list-tags "${reg}" --filter='-tags:*'  --format='get(digest)' --limit=50); do gcloud container images --quiet delete "${reg}"@"${digest}";</span></pre><p id="cb1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes cronjob在一天结束时删除未标记的google容器图像:</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="cfc9" class="jd je hi kh b fi kq kr l ks kt">apiVersion: batch/v1beta1<br/>kind: CronJob<br/>metadata:<br/>  name: gcloud-cron<br/>  namespace: default<br/>spec:<br/>  concurrencyPolicy: Allow<br/>  failedJobsHistoryLimit: 1<br/>  jobTemplate:<br/>    metadata:<br/>      creationTimestamp: null<br/>    spec:<br/>      template:<br/>        metadata:<br/>          creationTimestamp: null<br/>        spec:<br/>          containers:<br/>          - args:<br/>            - /bin/bash<br/>            - -c<br/>            - for reg in $(gcloud container images list --repository=gcr.io/[PROJECT_NAME]);<br/>              do for digest in $(gcloud container images list-tags "${reg}" --filter='-tags:*'  --format='get(digest)'<br/>              --limit=50); do gcloud container images --quiet delete "${reg}"@"${digest}";<br/>              done; done<br/>            image: google/cloud-sdk<br/>            imagePullPolicy: Always<br/>            name: gcloud-cron<br/>            resources: {}<br/>            terminationMessagePath: /dev/termination-log<br/>            terminationMessagePolicy: File<br/>          dnsPolicy: ClusterFirst<br/>          restartPolicy: OnFailure<br/>          schedulerName: default-scheduler<br/>          securityContext: {}<br/>          terminationGracePeriodSeconds: 30<br/>  schedule: 0 0 0 * *<br/>  successfulJobsHistoryLimit: 3<br/>  suspend: false</span></pre></div></div>    
</body>
</html>