<html>
<head>
<title>Integrating Tracing and Logging with OpenTelemetry and Stackdriver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用OpenTelemetry和Stackdriver集成跟踪和日志记录</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/integrating-tracing-and-logging-with-opentelemetry-and-stackdriver-a5396fbc3e78?source=collection_archive---------0-----------------------#2020-02-18">https://medium.com/google-cloud/integrating-tracing-and-logging-with-opentelemetry-and-stackdriver-a5396fbc3e78?source=collection_archive---------0-----------------------#2020-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2530" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用像Stackdriver这样的一体化可观察性套件的主要好处之一是，它提供了您可能需要的所有功能。具体来说，您的指标、跟踪和日志都在一个地方，随着云控制台中监控的GA <a class="ae jd" href="https://cloud.google.com/monitoring/docs/monitoring_in_console" rel="noopener ugc nofollow" target="_blank">发布</a>，这比以往任何时候都更加真实。然而，在很大程度上，这些数据元素中的每一个仍然是独立的，我想尝试将它们中的两个统一起来——跟踪和日志。</p><p id="d50d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该项目的想法受到了Alex Amies在他的参考指南中所做的出色工作的启发。具体来说，他包括了一个applog <a class="ae jd" href="https://github.com/GoogleCloudPlatform/opencensus-spanner-demo/tree/master/applog" rel="noopener ugc nofollow" target="_blank">包</a>，它集成了OpenCensus中的跟踪和日志:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/15c06fc13d2dd3419e146e4ff22b45fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0DmxlUedaGdJWbh1"/></div></div></figure><p id="5ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想继续我的<a class="ae jd" href="https://dev.to/yurigrinshteyn/distributed-tracing-with-opentelemetry-in-go-473h" rel="noopener ugc nofollow" target="_blank">帖子</a>中关于OpenTelemetry跟踪的内容，并尝试创建集成的跟踪和日志。让我们开始吧！</p><h1 id="5f88" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">该应用程序</h1><p id="2628" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我使用Mux路由器创建了一个非常简单的Go应用程序:</p><ol class=""><li id="bc65" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">在<code class="du lc ld le lf b">/</code>收到请求。</li><li id="a98d" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">睡眠时间在0到9秒之间。</li><li id="0010" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">进行后端调用(给<a class="ae jd" href="https://www.google.com" rel="noopener ugc nofollow" target="_blank">https://www.google.com</a></li></ol><p id="f01a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的意图是创建一个有两个子节点的根span一个用于模拟内部流程的延迟，另一个用于后端调用。</p><h1 id="a52b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">代码</h1><h1 id="d6d9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">主要功能</h1><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="da9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">main函数简单地设置我的跟踪和日志记录，并使用<code class="du lc ld le lf b">mainHandler</code>来响应<code class="du lc ld le lf b">/</code>上的请求。</p><h1 id="8127" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">跟踪设置</h1><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="3861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">跟踪设置非常简单——我只是使用了由Yoshi Yamaguchi编写的exporter，他是一位出色的开发者倡导者。这是我在追踪帖子中使用的同一个导出器，没有任何变化。</p><h1 id="c27c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">日志记录设置</h1><p id="bbf7" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这就是事情开始变得有趣的地方。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="edfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很大程度上是从亚历克斯的作品<a class="ae jd" href="https://github.com/GoogleCloudPlatform/opencensus-spanner-demo/blob/master/applog/applog.go" rel="noopener ugc nofollow" target="_blank">中剽窃来的。init函数只是设置日志客户端。</a></p><h1 id="1a9c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">写日志</h1><p id="0099" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这是跟踪/日志记录集成真正发生的地方。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="39cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Stackdriver中，可以通过在日志消息的有效负载中写入span ID和trace ID来连接跟踪和日志。这里，我使用上下文提取span和trace，然后提取它们的id。然后，我将它们写入日志有效负载。下面是生成的日志消息的样子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ln"><img src="../Images/e92e2418a59a3b382051e5af2ecab435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jH0_UUTOeWUpcEiy.png"/></div></div></figure><p id="43fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，<code class="du lc ld le lf b">spanId</code>和<code class="du lc ld le lf b">trace</code>字段已被适当填充。</p><h1 id="b331" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">查看痕迹</h1><p id="0202" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我可以在本地运行该应用程序(在使用<code class="du lc ld le lf b">gcloud auth application-default login</code>编写默认凭据后)，并将流量发送到<a class="ae jd" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>。以下是结果跟踪:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/8f1f4126d8a14344f680bf7944dc0400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tCZ4LXP0sUCQq_lD.png"/></div></div></figure><blockquote class="lp lq lr"><p id="44e5" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><em class="hi">注意，该跟踪包含事件(使用</em> <code class="du lc ld le lf b"><em class="hi">span.AddEvent()</em></code> <em class="hi">方法添加)和日志，如上所述。</em></p></blockquote><h1 id="4b17" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">查看日志</h1><p id="916c" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我可以单击其中一个日志条目来查看日志消息的完整详细信息:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/0152a8b33691746f0239b5b35ff956cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5mGzrjrn2Vk0Zz_l.png"/></div></div></figure><p id="6cd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我可以在日志查看器中单击打开，并在那里看到以下日志条目:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/7eb4de46f3ce4050eaa3766abe97d93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X2c8MfaSZELHAISe.png"/></div></div></figure><h1 id="0d38" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">总之…</h1><p id="8e20" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我非常高兴地看到，OpenCensus的这一不太被重视的功能在OpenTelemetry中仍然有效，只做了一些小的改动。具体来说，我必须找到在<code class="du lc ld le lf b">printf()</code>中使用的新API来从上下文中提取span，然后获得它的span ID和trace ID，这似乎没有很好地记录。也就是说，我希望这篇简短的教程对那些希望用Stackdriver构建一个更加集成的可观测性方法的人有用，尤其是在分布式系统中。非常感谢亚历克斯在这方面所做的原创工作，也感谢你的阅读！</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="149c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ls">原载于</em><a class="ae jd" href="https://gist.github.com/295b0056b9ed4a4c39cd7fd616887bd4" rel="noopener ugc nofollow" target="_blank"><em class="ls">http://github.com</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>