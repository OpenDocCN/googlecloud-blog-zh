<html>
<head>
<title>Kubernetes: DNS Proxy With Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:带服务的DNS代理</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-dns-proxy-with-services-d7d9e800c329?source=collection_archive---------0-----------------------#2018-07-17">https://medium.com/google-cloud/kubernetes-dns-proxy-with-services-d7d9e800c329?source=collection_archive---------0-----------------------#2018-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建应用程序时，通常需要与外部服务进行交互来完成业务目标。在Kubernetes集群中工作时，您可能喜欢使用<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-routing-internal-services-through-fqdn-d98db92b79d3">内部服务路由</a>让您的一个服务与您的另一个服务通信。如果您想使用Kubernetes DNS服务器来屏蔽外部服务，使它们看起来像内部服务，那么您很幸运——这是可能的！本文将介绍如何使用Kubernetes DNS服务器将外部服务伪装成内部服务。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/c9cc8734c0e499901d379261095f2a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JN5IfJPREvOhBPVdK1Uwow.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">带DNS服务代理的GCP GKE架构图</figcaption></figure><p id="5eb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">如果你没有通读甚至没有读过本系列</em>  <em class="ju">的第一部分</em> <a class="ae jd" rel="noopener" href="/@jonbcampos/kubernetes-day-one-30a80b5dcb29"> <em class="ju">，你可能会感到困惑，对代码在哪里或者之前做了什么有疑问。记住这里假设你正在使用</em> </a><a class="ae jd" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ju"> GCP </em> </a> <em class="ju">和</em><a class="ae jd" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"><em class="ju">GKE</em></a><em class="ju">。我将始终提供代码和如何测试代码是按预期工作。</em></p><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-day-one-30a80b5dcb29"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">库伯内特:第一天</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ki l kj kk kl kh km jo jy"/></div></div></a></div><h1 id="a670" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">为什么代理您的服务</h1><p id="b480" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">有很多原因可以让你使用Kubernetes DNS服务器来屏蔽外部服务。一个例子是改变端点。你可能知道一个服务端点会改变，而不是让你的开发人员在代码中改变端点，我们可以让开发人员指向一个易于使用的内部服务端点，而不管实际发生了什么。</p><p id="729f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以通过Kubernetes YAML配置文件随时更改您的外部服务端点，而不必进入您的应用程序代码。</p><h1 id="0f61" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建外部名称代理</h1><p id="f511" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">创建外部名称代理非常简单。我们需要做的大部分工作都在Kubernetes yaml文件中。在这种情况下，我们将<a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/external-communication/k8s/external-service.yaml#L1-L17" rel="noopener ugc nofollow" target="_blank">创建一个新的yaml文件</a>，如下图所示。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="14ce" class="lv ko hi lr b fi lw lx l ly lz">apiVersion: v1<br/>kind: Service # a way for the outside world to reach the Pods<br/>metadata:<br/>  # the name of our external Service<br/>  <strong class="lr hj">name: external-service</strong><br/>spec:<br/>  # Service ports<br/>  ports:<br/>    - name: http<br/>      port: 80<br/>      targetPort: 8080<br/>      protocol: TCP<br/>  # <em class="ju">Points to external name</em><br/>  <strong class="lr hj">type: ExternalName</strong><br/>  <strong class="lr hj">externalName: www.jonbcampos.com </strong><em class="ju"># the external url</em><br/>  selector:<br/>    app: kubernetes-series</span></pre><p id="d9fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个配置文件创建了一个ExternalName类型的新服务，并将外部名称指向我们选择的URL。</p><p id="79b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的外部服务配置好了，我们只需要在应用程序代码中调用外部服务。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="9236" class="lv ko hi lr b fi lw lx l ly lz">router.get('/foreign', function (req, res, next) {<br/>    const url = '<strong class="lr hj">http://external-service.default/some_path/</strong>';<br/>    http.get(url, response =&gt; {<br/>        let data = '';<br/>        response.on('data', chunk =&gt; {<br/>            data += chunk;<br/>        });<br/>        response.on('end', () =&gt; {<br/>            res.status(200).json(JSON.parse(data));<br/>        });<br/>    }).on('error', err =&gt; {<br/>        throw err;<br/>    });<br/>});</span></pre><h1 id="f760" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">查看我们的外部名称代理的运行情况</h1><p id="6585" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">我已经为你设置了一个实验，这样你就可以很容易地看到它的运行。正如我之前所做的，您可以运行一个启动脚本来在Google Cloud中设置您的Kubernetes集群并部署您的应用程序代码。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="adeb" class="lv ko hi lr b fi lw lx l ly lz">$ git clone <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series.git" rel="noopener ugc nofollow" target="_blank">https://github.com/jonbcampos/kubernetes-series.git</a><br/>$ cd ~/<a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/tree/master/external-communication/scripts" rel="noopener ugc nofollow" target="_blank">kubernetes-series/external-communication/scripts</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/external-communication/scripts/startup.sh" rel="noopener ugc nofollow" target="_blank">startup.sh</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/external-communication/scripts/deploy.sh" rel="noopener ugc nofollow" target="_blank">deploy.sh</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/external-communication/scripts/check-endpoint.sh" rel="noopener ugc nofollow" target="_blank">check-endpoint.sh</a> service</span></pre><p id="0d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦您的服务可用，您就可以点击<code class="du ma mb mc lr b">/foreign</code>端点来查看通话结果。根据您的集群的IP地址，这将是<code class="du ma mb mc lr b">http://[your cluster IP Address]/foreign</code>。</p><blockquote class="md me mf"><p id="302d" class="if ig ju ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">注意:如果你运行这段代码，你会得到一个错误，因为<code class="du ma mb mc lr b">jonbcampos.com</code>是通过Bluehost托管的，所以我没有直接的IP地址访问。您可以随时将这个值更改为适合您的测试的任何值。</p></blockquote><p id="7b30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试完成后，您就大功告成了！现在可以使用Kubernetes DNS服务器(通过kube-proxy)调用外部服务，就像调用内部服务一样。</p><h1 id="e5c5" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">拆卸</h1><p id="3a77" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">在您离开之前，请确保清理您的项目，这样您就不会为您用来运行群集的虚拟机付费。返回到云Shell并运行teardown脚本来清理您的项目。这将删除您的集群和我们构建的容器。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="8f29" class="lv ko hi lr b fi lw lx l ly lz">$ cd ~/<a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/tree/master/external-communication/scripts" rel="noopener ugc nofollow" target="_blank">kubernetes-series/external-communication/scripts</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/external-communication/scripts/teardown.sh" rel="noopener ugc nofollow" target="_blank">teardown.sh</a></span></pre></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="e923" class="kn ko hi bd kp kq mq ks kt ku mr kw kx ky ms la lb lc mt le lf lg mu li lj lk bi translated">本系列的其他文章</h1><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-routing-internal-services-through-fqdn-d98db92b79d3"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:通过FQDN路由内部服务</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">我记得当我第一次进入Kubernetes时。一切都是崭新的、闪亮的、有规模的。当我继续的时候…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="mv l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-horizontal-pod-scaling-190e95c258f5"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:水平Pod缩放</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">通过Pod自动扩展，您的Kubernetes集群可以监控现有Pod的负载，并确定我们是否需要更多…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="mw l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a href="https://itnext.io/kubernetes-readiness-probe-83f8a06d33d3" rel="noopener  ugc nofollow" target="_blank"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:就绪探测</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">如果对这个特性有任何疑问，我写这篇文章是为了说明这不是一个…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">itnext.io</p></div></div><div class="kh l"><div class="mx l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-liveness-checks-4e73c631661f"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:活性检查</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">最近，我整理了一篇关于Kubernetes就绪性调查以及它对您的集群有多重要的文章…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="my l kj kk kl kh km jo jy"/></div></div></a></div></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="3fb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="http://jonbcampos.com/" rel="noopener ugc nofollow" target="_blank"> Jonathan Campos </a>是一个狂热的开发者，喜欢学习新事物。我相信我们应该不断学习、成长和失败。我总是开发社区的支持者，并且总是愿意提供帮助。因此，如果你对这个故事有任何问题或意见，请在下面提出。在<a class="ae jd" href="https://www.linkedin.com/in/jonbcampos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae jd" href="https://twitter.com/jonbcampos" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，并提及这个故事。</p></div></div>    
</body>
</html>