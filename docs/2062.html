<html>
<head>
<title>Installing Python Dependencies in Dataflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在数据流中安装Python依赖项</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/installing-python-dependencies-in-dataflow-fe1c6cf57784?source=collection_archive---------0-----------------------#2022-01-19">https://medium.com/google-cloud/installing-python-dependencies-in-dataflow-fe1c6cf57784?source=collection_archive---------0-----------------------#2022-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将研究PipelineOptions和客户容器中的3个依赖选项。然后，我们将看到数据流作业中python依赖性的一些已知问题。</p><p id="5dcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">免责声明:本文中的观点、信息和意见属于我个人，不一定代表Google和Apache Beam。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/45148f857529f670e365c1b4e6ebce35.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*VBNiY9TO6ZnAA7Qm9ulSwA.png"/></div></figure><p id="eb29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您运行数据流管道时，您的管道可能需要python包而不是apache-beam。依赖项可能是来自PyPI的公共包，也可能是您的团队中构建的内部包。在创建数据流作业的本地环境中安装依赖项是不够的。您应该在数据流作业创建中指定依赖关系，以便数据流工作虚拟机在SDK容器中正确安装依赖关系。</p><p id="0360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，本文假设您的管道使用的是<a class="ae jm" href="https://cloud.google.com/dataflow/docs/guides/deploying-a-pipeline#dataflow-runner-v2" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Python Runner v2 </strong> </a>。可以通过显式指定<code class="du jn jo jp jq b">--experiments=use_runner_v2</code>来使用Runner v2。如果您的管道使用python legacy runner运行，您可能会从本文中看到不同的行为。</p><h1 id="553f" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">三个依赖管道选项</h1><p id="d31e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">Apache Beam在<a class="ae jm" href="https://beam.apache.org/documentation/sdks/python-pipeline-dependencies/" rel="noopener ugc nofollow" target="_blank">管理python管道依赖</a>中引入了3个Python依赖选项:<code class="du jn jo jp jq b">--requirements_file</code>、<code class="du jn jo jp jq b">--extra_packages</code>和<code class="du jn jo jp jq b">--setup_file</code>。它们也适用于数据流作业。在接下来的部分中，我们将看到在本地环境和数据流工作虚拟机的SDK容器中做了什么。</p><p id="c718" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">本地环境</em>是您创建数据流作业的地方:例如，您的桌面、GKE、GCE、GAE等。</p><p id="f18e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> SDK容器</em>是执行管道代码和Beam SDK的地方。数据流工作虚拟机可以运行多个SDK容器。基本上，虚拟机中SDK容器的数量与数据流Python Runner v2作业的CPU数量相同。Python依赖项安装发生在每个SDK容器中。</p><p id="5842" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">管道选项#1: </strong> <code class="du jn jo jp jq b"><strong class="ih hj">--requirements_file</strong></code></p><p id="56db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指定依赖关系的最简单方法是使用<code class="du jn jo jp jq b">--requirements_file=requirements.txt</code>选项。每个SDK容器都将运行<code class="du jn jo jp jq b">pip install -r requirements.txt</code>(通常，<em class="jd"> requirements.txt </em>是依赖列表的文件名，但是您可以更改它)。为了避免从SDK容器中的PyPI仓库下载包，包被下载到本地环境中，并上传到GCS中的<code class="du jn jo jp jq b">staging_location</code>。</p><p id="3c3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果指定了<code class="du jn jo jp jq b">--requirements_file</code>，它会使用<code class="du jn jo jp jq b">pip download --no-binary :all: requirements.txt</code>下载<strong class="ih hj">源包</strong>，如下图所示。包和可传递依赖项作为源文件下载并构建。下载的源码包文件在stage阶段上传到<code class="du jn jo jp jq b">staging_location</code>。</p><p id="60ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如<code class="du jn jo jp jq b">google-cloud-translate</code>依赖<code class="du jn jo jp jq b">protobuf</code>、<code class="du jn jo jp jq b">requests</code>等。如果requirements.txt包含<code class="du jn jo jp jq b">google-cloud-translate</code>，它将下载<code class="du jn jo jp jq b">google-cloud-translate</code>的源码包及其依赖关系，如<code class="du jn jo jp jq b">protobuf</code>和<code class="du jn jo jp jq b">requests</code>。并且，它会上传所有下载的包文件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/6279c5d47250bbfc0f9e45b9a6b3f5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25eWoHimFFfxf4VuxmQggQ.png"/></div></div></figure><p id="13a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Dataflow worker虚拟机的SDK容器中，它用分段源文件安装<em class="jd"> requirements.txt </em>中的包。所有可传递的依赖项都已经暂存。不能从PyPI库下载额外的包。因为它们是从源包安装的，所以它们被构建到二进制包中，然后被安装。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kz"><img src="../Images/60bda0e6a775310c1f409dfa7627209c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGNaK3cT3T2XTjC3vwPhPw.png"/></div></div></figure><p id="0e86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的<a class="ae jm" href="https://github.com/baeminbo/dataflow-python-dependency-pipelines/tree/main/example1" rel="noopener ugc nofollow" target="_blank">例子</a>在requirements.txt中有<code class="du jn jo jp jq b">google-cloud-translate==3.6.1</code>，可以看到源码内置在<em class="jd">Google _ cloud _ translate-3 . 6 . 1-py2 . py3-none-any . whl</em>中，然后安装。</p><p id="d867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">管道选项#2: </strong> <code class="du jn jo jp jq b"><strong class="ih hj">--extra_packages</strong></code></p><p id="030f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">python依赖的第二个选项是<code class="du jn jo jp jq b">--extra_packages</code>。如果本地有包文件，可以指定为<code class="du jn jo jp jq b">--extra_packages=my_package.zip</code>。这个选项对于在PyPI中不公开的内部包很有用。</p><p id="f52e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据流运行器上传指定的python包和包列表<em class="jd"> extra_packages.txt </em>到<code class="du jn jo jp jq b">staging_location</code>。与<code class="du jn jo jp jq b">--requirement_file</code>不同，该选项仅上传指定的包文件。额外软件包所依赖的软件包不会被上传。</p><p id="70da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果您指定一个本地下载的<em class="jd">google-cloud-translate-2.6.1.tar.gz</em>为<code class="du jn jo jp jq b">--extra_packages</code>，它只上传<code class="du jn jo jp jq b">google-cloud-translate</code> packge文件，而不上传其依赖关系如<code class="du jn jo jp jq b">protobuf</code>和<code class="du jn jo jp jq b">requests</code>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es la"><img src="../Images/5b1ba6661eb7186039ee226bbeb3d869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FVOmAlLTidrEtWaQBb4-A.png"/></div></div></figure><p id="ebf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数据流工作虚拟机的SDK容器中，<strong class="ih hj">强制重新安装<em class="jd"> extra_packages.txt </em>中的</strong>个包。额外包的依赖项是从PyPI存储库中安装的，如下图所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lb"><img src="../Images/1147608e2a83f5ecf8d153ff051b4857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGylmHAfdwgzLPuL-xr5hQ.png"/></div></div></figure><p id="64d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的<a class="ae jm" href="https://github.com/baeminbo/dataflow-python-dependency-pipelines/tree/main/example2" rel="noopener ugc nofollow" target="_blank">示例</a>指定<em class="jd">google-cloud-translate-3.6.1.tar.gz</em>为额外包装。要安装<code class="du jn jo jp jq b">google-cloud-translate</code>的包文件，SDK容器应该从PyPI库下载并安装<code class="du jn jo jp jq b">google-cloud-translate</code>的依赖项(例如<code class="du jn jo jp jq b">protobuf</code>和<code class="du jn jo jp jq b">requests</code>)。但是，在本例中，跳过了依赖项的下载和安装过程，因为默认的SDK容器映像预安装了库。</p><p id="1b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个额外的包依赖于一个没有预先安装在SDK容器映像中的包，您可以看到每个SDK容器从PyPI存储库中下载并安装依赖包。这可能需要您的管道<a class="ae jm" href="https://cloud.google.com/dataflow/docs/guides/routes-firewall#internet_access_for" rel="noopener ugc nofollow" target="_blank">访问互联网</a>。</p><p id="3248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">管道选项#3: </strong> <code class="du jn jo jp jq b"><strong class="ih hj">--setup_file</strong></code></p><p id="0cbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">python包依赖的第三个选项是<code class="du jn jo jp jq b">--supte_file</code>。如<a class="ae jm" href="https://beam.apache.org/documentation/sdks/python-pipeline-dependencies/#multiple-file-dependencies" rel="noopener ugc nofollow" target="_blank">Apache Beam doc</a>中所述，该选项用于打包多个管道源文件。此外，使用<a class="ae jm" href="https://github.com/baeminbo/dataflow-python-dependency-pipelines/blob/main/example5/setup.py" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> setup.py </em> </a>中的<code class="du jn jo jp jq b">install_requires</code>，可以指定管道的依赖关系。</p><p id="2e87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当指定了<code class="du jn jo jp jq b">--setup_file=./setup.py</code>时，它通过运行<code class="du jn jo jp jq b">python setup.py sdist</code>构建一个源包(通常使用<em class="jd"> setup.py </em>，但是您可以更改文件名)。构建好的包作为<em class="jd">workflow.tar.gz</em>上传。上传的文件名是固定的，与<em class="jd"> setup.py </em>中的包名无关。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es la"><img src="../Images/0b1f7d5668f8a961552d9ea72e13bf82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iv13QNVHJKq5ESmhFI6i0g.png"/></div></div></figure><p id="2fcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数据流工作者虚拟机的SDK容器中，它安装了<em class="jd">workflow.tar.gz</em>。由<code class="du jn jo jp jq b">install_requires</code>指定的依赖项将作为二进制包下载并安装。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lc"><img src="../Images/23df223114698ccc12458aa9344fb597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTMjjn4nAICtmLQVL_67bw.png"/></div></div></figure><p id="496c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的例子在<code class="du jn jo jp jq b">install_requires</code>中有<code class="du jn jo jp jq b">lxml==4.7.1</code>。该包需要非pypi库(<code class="du jn jo jp jq b">libxml2</code>和<code class="du jn jo jp jq b">libxslt</code>)来构建二进制文件，默认SDK容器映像中没有预安装这些库。因此，如果您在<code class="du jn jo jp jq b">--requirements_file</code>中包含<code class="du jn jo jp jq b">lxml</code>，SDK容器会因为安装<code class="du jn jo jp jq b">lxml</code>包的错误而失败，并且您的数据流作业无法启动数据进程。</p><p id="a397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> setup.py </em>是打包源文件和定义依赖关系的最灵活的管道选项。它还可以指定自定义命令，如<em class="jd"> apt </em>包。参见<a class="ae jm" href="https://github.com/apache/beam/blob/master/sdks/python/apache_beam/examples/complete/juliaset/setup.py" rel="noopener ugc nofollow" target="_blank"> Juliaset </a>示例。</p><h1 id="5955" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">自定义容器</h1><p id="fbca" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">虽然管道选项解决了python依赖的大多数问题，但是为了构建复杂的管道包或轻松安装非pypi包，您可以使用<a class="ae jm" href="https://cloud.google.com/dataflow/docs/guides/using-custom-containers" rel="noopener ugc nofollow" target="_blank">自定义容器</a>。客户容器目前在Dataflow中面向python正式发布。您需要使用Runner v2来为您的工作使用客户容器。</p><p id="ef31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果需要，建议使用客户容器</p><ul class=""><li id="6a47" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">非pypi包安装:例如<code class="du jn jo jp jq b">apt-get install ...</code></li><li id="a0ba" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">预安装软件包以减少SDK容器中的初始化时间</li><li id="28a7" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">防止在SDK容器中安装软件包时出现任何问题</li></ul><p id="8945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jm" href="https://cloud.google.com/dataflow/docs/guides/using-custom-containers" rel="noopener ugc nofollow" target="_blank">在数据流中使用定制容器</a>解释了如何在数据流中使用定制容器。在接下来的部分中，我们将看到Dockerfile和Dataflow作业运行脚本，它们在SDK容器中预安装了最小的包，并且在SDK容器中初始化时不安装任何python依赖项。</p><p id="e516" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在Github库中找到完整的示例代码。</p><p id="825d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">集装箱建造</strong></p><p id="346e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下示例是创建数据流python客户容器的最小Dockerfile文件。它将<code class="du jn jo jp jq b">python:3.7-slim</code>作为基础映像，并将<code class="du jn jo jp jq b">apache-beam</code>和<code class="du jn jo jp jq b">lxml</code>一起作为依赖包安装。应用启动器<code class="du jn jo jp jq b">/opt/apache/beam/boot</code>是从<code class="du jn jo jp jq b">apache/beam_python3.7_sdk:2.35.0</code>复制过来的。可以更改python版本(3.6、3.7、3.8)和Beam版本(2.35.0、2.34.0等。).</p><p id="0cad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<em class="jd"> Dockerfile </em>在容器中安装最小的包和应用程序来运行SDK harness应用程序。</p><pre class="jf jg jh ji fd lr jq ls lt aw lu bi"><span id="9426" class="lv js hi jq b fi lw lx l ly lz"># Dockerfile for minimal Custom Container <br/>FROM apache/beam_python3.7_sdk:2.35.0 AS beam_python</span><span id="1c39" class="lv js hi jq b fi ma lx l ly lz">FROM python:3.7-slim<br/>RUN pip install --no-cache-dir apache-beam[gcp]==2.35.0 lxml==4.7.1<br/>COPY --from=beam_python /opt/apache/beam /opt/apache/beam<br/>ENTRYPOINT [ "/opt/apache/beam/boot" ]</span></pre><p id="fa2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，Apache Beam baes容器映像(如<code class="du jn jo jp jq b">apache/beam_python3.7_sdk:2.35.0</code>)包括<a class="ae jm" href="https://github.com/apache/beam/blob/v2.35.0/sdks/python/container/base_image_requirements_manual.txt" rel="noopener ugc nofollow" target="_blank">非必要的附加包</a>(例如<code class="du jn jo jp jq b">tensorflow</code>)。额外的包不会影响管道过程，但是如果您的自定义容器来自基本映像，则可能会增加容器映像的大小，如下所示。</p><pre class="jf jg jh ji fd lr jq ls lt aw lu bi"><span id="a58e" class="lv js hi jq b fi lw lx l ly lz"># Another Dockerfile for Customer Container.<br/># apache-beam is included in the base image.<br/>FROM apache/beam_python3.7_sdk:2.35.0<br/>RUN pip install --no-cache-dir lxml==4.7.1</span></pre><p id="006b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了上面的Dockerfile，您可以通过使用<code class="du jn jo jp jq b">docker build</code>和<code class="du jn jo jp jq b">docker push</code>来构建和推送容器。否则，您可以通过运行以下命令来使用云构建。</p><pre class="jf jg jh ji fd lr jq ls lt aw lu bi"><span id="219c" class="lv js hi jq b fi lw lx l ly lz"># Build and push container image with Cloud Build<br/>IMAGE_URI=gcr.io/$PROJECT/custom_beam_python<br/>gcloud builds submit . -t $IMAGE_URI</span></pre><p id="07e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您已经准备好使用自定义容器运行数据流作业。很简单！</p><p id="a2dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用自定义容器运行作业</strong></p><p id="7e88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用客户容器运行作业，您只需像下面的命令一样指定<code class="du jn jo jp jq b">--sdk_container_image</code>。</p><pre class="jf jg jh ji fd lr jq ls lt aw lu bi"><span id="0b1e" class="lv js hi jq b fi lw lx l ly lz">python -m $PIPELINE \<br/>  --runner=DataflowRunner \<br/>  --project=$PROJECT \<br/>  --region=$REGION \<br/>  --experiments=use_runner_v2 \<br/>  --sdk_container_image=$IMAGE_URI \<br/>  --sdk_location=container</span></pre><p id="0dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于您在自定义容器中预装了<code class="du jn jo jp jq b">apache-beam</code>，所以您的管道不需要从本地环境将<code class="du jn jo jp jq b">apache-beam</code>包上传到GCS中的<code class="du jn jo jp jq b">staging_locaion</code>。为此，您可以指定<code class="du jn jo jp jq b">--sdk_location=container</code>。如果您的管道不使用定制容器或定制容器不包含<code class="du jn jo jp jq b">apache-beam</code>包，您必须跳过<code class="du jn jo jp jq b">--sdk_location</code>或使用<code class="du jn jo jp jq b">default</code>。</p><p id="5059" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行脚本使用没有python依赖选项的<code class="du jn jo jp jq b">--sdk_container_image</code>和<code class="du jn jo jp jq b">--sdk_location=container</code>。它不在本地环境中下载或构建任何包，也不在数据流工作虚拟机中的SDK容器中下载或构建。在数据流作业中安装python依赖项可以避免任何问题或延迟。客户容器通常被推荐为避免数据流python作业中python依赖性问题的最佳方式。</p><h1 id="8345" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">常见问题</h1><p id="bdbe" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们研究了在SDK容器中指定python依赖关系的方法:使用python依赖选项或自定义容器。在这一节中，我们将看到一些常见的问题，这些问题的根本原因是python依赖安装。</p><p id="7c15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">包构建错误与</strong> <code class="du jn jo jp jq b"><strong class="ih hj">--requirements_file</strong></code></p><p id="4428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，<code class="du jn jo jp jq b">--requirements_file</code>选项下载源包并编译成SDK容器中的二进制文件。有些包需要非pypi二进制文件。比如<code class="du jn jo jp jq b">lxml</code>需要<code class="du jn jo jp jq b">libxml2</code>和<code class="du jn jo jp jq b">libxlst</code>库，可以通过<code class="du jn jo jp jq b">apt-get install</code>安装。但是，这些库没有安装在SDK容器映像中。如果您在requirements.txt中为<code class="du jn jo jp jq b">--requirements_file</code>包含<code class="du jn jo jp jq b">lxml</code>，SDK容器可能会因构建错误而无限期失败，如下图所示。您的数据流作业可能会因为没有工作线程活动而失败。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mb"><img src="../Images/d23a6efa9992402fd46706b687c256cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKIll2HeVBlhJZj6F_K6Ag.png"/></div></div></figure><p id="4c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以试试<code class="du jn jo jp jq b">--setup_file</code>来避免这个问题。<em class="jd"> setup.py </em>中<code class="du jn jo jp jq b">install_requires</code>的包是用二进制包安装的。上面<code class="du jn jo jp jq b">--setup_file</code>部分的例子可以通过在setup.py中添加<code class="du jn jo jp jq b">lxml</code>来成功运行数据流作业。</p><p id="c426" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的数据流作业仍然存在<code class="du jn jo jp jq b">--setup_file</code>问题，请考虑使用客户容器。</p><p id="6650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了构建错误之外，一些python包的构建需要几分钟或更长时间。这可能会延迟数据流作业的启动或虚拟机的扩展。您也可以尝试使用<code class="du jn jo jp jq b">--setup_file</code>或客户容器来缓解这个问题。</p><p id="e19c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不包括</strong><code class="du jn jo jp jq b"><strong class="ih hj">--requirements_file</strong></code><strong class="ih hj"/><code class="du jn jo jp jq b"><strong class="ih hj">--setup_file</strong></code>中的 <code class="du jn jo jp jq b"><strong class="ih hj">apache-beam</strong></code> <strong class="ih hj"/></p><p id="3bfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个常见的错误是将<code class="du jn jo jp jq b">apache-beam</code>作为依赖项添加到<code class="du jn jo jp jq b">--requirement_file</code>或<code class="du jn jo jp jq b">--setup_file</code>中。默认情况下，<code class="du jn jo jp jq b">apache-beam</code>包在本地环境中上传，不管python依赖选项如何(除非您使用<code class="du jn jo jp jq b">--sdk_location=container</code>)，所以您不应该将<code class="du jn jo jp jq b">apache-beam</code>与<code class="du jn jo jp jq b">--requirements_file</code>或<code class="du jn jo jp jq b">--setup_file</code>包含在一起。</p><p id="92e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du jn jo jp jq b">apache-beam</code>包含在依赖项中，它会导致不必要的包下载和上传到本地环境中的GCS，以及SDK容器中的冗余安装。这可能会降低数据流作业开始和自动缩放时SDK容器中的初始化速度。特别是如果您指定了不同于数据流作业创建版本的<code class="du jn jo jp jq b">apache-beam</code>版本(数据流控制台中显示的SDK版本)作为依赖项，在最坏的情况下会导致版本冲突和数据流作业失败。</p><p id="5c49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Flex模板启动器中的PyPI包下载错误</strong></p><p id="ed10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很少情况下，PyPI存储库暂时不可用，下载包可能会失败。如果在SDK容器中发生这种情况，将通过重新运行SDK容器来重试。但是，如果在创建数据流作业的本地环境中发生下载错误，作业创建将会失败。您应该重试作业创建。同样，如果此问题发生在Flex模板启动器中，数据流作业将在启动前失败。您可以通过在系统中为失败的Flex模板作业实现重试逻辑来缓解这一问题。自定义容器也可以缓解这个问题，因为它可以最大限度地减少从PyPI存储库下载的包，如前一节所述。</p><p id="0aa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flex模板创建作业有10分钟的超时时间。有多种因素会影响Flex template launcher中创建作业的处理时间。一个常见的根本原因是指定python依赖项需要很长时间来下载或构建。比如下载<code class="du jn jo jp jq b">pandas</code>为非二进制包需要很长时间(实际上，<code class="du jn jo jp jq b">pandas</code>是预装在默认SDK容器镜像中的。您不应该在—需求文件的文件中包含熊猫。在<a class="ae jm" href="https://gist.githubusercontent.com/baeminbo/8db2ce0f167be813987644a8fc094e34/raw/327411b5b53d3c5c9d0ed7f59928428149fe7228/gistfile1.txt" rel="noopener ugc nofollow" target="_blank">这个测试</a>，下载<code class="du jn jo jp jq b">pandas</code>为非二进制包花了8分多钟。如果<code class="du jn jo jp jq b">pandas</code>包含在<code class="du jn jo jp jq b">--requirements_file</code>中，您的Flex模板作业可能会因超时而失败。还有许多其他软件包也有这个问题。您可以通过使用客户容器或使用<code class="du jn jo jp jq b">--setup_file</code>来减轻这种情况。</p><p id="547a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述问题可能发生在GAE、作曲家、GKE或任何你创造工作的环境中。如果您的作业失败是由于python依赖性问题，请应用这些建议。</p><h1 id="2103" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">包裹</h1><p id="dd03" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在本文中，我们介绍了为数据流python作业指定python依赖关系的方法以及一些已知问题。如果你有进一步的兴趣，请阅读<a class="ae jm" href="https://github.com/apache/beam" rel="noopener ugc nofollow" target="_blank"> Apache Beam GitHub库</a>。<a class="ae jm" href="https://github.com/apache/beam/blob/v2.35.0/sdks/python/container/boot.go#L246" rel="noopener ugc nofollow" target="_blank"> boot.go </a>是在SDK容器中安装包和启动SDK harness python应用的Golang代码，<a class="ae jm" href="https://github.com/apache/beam/blob/v2.35.0/sdks/python/apache_beam/runners/portability/stager.py#L160" rel="noopener ugc nofollow" target="_blank"> stager.py </a>是在位置环境中下载和上传python包的Python代码。</p></div></div>    
</body>
</html>