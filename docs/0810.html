<html>
<head>
<title>Introduction to Stackdriver Profiler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Stackdriver探查器简介</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/introduction-to-stackdriver-profiler-614b580b978a?source=collection_archive---------0-----------------------#2018-11-12">https://medium.com/google-cloud/introduction-to-stackdriver-profiler-614b580b978a?source=collection_archive---------0-----------------------#2018-11-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8e1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">【更新日期:2019年2月28日</strong>——参见本博客<a class="ae jd" href="https://cloud.google.com/blog/products/management-tools/stackdriver-profiler-adds-more-languages-and-new-analysis-features" rel="noopener ugc nofollow" target="_blank">关于我没有提到的新分析器特性的帖子</a></p><p id="32d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在谷歌这样的地方工作的(许多)好处之一是，周围都是工作让你相形见绌的人。其中一个人是<a class="ae jd" rel="noopener" href="/@DazWilkin">戴斯·威尔金</a>，他可能已经忘记了比我还多的关于Stackdriver的知识。他在Stackdriver Profiler上的<a class="ae jd" rel="noopener" href="/google-cloud/stackdriver-profiler-671fb481236d">帖子</a>特别启发了我，它提醒我这是一个我还没有以任何有意义的方式探索的工具。我非常欣赏他提供的关于安装和运行Profiler的指导，我也想自己使用它们——特别是比较Profiler在不同语言之间的作用。</p><p id="adcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，产品团队已经清楚地记录了每种语言的可用功能。截至发稿时(2018年11月)，看起来是这样的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/d86f2276bd07481fc8cccbc7204750ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jqz9nPzHX1oyvVSO"/></div></div></figure><p id="c84b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我决定尝试在3种受支持的语言中实现一些东西，以亲眼看看所捕获的不同指标是什么样的，以及让Profiler收集数据有多困难。我决定做一些非常基本的事情——在返回之前，创建一段在随机生成的短时间内使用大量CPU的代码，并且我希望尽可能地跨语言复制我的方法。让我们开始吧！</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="2dea" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">节点。JS </strong></h1><h1 id="37cf" class="jx jy hi bd jz ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku bi translated"><strong class="ak">设置</strong></h1><p id="ba83" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我从我的舒适区——node . js开始。首先，下面是我为实现我想要的功能而达到的目标:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c4c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，这是一个非常基本的Express应用程序，它简单地生成一个随机整数，并将该整数传递给blockCpuFor()函数。该函数本身执行以下操作:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="4734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个基本的循环，在函数调用中指定的时间内生成随机数。</p><p id="1431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，是时候向代码中添加分析器工具了。在app.js文件中，我添加了:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="51e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相当简单！如果你愿意，你可以在GitHub <a class="ae jd" href="https://github.com/yuriatgoogle/profilerdemo" rel="noopener ugc nofollow" target="_blank">库</a>中看到整个<a class="ae jd" href="https://github.com/yuriatgoogle/profilerdemo/blob/master/node/app.js" rel="noopener ugc nofollow" target="_blank">文件</a>。然后，只需运行npm install，使用gcloud auth login向Google Cloud进行身份验证，并使用node app.js运行应用程序。我使用Apache Bench生成了一点负载，然后登录到GCP控制台，查看Profiler报告了什么(注意，与Daz不同，他经历了打包所有内容并部署到GKE的麻烦，我在MacOS上本地运行所有内容)。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="5c32" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">个人资料</strong></h1><p id="44fe" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated"><strong class="ih hj">墙壁时间</strong></p><p id="49f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如文档中所述，Profiler for Node.js收集关于墙时间和堆使用的信息。在我的例子中，因为我使用了大量的CPU，但是没有太多的内存，所以前者可能更有意思。让我们来看看:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a5df7744bb53c2ad5d83b7a00f179862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M_d0EOyyHzwwFaWw"/></div></div></figure><p id="89df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">果然——我们看到了完整的调用堆栈，几乎所有的时间都消耗在我的blockCpuFor函数中。这真的很酷——这正是我所期望看到的，并且很明显这在例如试图找出特定服务运行缓慢的原因或在受基础架构资源限制的环境中发生了什么时会很有用。</p><p id="7b84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">堆</strong></p><p id="0f2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，我的代码在使用内存方面做得不多——我没有创建或操作大型对象。然而，让我们看看在Profiler中查看堆视图时会得到什么:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f524b8bbd29912e6a84e6a7401d45e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iDq6nOuTjJYKVDO7"/></div></div></figure><p id="cafb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我能够快速轻松地找到有问题的函数，如果您是调试特定代码的开发人员，这可能会很有用，Profiler甚至会告诉我该函数在哪个文件中(就像在Wall Time视图中一样)。得心应手！</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="bc14" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">开始</strong></h1><h1 id="2d6f" class="jx jy hi bd jz ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku bi translated"><strong class="ak">设置</strong></h1><p id="b4bb" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">有了Node.js，是时候继续在Go中尝试同样的事情了。在这里，我有点力不从心，但是让我们看看会发生什么。</p><p id="fb54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们创建基本的Web服务器:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="5d23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再一次，我不得不称赞Daz——这段代码几乎完全是直接从他的文章中抄袭来的。现在，让我们添加blockCPU函数:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="cd18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不知道这是否是上述相同想法的最优雅的实现，但它对我很有效。我再次简单地将随机数乘以函数调用的秒数。我花了一些时间来弄清楚在Go中操纵时间的各种细节——在当前时间上增加几秒钟比我想象的要深奥得多——但我想一个更有经验的开发人员应该不会遇到这么多麻烦。</p><p id="fb33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们向main()函数添加分析器工具:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="b3da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再说一次，我是从Daz那里偷的检测代码，但是这很简单。我通过硬编码来指定projectID，因为我不想麻烦地把它变成一个配置或环境变量，这对于生产部署来说是不可能的，但是它对我的目的是有用的。和以前一样，如果你愿意，你可以在<a class="ae jd" href="https://github.com/yuriatgoogle/profilerdemo/tree/master/go" rel="noopener ugc nofollow" target="_blank">回购</a>中看到整个<a class="ae jd" href="https://github.com/yuriatgoogle/profilerdemo/blob/master/go/main.go" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><p id="e4a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在运行代码之前，我需要去获取“cloud.google.com/go/profiler”，然后我准备用go run main.go运行应用程序。我再次用Apache Bench生成一些请求——让我们看看profiler在go中做了什么。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="4569" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">剖面数据</h1><p id="1ac0" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated"><strong class="ih hj"> CPU </strong></p><p id="2a3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所猜测的，这应该是最有趣的数据所在，因为我的“应用程序”的整个目的是让CPU旋转一点。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/6e1d07ac50722315fdcee1a8f4a5f644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oPALvslbZoEtY3N6"/></div></div></figure><p id="a89a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不出所料，我的函数被清楚地标识出来，并且提供了源文件。我有点惊讶这个数字如此之低——显然，只有57%的CPU利用率来自我的blockCPU方法。我不太确定如何理解这个结论——是不是围棋生成随机数的效率更高？或者，实际运行和服务基本HTTP响应所需要的其他东西的效率要低得多？一位更有经验的同事指出，这可能是因为我正在创建一个rand。循环中的New()，这可能非常昂贵。这实际上是剖析代码价值的一个很好的例子！</p><p id="c625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">堆</strong></p><p id="0dda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个视图可能是这个用例中最不有趣的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/982deb207b6b388c230e275d40189c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uSrcMaFm3ZsP3XAo"/></div></div></figure><p id="26b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">果然——我甚至在努力寻找我在这个视图中关心的函数。幸运的是，Profiler提供了一种便捷的方法来找到您想要的代码——只需使用度量过滤器旁边的突出显示功能，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/854e9a6b23a6700e9df83e47a6b36d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tXoWkI3GyW3drlgx"/></div></div></figure><p id="4e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就在那里！正如人们可能预料的那样，它肯定没有使用太多的堆。</p><p id="0b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">螺纹</strong></p><p id="3aa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我正在做一些多线程的事情，或者，例如，在我的服务上看到很多负载，这个视图可能会更有趣，但是我没有。我甚至没有在Apache Bench中并行化我的负载。然而，让我们看看我们得到了什么:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ae19005037c8849f6fb3937450b7c8fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PbbJW7AftQ577Ymo"/></div></div></figure><p id="aa9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我找到了我的方法，但从这个角度来看，它很小，这不足为奇。尽管如此，这仍然是一个非常有用的视图——只是不适合我的特定测试用例。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="9ef7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Java语言（一种计算机语言，尤用于创建网站）</h1><h1 id="8762" class="jx jy hi bd jz ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku bi translated">设置</h1><p id="27aa" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我以谈论谦卑开始这篇文章，这部分确实是谦卑的。我突然想起，自从上了大学的操作系统课之后，我就再也没有做过Java编程了。这也很好地说明了在我看来更现代的语言如Node.js和Go中快速入门是多么容易。不过，让我们开始吧。</p><p id="4a56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，在撰写本文时(2018年11月)，Profiler for Java只在Linux上运行。因此，我需要使用Debian Linux VM来完成这一部分，而不是在MacOS上本地完成所有工作。下一个挑战是弄清楚用什么作为Java的基本Web框架(因为，我的知识已经过时十多年了)。读了一些资料后，我选择了Spring Boot，并向一位更有见识的同事确认了这一选择。谢天谢地，在<a class="ae jd" href="http://spring.io" rel="noopener ugc nofollow" target="_blank"> spring.io </a>上有一个很棒的<a class="ae jd" href="https://spring.io/guides/gs/spring-boot/" rel="noopener ugc nofollow" target="_blank">入门</a>，没有它，我仍然会努力弄清楚如何让HTTPserver工作以及如何让Maven编译任何东西。我必须承认——即使遵循了教程，我仍然不能完全理解Spring Boot是如何以与Node.js中的grok express相同的方式工作的，但是我能够做足够的事情来实现我的目的。</p><p id="6bca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了他们提供的完整示例，并简单地修改了源文件。事实上，我根本不需要修改Application.java文件，只需要删除代码来遍历提供的Beans。所以，我的非常简单的文件现在看起来像这样:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="25bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为这是这个文件可能达到的最小限度。我的实际逻辑进入了HelloController.java。首先，我添加了另一个@RequestMapping:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="0214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常简单——我生成一个随机数并将其传递给BlockCPU()。该函数看起来像这样:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="4aa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和围棋一样，我花了相当多的时间来弄清楚如何操纵时间。我最终找到了堆栈溢出的答案——我使用了System.currentTimeMillis()，但随后遇到了类型不匹配的问题，并最终使用了long而不是int。这可能不是最优雅的实现，但它似乎是可行的。</p><p id="b552" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦编写并编译了所有代码，就该添加分析器工具了。这是Java体验明显不同的另一个地方。这个过程清楚地记录在<a class="ae jd" href="https://cloud.google.com/profiler/docs/profiling-java" rel="noopener ugc nofollow" target="_blank">这里</a>，但是重要的部分是我需要下载Profiler代理库并把它传递给我的Java运行时，而不是简单地把它包含在我的代码中。具体来说:</p><pre class="jf jg jh ji fd lh li lj lk aw ll bi"><span id="cfaa" class="lm jy hi li b fi ln lo l lp lq">java \<br/>-agentpath:/opt/cprof/profiler_java_agent.so=\<br/>-cprof_service=java-profiler,\<br/>-cprof_service_version=0.0.1,\<br/>-logtostderr,\<br/>-cprof_project_id=&lt;project ID&gt; \<br/>-jar target/gs-spring-boot-0.1.0.jar</span></pre><p id="ca46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里需要注意的一点是，当我使用“javaProfiler”作为服务名，不得不改为“java-profiler”时，我实际上遇到了一些Profiler抱怨无效参数的问题。基本上，分析器希望服务名全部小写，用破折号分隔。如果代理能打印一份更好的诊断信息就好了，我被告知，在向工程部门提出这个问题后，这个问题将很快得到解决。</p><p id="6b98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">征服了这一切之后，是时候看看收集的数据了！</p><h1 id="9b8b" class="jx jy hi bd jz ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku bi translated">探查器数据</h1><p id="9b62" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated"><strong class="ih hj">墙壁时间</strong></p><p id="0d04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里的期望是，我的阻塞CPU的功能将是最重要的——毕竟，它是花费大部分时间的地方！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a740c623e13997b39036e383edb2870a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cNdY7iWq1IARPxh6"/></div></div></figure><p id="317b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这可能是这个实验中最令人惊讶的部分，它根本不存在！我甚至尝试了高亮显示功能，但这丝毫没有改变视图。这在过去和现在都很令人困惑，我真的不知道该如何解释。</p><p id="a69f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> CPU时间</strong></p><p id="0d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里的期望和以前一样——大部分CPU时间应该在我的函数中。找到它当然不容易，因为调用堆栈实在是太大了！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/eca2658f121f74135526c7510b671b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4o5Rx0k3JvMAuovA"/></div></div></figure><p id="78f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我能够放大视图并很容易地找到我的功能:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/218afaa0ed925ad99f91e94b4080eb44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mjNQSXs0AB4LCH79"/></div></div></figure><p id="fa00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如所料，这是CPU时间花费最多的地方。我发现一件有趣的事情，这可能是由于我对Java的相对无知，当按CPU时间排序时，堆栈是非常垂直的…..但是当按墙时间分析时要复杂得多。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h1 id="6dc4" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">结论</h1><p id="5845" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">总而言之，这是一个非常有趣的项目，我觉得推荐Profiler比以前舒服多了。当这种支持可用时，我很高兴将Python加入其中。我也很想看看语言中的功能是如何随着时间的推移而演变的——例如，我希望CPU使用率/时间最终能够进入Profiler for Go。感谢您一直读到最后——如果您还没有将Profiler添加到您的仪器中，我希望您这样做。</p></div></div>    
</body>
</html>