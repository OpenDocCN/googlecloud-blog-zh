<html>
<head>
<title>Build a blog application on Google App Engine: Admin module (part 5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google App Engine上构建博客应用程序:管理模块(第5部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-admin-module-part-5-d6b008855f69?source=collection_archive---------2-----------------------#2018-12-04">https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-admin-module-part-5-d6b008855f69?source=collection_archive---------2-----------------------#2018-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1737cbc7819e4bc8cec4c1de0cd15823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YotJes48hkU4DtU6is0VPw.jpeg"/></div></div></figure><p id="85fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是关于如何使用<strong class="is hj"> Google Datastore </strong>在Node.js中构建小型博客应用程序并将其部署到<strong class="is hj"> Google App Engine </strong>的多部分教程的第五部分。如果你错过了开头，<a class="ae jo" rel="noopener" href="/google-cloud/build-a-blog-application-on-google-app-engine-setup-part-1-38dab981b779">跳到第一部分</a>，在那里我解释了如何建立这个项目，在那里你可以找到其他部分的链接。</p><p id="84fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将构建一个小型的<em class="jp">管理</em>模块，允许我们<strong class="is hj">创建、</strong> <strong class="is hj">编辑和删除</strong> <em class="jp">博客文章</em>。</p><h1 id="fed2" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">管理路由处理程序</h1><p id="210d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">让我们从<strong class="is hj">开始，为我们需要的路由创建处理程序</strong>。我们的小模块将有三页:</p><ul class=""><li id="fbf2" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><code class="du lc ld le lf b">/</code>首页列出我们的帖子(获取)</li><li id="de51" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">/create-post</code>页面(获取或发布)</li><li id="44e2" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><code class="du lc ld le lf b">/edit-post</code>页面(获取或发布)</li></ul><p id="27fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们为这3条路由创建处理程序。</p><h2 id="46de" class="ll jr hi bd js lm ln lo jw lp lq lr ka jb ls lt ke jf lu lv ki jj lw lx km ly bi translated">回家路线处理程序</h2><p id="7472" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在<em class="jp"> admin </em>模块文件夹中创建一个“<em class="jp">admin . routes-handlers . ts</em>”文件，并添加以下内容:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="0d4d" class="ll jr hi lf b fi mh mi l mj mk">// modules/admin/admin.routes-handlers.ts</span><span id="5a82" class="ll jr hi lf b fi ml mi l mj mk">import is from "is";<br/>import { Request, Response } from "express";<br/>import { Context, Modules } from "./models";</span><span id="ed88" class="ll jr hi lf b fi ml mi l mj mk">export interface AdminRoutesHandlers {<br/>  dashboard(req: Request, res: Response): any;<br/>  createPost(req: Request, res: Response): any;<br/>  editPost(req: Request, res: Response): any;<br/>}</span><span id="2d3f" class="ll jr hi lf b fi ml mi l mj mk">export default (<br/>  { gstore }: Context,<br/>  { blog }: Modules<br/>): AdminRoutesHandlers =&gt; {<br/>  const { blogPostDomain } = blog.blogPost;</span><span id="2543" class="ll jr hi lf b fi ml mi l mj mk">  return {<br/>    async dashboard(req, res) {<br/>      const template = "admin/dashboard";</span><span id="49fb" class="ll jr hi lf b fi ml mi l mj mk">      let posts;<br/>      try {<br/>        posts = await blogPostDomain.getPosts({<br/>          cache: req.query.cache !== "false"<br/>        });<br/>      } catch (error) {<br/>        return res.render(template, {<br/>          error,<br/>          pageId: "admin-index"<br/>        });<br/>      }</span><span id="36de" class="ll jr hi lf b fi ml mi l mj mk">      res.render(template, {<br/>        posts: posts.entities,<br/>        pageId: "admin-index",<br/>      });<br/>    },<br/>  };<br/>};</span></pre><p id="ae12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主页(仪表板)页面处理程序的代码很简单，我们只需从blogPost域层调用<code class="du lc ld le lf b">getPosts()</code>方法。然后，我们根据<code class="du lc ld le lf b">cache</code> URL查询参数启用或禁用缓存。这个查询参数允许我们在创建或更新帖子后从数据存储中获取最新的帖子数据。</p><p id="66cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能已经注意到，我们从一个“<em class="jp"> models.ts </em>”文件中导入了一些尚不存在的类型。让我们将它们添加到我们的<em class="jp"> models.ts </em>文件中。</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="4ff3" class="ll jr hi lf b fi mh mi l mj mk">// modules/admin/models.ts</span><span id="78e0" class="ll jr hi lf b fi ml mi l mj mk">import { Gstore } from "gstore-node";<br/>import { Logger } from "winston";<br/>import { BlogModule } from "../blog/index";<br/>import { ImagesModule } from "../images/index";</span><span id="b03f" class="ll jr hi lf b fi ml mi l mj mk">export type Context = {<br/>  gstore: Gstore;<br/>  logger: Logger;<br/>};</span><span id="502a" class="ll jr hi lf b fi ml mi l mj mk">export type Modules = {<br/>  blog?: BlogModule;<br/>  images?: ImagesModule;<br/>};</span></pre><h2 id="31fb" class="ll jr hi bd js lm ln lo jw lp lq lr ka jb ls lt ke jf lu lv ki jj lw lx km ly bi translated">C <strong class="ak">创建后路径处理器</strong></h2><p id="3d14" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">现在让我们添加路由处理程序来创建一篇博客文章:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="e8fe" class="ll jr hi lf b fi mh mi l mj mk">// modules/admin/admin.routes-handlers.ts</span><span id="2291" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="bff7" class="ll jr hi lf b fi ml mi l mj mk">export default (<br/>  { gstore }: Context,<br/>  { blog }: Modules<br/>): AdminRoutesHandlers =&gt; {<br/>  const { blogPostDomain } = blog.blogPost;</span><span id="e0d8" class="ll jr hi lf b fi ml mi l mj mk">  return {<br/>    async dashboard(req, res) { ... },</span><span id="846f" class="ll jr hi lf b fi ml mi l mj mk">    async createPost(req, res) {<br/>      const template = "admin/edit";</span><span id="5c7b" class="ll jr hi lf b fi ml mi l mj mk">      if (req.method === "POST") {<br/>        const entityData = Object.assign({}, req.body, {<br/>          file: req.file<br/>        });</span><span id="337e" class="ll jr hi lf b fi ml mi l mj mk">        // We use the gstore helper to create a Dataloader instance<br/>        const dataloader = gstore.createDataLoader();</span><span id="1e1b" class="ll jr hi lf b fi ml mi l mj mk">        try {<br/>          await blogPostDomain.createPost(entityData, dataloader);<br/>        } catch (err) {<br/>          return res.render(template, {<br/>            blogPost: entityData,<br/>            error: is.object(err.message) ? err.message : err<br/>          });<br/>        }</span><span id="de13" class="ll jr hi lf b fi ml mi l mj mk">        // After succesfully creating the post we got back<br/>        // to the home page and disable the cache<br/>        return res.redirect("/admin?cache=false");<br/>      }</span><span id="63c7" class="ll jr hi lf b fi ml mi l mj mk">      return res.render(template, {<br/>        pageId: "blogpost-edit"<br/>      });<br/>    }</span></pre><p id="8cb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先检查请求方法是<code class="du lc ld le lf b">GET</code>还是<code class="du lc ld le lf b">POST</code>。如果是<code class="du lc ld le lf b">POST</code>，则意味着<strong class="is hj">我们正在提交表单</strong>。在这种情况下，我们通过将请求的<code class="du lc ld le lf b">body</code>与附加到请求的可选文件<em class="jp"> </em>合并来创建一个<code class="du lc ld le lf b">entityData</code>对象(我们马上会看到如何将文件附加到HTTP请求)。然后我们使用一个<code class="du lc ld le lf b">gstore</code>实用函数来<strong class="is hj">创建一个数据加载器实例</strong>，我们调用<code class="du lc ld le lf b">createPost()</code>域方法来创建BlogPost。一旦创建了博客文章，我们就将用户重定向到仪表板(并禁用缓存)。</p><p id="05d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<code class="du lc ld le lf b">GET</code>请求方法，事情要简单得多:)我们简单地呈现视图模板。</p><h2 id="110d" class="ll jr hi bd js lm ln lo jw lp lq lr ka jb ls lt ke jf lu lv ki jj lw lx km ly bi translated">编辑投递路线处理程序</h2><p id="ae99" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">最后，让我们添加处理程序到<strong class="is hj">编辑帖子</strong>。这将是非常类似的后期创作，所以我不会进入细节。主要的区别在于，在这里，对于<code class="du lc ld le lf b">GET</code>请求，我们确实需要获取blog post实体并将其传递给我们的视图模板。</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="0b1b" class="ll jr hi lf b fi mh mi l mj mk">// modules/admin/admin.routes-handlers.ts</span><span id="e083" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="fc20" class="ll jr hi lf b fi ml mi l mj mk">export default (<br/>  { gstore }: Context,<br/>  { blog }: Modules<br/>): AdminRoutesHandlers =&gt; {<br/>  const { blogPostDomain } = blog.blogPost;</span><span id="5ace" class="ll jr hi lf b fi ml mi l mj mk">  return {<br/>    async dashboard(req, res) { ... },<br/>    async createPost(req, res) { ... },</span><span id="5f45" class="ll jr hi lf b fi ml mi l mj mk">    async editPost(req, res) {<br/>      const template = "admin/edit";<br/>      const pageId = "blogpost-edit";<br/>      const dataloader = gstore.createDataLoader();<br/>      const { id } = req.params;</span><span id="d7b0" class="ll jr hi lf b fi ml mi l mj mk">      if (req.method === "POST") {<br/>        const entityData = Object.assign({}, req.body, {<br/>          file: req.file<br/>        });</span><span id="4247" class="ll jr hi lf b fi ml mi l mj mk">        try {<br/>          await blogPostDomain.updatePost(<br/>            id,<br/>            entityData,<br/>            dataloader,<br/>            true<br/>          );<br/>        } catch (err) {<br/>          return res.render(template, {<br/>            post: Object.assign({}, entityData, { id }),<br/>            pageId,<br/>            error: is.object(err.message) ? err.message : err<br/>          });<br/>        }</span><span id="658e" class="ll jr hi lf b fi ml mi l mj mk">        return res.redirect("/admin?cache=false");<br/>      }</span><span id="c69d" class="ll jr hi lf b fi ml mi l mj mk">      let post;<br/>      try {<br/>        post = await blogPostDomain.getPost(id, dataloader);<br/>      } catch (err) {<br/>        return res.render(template, {<br/>          post: {},<br/>          pageId,<br/>          error: is.object(err.message) ? err.message : err<br/>        });<br/>      }</span><span id="8ebe" class="ll jr hi lf b fi ml mi l mj mk">      if (!post) {<br/>        return res.redirect("/404");<br/>      }</span><span id="1e30" class="ll jr hi lf b fi ml mi l mj mk">      res.render(template, {<br/>        post,<br/>        pageId<br/>      });<br/>    }<br/>  };<br/>};</span></pre><h1 id="77f9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">管理路由器</h1><p id="19df" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">太好了！我们已经定义了所有的路由处理器。现在让我们创建<em class="jp"> Express </em> <strong class="is hj"> router </strong>，它将把路由路径连接到那些处理程序。但是首先简单介绍一下如何读取表单数据。</p><h2 id="1ad0" class="ll jr hi bd js lm ln lo jw lp lq lr ka jb ls lt ke jf lu lv ki jj lw lx km ly bi translated">读取多部分/格式数据</h2><p id="6cb6" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我在本教程的第一部分提到过，我不会详细讨论视图(T2模板)是如何渲染的。但是让我们快速了解一下用于创建或编辑博客文章的表单。如果查看"<em class="jp"> views/admin/edit.pug </em>"模板文件，您会看到表单的<code class="du lc ld le lf b">enctype</code>格式被设置为"<em class="jp"> multipart/form-data </em>"。这种格式允许我们<strong class="is hj">从用户浏览器</strong>发送文件以及表单输入数据。为了<strong class="is hj">解析<em class="jp"> Express </em>内部表单发送的请求数据</strong>，我们将使用<strong class="is hj">路由</strong>上的一个中间件<a class="ae jo" href="https://www.npmjs.com/package/multer" rel="noopener ugc nofollow" target="_blank">multer<em class="jp">package</em></a>。</p><p id="f513" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说，创建一个<em class="jp"> admin.routes.ts </em>文件并添加以下内容:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="1d6e" class="ll jr hi lf b fi mh mi l mj mk">// modules/admin/admin.routes.ts</span><span id="9a36" class="ll jr hi lf b fi ml mi l mj mk">import express, { Router } from "express";<br/>import multer from 'multer';<br/>import { Context, Modules } from "./models";<br/>import { AdminRoutesHandlers } from "./admin.routes-handlers";</span><span id="860b" class="ll jr hi lf b fi ml mi l mj mk">const uploadInMemory = multer({<br/>  storage: multer.memoryStorage(),<br/>  limits: {<br/>    fileSize: 5 * 1024 * 1024 // no larger than 5mb<br/>  },<br/>  fileFilter: (req, file, cb) =&gt; {<br/>    // Validate image type<br/>    if (["image/jpeg", "image/png"].indexOf(file.mimetype) &lt; 0) {<br/>      const err = new Error(<br/>        `File type not allowed: ${req.file.mimetype}`<br/>      );<br/>      return cb(err, false);<br/>    }<br/>    return cb(null, true);<br/>  }<br/>});</span><span id="40a9" class="ll jr hi lf b fi ml mi l mj mk">export default (<br/>  _: Context,<br/>  routesHandlers: AdminRoutesHandlers,<br/>  { images }: Modules<br/>): Router =&gt; {<br/>  const router = express.Router();</span><span id="d115" class="ll jr hi lf b fi ml mi l mj mk">  router.get("/", routesHandlers.dashboard);<br/>  router.get("/create-post", routesHandlers.createPost);<br/>  router.get("/edit-post/:id", routesHandlers.editPost);<br/>  router.post(<br/>    "/create-post",<br/>    [uploadInMemory.single("image")], // middleware to parse form<br/>    routesHandlers.createPost<br/>  );<br/>  router.post(<br/>    "/edit-post/:id",<br/>    [uploadInMemory.single("image")], // middleware to parse form<br/>    routesHandlers.editPost<br/>  );</span><span id="cf10" class="ll jr hi lf b fi ml mi l mj mk">  return router;<br/>};</span></pre><p id="0be3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里不多解释了。对<em class="jp">图像</em>模块的依赖已经声明但尚未使用(当我们<strong class="is hj">将特色图像上传到Google存储</strong>时，我们将需要它)。</p><p id="49d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们<strong class="is hj">从我们的<em class="jp">管理</em>模块"<em class="jp"> index.ts </em>"条目文件中导出这个路由器</strong>。将文件内容替换为:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="2aec" class="ll jr hi lf b fi mh mi l mj mk">// modules/admin/index.ts</span><span id="be8f" class="ll jr hi lf b fi ml mi l mj mk">import { Router } from "express";<br/>import initRoutes from "./admin.routes";<br/>import initRoutesHandlers from "./admin.routes-handlers";</span><span id="08f3" class="ll jr hi lf b fi ml mi l mj mk">import { Context, Modules } from "./models";</span><span id="2ebd" class="ll jr hi lf b fi ml mi l mj mk">export interface AdminModule {<br/>  webRoutes: Router;<br/>}</span><span id="002f" class="ll jr hi lf b fi ml mi l mj mk">export default (context: Context, { blog, images }: Modules) =&gt; {<br/>  const routesHandlers = initRoutesHandlers(context, { blog });</span><span id="3109" class="ll jr hi lf b fi ml mi l mj mk">  return {<br/>    webRouter: initRoutes(context, routesHandlers, { images })<br/>  };<br/>};</span></pre><p id="e403" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模块<strong class="is hj">在实例化时需要提供两个参数</strong><strong class="is hj"/>(上下文和模块)。让我们将它们添加到我们的"<em class="jp"> modules.ts" </em>文件中:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="e280" class="ll jr hi lf b fi mh mi l mj mk">// modules.ts<br/>...</span><span id="8187" class="ll jr hi lf b fi ml mi l mj mk">export default (context: Context): AppModules =&gt; {<br/>  const utils = initUtilsModule();<br/>  const images = initImagesModule();<br/>  const blog = initBlogModule(context, { utils, images });<br/>  const admin = initAdminModule(context, { blog, images }); // edit<br/>  ...</span></pre><p id="a2d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们<strong class="is hj">将我们的管理路由器连接到<code class="du lc ld le lf b">/admin</code>路径下的应用程序路由</strong>。</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="f33f" class="ll jr hi lf b fi mh mi l mj mk">// routes.ts</span><span id="1eee" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="5a07" class="ll jr hi lf b fi ml mi l mj mk">export default (<br/>  { logger, config }: Context,<br/>  {<br/>    app,<br/>    modules: { blog, admin }<br/>  }: { app: Express; modules: AppModules }<br/>) =&gt; {<br/>  /**<br/>   * Web Routes<br/>   */<br/>  app.use("/blog", blog.webRouter);<br/>  app.use("/admin", admin.webRouter); // Add this line</span><span id="0941" class="ll jr hi lf b fi ml mi l mj mk">...</span></pre><p id="14f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！你现在应该可以访问<code class="du lc ld le lf b">/admin</code>路线，并从那里创建一个新帖子。你也应该能够<strong class="is hj">编辑</strong>一篇文章，但是如果你试图<strong class="is hj">删除一篇文章</strong>，你会发现它不起作用。这是因为链接<strong class="is hj">调用了一个我们还没有定义的API端点</strong>(通过客户端的HTTP请求)。我们现在就开始吧！</p><h1 id="f8e3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">博客模块API</h1><p id="ec34" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们将为我们的<em class="jp">博客</em>模块<strong class="is hj">创建一个小型REST API </strong>，它将允许我们:</p><ul class=""><li id="0fe8" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">删除博客文章</li><li id="f589" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated">阅读/创建和删除评论(我们将在以后的帖子中看到)</li></ul><p id="f4bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的博客模块中打开“<em class="jp"> blog.routes.ts </em>”文件，并进行以下修改:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="ecda" class="ll jr hi lf b fi mh mi l mj mk">// modules/blog/blog.routes.ts</span><span id="d80f" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="603a" class="ll jr hi lf b fi ml mi l mj mk">webRouter.get("/:id", blogPost.routesHandlers.detailPost);</span><span id="6b4b" class="ll jr hi lf b fi ml mi l mj mk">// API<br/>const apiRouter = express.Router();<br/>apiRouter.delete(<br/>  "/blog-posts/:id",<br/>  blogPost.routesHandlers.deletePost<br/>);</span><span id="27cd" class="ll jr hi lf b fi ml mi l mj mk">return {<br/>  webRouter,<br/>  apiRouter // Add this line<br/>};</span></pre><p id="d1e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们<strong class="is hj">从我们的<em class="jp">博客</em>模块中导出API路由器</strong>:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="3834" class="ll jr hi lf b fi mh mi l mj mk">// modules/blog/index.ts</span><span id="6049" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="d1bc" class="ll jr hi lf b fi ml mi l mj mk">export interface BlogModule {<br/>  webRouter: Router;<br/>  apiRouter: Router; // Add this line<br/>  blogPost: BlogPostModule;<br/>}</span><span id="4e1a" class="ll jr hi lf b fi ml mi l mj mk">export default (context: Context, modules: Modules): BlogModule =&gt; {<br/>  const blogPost = initBlogPost(context, {});<br/>  const { webRouter, apiRouter } = initRoutes(context, {<br/>    blogPost<br/>  });</span><span id="4e13" class="ll jr hi lf b fi ml mi l mj mk">  return {<br/>    webRouter,<br/>    apiRouter // Add this line<br/>    blogPost,<br/>  };<br/>};</span></pre><p id="b5bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在需要为我们的<em class="jp"> BlogPost </em> routes处理程序创建<code class="du lc ld le lf b">deletePost()</code>处理程序。打开“<em class="jp">blog-post . routes-handlers . ts</em>”文件，添加以下内容:</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="1af6" class="ll jr hi lf b fi mh mi l mj mk">// modules/blog/blog-post/blog-post.routes-handlers.ts</span><span id="f8c7" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="414a" class="ll jr hi lf b fi ml mi l mj mk">export interface BlogPostRoutesHandlers {<br/>  listPosts(req: Request, res: Response): any;<br/>  detailPost(req: Request, res: Response): any;<br/>  deletePost(req: Request, res: Response): any; // Add this line<br/>}</span><span id="6028" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="9780" class="ll jr hi lf b fi ml mi l mj mk">async detailPost(req, res) { ... },</span><span id="c815" class="ll jr hi lf b fi ml mi l mj mk">async deletePost(req, res) {<br/>  let result: DeleteResult;</span><span id="3cc5" class="ll jr hi lf b fi ml mi l mj mk">  try {<br/>    result = await blogPostDomain.deletePost(req.params.id);<br/>  } catch (err) {<br/>    return res.status(err.status || 401).end(err.message);<br/>  }</span><span id="2e33" class="ll jr hi lf b fi ml mi l mj mk">  if (!result.success) {<br/>    return res.status(400).json(result);<br/>  }</span><span id="d548" class="ll jr hi lf b fi ml mi l mj mk">  return res.json(result);<br/>},</span><span id="deaa" class="ll jr hi lf b fi ml mi l mj mk">...</span></pre><p id="77bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没什么特别的。我们简单地调用我们的域层上的<code class="du lc ld le lf b">deletePost()</code>方法并返回结果。<br/>最后，我们需要<strong class="is hj">将我们全新的<em class="jp">博客</em> API路由器连接到我们的主应用</strong> routes。</p><pre class="lz ma mb mc fd md lf me mf aw mg bi"><span id="9390" class="ll jr hi lf b fi mh mi l mj mk">// routes.ts</span><span id="4f7e" class="ll jr hi lf b fi ml mi l mj mk">...</span><span id="863e" class="ll jr hi lf b fi ml mi l mj mk">/**  <br/> * Web Routes<br/> */<br/>app.use("/blog", blog.webRouter);<br/>app.use("/admin", admin.webRoutes);</span><span id="42bf" class="ll jr hi lf b fi ml mi l mj mk">/**<br/> * API Routes<br/> */<br/>const { apiBase } = config.common; // Add this line       <br/>app.use(apiBase, blog.apiRouter); // Add this line</span><span id="50c2" class="ll jr hi lf b fi ml mi l mj mk">...</span></pre><p id="635b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！<strong class="is hj">我们现在可以创建/编辑和删除博客文章了。至此，我们完成了<em class="jp">管理</em>模块。</strong></p><p id="3f58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读，如果您有什么不清楚的地方或有任何问题，请在评论中联系我们。</p><p id="3e6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的应用程序开始成形。我们要添加的下一个功能是可以为我们的博客文章向Google Storage 上传特色图片。</p><p id="514e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在教程的下一部分构建我们的<em class="jp">图像</em>模块时做这些事情。</p></div></div>    
</body>
</html>