<html>
<head>
<title>Cloud Build Notifications with Cloud Run and C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云运行和C++的云构建通知</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-build-notifications-with-cloud-run-and-c-a23294e2e959?source=collection_archive---------2-----------------------#2021-05-13">https://medium.com/google-cloud/cloud-build-notifications-with-cloud-run-and-c-a23294e2e959?source=collection_archive---------2-----------------------#2021-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0d1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卡洛斯·奥赖安(谷歌)</p><p id="9be2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在将google-cloud-cpp的许多持续集成构建迁移到GCB (Google Cloud Build ),因为它提供了高吞吐量、简单的配置以及与其他GCP服务的安全集成。虽然我们喜欢GCB中的大多数特性，但是我们缺少一种在完全构建(与拉请求构建相反)失败时通知我们的方式。本文描述了我们如何使用Google云服务和C++客户端库解决这个问题。这里描述的所有东西的实际工作代码都可以在我们的GitHub repo中找到。</p><p id="c6f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些观察帮助我们总结出了这个解决方案:</p><ul class=""><li id="703f" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">GCB为构建生命周期中的每个有趣事件(开始、成功完成、取消等)发送发布/订阅通知。)</li><li id="b1c9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我们可以使用C++的函数框架来捕获云构建状态的变化，因为这些变化是通过云发布/订阅发送的</li><li id="d4b9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我们可以发送一个HTTP POST到一个特定的URL，它将在Google聊天室中发布一条消息来提醒我们失败(而且仅仅是失败)。</li></ul><p id="ba37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这似乎也很有趣，因为我们将使用自己的功能框架来组合我们需要的功能。</p><h1 id="35e8" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">C++函数</h1><p id="338b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这段代码中的主要入口点函数是SendBuildAlerts()(关于如何配置该函数的名称，请参见下文)。当接收到新的CloudEvent时，函数框架会自动调用这个函数。它需要做的第一件事是获取聊天消息将被发布的秘密URL(称为webhook)。我们使用<a class="ae ku" href="https://cloud.google.com/secret-manager" rel="noopener ugc nofollow" target="_blank"> Google Secret Manager </a>将这个URL注入到流程的环境中。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="66af" class="le js hi la b fi lf lg l lh li">void SendBuildAlerts(google::cloud::functions::CloudEvent event) {<br/>  static auto const webhook = [] {<br/>    std::string const name = "GCB_BUILD_ALERT_WEBHOOK";<br/>    auto const* env = std::getenv(name.c_str());<br/>    if (env) return std::string{env};<br/>    throw std::runtime_error("Missing environment variable: "<br/>        + name);<br/>  }();<br/>… … … <br/>}</span></pre><p id="e3a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们进行一些解析，从云发布/订阅消息中提取代表构建结果的JSON对象。你可以在GitHub上看到<a class="ae ku" href="https://github.com/googleapis/google-cloud-cpp/blob/9ce4ca8509e1be20d1a11badf8770f62f94aa3e2/ci/cloudbuild/notifiers/alerts/function/function.cc#L34-L50" rel="noopener ugc nofollow" target="_blank">的全部细节</a>，但是它非常简单，唯一不明显的地方是Pub/Sub消息有一个消息字段，包含GCB的<a class="ae ku" href="https://cloud.google.com/build/docs/api/reference/rest/v1/projects.builds#Build" rel="noopener ugc nofollow" target="_blank">构建资源</a>的base64编码表示。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7b20" class="le js hi la b fi lf lg l lh li">void SendBuildAlerts(google::cloud::functions::CloudEvent event) {<br/>… … … <br/>  auto const bs = ParseBuildStatus(std::move(event));<br/>… … … <br/>}</span></pre><p id="8e4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们过滤掉不值得发出警报的事件，例如成功的构建或手动启动的构建:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="6dda" class="le js hi la b fi lf lg l lh li">void SendBuildAlerts(google::cloud::functions::CloudEvent event) {<br/>… … …<br/>  if (bs.status != "FAILURE") return;<br/>  auto const substitutions = bs.build["substitutions"];<br/>  auto const trigger_type = substitutions.value(<br/>      "_TRIGGER_TYPE", "");<br/>  auto const trigger_name = substitutions.value("TRIGGER_NAME", "");<br/>  // Skips PR invocations and manually invoked builds (no trigger<br/>  // name).<br/>  if (trigger_type == "pr" || trigger_name.empty()) return;<br/>… … … <br/>}</span></pre><p id="664e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在只需要向webhook URL发出POST请求:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="405f" class="le js hi la b fi lf lg l lh li">void SendBuildAlerts(google::cloud::functions::CloudEvent event) {<br/>… … … <br/>  auto const chat = MakeChatPayload(bs);<br/>  std::cout &lt;&lt; nlohmann::json{{"severity", "INFO"}, {"chat" : chat}}<br/>            &lt;&lt; "\n";<br/>  HttpPost(webhook, chat.dump());<br/>}</span></pre><p id="f0d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">聊天消息本身是一个JSON对象:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7232" class="le js hi la b fi lf lg l lh li">nlohmann::json MakeChatPayload(BuildStatus const&amp; bs) {<br/>  auto const trigger_name = bs.build["substitutions"].value("TRIGGER_NAME", "");<br/>  auto const log_url = bs.build.value("logUrl", "");<br/>  auto text = fmt::format(<br/>      "Build failed: *{}* {}", trigger_name, log_url);<br/>  return nlohmann::json{{"text", std::move(text)}};<br/>}</span></pre><p id="c547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP POST是使用libcurl实现的:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="93ca" class="le js hi la b fi lf lg l lh li">void HttpPost(std::string const&amp; url, std::string const&amp; data) {<br/>  static constexpr auto kContentType =<br/>      "Content-Type: application/json";<br/>  using Headers =<br/>      std::unique_ptr&lt;curl_slist, decltype(&amp;curl_slist_free_all)&gt;;<br/>  auto const headers = Headers{<br/>     curl_slist_append(nullptr, kContentType), curl_slist_free_all};<br/>  using CurlHandle =<br/>      std::unique_ptr&lt;CURL, decltype(&amp;curl_easy_cleanup)&gt;;<br/>  auto curl = CurlHandle(curl_easy_init(), curl_easy_cleanup);<br/>  if (!curl) {<br/>      throw std::runtime_error("Failed to create CurlHandle");<br/>  }<br/>  curl_easy_setopt(curl.get(), CURLOPT_URL, url.c_str());<br/>  curl_easy_setopt(curl.get(), CURLOPT_HTTPHEADER, headers.get());<br/>  curl_easy_setopt(curl.get(), CURLOPT_POSTFIELDS, data.c_str());<br/>  CURLcode code = curl_easy_perform(curl.get());<br/>  if (code != CURLE_OK) {<br/>      throw std::runtime_error(curl_easy_strerror(code));<br/>  }<br/>}</span></pre><h1 id="16ff" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">获取和存储Webhook</h1><p id="1b3b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">要为您的Google聊天室设置一个传入的webhook，您可以按照<a class="ae ku" href="https://developers.google.com/hangouts/chat/how-tos/webhooks" rel="noopener ugc nofollow" target="_blank">以下步骤进行</a>。一旦你完成了这些，你就有了从你的云函数发布到的URL(上面显示为GCB_BUILD_ALERT_WEBHOOK环境变量的内容)。您可以使用curl(1)向该URL发送一篇测试文章，命令如下:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="6f13" class="le js hi la b fi lf lg l lh li">curl -X POST -sSL "&lt;YOUR_WEBHOOK_URL&gt;" \<br/>    --data-binary "{'text': 'hello world'}"</span></pre><p id="7e60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个网址应该保密，因为它允许任何人在你的谷歌聊天室发帖——<strong class="ih hj">把它当作密码</strong>。我们按照这个<a class="ae ku" href="https://cloud.google.com/secret-manager/docs/quickstart#secretmanager-quickstart-web" rel="noopener ugc nofollow" target="_blank"> Secret Manager快速入门指南</a>中的说明将这个URL存储在Google Secret Manager中。接下来，我们需要将这个秘密安全地注入到我们的函数环境中。我们通过配置<a class="ae ku" href="https://cloud.google.com/run/docs/configuring/secrets" rel="noopener ugc nofollow" target="_blank"> Google Cloud Run来使用这个秘密</a>来进行配置。瞧啊。</p><p id="3cae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:我们在这里使用了一个Google Chat Webhook，但是我们相信类似的方法也适用于<a class="ae ku" href="https://api.slack.com/messaging/webhooks" rel="noopener ugc nofollow" target="_blank"> Slack Webhooks </a>或<a class="ae ku" href="https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks" rel="noopener ugc nofollow" target="_blank"> Discord Webhooks </a>。</p><h1 id="fcc3" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">部署C++函数</h1><p id="2fc5" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">functions framework for C++集成了Cloud Run，这是一个托管的无服务器平台，您可以在其中将代码部署为一个容器。该平台调用您的代码来响应web请求或发布/订阅事件。该平台负责启动服务器，随着负载的增加增加服务器的数量，并在处理失败时重新传递消息。我们需要做的就是编写SendBuildAlerts()函数，并将其包装到Docker映像中。</p><p id="ce86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将逐个显示每个命令，但是我们有一个<a class="ae ku" href="https://github.com/googleapis/google-cloud-cpp/blob/main/ci/cloudbuild/notifiers/alerts/deploy.sh" rel="noopener ugc nofollow" target="_blank">小shell脚本</a>来运行它们。</p><p id="f1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方便的是，Google的build pack支持C++的函数框架，因此创建Docker映像是一个简单的命令:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="36ef" class="le js hi la b fi lf lg l lh li">readonly IMAGE="gcr.io/${GOOGLE_CLOUD_PROJECT}/send-build-alerts"<br/>pack build --builder gcr.io/buildpacks/builder:latest \<br/>  --env "GOOGLE_FUNCTION_SIGNATURE_TYPE=cloudevent" \<br/>  --env "GOOGLE_FUNCTION_TARGET=SendBuildAlerts" \<br/>  --path "function" "${IMAGE}"</span></pre><p id="1709" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将检测我们函数的依赖项，下载、编译和安装它们，然后将我们的函数编译成HTTP服务。此外，依赖项是缓存的(本地，在您的工作站上)，所以额外的构建相当快。</p><p id="0712" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦图像被创建，我们可以把它推到GCR(谷歌容器注册):</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e2ce" class="le js hi la b fi lf lg l lh li">docker push “${IMAGE}:latest”</span></pre><p id="843e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并部署代码:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="d95c" class="le js hi la b fi lf lg l lh li">gcloud run deploy send-build-alerts \<br/>    --project="${GOOGLE_CLOUD_PROJECT}" \<br/>    --image="${IMAGE}:latest" \<br/>    --region="us-central1" \<br/>    --platform="managed" \<br/>    --no-allow-unauthenticated</span></pre><p id="1415" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的服务器已经“运行”了，我们需要设置一个触发器来向它发送云构建消息，这是通过Eventarc完成的:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="fd42" class="le js hi la b fi lf lg l lh li">PROJECT_NUMBER=$(gcloud projects list \<br/>    --filter="project_id=${GOOGLE_CLOUD_PROJECT}" \<br/>    --format="value(project_number)" \<br/>    --limit=1)</span><span id="9fd0" class="le js hi la b fi lj lg l lh li">gcloud beta eventarc triggers create send-build-alerts-trigger \<br/>    --project="$GOOGLE_CLOUD_PROJECT" \<br/>    --location="us-central1" \<br/>    --destination-run-service="send-build-alerts" \<br/>    --destination-run-region="us-central1" \<br/>    --transport-topic="cloud-builds" \<br/>    --matching-criteria="type=google.cloud.pubsub.topic.v1.messagePublished" \<br/>    --service-account="${<a class="ae ku" href="mailto:PROJECT_NUMBER}-compute@developer.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">PROJECT_NUMBER}-compute@developer.gserviceaccount.com</a>"</span></pre><p id="ae77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，在这个例子中，我们使用默认的Google Compute服务帐户向函数发送通知。为了这个目的，你可能想要使用一个特定的服务帐户，遵循最小特权的原则，我们只是不想因为创建服务帐户和权限分配而使这篇文章变得混乱。</p><h1 id="9426" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">后续步骤</h1><p id="fa17" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">一旦你有了在每次构建后运行的代码，你就可以真正发挥创造力了:</p><ul class=""><li id="e36e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">也许在一个数据库中捕获所有的构建结果并跟踪剥落</li><li id="455f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">创建仪表板来查看构建的长期趋势(构建时间增长？)</li><li id="7190" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">考虑自动归档失败/脆弱版本的GitHub问题</li></ul><p id="f475" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在Google Cloud社区Slack ( <a class="ae ku" href="https://googlecloud-community.slack.com/archives/C8CDDF81H" rel="noopener ugc nofollow" target="_blank"> #cpp </a>)中发现这很有用，请告诉我们。</p></div></div>    
</body>
</html>