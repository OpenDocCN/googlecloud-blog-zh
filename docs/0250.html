<html>
<head>
<title>Understanding and Profiling App Engine Cold-Boot Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解和分析应用引擎冷启动时间</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/understanding-and-profiling-app-engine-cold-boot-time-908431aa971d?source=collection_archive---------0-----------------------#2017-04-06">https://medium.com/google-cloud/understanding-and-profiling-app-engine-cold-boot-time-908431aa971d?source=collection_archive---------0-----------------------#2017-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d9dc4b6b7d36750855f51f34b01f8003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8gFMHNLtQJj-DnrepTSjw.jpeg"/></div></div></figure><div class=""/><p id="d510" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我一直在做这整个"<a class="ae jo" href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" rel="noopener ugc nofollow" target="_blank">性能宣传</a>的事情一个<a class="ae jo" href="https://www.youtube.com/watch?v=0UNWi7FA36M" rel="noopener ugc nofollow" target="_blank">长时间</a>。因此，当我将注意力转向“<a class="ae jo" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">云</a>”的消息传出后，我开始收到开发人员的pings，他们希望帮助提高他们基于云的应用程序的性能。</p><p id="2e82" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个同事；让我们叫他“卡特”写了一个名为“<em class="jp">诱饵和缝合</em>的网站，帮助钓鱼爱好者与该地区的设计师联系，创造个人品牌的钓鱼服装。在假期休息期间，他看到该应用程序上有大量用户，并得到一些反馈，即他们在白天第一次使用该应用程序时，该应用程序运行非常慢，之后，它变得明显更快。</p><p id="4b9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常，当我听到这样的反馈时，意味着一件事:<strong class="is hu">冷启动性能</strong>。</p><p id="b142" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当一个<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">应用引擎</a>实例第一次启动时，它必须执行一堆只在初始引导时发生的工作。如果这项额外的工作太长，那么它会延迟实例对用户流量的响应(也就是说，这很糟糕)。</p><p id="32da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常，谷歌<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">应用引擎</a>(标准版)的冷启动问题非常罕见，这也是我对这个问题感兴趣的地方。卡特的用户已经开始抱怨这些性能问题，这意味着是时候让他和我坐下来研究代码，喝一杯茶，找出问题所在。</p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">忙到没时间看书？查看上面的视频以了解总结。</figcaption></figure><h1 id="1906" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用日志记录分析启动时间</h1><p id="f42c" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">每当您获得关于性能的反馈时，第一步应该是检查系统给了您什么时间信息，而不必开始过多地挖掘，或者浪费时间构建整个分析工具。幸运的是，我们的<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">应用引擎</a>记录了关于每个请求的信息，包括请求被您的服务处理需要多长时间。看了一眼谷歌云控制台的日志，证实了我的怀疑:我们遇到了冷启动时间的问题。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/1deb619577b096c6e69ddaeca2d10a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*QKqF56P5pr8pP_XJgDHHZA.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">Google Cloud控制台将显示通过您的实例发出的请求的日志数据。</figcaption></figure><p id="c9c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最上面用蓝色突出显示的请求是我的“加载请求”。正是这个请求导致了一个实例的旋转。点击它确认这个状态；“加载请求”标志被设置为1，并添加一个日志条目来指示这是一个加载请求。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es le"><img src="../Images/74877634021d57637d755d41615e86a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*ZntdXzB2E3MY7MRVJflhIw.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">导致创建实例的请求在日志中会有一些带注释的数据。</figcaption></figure><p id="9cdc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于我们的例子，我们感兴趣的是我们的冷启动时间花了多长时间，这可以显示在日志概要中，单击一个项目就可以看到。这有助于了解加载延迟如何随着时间的推移而调整，但它并没有帮助我理解部分请求可能会花费在加载时间和请求服务上。至少我们已经确认了用户报告的事情确实发生了，但是我们还不知道为什么。</p><h1 id="437f" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">跟踪时分析启动时间</h1><p id="6153" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated"><a class="ae jo" href="https://cloud.google.com/stackdriver/" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>追踪内置于<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank"> App Engine </a>标准中；请求被记录，关于它们的<a class="ae jo" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank"> RPC调用</a>的细节也被列出。它可以很容易地快速洞察您的时间在请求过程中的去向，以找到启动项目，搜索延迟高于其邻居的元素(如下面的1400毫秒请求，比相同位置的其他请求慢10倍)。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lf"><img src="../Images/5deb087baedb6c3f32f46b265b1a1c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*GIl8l2mBrwz_2w-qaeggUQ.png"/></div></figure><p id="ab7b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择它会调出一个trace，其中<em class="jp"> cloud_debugger。DebugletStarted </em>占用了大部分时间。这个块只在产生了一个新实例时执行，所以很明显这是一个导致冷启动发生的请求。</p><p id="a1c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您查看summary视图，它会告诉您跟踪的时间与未跟踪的时间，因此您可以看到这个预热用了1209毫秒(实际请求是195毫秒)。</p><p id="505e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在左图中看到，在创建套接字以允许连接到实例之前，大约有900毫秒。这是启动时间的粗略指标。</p><p id="c5e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，跟踪中断了应用程序进行的任何RPC调用，因此您可以看到您可能被阻止的内容。</p><p id="4c8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">跟踪向我们展示了一些非常重要的信息:RPC调用不是问题，GAE的通用启动时间也不是问题；我的启动代码内部发生了一些事情，导致了性能峰值。</p><h1 id="2c84" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">自定义跟踪指标</h1><p id="9a52" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">现在，Bait-and-Stitch的加载时间约为1.2秒；我们已经排除了<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">应用引擎</a>的原因，并确保没有任何奇怪的RPC调用导致问题。遗憾的是，我们仍然不知道问题出在哪里。为了获得更多的洞察力，我们需要对我们的代码进行更多的剖析。</p><p id="25a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看，跟踪在记录RPC函数调用所花费的时间方面做得很好；但是它不会跟踪这些调用之间出现的所有自定义代码。要做到这一点，我们需要利用<a class="ae jo" href="https://cloud.google.com/trace/api/reference/rest/" rel="noopener ugc nofollow" target="_blank"> Stackdriver跟踪API </a>，它允许我们修补现有的跟踪，这些跟踪是<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">应用引擎</a>用我们自己的数据生成的，因此它们将全部显示在一个好地方。</p><p id="7039" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Carter和我能够编写一个小的实用程序类来跟踪各种代码段的开始和结束时间，并根据需要将这些结果转换成JSON字符串</p><figure class="jq jr js jt fd hk"><div class="bz dy l di"><div class="lg jv l"/></div></figure><p id="8282" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将这个JSON字符串格式化，以完全匹配Stackdriver跟踪为其公开的Rest API接受的内容。一旦我们建立了auth流，并挖掘了一些其他信息，Stackdriver就完成了所有的繁重工作。</p><p id="cc88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果是，我们发出的任何请求，现在都有了堆栈跟踪尚未监控的代码块的自定义跟踪数据。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es lh"><img src="../Images/29e3383826e92d2686e912acd4f9de9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*nmx0enBGHAAnp31ALBndvQ.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">确保在你的申请中加入花生酱；这有助于给他们一个奶油的味道。</figcaption></figure><p id="32c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很漂亮，是吧？</p><h1 id="1a93" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">理智检查:GAE的启动时间有多快？</h1><p id="403b" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">但是让我们退后一步，确认一些事情:对于一个hello-word应用程序，GAE的启动时间有多快？</p><p id="607a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过上面的测试，我能够开始获得关于GAE启动时间有多快的时间数据。为此，我编写了一个脚本，杀死所有实例，发出一个请求，并获取冷启动请求的日志记录时间。</p><p id="9370" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计时的结果相当有趣:<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> App引擎</em> </a> <em class="jp">启动时间真的很快。</em></p><p id="591d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了让事情看得更清楚，我决定用各种类型的配置测试一个基本的应用程序。下图显示了基本hello-world应用程序的实例类型与启动时间的关系:</p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es li"><img src="../Images/8a57cb094d31c25c2fcd9e028e9b7596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*3cu4zfVSLfQlxYgXXtyJ5Q.png"/></div></figure><p id="08ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于F2实例来说，250毫秒的启动时间非常快。这比在4G连接上从大多数cdn获取一个Javascript文件还要快。这意味着GAE本身非常擅长响应实例创建时间。</p><p id="d6c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jp">(注意，如果你想知道为什么B1、B2、B4实例的时间明显变慢，我们将在以后的帖子中讨论这个问题)</em></p><p id="a452" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的加载时间大约是1.2秒，所以很明显，这不是GAE的错，而是“<em class="jp">诱饵和缝合</em>代码中发生了一些事情。</p><h1 id="065f" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">每一毫秒都很重要</h1><p id="cfc6" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">设置了自定义跟踪后，我们现在对“<em class="jp">诱饵和缝合</em>”应用程序的冷启动时间中出现的问题有了一个非常清晰的了解…并且..不太好。但是要解决这个问题，我们需要更深入地挖掘，这是另一篇文章的主题。；)</p></div></div>    
</body>
</html>