<html>
<head>
<title>Dataflow Flex Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据流弹性模板</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/dataflow-flex-templates-2819572f165f?source=collection_archive---------0-----------------------#2022-11-06">https://medium.com/google-cloud/dataflow-flex-templates-2819572f165f?source=collection_archive---------0-----------------------#2022-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aea9238b079d2f8e5ba4f1f60e523142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EbIRv9VO3sWImG3fjfpdg.png"/></div></div></figure><p id="5c70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">借助Dataflow Flex模板，我们可以定义一个Dataflow管道，该管道可以通过来自云控制台、gcloud或REST API调用的请求来执行。通过REST API，就有可能通过云调度器或许多其他机制来启动作业。</p><p id="fb80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我坐下来使用Dataflow Flex模板时，我阅读了文档，似乎有相当多的部分可以让它运行起来。随着我的进一步研究，模型和需求最终都到位了。本文试图简化并说明如何使用Flex模板。</p><p id="130e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先回顾一下在没有Flex模板的情况下启动数据流作业需要做些什么。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/036aa9dfe4aae54debe0ad90d761ca39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/0*pKMJnglQD9gqKN0O"/></div></figure><p id="68fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开发人员用Java编写一个Beam管道(也可以是其他语言，但为了便于讨论，我们将只关注Java)。然后，开发人员运行管道。他们可以在笔记本电脑上运行它进行测试/开发，也可以在计算引擎或其他GCP生产环境中运行。当pipeline应用程序启动时，它会构建一个Apache Beam执行图，然后发送给Dataflow。数据流然后使用它的数据流运行引擎执行图形。对于开发和测试来说，这个工作流是好的，但是对于生产来说有一些问题。首先，为了执行数据流作业，必须将执行图发送到数据流，这是通过使用包括JVM和其他库的环境运行管道应用程序来完成的。这意味着管道(由开发人员编写)可能有一组依赖关系，但当其他人运行管道时，这些依赖关系必须完全复制。这些包括JVM的版本、Beam SDKs的版本等等。这为不匹配创造了机会。说到CI/CD管道，我们就崩溃了。如果开发人员将他们的管道代码签入源代码库，就不能保证测试和生产团队拥有相同的编译和执行环境。</p><p id="f651" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，考虑用户或操作人员。假设您被告知运行一个数据流作业。现在，您必须执行自己的组装来构建启动所需的所有先决条件。如果您是用户，您可能会问“为什么我不能从列表中选择作业并启动它？”。</p><p id="995b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些只是Flex模板解决的几个难题。</p><p id="6c9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看Flex模板的模型。我将使用一种渐进的架构披露技术来帮助我们理解。让我们从最后的结果开始，我们将向后工作。</p><p id="3763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Flex模板为我们创建了两个工件，允许我们启动数据流作业。这是一个Docker映像和一个JSON文件，存储在Google云存储(GCS)中。</p><p id="46ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些在下图中显示为Docker图像和模板文件:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/6de6a432f42ec11ceb3ecc7a83f22482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*T-JALmnFkqV71WCV"/></div></figure><p id="1c56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们来分解一下，这样我们就能清楚地看到发生了什么。我们将从用户想要运行数据流作业的核心概念开始。因此，用户将向Google Cloud API服务发送一个请求，说“开始我的数据流作业”。用户<strong class="is hj">实际上</strong>这样做的方式是命名一个JSON文件，它存在于一个我们称之为模板文件的GCS桶中。我们将在后面介绍这个文件是如何创建的。现在，假设模板文件指向工件注册表中的Docker映像(同样，Docker映像来自哪里将在后面讨论)。</p><p id="ef43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用户刚刚声明“在GCS上运行本文件中描述的数据流作业”。然后，谷歌云查看文件内部，找到Docker图像的身份。然后，谷歌云启动了一个计算引擎，称之为<em class="ju">启动器</em>，并使用Docker映像作为在该计算引擎中运行的映像。Docker映像包含开发人员最初编写的Apache Beam管道的编译代码。当启动器计算引擎最终开始运行时，Docker映像运行并导致数据流执行图被创建并被发送到数据流以执行Beam流水线。</p><p id="918e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里停下来思考这个故事。如果开发人员将他们的Beam管道打包成Docker映像，那么无论在哪里使用它(test，prod ),它都将是完全相同的代码，并且打包了正确的依赖项。这解决了一些最初的困惑。此外，要使用管道，用户只需要<em class="ju">知道GCS bucket中包含的文件的身份，因为当他们启动作业时，这就是他们需要指定的全部内容。</em></p><p id="ebfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用户可以使用以下方式启动数据流作业:</p><p id="cc03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jv jw jx jy b">gcloud dataflow flex-template run</code></p><p id="7746" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者</p><p id="27c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jz" href="https://cloud.google.com/dataflow/docs/reference/rest/v1b3/projects.locations.flexTemplates/launch" rel="noopener ugc nofollow" target="_blank">方法:projects . locations . flex templates . launch</a>—REST API</p><p id="e7ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/b5cc9ebf512ebff98208e231feec2261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EduvVs2sxU9FQeG_"/></div></div></figure><p id="6266" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这三个都将GCS文件对象作为输入参数。</p><p id="8cf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们开始关注我们故事中缺失的部分。我们还没有描述模板文件中包含了什么或者它是如何创建的，也没有描述如何正确地构建Docker映像。</p><p id="0050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然Docker映像<em class="ju">可以手工构建</em>，但我们不会在这里描述它。相反，我们将描述最简单的方法。Google提供了一个名为:</p><p id="2ba0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jv jw jx jy b">gcloud dataflow flex-template build</code></p><p id="ba11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该命令将以下内容作为输入:</p><ul class=""><li id="0ae9" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated">将创建的模板文件的GCS路径</li><li id="bef0" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">用作构建Docker映像基础的基本Docker映像</li><li id="1b55" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">将保存构建的Docker映像的工件存储库</li><li id="65e8" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">波束管道的预编译代码和依赖项</li></ul><p id="5a4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当该命令运行时，它将创建<em class="ju">和</em>Docker映像以及相应的模板文件。</p><p id="6ee1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整个图表如下所示:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/5048cc8430b960408bf94a3cc390a030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SbtTfb_nWY_d2D8U"/></div></div></figure><p id="d7e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到现在为止，你有希望得到我们已经分成两部分的架构模型。</p><p id="c8a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开发人员希望创建一个Docker映像和一个模板文件，最终用于启动数据流作业。用户将知道指向Docker图像的模板文件的名称，Docker图像将用于启动最终的数据流作业。</p><p id="3a29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在将注意力转向如何构建由开发人员构建的JAR，该JAR将被打包到Docker映像中。这个比较棘手。JAR必须不仅包含编译后的Beam代码，还必须包含<em class="ju">所有</em>在构建过程中使用的级别所需的先决条件。Google为此提供了一个包含maven <code class="du jv jw jx jy b">pom.xml</code>文件的Github项目示例。遗憾的是，我不是任何类型的专家，所以无法解释它是如何工作的…但是从使用的角度来看，我们执行:</p><p id="b4e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jv jw jx jy b">mvn package</code></p><p id="d5b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且在目标文件夹中创建一个称为“fat”或“Uber”jar的文件。它很大，包含执行所需的一切。</p><p id="cc33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于Flex模板，我们可以说的还有很多，包括:</p><ul class=""><li id="e2f0" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated">如何向管道传递参数</li><li id="b0ac" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">如何为运行时参数指定默认值</li><li id="0522" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">如何使用Java以外的语言</li></ul><p id="a3d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…但是我们现在有足够的钱让我们继续前进。接下来是让Flex模板可操作的方法。</p><ol class=""><li id="c051" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kq kh ki kj bi translated">创建项目</li></ol><p id="5618" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们为我们的测试创建一个GCP项目。如果你愿意，你可以重复使用现有的。</p><p id="9f91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.启用服务</p><p id="79d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的测试中，由于我们创建了一个新项目，没有预先启用任何服务，我们将启用我们需要的服务。</p><ul class=""><li id="729b" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated">计算引擎</li><li id="32d0" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">数据流</li><li id="aac3" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">工件注册表</li><li id="241c" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated">云构建</li></ul><p id="1bea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.创建GCS存储桶</p><p id="504c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要创建一个GCS存储桶来保存我们的Flex模板GCS文件。</p><p id="eca6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jv jw jx jy b">gs://kolban-dataflow6-tmp</code></p><p id="3f4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.创建一个VPC网络</p><p id="1a9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我建议不要使用默认的VPC网络(如果您有)，并创建了一个名为<code class="du jv jw jx jy b">myvpc</code>的新VPC网络。</p><p id="1ef7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.为工作人员创建服务帐户</p><p id="887a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当数据流运行时，它会创建作为工作者运行的计算引擎。这些必须作为服务帐户运行，这里我们创建一个新的服务帐户，它们将作为服务帐户运行。我称我的为“工人”。</p><p id="244a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.授予工人数据流工人</p><p id="afd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了能够执行数据流工作者的角色，新创建的服务帐户必须被授予数据流工作者角色。</p><p id="ee0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.创建码头报告</p><p id="f025" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个Docker图像将被创建，我们需要一个repo来存储它。我们称这种回购为“T4”。</p><p id="9f29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.授予repo上的worker工件注册表读取器</p><p id="8a06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">worker服务帐户是启动程序运行时使用的服务帐户。它必须拥有读取工件注册表的权限。我们授予它读者角色。</p><p id="21ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">9.克隆我们的示例项目</p><p id="d695" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们克隆了我们的示例Github项目:</p><p id="cd39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jv jw jx jy b">git clone <a class="ae jz" href="https://github.com/kolban-google/flex-templates" rel="noopener ugc nofollow" target="_blank">https://github.com/kolban-google/flex-templates</a></code></p><p id="4882" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">10.切换到克隆的github项目</p><p id="2f88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jv jw jx jy b">cd flex-templates</code></p><p id="a0c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">11.编辑<code class="du jv jw jx jy b">Makefile</code>并改变变量</p><ul class=""><li id="b425" class="kb kc hi is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><code class="du jv jw jx jy b">PROJECT_ID</code></li><li id="2d7c" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><code class="du jv jw jx jy b">BUCKET_NAME</code></li></ul><p id="48ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">12.运行代码生成器</p><p id="43a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我假设您的环境中安装了Java 11和Maven。</p><p id="7c86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行<code class="du jv jw jx jy b">make build-code</code></p><p id="b733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将编译代码并构建fat jar。</p><p id="749b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">13.运行Flex模板生成器</p><p id="fd30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行<code class="du jv jw jx jy b">make build-flex</code></p><p id="aa9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将运行<code class="du jv jw jx jy b">gcloud</code>命令来构建Flex模板。它将使用fat jar并在GCS bucket中构建Docker映像和Flex模板文件。</p><p id="284e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">14.运行Flex模板</p><p id="b289" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行<code class="du jv jw jx jy b">make run-flex</code></p><p id="16bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将使用Flex模板向数据流提交一个作业</p><p id="6f7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后…一个视频演示了本文的一些概念:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><h1 id="0cc7" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><ul class=""><li id="ad58" class="kb kc hi is b it lr ix ls jb lt jf lu jj lv jn kg kh ki kj bi translated"><a class="ae jz" href="https://cloud.google.com/dataflow/docs/concepts/dataflow-templates" rel="noopener ugc nofollow" target="_blank">数据流数据管道模板|谷歌云</a></li><li id="6a44" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" href="https://cloud.google.com/sdk/gcloud/reference/dataflow/flex-template/run" rel="noopener ugc nofollow" target="_blank">g Cloud data flow flex-template run | Google Cloud CLI文档</a></li><li id="ffd5" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" href="https://cloud.google.com/blog/topics/developers-practitioners/why-you-should-be-using-flex-templates-your-dataflow-deployments" rel="noopener ugc nofollow" target="_blank">为什么您应该将Flex模板用于您的数据流部署|数据集成</a></li><li id="bd57" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" href="https://cloud.google.com/blog/products/data-analytics/create-templates-from-any-dataflow-pipeline" rel="noopener ugc nofollow" target="_blank">从任何数据流管道创建模板|谷歌云博客</a></li><li id="07bc" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" rel="noopener" href="/@emailchhavisharma/quick-steps-to-build-deploy-dataflow-flex-templates-python-java-728fc366f0d1">快速构建步骤&amp;部署数据流灵活模板(Python&amp;Java)| by Chhavi Sharma | Medium</a></li><li id="04de" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" href="https://headintheclouds.appsbroker.com/how-to-deploy-a-dataflow-template/" rel="noopener ugc nofollow" target="_blank">如何使用Flex模板部署数据流模板——云端技术</a></li><li id="beb9" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" href="https://www.youtube.com/watch?v=xaoruVUt0jk" rel="noopener ugc nofollow" target="_blank">数据流Flex模板</a>—2020年梁数字峰会</li><li id="cc87" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" href="https://binx.io/2022/07/28/a-declarative-approach-for-dataflow-flex-templates/" rel="noopener ugc nofollow" target="_blank">一种用于数据流Flex模板的声明式方法— Binx </a></li><li id="6cf5" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" rel="noopener" href="/cts-technologies/building-and-testing-dataflow-flex-templates-80ef6d1887c6">在谷歌云中构建、测试和部署数据流灵活模板</a></li><li id="54d4" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" rel="noopener" href="/@tjwebb/using-custom-containers-with-dataflow-flex-templates-f5b59a95ceae">使用带有数据流灵活模板的定制容器</a></li><li id="e2f6" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" rel="noopener" href="/@amal.kumar.singh/dataflow-dynamic-batch-streaming-pipeline-using-flex-templates-python-cc245dad60cd">谷歌云数据流动态(批处理&amp;流)管道使用Flex模板(Python) </a></li><li id="ef00" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" rel="noopener" href="/google-cloud/streaming-data-generator-978846c5c807">GCP上的流数据生成器数据流灵活模板| prat hap Reddy |谷歌云—社区| Medium </a></li><li id="ec80" class="kb kc hi is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj bi translated"><a class="ae jz" href="https://github.com/kolban-google/flex-templates" rel="noopener ugc nofollow" target="_blank">本文Github</a></li></ul></div></div>    
</body>
</html>