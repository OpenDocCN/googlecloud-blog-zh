<html>
<head>
<title>Working with JSON data in BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在BigQuery中使用JSON数据</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/working-with-json-data-in-bigquery-24ca8fd6e90c?source=collection_archive---------0-----------------------#2022-01-25">https://medium.com/google-cloud/working-with-json-data-in-bigquery-24ca8fd6e90c?source=collection_archive---------0-----------------------#2022-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5fd9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用新的JSON数据类型</h2></div><p id="ee86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">BigQuery最近宣布将支持<a class="ae jt" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/json-data" rel="noopener ugc nofollow" target="_blank"> JSON作为数据类型</a>。让我们探讨一下这意味着什么，以及这对我们意味着什么。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/15681a53611e9b6123c1d7f54c64a825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i1CxD3bDpUKamU5EYxM4mQ.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@javad_esmaeili?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贾瓦德·埃斯马埃利</a>在<a class="ae jt" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="624a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">BigQuery中的JSON支持并不新鲜</h2><p id="b477" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">首先，BigQuery中的JSON支持并不新鲜。比如BigQuery早就有JSON查询和JSON生成功能了。您可以:</p><pre class="jv jw jx jy fd lk ll lm ln aw lo bi"><span id="3766" class="kk kl hi ll b fi lp lq l lr ls">SELECT <br/>   <strong class="ll hj">JSON_QUERY</strong>('{"user_id": 3, "name": "Alice","address": {"street": "A Ave","city": "Aville"}}',<br/>              <strong class="ll hj">"$.address.city"</strong>),<br/>   <strong class="ll hj">TO_JSON_STRING</strong>(STRUCT(5 AS user_id, STRUCT('Bob' AS name)))</span></pre><p id="e731" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将返回:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es lt"><img src="../Images/f921bb0230a92eff9c45d6e99424f656.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*A2EFrcZxTBIpaDprdFOkhA.png"/></div></figure><p id="e3d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">新的是JSON是一种<em class="lu">数据类型</em>(加上一组处理该数据类型的函数)——想想地理是如何成为一种类型的，以及它如何打开了ST_*函数的整个世界，而不是让我们自己去计算纬度和经度。</p><h2 id="629e" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">JSON数据类型</h2><p id="d6ca" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">有两种方法可以创建JSON类型的字段:*</p><ul class=""><li id="ba22" class="lv lw hi iz b ja jb jd je jg lx jk ly jo lz js ma mb mc md bi translated">通过对JSON格式的字符串调用PARSE_JSON。安全。如果JSON字符串中有语法错误，PARSE_JSON告诉BigQuery对对象使用null。</li><li id="e940" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">通过在结构上调用TO_JSON</li></ul><p id="9eb1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这说明了两种方法:</p><pre class="jv jw jx jy fd lk ll lm ln aw lo bi"><span id="b93b" class="kk kl hi ll b fi lp lq l lr ls">WITH input_table AS (<br/>   SELECT <strong class="ll hj">SAFE.PARSE_JSON</strong>('{"user_id": 3, "name": "Alice","address": {"street": "A Ave","city": "Aville"}}') AS user<br/>   UNION ALL<br/>   SELECT <strong class="ll hj">TO_JSON</strong>(STRUCT(5 AS user_id, 'Bob' as name,<br/>                         STRUCT('B Blvd' AS street, 'Bville' AS city) AS address)) AS user<br/>)</span><span id="5362" class="kk kl hi ll b fi mj lq l lr ls">SELECT <br/>   user, <br/>   user['name'], <br/>   INT64(user.user_id),<br/>   user.address.street<br/>FROM input_table</span></pre><p id="74a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码还说明了如何使用JSON数据类型:</p><ul class=""><li id="af58" class="lv lw hi iz b ja jb jd je jg lx jk ly jo lz js ma mb mc md bi translated">用户是一个列。所以你可以选择它，得到整个物体。</li><li id="6daa" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">您可以使用user['name']这样的语法提取JSON的各个部分</li><li id="d5e6" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">您也可以使用点语法提取数据。这将返回一个JSON对象。您可以将它转换成您想要的类型:INT64(user.user_id)</li><li id="63f4" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">您可以使用多个点进入嵌套结构。深达500。</li></ul><p id="6201" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果有数组，可以使用[0]、[1]等来访问元素。</p><p id="b79d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*还有第三种创建JSON数据类型的方法——如果您有一个包含定义为JSON类型的列的表，您可以在该列中插入一个字符串，然后进行自动转换:</p><pre class="jv jw jx jy fd lk ll lm ln aw lo bi"><span id="bc93" class="kk kl hi ll b fi lp lq l lr ls">INSERT INTO NEW_TABLE_WITH_JSON_TYPE<br/>SELECT * FROM OLD_TABLE_WITH_STRINGS;</span></pre><h2 id="6129" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">JSON数据类型更具性能</h2><p id="c536" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">那么，如果我们已经能够查询和生成JSON，那么JSON数据类型还有什么意义呢？</p><p id="dacf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">性能(以及隐含的成本)。</p><p id="7bb8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当创建JSON类型的列时，数据以解析的形式存储。因此，您可以获得列数据库的所有好处。</p><p id="7e60" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了验证这一点，让我们创建一个新的BigQuery数据集，并用JSON值模拟一个表。在一列中，我们将JSON存储为字符串，在另一列中，我们将它存储为JSON类型:</p><pre class="jv jw jx jy fd lk ll lm ln aw lo bi"><span id="d526" class="kk kl hi ll b fi lp lq l lr ls">-- START Random generation function<br/>CREATE TEMP FUNCTION MapChar(c INT64) AS (<br/>  CASE<br/>    WHEN c BETWEEN 0 AND 9 THEN 48 + c -- 0 to 9<br/>    WHEN c BETWEEN 10 AND 35 THEN 55 + c -- A to Z<br/>    ELSE 61 + c -- a to z<br/>  END<br/>);</span><span id="4591" class="kk kl hi ll b fi mj lq l lr ls">CREATE TEMP FUNCTION random_string(id INTEGER) AS ((<br/>  SELECT CODE_POINTS_TO_STRING(ARRAY_AGG(MapChar(MOD(c, 62))))<br/>  FROM UNNEST(TO_CODE_POINTS(MD5(CAST(RAND() + id AS STRING)))) AS c<br/>));<br/>-- END Random generation function</span><span id="b77e" class="kk kl hi ll b fi mj lq l lr ls"><strong class="ll hj">CREATE OR REPLACE TABLE advdata.simulated_json AS</strong></span><span id="a929" class="kk kl hi ll b fi mj lq l lr ls">WITH input_data AS (<br/>  SELECT STRUCT(id AS user_id,<br/>                 STRUCT(random_string(id) AS name, random_string(id) AS city) AS address) AS user<br/>  FROM UNNEST(GENERATE_ARRAY(1, 1000*1000)) AS id<br/>)<br/>SELECT <br/>  <strong class="ll hj">TO_JSON(user) AS user_json,<br/>  TO_JSON_STRING(user) AS user_json_string</strong></span></pre><p id="2746" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的查询生成了一百万个用随机值填充的名为user的结构。这些看起来像这样:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mk"><img src="../Images/df87931d053c29c8e703207e0e44b7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJjJakLidsxAyStMytA8Cw.png"/></div></div></figure><p id="0645" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用“老”的方式写一个查询:</p><pre class="jv jw jx jy fd lk ll lm ln aw lo bi"><span id="0d3f" class="kk kl hi ll b fi lp lq l lr ls">CREATE TEMPORARY FUNCTION INT64(x STRING) AS<br/>(<br/>  CAST(JSON_VALUE(x) AS INT64)<br/>);</span><span id="3872" class="kk kl hi ll b fi mj lq l lr ls">SELECT AVG(INT64(<strong class="ll hj">JSON_QUERY(user_json_string, "$.user_id"))</strong>)<br/>FROM advdata.simulated_json</span></pre><p id="26b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所料，结果是500，000.5，但更有趣的是处理的数据量:80 MB。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ml"><img src="../Images/f57f8c6c36882412e7ca69a921f23503.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*lRiD9K1Jux6rN5_Etl0tQQ.png"/></div></figure><p id="019e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是整个JSON字符串的大小。</p><p id="2409" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们以新的方式编写查询，利用JSON数据类型和点语法来解析它:</p><pre class="jv jw jx jy fd lk ll lm ln aw lo bi"><span id="f651" class="kk kl hi ll b fi lp lq l lr ls">SELECT AVG(INT64(<strong class="ll hj">user_json.user_id</strong>))<br/>FROM advdata.simulated_json</span></pre><p id="5ee4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，查询将只提取user_id“子列”,最终只处理7.6 MB的数据！</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ml"><img src="../Images/bf80d24afd969f14679222130aa4ebe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*2s9DHAUIUSClBjCl3agAjw.png"/></div></figure><p id="7d69" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果将日志或其他以JSON字符串形式出现的数据存储为类型为JSON(而不是string)的列，查询会更有效。</p><p id="bd6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它也更便宜，因为您处理的数据更少(如果您是按需付费)。如果您支付统一费率，您可以在较短的时间内使用您的老虎机，因此您可以使用您的老虎机做更多的事情。</p><p id="2e99" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽情享受吧！</p><p id="bd23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢Chris Crosbie对这篇文章的有益评论和建议。</p></div></div>    
</body>
</html>