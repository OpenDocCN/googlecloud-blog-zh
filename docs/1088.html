<html>
<head>
<title>Cloud Run: multiple processes in a container (the lazy way)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云运行:容器中的多个进程(懒惰方式)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-run-multiple-processes-4b6f1b3827e?source=collection_archive---------0-----------------------#2019-07-23">https://medium.com/google-cloud/cloud-run-multiple-processes-4b6f1b3827e?source=collection_archive---------0-----------------------#2019-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="13e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多<a class="ae jd" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> Google Cloud Run </a>用户第一次开始开发容器，但他们通常会迁移他们现有的应用程序。有时，这些应用程序并没有被设计为适合每个容器一个进程模型的微服务，而是需要多个服务器进程在一个容器中一起运行。</p><p id="45f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你经常会听到“在一个容器中运行多个进程是不好的”，尽管这样做并没有什么错，正如我在我的<a class="ae jd" href="https://ahmet.im/blog/minimal-init-process-for-containers/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>比较针对容器优化的init系统中解释的那样。</p><p id="cd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将展示一个不是超级生产就绪的(因此称为“懒惰方式”)但是在Cloud Run上运行多进程容器的工作解决方案，并将提供<a class="ae jd" href="https://github.com/ahmetb/multi-process-container-lazy-solution" rel="noopener ugc nofollow" target="_blank">示例代码</a>。</p><h1 id="1fe0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">示例使用案例</h1><p id="f72a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">来到<a class="ae jd" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">云运行</a>作为一个新用户，<strong class="ih hj">出于各种原因，您可能需要在一个容器</strong>中运行多个流程，例如:</p><ul class=""><li id="e2be" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">在你的应用程序前进行反向代理(比如nginx/Envoy或云端点)</li><li id="dfba" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">通过主HTTP服务器公开的非HTTP服务器(如grpc-web)</li><li id="633c" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">出站流量的本地代理服务器</li><li id="5778" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">实例本地缓存(例如memcached)</li><li id="3127" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">合作过程的其他例子</li></ul><h1 id="4aad" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">设计容器</h1><p id="73c8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在本文中，我将使用nginx示例。我们希望开发一个运行<code class="du kv kw kx ky b">nginx</code>服务器以及您的服务器应用程序的容器映像。</p><p id="ea89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在主云运行端口(8080)上运行<code class="du kv kw kx ky b">nginx</code>，您在8081上的服务器作为<code class="du kv kw kx ky b">nginx</code>将流量路由到您的应用程序，如下所示:</p><ul class=""><li id="0bf9" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><code class="du kv kw kx ky b">/static/*</code>路径由nginx从本地文件系统提供服务</li><li id="b762" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><code class="du kv kw kx ky b">/*</code>其他任何东西都被转发到你的主服务器进程</li></ul><p id="0f56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个容器必须有一个单独的<em class="kz">入口点</em>进程。当入口点退出时，容器就死了。因此，您仍然需要一个“入口点脚本”来启动两个服务器(<code class="du kv kw kx ky b">nginx</code>和您的应用程序)。</p><p id="dffc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果其中一个服务器终止(表明有问题)，您的entrypoint脚本也应该很快终止，而不是试图恢复服务器进程(因为无论如何容器都很容易重启)。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es la"><img src="../Images/c1184d205d154fbd157708f79e46bc76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dupOkE32xiENO31s.png"/></div></div></figure><p id="f649" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个入口点脚本并不像“保姆进程”那样监督子进程并重新启动它们。它宁愿等待其中一个终止，所以我们可以通过退出容器来快速失败。</p><p id="536b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，您编写了一个<code class="du kv kw kx ky b">bash</code>脚本作为您的容器的入口点，它启动并等待您想要运行的实际服务器:</p><p id="f02d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动并等待要运行的实际服务器的容器的输入点:</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="5fd9" class="lq jf hi ky b fi lr ls l lt lu">#!/usr/bin/env bash<br/>set -e</span><span id="d64c" class="lq jf hi ky b fi lv ls l lt lu"><strong class="ky hj">nginx &amp;</strong><br/>env PORT=8081 <strong class="ky hj">/path/to/your-app &amp;</strong></span><span id="a204" class="lq jf hi ky b fi lv ls l lt lu">wait -n</span></pre><ul class=""><li id="151c" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><code class="du kv kw kx ky b">&amp;</code>使进程在后台运行(但它仍然作为这个脚本的子进程)</li><li id="ac67" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><code class="du kv kw kx ky b">wait -n</code>(bash 4.3中引入)在后台进程退出时立即返回(表明服务器进程有问题)，这样我们就可以终止容器。</li><li id="55f9" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><code class="du kv kw kx ky b">env PORT=...</code>命令会覆盖实际应用的<code class="du kv kw kx ky b">$PORT</code>入口点，因为<code class="du kv kw kx ky b">nginx</code>将使用云运行端口=8080。</li></ul><h1 id="84b7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">bash:一个合适的初始化进程？</h1><p id="19ec" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Linux容器的Entrypoint进程用PID(进程id) <code class="du kv kw kx ky b">1</code>运行，它有<a class="ae jd" href="https://vagga.readthedocs.io/en/latest/pid1mode.html" rel="noopener ugc nofollow" target="_blank">特殊职责</a>，例如(但不限于):</p><ul class=""><li id="26ba" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">将信号转发给子进程</li><li id="5114" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">处理如何处理一个死亡的间接子进程是它的父进程(又名<a class="ae jd" href="https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/" rel="noopener ugc nofollow" target="_blank">僵尸子进程收割</a>问题)</li></ul><p id="62d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们让入口点成为一个<code class="du kv kw kx ky b">bash</code>脚本时，它不能做这些事情。由于云运行的应用程序应该是无状态的(并且在任何时候都会被不体面地终止)，所以我们不太关心信号转发行为。</p><p id="f249" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，僵尸子进程收割可能是一个问题，尤其是当您运行的程序(如nginx)启动了许多短命的子进程，因为它们的子进程将成为入口点的父进程。</p><p id="c56f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了处理这些情况，您可以插入一个小的<a class="ae jd" href="https://en.wikipedia.org/wiki/Init" rel="noopener ugc nofollow" target="_blank"> init进程</a>，如<a class="ae jd" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> tini </strong> </a>作为您的容器的新入口点，并从那里启动脚本(因为<code class="du kv kw kx ky b">tini</code>仍然不能管理我们需要的多个子进程):</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lw"><img src="../Images/ebb245ed6864ae0514e9c3e91488186c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IBhhLJn65qVK1W3f.png"/></div></div></figure><p id="2fb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，<code class="du kv kw kx ky b">tini</code>帮助您收获子流程。参考<a class="ae jd" href="https://github.com/ahmetb/multi-process-container-lazy-solution" rel="noopener ugc nofollow" target="_blank">库</a>中的<code class="du kv kw kx ky b">Dockerfile</code>来查看<code class="du kv kw kx ky b">tini</code>如何集成为新的入口点。</p><h1 id="5117" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">尝试一下</h1><p id="7c9a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如前面所承诺的，<a class="ae jd" href="https://github.com/ahmetb/multi-process-container-lazy-solution" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里有一个示例应用程序</strong> </a>，它包含了<code class="du kv kw kx ky b">Dockerfile</code>和NGINX容器的源代码，NGINX服务于<code class="du kv kw kx ky b">/static/*</code>上的静态资产，并将其他所有东西代理给Python服务器。</p><p id="777a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦您将这个容器映像部署到Cloud Run，您就获得了一个容器，该容器为在单个容器中运行的多个流程的流量提供服务。</p><p id="fd8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以阅读我以前的文章<a class="ae jd" rel="noopener" href="/google-cloud/init-process-for-containers-d03a471fa0cc">containers的init系统比较</a>，了解更多关于在容器中运行多个进程的其他选项。</p><p id="278f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这有助于您将现有的或遗留的应用程序迁移到云运行，并利用无服务器容器，请在Twitter上告诉我<a class="ae jd" href="https://twitter.com/ahmetb" rel="noopener ugc nofollow" target="_blank"/>！</p><p id="3994" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇博文中，我将探索使用一个<em class="kz">实际的</em> <code class="du kv kw kx ky b">init</code>流程(而不是<code class="du kv kw kx ky b">bash</code>)来监督容器环境中的子流程。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="6cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kz">原载于2019年7月23日</em><a class="ae jd" href="https://ahmet.im/blog/cloud-run-multiple-processes-easy-way/" rel="noopener ugc nofollow" target="_blank"><em class="kz">Ahmet . im</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>