<html>
<head>
<title>Playing with Python Kubernetes API: Running Tasks in Jobs Generated by a Pod in Google Kubernetes Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python Kubernetes API:在由Google Kubernetes引擎中的Pod生成的作业中运行任务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/playing-with-python-kubernetes-api-running-tasks-in-jobs-generated-by-a-pod-in-google-kubernetes-b5048696dfa8?source=collection_archive---------1-----------------------#2019-12-29">https://medium.com/google-cloud/playing-with-python-kubernetes-api-running-tasks-in-jobs-generated-by-a-pod-in-google-kubernetes-b5048696dfa8?source=collection_archive---------1-----------------------#2019-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5524" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些用例中，您可以使用一个作业进行一次性查询，然后为了优化应用程序而保存在一些缓存中。<br/>当我试图利用Kubernetes API来执行这个任务时，我就是这么想的。</p><blockquote class="jd je jf"><p id="3902" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">那么为什么是Python呢？因为我的这个项目与分析有关，如果我使用Python实际上更合适，因为它已经为我提供了许多统计库，如Pandas和Scipy，并且它还为我可能需要能够与其他组件交互的其他库建立了库。</p></blockquote><p id="7704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在直接进入主题之前，我想简单解释一下Kubernetes API服务器、Kubernetes认证方法、Kubernetes授权和Kubernetes客户端。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="1d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">介绍API服务器</strong></p><blockquote class="jd je jf"><p id="6727" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">中央管理实体和唯一可以直接访问etcd的组件，作为HTTP上的RESTful API实现，所有其他组件通过它进行交互…</p></blockquote><p id="8cdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes API基本上是一个HTTP API，JSON是它的主要序列化模式。它还支持协议缓冲区(主要用于集群内部通信)。出于可扩展性的原因，Kubernetes支持不同API路径下的多个API版本。现在看看HTTP API空间是如何构造的。在顶层，我们区分核心组(<code class="du js jt ju jv b">/api/v1</code>)、命名组(<code class="du js jt ju jv b">/apis/$NAME/$VERSION</code>)和全系统实体(如<code class="du js jt ju jv b">/metrics</code>)。注意版本可以是<code class="du js jt ju jv b">v1alpha1</code>(默认禁用)、<code class="du js jt ju jv b">v2beta3</code>(默认启用)和<code class="du js jt ju jv b">v1</code>。</p><p id="e14a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，Kubernetes API支持通过标准的HTTP动词<code class="du js jt ju jv b">POST</code>、<code class="du js jt ju jv b">PUT</code>、<code class="du js jt ju jv b">DELETE</code>和<code class="du js jt ju jv b">GET</code>在给定路径上进行创建、更新、删除和检索操作，并将JSON作为默认负载。</p><p id="d069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">API组、版本和资源(GVR)唯一地定义了HTTP路径:</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es jw"><img src="../Images/25358962c925d987435ea219f7a5635c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WOFozY18oqNVvJ22qvaTA.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">作业HTTP路径的外观。</figcaption></figure><p id="5fef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，当HTTP请求命中Kubernetes API时，首先应用的是请求将由在<code class="du js jt ju jv b">DefaultBuildHandlerChain()</code> ( <a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/config.go" rel="noopener ugc nofollow" target="_blank"> config.go </a>)中注册的过滤器链处理。这期间会发生什么？在高层次上，过滤器或者传递相应的信息并将其附加到<code class="du js jt ju jv b">ctx.RequestInfo</code>，比如经过身份验证的用户，或者返回适当的HTTP响应代码。现在我们将试着更深入地看看<code class="du js jt ju jv b">DefaultBuildHandlerChain()</code>内部设置的过滤器:</p><ul class=""><li id="5399" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithRequestInfo()</code>如<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/requestinfo.go" rel="noopener ugc nofollow" target="_blank"> requestinfo.go中所定义</a>将一个<code class="du js jt ju jv b"><a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/585f7eed30ae80d4b946d4b7c849dd47febdc498/pkg/endpoints/request/requestinfo.go#L117" rel="noopener ugc nofollow" target="_blank">RequestInfo</a></code>附加到上下文中</li><li id="2e72" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithMaxInFlightLimit()</code>如<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/maxinflight.go" rel="noopener ugc nofollow" target="_blank">中所定义，maxinflight.go </a>限制飞行中请求的数量</li><li id="9c6d" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithTimeoutForNonLongRunningRequests()</code>如<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/timeout.go" rel="noopener ugc nofollow" target="_blank"> timeout.go </a>中所定义，与大多数<code class="du js jt ju jv b">GET</code>、<code class="du js jt ju jv b">PUT</code>、<code class="du js jt ju jv b">POST</code>、<code class="du js jt ju jv b">DELETE</code>请求一样，非长时间运行的请求超时，这与长时间运行的请求(如观察器和代理请求)相反</li><li id="a624" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithPanicRecovery()</code>如<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/wrap.go" rel="noopener ugc nofollow" target="_blank"> wrap.go中所定义</a>包装一个处理程序来恢复和记录死机</li><li id="0843" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/server/filters/cors.go" rel="noopener ugc nofollow" target="_blank">中定义的<code class="du js jt ju jv b">WithCORS()</code>cors . go</a>提供了一个CORS实现；CORS代表跨源资源共享，它是一种机制，允许嵌入在HTML页面中的JavaScript向不同于JavaScript起源的域发出XMLHttpRequests。</li><li id="02af" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithAuthentication()</code>如<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authentication.go" rel="noopener ugc nofollow" target="_blank">中所定义的，authentication.go </a>尝试将给定请求认证为用户，并将用户信息存储在提供的上下文中。成功时，从请求中删除<code class="du js jt ju jv b">Authorization</code> HTTP头。</li><li id="a45f" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithAudit()</code>如<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/audit.go" rel="noopener ugc nofollow" target="_blank"> audit.go </a>中所定义，用所有传入请求的审计日志信息来修饰处理程序。审计日志条目包含诸如请求的源IP、调用操作的用户和请求的名称空间等信息。</li><li id="e8fe" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithImpersonation()</code>如<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/impersonation.go" rel="noopener ugc nofollow" target="_blank"> impersonation.go中定义的那样</a>通过检查试图改变用户的请求来处理用户模拟(类似于sudo)。</li><li id="e43f" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><code class="du js jt ju jv b">WithAuthorization()</code>在<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/master/pkg/endpoints/filters/authorization.go" rel="noopener ugc nofollow" target="_blank"> authorization.go </a>中定义，将所有授权的请求传递给多路复用器，多路复用器将请求发送给正确的处理器，否则返回禁止错误。</li></ul></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="b50a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Kubernetes认证</strong></p><p id="ec78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Kubernetes中，我们有两种用户定义:</p><ul class=""><li id="bcdc" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">由Kubernetes管理的服务帐户，通常由Kubernetes API管理，绑定到特定的名称空间，由API服务器自动创建或通过API调用手动创建(其凭证保存为安装到pods的<code class="du js jt ju jv b">Secrets</code>,从而允许集群内进程与Kubernetes API对话)；</li><li id="52b9" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">普通用户，通常由外部独立服务管理。</li></ul><p id="6e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes使用客户端证书、不记名令牌、认证代理或HTTP basic auth来通过认证插件认证API请求。当向API服务器发出HTTP请求时，插件试图将以下属性与在<code class="du js jt ju jv b"><a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/585f7eed30ae80d4b946d4b7c849dd47febdc498/pkg/authentication/group/authenticated_group_adder.go#L39" rel="noopener ugc nofollow" target="_blank">AuhenticateRequest(req *http.Request)</a></code>中定义的请求相关联。更多信息可以在<a class="ae jr" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" rel="noopener ugc nofollow" target="_blank">认证</a>中阅读。我们的一个认证策略是使用X509客户端证书。这也是理解GKE认证过程的前提。</p><p id="f64a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GKE有自己的控制平面。在GKE集群中，控制平面组件运行在Google拥有的GCE实例上，在一个单独的Google管理的项目中。每个实例只为一个客户运行这些组件。每个集群都有自己的<a class="ae jr" href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster" rel="noopener ugc nofollow" target="_blank">根认证机构(CA) </a>。内部服务管理此CA的根密钥。每个集群也有自己的etcd CA。etcd CA的根密钥被分发到运行Kubernetes API服务器的虚拟机的元数据中。节点和Kubernetes API服务器之间的通信受TLS保护。有关更多信息，请参见<a class="ae jr" href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-trust" rel="noopener ugc nofollow" target="_blank">集群信任</a>。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="8faa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Kubernetes授权</strong></p><p id="86a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes使用API服务器授权API请求。它根据所有策略评估所有请求属性，并允许或拒绝请求。API请求的所有部分都必须被某个策略允许才能继续。这种授权的功能一般在<a class="ae jr" href="https://github.com/kubernetes/apiserver/blob/585f7eed30ae80d4b946d4b7c849dd47febdc498/pkg/endpoints/filters/authorization.go#L45" rel="noopener ugc nofollow" target="_blank">那里</a>中提到。有几种<a class="ae jr" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" rel="noopener ugc nofollow" target="_blank">授权模式</a>，其中一个例子是RBAC，或基于角色的认证模式。<code class="du js jt ju jv b">kubectl</code>提供了一种使用<code class="du js jt ju jv b">auth can-i</code>命令验证特定API授权层的机制。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="2050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">支持的Kubernetes客户端</strong></p><p id="a45e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多由官方支持或由社区维护的受支持客户端，列表可以在<a class="ae jr" href="https://kubernetes.io/docs/reference/using-api/client-libraries/" rel="noopener ugc nofollow" target="_blank">那里</a>看到。</p><p id="af62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端库通常会为您处理一些常见的任务，例如身份验证。大多数客户端库可以发现并使用Kubernetes服务帐户来验证API客户端是否在Kubernetes集群中运行，或者可以理解<a class="ae jr" href="https://kubernetes.io/docs/tasks/access-application-cluster/authenticate-across-clusters-kubeconfig/" rel="noopener ugc nofollow" target="_blank"> kubeconfig文件</a>格式来读取凭证以及API服务器地址。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="5770" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用Kubernetes Python客户端</strong></p><pre class="jx jy jz ka fd la jv lb lc aw ld bi"><span id="0f1c" class="le lf hi jv b fi lg lh l li lj">import os<br/>from kubernetes import client, config, utils<br/>from kubernetes.client.rest import ApiException</span><span id="233e" class="le lf hi jv b fi lk lh l li lj">class Constants(obj):<br/>    NAMESPACE = 'example'</span><span id="f80b" class="le lf hi jv b fi lk lh l li lj">class KubernetesApiClient(obj):<br/>    def __init__(self):<br/>        # load <br/>        try:<br/>            config.load_incluster_config()<br/>        except:<br/>            config.load_kube_config()</span><span id="ee0f" class="le lf hi jv b fi lk lh l li lj">self.configuration = client.Configuration()</span><span id="1d45" class="le lf hi jv b fi lk lh l li lj">def create_batch_api_client(self):<br/>        return client.BatchV1Api(client.ApiClient(self.configuration))</span><span id="9658" class="le lf hi jv b fi lk lh l li lj">def create_job_object(self, job_name, container_image, args):<br/>        volume_name = "" # volume inside of which you put your service account<br/>        google_app_credentials_path = os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')<br/>        volume_mount = client.V1VolumeMount(<br/>            mount_path='/'.join(google_app_credentials_path.split('/')[:-1]),<br/>            name=volume_name<br/>        )</span><span id="160e" class="le lf hi jv b fi lk lh l li lj">env = client.V1EnvVar(<br/>            name='GOOGLE_APPLICATION_CREDENTIALS',<br/>            value=google_app_credentials_path<br/>        )</span><span id="77b9" class="le lf hi jv b fi lk lh l li lj">container = client.V1Container(<br/>            name=job_name,<br/>            image=container_image,<br/>            args=args,<br/>            volume_mounts=[volume_mount],<br/>            env=[env],<br/>            image_pull_policy="Always")</span><span id="85e6" class="le lf hi jv b fi lk lh l li lj">volume = client.V1Volume(<br/>            name=volume_name,<br/>            secret=client.V1SecretVolumeSource(secret_name='&lt;secret-where-you-put-the-service-account&gt;')<br/>        )</span><span id="1a3c" class="le lf hi jv b fi lk lh l li lj">template = client.V1PodTemplateSpec(<br/>            metadata=client.V1ObjectMeta(labels={"app": "sample"}),<br/>            spec=client.V1PodSpec(restart_policy="Never", <br/>                                  containers=[container],<br/>                                  volumes=[volume]))</span><span id="d073" class="le lf hi jv b fi lk lh l li lj">spec = client.V1JobSpec(<br/>            template=template,<br/>            backoff_limit=3,<br/>            ttl_seconds_after_finished=60)</span><span id="f25a" class="le lf hi jv b fi lk lh l li lj">job = client.V1Job(<br/>            api_version="batch/v1",<br/>            kind="Job",<br/>            metadata=client.V1ObjectMeta(name=job_name),<br/>            spec=spec)</span><span id="4e91" class="le lf hi jv b fi lk lh l li lj">return job</span></pre><p id="ceeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后你可以调用你的程序:</p><pre class="jx jy jz ka fd la jv lb lc aw ld bi"><span id="58e8" class="le lf hi jv b fi lg lh l li lj">api_client = KubernetesApiClient()</span><span id="1454" class="le lf hi jv b fi lk lh l li lj">job_api_client = api_client.create_batch_api_client()</span><span id="247f" class="le lf hi jv b fi lk lh l li lj">job = api_client.create_job_object(job_name, container_image, args)</span><span id="4ec8" class="le lf hi jv b fi lk lh l li lj"><em class="jg">try</em>: <br/>    api_response = job_api_client.create_namespaced_job(<br/>        namespace=Constants.NAMESPACE,<br/>        body=job)<br/>    <em class="jg">print</em>(str(api_response.status))<br/><em class="jg">except </em>ApiException <em class="jg">as </em>e:<br/>    <em class="jg">print</em>(e) # Handle the exception.</span></pre><p id="9e3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将该应用程序部署到集群中之前，请确保您使用的服务帐户已经能够访问您将在其中部署Kubernetes作业的名称空间，尤其是在您使用RBAC的情况下。</p><blockquote class="jd je jf"><p id="e444" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">我们希望你能派上用场。👋</p></blockquote></div></div>    
</body>
</html>