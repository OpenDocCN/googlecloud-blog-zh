<html>
<head>
<title>When to allow your environment to drift? and other edge cases for Terraform.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候让你的环境随波逐流？以及地形的其他边缘情况。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/when-to-allow-your-environment-to-drift-and-other-edge-cases-for-terraform-a45b290bf013?source=collection_archive---------2-----------------------#2022-11-21">https://medium.com/google-cloud/when-to-allow-your-environment-to-drift-and-other-edge-cases-for-terraform-a45b290bf013?source=collection_archive---------2-----------------------#2022-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="00e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Terraform是在云中供应基础架构的行业标准，它之所以出色有很多原因——它是开源的，与云无关，支持单击实例化和不可变的基础架构。这给我们带来了手头的问题，这与Terraform的一个关键优势密切相关，即不变性和环境漂移。</p><p id="d29b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说环境漂移。环境漂移是基础设施代码和实时环境状态不匹配的现象。从而导致漂移。如果你在原生云领域工作，你会知道这是不可取的，因为它违背了原生云原则，即你的基础设施代码应该是你的环境的唯一真实来源。但是这有反模式吗？</p><p id="af66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个我们不希望环境漂移被校正的场景。假设我们的基础设施代码声明我们有3个标签——LOB名称、成本中心和计费ID。<em class="jd">假设您正在公共云上运行一个自助服务平台，并使用这些标签向相应部门收取云消费费用。</em>这些标签是永久性的，是作为自动化基础设施实例化管道的一部分创建的。并因此在“terraform.tfstate”文件中被跟踪，该文件是terraform的真实世界资源到您的配置的映射，跟踪元数据；简而言之，它捕捉到了上次运行Terraform“应用”或“刷新”时您的环境所处的真实状态。如果从控制台或CLI更新这些标签的键值对之一，环境状态将与“terraform.state”不匹配，从而导致漂移。</p><p id="0f57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果您为环境重新运行terraform，它将重写这些值以匹配基础设施代码。<em class="jd">这无疑是地形最强的能力之一，也是它被如此广泛接受的原因。</em>这也将我们带到了一个边缘案例，假设发生了重组(发生的次数超过了我们的期望，对吗？)因此，成本中心和计费ID已经更改。这是一个关键的更新，将决定谁为各自的资源计费，如果您的计费周期即将结束，它也可能是时间敏感的。还有一个因素要考虑，这些变化可能是频繁的。</p><p id="b66d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有两个选择，通过控制台或CLI更新Terraform代码以反映更改或更新键值对。</p><p id="ce55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上述场景中，在Terraform之外更新值可能是有利的，在这些场景中，更新代码是一项开销，并且/或者管理成本中心和计费ID的资源希望能够自由地在云中管理这些资源，而不需要管理Terraform的团队参与。</p><p id="091c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，Terraform想到并接受了这种边缘情况，并为其构建了一个特性。</p><p id="b15b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入(请击鼓)“元论点”。<code class="du je jf jg jh b">lifecycle</code>是可以出现在资源块中的嵌套块。<code class="du je jf jg jh b">lifecycle</code>块及其内容是元参数。</p><p id="2cbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">注:适用于所有</em> </strong> <code class="du je jf jg jh b"><strong class="ih hj"><em class="jd">resource</em></strong></code> <strong class="ih hj"> <em class="jd">块，不论类型。</em> </strong></p><p id="0d7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生命周期资源块中特定于我们的边缘案例的参数是<code class="du je jf jg jh b">ignore_changes</code>元参数。</p><p id="e7c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，Terraform会检测真实基础架构对象的当前设置中的任何差异，并计划更新远程对象以匹配配置</p><p id="fe8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">ignore_changes</code>元变元旨在用于在创建资源时引用将来可能改变的数据，但在创建后不应影响所述资源。在一些罕见的情况下，远程对象的设置被Terraform之外的进程修改，Terraform将在下次运行时尝试“修复”。为了使Terraform通过单独的进程分担单个对象的管理责任，<code class="du je jf jg jh b">ignore_changes</code>元参数指定了Terraform在计划相关远程对象的更新时应该忽略的资源属性。</p><p id="939d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当计划一个<em class="jd">创建</em>操作时，对应于给定属性名的参数被考虑，但是当计划一个<em class="jd">更新</em>时，这些参数被忽略。参数是资源中属性的相对地址。映射和列表元素可以使用索引符号引用，分别像<code class="du je jf jg jh b">tags["Name"]</code>和<code class="du je jf jg jh b">list[0]</code>。"<em class="jd"> —来自Terraform网页</em></p><p id="389a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的文字表示，添加到ignore_changes元参数的属性仍将在“terraform应用和销毁”时创建和销毁，但不会在随后的“terraform应用”中更新(重写或修复)。这正好解决了我们的问题。每当业务事件导致“成本中心”和“计费ID”发生变化时，相关的FinOps团队可以去更新这些标签的键:值对，而不必担心地形和相关的延迟。</p><p id="8c80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是它想要的效果:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/40c02e6d639686274ec54b2072046ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zbJtZ5yBX42LFiiQ"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">ignore_changes元参数</figcaption></figure><p id="59a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du je jf jg jh b">lifecycle</code>块中可用的其他参数有<code class="du je jf jg jh b">create_before_destroy</code>、<code class="du je jf jg jh b">prevent_destroy</code>和<code class="du je jf jg jh b">replace_triggered_by</code>。所有这些论点都有它们适合的独特的边缘情况。让我们从更高的层面来看待它们。</p><p id="c641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">create_before_destroy</code>:默认情况下，当Terraform必须更改由于远程API限制而无法就地更新的资源参数时，Terraform会销毁现有对象，然后用新配置的参数创建一个新的替换对象。<code class="du je jf jg jh b">create_before_destroy</code>元参数改变了这种行为，因此新的替换对象首先被创建<em class="jd">，</em>并且先前的对象在替换对象被创建后被销毁。这对于我们不希望停机的边缘情况非常有用，例如，我们总是希望资源的副本处于运行状态。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/5bf7338bef95ea0fdd71985997f64889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8XvleNiESw2PJypH"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">create_before_destroy元参数</figcaption></figure><p id="f686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">prevent_destroy</code>:当设置为<code class="du je jf jg jh b">true</code>时，该元参数将导致Terraform错误地拒绝任何会破坏与资源相关联的基础设施对象的计划，只要该参数仍然存在于配置中。这可以作为一种安全措施，防止复制成本高昂的对象(如业务关键型计算)被意外替换。<code class="du je jf jg jh b">prevent_destroy</code>提供了一个额外的保护层，防止意外删除，或者为您想要在Terraform之外管理的资源提供保护。元参数设置为“true”的资源的销毁需要一个额外的步骤来确认您“真的”想要删除该资源。您可以对Terraform代码进行更改，在提交之前会经过一个PR过程，或者您必须到控制台手动删除资源(理想情况下只有少数人有权限这样做)。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jy"><img src="../Images/e75f49b4bd46fb416d951c2611f025b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7VxQPtzeEMyRDYuz6YkSg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">防止_销毁元参数</figcaption></figure><p id="3876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">replace_triggered_by</code>:当任何被引用的资源发生变化时，替换该资源。注意，这里的更改包括修改和删除。您可以提供引用多个资源的表达式列表。</p><p id="4b8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在以下情况下，引用会触发替换:</p><ul class=""><li id="eda0" class="jz ka hi ih b ii ij im in iq kb iu kc iy kd jc ke kf kg kh bi translated">如果引用具有多个实例的资源，更新或替换任何实例的计划将触发替换。</li><li id="2771" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc ke kf kg kh bi translated">如果引用的是单个资源实例，更新或替换该实例的计划将触发替换。</li><li id="f80b" class="jz ka hi ih b ii ki im kj iq kk iu kl iy km jc ke kf kg kh bi translated">如果引用的是资源实例的单个属性，对属性值的任何更改都将触发替换。</li></ul><p id="4352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在下面的场景中，我们希望负载平衡器和实例模板资源相互耦合。如果我们删除实例模板，我们肯定不再需要后端服务。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es kn"><img src="../Images/8455a93435e0c2e265e895b7465159dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1QtYi4vzUqgZ5UlQeIX7w.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">替换触发元参数</figcaption></figure><p id="d639" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我之所以写这篇文章，是因为我觉得随着大型企业采用Terraform，这些元论点所要解决的边缘情况变得越来越普遍。希望这篇文章有助于减少您发现您正在处理的边缘案例已经被想到的时间。</p><p id="3199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要了解关于生命周期元参数及其实现的更多信息，请访问下面的Hashicorp官方页面。</p><p id="029e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ko" href="https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle" rel="noopener ugc nofollow" target="_blank">https://developer . hashi corp . com/terra form/language/meta-arguments/life cycle</a></p></div></div>    
</body>
</html>