<html>
<head>
<title>Ruby Meets BigQuery: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby遇上BigQuery:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/ruby-meets-bigquery-part-1-d8aa1f9e68f7?source=collection_archive---------5-----------------------#2016-07-13">https://medium.com/google-cloud/ruby-meets-bigquery-part-1-d8aa1f9e68f7?source=collection_archive---------5-----------------------#2016-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7bfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着我们在Google云平台上改进对Ruby的支持，我们讨论中出现的一个问题是哪些gem被频繁使用。我们希望确保普通的gems干净地安装在我们提供的Ruby容器上。这意味着在容器映像中包含许多具有本地扩展的gem的库。当我们讨论这个问题时，我内心的测试者想知道，最常见的500种宝石是什么？幸运的是，有多种数据来源可以解决这个问题。</p><h2 id="1f29" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Rubygems.org数据</h2><p id="420e" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><a class="ae kd" href="https://rubygems.org/" rel="noopener ugc nofollow" target="_blank">Rubygems.org</a>每周提供清理过的【PostgreSQL数据库的转储。转储包括gem和版本的下载计数。下载表名为gem_downloads，模式如下:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="f9fe" class="jd je hi kj b fi kn ko l kp kq">| Column Name | Type    |<br/>|-------------+---------|<br/>| id          | integer |<br/>| rubygem_id  | integer |<br/>| version_id  | integer |<br/>| count       | bigint  |</span></pre><p id="f494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rubygem_id和version_id是包含gem名称、版本字符串和其他相关信息的其他表的外键。</p><p id="dc4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是一个特别大的数据集，但是我想把导入的数据放在一个团队中的其他人可以容易地运行特别查询的地方。对我来说，最好的地方是<a class="ae kd" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>。BigQuery是一个托管数据仓库，是谷歌云平台的一部分。它在查询大型数据集时速度惊人，我可以使用标准SQL查询它。</p><h1 id="3c90" class="kr je hi bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">将数据放入BigQuery</h1><p id="0097" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我使用rubygems.org提供的示例加载脚本将数据加载到本地PostegreSQL数据库中。从那里将数据加载到BigQuery非常简单。对于一些表格，我使用了流方法。下面是加载gems表的代码。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="2453" class="jd je hi kj b fi kn ko l kp kq">require 'pg'<br/>require 'gcloud'</span><span id="4fdf" class="jd je hi kj b fi li ko l kp kq">pg_conn = PG.connect dbname: 'rubygems'</span><span id="5702" class="jd je hi kj b fi li ko l kp kq">gcloud   = Gcloud.new<br/>bigquery = gcloud.bigquery<br/>dataset  = bigquery.dataset "rubygems"</span><span id="0bd0" class="jd je hi kj b fi li ko l kp kq">bq_table ||= bq_database.create_table("gems") do |s|<br/> s.integer "id"<br/> s.string "name"<br/> s.timestamp "created_at"<br/> s.timestamp "updated_at"<br/>end</span><span id="d154" class="jd je hi kj b fi li ko l kp kq">rubygems_cols = %w[id name created_at updated_at]</span><span id="3767" class="jd je hi kj b fi li ko l kp kq">pg_conn.exec("SELECT * FROM rubygems") do |result|<br/>  result.each do |row|<br/>    data = Hash[rubygems_cols.zip(row.values)]<br/>    bq_table.insert(data)<br/>  end<br/>end</span></pre><p id="4a4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第21行有点混乱。PostgreSQL以值数组的形式返回每一行。BigQuery需要键值对。zip和Hash[]将值数组转换成一个散列，该散列将以正确的格式发送给BigQuery。</p><p id="da62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个例子的其余部分非常简单。首先我需要pg和gcloud宝石。然后我初始化一个到BigQuery和PostgreSQL的连接。之后，如果BigQuery表不存在，我就创建它。最后，我连接PostgreSQL，提取数据，并插入到BigQuery中。</p><p id="6a1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于rubygems.org数据中的其余表，我使用了批处理。我将表导出到CSV，然后使用UI将它们直接从CSV加载到BigQuery中。还可以使用gcloud gem将CSV、json或avro文件加载到BigQuery中。</p><h1 id="193a" class="kr je hi bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">分析rubygems.org数据</h1><p id="01b6" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">一旦数据被加载到BigQuery中，分析就像编写SQL查询一样简单。我的主要问题是“哪些宝石下载最多？”这个查询获得了下载最多的五个gem:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a84a" class="jd je hi kj b fi kn ko l kp kq">SELECT name, count <br/>FROM [rubygems.downloads] <br/>JOIN rubygems.gems ON rubygems.gems.id = rubygems.downloads.rubygem_id <br/>ORDER BY count DESC <br/>LIMIT 5</span></pre><p id="1fe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果如下:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="63ff" class="jd je hi kj b fi kn ko l kp kq">| name       | count       |<br/>|------------+-------------|<br/>| rake       | 107,076,261 |<br/>| rack       | 100,955,906 |<br/>| multi_json | 100,171,080 |<br/>| json       | 95,715,131  |<br/>| bundler    | 93,085,862  |</span></pre><p id="4537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我原本预计Rails是下载量最大的宝石，但它只排在第14位。</p><p id="9948" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">gem_downloads表有一个gem_id和一个version_id列。下载是针对特定gem的特定版本统计的，所以上面的查询没有给出准确的统计。该查询对每个gem的所有版本的计数求和。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="aca3" class="jd je hi kj b fi kn ko l kp kq">SELECT name, sum(count) as total <br/>FROM [rubygems.downloads] <br/>JOIN rubygems.gems ON rubygems.gems.id = rubygems.downloads.rubygem_id <br/>GROUP BY name <br/>ORDER BY total DESC <br/>LIMIT 5</span></pre><p id="94ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这产生了同样的前五名宝石，但具有更高的下载计数。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="4dd6" class="jd je hi kj b fi kn ko l kp kq">| name       | count       |<br/>|------------+-------------|<br/>| rake       | 214,152,212 |<br/>| rack       | 201,911,759 |<br/>| multi_json | 200,342,260 |<br/>| json       | 191,430,173 |<br/>| bundler    | 186,172,479 |</span></pre><p id="78f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我也很好奇哪个测试库最受欢迎。感觉测试库的讨论就像是ruby社区的编辑战争。我非常喜欢minitest，但许多人仍然使用rspec。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="5f11" class="jd je hi kj b fi kn ko l kp kq">SELECT name, sum(count) as total <br/>FROM [rubygems.downloads] <br/>JOIN rubygems.gems <br/>  ON rubygems.gems.id = rubygems.downloads.rubygem_id <br/>GROUP BY name <br/>HAVING name IN ('minitest', 'rspec')</span><span id="e13e" class="jd je hi kj b fi li ko l kp kq">| name     | total       |<br/>|----------+-------------|<br/>| minitest | 101,151,246 |<br/>| rspec    | 77,293,803  |</span></pre><p id="ec9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud Ruby团队感兴趣的最后一件事是哪个版本的Rails最受欢迎。我们都知道有人还在使用旧版本的Rails 3。为了回答这个问题，我需要获得每个版本Rails的下载量。</p><p id="929a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们所说的版本号，像3.1.0，其实就是字符串。为了获得每个版本的计数，我必须提取版本字符串的主要版本部分，忽略次要版本和补丁部分。我使用正则表达式获取版本字符串中第一个点之前的所有内容。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="5870" class="jd je hi kj b fi kn ko l kp kq">SELECT REGEXP_EXTRACT(number,r'(\d)\.') AS major,<br/>  sum(rubygems.downloads.count) AS total <br/>FROM [rubygems.versions] <br/>JOIN rubygems.gems <br/>  ON rubygems.gems.id = rubygems.versions.rubygem_id <br/>JOIN rubygems.downloads <br/>  ON rubygems.versions.rubygem_id = rubygems.downloads.rubygem_id WHERE rubygems.gems.name = 'rails' <br/>GROUP BY name, major <br/>ORDER BY major</span><span id="2923" class="jd je hi kj b fi li ko l kp kq">| version | downloads              |<br/>|---------+------------------------|<br/>|       0 | 2,890,350,351          |<br/>|       1 | 2,064,535,965          |<br/>|       2 | 3,991,436,199          |<br/>|       3 | 16,378,651,989         |<br/>|       4 | 12,662,487,252         |<br/>|       5 | 963,450,117            |</span></pre><p id="0a93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这表明Rails 3是下载最多的，Rails 4也有相当多的下载。</p><h1 id="f653" class="kr je hi bd jf ks kt ku jj kv kw kx jn ky kz la jq lb lc ld jt le lf lg jw lh bi translated">衡量下载量的问题</h1><p id="0819" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">这个数据给了我们一个合理的标准，来衡量哪种宝石最受欢迎。然而，下载量并不一定是衡量使用情况的最佳方式。一个公司有很多服务器，他们经常更新，如果他们每次安装时都从网上下载他们的gem，可能会严重扭曲数据。我想找到另一种方法来衡量宝石的使用。</p><p id="4c30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我在写这篇博文的时候，以及随之而来的<a class="ae kd" href="https://www.youtube.com/watch?v=0mzNNg62_kM" rel="noopener ugc nofollow" target="_blank">谈话</a>。我发现Google从GitHub发布了近300万个开源存储库的信息作为BigQuery公共数据集。本系列的下一篇文章将使用这些数据来分析gem的受欢迎程度，并比较这两种来源的结果有何不同。</p><p id="b1b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">07/13/16</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="38a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lq">原载于2016年7月13日</em><a class="ae kd" href="http://www.thagomizer.com/blog/2016/07/13/ruby-meets-bigquery-part-one.html" rel="noopener ugc nofollow" target="_blank"><em class="lq">【www.thagomizer.com</em></a><em class="lq">。</em></p></div></div>    
</body>
</html>