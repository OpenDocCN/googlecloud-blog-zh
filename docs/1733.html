<html>
<head>
<title>BigTips: Removing Duplicates while Maintaining Row History</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大提示:在维护行历史的同时删除重复项</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigtips-removing-duplicates-while-maintaining-row-history-520f24706d63?source=collection_archive---------0-----------------------#2020-12-29">https://medium.com/google-cloud/bigtips-removing-duplicates-while-maintaining-row-history-520f24706d63?source=collection_archive---------0-----------------------#2020-12-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8b1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用和实现BigQuery时，有许多小问题我找不到文档或解决方案的工作示例。任何数据库偶尔都会发生这种情况。虽然这些可能不是要解决的突破性问题，但希望它能让某人的一天变得轻松一点。有时候，是一些小事。</p><p id="ed1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BigTips:删除具有混合静态和可变列的重复行，同时保留行版本历史！</p><h1 id="49bc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我知道我需要什么，只要告诉我脚本就行了！</h1><ul class=""><li id="ead9" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated"><a class="ae km" href="https://github.com/slagathorr/bigquery-tools" rel="noopener ugc nofollow" target="_blank">主GitHub库</a>。</li><li id="da1e" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/example_script_superDeduper.sql" rel="noopener ugc nofollow" target="_blank">范例剧本</a>。</li><li id="8a40" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/sproc_superDeduper.sql" rel="noopener ugc nofollow" target="_blank">存储过程</a>。</li></ul><h1 id="e146" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">问题陈述</h1><p id="c9da" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">分析数据中的一个老问题是如何处理迟到的数据。在接收数据时，这是一个相当常见的问题，尤其是在处理频繁事务的系统中。这也是系统经常对以前的数据进行修正的一个问题。</p><p id="539b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的挑战语句试图在BigQuery内部处理这个问题。像Informatica PowerCenter、IBM DataStage这样的ETL工具，以及它们通常的同类工具都有在它们的工具中处理这种情况的工具。虽然在运行ETL管道时这通常没问题，但是如果您想利用BigQuery的引擎来做这件事呢？</p><p id="9234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初会想到一些想法。第一个，也是最明显的一个，就是发出一个<code class="du kv kw kx ky b"><a class="ae km" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#duplicate_row_handling" rel="noopener ugc nofollow" target="_blank">SELECT DISTINCT *</a></code>语句来查找和处理所有重复的行。如果你要找的就是这个，那就可以了。它不处理对以前条目的更新，以及当一些列是维度，而其他列是度量时的更新。它会将一个更新视为一个新的不同的行，所以您不能轻易地将它们联系在一起。</p><p id="cb5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是使用<code class="du kv kw kx ky b"><a class="ae km" href="https://cloud.google.com/blog/products/gcp/performing-large-scale-mutations-in-bigquery" rel="noopener ugc nofollow" target="_blank">MERGE</a></code>语句。这适用于问题陈述，但不完全清楚我们如何处理数量可变的代理键列，以及如何排除不同的列。特别是如果我们想使这个通用的，并适用于一个未知的表。</p><p id="d817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当在文本描述中描述这些异议时，可能会令人困惑，但是让我们举一个例子来具体说明这一点。</p><p id="1dab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个名为<code class="du kv kw kx ky b">main_table</code>的基础表，包含以下基础数据:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="1296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是这些列的含义:</p><ul class=""><li id="7c38" class="kb kc hi ih b ii ij im in iq lg iu lh iy li jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">is_latest</code>是一个<code class="du kv kw kx ky b">BOOL</code>列，它告诉我们该行是否代表该数据的“当前”版本。</li><li id="295e" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">ingest_ts</code>是一个列，它告诉我们该行何时被加载到表中。</li><li id="9e4e" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">reported_dt</code>是一个告诉我们那一行中的数据代表什么日期的列。</li><li id="2dfa" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">COLA</code>只是一些维度列，在本例中是一个状态。</li><li id="ccfb" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">COLB</code>是另一个维度列，在本例中是一个年龄组。</li><li id="4335" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">MEASUREMENT</code>只是对某物的某种度量。</li><li id="4bf4" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">COLC</code>是另一个测量栏。这一列对数据没有任何特殊的意义，它只是另一个值可以改变的列。</li></ul><p id="d97d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有<code class="du kv kw kx ky b">ingest_ts</code>和<code class="du kv kw kx ky b">reported_dt</code>，所以数据是<a class="ae km" href="https://en.wikipedia.org/wiki/Bitemporal_Modeling" rel="noopener ugc nofollow" target="_blank">双时态的</a>，我们可以测量“当源观察它时”和“当我们接收它时”的数据这里的想法是保存变更的运行历史记录(通过使用<code class="du kv kw kx ky b">ingest_ts</code>和<code class="du kv kw kx ky b">reported_dt</code>的组合)以及维护<code class="du kv kw kx ky b">is_latest</code>标志，这样您就可以轻松地发出查询<code class="du kv kw kx ky b">SELECT * FROM mytable WHERE is_latest = TRUE</code>来获取所有最新的数据。</p><p id="7f23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个结构中，我们有三组柱子。</p><ul class=""><li id="1337" class="kb kc hi ih b ii ij im in iq lg iu lh iy li jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">is_latest</code>和<code class="du kv kw kx ky b">ingest_ts</code>是元数据列，帮助我们计算数据的新近性，但其本身并不是实际的数据。<code class="du kv kw kx ky b">is_latest</code>是一个需要维护的简单过滤标志。</li><li id="de0c" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">reported_dt</code>、<code class="du kv kw kx ky b">COLA</code>和<code class="du kv kw kx ky b">COLB</code>是三列，它们组合在一起可以告诉我们什么代表数据的唯一度量。这些可以作为我们的<a class="ae km" href="https://en.wikipedia.org/wiki/Surrogate_key" rel="noopener ugc nofollow" target="_blank">代理键</a>。这些列的独特组合意味着它在某种意义上是一个“新行”。在本文中，我们将这些列称为“唯一列”</li><li id="5f5a" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated"><code class="du kv kw kx ky b">MEASUREMENT</code>、<code class="du kv kw kx ky b">COLC</code>为我们的测量柱。对于代理键的每个唯一组合，这两个度量值都可能改变。下一个数据集将举例说明这是如何实现的。在本文中，我们将称之为“测量柱”。</li></ul><p id="aef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了基本数据表，让我们添加第二个表。这是我们的<code class="du kv kw kx ky b">ingest_table</code>它有一个相似的结构，但是这代表了“一个更晚的日期”到来的新数据</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="afca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是同一表的后续数据加载，因此<code class="du kv kw kx ky b">is_latest</code>列不存在(这是我们需要计算的)，下面是一些数据复杂性的示例。</p><ul class=""><li id="0bdd" class="kb kc hi ih b ii ij im in iq lg iu lh iy li jc ki kj kk kl bi translated">加利福尼亚有一个更新(对于2020-1-15，加利福尼亚的18-22计数从150变为200)，一个新行(对于2020-1-15，加利福尼亚的22-30是一个新记录)，以及一个历史副本(对于2020-1-15，加利福尼亚的18-22测量为100，并且“hello”是历史副本)。</li><li id="11e7" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">特拉华州的行(2020–1–15，特拉华州的22–30计数为100/磅)是活动数据点的副本。</li><li id="06a6" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">弗罗里达州的测量结果(2020-1-15，特拉华州的22-30计数为200/平)是新的一排。</li></ul><p id="5f44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么只匹配一列的策略并不总是有效，也不仅仅是在所有列中选择不同的。这有点棘手。而且，这在现实世界的系统中确实经常发生。如果您是零售商，可能会出现这样的情况:“我们的生产线出现了问题，上周二的批次实际上比我们最初记录的少了100台。”或者，如果您要在全国范围内汇总医疗数据，则可能需要在以下情况下更新数据:“三天前的测量结果实际上有所不同，因为加利福尼亚的一些医院因文书工作而延误，而我们刚刚收到了这些数据。”在您的日常生活中，想想您的信用卡账单吧，这一点更加明显。如果您经常观看，您会注意到交易结算时通常会有几个工作日的延迟期(至少在美国是这样，但我怀疑许多国家的操作都是类似的)，并且随着交易的结束，您在这些天的“截止”余额和“当前余额”可能会波动。这些都是这个问题开始发挥作用的例子。</p><p id="5463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到示例表。其中包含了最常见的延迟到达数据场景的示例:真正新的唯一数据、最新数据的更新、最新数据的副本以及先前历史数据的副本。这几乎是一个<code class="du kv kw kx ky b"><a class="ae km" href="https://wiki.postgresql.org/wiki/UPSERT#.22UPSERT.22_definition" rel="noopener ugc nofollow" target="_blank">UPSERT</a></code>。让我们去建造一些东西来处理它！</p><p id="834a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将一步一步地介绍如何构建它，并将它包装在一个存储过程中。如果您只想跳到最终结果，请到这里查看嵌入了数据的示例，到这里查看您可以部署的实际脚本。</p><p id="d701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道我们的目标最终状态是什么，如果我们手动将接收表中的数据更改应用到主表，我们可以看到这就是我们想要的:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="066e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们设法到达那里。</p><p id="1826" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对此我们将采取两种方法。<a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/example_script_superDeduper.sql" rel="noopener ugc nofollow" target="_blank">一个完全自包含的BigQuery脚本，包括样本数据</a>，还有一个版本，我们把所有这些都包装在一个<a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/sproc_superDeduper.sql" rel="noopener ugc nofollow" target="_blank">存储过程中，这样你就可以在任意表上调用它</a>。</p><h1 id="1be5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">伪代码</h1><p id="dfd9" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">让我们先把我们的逻辑搞清楚，这样我们就知道我们在朝着什么方向努力了。基本的psudeocode如下所示:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="e078" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这个逻辑如何处理前面概述的四种数据场景:</p><ul class=""><li id="c0bd" class="kb kc hi ih b ii ij im in iq lg iu lh iy li jc ki kj kk kl bi translated">对最新数据的更新:块1中的<code class="du kv kw kx ky b">WHERE</code>子句的前半部分解决了这个问题。它在<code class="du kv kw kx ky b">main_table</code>中寻找<code class="du kv kw kx ky b">is_latest</code>为真的行，唯一的列匹配表示它是相同的度量，但是具有新的度量。在块2中，我们将<code class="du kv kw kx ky b">main_table</code>中的相应数据标记为历史数据，然后在块3中加载新数据。</li><li id="5cd1" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">先前历史数据的副本:先前逻辑的问题是，如果传入的行有先前的历史度量，它仍然可以通过逻辑，因为它没有将它与历史值进行比较。Block 1中的第二个子句是我们捕获这个异常的地方，在创建更新的临时表时忽略它。</li><li id="8830" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">最新数据的副本/真正新的唯一数据:块4处理这两者。这里，我们只合并唯一列和度量列都是新列的行。</li></ul><h1 id="a2cf" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">与JSON比较</h1><p id="4055" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">当进行这些比较以查看哪些列发生了变化，哪些没有发生变化时，我们通常必须在where子句中手工键入所有这些内容。这不仅对于非常宽的表来说是一种痛苦，而且对于一般的表来说也不灵活。处理通用表的想法我们将在后面的部分讨论，但是让我们引入JSON字符串来解决另一个问题。</p><p id="1c64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在一个简单的语句中比较大量的列，而不是使用一堆比较操作符，其中一个技巧是将行序列化为JSON字符串，然后进行一次比较。您可以使用<code class="du kv kw kx ky b">TO_JSON_STRING()</code>函数轻松序列化JSON字符串。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lj"><img src="../Images/d0cac54dbffd43d4446c4ffc8706ead3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*wMPuZoimH5OGdqLjVYFppA.png"/></div></figure><p id="6b7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了你一个字符串，你现在可以操作它。如果将它与正则表达式结合起来，现在就有了一种简单的方法来比较列值。假设我们只想连接两个表中的<code class="du kv kw kx ky b">cola</code>和<code class="du kv kw kx ky b">colb</code>，其中<code class="du kv kw kx ky b">colc</code>是相同的。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/c120fdd6c83f45900d28700bec40f144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBVUq2pUd66nTSDj1MJXpw.png"/></div></div></figure><p id="efb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里所做的是创建一个正则表达式，它从字符串中删除了<code class="du kv kw kx ky b">cola</code>和<code class="du kv kw kx ky b">colb</code>的数据，所以现在JSON字符串只剩下<code class="du kv kw kx ky b">colc</code>了，现在比较它们非常简单。虽然这是一个简单的例子，但是您可以开始看到动态创建比较字符串的灵活性和简易性，尤其是当您有几十列甚至几百列宽的表时。</p><h1 id="07e9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">把它们放在一个剧本里</h1><p id="e3c5" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">好吧，那这一切是怎么一起工作的？让我们一点一点地把它建造出来。如果你想知道它是如何构建的，请继续阅读，但是如果你想跟随整个脚本，它位于这里的<a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/example_script_superDeduper.sql" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="c7d2" class="lr je hi bd jf ls lt lu jj lv lw lx jn iq ly lz jr iu ma mb jv iy mc md jz me bi translated">变量和数据</h2><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mf"><img src="../Images/8f196244e895bc7b940e411dab7421e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXP24S_NOHoFB_aYKU1IRA.png"/></div></div></figure><p id="4c7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面两条语句非常简单，我们用我们的<code class="du kv kw kx ky b">main_table</code>和<code class="du kv kw kx ky b">ingest_table</code>数据创建了两个临时表。这是与上面的例子相同的数据。</p><p id="a596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前三行中，我们创建变量来存储列名。一个是指出哪一列是我们的摄取时间列。一组用于存储我们唯一的列名，另一组用于存储测量列名。我们在第4行和第5行使用这些来预构建正则表达式字符串。在我们引入JSON字符串的简单例子中，我们在正则表达式中硬编码了<code class="du kv kw kx ky b">cola</code>和<code class="du kv kw kx ky b">colb</code>。这里我们使用列名数组来动态生成。第4行是我们删除测量列和摄取时间戳列的地方，因此我们将只有唯一的列值。第5行正好相反，所以我们只有测量列。这将有助于我们稍后的比较更加容易。</p><h2 id="860c" class="lr je hi bd jf ls lt lu jj lv lw lx jn iq ly lz jr iu ma mb jv iy mc md jz me bi translated">第一部分，识别真实更新</h2><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mg"><img src="../Images/69c73b676e683b3b4d97531818d33e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87VDYqly833rFLMUHzTRfg.png"/></div></div></figure><p id="c600" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们正在构建psudeocode的模块1。通过使用正则表达式字符串和比较被操纵的JSON字符串的技术，我们可以执行我们想要执行的逻辑。在我们的测试数据中，我们发现只有加利福尼亚州的18–22测量值是真正的更新，而加利福尼亚州的22–30测量值是历史重复值，我们可以看到，它正确地用这一行填充了staging表。</p><h2 id="f2aa" class="lr je hi bd jf ls lt lu jj lv lw lx jn iq ly lz jr iu ma mb jv iy mc md jz me bi translated">块二，使传出的更新行无效</h2><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/f450e7b0b4082d3d0262df831f001b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGhw7tcoV-sd8iYEL1Mf8g.png"/></div></div></figure><p id="70d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在psudeocode的第2块中，我们只取了<code class="du kv kw kx ky b">main_table</code>中的值，这些值是最新的行，然后使那些与传入的更新相匹配的行无效。由于加州的18–22将从150变为200，我们应该预料到<code class="du kv kw kx ky b">main_table</code>中的那一行将被无效，我们在上面的结果中看到它成功地工作。</p><h2 id="bb44" class="lr je hi bd jf ls lt lu jj lv lw lx jn iq ly lz jr iu ma mb jv iy mc md jz me bi translated">块三，加载新的更新行</h2><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/cc300c20eee67c480fbd8af4497aadbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OawYO7PkwdWlwbAGROnBCQ.png"/></div></div></figure><p id="9620" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是最简单的方法，简单地插入来自<code class="du kv kw kx ky b">update_staging</code>表的数据。我们在这里可以看到，加州新的18–22排200个is已经成功加载。</p><h2 id="c86b" class="lr je hi bd jf ls lt lu jj lv lw lx jn iq ly lz jr iu ma mb jv iy mc md jz me bi translated">块四，加载真正的新行</h2><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mi"><img src="../Images/e89310e7f93d78b6fdbc0f703871d3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuKKVPovP7KxnuFhrJjRmg.png"/></div></div></figure><p id="2c44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们希望加载真正的新行。这里我们寻找匹配，然后在不匹配的时候插入。因为不能在match的<code class="du kv kw kx ky b">MERGE</code>语句中插入行，所以我们做了相反的事情。我们希望看到加州新的22-30行和佛罗里达州的1-88行被插入，我们看到它成功地做到了这一点。提醒一下，这是我们的预期输出。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="f953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万岁，成功了！</p><p id="58d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，<a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/example_script_superDeduper.sql" rel="noopener ugc nofollow" target="_blank">如果你想看的话，这里有整个脚本</a>的链接。</p><h1 id="dc24" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">将这些放在一个存储过程中</h1><p id="6eb9" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">所以这很酷。最终，我们希望将它包装成一个通用的存储过程，可以应用于任何表。</p><p id="fdb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到完成的剧本<a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/super-deduper/super-deduper/sproc_superDeduper.sql" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7f59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您查看一下脚本细节，就会发现它与上一节中的脚本只有几个主要的区别。</p><p id="2dbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，因为这是一个通用的过程，我们没有定义任何列或测试数据。这些都将由用户在过程调用中提供。</p><p id="dce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个主要区别是，与直接调用不同，您会注意到SQL被设置为<code class="du kv kw kx ky b">STRING</code>对象，所有内容都在<code class="du kv kw kx ky b">EXECUTE IMMEDIATE</code>调用中被调用。这是为了让我们可以用过程调用提供的列动态地运行它们。</p><p id="6929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，它的核心逻辑很大程度上遵循了上一节脚本中的设计。所以让我们试一试。</p><p id="0d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要<a class="ae km" href="https://github.com/slagathorr/bigquery-tools" rel="noopener ugc nofollow" target="_blank">克隆整个存储库</a>，这将是最简单的方法。你也会得到BigTips中包含的所有其他内容。如果你只是想要这些文件，你可以在这里看到它们<a class="ae km" href="https://github.com/slagathorr/bigquery-tools/tree/main/super-deduper" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3936" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，确保在命令行中运行一个<code class="du kv kw kx ky b">gcloud auth</code>，这样您就有了正确的用户和项目集。</p><p id="cc1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行<code class="du kv kw kx ky b"><a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/runmefirst.sh" rel="noopener ugc nofollow" target="_blank">runmefirst.sh</a></code>脚本。这将创建一个名为<code class="du kv kw kx ky b">dedup_stuff</code>的数据集，然后运行<code class="du kv kw kx ky b"><a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/create_ingest_table.sql" rel="noopener ugc nofollow" target="_blank">create_ingest_table.sql</a></code>和<code class="du kv kw kx ky b"><a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/create_main_table.sql" rel="noopener ugc nofollow" target="_blank">create_main_table.sql</a></code>脚本来生成与我们之前相同的测试数据。最后，它将运行<code class="du kv kw kx ky b"><a class="ae km" href="https://github.com/slagathorr/bigquery-tools/blob/main/super-deduper/sproc_superDeduper.sql" rel="noopener ugc nofollow" target="_blank">sproc_superDeduper.sql</a></code>文件，从而创建过程。这应该会给你一个新的快乐的小数据集。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mj"><img src="../Images/ae1827d45d2b09cc8f4ebca404520db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*D0FAD79jrXIc4QcI0m-uAw.png"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">快乐的桌子是最好的桌子。</figcaption></figure><p id="e917" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想在运行脚本之前感受一下所有对象的样子，请随意查看表格和脚本。准备好之后，继续使用以下参数在BigQuery中运行脚本。</p><pre class="kz la lb lc fd mo ky mp mq aw mr bi"><span id="9d13" class="lr je hi ky b fi ms mt l mu mv">CALL dedup_stuff.superDeduper(<br/>  '`dedup_stuff.ingest_table`',<br/>  '`dedup_stuff.main_table`',<br/>  'ingest_ts',<br/>  'is_latest',<br/>  ['reported_dt', 'cola', 'colb'],<br/>  ['measurement', 'colc']<br/>);</span></pre><p id="e29c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行之后，预览<code class="du kv kw kx ky b">main_table</code>，您将看到数据与我们预期的结果相匹配。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mw"><img src="../Images/4e1a4070c1877b434c59505ce4d24c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRTTLJC_7caLvtOTWOpMhg.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">最幸福的桌子。</figcaption></figure><p id="47fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你知道了！这是一个较长的技巧，但是我想确保它背后的逻辑是清楚的，这样您就可以确切地知道它是如何工作的，因为阅读其他人的脚本/代码并不总是最容易的。希望这有助于让某人的大查询日稍微轻松一点！另外，请务必在<a class="ae km" href="https://medium.com/google-cloud" rel="noopener">谷歌云媒体频道</a>查看更多BigQuery内容！查询愉快！</p></div></div>    
</body>
</html>