<html>
<head>
<title>Cloud Functions to Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云功能到云运行</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-functions-to-cloud-run-e297aac28eb8?source=collection_archive---------1-----------------------#2020-12-18">https://medium.com/google-cloud/cloud-functions-to-cloud-run-e297aac28eb8?source=collection_archive---------1-----------------------#2020-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7027a51ee6a09d73a82fbb7c2e660fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Z0zAFD3j_orsLJRwYUtNg.png"/></div></div></figure><p id="df52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们使用名为云函数的GCP产品时，我们提供的是包含我们希望执行的代码逻辑的函数体。通过这样做，我们将自己与如何调用功能的<em class="jo">的任何关注或实现分离开来。当传入的请求到达时，是云函数导致我们的代码执行。我们不必发展任何形式的服务脚手架。云功能还负责根据负载启动我们需要的尽可能多的实例，并在没有呼叫时缩减到零。</em></p><p id="0c6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云功能的一个替代方案是被称为云运行的服务。云运行与云功能有相似之处，它可以扩展到零，并负责实例的启动/关闭。然而，发展模式发生了很大变化。有了Cloud Run，开发人员就有责任构建一个Docker映像，它将作为一个由Cloud Run启动的容器来运行。容器将负责成为一个完整的REST服务器，接收传入的请求，然后将控制权传递给业务逻辑代码。</p><p id="5899" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们试图在图表中对比这些故事，我们会得到如下结果:</p><p id="7ff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一张图显示了提供给云函数的函数体(我们希望执行的代码)。我们只关注函数体，并把它交给云函数来执行。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/a166ffe2b54229bdf273bb388f2d95de.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/0*mzvSVPAO8f18knsS"/></div></figure><p id="1a8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于Cloud Run，我们希望执行的函数体是REST服务器框架的一部分，我们也负责构建该框架。然后，我们必须将所有这些打包到Docker映像中，最后我们将Docker映像交给Cloud Run执行。正如我们所看到的，还有额外的步骤。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/f7beb42c84f81af41f66a8560af01b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/0*Ha08lXDjdeCKHRd1"/></div></figure><p id="b73d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们以前构建了一个基于云功能的解决方案，现在希望在云上运行该解决方案，该怎么办？在这方面我们有什么故事？</p><p id="74e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们将看看GCP的一个功能，称为建立包。在最高级别，构建包可以被认为是一种技术，其目的是将源代码作为输入，并生成Docker容器作为输出。传统上，如果想要创建一个Docker容器，必须手动创建一个<code class="du ju jv jw jx b">Dockerfile</code>，然后将它和源代码传递给Docker，结果就是一个容器。虽然不麻烦，但它确实增加了额外的步骤，因此带来了麻烦和出错的机会。Build Packs故事自动检测容器中托管的应用程序的编程语言，并消除了编写docker文件和选择配方以在容器中构建代码的负担。</p><p id="0bb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个使用构建包的例子。如果我们有一个用Node编写的应用程序，我们可能有一个源文件(<code class="du ju jv jw jx b">index.js</code>)和一个包文件(<code class="du ju jv jw jx b">package.json</code>)。如果我们希望构建一个包含我们的应用程序的容器，我们可以运行:</p><pre class="jq jr js jt fd jy jx jz ka aw kb bi"><span id="7156" class="kc kd hi jx b fi ke kf l kg kh">gcloud builds submit --pack image=us-central1-docker.pkg.dev/[PROJECT]/[REPO]/[IMAGE],env=GOOGLE_FUNCTION_TARGET=functionName</span></pre><p id="776b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个命令有很多内容，所以让我们把它拆开。该命令是利用GCP云构建服务的请求。云构建能够在GCP而不是在您的本地环境中执行Docker容器构建。运行<code class="du ju jv jw jx b">gcloud builds submit</code>获取当前目录下的源文件，上传到GCP，然后执行容器构造。通常情况下，Cloud Build还会被提供一个Dockerfile，其中包含构建容器的方法。通过添加<code class="du ju jv jw jx b">--pack</code>标志，我们利用了云构建与构建包故事的集成。通过提供这个标志，我们告诉云构建到<em class="jo">而不是</em>期望Dockerfile作为输入，而是使用构建包技术来确定如何将源转换为容器。我们还指定结果图像将被放入的存储库。在这个例子中，我们使用GCP的工件注册表。由<code class="du ju jv jw jx b">GOOGLE_FUNCTION_TARGET</code>参数指定的最后一个标志是一些专门的谷歌魔术。如果提供了该标志，它会通知云构建，源代码是<em class="jo"> only </em> a function body，并且将调用该函数的REST框架还没有提供<em class="jo"/>。然后，Cloud Build会将云函数框架注入到结果容器中，这样当请求到达时，它将调用代码提供的函数。</p><p id="0580" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个冗长的描述。更简单地说，如果我们给这个命令输入两个文件:</p><ul class=""><li id="24f8" class="ki kj hi is b it iu ix iy jb kk jf kl jj km jn kn ko kp kq bi translated">索引. js</li><li id="1a49" class="ki kj hi is b it kr ix ks jb kt jf ku jj kv jn kn ko kp kq bi translated">package.json</li></ul><p id="d346" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<code class="du ju jv jw jx b">index.js</code>只包含我们可能提供给云函数环境的函数体，那么结果将是存储在GCP工件注册中心的Docker映像。从这个映像中，我们可以创建一个云运行实例，当它被调用时，将以与云功能部署完全相同的方式调用在<code class="du ju jv jw jx b">index.js</code>中找到的功能代码。</p><p id="fefb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了进一步说明这个故事，这里有一个视频展示了云功能到云运行的完整端到端迁移。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="2ed2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另请参见:</p><ul class=""><li id="7c3d" class="ki kj hi is b it iu ix iy jb kk jf kl jj km jn kn ko kp kq bi translated"><a class="ae ky" href="https://cloud.google.com/sdk/gcloud/reference/builds/submit" rel="noopener ugc nofollow" target="_blank"> gcloud构建提交</a></li><li id="23c6" class="ki kj hi is b it kr ix ks jb kt jf ku jj kv jn kn ko kp kq bi translated"><a class="ae ky" href="https://cloud.google.com/blog/products/containers-kubernetes/google-cloud-now-supports-buildpacks" rel="noopener ugc nofollow" target="_blank">宣布Google Cloud build pack——容器映像变得简单</a></li><li id="ddc8" class="ki kj hi is b it kr ix ks jb kt jf ku jj kv jn kn ko kp kq bi translated"><a class="ae ky" href="https://buildpacks.io/" rel="noopener ugc nofollow" target="_blank"> buildpacks.io </a></li><li id="8d50" class="ki kj hi is b it kr ix ks jb kt jf ku jj kv jn kn ko kp kq bi translated"><a class="ae ky" href="https://github.com/GoogleCloudPlatform/buildpacks" rel="noopener ugc nofollow" target="_blank">Github:Google cloud platform/build packs</a></li></ul></div></div>    
</body>
</html>