<html>
<head>
<title>Anthos-at-Home: Spinning Up a Bare-Metal Anthos Cluster on Dumpster Servers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Anthos-at-Home:在垃圾服务器上运行裸机Anthos集群</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/anthos-at-home-spinning-up-a-bare-metal-anthos-cluster-on-dumpster-servers-5bcef301cfa5?source=collection_archive---------0-----------------------#2022-06-24">https://medium.com/google-cloud/anthos-at-home-spinning-up-a-bare-metal-anthos-cluster-on-dumpster-servers-5bcef301cfa5?source=collection_archive---------0-----------------------#2022-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6327" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">摘要:</h1><p id="593a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">谷歌云上的Anthos世界是广阔的。配置管理器、服务网格、裸机、VMWare上的Anthos不胜枚举。文档是详细和完善的，但是对于大多数业余爱好者来说是不容易理解的。在这个项目中，我打算演示Anthos在裸机上的功能，并提供一个详细的指南和解释，说明如何自己做。</p><h1 id="3dad" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">观众:</h1><p id="3dc4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">本演示面向对linux操作系统、网络和Kubernetes有一定经验的人。该演示突出了Anthos在裸机上的功能，应该可供对扩展GKE功能感兴趣的技术专家、爱好者、IT专业人员和商业领袖使用。</p><h1 id="66a2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">主题:</h1><p id="ee6b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这一论证深深植根于库伯内特斯，因此假定对库伯内特斯资源有基本的了解。在Kubernetes中，我们将讨论网络、负载平衡、集群配置以及集群认证和安全性。</p><p id="8e36" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这一过程中最困难的步骤围绕着消费者网络中的网络配置。我们将讨论IP范围、CIDR块和DHCP。</p><h1 id="e916" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">服务器设置:</h1><p id="fd92" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们开始吧！首先，让我们看看我将用作本地节点的服务器。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/3e558a43d7683792170a1e21c2884932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0NIWkdnxhXTjXnW-"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">我的公寓服务器机架</figcaption></figure><p id="69da" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它们是位于我机架正中间的两台Dell r610s(每个都有6个2.5英寸驱动器托架)。是的，我有很多服务器；顶部的是我的第一台存储服务器，底部的是一台r720，它在Proxmox上运行许多虚拟机。我从我的一个朋友那里得到这两个r610s。他们的雇主正在进行云转型，因此这些服务器正在被转储。当然，我不能让这种事情发生！</p><p id="dc6a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我应该澄清一下——您不需要大型、嘈杂的企业级服务器来处理这样的事情。我见过有人在小型英特尔nuc和旧的企业工作站(如戴尔Optiplexes)上运行Anthos集群。我使用这些是因为我想最大化我的可用CPU内核和内存(我不介意有一点噪音)。以下是裸机节点的最低硬件要求:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kx"><img src="../Images/b9bc6dc94d3090b2d330ec25c542ce3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvB9oNM2MXchm0dBIfJ5oQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">关于裸机硬件要求的Anthos</figcaption></figure><p id="8094" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这些都来自官方文件，你可以在这里找到<a class="ae ky" href="https://cloud.google.com/anthos/clusters/docs/bare-metal/latest/installing/hardware" rel="noopener ugc nofollow" target="_blank"/>。如果您的计算机不满足这些要求，您也许可以使用edge配置文件来配置您的群集，这基本上将默认要求减半。</p><h1 id="3553" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">物理设置:</h1><p id="fb54" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我将更多地谈谈我的情况以及我是如何选择设置的。每个r610包含2个英特尔至强X5675s，它们是运行频率为3.1 GHz的六核12线程CPU。每台服务器还包含128 GBs的DDR 3–1333注册ECC内存。总而言之，我最终应该有48个vCPUs和256 GBs的内存来工作。</p><p id="befa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就存储而言，每台服务器都有两个300 GB的SAS驱动器。像这样的企业服务器很奇怪，因为存储配置是由RAID控制器控制的。在每台服务器的BIOS设置中，我将RAID控制器配置为用RAID 1中的两个驱动器创建一个虚拟磁盘，这意味着两个驱动器都是“镜像的”。如果一个驱动器出现故障，不会丢失任何数据。这个虚拟磁盘将是我的启动驱动器。</p><p id="d8d0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这也是大多数爱好者不必要的一步。对于消费类硬件，只需将操作系统安装到一个驱动器上，然后根据需要安排备份到第二个驱动器上，这要容易得多。然而，出于本演示的目的，这是我为了遵循设置服务器的最佳实践而完成的额外步骤。</p><p id="9301" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我强烈建议为每台机器设置静态内部IP地址。您可以从源或目的地实现这一点，即从服务器本身或从您的路由器设备，但我建议从您的路由器进行更改。这是因为在您的子网中有一些事情要记住，因为重叠的IP地址或范围基本上意味着这个项目的死亡。</p><p id="1f4b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我的例子中，我使用的是pfSense路由器。pfSense是一款<a class="ae ky" href="https://www.pfsense.org/download/" rel="noopener ugc nofollow" target="_blank">开源防火墙应用</a>，可以在轻量级硬件上运行。不久前，我构建了自己的pfSense服务器，并配置了四个物理上分离的子网。这是我在物理上分离我的设备并防止一些设备相互通话的一种方法。我不是特别喜欢物联网设备可以在我的网络上四处嗅的想法)。这绝对是矫枉过正，但这只是我的设置。我们需要做的事情也很容易在消费设备上完成，只要您可以访问管理网页(通常可以通过您的默认网关IP地址访问，例如192.168.0.1)。</p><p id="3efa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">无论如何，我对路由器的DHCP设置感兴趣。DHCP是动态主机控制协议，它自动向网络上的设备授予随机或顺序的IP地址租约。如果该设备断开足够长时间，其租约将到期，从而向新设备开放其旧IP地址。这对消费者网络非常有利，因为它几乎消除了IP地址重叠的可能性(两个设备具有相同的IP地址)。出于我们的目的，为我们的机器设置静态IP地址要稳定得多，所以这里是我的基本配置:</p><p id="67ca" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我使用的子网是192.168.1.0/24(24表示IP地址范围从192 . 168 . 1 . 0到192.168.1.255)。如果你不熟悉CIDR街区，<a class="ae ky" href="https://www.digitalocean.com/community/tutorials/understanding-ip-addresses-subnets-and-cidr-notation-for-networking" rel="noopener ugc nofollow" target="_blank">这里有一个快速复习</a>。</p><p id="91ba" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在此范围内，我将DHCP可分配地址的范围限制为192.168.1.100到192.168.1.255。这意味着当新设备加入网络时，DHCP服务只会将此范围内的IP地址出租给新设备。然后，我们可以将IP地址范围从192.168.1.2到192.168.1.99用于静态映射。192.168.1.1怎么了？在我的例子中，这是默认网关，或者换句话说，是路由器的网络位置。它是流量从路由器进出子网的地方。</p><p id="e640" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，有了这个禁止DHCP服务使用的新IP地址范围，我们现在可以自由地将它们分配给我们的节点。在我的场景中，节点1被分配了192.168.1.51，节点2被分配了192.168.1.52。当我们设置机器时，我将讨论如何配置它。</p><p id="c136" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这样做是该过程的一个重要步骤，理想情况下，您会希望划分出大约20个IP地址(最少10个)，以便我们有空间分配服务IP地址，如控制平面VIP或负载平衡器入口VIP。</p><h1 id="ecf8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">操作系统和准备工作:</h1><p id="8a78" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">裸机上的Anthos可以部署在几个linux发行版之上。我使用的是bmctl命令行工具的1.11.2版本，它可以帮助我们部署和管理裸机集群。以下是该工具1.11.2版支持的Linux发行版:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kz"><img src="../Images/795ad634d40151db5ad1e633478dafd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Yv7VYsb_CtUjBosh1flvQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">Anthos裸机支持的操作系统(针对版本1.11.2)</figcaption></figure><p id="c7e9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请<a class="ae ky" href="https://cloud.google.com/anthos/clusters/docs/bare-metal/latest/installing/os-reqs" rel="noopener ugc nofollow" target="_blank">查看文档</a>，因为您可能正在使用不同版本的工具和/或Anthos。这种情况下我用的是Ubuntu Server 20.04。它很容易安装，很容易使用，我的大部分Linux经验都来自于摆弄Ubuntu机器。</p><p id="742f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以，我按照通常的步骤在每台机器上安装Ubuntu服务器:</p><ol class=""><li id="2b39" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lf lg lh li bi translated">用Ubuntu服务器ISO文件刷新u盘。这可以在Windows中用<a class="ae ky" href="https://rufus.ie/en/" rel="noopener ugc nofollow" target="_blank"> Rufus </a>，在MacOS中用<a class="ae ky" href="https://www.balena.io/etcher/" rel="noopener ugc nofollow" target="_blank"> Balena Etcher </a>之类的东西，或者在linux中用dd(在这里找到教程<a class="ae ky" href="https://ostechnix.com/how-to-create-bootable-usb-drive-using-dd-command/" rel="noopener ugc nofollow" target="_blank"/>)来完成。</li><li id="5d34" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">将USB驱动器插入服务器并启动。在这个阶段，我们需要访问BIOS启动菜单，所以您需要在启动时按几个键中的一个来进入BIOS设置。此按钮因不同的BIOS制造商而异，但在我的戴尔Power-edge服务器中，它是“F11”否则，您可以尝试像“Delete”和“F2”这样的键</li><li id="3ab3" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">在启动菜单中选择USB驱动器</li><li id="6633" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">如果看不到驱动器，应该检查在刷新驱动器时使用了哪个分区模式。GUID分区表(GPT)是主引导记录(MBR)的下一个发展。一般来说，较新的(+/- 5年前)计算机将使用GPT，而带有传统BIOSs的旧计算机将只识别MBR。</li><li id="7225" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">这可能有其他原因，例如BIOS中禁用的USB端口或需要更新的不兼容驱动程序。</li><li id="9b11" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">按照安装工具提示的设置步骤进行操作。为了在裸机上正确安装Anthos，记住以下几点很重要:</li><li id="3ba3" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">确保没有两台服务器具有相同的主机名。如果你设置了相同的默认用户和密码就可以了，但是主机名必须不同。</li><li id="4dad" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">除了openssh-server之外，不要安装任何提示您安装的软件包。我们确实需要Docker，但是用安装工具安装它会调用snap，而不是apt。如果通过snap安装，软件包将保留在。快照目录，并且未与系统的其余部分集成。</li></ol><p id="774a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦安装了Ubuntu服务器，我们就可以继续我们的前期工作了。对于任何全新安装的Ubuntu，我们运行以下命令来更新和验证软件包管理器apt:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="5901" class="lt ig hi lp b fi lu lv l lw lx">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</span></pre><p id="44d4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在裸机上的Anthos中，机器之间的通信是必要的。这是通过无密码的根ssh完成的，这带来了一些复杂性和安全性考虑。让我们简单谈谈我们将如何从现在的位置配置该群集。</p><h1 id="03b5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Anthos on裸机安装先决条件:</h1><p id="0370" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们从安装步骤开始。首先，我们定义一台工作站机器和一台或多台节点机器。这个想法是，我们在我们的工作站机器上完成所有的安装工作，并从工作站机器上配置我们的其他节点机器。一旦我们创建了集群，我们的工作站机器本身就变成了节点机器。</p><p id="a53a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在裸机上的Anthos中，您可以使用bmctl命令行工具来创建和配置集群。Bmctl首先生成一个配置文件，它描述了将要构建的集群的每个细节。然后，使用bmctl实际创建集群。这个过程看起来像这样:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/b581238075f7aaffef30669e7e1153cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0eyQuF2brQNzyomj"/></div></div></figure><p id="d17a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们稍后将对此进行更深入的讨论，但我想在这里包括它，以支持我们的预安装步骤。有了这个，就更容易明白我们需要什么，为什么需要它。例如，我们需要让节点1上的用户thomas能够将ssh无密码地传递到两台机器的根目录，甚至是节点1上的根目录。我们看到，由于节点1的根用户成为控制平面/主节点，bmctl生成的引导集群(在用户thomas下运行)需要能够在没有密码的情况下访问它(无密码ssh)。就好像工作站是一台独立的计算机。</p><p id="4926" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您还会发现，最终，每台机器上的根用户负责运行集群的不同部分。这显然是一个安全问题，有一些方法可以将集群配置为在非root用户帐户上运行。为了简单起见，我将坚持使用默认配置。毕竟这只是一个简单的概念证明！</p><p id="8017" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，为了让bmctl正常工作，下面是对每个节点的要求(取决于其类型):</p><h1 id="f93c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">工作站先决条件:</h1><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ly"><img src="../Images/6d923873fb6c43ee1a4321969bdb1356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zY5ODhBwy8Tco3fx-zlNEw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">来源:<a class="ae ky" href="https://cloud.google.com/anthos/clusters/docs/bare-metal/latest/installing/install-prereq" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/anthos/clusters/docs/bare-metal/latest/installing/install-prereq</a></figcaption></figure><h1 id="2c10" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">节点先决条件:</h1><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lz"><img src="../Images/5185fa495acaaf8f7f568e8ea8b4501f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nj5Sl2YeDzRuWH7tb-1Bow.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">节点先决条件，第1部分</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lz"><img src="../Images/3147bd133328f57e57d15a6717e54327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNU1Y62DHZBEtNimrScb-Q.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">节点先决条件，第2部分</figcaption></figure><h1 id="f7c5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">安装和配置软件:</h1><p id="0290" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们现在可以知道在每台服务器上做什么了。从全新安装开始，以下是让我们的节点准备就绪的步骤:</p><ol class=""><li id="e11c" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lf lg lh li bi translated">配置无密码的超级用户访问。</li><li id="7d65" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">禁用AppArmor和简单防火墙(UFW)</li><li id="4bf7" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">在每台机器上安装Docker</li><li id="fe0e" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">在工作站机器上安装gcloud CLI</li><li id="657f" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">配置gcloud并使用gcloud安装kubectl</li></ol><p id="0f5d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我们对新安装的Ubuntu做任何事情之前，让我们配置我们的静态IP地址。正如我前面提到的，这一步非常重要，不仅可以确保我们的主机有一个健康的IP地址范围，还可以为服务分配虚拟IP地址和范围。</p><p id="b9e9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我的路由器中，我进入子网的DHCP页面，将其范围设置为192 . 168 . 1 . 100–192 . 168 . 1 . 255。这就为静态映射留出了从192.168.1.2到192.168.1.99的范围。因为我在这个子网上已经有了服务器，所以我为它们分配了192.168.1.5到192.168.1.19之间的静态IP地址。这是我的网络所特有的，但是我想为配置服务留下一个健康的范围。</p><p id="0907" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然后，在我的DHCP租约概述页面(连接的设备)中，我将两台机器的MAC地址复制到剪贴板。创建静态映射时，路由器会监听具有该特定MAC地址标识符的设备。当它试图连接时，它知道给机器分配一个特定的IP地址，这个地址是我们静态设置的。出于此部署的目的，我将为Node1(现在是我们的工作站机器，在我们的混合部署中将成为我们的控制平面/主节点)分配IP地址192.168.1.51。我将为节点2(即将成为我们的一个工作节点)分配IP地址192.168.1.52</p><p id="f22c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我们开始之前，从现在开始，我将务实地处理每个机器/用户。即工作站机器是我以用户“thomas”或thomas@192.168.1.51登录到节点1。因此，Worker 1是root@192.168.1.52，依此类推。</p><h1 id="001d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">配置无密码SSH</h1><p id="2aeb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是概念上更难理解的任务之一。您需要将工作站机器和控制平面/主节点视为独立的机器，即使它们是同一台机器。下面是我正确设置无密码ssh的步骤:</p><p id="813f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，我们将生成一个RSA公钥/私钥对。从工作站机器的非root用户(thomas@192.168.1.51)运行以下命令，并在所有提示中按enter键:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="4090" class="lt ig hi lp b fi lu lv l lw lx">ssh-keygen -t rsa</span></pre><p id="2e24" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这在您的$HOME/中生成了SSH私有和公共密钥对。ssh/目录。您的公钥和私钥将分别被命名为<em class="kw"> id_rsa.pub </em>和<em class="kw"> id_rsa </em>。现在，我们需要将公钥复制到远程服务器(root@192.168.1.52)。</p><p id="1022" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为此，我们需要在远程主机上通过密码启用root ssh，因此切换到第二台计算机并运行:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="3d9a" class="lt ig hi lp b fi lu lv l lw lx">sudo nano /etc/ssh/sshd_config</span></pre><p id="2f93" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将以下两行添加到文件的末尾:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="5000" class="lt ig hi lp b fi lu lv l lw lx">PasswordAuthentication yes</span><span id="9aeb" class="lt ig hi lp b fi ma lv l lw lx">PermitRootLogin yes</span></pre><p id="9761" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">重新启动ssh服务:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="9e74" class="lt ig hi lp b fi lu lv l lw lx">sudo service ssh restart</span></pre><p id="c7db" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">并设置一个强根密码:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="eb59" class="lt ig hi lp b fi lu lv l lw lx">sudo passwd</span></pre><p id="5e9c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，回到工作站(托马斯@192.168.1.51)。要将公钥复制到远程服务器，运行<em class="kw"> ssh-copy-id </em>:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="df42" class="lt ig hi lp b fi lu lv l lw lx">ssh-copy-id -i ~/.ssh/id_rsa root@192.168.1.52</span></pre><p id="941a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该命令将提示您输入远程服务器的root密码，因为它通过端口22 (ssh协议)传输密钥。因为我们允许使用密码通过ssh进行root身份验证，所以应该不会出错。</p><p id="bea5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，测试连接:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="fee3" class="lt ig hi lp b fi lu lv l lw lx">ssh -i ~/.ssh/id_rsa root@192.168.1.52</span></pre><p id="94b8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这应该会立即连接，而不会提示您输入密码。如果是这样，就转到远程服务器(Worker 1)来更新<em class="kw"> sshd_config </em>。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="1449" class="lt ig hi lp b fi lu lv l lw lx">sudo nano /etc/ssh/sshd_config</span></pre><p id="1026" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">用下面的内容更新您之前添加的两行代码:(注意:如果您计划通过ssh管理您的服务器，请将PasswordAuthentication设置为“yes”否则，您将无法ssh到您的工作站。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="423a" class="lt ig hi lp b fi lu lv l lw lx">PasswordAuthentication yes # set to no, if not working over ssh</span><span id="623e" class="lt ig hi lp b fi ma lv l lw lx">PermitRootLogin without-password</span></pre><p id="ec21" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">重新启动ssh服务:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="787e" class="lt ig hi lp b fi lu lv l lw lx">sudo service ssh restart</span></pre><p id="b46c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">并删除您之前为root设置的密码:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="f91a" class="lt ig hi lp b fi lu lv l lw lx">sudo passwd -l root</span></pre><p id="d1f5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你有它！无密码根ssh。请记住，您必须为包括工作站/控制平面/主节点(192.168.1.51或节点1)在内的每台机器执行此操作。只需将远程服务器的IP地址替换为192.168.1.51。</p><h1 id="19c5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">残疾人服装和UFW</h1><p id="408e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在每台计算机上，运行以下命令集:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="9c1e" class="lt ig hi lp b fi lu lv l lw lx">systemctl stop apparmor &amp;&amp; \</span><span id="63e7" class="lt ig hi lp b fi ma lv l lw lx">systemctl disable apparmor &amp;&amp; \</span><span id="5172" class="lt ig hi lp b fi ma lv l lw lx">systemctl stop ufw</span><span id="b9a1" class="lt ig hi lp b fi ma lv l lw lx">systemctl disable ufw</span></pre><h1 id="f0df" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在每台机器上安装Docker</h1><p id="e7d9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了安装Docker，您需要更新apt包索引并安装包，以允许apt通过HTTPS使用一个库。可以在<a class="ae ky" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank"> Docker官网</a>上按照步骤操作。</p><p id="6cde" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">成功安装后，有必要允许非根用户访问docker CLI。您可以通过将您的用户添加到docker组来实现这一点。如何操作的说明可以在<a class="ae ky" href="https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="e28b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在您的工作站上安装和配置gcloud CLI</h1><p id="676f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">与安装Docker的方式类似，您需要添加gcloud CLI发行版URI作为软件包源。关于如何安装CLI的说明可以在<a class="ae ky" href="https://cloud.google.com/sdk/docs/install#deb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="2853" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Ubuntu 20.04支持signed-by选项，apt-key命令支持— keyring参数，所以在安装gcloud CLI时一定要使用这些参数。从这里，我们可以设置我们的项目并安装所需的依赖项。</p><p id="4848" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，我们将更新CLI:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="37c7" class="lt ig hi lp b fi lu lv l lw lx">gcloud components update</span></pre><p id="93a5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">之后，我们将登录我们的GCP项目。根据您的操作系统，此过程可能会有所不同。由于Ubuntu Server没有桌面环境或浏览器，所以这个过程稍微复杂一些。首先，运行:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="3163" class="lt ig hi lp b fi lu lv l lw lx">gcloud auth login --update-adc</span></pre><p id="ce4d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你会得到一个以<em class="kw">g cloud auth log in-remote-bootstrap =</em>开头的命令提示。您需要在已经安装了桌面环境、web浏览器和gcloud CLI的机器上运行这个命令。在这种情况下，我将该命令带到我的Macbook上并在那里运行。它正确地通过了身份验证，并吐出了一个很长的URL，然后我不得不把它带回工作站。是对提示的响应，<strong class="jf hj">“输入上面命令的输出，回车完成授权。”</strong></p><p id="33d2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在我们已经登录，我们可以管理服务和服务帐户。我们还可以完成依赖项的安装:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="4b60" class="lt ig hi lp b fi lu lv l lw lx">gcloud components install kubectl</span></pre><p id="a2fa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">此时，运行gcloud init也是一个好主意，它会设置一个新的或现有的配置，并在该配置中设置属性，包括当前项目和您希望使用的默认Google计算引擎区域。</p><p id="abf5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就是这样！我们的服务器都已正确配置，因此我们可以进入下一步:安装并使用bmctl命令行工具来生成配置文件，该文件描述了我们希望如何设置裸机集群。</p><h1 id="aa1d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">GCP属地:</h1><p id="a02e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们来谈谈服务客户和IAM角色。为了使此工作正常进行，需要向项目授予几个服务帐户和IAM角色。幸运的是，当我们运行bmctl create config命令时，bmctl命令行工具为我们配置了这些资源。如果您选择手动执行此操作，以下是您需要创建和配置的内容:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/a02ce0bd9ddb4081776ea5796d5df24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jOxfLda12huiRUUn"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">裸机上的Anthos所需的权限</figcaption></figure><p id="971a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意:根据您使用的bmctl工具的版本，它可能不会创建所有需要的资源。我不得不手动将“Ops配置监控资源元数据写入器”添加到<em class="kw">anthos-bare metal-cloud-Ops @&lt;PROJECT _ ID&gt;. iam . gserviceaccount . com</em>服务帐户。然而，bmctl工具确实指定了在失败时缺少什么，所以我不需要非常努力地寻找我需要做什么。</p><p id="9439" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我设置的某些情况下，bmctl不会为我的项目启用适当的IAM角色，所以现在这样做不会有什么坏处。为此，您可以运行以下命令:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="5661" class="lt ig hi lp b fi lu lv l lw lx">gcloud services enable --project PROJECT_ID \</span><span id="1600" class="lt ig hi lp b fi ma lv l lw lx">anthos.googleapis.com \</span><span id="1bef" class="lt ig hi lp b fi ma lv l lw lx">anthosaudit.googleapis.com \</span><span id="a6d5" class="lt ig hi lp b fi ma lv l lw lx">anthosgke.googleapis.com \</span><span id="6ab6" class="lt ig hi lp b fi ma lv l lw lx">cloudresourcemanager.googleapis.com \</span><span id="4fd8" class="lt ig hi lp b fi ma lv l lw lx">gkeconnect.googleapis.com \</span><span id="c3c7" class="lt ig hi lp b fi ma lv l lw lx">gkehub.googleapis.com \</span><span id="3fa0" class="lt ig hi lp b fi ma lv l lw lx">serviceusage.googleapis.com \</span><span id="215f" class="lt ig hi lp b fi ma lv l lw lx">stackdriver.googleapis.com \</span><span id="3b78" class="lt ig hi lp b fi ma lv l lw lx">monitoring.googleapis.com \</span><span id="8451" class="lt ig hi lp b fi ma lv l lw lx">logging.googleapis.com \</span><span id="f50d" class="lt ig hi lp b fi ma lv l lw lx">opsconfigmonitoring.googleapis.com</span></pre><h1 id="e6e4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">BMCTL:</h1><p id="c432" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">bmctl命令自动设置所需的服务帐户，并启用在指定项目中的裸机上使用Anthos集群所需的API。</p><p id="40e0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您想创建自己的服务帐户或自己进行其他手动项目设置，请参见<a class="ae ky" href="https://cloud.google.com/anthos/clusters/docs/bare-metal/latest/installing/configure-sa" rel="noopener ugc nofollow" target="_blank">在使用bmctl创建集群之前启用Google服务和服务帐户</a>。</p><p id="549e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，我们将为整个项目创建一个目录，包括bmctl工具本身:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="8e5d" class="lt ig hi lp b fi lu lv l lw lx">cd ~</span><span id="9d9e" class="lt ig hi lp b fi ma lv l lw lx">mkdir baremetal</span><span id="30d0" class="lt ig hi lp b fi ma lv l lw lx">cd baremetal</span></pre><p id="a6ae" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们将从其云存储桶中下载最新版本的bmctl，并使其可执行:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="6500" class="lt ig hi lp b fi lu lv l lw lx">gsutil cp gs://anthos-baremetal-release/bmctl/1.11.2/linux-amd64/bmctl bmctl</span><span id="a39d" class="lt ig hi lp b fi ma lv l lw lx">chmod a+x bmctl</span></pre><p id="403c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您可以通过运行以下命令来检查它是否在工作:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="7c0e" class="lt ig hi lp b fi lu lv l lw lx">./bmctl -h</span></pre><p id="9bbc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">好消息是。我们将立即为我们的集群创建一个配置文件，并自动启用服务帐户和API:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="d246" class="lt ig hi lp b fi lu lv l lw lx">./bmctl create config -c CLUSTER_NAME \</span><span id="e4bd" class="lt ig hi lp b fi ma lv l lw lx">--enable-apis --create-service-accounts --project-id=PROJECT_ID</span></pre><p id="2e7b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kw"> CLUSTER_NAME </em>可以是你想要的任何东西，<em class="kw"> PROJECT_ID </em>当然是你的项目ID。这将需要几秒钟的时间来运行，但完成后，它将创建几个新的文件和目录。我们对位于以下路径的<em class="kw">裸机</em>目录下的配置文件感兴趣:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="802c" class="lt ig hi lp b fi lu lv l lw lx">bmctl-workspace/CLUSTER_NAME/CLUSTER_NAME.yaml</span></pre><p id="f143" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们需要对提供的文件进行一些编辑，这可以在像nano或vim这样的文本编辑器中完成。</p><p id="6aff" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在下一节中，我已经复制了我的整个完整配置，我将并排讨论它的每个重要细节，因为这是我花费大部分时间的地方。提前计划是很重要的，尤其是在人际交往方面。对CIDR数据块和IP地址分配的深入了解是成功启动集群的必要条件。</p><h1 id="4356" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">编辑配置:</h1><p id="a569" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这一节中，我将介绍如何配置我的集群配置yaml。文件中有一些数字与下面的描述相对应。比如<strong class="jf hj"> &lt; 1 &gt; </strong>会对应关于SSH私钥的段落。这里有几件事情需要记住，它们将根据您的具体部署而有所不同，我将详细介绍。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="4c25" class="lt ig hi lp b fi lu lv l lw lx"># CLUSTER_NAME.yaml<br/>gcrKeyPath: bmctl-workspace/.sa-keys/anthos-at-home-demo-anthos-baremetal-gcr.json<br/>sshPrivateKeyPath: /home/thomas/.ssh/id_rsa <strong class="lp hj"># &lt;1&gt;</strong><br/>gkeConnectAgentServiceAccountKeyPath: bmctl-workspace/.sa-keys/anthos-at-home-demo-anthos-baremetal-connect.json<br/>gkeConnectRegisterServiceAccountKeyPath: bmctl-workspace/.sa-keys/anthos-at-home-demo-anthos-baremetal-register.json<br/>cloudOperationsServiceAccountKeyPath: bmctl-workspace/.sa-keys/anthos-at-home-demo-anthos-baremetal-cloud-ops.json<br/>---<br/>apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: cluster-on-prem-cluster<br/>---<br/>apiVersion: baremetal.cluster.gke.io/v1<br/>kind: Cluster<br/>metadata:<br/>  name: on-prem-cluster<br/>  namespace: cluster-on-prem-cluster<br/>spec:<br/>  type: hybrid <strong class="lp hj"># &lt;2&gt;</strong><br/>  profile: default <strong class="lp hj"># &lt;3&gt;</strong><br/>  anthosBareMetalVersion: 1.11.2<br/>  gkeConnect:<br/>    projectID: anthos-at-home-demo<br/>  controlPlane:<br/>    nodePoolSpec:<br/>      nodes:<br/>      - address: 192.168.1.51 <strong class="lp hj"># &lt;4&gt;</strong><br/>  clusterNetwork:<br/>    pods:<br/>      cidrBlocks:<br/>      - 172.16.0.0/16 <strong class="lp hj"># &lt;5&gt;</strong><br/>    services:<br/>      cidrBlocks:<br/>      - 10.96.0.0/20 <strong class="lp hj"># &lt;6&gt;</strong><br/>  loadBalancer:<br/>    mode: bundled <strong class="lp hj"># &lt;7&gt;</strong><br/>    ports:<br/>      controlPlaneLBPort: 443<br/>    vips: <strong class="lp hj"># &lt;8&gt;</strong><br/>      controlPlaneVIP: 192.168.1.99<br/>      ingressVIP: 192.168.1.20<br/>    addressPools:<br/>    - name: pool1<br/>      addresses:<br/>      - 192.168.1.20–192.168.1.29<br/>  clusterOperations:<br/>    projectID: anthos-at-home-demo<br/>    location: us-central1<br/>  storage: <strong class="lp hj"># &lt;9&gt;</strong><br/>    lvpNodeMounts:<br/>      path: /mnt/localpv-disk<br/>      storageClassName: local-disks<br/>    lvpShare:<br/>      path: /mnt/localpv-share<br/>      storageClassName: local-shared<br/>      numPVUnderSharedPath: 5<br/>  nodeConfig:<br/>    podDensity:<br/>      maxPodsPerNode: 250<br/>    containerRuntime: containerd</span><span id="a12a" class="lt ig hi lp b fi ma lv l lw lx">### Authentication Section ### <strong class="lp hj"># &lt;10&gt;</strong></span><span id="a2f8" class="lt ig hi lp b fi ma lv l lw lx">---<br/>apiVersion: baremetal.cluster.gke.io/v1<br/>kind: NodePool<br/>metadata:<br/>  name: node-pool-1<br/>  namespace: cluster-on-prem-cluster<br/>spec:<br/>  clusterName: on-prem-cluster<br/>  nodes: <strong class="lp hj"># &lt;11&gt;</strong><br/>  - address: 192.168.1.52 <br/>  # — address: &lt;Machine 3 IP&gt;</span></pre><p id="7b7b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 1 &gt; </strong>在这个部分中，我们定义了我们的键的位置。除了<em class="kw">ssprivatekeypath</em>之外，其他都已定义，所以我们将在这里这样做。需要记住的是，bmctl不处理环境变量，所以$HOME/。ssh/id_rsa不行。我们需要指定绝对路径/home/thomas/。ssh/id_rsa，以便bmctl能够找到它。这个键将允许工作站能够访问两台机器的root用户(记住将node 1–Thomas和node 1–root视为两台不同的机器)</p><p id="9db4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 2 &gt; </strong>在这里，我们定义想要创建的集群类型和想要使用的集群配置文件。混合最适合我的用例，因为我只有两个物理节点。我无法创建单独的管理和用户节点，因此混合模式允许我在管理集群上运行用户工作负载。当我描述我的集群时，kubectl将向我展示Node1是我的控制平面和主节点，Node2是我的工作节点。</p><p id="7a6e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt;三个&gt; </strong>(“小于三”在介质上显示为心形，观察:❤)由于我的节点满足最低硬件要求，所以使用默认配置文件。边缘配置文件用于较小的节点，但只能在独立集群中调用。</p><p id="949d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 4 &gt; </strong>这是控制平面/主节点的静态IP(即节点1)</p><p id="3375" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是重要的一步。它最初的CIDR范围是192.168.0.0/16，包含192.168.0.0到192.168.255.255之间的IP地址。这与我们的子网192.168.1.0/24重叠，因此我将其更改为另一个私有RFC1918地址空间172.16.0.0/16。这样，我们的pod网络就不会与其他任何东西重叠。</p><p id="806a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这个CIDR靶场将会很好，除非你在这个地方操作任何东西。</p><p id="199d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 7 &gt; </strong>在“捆绑”模式下，在集群创建期间，负载平衡器将安装在负载平衡器节点上。这样设置意味着我们不需要担心手动配置外部负载平衡器。</p><p id="8599" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 8 &gt; </strong>我们在这里指定两个虚拟IP地址:一个用于控制平面服务(即Kubernetes API服务器)，一个用于所有服务的入口。它是第7层负载平衡器，这意味着它根据主机名或路径而不是IP地址来引导流量。控制平面VIP不能在负载平衡器的地址池中，所以我把它放在静态IP范围的最末端。入口VIP由入口流量的所有服务共享，并且必须位于负载平衡器使用的地址池(此处称为pool1)中。在这种情况下，负载平衡器将处理所有类型的集群服务以及工作负载，因此我们需要为它分配相当多的IP地址。对我来说，10已经足够了。</p><p id="1d37" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 9 &gt;</strong></p><p id="e87c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 10 &gt; </strong>还有一个额外的身份验证部分，但这只适用于您想要在集群上设置OIDC身份验证的情况。非常适合生产工作负载安全性，但是对于本演示来说太复杂了</p><p id="02bb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> # &lt; 11 &gt; </strong>在这里，您可以指定其他机器的静态IP地址。这些机器将构成您的工作节点池。</p><h1 id="1cf3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建集群</h1><p id="afc2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">此时，我们可以继续使用bmctl来创建我们已经定义的集群。这是命令:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="9601" class="lt ig hi lp b fi lu lv l lw lx">./bmctl create cluster -c CLUSTER_NAME</span></pre><p id="1b62" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这需要一些时间。对我来说，大约需要20分钟。如果有错误，bmctl会运行预检检查以确保所有配置都正确，如果有任何错误，它会使作业失败。这些错误将向您显示配置文件、服务帐户或IAM中分配或未分配的权限是否有问题。这些错误将打印到STDOUT，但是您可以在日志文件中找到更详细的信息，可以在以下位置找到:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="4fae" class="lt ig hi lp b fi lu lv l lw lx">bmctl-workspace/CLUSTER_NAME/log/create-cluster-TIMESTAMP/bootstrap-cluster/</span></pre><h1 id="f5a4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在云控制台中管理集群</h1><p id="51b1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果集群创建成功，您可以在GCP控制台查看GKE的新集群。它看起来会像这样:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/1428c5b5c0e094050b051af3d14b5ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ljO7SmLhPR4E-aqC"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">Anthos UI显示您需要登录到您的集群。</figcaption></figure><p id="36a9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如提示所述，您需要登录到您的集群。在裸机上安装Anthos集群后，Connect使用一个名为Connect Agent的部署在集群和Google Cloud项目之间建立连接，并处理Kubernetes请求。Connect Agent管理有关您的帐户凭据的信息，以及您连接的集群基础架构和工作负载的技术详细信息，包括资源、应用程序和硬件。若要授予对您的GCP用户帐户的访问权限，建议创建一个Kubernetes服务帐户来生成无记名令牌，然后使用无记名令牌身份验证。这个过程有点复杂，但总体思路是这样的:</p><ol class=""><li id="328c" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lf lg lh li bi translated">创建一个名为cloud-console-reader的集群角色RBAC角色定义</li><li id="40d6" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">创建并授权Kubernetes服务帐户(KSA)</li><li id="d528" class="la lb hi jf b jg lj jk lk jo ll js lm jw ln ka lf lg lh li bi translated">得到KSA的不记名令牌</li></ol><p id="b4de" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这将允许您从云控制台访问以查看和管理您的群集资源。我是这样做的:</p><p id="674a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> <em class="kw">更新【09/29/22】:看来下面的策略可能不再管用了。如果您在尝试生成您的KSA不记名令牌时遇到问题，请参考由</em> </strong> <a class="mb mc ge" href="https://medium.com/u/1def10e8c217?source=post_page-----5bcef301cfa5--------------------------------" rel="noopener" target="_blank"> <strong class="jf hj"> <em class="kw"> Hil廖</em> </strong> </a> <strong class="jf hj"> <em class="kw">(谢谢！):</em> </strong></p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="f4a9" class="lt ig hi lp b fi lu lv l lw lx">#!/bin/bash<br/>set -e # exit the script when execution hits any error<br/>set -x # print the executing lines<br/>KSA_NAME=ksa-cloud-console<br/>kubectl create serviceaccount ${KSA_NAME}<br/>kubectl create clusterrolebinding cloud-console-reader-role-binding --clusterrole cloud-console-reader --serviceaccount default:${KSA_NAME}<br/>SECRET_NAME=$KSA_NAME-token<br/>kubectl apply -f - &lt;&lt; __EOF__<br/>apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: "${SECRET_NAME}"<br/>  annotations:<br/>    kubernetes.io/service-account.name: "${KSA_NAME}"<br/>type: kubernetes.io/service-account-token<br/>__EOF__</span><span id="e560" class="lt ig hi lp b fi ma lv l lw lx">kubectl create clusterrolebinding admin-role-binding --clusterrole=cluster-admin --serviceaccount default:ksa-cloud-console</span><span id="b64d" class="lt ig hi lp b fi ma lv l lw lx">kubectl get secret ${SECRET_NAME} -o jsonpath='{$.data.token}' | base64 --decode</span></pre><ol class=""><li id="6796" class="la lb hi jf b jg kb jk kc jo lc js ld jw le ka lf lg lh li bi translated"><strong class="jf hj">生成集群角色RBAC策略:</strong></li></ol><p id="7747" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">通过将文件读入yaml定义来生成一个ClusterRole。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="e6bd" class="lt ig hi lp b fi lu lv l lw lx">cat &lt;&lt;EOF &gt; cloud-console-reader.yaml<br/>kind: ClusterRole<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/>  name: cloud-console-reader<br/>rules:<br/>- apiGroups: [“”]<br/>  resources: [“nodes”, “persistentvolumes”, “pods”]<br/>  verbs: [“get”, “list”, “watch”]<br/>- apiGroups: [“storage.k8s.io”]<br/>  resources: [“storageclasses”]<br/>  verbs: [“get”, “list”, “watch”]<br/>EOF</span></pre><p id="e455" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将新资源应用到集群。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="9ee9" class="lt ig hi lp b fi lu lv l lw lx">kubectl apply -f cloud-console-reader.yaml</span></pre><p id="60ad" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">2.<strong class="jf hj">使用gcloud CLI创建并授权KSA:</strong></p><p id="f0e3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">定义一个环境变量。这是您的Kubernetes服务帐户的名称。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="5085" class="lt ig hi lp b fi lu lv l lw lx">KSA_NAME=KSA_NAME</span></pre><p id="1708" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">创建服务帐户，并赋予其角色“查看”和“云控制台-阅读器”</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="f944" class="lt ig hi lp b fi lu lv l lw lx">kubectl create serviceaccount ${KSA_NAME}</span><span id="abb0" class="lt ig hi lp b fi ma lv l lw lx">kubectl create clusterrolebinding VIEW_BINDING_NAME \<br/>--clusterrole view --serviceaccount default:${KSA_NAME}</span><span id="78ec" class="lt ig hi lp b fi ma lv l lw lx">kubectl create clusterrolebinding CLOUD_CONSOLE_READER_BINDING_NAME \<br/>--clusterrole cloud-console-reader --serviceaccount default:${KSA_NAME}</span></pre><p id="2251" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请记住，您需要完成这个过程，以便向您希望访问该群集的每个其他服务帐户或用户授予访问权限。对于您可以创建的其他任务，还有其他可用的群集角色绑定。例如，您可以应用以下内容来授予您的用户在群集上部署GKE市场应用程序的权限:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="55ec" class="lt ig hi lp b fi lu lv l lw lx">kubectl create clusterrolebinding BINDING_NAME \<br/>--clusterrole cluster-admin --serviceaccount default:ACCOUNT_NAME</span></pre><p id="af64" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">3.<strong class="jf hj">获得KSA的不记名令牌:</strong></p><p id="91b1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这有点复杂，但是这是最好的方法。首先，为您的KSA令牌声明一个环境变量名。</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="6eff" class="lt ig hi lp b fi lu lv l lw lx">SECRET_NAME=KSA_NAME-token</span></pre><p id="6d7b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">应用一个Kubernetes Secret定义来实例化您的Kubernetes服务帐户，并等待集群发出一个不记名令牌</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="b2cf" class="lt ig hi lp b fi lu lv l lw lx">kubectl apply -f — &lt;&lt; __EOF__<br/>apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: “${SECRET_NAME}”<br/>  annotations:<br/>    kubernetes.io/service-account.name: “${KSA_NAME}”<br/>type: kubernetes.io/service-account-token<br/>__EOF__<br/>until [[ $(kubectl get -o=jsonpath=”{.data.token}” “secret/${SECRET_NAME}”) ]]; do<br/>  echo “waiting for token…” &gt;&amp;2;<br/>  sleep 1;<br/>done</span></pre><p id="5022" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将秘密读出到STDOUT:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="aa34" class="lt ig hi lp b fi lu lv l lw lx">kubectl get secret ${SECRET_NAME} -o jsonpath=’{$.data.token}’ | base64 --decode</span></pre><p id="93eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，您可以将此令牌复制到GCP·安托什的令牌仪表板，并将其粘贴为您的不记名令牌。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/c5cc483702736a384c260af3420cc749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GBc5BQtTYY7ixPsn"/></div></div></figure><p id="f808" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">另外要提到的是，您可能需要指定使用哪个kubeconfig。在某些情况下，我需要遵循每个kubectl命令:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="d404" class="lt ig hi lp b fi lu lv l lw lx">--kubeconfig bmctl-workspace/&lt;CLUSTER_NAME&gt;/&lt;CLUSTER_NAME&gt;-kubeconfig</span></pre><p id="aa59" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">事实证明，您可以将这个配置作为环境变量导出，当您运行kubectl命令时，kubectl会知道使用正确的kubeconfig。你可以这样做:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="bb2c" class="lt ig hi lp b fi lu lv l lw lx">export \ <br/>KUBECONFIG=$HOME/baremetal/bmctl-workspace/on-prem-cluster/on-prem-cluster-kubeconfig</span></pre><p id="2afb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">使用测试命令验证环境变量是否已正确导出:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="8bb5" class="lt ig hi lp b fi lu lv l lw lx">kubectl get nodes</span></pre><p id="6743" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接下来应该是:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="003c" class="lt ig hi lp b fi lu lv l lw lx">NAME   STATUS  ROLES                 AGE  VERSION<br/>node1  Ready   control-plane,master  45m  v1.22.8-gke.200<br/>node2  Ready   worker                45m  v1.22.8-gke.200</span></pre><p id="b251" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您收到如下所示的错误:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="c8e4" class="lt ig hi lp b fi lu lv l lw lx">The connection to the server localhost:8080 was refused — did you specify the right host or port?</span></pre><p id="eded" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">…这意味着找不到您的kubeconfig。</p><p id="afbc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果没有错误，我们就可以开始了！</p><h1 id="8c14" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">现在怎么办？</h1><p id="8f55" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们的集群是活的并且经过认证的，所以我们可以开始用它做一些事情。从一开始，Anthos就向您展示了您能够将什么整合到您的集群中:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es md"><img src="../Images/0daa1ef1b01a6fefdd9044798ec39cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/0*p6aGHhsjofBCUxSE"/></div></figure><p id="38be" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们将从从工作站机器(thomas@Node1)向集群部署应用程序开始。我们将保持简单，使用来自Google Samples的“hello-app”示例容器映像创建一个示例nginx部署。下面是deployment.yaml文件:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="b7b9" class="lt ig hi lp b fi lu lv l lw lx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hello-app<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: hello-app<br/>  replicas: 3<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello-app<br/>    spec:<br/>      containers:<br/>      - name: hello<br/>        image: “gcr.io/google-samples/hello-app:2.0”</span></pre><p id="9c47" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们需要将这些信息写入工作站机器上的一个文件中，所以我已经ssh到其中，并再次从baremetal目录开始工作。</p><p id="8683" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，确保你在正确的地方:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="ef7f" class="lt ig hi lp b fi lu lv l lw lx">cd $HOME/baremetal</span></pre><p id="565f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然后，我们将使用nano创建并写入一个文件:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="0bb1" class="lt ig hi lp b fi lu lv l lw lx">nano deployment.yaml</span></pre><p id="36a7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将上面的文字粘贴到文件中，然后按ctrl+o，回答“是”保存文件，然后按ctrl+x退出nano。</p><p id="c902" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们可以创建部署:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="9ab7" class="lt ig hi lp b fi lu lv l lw lx">kubectl apply -f deployment.yaml</span></pre><p id="467b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就是这样！它已经启动并运行了，您可以通过运行kubectl get deployments来验证这一点。但是我们还没有完成，因为我们需要定义一个服务来公开集群外部的应用程序。我们将使用以下yaml来创建我们的服务:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="6c4a" class="lt ig hi lp b fi lu lv l lw lx">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: hello-app-lb<br/>spec:<br/>  selector:<br/>    app: hello-app<br/>  type: LoadBalancer<br/>  ports:<br/>  - port: 80<br/>    targetPort: 8080</span></pre><p id="eef9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为该服务编写一个文件，类似于我们部署hello-app部署的方式:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="5d68" class="lt ig hi lp b fi lu lv l lw lx">nano service.yaml</span></pre><p id="c3ac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">将上面的文本粘贴到文件中，然后保存并退出。</p><p id="09f5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后，部署服务:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="d478" class="lt ig hi lp b fi lu lv l lw lx">kubectl apply -f service.yaml</span></pre><p id="43b0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后，您需要检查集群分配给应用程序的IP地址和端口，因此运行:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="3f5d" class="lt ig hi lp b fi lu lv l lw lx">kubectl get services</span></pre><p id="5865" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">输出应该如下所示:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="6c6e" class="lt ig hi lp b fi lu lv l lw lx">NAME          TYPE          CLUSTER-IP    EXTERNAL-IP   PORT(S)       AGE<br/>hello-app-lb  LoadBalancer  10.96.15.179  192.168.1.21  80:31959/TCP  18s<br/>kubernetes    ClusterIP     10.96.0.1     &lt;none&gt;        443/TCP       2d1h</span></pre><p id="2b8d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在我们结束了。我们可以通过进入web浏览器(在连接到您的网络的机器上)并指定负载平衡器服务的IP地址和端口来测试部署，以查看它是否工作。在这种情况下，它是192.168.1.21:80。</p><p id="acc1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我们可以访问这个网页来展示我们的劳动成果:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es me"><img src="../Images/6407a38243638ade45f5b492b59cdbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6pzcJK22CYzIr-aa"/></div></div></figure><p id="885b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你必须原谅我的书签，但这是一个巨大的成功！这一切都完美无缺。</p><p id="9239" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">此外，如果您想检查部署是否成功，但您不在装有浏览器的计算机上，只需运行以下命令:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="881a" class="lt ig hi lp b fi lu lv l lw lx">curl 192.168.1.21</span></pre><p id="6931" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果一切顺利，您将看到如下输出:</p><pre class="kh ki kj kk fd lo lp lq lr aw ls bi"><span id="bc4f" class="lt ig hi lp b fi lu lv l lw lx">Hello, world!<br/>Version: 2.0.0<br/>Hostname: hello-app-669b85c4cc-dpzw8</span></pre><p id="dcd8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在你知道了！这是我详细的一步一步的指南，告诉我如何在家里自己的服务器上成功地在裸机集群上运行Anthos。同样，做这样的事情并不需要强大的企业级硬件，我希望我的解释尽可能地让这个过程易于理解。要与我联系，请发送电子邮件给我:</p><p id="6dad" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae ky" href="mailto:tdesrosi@google.com" rel="noopener ugc nofollow" target="_blank">tdesrosi@google.com</a></p></div></div>    
</body>
</html>