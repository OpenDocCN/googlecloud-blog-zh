<html>
<head>
<title>Kubernetes Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-best-practices-8d5cd03446e2?source=collection_archive---------1-----------------------#2018-04-19">https://medium.com/google-cloud/kubernetes-best-practices-8d5cd03446e2?source=collection_archive---------1-----------------------#2018-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ca27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我和一位前谷歌员工SRE聊天，他(正确地)指出Kubernetes发展非常快(太快以至于不能保持流行)，使用(许多)新颖的概念，并且有(太多)方法来解决同样的问题。</p><p id="248f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这大部分是真的，不一定是坏事，也不一定与任何其他技术不同。我不同意的是，这些因素阻碍了他采用Kubernetes。我会鼓励你投入进去。Kubernetes是成功的，尽管有这些(合理的)担忧，因为它非常非常好。</p><p id="aa7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本帖中，我将向您提供一些基本的最佳实践，希望能帮助您抓住这一技术的容器并深入其中。</p><p id="04ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">排名不分先后:</p><ol class=""><li id="0387" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">让别人去做苦工吧！</strong></li></ol><p id="e4a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Kubernetes服务，如Kubernetes引擎。除非你很好奇，你是一个开发Kubernetes的开发者，或者你是一个平台提供商，有客户要求Kubernetes服务，省掉麻烦，使用Kubernetes服务。你建造了自己的家和汽车吗？或者你真的喜欢睡在一个狼不会吹倒的地方，开着一辆可靠地把你从A带到B的车？</p><p id="295b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，如果你读过我的其他帖子，我也建议你评估一下<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/multi-zone-and-regional-clusters#regional" rel="noopener ugc nofollow" target="_blank">区域集群</a>，这样你就可以看到这样的东西:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="d978" class="jw jx hi js b fi jy jz l ka kb">gcloud beta container clusters create ${CLUSTER} ...<br/>gcloud beta container clusters get-credentials ${CLUSTER} ...</span></pre><p id="0ccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，你就可以开始了:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="7d7e" class="jw jx hi js b fi jy jz l ka kb">kubectl apply --filename=marvels.yaml</span></pre><p id="6c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。试想想“Kubernetes”</strong></p><p id="14e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其他平台相比，这对于Kubernetes引擎来说可能是一个更大的挑战，但是在Google云平台上，您必须了解Kubernetes中资源的状态(例如节点、入口)，同时还要了解计算引擎中的底层资源(例如虚拟机、HTTP/S负载平衡器)。这个粒子-波二元性问题是不幸的。感谢戴尔·h首先为我阐明了这一点。</p><p id="8b67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在可能的情况下，试着坚持从Kubernetes的资源的角度思考，而忽略潜在的GCE资源。现在，我已经花了一年多的时间将我的工作偏向于Kubernetes，这使得纯粹从服务(和入口)公开的“一定数量”的pod的角度来考虑变得更加容易。</p><p id="8973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。名称空间，名称空间，名称空间</strong></p><blockquote class="kc kd ke"><p id="023c" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated">U <strong class="ih hj"> pdate </strong>:感谢<a class="kj kk ge" href="https://medium.com/u/5b086b7c6aea?source=post_page-----8d5cd03446e2--------------------------------" rel="noopener" target="_blank"> Michael Hausenblas </a>教给我一个最佳实践，即不要在Kubernetes YAML文件中引用名称空间。虽然你应该总是使用名称空间，但在你<code class="du kl km kn js b">apply</code>文件时指定这些名称空间提供了更多的灵活性和对不同的场景使用相同的YAML文件的能力。看迈克尔的文章<a class="ae jd" href="https://blog.openshift.com/kubernetes-application-operator-basics/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><p id="9077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几个月前，Mike Altarace和我在博客上讨论了Kubernetes中的名称空间以及应该在哪里使用它们。从那时起，我几乎忽略了我自己的建议，认为我的用例是如此之小，以至于使用名称空间会过于紧张。我错了。始终使用名称空间。</p><p id="3a2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像容器对于流程一样，名称空间对于Kubernetes项目也是如此。除了名称空间传达的安全边界之外，它们是划分您的工作的一种极好的方式，并且它们产生了重置或删除它的一种极好的方式:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="fd4d" class="jw jx hi js b fi jy jz l ka kb">kubectl delete namespace/$WORKING_PROJECT</span></pre><p id="1341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唯一的缺点是，当使用非<code class="du kl km kn js b">default</code>名称空间时，您需要在<code class="du kl km kn js b">kubectl</code>命令上指定您的工作名称空间<code class="du kl km kn js b">--namespace=$WORKING_PROJECT</code>，在我看来，这是一个很好的保护措施。然而，你可以总是<code class="du kl km kn js b">--all-namespaces</code>或者设置一个不同的名称空间作为你的默认名称空间(<a class="ae jd" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-preference" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><p id="e550" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。解决问题的方法太多</strong></p><p id="fa38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个令人沮丧的担忧。我认为这可能是不真实的，但是，如果没有好的指导和最佳实践，也许看起来有太多相似的方法来解决同一个问题。我有一个常用的模式，我在这里总结一下，以鼓励讨论:</p><ul class=""><li id="5f44" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc ko jk jl jm bi translated">YAML文件是冷藏的知识(见#5)</li><li id="b44f" class="je jf hi ih b ii kp im kq iq kr iu ks iy kt jc ko jk jl jm bi translated">你的容器应该做好一件事</li><li id="6b88" class="je jf hi ih b ii kp im kq iq kr iu ks iy kt jc ko jk jl jm bi translated">始终部署部署(参见第6条)</li><li id="a197" class="je jf hi ih b ii kp im kq iq kr iu ks iy kt jc ko jk jl jm bi translated">如果您想要L7(也称为HTTP/S)负载平衡，请使用Ingress(参见#7 — ha！)</li><li id="9b8d" class="je jf hi ih b ii kp im kq iq kr iu ks iy kt jc ko jk jl jm bi translated">使用机密安全地管理凭证(<a class="ae jd" href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/" rel="noopener ugc nofollow" target="_blank">链接</a>)</li></ul><p id="4b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5。偏向</strong> <code class="du kl km kn js b"><strong class="ih hj">kubectl apply --filename</strong></code> <strong class="ih hj">而不是备选方案</strong></p><p id="be39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du kl km kn js b">kubectl create namespace/${WORKING_DIR}</code>很容易获得快速响应，但是，在几个这样的命令之后，您可能想知道您是如何到达当前状态的——更重要的是——如何重新创建这个状态。我鼓励你创建YAML文件来描述你的资源，而不是等效的<code class="du kl km kn js b">kub ectl create</code>命令。</p><p id="0fee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我鼓励您熟悉*优秀*的Kubernetes API文档(<a class="ae jd" href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/" rel="noopener ugc nofollow" target="_blank">链接</a>、<a class="ae jd" href="https://kubernetes.io/docs/reference/" rel="noopener ugc nofollow" target="_blank">链接</a>和<a class="ae jd" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/" rel="noopener ugc nofollow" target="_blank"> 1.10 </a>)，这些文档详尽、准确且易于浏览(也许是最完美的文档！？).但是，即使有了这个强大的工具，有时将一个为您工作的<code class="du kl km kn js b">kubectl</code>命令转换成YAML还是有点困难。它不是:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="2660" class="jw jx hi js b fi jy jz l ka kb">kubectl get deployment/${MY_DEPLOYMENT} --output=yaml<br/>kubectl get service/${MY_SERVICE} --output=yaml<br/>kubectl get anything/${MY_ANYTHING} --output=yaml</span></pre><p id="3a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您愿意，可以将结果通过管道传输到一个文件中，但是要将这些结果作为等价(！idspnonenote)的基础。)YAML文件。您需要删除任何实例引用。</p><p id="1346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你完成了<code class="du kl km kn js b">masterpiece.yaml</code>，我鼓励你总是<code class="du kl km kn js b">apply</code>做最初的创建，<code class="du kl km kn js b">apply</code>做任何后续的更新，如果你必须的话<code class="du kl km kn js b">delete</code>。就是这样！</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="332b" class="jw jx hi js b fi jy jz l ka kb">kubectl apply --filename=masterpiece.yaml<br/>kubectl delete --filename=masterpiece.yaml</span></pre><p id="cec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf">小见识</em>:你不需要为了部署而把YAML文件拉到本地。您也可以为<code class="du kl km kn js b">kubectl apply --filename</code>提供URL，只要任何依赖文件都是本地引用，部署就会工作。</p><p id="0eb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf">小见识</em>:我只在Kubernetes-land看到过这种用法，但这是一种合法的做法，你可以用<code class="du kl km kn js b">---</code>和<code class="du kl km kn js b">...</code>文件分隔符将多个YAMLs文件合并成一个YAML文件。因此，与命名空间YAML、部署YAML和服务YAML不同，您可能有一个将所有三个文件合并为一个的大型YAML。</p><figure class="jn jo jp jq fd ku"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="03d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是有效的YAML(将其复制并粘贴到例如<a class="ae jd" href="http://www.yamllint.com/" rel="noopener ugc nofollow" target="_blank"> YAML林特</a>)。这是无效的，因为每个规范都是不完整的，但是如果每个规范都是完整的，这是非常好的YAML，也是保持资源关联的好方法。</p><p id="969c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个批评见#B (Xsonnet)。</p><p id="7148" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6。使用部署</p><p id="5532" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>中有很多力量，我的指导是:始终使用部署，每时每刻。即使你正在部署你的第一个单人吊舱<code class="du kl km kn js b">nginx</code>。部署是“头等舱”旅行，以蔻驰的价格来说，你可以进入滚动部署，你犯了一个错误，重新<code class="du kl km kn js b">apply</code>和Kubernetes负责杀死顽皮的豆荚，并用表现良好的豆荚替换它们。</p><p id="b85c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 7。负载平衡器和入口</strong></p><p id="e11e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些造成了混乱。在我看来(我可能错了)，当我使用<code class="du kl km kn js b">--type=LoadBalancer</code>创建服务时，我想要|得到一个网络LB。如果我想要HTTP/S(第7级)负载平衡，我需要创建一个入口。Ingress是一个令人困惑的Kubernetes资源。简单来说，L7==Ingress(结果是大量的配置能力)。</p><p id="8316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes引擎将入口资源显示为GCE HTTP/S负载平衡器。Christopher Grant在他的文章中很好地揭开了入口的神秘面纱(这里的<a class="ae jd" rel="noopener" href="/google-cloud/global-ingress-in-practice-on-google-container-engine-part-1-discussion-ccc1e5b27bd0"/>和这里的<a class="ae jd" rel="noopener" href="/google-cloud/global-ingress-in-practice-on-google-container-engine-part-2-demo-cf587765702"/>)。</p><p id="9356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 8。节点端口</strong></p><p id="3816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我没有(从来没有？)直接创建了一个ClusterIP。我对Kubernetes做了一些事情，导致服务被ClusterIPs公开。主要是(！)我创建了节点端口，或者我做了一些使用节点端口的事情(例如创建入口资源)。</p><p id="ba76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点端口与Kubernetes节点相关联，它们是端口。它们提供的强大功能是集群中的每个节点(或者是这个节点池？<code class="du kl km kn js b">[[TODO]]</code>)在同一个(节点)端口上公开同一个服务。</p><p id="4181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我创建一个在节点端口<code class="du kl km kn js b">X</code>上公开的服务，我可以保证，如果我在集群中的*任何*节点上访问该端口，我将访问该服务。这构成了Kubernetes负载平衡功能的基础，因为集群能够将传入的服务请求路由到任何节点上的这个端口。</p><p id="36ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud SDK(又名<code class="du kl km kn js b">gcloud</code>)包括一个<code class="du kl km kn js b">ssh</code>客户端，可以轻松连接到计算引擎虚拟机(您应该记得是Kubernetes集群节点)。<code class="du kl km kn js b">ssh</code>客户端包括端口转发功能。因此，如果我们想要连接到一个Kubernetes服务，并且我们可以查找该服务的节点端口，那么我们可以很容易地(！)通过端口转发(使用<code class="du kl km kn js b">gcloud</code>或任何<code class="du kl km kn js b">ssh</code>客户端)到任何节点上端口，端口转发到服务。</p><p id="daf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子使用<code class="du kl km kn js b">kubectl</code>来抓取集群中的第0个节点。Kubernetes引擎节点名称与计算引擎虚拟机名称相同。给定一个在名为<code class="du kl km kn js b">${MY_NAMESPACE}</code>的名称空间中名为<code class="du kl km kn js b">${MY_SERVICE}</code>的服务，我们确定服务的节点端口。然后，我们切换到<code class="du kl km kn js b">gcloud</code>，并使用其内置的<code class="du kl km kn js b">ssh</code>进行端口转发(使用<code class="du kl km kn js b">--ssh-flag="-L XXXX:localhost:XXXX</code>)。</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="a36f" class="jw jx hi js b fi jy jz l ka kb">NODE_HOST=$(\<br/>  kubectl get nodes \<br/>  --output=jsonpath="{.items[0].metadata.name}")</span><span id="7b76" class="jw jx hi js b fi kx jz l ka kb">NODE_PORT=$(\<br/>  kubectl get services/${MY_SERVICE} \<br/>  --namespace=${MY_NAMESPACE} \<br/>  --output=jsonpath="{.spec.ports[0].nodePort}")</span><span id="db83" class="jw jx hi js b fi kx jz l ka kb">echo ${NODE_PORT}</span><span id="5c2d" class="jw jx hi js b fi kx jz l ka kb">gcloud compute ssh ${NODE_HOST} \<br/>--ssh-flag="-L ${NODE_PORT}:localhost:${NODE_PORT}" \<br/>--project=${YOUR_PROJECT}</span></pre><p id="51b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有什么厉害的？现在，您可以像在本地一样访问服务，而不必在防火墙上打孔。</p><p id="0a20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点端口是高编号端口(~30，000–32，767)。</p><p id="d4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 9。黑客</strong> <code class="du kl km kn js b"><strong class="ih hj">kubectl</strong></code> <strong class="ih hj">使用JSON </strong></p><p id="488f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌的<a class="ae jd" href="https://cloud.google.com/sdk/docs/" rel="noopener ugc nofollow" target="_blank">云SDK </a>(又名<code class="du kl km kn js b">gcloud</code>)确实很优秀但是<code class="du kl km kn js b">kubectl</code> (Kubernetes CLI)更好(原文如此)。一个强大的功能是格式化和过滤输出。这允许以非编码(非API争论)的方式使用来自Kubernetes集群的信息来扩展脚本和其他工具。</p><p id="ba65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的Kubernetes资源状态都可以通过例如<code class="du kl km kn js b">kubectl get</code>(根据我的经验，它比<code class="du kl km kn js b">kubectl describe</code>)命令来访问。然后，剩下的就是在JSON的大海里捞针了。</p><p id="99a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">诀窍是:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="80e9" class="jw jx hi js b fi jy jz l ka kb">kubectl get [resource]/[resource-name] --output=JSON</span></pre><p id="fa6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后查看结果，开始构建查询字符串:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="ed95" class="jw jx hi js b fi jy jz l ka kb">kubectl get [resource]/[resource-name] --output=jsonpath=".items[*]"</span></pre><p id="1934" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并反复细化结果集，直到得到您所寻找的项目。这里有一个适用于任何集群的示例:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="2273" class="jw jx hi js b fi jy jz l ka kb">kubectl get nodes --output=json<br/>kubectl get nodes --output=jsonpath="{.items[*]}<br/>kubectl get nodes --output=jsonpath="{.items[0]}<br/>kubectl get nodes --output=jsonpath="{.items[0].metadata.name}</span></pre><p id="97aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，学习一种JSON解析工具并将该工具应用于所有JSON解析需求，这是一个很好的理由(也是*nix的宗旨)。在这种情况下，<code class="du kl km kn js b">jq</code>有没有合理的竞争对手？我想不会。</p><p id="6f84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加上<a class="ae jd" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>有一个优秀的游乐场(jqplay.org)。</p><p id="edcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">答:使用标签</strong></p><p id="6ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个漫长的过程，但是现在所有的软件服务都支持任意标记资源的概念(通常是键值对)。其强大的原因在于，这种元数据提供了一种开放式的、完全由用户定义的资源查询方式。Kubernetes固有地使用这个原则；这是一种内在的能力，而不是一种事后想出来的|附加功能。</p><p id="e35d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes服务公开任意数量的Kubernetes Pods。服务不会公开名为“Henry”的pod或包含副本集的pod。相反，服务公开其标签符合服务规范中定义的标准的pod，这些标签当然是用户定义的。</p><figure class="jn jo jp jq fd ku"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="75f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>在上面的例子中，我们使用了一个名为<code class="du kl km kn js b">project-x</code>的名称空间，这个名称空间规范出现在<code class="du kl km kn js b">Namespace</code>(当它被创建时)、<code class="du kl km kn js b">Deployment</code>中以定义部署存在的位置，并且出现在<code class="du kl km kn js b">Service</code>中。<code class="du kl km kn js b">Deployment</code>(称为<code class="du kl km kn js b">microservice-y</code>)将创建一个副本集(此处隐式指定；这是部署所创造的)将维持100个吊舱。每个Pod将有一个标签<code class="du kl km kn js b">app: publicname-a</code>，并包含一个基于名为<code class="du kl km kn js b">image-grpc-proxy</code>的图像的名为<code class="du kl km kn js b">grpc-proxy</code>的容器。这个服务叫做<code class="du kl km kn js b">service-p</code>。最重要的是，该服务选择(！)具有标签<code class="du kl km kn js b">app: publicname-a</code>的pod(仅在<code class="du kl km kn js b">project-x</code>名称空间中)。该服务将选择具有该标签(键:值)对的任何Pod(在<code class="du kl km kn js b">project-x</code>名称空间中),而不仅仅是在该部署中创建的那些Pod。该服务不通过pod的名称(基于部署名称)、其容器名称或容器图像名称来引用pod，只引用与pod相关联的标签。</p><p id="626f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是一个好的做法，但它证明了这一点。如果您要运行一个类似于上面的配置，然后单独创建一个运行Nginx的Pod(在<code class="du kl km kn js b">project-x</code>名称空间中),然后您给它添加标签<code class="du kl km kn js b">app: publicname-a</code>,它将很快被合并到由<code class="du kl km kn js b">service-p</code>服务聚合的Pod集合中。如果您要删除由服务聚合的任何Pod的标签，该Pod将停止被包含。</p><p id="c6c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此功能通过滚动更新来体现，其中部署创建新的副本集，该副本集包括版本X '的新单元，不同于版本X的副本集和单元。服务可被定义为展示跨这两个版本运行的单元的交集，因为它不是根据副本集或特定单元来定义的，而是通过用户定义的标签(“选择器”)来定义的，这些标签是在创建单元时由您应用的。</p><p id="3a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那是很厉害的！</p><p id="4e57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b .使用Jsonnet，可能是Ksonnet </p><p id="0fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个挑战同所有(！？)结构化格式(YAML、JSON、XML、CSV-)是自引用和变量。当您为Kubernetes部署制定规格时，您会很容易遇到这个问题。您会发现自己在使用文字(例如，用于图像名称和摘要),甚至在受人尊敬的部署中，也在使用重复的名称和选择器。</p><p id="31d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你把自己局限于YAML和JSON，这些问题是没有解决办法的。谷歌创建了<a class="ae jd" href="http://jsonnet.org/" rel="noopener ugc nofollow" target="_blank"> Jsonnet </a>部分是为了解决这些问题。聪明的Heptio人用… <a class="ae jd" href="http://ksonnet.io" rel="noopener ugc nofollow" target="_blank"> Ksonnet </a>将Jsonnet扩展到了Kubernetes。</p><p id="6406" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两者都是解决上述问题(以及更多问题)的模板语言。我鼓励你考虑Jsonnet。正如我建议考虑使用jq一样，学习一次Jsonnet，并在使用JSON的任何地方应用它。Ksonnet是Kubernetes特有的—在我有限的(！)经验——我发现从这种特殊性中获得的好处不会被学习曲线所抵消。</p><p id="7bfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> C. YAML或JSON </strong></p><p id="a70e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes对YAML和JSON几乎一视同仁。就我个人而言，我发现YAML更适合配置文件，因为YAML比JSON更简洁。虽然我觉得YAML更难写。</p><p id="6bd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，说到理解结构和解析，我更喜欢<code class="du kl km kn js b">--output=JSON</code>，也因为<code class="du kl km kn js b">--output=JSONPATH</code>。我是Golang的超级粉丝，但围棋模板并不直观，我也不使用它们。</p><p id="1c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">次要观点:YAML是JSON的超集(<a class="ae jd" href="https://en.wikipedia.org/wiki/JSON#YAML" rel="noopener ugc nofollow" target="_blank">链接</a>)……等等！什么？</p><p id="9563" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> D .向下狗API和配置</strong></p><p id="e322" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“向下API”给了它一个正确但同样令人困惑的名字，它是Kubernetes中的一个设施，通过它，pod可以获得它们周围的集群感。我假设，正常的流程是从外部世界向上进入Pod和它的容器，但是有时它对容器(！)以获得关于其环境的信息，例如其节点名称|IP、Pod的名称(空间)|IP。</p><p id="3b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向下的API值通过环境变量呈现给容器。环境变量用于(和其他地方一样)向容器提供配置或其他状态。使用环境变量和向下API实现的一个非常好的结果(有一个小警告)是容器保持与Kubernetes的解耦。</p><p id="92c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我的好友Sal Rashid的一个例子，他使用向下API来收集节点和Pod状态，并将其呈现给用户:</p><p id="ede2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/salrashid123/istio_helloworld/blob/master/all-istio.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/salrashid 123/istio _ hello world/blob/master/all-istio . YAML</a></p><p id="24de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参阅从第76、80、84、88行开始的部分，其中Pod名称、名称空间、IP和节点名称在运行时由向下API提供给名为<code class="du kl km kn js b">myapp-container</code>的容器。</p><p id="cbe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向下API是收集容器数据的唯一实用的方法。所以更多的是“唯一的实践”而不是“最佳实践”。</p><p id="834a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的许多帖子中，当我为Kubernetes构建解决方案时，我在本地和容器外测试流程，然后在容器中(指定环境变量)，然后在Kubernetes集群上。容器化的机制是一致的(见下文),即使一个通常运行在Docker上，一个运行在Kubernetes上。</p><p id="1606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我最近写的一篇关于Google的容器优化操作系统的文章中，我演示了一个容器在Docker下本地运行，在容器优化操作系统下远程运行，然后在Kubernetes上运行。</p><p id="0049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是在本地Docker下运行的。注意环境变量(<code class="du kl km kn js b">--env</code>)是如何被用来为<code class="du kl km kn js b">gcr.io/${PROJECT}/datastore</code>提供配置的。</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="d795" class="jw jx hi js b fi jy jz l ka kb">docker run \<br/>--interactive \<br/>--tty \<br/>--publish=127.0.0.1:8080:8080 \<br/>--env=GCLOUD_DATASET_ID=${PROJECT} \<br/>--env=GOOGLE_APPLICATION_CREDENTIALS=/tmp/${ROBOT}.key.json \<br/>--volume=$PWD/${ROBOT}.key.json:/tmp/${ROBOT}.key.json \<br/>gcr.io/${PROJECT}/datastore</span></pre><p id="89e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是将部署包装到容器优化的VM的创建中的相同结果。这次检查提供给<code class="du kl km kn js b">container-env</code>标志的值:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="d7f9" class="jw jx hi js b fi jy jz l ka kb">gcloud beta compute instances create-with-container ${INSTANCE} \<br/>--zone=${ZONE} \<br/>--image-family=cos-stable \<br/>--image-project=cos-cloud \<br/>--container-image=gcr.io/${PROJECT}/${IMAGE}@${DIGEST} \<br/>--container-restart-policy=always \<br/>--container-env=\<br/>GCLOUD_DATASET_ID=${PROJECT},\<br/>GOOGLE_APPLICATION_CREDENTIALS=/tmp/${ROBOT}.key.json \<br/>--container-mount-host-path=\<br/>mount-path=/tmp,\<br/>host-path=/tmp,\<br/>mode=rw \<br/>--project=${PROJECT}</span></pre><p id="caa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，这是Kubernetes在YAML的部署片段:</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="1a48" class="jw jx hi js b fi jy jz l ka kb">containers:<br/>      - name: datastore<br/>        image: gcr.io/${PROJECT}/datastore<br/>        imagePullPolicy: Always<br/>        volumeMounts:<br/>          - name: datastore<br/>            mountPath: /var/secrets/google<br/>        env:<br/>        - name: GOOGLE_APPLICATION_CREDENTIALS<br/>          value: /var/secrets/google/datastore.key.json<br/>        - name: GCLOUD_DATASET_ID<br/>          value: ${PROJECT}<br/>        ports:<br/>        - name: http<br/>          containerPort: 8080</span></pre><p id="58c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现在配置中使用环境变量是相当笨拙的。没有明确的特定环境变量与特定流程的有意绑定，当出现问题时，您只会意识到它们没有正确配置。在非容器化的环境中，很容易想象环境变量会发生冲突，尽管这对于容器来说是个小问题，因为如上所述，我们是在为特定的容器显式设置值。</p><p id="437d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，以这种方式使用环境变量是最佳实践。</p><p id="5f2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">边斗和为什么豆荚不总是集装箱的同义词</strong></p><blockquote class="kc kd ke"><p id="7a3c" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated">5 cl干邑<br/> 2 cl三秒<br/> 2 cl柠檬汁<br/>准备将所有原料倒入加满冰块的调酒器。摇匀后滤入鸡尾酒杯。</p></blockquote><p id="8e63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多时候，您会创建包含单个容器的Kubernetes Pods，并且您会奇怪为什么当您只需要一个容器时，会有Pod的所有开销。pod更类似于可以运行许多容器的主机环境。很多时候，您会考虑在一个Pod中运行多个容器…</p><p id="85e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…并且只有一次你应该:-)</p><p id="c856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能不止一次，但让我们坚持一次。</p><p id="ea56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反模式(不要这样做)是设想您当前的配置(让我们假设一个web服务器和一个数据库后端),并将两者都塞进一个Pod中。这不是一个好主意，除非每个web服务器实例必须不可分割地、永远地连接到一个特定的数据库实例。这不太可能。</p><p id="299b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更有可能的是，您的web服务器实例应该根据<em class="kf">聚合</em>前端负载进行扩展，而您的数据库实例应该根据它们处理前端负载的<em class="kf">聚合</em>能力进行扩展(独立于此)。当您看到聚合时，请考虑服务，当您考虑服务时，请尝试设想任意数量的pod(因为这关系到您的账单，但对于大多数其他目的，只要数量刚好满足工作负载，需要多少pod并不重要)。</p><p id="03ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么时候你应该考虑每箱多个集装箱？只有当您希望补充、扩展或丰富容器中主Pod的行为时，这种做法才有意义。让我们回顾一下上面的web服务器和数据库示例。在这个场景中，希望您现在确信您将部署两个服务(和两个部署)，一个用于前端，一个用于后端。</p><p id="7765" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给web服务器实例本身配备一个反向代理是一种很好的常见做法。通常这可能是<a class="ae jd" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>或<a class="ae jd" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>并且使用<a class="ae jd" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>变得越来越普遍(如果你正在寻找代理，我建议考虑Envoy；参见#F Istio)。即使你使用不同的网络服务器(例如Apache，<a class="ae jd" href="http://tomcat.apache.org/" rel="noopener ugc nofollow" target="_blank"> Tomcat </a> w/ Java等),反向代理也能提供一致性(我们只使用例如Envoy)。)，即使你混合了HTTP、<a class="ae jd" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>、Web Sockets等。交通。，即使您希望将一些流量导向您的网络服务器，将一些流量导向缓存(例如<a class="ae jd" href="https://varnish-cache.org/" rel="noopener ugc nofollow" target="_blank"> Varnish </a>)。</p><p id="59ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前面的所有场景中，使用“边车”模型是有意义的。在这个模型中，主容器(您的web服务器)有辅助的、补充的容器(Envoy代理、Varnish缓存等)。).这些必须紧密耦合到特定的web服务器实例*和*功能上，组合就是“单元”。</p><p id="d4da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很常见的是，日志、监控、跟踪和其他基础设施组件也是作为边柜交付的。这里的一个动机是分离关注点。为开发人员提供一致的需求，以产生“可管理”的代码，并为SRE提供选择首选工具的灵活性，因为他们知道所有代码都将记录日志、发出指标、可跟踪、一致地应用授权等。这是一种形成服务网格基础的模式(参见#F Istio)。这是最后的最佳做法，尽管是新生的做法。</p><p id="b158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> F .使用</strong><a class="ae jd" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank">T3】IstioT5】</a></p><p id="cd82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">小心使用<a class="ae jd" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>。</p><p id="04f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Istio(和其他服务网格)是相对新生的技术，诞生于大规模运行容器的公司(包括谷歌)。服务网格通常在每个集群的每个名称空间的每个部署中的每个Pod中放置一个通用代理(在Istio的例子中是Envoy)。</p><p id="b01a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是一个一致的管理基础，允许管理(我们今天将使用Stackdriver Trace，但有迁移到Jaeger的计划，我们已经推出了我们的Prometheus monitoring)和控制服务(我们知道我们所有的服务都是安全的，我们将10%的流量路由到服务A、B和C的canary版本)的松散耦合。</p><p id="5315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我建议“小心”，因为这些技术是新的，有粗糙的边缘，并且正在迅速发展。但是，该方法为您提供的优势(灵活性、敏捷性、面向未来)可能远远超过成本。最重要的是，使用服务网格作为Kubernetes的模型，即使您还不想采用服务网格技术。</p><p id="dc0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf">就这些了，乡亲们！</em></p></div></div>    
</body>
</html>