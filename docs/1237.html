<html>
<head>
<title>GCP Solving MySQL HA Replication Lag</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP解决MySQL高可用性复制延迟</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/gcp-solving-mysql-ha-replication-lag-4f005779a32c?source=collection_archive---------0-----------------------#2019-12-30">https://medium.com/google-cloud/gcp-solving-mysql-ha-replication-lag-4f005779a32c?source=collection_archive---------0-----------------------#2019-12-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f8a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；DR </strong>:该解决方案侧重于使用多区域磁盘(称为区域磁盘)来实现持久的MySQL HA复制。这是基于GCE的<a class="ae jd" href="https://cloud.google.com/sql/docs/mysql/high-availability" rel="noopener ugc nofollow" target="_blank"> CloudSQL复制技术</a>的实现。</p><h1 id="fc8f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">问题陈述</h1><p id="a629" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当持久性开启(即sync_binlog = 1)且平均负载大于约300 tps(每秒事务数)时，公共云(如GCP)开始显示MySQL副本实例的复制延迟。然而，裸机硬件在大约300 tps的极限下没有显示出滞后。<br/> <strong class="ih hj">注意</strong> : 300 TPS的限制可能因事务大小和类型、单线程或多线程复制等而异。</p><p id="9356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">次要目标—在30秒内实现故障切换。</p><h1 id="5b2d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">假设</h1><p id="4722" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Mysql版本:5.7.10+ <br/>复制类型:异步<br/>持久性:必需(即sync_binlog = 1) <br/>故障转移时间:30秒以下</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="ac64" class="je jf hi bd jg jh ko jj jk jl kp jn jo jp kq jr js jt kr jv jw jx ks jz ka kb bi translated">理解问题</h1><p id="76ce" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj">为什么需要耐久性？</strong></p><p id="a95d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据库管理员需要在复制时具有持久性，以确保副本中数据的一致性和稳定性。此外，它使故障切换更快更容易，因为除了告诉副本服务器停止复制之外，不需要对副本服务器进行任何更改。</p><p id="cc87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么导致了持久复制的滞后？</strong></p><p id="0d00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复制滞后的根本原因是虚拟化增加了延迟。</p><p id="c67a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，由于多线程时mysql复制的无效性，这一问题变得更加突出。MySQL不能很好地使用多线程来在线程之间分配复制负载，并且经常求助于单个线程来完成大部分工作。</p><p id="ea5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为什么MASTER不滞后或者高延迟？</strong></p><p id="fe0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Master通过多个连接(线程)接收流量，并有机地写入数据库。换句话说，MySQL作为master使用多线程是有效的，但在复制时却不是这样。</p><p id="72bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除非主服务器处于半同步复制设置，否则它可能不会显示高延迟。即使半同步模式也仅确保事务被提交给至少一个复制品。因此，如果您从本地主服务器复制到(1)本地副本服务器。(2) gcp复本。主机不会显示额外的延迟。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="0770" class="je jf hi bd jg jh ko jj jk jl kp jn jo jp kq jr js jt kr jv jw jx ks jz ka kb bi translated">mysql复制延迟的解决方案</h1><p id="b6d5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在上面的部分中，我们已经确定MySQL中的复制延迟是由于(1)虚拟化导致的延迟(2)MySQL软件在复制时的无效性</p><p id="2ccb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们可以通过使用GCP的<a class="ae jd" href="https://cloud.google.com/compute/docs/disks/#repds" rel="noopener ugc nofollow" target="_blank">区域持久磁盘</a>来消除(2)。这些圆盘在给定的区域是双带的。因此，在其上写入的任何内容都会同时写入两个区域。</p><p id="e102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">部署图</strong></p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/cd784fc426d1dd23bd131da600419b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQTThK2znE9UtCkxOJbygg.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">带区域ssd的MySQL Master (HA)</figcaption></figure><ol class=""><li id="86a3" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">创建GCP内部负载平衡器是为了将所有流量发送到umig1(非托管实例组1)，并且仅在故障转移时发送到umig2。</li><li id="e6f3" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">虚拟机DB zn1和DB zn2使用相同的启动映像与mysql一起安装。(更多细节见下一节)。</li><li id="26c5" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">每个虚拟机都被添加到单独的非托管实例组(umig)中。</li><li id="f9c9" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">区域SSD是mysql用来写数据和日志的磁盘。在给定时间，只有一个虚拟机可以以读/写模式连接它。</li></ol></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="3f32" class="je jf hi bd jg jh ko jj jk jl kp jn jo jp kq jr js jt kr jv jw jx ks jz ka kb bi translated">设置基于区域磁盘的方法的详细信息</h1><ol class=""><li id="545f" class="lj lk hi ih b ii kc im kd iq lx iu ly iy lz jc lo lp lq lr bi translated">创建金启动磁盘。<br/> a .创建一个新的虚拟机并通过ssh连接到虚拟机<br/> b .安装软件mysql(以及任何监控软件，如果需要的话)。c .在my.cnf文件中配置mysql使用挂载的磁盘路径。<br/> <code class="du ma mb mc md b">datadir = /mnt/attached-disk/msql/data<br/>log-bin = /mnt/attached-disk/msql/log/repl</code> <br/> d .禁用mysql服务自动启动<br/> <code class="du ma mb mc md b">sudo systemctl disable mysqld<br/></code> e .关闭虚拟机<br/> f .创建启动盘镜像</li><li id="3535" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">创建区域pd-ssd。</li><li id="e1fe" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">使用元数据“attached_disk_name= <name of="" regional="" pd-ssd="">”创建主虚拟机和备用虚拟机。<br/>注意:将所有计算引擎API权限授予虚拟机。</name></li><li id="dfc0" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">登录到上述两个虚拟机，并复制failover.sh脚本(如下)。</li><li id="0515" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">在主实例中执行以上failover.sh以开始服务mysql。</li></ol><p id="e3bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> failover.sh </strong></p><pre class="ku kv kw kx fd me md mf mg aw mh bi"><span id="ad59" class="mi jf hi md b fi mj mk l ml mm">#### Variables<br/>export other_vm_name="&lt;other instance name primary/standby&gt;"<br/>export other_vm_zone="us-central1-a"<br/>export mysql_root_password="&lt;password&gt;"<br/>#### Variables END</span><span id="b513" class="mi jf hi md b fi mn mk l ml mm">echo $(date) " starting failover #############"<br/>gcloud compute ssh $other_vm_name --zone $other_vm_zone --quiet -- -o ConnectTimeout=10 -t "sudo systemctl stop mysqld"<br/>echo $(date) " stopped current master ##########"</span><span id="8798" class="mi jf hi md b fi mn mk l ml mm">export inst_zone=$(curl "http://metadata.google.internal/computeMetadata/v1/instance/zone" -H "Metadata-Flavor: Google" |  awk '{split($0,a,"/"); print a[4]}')<br/>export inst_name=$(curl "http://metadata.google.internal/computeMetadata/v1/instance/name" -H "Metadata-Flavor: Google")<br/>export attached_disk_name=$(curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/attached_disk_name" -H "Metadata-Flavor: Google")</span><span id="60ff" class="mi jf hi md b fi mn mk l ml mm">gcloud compute instances attach-disk $inst_name --zone "$inst_zone" --disk "$attached_disk_name" --device-name "$attached_disk_name" --mode rw --force-attach --disk-scope "regional"</span><span id="e1cc" class="mi jf hi md b fi mn mk l ml mm">echo $(date) " attached regional disks ##########"</span><span id="34f8" class="mi jf hi md b fi mn mk l ml mm">sudo mount -o discard,defaults /dev/sdb /mnt/attached-disk</span><span id="c1b3" class="mi jf hi md b fi mn mk l ml mm">echo $(date) " mounted regional disks ##########"</span><span id="930b" class="mi jf hi md b fi mn mk l ml mm">sudo systemctl start mysqld</span><span id="d514" class="mi jf hi md b fi mn mk l ml mm">echo $(date) " started mysql ##########"<br/>echo $(date) " failover complete ##########"</span><span id="cb95" class="mi jf hi md b fi mn mk l ml mm">mysql -uroot -p$mysql_root_password -e "show master status"</span></pre><h1 id="0589" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">执行故障转移</h1><p id="2164" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在备用虚拟机中执行<code class="du ma mb mc md b">failover.sh</code>。负载平衡器将自动检测和切换流量。</p><h1 id="b371" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">执行回切</h1><p id="1a6a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">从主虚拟机执行<code class="du ma mb mc md b">failover.sh</code>。负载平衡器将自动检测和切换流量。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="0fb5" class="je jf hi bd jg jh ko jj jk jl kp jn jo jp kq jr js jt kr jv jw jx ks jz ka kb bi translated">多区域部署</h1><p id="ae95" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">同样，可以部署多区域复制，以便DC和灾难恢复都高度可用。唯一的区别是，从DC到灾难恢复的复制必须是非持久性的，以弥补复制滞后。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mo"><img src="../Images/a59bae425f864d651365fb47766f6545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYaVOxgUF-6QasTylwpZBg.png"/></div></div></figure><p id="f8af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在该架构中需要考虑以下几点:</p><ol class=""><li id="fca7" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">迁移MySQL和实例的故障转移是本文的重点。因此，该图用相当简单的术语显示了所有其他方面。</li><li id="add2" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">每个数据库虚拟机位于不同的区域，即ZN[1–4]</li><li id="ad74" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">该图清楚地显示了这两个区域中的主服务器和备用服务器。主数据库和备用数据库之间没有复制。</li><li id="1989" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">待机将停止mysqld服务。在主节点(在相应区域中)发生故障之前，备用节点不会连接到区域ssd。</li><li id="d441" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">每个负载平衡器应该“仅在故障转移的情况下”向备用服务器发送流量。</li><li id="84bf" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">灾难恢复主节点(zn3)从DC主节点(zn1)进行非持久性复制。</li><li id="855d" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">从区域1到区域2的单向复制。因为region2的mysql是非持久的。</li><li id="d065" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">[可选]使用dns服务路由应用程序流量。</li><li id="8e36" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">[可选]如果配置了额外的读取副本，将使用分区ssd进行非持久复制。</li></ol><h1 id="d553" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">借助区域PD-SSD实现分区故障转移和故障回复</h1><p id="0107" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在事件主节点(DB zn1主节点)中，拓扑将更新如下。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mp"><img src="../Images/9c4d7a31e1396899de8c4a1a5aa425cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm22Ofqmwcfyg6jh1VKjJg.png"/></div></div></figure><p id="b82d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦检测到故障，脚本(如上的failover.sh)将需要执行以下步骤:</p><ol class=""><li id="d855" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">尝试优雅的失败。尝试停止主数据库(超时10秒)。</li><li id="9831" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">将区域pd-ssd强制连接到备用虚拟机。</li><li id="c7c5" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">启动备用的mysql服务。</li><li id="1d18" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">更改灾难恢复主服务器上的主服务器，以继续灾难恢复中的复制。</li></ol><p id="2151" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦步骤1、2和3完成。理想情况下，负载平衡器会自动检测备用实例是否正常，并开始向备用实例发送所有流量。</p><h1 id="5cd8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">添加多个读取副本</h1><p id="9936" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">多个读取副本(用于mysql性能)可以进一步添加到同一个设置中。通过添加独立的mysql节点进行不持久的复制。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="059b" class="je jf hi bd jg jh ko jj jk jl kp jn jo jp kq jr js jt kr jv jw jx ks jz ka kb bi translated">替代解决方案</h1><p id="d360" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在解决这个问题的过程中，我们发现了以下更多的解决方法。但所有这些都是通过调整mysql(应用层)复制设置实现的，因此每个都有一些缺点。</p><ol class=""><li id="5b8f" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated"><strong class="ih hj">半同步复制:</strong>可能以增加主设备延迟为代价解决复制延迟。这通常是不希望的。</li><li id="ebe6" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">关闭</strong><a class="ae jd" href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_log_slave_updates" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">log _ slave _ updates</strong></a><strong class="ih hj">:</strong>当副本也生成bin日志时，复制延迟通常会提高。消除bin日志，加快复制速度，直到达到700 tps的限制(几乎翻倍)。这可以在my.cnf中使用(log_slave_updates = OFF)来关闭。因此，灾难恢复中的任何读取副本也必须从主DC主机复制。</li><li id="f383" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">多线程复制:</strong>我们进行了尝试，通过sysbench生成的负载显示了很好的结果。然而，在真实负载下，它的性能并没有好到完全赶上复制延迟。</li></ol></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="c382" class="je jf hi bd jg jh ko jj jk jl kp jn jo jp kq jr js jt kr jv jw jx ks jz ka kb bi translated">结论</h1><p id="9f64" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">使用区域性持久磁盘是创建高可用性数据库基础设施的最佳选择。给出小于30秒的故障转移时间。</p><p id="6a85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。如果你想看到terraform或shell脚本来启动整个基础设施，请回复这个帖子并告诉我。我可以写第2部分给出完整的端到端代码。</p></div></div>    
</body>
</html>