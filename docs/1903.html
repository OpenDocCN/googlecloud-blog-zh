<html>
<head>
<title>Using Cloud Pub/Sub on Node.js from Elm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elm的Node.js上使用云发布/订阅</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-cloud-pub-sub-on-node-js-from-elm-2a769731c097?source=collection_archive---------0-----------------------#2021-06-17">https://medium.com/google-cloud/using-cloud-pub-sub-on-node-js-from-elm-2a769731c097?source=collection_archive---------0-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/09f438f670a790be53cbc7b0513dbd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*8D8MqXpumqfLKXuiPnKD1w.png"/></div></figure><figure class="in io ip iq fd ij er es paragraph-image"><div class="er es im"><img src="../Images/bc6224cb61869718a0e8dcd576746a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*qk_LpjAlkjXOY-ci"/></div></figure><figure class="in io ip iq fd ij er es paragraph-image"><div class="er es ir"><img src="../Images/210c0e1ded8606a4f39757d95172d473.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*1Dq0AeMea7LH3tQK"/></div></figure><h1 id="f639" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">为什么是榆树？</h1><p id="33f8" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><a class="ae ko" href="https://elm-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elm </a>是一种纯粹的函数式语言，语法类似于<a class="ae ko" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>，但是针对编写前端web应用程序进行了优化。它有一个transpiler，可以将Elm模块转换成JavaScript，还有一个非常小而快速的运行时，可以与浏览器交互。</p><p id="0b64" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">Elm相当稳固地定位为前端工具，为浏览器开发动态的单页面应用程序。但是在<a class="ae ko" href="https://www.npmjs.com/package/elm-node" rel="noopener ugc nofollow" target="_blank">榆树节点包</a>的帮助下，更多的事情成为可能！</p><h1 id="7b85" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">警告</h1><p id="229d" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">本文将带您构建一个在Node.js中运行的Elm应用程序，并使用Node.js发布/订阅库与<a class="ae ko" href="https://cloud.google.com/pubsub" rel="noopener ugc nofollow" target="_blank"> Google Cloud发布/订阅</a>通信。请注意<strong class="js hj">我们不建议此时为您的生产工作执行此操作</strong>；这篇文章主要是为了好奇！</p><h1 id="8710" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">为什么是“纯功能性”？</h1><p id="e301" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们很多人都熟悉基本的<a class="ae ko" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数模式</a>，比如在JavaScript中将lambda函数传递给<em class="ku"> map() </em>。</p><p id="2585" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/Purely_functional_programming" rel="noopener ugc nofollow" target="_blank"> <strong class="js hj">纯函数式</strong> </a>指的是以声明的方式描述你想要弄清楚的东西的程序。大多数程序都是以命令的方式编写的，也就是说，作为程序员，你告诉计算机采取什么步骤，以什么顺序，并管理程序的状态。这给程序员带来了很大的负担，因为他们必须经常考虑如何维护状态的一致性，以及在处理未知副作用带来的意外错误时可能会出现什么问题。</p><p id="c5a9" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">JavaScript工具已经被开发出来，至少可以帮助解决状态问题，比如<a class="ae ko" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>，其模型<a class="ae ko" href="https://redux.js.org/understanding/history-and-design/prior-art#elm" rel="noopener ugc nofollow" target="_blank">受到了Elm </a>的启发。Redux允许您将程序的状态声明为不可变的结构，并使用mutators进行更新。然而，许多事情在运行时仍然可能出错，因为编译器没有帮助你理解逻辑中可能的流程。</p><p id="0885" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">真正纯粹的函数式语言没有流控制。不需要运行任何步骤，因为你的程序基本上是一个数学方程，编译器能够完全理解它，并在编译时捕捉大多数逻辑错误。事实上，甚至可以<a class="ae ko" href="https://www.cs.princeton.edu/~dpw/courses/cos326-12/notes/reasoning.php" rel="noopener ugc nofollow" target="_blank">写关于纯函数程序的证明</a>。</p><h1 id="559f" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">榆树…在节点上？</h1><p id="9442" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">因为Elm只是一个transpiler，所以也可以使用Node.js运行时而不是浏览器来运行结果代码。这使您能够使用npm/yarn中所有现有的节点兼容库来构建非常轻量级的服务器进程，同时在Elm中运行尽可能多的应用程序。Elm没有副作用也意味着许多逻辑和数据结构模块可以在客户机和服务器之间共享。</p><p id="0f25" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">本文将带您构建一个运行在Node.js中的Elm应用程序，并使用<a class="ae ko" href="https://github.com/googleapis/nodejs-pubsub/" rel="noopener ugc nofollow" target="_blank"> Node.js发布/订阅库</a>与<a class="ae ko" href="https://cloud.google.com/pubsub" rel="noopener ugc nofollow" target="_blank"> Google Cloud发布/订阅库</a>进行通信。</p><blockquote class="kv kw kx"><p id="2c5a" class="jq jr ku js b jt kp jv jw jx kq jz ka ky kr kd ke kz ks kh ki la kt kl km kn hb bi translated"><strong class="js hj">我的“使用Pub/Sub From”系列文章:<br/> </strong> <a class="ae ko" rel="noopener" href="/google-cloud/using-cloud-pub-sub-from-kotlin-d501f7d65e24">使用Kotlin的Cloud Pub/Sub</a><br/><a class="ae ko" rel="noopener" href="/google-cloud/using-cloud-pub-sub-on-node-js-from-kotlin-js-46ad79739bbf">使用Kotlin/JS的Node.js上的Cloud Pub/Sub</a></p><p id="a907" class="jq jr ku js b jt kp jv jw jx kq jz ka ky kr kd ke kz ks kh ki la kt kl km kn hb bi translated"><strong class="js hj">也感兴趣:</strong> <br/> <a class="ae ko" rel="noopener" href="/google-cloud/things-i-wish-i-knew-about-google-cloud-pub-sub-852fac1ffbc6">我希望了解的关于谷歌云的事情发布/订阅:第1部分</a></p></blockquote><h1 id="c403" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">项目设置</h1><p id="2756" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">首先安装一个最新版本的<a class="ae ko" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。(或者使用<a class="ae ko" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank"> nvm </a>！)</p><p id="7352" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">您还需要Elm和elm-node的命令，所以要全局安装它们:</p><pre class="in io ip iq fd lb lc ld le aw lf bi"><span id="b458" class="lg it hi lc b fi lh li l lj lk">npm install -g elm elm-node</span></pre><p id="931d" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">然后，您可以创建一个elm节点项目:</p><pre class="in io ip iq fd lb lc ld le aw lf bi"><span id="e72e" class="lg it hi lc b fi lh li l lj lk">elm init<br/>elm-node --example-elm &gt; src/Main.elm<br/>elm-node --example-js &gt; src/index.js<br/>elm-node --js src/index.js src/Main.elm</span></pre><p id="e41d" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">马上发现生成的样例代码中有一个错误——<strong class="js hj">index . js</strong>需要引用<em class="ku"> Elm。主</em>，非<em class="ku">榆。MainWithJs </em>。这些类型的错误可能会在您尝试时得到修复。</p><p id="1f23" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">生成的程序非常简单。一些程序声明是在Elm中进行的，包括一个与JavaScript对话的<strong class="js hj">端口</strong>。JavaScript代码然后订阅端口并响应调用。</p><h1 id="0ecf" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">应用程序设计</h1><p id="0cd8" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">因为Elm和JavaScript跨两种非常不同的编码接口，我们需要考虑它们将如何通信。《T2榆树指南》详细讨论了这一点。建议本质上是尽量避免通过管道将每个JavaScript调用传递给Elm。而是做一个在Elm中有意义的接口。这也有助于Elm/JavaScript转换，它依赖于传递不比JSON更复杂的东西。(没有对象句柄什么的。)</p><p id="288f" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">对于这个非常简单的例子，我选择向Elm公开一个接口，让Elm代码请求发送或确认消息，然后能够以事件驱动的方式接收消息。对于一个实际的应用程序，您可能需要更复杂的东西，比如传递数字或JSON来引用特定的主题或订阅，并在JavaScript端缓存这些内容。</p><p id="c479" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">Elm设计者的最终建议是在本机Elm中重写客户端库，但是考虑到节点发布/订阅库的大小和复杂性，这在目前可能是不可行的。所以我们要用端口！</p><h1 id="9496" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">端口定义</h1><p id="3157" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们必须从定义我们的端口开始。为了定义我们的端口，我们必须首先决定在Elm端需要什么样的功能和接口。有多少将在Elm中声明，有多少将驻留在JavaScript/TypeScript中？</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="5c9e" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">让我们简单地把它拆开一点！</p><p id="fa8c" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">首先，我们有将要来回传递的消息的定义。在这个例子中，我们的消息有效负载将是一个简单的字符串，所以<em class="ku"> MessageToSend </em>将只是<em class="ku">字符串</em>的别名。当接收消息时，我们还必须知道发布/订阅消息ID，因此<em class="ku"> MessageReceived </em>既有有效载荷又有ID。</p><p id="227e" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">端口本身基本上是可以在Elm和JavaScript之间传递的消息的声明。<em class="ku"> log </em>端口让我们打印日志消息，<em class="ku"> publish </em>让我们请求发送消息，<em class="ku"> receive </em>从JavaScript到Elm获取接收到的消息，<em class="ku"> ack </em>让我们确认发布/订阅消息。需要注意的一点是，我选择让参数<em class="ku">发布</em>一个<strong class="js hj">记录</strong>，而不仅仅是一个字符串。这是为了方便以后添加更多的参数，如果我们想要的话。</p><p id="f357" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">您可以看到从Elm到JavaScript的消息是返回类型<em class="ku"> Cmd msg </em>的函数。这是一个通用类型，它指定了Elm程序为了到达下一个状态而请求的命令。从JavaScript到Elm的消息使用<em class="ku">子消息</em>，这是一个返回类型<em class="ku">子消息</em>的函数。这意味着我们订阅了参数类型为<em class="ku"> MessageReceived </em>的消息，并将使用这些消息来触发状态更新。</p><h1 id="fe26" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Elm模型</h1><p id="29c1" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在我们已经定义了我们的端口，让我们定义我们的Elm端模型。</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="5f4e" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">在这种情况下，我们非常简单的例子是一次只发送这个句子中的一个单词(因此<em class="ku">发送</em>剩余要发送的内容，而<em class="ku">接收到的消息</em>表示我们已经收到的内容)。此外，我们在这里将<em class="ku"> Msg </em>定义为我们将用来触发状态更新的类型。在这种情况下，我们将收到的唯一消息是<em class="ku"> Received </em>，带有类型为<em class="ku"> MessageReceived </em>的参数。但是在更复杂的应用程序中可能还有其他的。</p><h1 id="6a34" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">榆树街</h1><p id="540a" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果这看起来更像一个数据结构而不是一个程序，你就不会错了！在榆树，他们是同一个。</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7afa" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">我们在这个Elm模块中导出的主符号是<em class="ku"> main </em>，它将是一个<em class="ku"> worker </em>程序(没有UI)。<em class="ku"> init </em>函数将指定初始状态。<em class="ku">订阅</em>功能会列出我们愿意接收的消息。并且<em class="ku">更新</em>将定义如何从接收到的消息中获得更新的状态，以及进一步的动作。</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="3338" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">这定义了<em class="ku"> init </em>函数，该函数返回一个<strong class="js hj">元组</strong>。这包括初始状态(<em class="ku">发送的</em>除了第一个字之外都有，而<em class="ku">收到的消息</em>还没有收到)以及接下来要采取的步骤。函数构建了一个以任何顺序执行的命令数组，可能是一次全部执行。注意，这些是我们上面的<strong class="js hj">端口</strong>。</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="582c" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">这个很简单！我们只是说我们能够接收消息类型<em class="ku"> Received </em>(上面定义为<em class="ku">消息</em>的一部分)。</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="5b36" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">这是Elm app中逻辑的核心。基本上，当Elm应用程序被传递时，type <em class="ku"> Received </em>带有一条消息(同样，如上所述)和一个先前的状态模型，我们将返回一个新的模型。该模型将更新<em class="ku">发送</em>比以前的模型少一个字；我们还会将新收到的单词添加到<em class="ku">已收到的消息</em>中。(注意这些更新不是就地完成的，但这是返回一个<em class="ku">新的</em>模型；因此，如果我们想要立即得到这些值，我们必须使用<strong class="js hj"> let </strong>。)最后，<em class="ku"> Cmd </em>批处理将打印出我们收到的内容，确认Pub/Sub中的消息，并可能发布下一个单词。(所有这些都可能以任何顺序同时发生。)如果没有剩下要发送的内容，则不会发出进一步的命令。</p><h1 id="1fef" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">运行应用程序</h1><p id="d7cf" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">毫无疑问，您的流程在这里会有所不同，但是对于完整的示例，我已经创建了一个<strong class="js hj"> <em class="ku"> npm run </em> </strong>脚本，您可以使用它来启动它。您应该会看到类似这样的内容:</p><pre class="in io ip iq fd lb lc ld le aw lf bi"><span id="c012" class="lg it hi lc b fi lh li l lj lk">&gt; npm run run<br/>[…]<br/>Use Ctrl+C to exit.<br/>Elm starting Pub/Sub Elm test<br/>JS publishing: Mary<br/>JS: received: 1 : Mary<br/>Elm received so far: ‘Mary’<br/>JS publishing: had<br/>JS acking: 1<br/>JS: received: 2 : had<br/>Elm received so far: ‘Mary had’<br/>[…etc…]</span></pre><p id="613f" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">请注意，因为我们的应用程序是按顺序发布消息的，所以最终的消息字符串将总是有序的。对读者来说，一个很好的练习是让它一次发布多条消息(每个单词一条)，你可以看到它们可能是无序的。从那里开始，你可以把它们按顺序重新组装起来，等等。</p><h1 id="8e8e" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">后续步骤</h1><p id="d4b3" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">查看在发布/订阅模拟器上运行的完整工作示例:</p><p id="e5da" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated"><a class="ae ko" href="https://github.com/feywind/elm-node-pubsub" rel="noopener ugc nofollow" target="_blank">https://github.com/feywind/elm-node-pubsub</a></p><p id="921f" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">用Node.js在服务器端用过Elm吗？你觉得这很有趣并希望听到更多吗？关于Elm on Google Cloud Platform，请随时对这篇文章或您觉得有趣/有前途的事情发表评论！</p></div></div>    
</body>
</html>