<html>
<head>
<title>Search on Google Cloud Platform — Cloud Datastore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索谷歌云平台—云数据存储</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/search-on-google-cloud-platform-cloud-datastore-615c14cb1bb?source=collection_archive---------2-----------------------#2018-07-11">https://medium.com/google-cloud/search-on-google-cloud-platform-cloud-datastore-615c14cb1bb?source=collection_archive---------2-----------------------#2018-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d0fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的<a class="ae jd" rel="noopener" href="/google-cloud/search-on-google-cloud-platform-app-engine-and-search-api-31cda6917bbf">文章</a>中，我描述了如何使用谷歌云平台产品实现搜索功能(针对eshop或类似产品)的简化解决方案，即使用作为谷歌应用引擎标准一部分的搜索API。在本文中，我将描述使用云数据存储作为存储的解决方案。大多数介绍性的解释都写在以前的文章中，因此我在这里只着重描述搜索功能的实现。</p><p id="85bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提醒一下，任务描述是这样的:“假设你是eshop，你想实现你的产品描述功能的自动完成，所以当用户在搜索框中键入一些词，他们会得到包含这些词的产品。你如何在GCP上实现可伸缩性、快速性等……”</p><p id="60e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个例子和之前的例子都在<a class="ae jd" href="https://github.com/zdenulo/gcp-search/tree/master/cloud_datastore" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><h1 id="25e2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">云数据存储</h1><p id="4da4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">云数据存储是NoSQL数据库，于2008年作为谷歌应用引擎的一部分首次推出，随后于2013年作为独立产品在谷歌云上推出。因为它是NoSQL，这意味着它是可伸缩的，但是与SQL数据库相比有一些限制。与文本搜索最显著相关的事实是，不可能进行“LIKE”或正则表达式查询，这种查询进行部分文本匹配，并适合我们的文本搜索。这意味着，如果你想查询和做文本搜索，它需要完全匹配。这意味着将需要一些定制和手工工作来准备可搜索的数据。</p><p id="5805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据存储的一些属性:</p><ul class=""><li id="3046" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">NoSQL暗示了一些限制:</li><li id="f145" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">对于您想要执行的每个查询，都需要有索引</li><li id="667e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">支持交易</li><li id="733e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">基本上没有存储的限制</li><li id="beef" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">付费使用模式:50k读取0.06美元，20k写入0.18美元，20k删除0.02美元，存储0.18美元每1GB，每日免费配额。</li><li id="f6b2" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">有用于本地开发的模拟器</li><li id="0e7b" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">有一些编程语言的客户端库可供访问，或者可以从Google App Engine Standard访问。</li></ul><h2 id="bf01" class="kv jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">模型</h2><p id="52f7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我再次使用谷歌应用引擎标准与Python。正如我提到的，数据存储API是GAE SDK的一部分，即它的使用非常简单，特别是与NDB库(还有官方的python客户端库<a class="ae jd" href="https://googlecloudplatform.github.io/google-cloud-python/latest/datastore/client.html" rel="noopener ugc nofollow" target="_blank">https://Google cloud platform . github . io/Google-cloud-python/latest/Datastore/client . html</a>，可以在任何地方使用)。所以我创建的数据库模型看起来像这样:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="1f1c" class="kv jf hi lo b fi ls lt l lu lv">class Product(ndb.Model):<br/>    """Datastore model representing product"""<br/>    partial_strings = ndb.StringProperty(repeated=True)<br/>    product_name = ndb.StringProperty()<br/>    price = ndb.FloatProperty()<br/>    url = ndb.StringProperty()<br/>    type = ndb.StringProperty()<br/><br/>    def _pre_put_hook(self):<br/>        """before save, parse product name into strings"""<br/>        if self.product_name:<br/>            product_name_lst = regex_replace.sub(' ', self.product_name.lower()).split(' ')<br/>            product_name_lst = [x for x in product_name_lst if x and len(x) &gt; 2]<br/>            self.partial_strings = product_name_lst<br/><br/>    @classmethod<br/>    def search(cls, text_query):<br/>        words = text_query.lower().split(' ')<br/>        words = [w for w in words if w]<br/>        query = cls.query()<br/>        for word in words:<br/>            query = query.filter(cls.partial_strings == word)<br/>        return query.fetch(20)<br/><br/>    @classmethod<br/>    def create(cls, item):<br/>        """Create object"""<br/>        key = ndb.Key(cls, int(item['sku']))<br/>        obj = cls(key=key, price=float(item['price']), product_name=item['name'], url=item['url'], type=item['type'])<br/>        return obj</span></pre><p id="21ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我添加了一些额外的字段，如价格、类型、url…就像我在数据存储中编写的文本搜索需要额外的定制才能正常工作，因此步骤如下:</p><ul class=""><li id="8b95" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">在pre_put_hook方法(在保存实例之前执行)中，我执行基本的文本拆分。我用空格分割产品名称，并删除长度小于2的单词，因为我不想查询这些单词。我将这个单词列表设置为变量partial_strings。数据存储允许包含对象列表的字段，并且这些字段可以根据列表中的内容进行查询。</li><li id="5f1f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">在创建方法中，我使用sku作为实体的id (key)。</li><li id="39c0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">在搜索方法中，我将文本拆分成单词，并动态创建数据库查询和过滤器来获取实体。因此，对于文本“鼠标键盘”，数据库查询将如下所示:product . query(Product.partial_strings ==“鼠标”，product . partial _ strings = =“键盘”)，并将返回名称中同时包含单词“鼠标”和“键盘”(或其他一些单词)的产品。现在的做法是匹配精确的单词。当然，只需几行代码，就可以对产品名称中的单词进行标记，以便匹配部分单词。类似这样的事情是可行的:</li><li id="3579" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">name = " mouse keyboard " partial _ strings =[]for word in name . split('):for I in range(3，len(word)+1):partial _ strings . append(word[0:I])print partial _ strings[' mou '，' mous '，' mouse '，' key '，' keyb '，' keybo '，' keyboa '，' keyboar '，' keyboard']</li><li id="399d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">因此，现在它也可以匹配文本“牟”，即允许更敏感的搜索。</li></ul><p id="cf55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于后端和数据上传，一切都或多或少与前一篇文章相同。从csv文件上传1.2M行花了2.5个小时，我用与搜索API类似的方式做了这件事，尽管对于数据存储没有关于操作频率的限制。如果我使用并发请求，速度可能会更快，但是这次我没有考虑这个问题。</p><figure class="lj lk ll lm fd lx er es paragraph-image"><div class="er es lw"><img src="../Images/346cd349703b52430a9d19c9131c0908.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*5juvFIbgfzzLtSPP.png"/></div></figure><h1 id="2187" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">负载测试</h1><p id="cfd8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">使用与上例相同的配置，每秒10个用户的孵化率需要几分钟才能达到2000个用户，并且仍然可以在最大用户数下运行几分钟。它发出了大约165，000个请求，平均时间为69毫秒，中位数为38毫秒。总体数据存储看起来比存储API更快。这可能与数据存储区的获取时间与其检索的对象数量有关的事实有关，如果它不检索任何或很少对象，它可能会更快。经过测试后，我意识到在上传过程中，我删除了字母数字字符，并在负载测试中使用这些字符作为输入，在这些情况下，它不会返回结果。当然，在这种情况下，一些缓存可以加快响应速度。</p><figure class="lj lk ll lm fd lx er es paragraph-image"><div class="er es ma"><img src="../Images/45b978608390206d9559c99f666c5d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*OUg36GyCwRqX3D0F.png"/></div></figure><p id="d2c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显示每秒总数和平均响应时间发展的图表。</p><figure class="lj lk ll lm fd lx er es paragraph-image"><div class="er es ma"><img src="../Images/4a664cd4fb5b581ebae29c025152e6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*R59BXx8_zn7zbWQK.png"/></div></figure><p id="a28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和用户数量。</p><figure class="lj lk ll lm fd lx er es paragraph-image"><div class="er es mb"><img src="../Images/69b09634a66bcf7713f60e9e2b46ed90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*_cLe_P72-rkO3YTc.png"/></div></figure><p id="458e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">日志</p><figure class="lj lk ll lm fd lx er es paragraph-image"><div class="er es lw"><img src="../Images/4ec15634e889d8b5bd90b500a4b43604.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*B-sg-duX8TiPk530.png"/></div></figure><p id="74b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过测试的谷歌应用引擎实例数。</p><figure class="lj lk ll lm fd lx er es paragraph-image"><div class="er es ma"><img src="../Images/126c7f850b8aa9daa36e17f54ca94b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*Bqa6P2Gvpr1Zqgva.png"/></div></figure><p id="42a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项测试的总成本约为4美元。所有都与数据存储相关，1.89美元的107万次写操作和2.13美元的360万次读操作，App Engine是免费的，负载测试Kubernetes Cluster I不算在内。</p><p id="2e97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之:数据存储是文本搜索的可行选择，尽管它的文本搜索能力有限，但它更容易与其他可能的数据库模型集成。</p><p id="5876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在发布关于谷歌云平台<a class="ae jd" href="https://www.gcpweekly.com/" rel="noopener ugc nofollow" target="_blank">https://www.gcpweekly.com/</a>的每周简讯。如果您想在每周一收到与GCP相关的新闻和文章，请订阅</p></div></div>    
</body>
</html>