<html>
<head>
<title>Introduction to Event-Driven Systems with Stream Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带流处理的事件驱动系统简介</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/introduction-to-event-driven-systems-with-stream-processing-8b169a9fae12?source=collection_archive---------4-----------------------#2019-09-05">https://medium.com/google-cloud/introduction-to-event-driven-systems-with-stream-processing-8b169a9fae12?source=collection_archive---------4-----------------------#2019-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="67b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文档讨论流处理事件驱动系统的基础。这是<a class="ae jd" rel="noopener" href="/@ratrosy/building-event-driven-cloud-applications-and-services-ad0b5b970036">构建事件驱动的云应用和服务</a>教程系列的一部分。</p><h1 id="7983" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">介绍</h1><p id="2832" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">流处理器是流处理事件驱动系统的核心，它将这种模式与反应式模式区分开来:处理器将输入、数据处理和输出捆绑在一起，同时单独管理自己的执行。开发人员不再自己从头开始编写代码；相反，它们在所选流处理器的上下文中操作数据。</p><p id="e9b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式在事件方面提供了更高层次的抽象。大多数流处理系统不是对每个事件都做出反应，而是用流的语言说话，将动作作为一个整体应用于流。流处理器帮助从流中提取状态，并将其传递回开发人员以进行进一步的操作或分析。许多流处理解决方案也是在考虑分布式处理的情况下构建的；如果您有一个足够强大的集群来支持工作流，它们可以轻松处理大量的流数据，几乎不需要人工干预。</p><p id="5ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以Youtube中的视图计数为例，可能更容易理解流处理事件驱动系统的独特性质:每次打开Youtube视频，Google都会显示其当前的视图计数，并将数字加1。该用例看起来很简单，但考虑到Youtube的规模(每天超过50亿次观看)，它在工程上可能相当具有挑战性，因为该功能是读写密集型的:</p><ul class=""><li id="7b66" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">如果您使用SQL/NoSQL数据库来保存计数，由群集写入(视图计数递增1)请求导致的持续锁定和释放将严重影响性能。对于热门视频来说尤其如此，这些视频每分钟的访问量可能高达30，000次。</li><li id="2bbe" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">如果您使用事件源持久化数据，那么持续的写入将不是问题；然而，使用这些解决方案，获取视图计数在计算上变得低效，因为每次读取都需要扫描和计算所有相关数据。您可能必须缓存结果，并冒着向查看者提供陈旧数据的风险。</li></ul><p id="c032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，流处理事件驱动系统通过关注大图来支持这种用例:每个视图成为流中的一个事件，流处理器在内存中动态计算视图计数<strong class="ih hj"/>。换句话说，它从单个视图计数事件流中提取出<strong class="ih hj">状态</strong>(聚合视图计数)，以便下游可以得到他们真正想要的(视图计数)，而不必担心不太重要的单个部分(视图)。通过一点分布式处理的魔力，这种模式可以在任何规模上轻松处理(几乎)实时视图计数(以及大量其他类似的用例)，许多企业和组织已经在生产中采用了它。</p><p id="5f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，您将使用<a class="ae jd" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Flink </a>构建一个类似(但基本)的视图计数流处理系统，Apache Flink 是该领域中普遍采用的流处理器之一，其中一个应用程序通过<a class="ae jd" href="https://cloud.google.com/pubsub/" rel="noopener ugc nofollow" target="_blank"> Cloud Pub/Sub </a>发送视图事件，Apache Flink使用事件流帮助计数视图。演示项目使用Java(对于Apache Flink)和Python(对于示例应用程序)。</p><h1 id="038b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">架构概述</h1><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/70492fbba476d2299b80fd49e52c4647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rf_NBu3Zcd2sWd_oO5ve4A.png"/></div></div></figure><p id="096f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工作流程如下:</p><ol class=""><li id="5e3a" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc lh kn ko kp bi translated">该应用程序通过云发布/订阅发布大量视图事件。</li><li id="21be" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lh kn ko kp bi translated">Apache Flink集群从云发布/订阅中获取事件，并开始处理流。更具体地说，</li></ol><ul class=""><li id="273b" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">(<code class="du li lj lk ll b">keyBy</code>)根据视频的id，集群将流划分为并行、分布式处理</li><li id="8158" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">(<code class="du li lj lk ll b">filter</code>)集群过滤所有过时或重复的事件</li><li id="b71e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">(<code class="du li lj lk ll b">flatMap</code>)集群将事件转换成更容易处理的格式，从每个事件中删除事件ID属性</li><li id="feb3" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">(<code class="du li lj lk ll b">keyBy</code>)集群根据视频的id再次分割流</li><li id="988c" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">(<code class="du li lj lk ll b">timeWindow</code>)群集对最近10秒内到达的所有事件进行分组</li><li id="7e91" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">(<code class="du li lj lk ll b">reduce</code>)群集计算窗口中每个视频的总观看次数</li></ul><h1 id="3a22" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">设置</h1><ol class=""><li id="8b53" class="kh ki hi ih b ii kc im kd iq lm iu ln iy lo jc lh kn ko kp bi translated">在你的机器上安装<a class="ae jd" href="https://cloud.google.com/java/docs/setup" rel="noopener ugc nofollow" target="_blank"> Java 8 </a>(使用Gradle作为构建自动化工具)和<a class="ae jd" href="https://cloud.google.com/python/setup" rel="noopener ugc nofollow" target="_blank"> Python 3 </a>。</li><li id="c479" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lh kn ko kp bi translated">安装<a class="ae jd" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank">谷歌云SDK </a>。</li><li id="1c79" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lh kn ko kp bi translated">下载阿帕奇弗林克。</li><li id="702f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lh kn ko kp bi translated"><a class="ae jd" href="https://cloud.google.com/pubsub/docs/quickstart-console" rel="noopener ugc nofollow" target="_blank">在你的谷歌云平台项目</a>中创建一个云发布/订阅主题和该主题的云发布/订阅订阅。使用<code class="du li lj lk ll b">Pull</code>类型进行订阅。</li><li id="0510" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lh kn ko kp bi translated">从GitHub克隆源代码。</li></ol><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="0a89" class="lt jf hi ll b fi lu lv l lw lx">git clone <a class="ae jd" href="https://github.com/michaelawyu/stream-processing-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/michaelawyu/stream-processing-demo</a></span></pre><h1 id="e545" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">理解代码</h1><p id="5a77" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Apache Flink作为该项目的流处理器，管理工作流的输入、数据转换和输出，其细节可在<code class="du li lj lk ll b"><a class="ae jd" href="https://github.com/michaelawyu/stream-processing-demo/blob/master/src/main/java/org/example/demo/StreamingJob.java" rel="noopener ugc nofollow" target="_blank">StreamingJob.java</a></code>获得。</p><h2 id="80b6" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">投入</h2><p id="0540" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Apache Flink提供了对连接到云发布/订阅主题的内置支持，这将自动提取消息(事件)。配置如下:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="2dff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置输入后，Flink返回一个<code class="du li lj lk ll b">DataStream</code>，你可以在上面操作。此时，由于没有指定数据转换，流看起来如下(假设已经发布了许多事件或视图):</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mn"><img src="../Images/46560e882af5d94c6645a8709b065675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z52zj2jTfWwVxxwsbYshJg.png"/></div></div></figure><h2 id="30c8" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">步骤#1:分区(keyBy)</h2><p id="cefa" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">您将应用的第一个操作是使用视频id对流进行分区:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="0177" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步之后，流看起来如下:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mn"><img src="../Images/00a203da2bb72eba7d2272a337fea72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPEmtwNfBqPe8VX28nPS2Q.png"/></div></div></figure><h2 id="6f6e" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">第二步:过滤</h2><p id="3fc0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">接下来，过滤流并删除所有重复的事件(如果有的话)。Cloud Pub/Sub只保证至少一次传递，偶尔可能会返回两次或更多次相同的消息；因此，要使用云发布/订阅作为视图计数的可靠来源，您必须在流中消除重复事件。</p><p id="f14c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此步骤中，您将使用自定义过滤器进行重复数据删除。过滤器内部驻留了一个<a class="ae jd" href="https://guava.dev/releases/19.0/api/docs/com/google/common/cache/LoadingCache.html" rel="noopener ugc nofollow" target="_blank"> LoadingCache </a>，由<a class="ae jd" href="https://github.com/google/guava" rel="noopener ugc nofollow" target="_blank">Google Core Libraries for Java</a>提供；每次事件到达时，自定义过滤器检查事件的ID是否在缓存中；如果缓存命中，Flink将从流中移除事件。缓存的内容会在10分钟后自动过期，因此您不必担心内存溢出。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="f0e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步之后，流看起来如下:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mn"><img src="../Images/33531dceb04538e2e08ffb9497438aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqxgQBvQDMC1DeknqFn7JA.png"/></div></div></figure><blockquote class="mo mp mq"><p id="e506" class="if ig mr ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">注</em> </strong></p><p id="8de1" class="if ig mr ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated"><em class="hi">实际上，云发布/订阅很少重复事件。这通常发生在订户未能及时确认事件时。该图仅用于演示目的，图中过滤事件的百分比绝对不准确。</em></p></blockquote><h2 id="d2d1" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">第3步和第4步:映射(平面映射)和分区(keyBy)</h2><p id="5076" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这两个步骤中，您将把来自定制Java类<code class="du li lj lk ll b">PubSubEvent</code>的事件映射到一个包含两个条目的元组，并使用videos的ID(元组的第一个条目)再次对流进行分区:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="27a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个步骤有助于使最后的计算步骤稍微容易一些。在这一步之后，流看起来如下:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mn"><img src="../Images/20830500f5bf491ed3c348f2a10db600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqKferSPTflqTabjBdhZ8g.png"/></div></div></figure><h2 id="ebf0" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">第5步:开窗(时间窗)</h2><p id="9fb7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">此时此刻，事件流无限流动，如果新的观看次数不断增加，我们不可能输出每个视频的总观看次数。在这一步中，您将要求Flink对流进行窗口处理，对最近10秒内到达的所有元组进行分组:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="123c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步之后，流看起来如下:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mn"><img src="../Images/77c71d4dd56238c7fcdd87d18333ea2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHmhLJo8M8KsfhFYzp8Anw.png"/></div></div></figure><h2 id="e2b7" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">第六步:减少</h2><p id="2a5c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在，您可以使用<code class="du li lj lk ll b">reduce</code>功能计算出最近10秒内每个视频的总观看次数。<a class="ae jd" href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)" rel="noopener ugc nofollow" target="_blank"> Reduce </a>是函数式编程领域的一个概念，系统通过组合递归数据结构各层的返回值来构建最终的返回值。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="e3b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图展示了<code class="du li lj lk ll b">reduce</code>的工作原理:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mv"><img src="../Images/8fdb05daff5cd3167c50d0bff09d157a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZ2O8qrkRkq2juf2a_p7MA.png"/></div></div></figure><p id="4bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步中，Flink以同样的方式计算最终输出，即视频的观看次数:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mn"><img src="../Images/c47a787dd5f2bc71836d794527327fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfRSKt6myVBxx0fxVRK2Jg.png"/></div></div></figure><h2 id="28a0" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">输出</h2><p id="489e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">出于简单的原因，这个演示项目中的工作流将视频的观看次数输出到终端(<code class="du li lj lk ll b">stdout</code>)。但是，在生产中，您可能希望将输出保存在数据库中以供查询。本质上，此工作流有助于定期(每10秒)输出每个视频的聚合视图计数，有效地消除了每次出现新视图时更新视图计数数据库的需要，从而大大提高了应用程序的性能。</p><h2 id="2535" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">可量测性</h2><p id="d89b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Apache Flink能够在多个节点上并行执行这个演示项目中的工作流，您可以设置这些节点来增加系统的吞吐量。Flink保证具有相同键的<strong class="ih hj">事件将总是命中相同的分区，而不管可能有多少个分区</strong>，从而使开发人员更容易设计可扩展的流处理系统。</p><p id="61a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，工作流的第二步使用内存缓存进行重复数据删除。缓存本身绑定到一个Flink分区，而不是整个集群；启用并行化后，每个分区都将拥有自己的缓存。如果没有Flink分区保证，重复事件可能会被发送到不同的分区，从而有效地绕过重复数据删除机制，并最终影响最终的视图计数。</p><p id="00e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他流处理解决方案可能内置了重复数据删除功能:例如，<a class="ae jd" href="https://cloud.google.com/dataflow/" rel="noopener ugc nofollow" target="_blank">云数据流</a>，智能地使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布隆过滤器</a>进行快速准确的重复检测。您可能希望实现它，而不是应用程序中使用的基本缓存。</p><h2 id="60b3" class="lt jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">检查站</h2><p id="805d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">每个应用程序都会崩溃，事件驱动的流处理系统也不例外。通常开发人员必须编写他们自己的错误处理逻辑；然而，由于流处理器管理自己的执行，它们中的许多都有能力自己从错误中恢复。Apache Flink使用基于检查点的机制进行灾难恢复:系统在执行过程中以指定的时间间隔自动备份状态作为检查点；如果出现异常，Apache Flink将从异常中恢复状态。</p><p id="7592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您只是在Flink工作流中操作数据，例如将Flink传递的两个值相加并在步骤6中返回总和，则不需要额外的设置来使用检查点。另一方面，如果开发人员试图在工作流中引入一个自定义变量作为状态，他们必须告诉Flink如何备份和恢复状态。例如，步骤2中使用的缓存就是这样一个自定义变量:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h1 id="e939" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">看看它的实际效果</h1><p id="da48" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在，您可以在本地集群中运行此工作流了:</p><ul class=""><li id="df09" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><a class="ae jd" href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually" rel="noopener ugc nofollow" target="_blank">通过环境变量为您的项目</a> ( <code class="du li lj lk ll b">GOOGLE_APPLICATION_CREDENTIALS</code>)设置服务帐户凭证。</li><li id="9421" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">设置以下环境变量:</li></ul><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="5f03" class="lt jf hi ll b fi lu lv l lw lx">export GCP_PROJECT=YOUR-PROJECT<br/>export PUBSUB_TOPIC=YOUR-PUBSUB-TOPIC<br/>export PUBSUB_SUBSCRIPTION=YOUR-PUBSUB-SUBSCRIPTION</span></pre><p id="6b97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用自己的值替换<code class="du li lj lk ll b">YOUR-PROJECT</code>、<code class="du li lj lk ll b">YOUR-PUBSUB-TOPIC</code>和<code class="du li lj lk ll b">YOUR-PUBSUB-SUBSCRIPTION</code>。</p><ul class=""><li id="e211" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">转到克隆项目的目录，用下面的命令运行示例应用程序。建议你使用Python <code class="du li lj lk ll b"><a class="ae jd" href="https://virtualenv.pypa.io/" rel="noopener ugc nofollow" target="_blank">virtualenv</a></code>。</li></ul><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="192d" class="lt jf hi ll b fi lu lv l lw lx">cd helper<br/>pip install -r requirements.txt<br/>python main.py</span></pre><p id="aca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">助手应用程序向您的云发布/订阅主题发布60个事件，包括视频1的20个视图、视频2的30个视图和视频3的10个视图。您可以在<code class="du li lj lk ll b">main.py</code>中自行编辑数值。</p><p id="979f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/michaelawyu/stream-processing-demo/blob/master/helper/events.yaml" rel="noopener ugc nofollow" target="_blank">点击此处查看事件规范</a>。该应用程序还使用CloudEvents Generator准备的事件库来发布事件。</p><p id="5496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该会看到以下输出:</p><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="9e09" class="lt jf hi ll b fi lu lv l lw lx">Waiting for Cloud Pub/Sub to complete publishing events (20s)…</span></pre><ul class=""><li id="a490" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">接下来，用gradle构建Apache Flink工作流it:</li></ul><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="24b7" class="lt jf hi ll b fi lu lv l lw lx">cd ..<br/>gradle build</span></pre><p id="b193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译后的JAR文件驻留在<code class="du li lj lk ll b">build/libs</code>中。</p><ul class=""><li id="4373" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">切换到Apache Flink的安装目录。如果你用<a class="ae jd" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> brew </a>在macOS上安装了Flink，你可能会找到带<code class="du li lj lk ll b">brew info apache-flink</code>的路径。</li><li id="93e2" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">启动本地Flink集群:</li></ul><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="9100" class="lt jf hi ll b fi lu lv l lw lx">./bin/start-cluster.sh # Linux<br/>./libexec/bin/start-cluster.sh # macOS (via brew)<br/>./bin/start-cluster.bat # Windows</span></pre><ul class=""><li id="ed6c" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">运行编译后的工作流:</li></ul><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="b071" class="lt jf hi ll b fi lu lv l lw lx">./bin/flink PATH-TO-PROJECT/build/libs/stream-processing-demo-0.1.0-all.jar # Linux</span><span id="8a3e" class="lt jf hi ll b fi mw lv l lw lx">flink PATH-TO-PROJECT/build/libs/stream-processing-demo-0.1.0-all.jar # macOS</span><span id="2131" class="lt jf hi ll b fi mw lv l lw lx">./bin/flink.exe PATH-TO-PROJECT/build/libs/stream-processing-demo-0.1.0-all.jar #Windows</span></pre><ul class=""><li id="e2c5" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">现在，您可以检查Flink计算的视图计数是否与之前的值匹配:</li></ul><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="1703" class="lt jf hi ll b fi lu lv l lw lx">tail log/flink-*-standalonesession-*.log</span></pre><p id="8f21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你应该看看</p><pre class="kw kx ky kz fd lp ll lq lr aw ls bi"><span id="9580" class="lt jf hi ll b fi lu lv l lw lx">(1, 20)<br/>(2, 30)<br/>(3, 10)</span></pre><p id="2c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或其输出中的等价物，它与<code class="du li lj lk ll b">main.py</code>中指定的视图数量相匹配。</p></div></div>    
</body>
</html>