<html>
<head>
<title>Continuous Delivery in Google Cloud Platform — Cloud Build with Compute Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google云平台中的持续交付—使用计算引擎构建云</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-compute-engine-a95bf4fd1821?source=collection_archive---------0-----------------------#2018-12-13">https://medium.com/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-compute-engine-a95bf4fd1821?source=collection_archive---------0-----------------------#2018-12-13</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><p id="e125" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">本文是解决Google云平台中持续交付的系列文章的第二部分。<a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5">在第一篇文章中，Google App Engine是主角</a>。在这一次，谷歌计算引擎——或简称GCE——将会登场。GCE是GCP的基础设施即服务组件，它建立在谷歌的全球基础设施之上，允许其用户按需启动虚拟机。</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et jf"><img src="../Images/354935f70102ff1cee14f077a8556a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgtaVt66gObGv4RdGvkU0g.png"/></div></div></figure><p id="1037" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">正如我们已经看到的，GAE非常适合持续交付项目。然而，使用该平台有一些限制:代码必须用特定的语言/版本编写，主要是如果你的团队旨在使用标准环境，这种环境更便宜(更多信息请访问<a class="ae je" href="https://cloud.google.com/appengine/docs/the-appengine-environments" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/app engine/docs/the-app engine-environments</a>)；如果该项目被设计为在GAE上运行，那么肯定会完全兼容，但是如果试图将遗留代码迁移到该平台，即使选择灵活的环境，也可能会遇到麻烦。</p><p id="0565" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">经过利弊分析后，您的团队可能会得出结论，GAE不是项目的最佳选择。可能是因为项目使用了一些平台不支持的语言或工具；也许是因为他们希望对执行环境有更多的控制或可定制性；可能是因为他们只想将工作负载从现有服务器迁移到GCP，以便在不改变太多代码的情况下立即利用应用程序的扩展。对于所有这些情况，考虑一下<a class="ae je" href="https://cloud.google.com/compute/" rel="noopener ugc nofollow" target="_blank"> <strong class="ii hk">谷歌计算引擎</strong> </a>。</p><p id="bdec" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们将在接下来的内容中看到如何使用一套在GCP可用的工具，允许您的团队使用GCE建立一个<strong class="ii hk">开发+自动化构建+连续交付</strong>管道。此外，通过使用示例Angular app，可以将该解决方案与使用GAE的解决方案进行比较，如第<a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5">篇文章</a>所述。这里的关键点是应用程序<strong class="ii hk">必须</strong>作为Docker映像发布。如果您能够在您的项目中做到这一点，您就有很大的机会像本文中描述的那样自动化整个部署过程。</p><blockquote class="jr js jt"><p id="17aa" class="ig ih ju ii b ij ik il im in io ip iq jv is it iu jw iw ix iy jx ja jb jc jd hc bi translated"><strong class="ii hk">在继续之前，如果您希望运行示例，请确保您已经创建了一个GCP项目，并在您的机器上安装了</strong><a class="ae je" href="https://cloud.google.com/sdk/install" rel="noopener ugc nofollow" target="_blank"><strong class="ii hk">Google Cloud SDK</strong></a><strong class="ii hk">。不要忘记运行</strong> <code class="dv jy jz ka kb b"><strong class="ii hk"><em class="hj">gcloud auth login</em></strong></code> <strong class="ii hk">和</strong> <code class="dv jy jz ka kb b"><strong class="ii hk"><em class="hj">gcloud config set project &lt;your-project-id&gt;</em></strong></code> <strong class="ii hk">来正确使用gcloud CLI。</strong></p></blockquote><p id="e96b" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">为了简单起见，Angular app将由Nginx提供服务。所以，创建你的新Angular应用程序(遵循这里的<a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5"/>和<code class="dv jy jz ka kb b">cd &lt;app-name&gt;</code>描述的步骤)。为了将应用程序和Nginx服务器打包成Docker映像，让我们在其根文件夹中创建一个名为<code class="dv jy jz ka kb b">Dockerfile</code>的文件，内容如下:</p><figure class="jg jh ji jj fe jk"><div class="bz dz l di"><div class="kc kd l"/></div></figure><p id="738f" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">基本上，它是一个多阶段的容器构建。第1行到第5行(第1阶段)使用NodeJS 8映像来构建应用程序。第7行到第11行(第2阶段)将构建过程的结果(一组HTML、CSS和JS文件)复制到Nginx映像，并用应用程序的内容替换默认服务器的主页。最后，第12行启动服务器。</p><p id="d18a" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">让我们在同一个文件夹中创建第二个文件<code class="dv jy jz ka kb b">.dockerignore</code>，内容如下。它将防止Docker将不必要的文件复制到构建的映像中，从而减小它们的大小。</p><figure class="jg jh ji jj fe jk"><div class="bz dz l di"><div class="kc kd l"/></div></figure><p id="463d" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">如果你触发了一个<code class="dv jy jz ka kb b">docker build -t &lt;app-name&gt; .</code>命令，然后是<code class="dv jy jz ka kb b">docker run -d --name &lt;app-name&gt;-container -p 80:80 &lt;app-name&gt;</code>，将你的浏览器指向<code class="dv jy jz ka kb b">http://localhost:4200</code>，你会看到Docker正在运行这个应用程序。</p><blockquote class="jr js jt"><p id="aebf" class="ig ih ju ii b ij ik il im in io ip iq jv is it iu jw iw ix iy jx ja jb jc jd hc bi translated">到目前为止，我们所看到的只是角度和Docker设置的东西。从现在开始，GCP将会行动起来，让事情变得更有趣！</p></blockquote><p id="2245" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在典型的非自动化或半自动部署场景中，工程师可以(1)设置一个CI工具(如Jenkins)来监控Git存储库的新推送，(2)在推送新内容时触发构建过程，以及(3)找到一种<em class="ju">神秘的</em>方式来更新所有运行Docker容器的虚拟机，以更新新版本。步骤1和2很简单。也许不是...在这一点上，GCP提供了一种更复杂的方法:与其创建虚拟机，在其上安装Docker，并手动管理容器，不如创建专门运行特定容器的虚拟机，并在发布新版本的映像时自动更新自己。听起来不错，对吧？所以，我们来看看怎么做。</p><p id="c3b3" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">首先，我们需要在项目根文件夹中再添加一个小文件，名为<code class="dv jy jz ka kb b">cloudbuild.yaml</code>，如下:</p><figure class="jg jh ji jj fe jk"><div class="bz dz l di"><div class="kc kd l"/></div></figure><p id="141d" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这个文件将由<a class="ae je" href="https://cloud.google.com/cloud-build/" rel="noopener ugc nofollow" target="_blank">云构建</a>使用指定的名称来构建Docker映像并创建一个存储库以将其存储在容器注册表中——在构建时，云构建会自动用您的项目ID替换<code class="dv jy jz ka kb b">$PROJECT_ID</code>。</p><p id="cc6e" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">Ops…前一段提到了一个新的GCP组件:<a class="ae je" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">容器注册表</a>。根据官方文档，它不仅仅是一个私有的容器存储库:是您的团队管理容器映像、执行漏洞分析以及通过细粒度访问控制决定谁可以访问什么的单一位置。</p><p id="2490" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">回到代码:添加文件后，运行项目根文件夹中的<code class="dv jy jz ka kb b">gcloud builds submit --config cloudbuild.yaml .</code>,稍等片刻，在构建完成后访问<code class="dv jy jz ka kb b">https://console.cloud.google.com/gcr/images/&lt;your-project-id&gt;</code>。您将在那里看到新的存储库(类似于下图)。这个手动步骤只需要一次。您可以复制完整的存储库名称，我们以后会需要它；).</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et ke"><img src="../Images/aa1048916f2a40a8011f65318d9c883f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqBuW2PKdIv8UXr8xNcb0Q.png"/></div></div><figcaption class="kf kg eu es et kh ki bd b be z dy translated">容器注册表中的Docker图像— Google云平台</figcaption></figure><p id="c95c" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们几乎完成了Docker的形象建设。只需要设置一个触发器，它将在每次新代码被推送到受监控的Git库时自动启动构建过程，这是一个<a class="ae je" href="https://cloud.google.com/source-repositories/" rel="noopener ugc nofollow" target="_blank">源库</a>的工作，正如我们在本系列的<a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5">第一篇文章</a>中看到的。它的设置将与GAE交付时完全一样。请记住，主要的区别将是云构建处理的结果:对于GAE，它发布了一个新版本的应用程序；对于当前进程，它只推送容器注册表中的一个图像。</p><p id="5c51" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">现在，让我们创建一些虚拟机来运行容器。在GCP导航菜单中，点击<em class="ju">计算引擎&gt;实例模板</em>。点击<em class="ju">创建实例模板</em>。在下一个屏幕中，选择<strong class="ii hk">将一个容器映像部署到这个虚拟机实例</strong>，键入(或粘贴)完整的<strong class="ii hk">容器映像</strong> —也称为存储库—名称，选择<strong class="ii hk">允许HTTP流量，</strong>并单击<em class="ju">创建</em>。</p><p id="9bf3" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在导航菜单中，选择<em class="ju">计算引擎&gt;实例组</em>。点击<em class="ju">创建实例组</em>。在下一个屏幕中，选择您刚刚创建的<strong class="ii hk">实例模板</strong>，并将<strong class="ii hk">最小实例数</strong>设置为<code class="dv jy jz ka kb b">3</code>。点击<em class="ju">创建</em>。</p><p id="e542" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">创建实例组后，在导航菜单中选择<em class="ju">计算引擎&gt;虚拟机实例</em>。单击实例的<strong class="ii hk">外部IP </strong>链接，确保应用程序正在每个实例中运行。第一次返回主页可能需要一段时间…</p><p id="d128" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">最后，将<strong class="ii hk">计算实例管理员(v1) </strong>和<strong class="ii hk">服务帐户用户</strong>角色授予<code class="dv jy jz ka kb b">&lt;your-project-number&gt;@cloudbuild.gserviceaccount.com</code>服务帐户(<em class="ju">导航菜单&gt; IAM &amp;管理员&gt; IAM </em>)。</p><p id="e5c3" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">那么，如果我们将新的应用程序版本推送到Git存储库会怎么样呢？为了让它在生产中运行，我们需要重复哪些步骤？只需重启虚拟机！在GCP有许多方法可以做到这一点，包括向某个PubSub主题发布消息以调用重启虚拟机的云功能，或者使用高级选项来更新托管实例组(<a class="ae je" href="https://cloud.google.com/compute/docs/instance-groups/updating-managed-instance-groups" rel="noopener ugc nofollow" target="_blank">https://Cloud . Google . com/compute/docs/instance-groups/updating-managed-instance-groups</a>)。但是，为了展示一个简单的例子，我们只需在<code class="dv jy jz ka kb b">cloudbuild.yaml</code>中添加以下几行:</p><figure class="jg jh ji jj fe jk"><div class="bz dz l di"><div class="kc kd l"/></div></figure><p id="a0ee" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">他们将在我们的构建过程中包含一个新的步骤，即运行<code class="dv jy jz ka kb b">gcloud compute instance-groups managed rolling-action restart</code>命令。属于我们在前面几个步骤中创建的组的实例将在构建后一个接一个地重新启动，这个过程确保在任何给定的时间都有可用的机器。这可能需要几分钟的时间，具体取决于该组有多少个实例，但可以完美地工作。要看到它的运行，改变你代码中的一些东西，例如<code class="dv jy jz ka kb b">app.component.ts</code>中的标题，并将新代码推送到由云构建监控的Git存储库。等待几分钟，刷新每个实例提供的HTML页面(重启后外部IP可能会改变)。</p><p id="faea" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">好了，这个话题就讲到这里。正如这里所演示的，为GCE设置CI环境通常比为GAE设置CI环境更复杂，但是如果您的项目需求不适合GAE，这是一个有效的选择。当然，这是一种解决方案，但还有其他的。</p><p id="cc1e" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">下图显示了文章中提到的主要GCP组件:</p><figure class="jg jh ji jj fe jk es et paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="es et kj"><img src="../Images/71b6b45c086fda05a7c8431b3fd98ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-c-m3vFlI-EnFKiQlYA6sQ.png"/></div></div></figure><p id="95ba" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">Github上有示例代码:<a class="ae je" href="https://github.com/ricardolsmendes/gcp-cloudbuild-gce-angular" rel="noopener ugc nofollow" target="_blank">https://Github . com/ricardolsmendes/GCP-cloud build-GCE-angular</a>。随便叉一下玩玩。</p><p id="1492" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">希望有帮助！</p></div><div class="ab cl kk kl gq km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hc hd he hf hg"><p id="4642" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这是关于谷歌云平台中<strong class="ii hk">持续交付的3篇文章系列的第2篇:</strong></p><p id="e7d8" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-build-with-app-engine-8355d3a11ff5"> App引擎</a> | <strong class="ii hk">计算引擎</strong> | <a class="ae je" rel="noopener" href="/google-cloud/continuous-delivery-in-google-cloud-platform-cloud-run-with-kubernetes-engine-49b73577ef0f"> Kubernetes引擎</a></p></div></div>    
</body>
</html>