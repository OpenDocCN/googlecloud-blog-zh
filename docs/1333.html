<html>
<head>
<title>Secret Manager: Improve Cloud Run security without changing the code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Secret Manager:在不改变代码的情况下提高云运行安全性</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/secret-manager-improve-cloud-run-security-without-changing-the-code-634f60c541e6?source=collection_archive---------0-----------------------#2020-03-23">https://medium.com/google-cloud/secret-manager-improve-cloud-run-security-without-changing-the-code-634f60c541e6?source=collection_archive---------0-----------------------#2020-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/197708b3212d7f601e4dd2fa0a3ea663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQKERQdZsjUArxXjaHo9PA.png"/></div></div></figure><p id="5a9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据库凭证、API密钥或私钥(例如TLS证书)是大多数应用程序工作所需的数据类型。这些数据是秘密的，知道的人越少，你的秘密就越大！</p><p id="b941" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，我看到了，而且我继续看到太多次<strong class="is hj">秘密在存储库或部署脚本</strong>中的纯文本。</p><blockquote class="jo"><p id="7f70" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">为什么开发商不保密？</p></blockquote><p id="81da" class="pw-post-body-paragraph iq ir hi is b it jy iv iw ix jz iz ja jb ka jd je jf kb jh ji jj kc jl jm jn hb bi translated">遗憾的是，<strong class="is hj">在</strong><a class="ae kd" href="https://cloud.google.com/secret-manager/docs" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Secret Manager</strong></a><strong class="is hj">发布之前，没有用于安全存储机密</strong>的托管解决方案，它们以纯文本形式存储在部署脚本中，因此部署的云运行服务也是如此。<br/>直到今天，这种不良做法仍被开发商保留着。<strong class="is hj">团队通常知道这很糟糕，但是他们不知道(也许仍然不知道)如何做得更好。</strong></p><h2 id="e48f" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">环境变量用法</h2><p id="b1b5" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">因为你有几个环境，<strong class="is hj">秘密的值根据环境的不同而不同</strong>。<em class="le">事实上，您不会将Prod凭证用于您的开发数据库。</em></p><p id="bc20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个开发人员都知道这些值必须是动态的，而不是硬编码的(<em class="le">我希望如此！).</em> <strong class="is hj">最好的办法就是使用环境变量。秘密以明文的形式放在里面。</strong></p><h1 id="9b41" class="lf kf hi bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv bi translated">秘密经理保守你的秘密，秘密</h1><p id="a360" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">2019年12月，<strong class="is hj"> Secret Manager已经公测发布，4个月后GA。</strong> Secret Manager允许您存储多个版本的密码，只有拥有正确IAM角色的帐户才能访问或更新它们。</p><p id="c4ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本质是:<strong class="is hj">你从来没有在环境变量中设置纯文本值，只有一个秘密的引用，你在运行时代码加载它！</strong></p><p id="7f2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用<code class="du lw lx ly lz b">gcloud</code>命令来管理秘密，或者您可以在代码中使用客户端库进行编程。</p><h1 id="4f65" class="lf kf hi bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv bi translated">秘密管理器和遗留代码</h1><p id="2563" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">Secret Manager是用于任何新开发的解决方案。然而，对于现有的应用程序，您必须更新代码才能使用Secret Manager。这可能是一个问题。</p><p id="a97d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，一些应用程序在启动时依赖于环境变量，而<strong class="is hj">添加解密步骤是不可能的，否则会增加巨大的开销</strong>，尤其是在遗留应用程序中。</p><h1 id="746b" class="lf kf hi bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv bi translated">透明使用云运行</h1><p id="b098" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">云运行和容器的强大之处在于能够定制运行环境。</p><p id="132b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想法是在启动应用程序之前，检索秘密并<strong class="is hj">将秘密值加载到环境变量中。我创建了一个脚本来执行这个</strong></p><h2 id="8b21" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">要求</h2><p id="151c" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">在深入脚本之前，<strong class="is hj">在环境变量值中设置的现有秘密必须被创建到秘密管理器中</strong>。为此，您可以使用<code class="du lw lx ly lz b">gcloud</code>命令</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="6e74" class="ke kf hi lz b fi mi mj l mk ml">echo "my super secret" | gcloud beta secrets create \<br/>  --data-file=- --replication-policy=automatic my-secret</span></pre><p id="8d6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">注:</em> <code class="du lw lx ly lz b"><em class="le">--data-file</em></code> <em class="le">中的破折号</em><code class="du lw lx ly lz b"><em class="le">-</em></code><em class="le">param得到前面命令的结果，这里的</em> <code class="du lw lx ly lz b"><em class="le">echo</em></code> <em class="le">为秘密</em></p><p id="c86b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，您必须用这种模式更改环境变量值</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="69fa" class="ke kf hi lz b fi mi mj l mk ml">&lt;prefix&gt;[&lt;procjectID&gt;]/&lt;secretName&gt;[#&lt;version&gt;]</span></pre><ul class=""><li id="f454" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated"><code class="du lw lx ly lz b">&lt;prefix&gt;</code>将环境变量标记为必须恢复到秘密管理器中。<em class="le">默认情况下，脚本使用值</em>T5】</li><li id="5be0" class="mm mn hi is b it mv ix mw jb mx jf my jj mz jn mr ms mt mu bi translated"><code class="du lw lx ly lz b">&lt;projectID&gt;</code>是可选的。它定义了秘密存储在哪个项目中。如果缺少，则使用当前项目。<em class="le">斜线</em> <code class="du lw lx ly lz b"><em class="le">/</em></code> <em class="le">始终是必需的</em></li><li id="94d4" class="mm mn hi is b it mv ix mw jb mx jf my jj mz jn mr ms mt mu bi translated"><code class="du lw lx ly lz b">&lt;secretName&gt;</code>是秘密进入秘密管理者的名字</li><li id="1089" class="mm mn hi is b it mv ix mw jb mx jf my jj mz jn mr ms mt mu bi translated"><code class="du lw lx ly lz b">#&lt;version&gt;</code>是可选的。它将秘密的版本定义到秘密管理器中。如果丢失，将恢复最新版本。</li></ul><p id="508d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">在我们的测试中，我们将使用这个值</em> <code class="du lw lx ly lz b"><em class="le">secret:/my_secret#1</em></code></p><h2 id="38d5" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">访问机密管理器</h2><p id="ed28" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">Cloud Run使用的服务帐户必须能够访问secrets into Secret Manager。我建议您<strong class="is hj">为每个云运行服务</strong>创建一个特定的服务帐户。服务帐户将能够访问机密信息，<strong class="is hj">拥有细粒度授权是最佳实践</strong>。</p><p id="3d73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先创建一个服务帐户</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="e607" class="ke kf hi lz b fi mi mj l mk ml">gcloud iam service-accounts create cr-access-secret</span></pre><p id="8bed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，您可以在项目范围内授予服务帐户访问机密的权限。<strong class="is hj"/></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="5f29" class="ke kf hi lz b fi mi mj l mk ml">gcloud projects add-iam-policy-binding \<br/>--member=serviceAccount:cr-access-secret@&lt;PROJECT_ID&gt;.iam.gserviceaccount.com \<br/>--role=roles/secretmanager.secretAccessor &lt;PROJECT_ID&gt;</span></pre><p id="8e08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">用您当前的项目ID </em>替换 <code class="du lw lx ly lz b"><em class="le">&lt;PROJECT_ID&gt;</em></code> <em class="le"/></p><p id="aefa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者你可以<strong class="is hj">只授予服务帐号一个特定的秘密</strong>。有几个秘密的话就是重复动作，但是安全性更高。</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="c760" class="ke kf hi lz b fi mi mj l mk ml">gcloud beta secrets add-iam-policy-binding  \<br/>--member=serviceAccount:cr-access-secret@&lt;PROJECT_ID&gt;.iam.gserviceaccount.com \<br/>--role=roles/secretmanager.secretAccessor my-secret</span></pre><p id="63c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">用您当前的项目ID </em>替换 <code class="du lw lx ly lz b"><em class="le">&lt;PROJECT_ID&gt;</em></code> <em class="le"/></p><h2 id="664b" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">仔细看看<code class="du lw lx ly lz b">Dockerfile</code></h2><p id="5339" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">现在，测试的环境已经设置好了。如果你看一下<code class="du lw lx ly lz b"><a class="ae kd" href="https://github.com/guillaumeblaquiere/secret-loader-medium/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code>，你会看到这最后两行</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="ef65" class="ke kf hi lz b fi mi mj l mk ml">RUN wget https://storage.googleapis.com/secret-loader/start.sh \<br/>     &amp;&amp; chmod +x /start.sh<br/>CMD ["/start.sh", "/server"]</span></pre><p id="12b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我简单地下载了一个<strong class="is hj"> bash脚本，并在上面添加了执行权限</strong>。然后我启动这个脚本，<em class="le">只有一个参数</em> : <strong class="is hj">我想在秘密加载后运行什么。</strong></p><h2 id="25b1" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">秘密装载</h2><p id="1abd" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">所有的过程都由<code class="du lw lx ly lz b"><a class="ae kd" href="https://github.com/guillaumeblaquiere/secret-loader-medium/blob/master/start.sh" rel="noopener ugc nofollow" target="_blank">start.sh</a></code>脚本文件执行。让我们深入了解一下。</p><p id="321b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我从<strong class="is hj">开始定义</strong> <code class="du lw lx ly lz b"><strong class="is hj">&lt;prefix&gt;</strong></code>默认值。<em class="le">想改就改！</em></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="17a9" class="ke kf hi lz b fi mi mj l mk ml">secret_prefix="secret:"</span></pre><p id="7af4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，处理就很简单了</p><ul class=""><li id="3839" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">扫描所有包含T4的<strong class="is hj">环境变量，提取每个变量的<code class="du lw lx ly lz b">key</code>和<code class="du lw lx ly lz b">value</code></strong></li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="1786" class="ke kf hi lz b fi mi mj l mk ml">for i in $(printenv | grep ${secret_prefix})<br/>do<br/>  key=$(echo ${i} | cut -d'=' -f 1)<br/>  val=$(echo ${i} | cut -d'=' -f 2-)</span></pre><ul class=""><li id="0ce9" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">然后我检查值是否以<code class="du lw lx ly lz b">&lt;prefix&gt;</code>开始。如果是这样，我<strong class="is hj">去掉</strong>T8】。<em class="le">事实上，另一个环境变量可以匹配</em> <code class="du lw lx ly lz b"><em class="le">grep</em></code> <em class="le">，但是没有前缀。</em></li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="0f7a" class="ke kf hi lz b fi mi mj l mk ml">if [[ ${val} == ${secret_prefix}* ]]<br/>then<br/>  val=$(echo ${val} | sed -e "s/${secret_prefix}//g")</span></pre><ul class=""><li id="4f1e" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">提取项目，如果不为空，<strong class="is hj">为</strong> <code class="du lw lx ly lz b"><strong class="is hj">gcloud</strong></code> <strong class="is hj">命令</strong>准备参数值</li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="14a4" class="ke kf hi lz b fi mi mj l mk ml">projectId=$(echo ${val} | cut -d'/' -f 1)<br/>secret=$(echo ${val} | cut -d'/' -f 2)<br/><br/>if [[ -n ${projectId} ]]<br/>then<br/>  project="--project=${projectId}"<br/>fi</span></pre><ul class=""><li id="a8f9" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated"><strong class="is hj">提取秘密的名称及其版本</strong>。如果缺少版本，则使用值<code class="du lw lx ly lz b">latest</code></li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="d5d9" class="ke kf hi lz b fi mi mj l mk ml">secretName=$(echo ${secret} | cut -d'#' -f 1)<br/>version="latest"<br/>if [[ ${val} == *#* ]]<br/>then<br/>  version=$(echo ${val} | cut -d'#' -f 2)<br/>fi</span></pre><ul class=""><li id="8b9f" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">最后，获取秘密并<strong class="is hj">将其加载到名为</strong> <code class="du lw lx ly lz b"><strong class="is hj">key</strong></code> <strong class="is hj">的环境变量中</strong></li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="1cd1" class="ke kf hi lz b fi mi mj l mk ml">plain="$(gcloud beta secrets versions access --secret=${secretName} ${version} ${project})"<br/>#For multiline management<br/>export $key="$(echo $plain | sed -e 's/\n//g')"</span></pre><p id="752c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。在对环境变量<strong class="is hj">进行循环之后，我调用了脚本中唯一的一个参数。</strong></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="1326" class="ke kf hi lz b fi mi mj l mk ml">#run the following command<br/>${1}</span></pre><p id="bad2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">这是一个唯一的参数。在</em> <code class="du lw lx ly lz b"><em class="le">Dockerfile</em></code> <em class="le">中设置</em> <strong class="is hj"> <em class="le">将整个命令及其参数放入同一个字符串</em> </strong></p><h2 id="dc3a" class="ke kf hi bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky bi translated">构建容器并部署云运行服务</h2><p id="9bcd" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">为了测试秘密的正确加载，我写了一个非常简单的<strong class="is hj"> Go服务器，当你调用它时，它会显示所有的环境变量</strong>。构建容器，例如使用云构建</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="f019" class="ke kf hi lz b fi mi mj l mk ml">gcloud builds submit -t gcr.io/&lt;PROJECT_ID&gt;/secret-loader</span></pre><p id="7287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">用您当前的项目ID </em>替换 <code class="du lw lx ly lz b"><em class="le">&lt;PROJECT_ID&gt;</em></code> <em class="le"/></p><p id="54a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并使用<strong class="is hj"> secret环境变量和授权服务帐户</strong>部署服务</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="f33c" class="ke kf hi lz b fi mi mj l mk ml">gcloud run deploy --image=gcr.io/&lt;PROJECT_ID&gt;/secret-loader \<br/>--platform=managed --region=us-central1 --allow-unauthenticated \<br/>--service-account=cr-access-secret@&lt;PROJECT_ID&gt;.iam.gserviceaccount.com \<br/>--set-env-vars=super_secret=secret:/my-secret#1 secret-loader</span></pre><p id="b820" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">用您当前的项目ID替换</em> <code class="du lw lx ly lz b"><em class="le">&lt;PROJECT_ID&gt;</em></code> <em class="le">。为了更简单的测试，我允许未经认证的用户。不强制，做最适合自己的！</em></p><p id="24b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，通过<strong class="is hj">点击部署后提供的URL </strong>或者通过命令行测试您的部署</p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="f2d4" class="ke kf hi lz b fi mi mj l mk ml">curl https://secret-loader.&lt;project-hash&gt;-uc.a.run.app</span></pre><h1 id="beca" class="lf kf hi bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv bi translated">透明装载</h1><p id="4f28" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">现在你有了。通过使用这个<strong class="is hj">预启动脚本，秘密被加载到您的环境变量</strong>中。您的遗留应用程序不需要更新，只有Docker文件发生了变化，最好的情况下只有2行。</p><p id="fbe5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用法<strong class="is hj">不限于云运行和容器</strong>。您也可以在计算引擎中使用这个预启动脚本<strong class="is hj">。</strong></p><p id="1caa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重构、复杂性、延迟将不再是让应用程序不安全的借口。保守秘密是最重要的！</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="29ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请根据您的要求随时更新、改编、更改脚本。我很乐意在评论中了解你的用法和更新。</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="8784" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">2020年4月18日更新</strong></p><h1 id="3331" class="lf kf hi bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv bi translated">春云GCP解决方案</h1><p id="6142" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">对于那些使用Spring Cloud的用户，有一个内置的解决方案。<strong class="is hj"/><a class="ae kd" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gcp/1.2.2.RELEASE/reference/html/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">spring-Cloud-GCP项目</strong> </a> <strong class="is hj">为无缝集成谷歌云产品提供了一个大型库。</strong></p><p id="e188" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中一个是专用于秘密管理器的<a class="ae kd" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gcp/1.2.2.RELEASE/reference/html/#secret-manager" rel="noopener ugc nofollow" target="_blank"/>，它允许你简单地通过3个简单的步骤的配置来轻松<strong class="is hj">加载你的秘密</strong></p><ul class=""><li id="df49" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">将依赖项添加到项目中</li></ul><p id="df16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">带Maven的</em></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="11e3" class="ke kf hi lz b fi mi mj l mk ml">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-gcp-starter-secretmanager&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="554f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">带梯度</em></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="12be" class="ke kf hi lz b fi mi mj l mk ml">dependencies {   compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-secretmanager' }</span></pre><ul class=""><li id="3d7d" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">在<code class="du lw lx ly lz b">bootstrap.properties</code>文件中激活启动引导，并为你的密码定义一个前缀<em class="le">(推荐)</em></li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="e290" class="ke kf hi lz b fi mi mj l mk ml"># Enable the bootstrap at startup<br/>spring.cloud.gcp.secretmanager.bootstrap.enabled=true<br/><br/># Optional prefix of the secret name<br/>spring.cloud.gcp.secretmanager.secret-name-prefix=secrets.</span></pre><ul class=""><li id="55ef" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">将您的秘密直接定义到<code class="du lw lx ly lz b">properties</code>文件中，无需更改代码</li></ul><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="4bc8" class="ke kf hi lz b fi mi mj l mk ml">my_super_secret=${secrets.my_secret}</span></pre><p id="c467" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lw lx ly lz b"><em class="le">my_secret</em></code> <em class="le">是秘密管理器中的秘密名称，带有已定义的前缀，</em> <code class="du lw lx ly lz b"><em class="le">my_super_secret</em></code> <em class="le">是变量的名称，您可以像这样在代码中注入:</em></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="e292" class="ke kf hi lz b fi mi mj l mk ml">@Value(${my_super_secret})<br/>private String mySuperSecret</span></pre><p id="e068" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">如果你喜欢更新你的代码，或者用这个库编码，你可以像这样直接使用Secret(</em><strong class="is hj"><em class="le">我不推荐这样，你直接在你的代码</em> </strong> <em class="le"> ) </em></p><pre class="ma mb mc md fd me lz mf mg aw mh bi"><span id="5a43" class="ke kf hi lz b fi mi mj l mk ml">@Value(${secrets.my_secret})<br/>private String mySuperSecret</span></pre></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="f592" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">仅此而已，不需要任何代码</strong>，只需要在属性文件中进行配置和变量重定义！<a class="ae kd" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-secretmanager-sample" rel="noopener ugc nofollow" target="_blank">示例文件中的更多示例</a></p></div></div>    
</body>
</html>