<html>
<head>
<title>Stream Millions of events from your client to BigQuery in a Serverless way, Part #1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以一种无服务器的方式将数百万个事件从客户机流式传输到BigQuery，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/stream-millions-of-events-from-your-client-to-bigquery-in-a-serverless-way-part-1-a38c4f9cd6e4?source=collection_archive---------2-----------------------#2021-03-21">https://medium.com/google-cloud/stream-millions-of-events-from-your-client-to-bigquery-in-a-serverless-way-part-1-a38c4f9cd6e4?source=collection_archive---------2-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="eac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创业公司成功的关键之一是<strong class="ih hj">数据，</strong>收集数据从来都不是一个坏主意，即使它可能会耗费时间和资源，但它是你用来了解你的产品和将你的平台提升到新水平的财富。</p><p id="d2c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将向您展示一种以可伸缩的方式处理数百万数据事件的方法，使用GCP提供的无服务器服务，并且确实有一个免费层！！</p><p id="7212" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文将分为两个部分:</p><p id="1cde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第1部分:构建一个API从客户端接收原始数据并将其推送到发布/订阅</strong></p><p id="aad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第2部分:<a class="ae jd" rel="noopener" href="/@abdulrahmanbabil/stream-millions-of-events-from-your-client-to-bigquery-in-a-serverless-way-part-2-d2913ecee763">运行ETL作业，将事件传输并加载到BigQuery中</a></p><p id="0e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<a class="ae jd" href="https://github.com/omegaes/serverless-streaming" rel="noopener ugc nofollow" target="_blank"> Github资源库</a>中找到<strong class="ih hj"> API </strong>和<strong class="ih hj"> gcloud </strong>的代码，以创建所有需要的资源，并提供更深入的细节。</p><h1 id="2597" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">事件流</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/1c51b139aec34b3313bc46a66c8c4b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57Wowb6Ot7zi-LWPiPejCA.png"/></div></div></figure><h1 id="7d6d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">生产者API！</h1><p id="ab28" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在大多数情况下，您有一个端点从客户端接收数据，可能客户端会向端点发送一批数据，这个端点应该是可靠的，并且始终可用，具有低延迟和高扩展能力，对于这个示例，我将选择一种简单的方法来构建这个API，我将使用GCP的CloudRun。</p><p id="52b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">云运行</strong> </a>确实支持以无服务器方式托管您包含的应用程序，根据您的流量从0扩展到N，这非常容易部署，让您专注于构建您的应用程序。</p><p id="691a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我确实在express中使用node.js编写了一个简单的端点，它可以接受JSON事件的JSON数组。</p><p id="28b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们预计在短时间内会有数百万的事件数据，这些数据对您的应用程序来说优先级较低，因此无需将其存储在主数据库中，但您可以将其存储在仓库/数据泄漏中，在本例中，我将使用BigQuery作为这些数据的最终目的地。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es kt"><img src="../Images/e2363c68d3230f7a896b0aebea1db400.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*Ga38B55jLSNWVYJVFz8lfA.png"/></div></figure></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="d7e0" class="je jf hi bd jg jh lb jj jk jl lc jn jo jp ld jr js jt le jv jw jx lf jz ka kb bi translated">堆栈驱动和发布/订阅</h1><blockquote class="lg lh li"><p id="d6cf" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">问题:我们如何将事件发送到发布/订阅？</p></blockquote><p id="e698" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，通过使用Pub/Sub SDK，它提供了一组函数来将消息推送到Pub/Sub主题中，然后主题将传递给它的订阅，这种方式被认为是好的，但可能有一些缺点，例如为每个API调用向Pub/Sub服务发出HTTP请求的网络延迟，或者当您为每个API调用发送少量消息时的较高成本。</p><p id="9ec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是将<a class="ae jd" href="https://cloud.google.com/logging" rel="noopener ugc nofollow" target="_blank"> Stackdriver </a>与<a class="ae jd" href="https://cloud.google.com/logging/docs/export/configure_export_v2" rel="noopener ugc nofollow" target="_blank">T3】Stackdriver sink</a><strong class="ih hj">s</strong>一起使用，默认情况下Stackdriver将从所有GCP服务收集日志，因此stdout中的任何日志都将由stack driver收集，您可以选择将这些日志作为文本文件存储在GCP，或者将这些日志发送到BigQuery或Pub/Sub。</p><p id="91af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以首先我们必须让API将事件以JSON格式写入stdout，对于node.js我会推荐你使用“Bunyan”。</p><pre class="kd ke kf kg fd ln lo lp lq aw lr bi"><span id="cee3" class="ls jf hi lo b fi lt lu l lv lw">const bunyan = require('bunyan');</span><span id="1ca7" class="ls jf hi lo b fi lx lu l lv lw">const logger = bunyan.createLogger({</span><span id="a048" class="ls jf hi lo b fi lx lu l lv lw">name: 'events-service',</span><span id="7eeb" class="ls jf hi lo b fi lx lu l lv lw">streams: [{stream: process.stdout, level: 'info'}]</span><span id="040f" class="ls jf hi lo b fi lx lu l lv lw">});</span><span id="060c" class="ls jf hi lo b fi lx lu l lv lw">app.post('/receive', (req, res) =&gt; {</span><span id="a9fd" class="ls jf hi lo b fi lx lu l lv lw"> req.body.forEach(event =&gt; {</span><span id="a180" class="ls jf hi lo b fi lx lu l lv lw">    event.receive_timestamp = Date.now()</span><span id="92de" class="ls jf hi lo b fi lx lu l lv lw">    logger.info(event);</span><span id="e71e" class="ls jf hi lo b fi lx lu l lv lw"> });</span><span id="6ebe" class="ls jf hi lo b fi lx lu l lv lw"> res.status(200).send({done: true});</span><span id="5246" class="ls jf hi lo b fi lx lu l lv lw">});</span></pre><p id="aafc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备好代码+ Dockerfile后，我们需要将其部署在<strong class="ih hj">云运行</strong>上，下一步是创建一个<strong class="ih hj"> Stackdriver sink </strong>，第一个sink会将所有日志定向到一个发布/订阅主题，您可以从GCP控制台或gcloud CLI创建sink。</p><blockquote class="lg lh li"><p id="7c9d" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">最好从Stackdriver _default sink中停止/排除这些日志，只是为了节省成本！</p></blockquote><p id="e4a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用一些事件调用您的Producer API，稍后您可以转到云日志(Stackdriver)，使用以下过滤器搜索日志:</p><pre class="kd ke kf kg fd ln lo lp lq aw lr bi"><span id="d177" class="ls jf hi lo b fi lt lu l lv lw">jsonPayload.name="events-service"</span></pre><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ly"><img src="../Images/a28918cf2793808e1d44a5d70ec908cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDEukwRlSFZ4VFXhj-01WQ.png"/></div></div></figure><p id="afa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是当生产者API被调用时发送的事件，只是登录到日志中，在几秒钟内，消息将被推送到目标主题，等待消费者作业完成ETL工作！。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lz"><img src="../Images/6da01a5baf12f57aeac6f269f7003a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGgyaBGaGr5kk2GpjDEKGA.png"/></div></div></figure><p id="f8d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜你！您的事件在Pub/Sub中等待，只需几行代码，无需关心客户端发送的事件数量，Pub/Sub和Cloud Run会处理它，请阅读第2部分，这样您就可以将这些事件转换并加载到BigQuery中。</p><p id="b20e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎在下面的评论中分享你的想法，如果你有任何问题或反馈，请不要犹豫！</p><p id="fe14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续阅读第2部分:<a class="ae jd" rel="noopener" href="/@abdulrahmanbabil/stream-millions-of-events-from-your-client-to-bigquery-in-a-serverless-way-part-2-d2913ecee763">运行ETL作业，将事件传输和加载到BigQuery </a>。</p></div></div>    
</body>
</html>