<html>
<head>
<title>Why I definitively switched from Cloud Functions to Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我最终从云功能转向云运行</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/why-i-definitively-switched-from-cloud-functions-to-cloud-run-635d03f1eb4d?source=collection_archive---------0-----------------------#2022-07-17">https://medium.com/google-cloud/why-i-definitively-switched-from-cloud-functions-to-cloud-run-635d03f1eb4d?source=collection_archive---------0-----------------------#2022-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c502e995ce0612b99976f284fffc1a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2tdX8v1_6Z3n-diSsG0lig.png"/></div></div></figure><p id="46cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无服务器工具对任何开发人员来说都非常容易使用，你可以轻松地构建应用程序并将其从0扩展到全球范围的解决方案。<br/>在这个过程中，项目管理、部署、自动化和所有工业化主题必须高效，以保持优势并继续平稳发展<strong class="is hj"/>。</p><p id="f920" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Google Cloud上，云功能是(was？)最流行的服务之一是<strong class="is hj">在HTTP模式或后台模式下部署一段简单的代码</strong>(响应事件，如PubSub消息或云存储事件)。</p><p id="059b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，<strong class="is hj">2019年</strong>推出的Cloud Run和产品中非常快速且非常<strong class="is hj">好的功能添加</strong>让我重新考虑云功能的使用，慢慢地，<strong class="is hj">让我放弃了它</strong>。</p><blockquote class="jo"><p id="bfba" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated"><strong class="ak"> <em class="jy">说到这里，我为什么抛弃了云功能。</em> </strong></p></blockquote><h1 id="e5fb" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">产品差异</h1><p id="4f4c" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我已经在我的第一篇文章中谈到了这个话题。这是<strong class="is hj">主要面向成本的</strong>，但是云功能也有一些优势。</p><p id="03f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天，云功能不再有优势</p><h2 id="5346" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">事件管理</h2><p id="2b49" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">Eventarc  的引入完全消除了事件管理的差异:现在可以像以前一样处理相同的事件，甚至更多，因为Eventarc支持70多个其他谷歌云产品。</p><h2 id="1860" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">降低成本的CPU片</h2><p id="67bc" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">最近引入的<a class="ae lc" href="https://cloud.google.com/run/docs/configuring/cpu#cpu-memory" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">部分vCPU分配</strong> </a>允许为您的云运行实例设置少于1个vCPU。如果你的代码主要是等待API调用的响应并执行一些处理，那么这个特性就特别有趣。</p><p id="9f2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云功能允许拥有部分CPU，现在云运行也是一样，但是也有能力<strong class="is hj">独立于CPU能力</strong>改变内存配置。<br/> <em class="lr">更多可能的组合！</em></p><h1 id="a5ce" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw bi translated">云运行杀手功能</h1><p id="b16a" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">经过几个月的时间，Cloud Run获得了越来越多的功能，现在已经超过了云功能的容量。这里有一些最重要的</p><h2 id="fcd9" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">无服务器容器平台</h2><p id="ea3a" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">容器很受欢迎，是打包应用程序的一种现代方式。但是这里真正的优势是能够让开发者能够<strong class="is hj">配置和定义他们自己的运行时环境</strong></p><p id="881d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">语言、二进制、多进程、(…)现在都是可能的，并且在支持的语言或包含的依赖项方面不再有限制。<strong class="is hj">开发者有了真正的自由</strong>！</p><p id="72c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">自由对于开发来说是真的，对于可移植性也是真的。因为<strong class="is hj">容器是打包</strong>应用程序的通用方式，所以你可以在任何地方运行它们！<em class="lr">在您的计算机上，在虚拟机上，在Kubernetes上，… </em> <strong class="is hj">移植性是固有的！</strong></p><h2 id="a9d2" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">回滚和流量分流</h2><p id="40f1" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">由于CI/CD渠道和DevOps思维，发布经常发生，而且越来越快。<strong class="is hj"> Bug、问题、版本验证</strong>也越来越快。</p><p id="0dd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云运行提供<a class="ae lc" href="https://cloud.google.com/run/docs/rollouts-rollbacks-traffic-migration" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">流量分流</strong> </a>轻松将一定比例的流量调度到不同版本。</p><ul class=""><li id="0601" class="lv lw hi is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md bi translated">回滚时的前一个</li><li id="6f1a" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">50–50用于蓝/绿部署</li><li id="755d" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">逐渐向新的金丝雀释放</li></ul><h2 id="a8c7" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">最小实例和冷启动度量</h2><p id="d2e7" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">无服务器对你的口袋和地球都有好处。如果您不再使用<strong class="is hj">服务</strong>，则这些服务的价值将降至0。没有服务器运行，不用付费，不会白白浪费电力。</p><p id="2822" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果是<strong class="is hj">一个新实例启动时等待的时间</strong>。这叫冷启动。根据您的容器配置，这可能需要几毫秒或几秒钟(例如这里的<a class="ae lc" rel="noopener" href="/google-cloud/serverless-performance-comparison-does-the-language-matter-c72a7191c799">和</a>)。Cloud Run now <strong class="is hj">跟踪指标</strong>以帮助您了解冷启动持续时间以及对您服务的影响。</p><p id="9539" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了<strong class="is hj">防止冷启动</strong>，您还可以将<a class="ae lc" href="https://cloud.google.com/run/docs/configuring/min-instances" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">最小实例设置为云运行</strong> </a>并保持一个或多个实例热运行。当然，您将为它们付费，但是您的服务已经开始并准备好服务请求！</p><h2 id="3380" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">云运行作业</h2><p id="cfb6" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated"><a class="ae lc" href="https://cloud.google.com/run/docs/create-jobs" rel="noopener ugc nofollow" target="_blank">云跑最新的牛逼补充是<strong class="is hj">乔布斯</strong> </a> <strong class="is hj">。</strong>像Cloud Run一样，它能够在无服务器模式下运行容器，但是，这一次，不再需要公开一个<strong class="is hj">HTTP web服务器</strong>。</p><p id="7c78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云运行作业<strong class="is hj">并行运行容器，并在它们的作业结束</strong>时停止(或者在出错时重试)。</p><h1 id="6526" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw bi translated">超越简单的产品比较</h1><p id="3865" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">在上面的原始特性列表比较中，正如我在引言中所讨论的，<strong class="is hj">从开发到部署的项目生命周期</strong>对于任何应用程序都是重要的。</p><h2 id="269f" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">测试能力</h2><p id="2c79" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">在<a class="ae lc" rel="noopener" href="/google-cloud/cloud-run-and-cloud-function-what-i-use-and-why-12bb5d3798e1">那篇文章</a>中，我已经<strong class="is hj">展示了云运行的可测试性优势</strong>:简单地在本地运行你的web服务器，或者你的容器。没有仿真器，也没有运行它的功能框架！<em class="lr">这也是</em> <strong class="is hj"> <em class="lr">可移植性的后果</em> </strong> <em class="lr">在</em>之前解释过</p><h2 id="35e7" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">地形部署</h2><p id="dd27" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">使用Terraform来部署我最新的应用程序已经成为我永远放弃云功能的基石！</p><p id="9b5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于云功能，Terraform模块需要一个<strong class="is hj"> ZIP文件，该文件要么位于您的本地磁盘上，要么位于云存储</strong>上。</p><blockquote class="jo"><p id="ce80" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">一个ZIP文件！！！</p></blockquote><p id="6623" class="pw-post-body-paragraph iq ir hi is b it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">这意味着，您必须在您的CI/CD中创建它，并将其放在云存储中。</p><blockquote class="mo mp mq"><p id="081a" class="iq ir lr is b it iu iv iw ix iy iz ja mr jc jd je ms jg jh ji mt jk jl jm jn hb bi translated">如何创建正确的ZIP结构？你如何管理云存储上的版本？如何回滚？</p></blockquote><blockquote class="jo"><p id="74a9" class="jp jq hi bd jr js mu mv mw mx my jn dx translated">真的吗？？？一个压缩文件？！！！不，不严重！！</p></blockquote><p id="ace6" class="pw-post-body-paragraph iq ir hi is b it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">在高层次上，<strong class="is hj">容器有着相同的目的</strong>:它是一种打包应用程序代码的方式。<br/>但它是OCI结构，有一个<strong class="is hj">注册表</strong>来存储它们，你可以<strong class="is hj">签署清单</strong>，你有<strong class="is hj">协议和平台之间的互操作性</strong>，…</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="afff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Terraform的云运行非常流畅:你必须部署你的容器。<br/>因为流行的stander，<strong class="is hj">很多工具可以为你搭建容器</strong>；Docker通过docker文件或专用库，如Java中的<a class="ae lc" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> JIB或Golang中的</a><a class="ae lc" href="https://github.com/google/ko" rel="noopener ugc nofollow" target="_blank"> Ko。只有行业标准，<strong class="is hj">没有自制/弱解</strong>。</a></p><h1 id="2e84" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw bi translated">软弱的自白</h1><p id="2003" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">最终的事实是<strong class="is hj">云功能第二代</strong>。那个gen太棒了！您仍然有<strong class="is hj">语言限制</strong>，但是您<strong class="is hj">利用了所有的云运行特性</strong>:更长的超时、并发性、CPU/内存可伸缩性、回滚&amp;流量分割……</p><blockquote class="jo"><p id="d44c" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">太好了，为什么，怎么做？</p></blockquote><p id="c932" class="pw-post-body-paragraph iq ir hi is b it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">仅仅因为云功能<strong class="is hj">第二代是在云上运行的后端！！</strong>和<strong class="is hj">运行时特性现在完全相同</strong>。</p><p id="80c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，云运行<strong class="is hj">是一个非常强大和伟大的产品</strong>和云功能没有选择<strong class="is hj">拥抱它继续生存和发展</strong>！</p><h1 id="4e4e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw bi translated">为什么要继续使用云功能？</h1><p id="7fe1" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我个人<strong class="is hj">无法回答那个问题</strong>。云功能，第一代或第二代，不再有任何优势。恰恰相反，它<strong class="is hj">限制了你的发展，</strong>因此<strong class="is hj">限制了你的创新</strong>！</p><ul class=""><li id="aaf3" class="lv lw hi is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md bi translated">有限数量的<strong class="is hj">可能的语言</strong></li><li id="cf3d" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">有限支持的<strong class="is hj">事件类型</strong> (Eventarc仅与第二代兼容)</li><li id="ec0b" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">没有<strong class="is hj">运行时配置</strong></li><li id="c82f" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">有限的<strong class="is hj">便携性</strong></li><li id="7673" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">不容易<strong class="is hj">局部测试</strong></li><li id="33cc" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">无<strong class="is hj">并发</strong>(仅第二代)</li></ul><p id="8a4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以及许多其他缺失的功能(总是在CPU上，最小实例，提交<strong class="is hj">使用折扣</strong>，自定义域，<strong class="is hj"> gRPC/HTTP2/WebSocket支持</strong>，…)</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="dc94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谷歌云团队告诉我，这是一种不同的开发者体验。是的，这是真的:</p><blockquote class="jo"><p id="ec03" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">没有要创建的容器，因此不需要学习Dockerfile语言</p></blockquote><p id="5a5a" class="pw-post-body-paragraph iq ir hi is b it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn hb bi translated">但是与所有其他约束和限制相比，<strong class="is hj">优势非常弱</strong>，而且今天的解决方案的简易性<strong class="is hj">为您构建了标准/可靠/优化的容器。</strong></p><p id="4862" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">实际上，谷歌云</em> <strong class="is hj"> <em class="lr">会自动为你的云功能创建一个容器</em> </strong> <em class="lr">，这要感谢</em><a class="ae lc" href="https://buildpacks.io/" rel="noopener ugc nofollow" target="_blank"><em class="lr">build packs . io</em></a><em class="lr">，它是谷歌云为此目的创建的，现在开源并属于CNCF。</em></p><p id="a1a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以通过直接使用命令<code class="du ng nh ni nj b">gcloud run deploy</code>来利用云运行 的<a class="ae lc" href="https://cloud.google.com/run/docs/deploying-source-code" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">构建包。最后，真正不同的是<strong class="is hj">增加了一个网络服务器</strong>。<strong class="is hj">许多语言中不到10行代码</strong>:</strong></a></p><blockquote class="jo"><p id="0b81" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">这真的重要吗？</p></blockquote><h1 id="91df" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">云功能向云运行迁移</h1><p id="1ec6" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">因为我看不到任何优势，所以我建议您开始<strong class="is hj">对所有用例使用云运行</strong>，如果您有一些时间，就<strong class="is hj">迁移到云运行您现有的功能。</strong></p><p id="afc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这两种情况下，您都必须公开一个web服务器。在我的例子中，我使用了<code class="du ng nh ni nj b"><a class="ae lc" href="https://flask.palletsprojects.com/en/2.1.x/" rel="noopener ugc nofollow" target="_blank">Flask</a></code>，并且在<code class="du ng nh ni nj b">requirements.txt</code>文件中添加了它作为依赖项</p><p id="78b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">如果您对云运行有并发性问题，请将最大并发性设置为1。云函数</em> <strong class="is hj"> <em class="lr">第一代并发设置为1。</em> </strong></p><h2 id="f434" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">HTTP函数迁移</h2><p id="493e" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">云函数响应HTTP请求，这是最简单的迁移</p><p id="3adb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">遗留云功能代码</strong></p><p id="0d47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文件<code class="du ng nh ni nj b">main.py</code></p><pre class="nk nl nm nn fd no nj np nq aw nr bi"><span id="bc04" class="ld ka hi nj b fi ns nt l nu nv">def Hello(request):<br/>    return "Hello World"</span></pre><p id="5e0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">云运行迁移解决方案</strong></p><p id="da91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">把你的<code class="du ng nh ni nj b">main.py</code>改名为<code class="du ng nh ni nj b">functions.py</code></p><p id="e555" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建那个<code class="du ng nh ni nj b">main.py</code>文件</p><pre class="nk nl nm nn fd no nj np nq aw nr bi"><span id="9427" class="ld ka hi nj b fi ns nt l nu nv">import os<br/>from flask import Flask,request<br/><strong class="nj hj">import functions</strong><br/><br/>app = Flask(__name__)<br/><br/>@app.route('/')<br/>def call_function():<br/>    return <strong class="nj hj">functions.Hello(request)</strong><br/><br/><br/># For local execution<br/>if __name__ == "__main__":<br/>    app.run(host='0.0.0.0',port=int(os.environ.get('PORT',8080)))</span></pre><p id="b7ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，您只是将请求对象转发给函数，仅此而已。</p><p id="8ae1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你使用Python的Buildpacks解决方案而不使用<code class="du ng nh ni nj b">Dockerfile</code>(使用命令<code class="du ng nh ni nj b">gcloud run deploy</code>)，你必须<strong class="is hj">指示你的容器</strong>的入口点。为此，你必须像那样加上一个<code class="du ng nh ni nj b">Procfile</code></p><pre class="nk nl nm nn fd no nj np nq aw nr bi"><span id="f08b" class="ld ka hi nj b fi ns nt l nu nv">web: python3 main.py</span></pre><p id="5285" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">当然，你可以用参数定制那个入口点，使用</em> <code class="du ng nh ni nj b"><em class="lr">Gunicorn</em></code> <em class="lr">或者在启动时做任何你想做的事情。</em></p><h2 id="d4a5" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated">后台功能迁移</h2><p id="3bfb" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">对于该示例，我采用了一个由云存储事件触发的云函数，并迁移到云存储上由Eventarc事件调用的云运行。</p><p id="fd2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">遗留云功能代码</strong></p><p id="3c6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文件<code class="du ng nh ni nj b">main.py</code></p><pre class="nk nl nm nn fd no nj np nq aw nr bi"><span id="b240" class="ld ka hi nj b fi ns nt l nu nv">def hellogcs(event, context):<br/>    [print(format('event: {} -&gt; {}', key, event[key])) for key in event]<br/>    [print(format('context: {} -&gt; {}', key, context[key])) for key in context]</span></pre><p id="7f21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">云运行迁移解决方案</strong></p><p id="28c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将您的<code class="du ng nh ni nj b">main.py</code>重命名为<code class="du ng nh ni nj b">function.py</code></p><p id="8502" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建那个<code class="du ng nh ni nj b">main.py</code>文件</p><pre class="nk nl nm nn fd no nj np nq aw nr bi"><span id="f3ff" class="ld ka hi nj b fi ns nt l nu nv">import os<br/><br/>from flask import Flask, request<br/><br/>import functions<br/><br/>app = Flask(__name__)<br/><br/><br/>class Object(object):<br/>    pass<br/><br/><br/>@app.route('/', methods=['POST'])<br/>def call_function():<br/>    resource = Object()<br/>    resource.service = str.split(str.replace(request.headers['Ce-Source'], '//', '/'), '/')[0]<br/>    resource.name = str.split(str.replace(request.headers['Ce-Source'], '//', '/'), '/', 1)[1] + request.headers['Ce-Subject']<br/>    resource.type = request.get_json()['kind']<br/><br/>    context = Object()<br/>    context.event_id = request.headers['Ce-Id']<br/>    context.timestamp = request.headers['Ce-Time']<br/>    context.event_type = request.headers['Ce-Type']<br/>    context.resource = resource<br/><br/>    functions.hellogcs(request.get_json(), context)<br/>    return "ok, see logs"<br/><br/><br/># For local execution<br/>if __name__ == "__main__":<br/>    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))</span></pre><p id="aff5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lr">请注意，您必须从</em> <strong class="is hj"> <em class="lr"> HTTP请求中提取事件数据，并将其拆分为两个变量</em> </strong> <em class="lr">。</em> <code class="du ng nh ni nj b"><em class="lr">Context</em></code> <em class="lr">作为一个对象，代码稍微复杂一点。但是你写一次，你</em> <strong class="is hj"> <em class="lr">然后</em> </strong> <em class="lr">就可以把你所有的函数都迁移了！<br/>同样，如果您使用BuildBacks解决方案</em>，您必须使用 <code class="du ng nh ni nj b"><em class="lr">Procfile</em></code> <em class="lr"/></p><h2 id="6b0b" class="ld ka hi bd kb le lf lg kf lh li lj kj jb lk ll kn jf lm ln kr jj lo lp kv lq bi translated"><strong class="ak">普通Dockerfile包装</strong></h2><p id="061d" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">如果您喜欢使用定制容器而不是使用构建包，那么您可以使用通用的<code class="du ng nh ni nj b">Dockerfile</code>。</p><pre class="nk nl nm nn fd no nj np nq aw nr bi"><span id="ab4b" class="ld ka hi nj b fi ns nt l nu nv">FROM python:3.10-slim<br/><br/>ENV <em class="lr">PYTHONUNBUFFERED </em>True<br/><br/>WORKDIR /app<br/><br/>COPY requirements.txt .<br/><br/>RUN pip3 install --no-cache-dir -r requirements.txt<br/><br/>COPY . .<br/>ENV <em class="lr">PORT </em>8080<br/><br/>CMD python3 main.py</span></pre></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><p id="1f60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后用一个简单的命令部署您的代码</p><pre class="nk nl nm nn fd no nj np nq aw nr bi"><span id="008d" class="ld ka hi nj b fi ns nt l nu nv">gcloud run deploy</span></pre><h1 id="9bfc" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw bi translated">达尔文进化模型</h1><p id="1918" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">我是云功能的大用户，因为它改变了我的开发者的生活。它仍然是一款优秀、可靠且可扩展的产品。我个人并不反对那个产品，<strong class="is hj">团队花了很多努力来提供最好的无服务器产品之一</strong>。</p><p id="44f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，现在有了更好、更强、更简单、更便携的<strong class="is hj">产品。用起来简直显而易见。越来越多的开发人员熟悉容器，现在使用它们并不需要额外的成本。<br/>使用单一产品，带来其他优势:您必须<strong class="is hj">在单一产品上培训您的团队</strong>，并且您<strong class="is hj">不再有在云功能或云运行之间选择</strong>的问题。最后，<strong class="is hj">流程和最佳实践更少了</strong>(因为只有一种产品)，你<strong class="is hj">提高了你的整体效率。</strong></strong></p><p id="db58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像达尔文进化模型一样，不是弱者消失，而是最适应环境的物种主宰并灭绝了其他物种。</p><blockquote class="jo"><p id="df61" class="jp jq hi bd jr js jt ju jv jw jx jn dx translated">云功能也会这样吗？</p></blockquote></div></div>    
</body>
</html>