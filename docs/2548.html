<html>
<head>
<title>Crossplane(IaC), New Kid On The Block</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉平面(IaC)，新成员</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/crossplane-iac-new-kid-on-the-block-c9057c859c6a?source=collection_archive---------1-----------------------#2022-11-24">https://medium.com/google-cloud/crossplane-iac-new-kid-on-the-block-c9057c859c6a?source=collection_archive---------1-----------------------#2022-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b9eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去，管理IT基础架构是一项艰难的工作。系统管理员必须手动管理和配置应用程序运行所需的所有硬件和软件。</p><p id="e01e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，近年来，事情发生了巨大的变化。云、敏捷和开发运维实践的进步彻底改变了IT基础设施的设计、开发和维护。基础设施即代码(IaC)是这些实践的关键组成部分之一。IaC使用配置文件管理您的IT基础设施，并提供诸如提高速度、效率和一致性等好处。IaC促进了更快的基础设施部署，因为团队不必维护各个部署环境的设置。</p><p id="2b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">市场上有几种IaC解决方案。Terraform是IaC当前的行业领导者，它是一个了不起的工具；但是，您必须精通Terraform领域特定语言，如HashiCorp配置语言(HCL)。Pulumi是另一个更面向开发人员的开源IaC工具，因为它支持Python、JavaScript、Java、TypeScript、Go和. NET等语言。您可以使用这些语言开发可重用的函数、包、类和Pulumi组件。但是在IaC市场上有一个新的参与者，cross plane(<a class="ae jd" href="https://crossplane.io/" rel="noopener ugc nofollow" target="_blank">https://crossplane.io/</a>)，它遵循GitOps的IaC方法，我们将在这篇博客中介绍这个新的参与者。</p><p id="6719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能想知道，在混合使用<a class="ae jd" href="http://terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、<a class="ae jd" href="http://pulumi.com/" rel="noopener ugc nofollow" target="_blank"> Pulumi </a>，甚至<a class="ae jd" href="https://www.ansible.com/" rel="noopener ugc nofollow" target="_blank"> Ansible </a>的情况下，我为什么要考虑Crossplane？</p><p id="7b38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于Crossplane，有几件事真正引起了我的兴趣:</p><ul class=""><li id="f4b2" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">坚持基础设施即数据的原则。</strong>这是Kubernetes-native，因此您使用Kubernetes自定义资源(YAML，即文本)以声明方式<em class="jn">供应云基础架构。</em></li><li id="742a" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><strong class="ih hj">无状态文件。</strong>与<a class="ae jd" href="http://terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>和<a class="ae jd" href="http://pulumi.com/" rel="noopener ugc nofollow" target="_blank"> Pulumi </a>不同，Crossplane不使用状态文件。作为一个Kubernetes运营商，它有一个控制器来协调期望状态和当前状态，利用etcd来做到这一点。</li><li id="21e0" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated">真理之源。与<a class="ae jd" href="http://terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>和<a class="ae jd" href="http://pulumi.com/" rel="noopener ugc nofollow" target="_blank"> Pulumi </a>不同，如果有人试图做一些偷偷摸摸的事情，比如使用CLI或管理控制台更新云资源，Crossplane不会让你得逞。</li></ul><h1 id="4614" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">什么是交叉平面？</strong></h1><p id="5299" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Crossplane是一个开源的Kubernetes插件，可以将您的集群转换成一个通用控制平面。Crossplane使平台团队能够组装来自多个供应商的基础设施，并为应用程序团队提供更高级别的自助服务API，而无需编写任何代码。</p><p id="185c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Crossplane扩展了您的Kubernetes集群，以支持编排任何基础设施或托管服务。</p><p id="957a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Crossplane是一个<a class="ae jd" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基础</a>项目。</p><h1 id="48dd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">概念</h1><p id="063b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Crossplane引入了多个构建块，使您能够使用Kubernetes API供应、组合和消费基础设施。这些单独的概念一起工作，允许在组织中不同角色之间的关注点的强大分离，这意味着团队的每个成员在适当的抽象级别上与Crossplane交互。</p><h1 id="3f84" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">包装</h1><p id="0e18" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><a class="ae jd" href="https://crossplane.io/docs/v1.10/concepts/packages.html" rel="noopener ugc nofollow" target="_blank">封装</a>允许扩展交叉板以包含新功能。这通常看起来像捆绑一组Kubernetes<a class="ae jd" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">CRD</a>和<a class="ae jd" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-controllers" rel="noopener ugc nofollow" target="_blank">控制器</a>，它们代表并管理外部基础设施(即提供商)，然后将它们安装到运行Crossplane的集群中。交叉板处理确保任何新的CRD不与现有的CRD冲突，以及管理新包的RBAC和安全性。不严格要求包是提供者，但这是目前包最常见的用例。</p><h1 id="1c81" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">提供者</h1><p id="6cb3" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">提供者是使Crossplane能够在外部服务上提供基础设施的包。他们带来了与外部基础设施资源一一对应的CRD(即托管资源)，以及管理这些资源生命周期的控制器。您可以在<a class="ae jd" href="https://crossplane.io/docs/v1.10/concepts/providers.html" rel="noopener ugc nofollow" target="_blank">提供者文档</a>中阅读更多关于提供者的信息，包括如何安装和配置它们。</p><h1 id="6459" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">托管资源</h1><p id="e32b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">托管资源是Kubernetes自定义资源，代表基础设施原语。API版本为<code class="du kw kx ky kz b">v1beta1</code>或更高版本的托管资源支持云提供商为给定资源所做的每一项工作。您可以在<a class="ae jd" href="https://marketplace.upbound.io/" rel="noopener ugc nofollow" target="_blank">上行市场</a>上找到每个提供商的托管资源及其API规范，并在<a class="ae jd" href="https://crossplane.io/docs/v1.10/concepts/managed-resources.html" rel="noopener ugc nofollow" target="_blank">托管资源文档</a>中了解更多信息。</p><h1 id="5a34" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">复合资源</h1><p id="9ece" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">复合资源(XR)是一种特殊的定制资源，由<code class="du kw kx ky kz b">CompositeResourceDefinition</code>定义。它将一个或多个被管理的资源组成一个更高级别的基础设施单元。复合资源是面向基础设施操作者的，但是也可以提供面向应用程序开发人员的复合资源声明，作为复合资源的代理。您可以在<a class="ae jd" href="https://crossplane.io/docs/v1.10/concepts/composition.html" rel="noopener ugc nofollow" target="_blank">组合文档</a>中了解更多关于所有这些概念的信息。</p><h1 id="f8c9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">入门指南</h1><h1 id="0052" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">选择交叉平面分布</h1><p id="a96c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">第一次使用Crossplane的用户现在有两种选择。第一种方法是使用由社区维护和发布的Crossplane版本，该版本可在<a class="ae jd" href="https://github.com/crossplane/crossplane" rel="noopener ugc nofollow" target="_blank"> Crossplane GitHub </a>上找到。</p><p id="a4e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种选择是使用供应商支持的交叉板分布。这些发行版<a class="ae jd" href="https://github.com/cncf/crossplane-conformance" rel="noopener ugc nofollow" target="_blank">已通过CNCF </a>认证，符合Crossplane，但可能会包含额外的功能或工具，使其更易于在生产环境中使用。</p><h1 id="bb64" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">从上游交叉板开始</h1><p id="75b7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">将Crossplane安装到现有的Kubernetes集群中需要更多的设置，但是可以为需要它的用户提供更多的灵活性。</p><h1 id="69dd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">获取Kubernetes集群</h1><ol class=""><li id="a112" class="je jf hi ih b ii kr im ks iq la iu lb iy lc jc ld jk jl jm bi translated"><strong class="ih hj">自制MAC OS</strong></li></ol><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="e9f4" class="lm ju hi kz b be ln lo l lp lq">brew upgrade<br/>brew install kind<br/>brew install kubectl<br/>brew install helm<br/>kind create cluster --image kindest/node:v1.23.0 --wait 5m</span></pre><p id="547a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">对于macOS / Linux，使用以下内容:</strong></p><ul class=""><li id="b186" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae jd" href="https://kubernetes.io/docs/setup/" rel="noopener ugc nofollow" target="_blank"> Kubernetes集群</a></li><li id="9ccc" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><a class="ae jd" href="https://kind.sigs.k8s.io/docs/user/quick-start/" rel="noopener ugc nofollow" target="_blank">种类</a></li><li id="6849" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><a class="ae jd" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>，最低版本<code class="du kw kx ky kz b">v0.28+</code></li><li id="a4f1" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><a class="ae jd" href="https://helm.sh/docs/intro/using_helm/" rel="noopener ugc nofollow" target="_blank">舵</a>，最低版本<code class="du kw kx ky kz b">v3.0.0+</code>。</li></ul><h1 id="7d29" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">安装交叉面板</h1><p id="43b0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj">舵3稳定</strong></p><p id="e22d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Helm 3安装Crossplane的最新官方<code class="du kw kx ky kz b">stable</code>版本，适用于社区使用和测试:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="02ad" class="lm ju hi kz b be ln lo l lp lq">kubectl create namespace crossplane-system<br/>helm repo add crossplane-stable https://charts.crossplane.io/stable<br/>helm repo update<br/><br/>helm install crossplane --namespace crossplane-system crossplane-stable/crossplane</span></pre><h1 id="17a1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">检查交叉面板状态</h1><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="3e42" class="lm ju hi kz b be ln lo l lp lq">helm list -n crossplane-system<br/><br/>kubectl get all -n crossplane-system</span></pre><h1 id="f7e2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">安装交叉面板CLI</h1><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="0dc5" class="lm ju hi kz b be ln lo l lp lq">curl -sL https://raw.githubusercontent.com/crossplane/crossplane/master/install.sh | sh</span></pre><h1 id="b1c5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">选择入门配置</h1><p id="6a14" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Crossplane不仅仅是将基础设施原语建模为定制资源，它使您能够用自己选择的模式定义新的定制资源。我们称这些为“复合资源”(XRs)。复合资源由托管资源组成——Kubernetes定制资源提供了基础设施原语的高保真表示，如SQL实例或防火墙规则。</p><p id="1c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用两种特殊的交叉面板资源来定义和配置这些新的自定义资源:</p><ul class=""><li id="2c5c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">一个<code class="du kw kx ky kz b">CompositeResourceDefinition</code> (XRD) <em class="jn">定义了</em>一种新的复合资源，包括它的模式。一个XRD可以选择<em class="jn">提供</em>一个声明(XRC)。</li><li id="4c26" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated">一个<code class="du kw kx ky kz b">Composition</code>指定了复合资源将由哪些资源组成，以及应该如何配置它们。您可以为每个复合资源创建多个<code class="du kw kx ky kz b">Composition</code>选项。</li></ul><p id="1a4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">XRDs和Compositions可以作为<em class="jn">配置</em>打包和安装。配置是一个组合配置的[包],可以通过创建一个声明性的<code class="du kw kx ky kz b">Configuration</code>资源或者使用<code class="du kw kx ky kz b">kubectl crossplane install configuration</code>轻松地安装到Crossplane。</p><p id="1405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，我们将安装一个配置，该配置定义一个新的<code class="du kw kx ky kz b">XPostgreSQLInstance</code> XR和<code class="du kw kx ky kz b">PostgreSQLInstance</code> XRC，它们接受单个<code class="du kw kx ky kz b">storageGB</code>参数，并创建一个带有<code class="du kw kx ky kz b">username</code>、<code class="du kw kx ky kz b">password</code>和<code class="du kw kx ky kz b">endpoint</code>键的连接<code class="du kw kx ky kz b">Secret</code>。对于能够满足一个<code class="du kw kx ky kz b">PostgreSQLInstance</code>的每一个提供者都存在一个<code class="du kw kx ky kz b">Configuration</code>。我们开始吧！</p><h1 id="9d82" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">安装配置包</h1><p id="e41e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj"> GCP </strong></p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="8ee7" class="lm ju hi kz b be ln lo l lp lq">kubectl crossplane install configuration registry.upbound.io/xp/getting-started-with-gcp:v1.10.1</span></pre><p id="b19f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等待，直到所有程序包都正常运行:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="7f91" class="lm ju hi kz b be ln lo l lp lq">watch kubectl get pkg</span></pre><h1 id="d6fa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">获取GCP帐户密钥文件</h1><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="ffb1" class="lm ju hi kz b be ln lo l lp lq"># replace this with your own gcp project id and the name of the service account<br/># that will be created.<br/>PROJECT_ID=my-project<br/>NEW_SA_NAME=test-service-account-name<br/><br/># create service account<br/>SA="${NEW_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"<br/>gcloud iam service-accounts create $NEW_SA_NAME --project $PROJECT_ID<br/><br/># enable cloud API<br/>SERVICE="sqladmin.googleapis.com"<br/>gcloud services enable $SERVICE --project $PROJECT_ID<br/><br/># grant access to cloud API<br/>ROLE="roles/cloudsql.admin"<br/>gcloud projects add-iam-policy-binding --role="$ROLE" $PROJECT_ID --member "serviceAccount:$SA"<br/><br/># create service account keyfile<br/>gcloud iam service-accounts keys create creds.json --project $PROJECT_ID --iam-account $SA</span></pre><h1 id="6ee0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建提供者机密</h1><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="a9d5" class="lm ju hi kz b be ln lo l lp lq">kubectl create secret generic gcp-creds -n crossplane-system --from-file=creds=./creds.json</span></pre><h1 id="fad2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">配置提供程序</h1><p id="78d1" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们将创建以下<code class="du kw kx ky kz b">ProviderConfig</code>对象来配置GCP提供者的凭证:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="ad29" class="lm ju hi kz b be ln lo l lp lq"># replace this with your own gcp project id<br/>PROJECT_ID=my-project<br/>echo "apiVersion: gcp.crossplane.io/v1beta1<br/>kind: ProviderConfig<br/>metadata:<br/>  name: default<br/>spec:<br/>  projectID: ${PROJECT_ID}<br/>  credentials:<br/>    source: Secret<br/>    secretRef:<br/>      namespace: crossplane-system<br/>      name: gcp-creds<br/>      key: creds" | kubectl apply -f -</span></pre><h1 id="3961" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">供应基础设施</h1><p id="b447" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj"> GCP </strong></p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="9ab0" class="lm ju hi kz b be ln lo l lp lq">apiVersion: database.example.org/v1alpha1<br/>kind: PostgreSQLInstance<br/>metadata:<br/>  name: my-db<br/>  namespace: default<br/>spec:<br/>  parameters:<br/>    storageGB: 20<br/>  compositionSelector:<br/>    matchLabels:<br/>      provider: gcp<br/>  writeConnectionSecretToRef:<br/>    name: db-conn</span></pre><pre class="lr li kz lj bn lk ll bi"><span id="9049" class="lm ju hi kz b be ln lo l lp lq">kubectl apply -f https://raw.githubusercontent.com/crossplane/crossplane/release-1.10/docs/snippets/compose/claim-gcp.yaml</span></pre><p id="0cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建了<code class="du kw kx ky kz b">PostgreSQLInstance</code>之后，Crossplane将开始在您选择的提供商上提供一个数据库实例。一旦配置完成，您应该在运行以下命令时在输出中看到<code class="du kw kx ky kz b">READY: True</code>:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="b18d" class="lm ju hi kz b be ln lo l lp lq">kubectl get postgresqlinstance my-db</span></pre><ul class=""><li id="6c6c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du kw kx ky kz b">kubectl get claim</code>:获取所有索赔种类的所有资源，如<code class="du kw kx ky kz b">PostgreSQLInstance</code>。</li><li id="a363" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><code class="du kw kx ky kz b">kubectl get composite</code>:获取所有复合类的资源，比如<code class="du kw kx ky kz b">XPostgreSQLInstance</code>。</li><li id="da97" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><code class="du kw kx ky kz b">kubectl get managed</code>:获取代表一个外部基础设施单元的所有资源。</li><li id="3cbf" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><code class="du kw kx ky kz b">kubectl get &lt;name-of-provider&gt;</code>:获取与<code class="du kw kx ky kz b">&lt;provider&gt;</code>相关的所有资源。</li><li id="e959" class="je jf hi ih b ii jo im jp iq jq iu jr iy js jc jj jk jl jm bi translated"><code class="du kw kx ky kz b">kubectl get crossplane</code>:获取所有与交叉平面相关的资源。</li></ul><p id="54db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尝试以下命令，查看您调配的资源是否准备就绪:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="2724" class="lm ju hi kz b be ln lo l lp lq">kubectl get crossplane -l crossplane.io/claim-name=my-db</span></pre><p id="2fc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦您的<code class="du kw kx ky kz b">PostgreSQLInstance</code>准备好了，您应该在<code class="du kw kx ky kz b">default</code>名称空间中看到一个名为<code class="du kw kx ky kz b">db-conn</code>的<code class="du kw kx ky kz b">Secret</code>，它包含了我们在XRD中定义的键。如果它们是由组合填充的，那么它们应该出现:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="4f04" class="lm ju hi kz b be ln lo l lp lq">$ kubectl describe secrets db-conn<br/>Name:         db-conn<br/>Namespace:    default<br/>...<br/><br/>Type:  connection.crossplane.io/v1alpha1<br/><br/>Data<br/>====<br/>password:  27 bytes<br/>port:      4 bytes<br/>username:  25 bytes<br/>endpoint:  45 bytes</span></pre><h1 id="51d8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">消耗您的基础设施</h1><p id="6965" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">因为连接秘密是作为Kubernetes <code class="du kw kx ky kz b">Secret</code>编写的，所以它们很容易被Kubernetes原语使用。Kubernetes中最基本的构建模块是<code class="du kw kx ky kz b">Pod</code>。让我们定义一个<code class="du kw kx ky kz b">Pod</code>,它将显示我们能够连接到新提供的数据库。</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="1f5b" class="lm ju hi kz b be ln lo l lp lq">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: see-db<br/>  namespace: default<br/>spec:<br/>  containers:<br/>  - name: see-db<br/>    image: postgres:12<br/>    command: ['psql']<br/>    args: ['-c', 'SELECT current_database();']<br/>    env:<br/>    - name: PGDATABASE<br/>      value: postgres<br/>    - name: PGHOST<br/>      valueFrom:<br/>        secretKeyRef:<br/>          name: db-conn<br/>          key: endpoint<br/>    - name: PGUSER<br/>      valueFrom:<br/>        secretKeyRef:<br/>          name: db-conn<br/>          key: username<br/>    - name: PGPASSWORD<br/>      valueFrom:<br/>        secretKeyRef:<br/>          name: db-conn<br/>          key: password<br/>    - name: PGPORT<br/>      valueFrom:<br/>        secretKeyRef:<br/>          name: db-conn<br/>          key: port</span></pre><pre class="lr li kz lj bn lk ll bi"><span id="6342" class="lm ju hi kz b be ln lo l lp lq">kubectl apply -f https://raw.githubusercontent.com/crossplane/crossplane/release-1.10/docs/snippets/compose/pod.yaml</span></pre><p id="c672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<code class="du kw kx ky kz b">Pod</code>只是连接到一个PostgreSQL数据库并打印它的名称，所以如果您运行<code class="du kw kx ky kz b">kubectl logs see-db</code>，您应该在创建它之后看到下面的输出(或类似的内容):</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="1413" class="lm ju hi kz b be ln lo l lp lq">current_database<br/>------------------<br/> postgres<br/>(1 row)</span></pre><h1 id="325d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">打扫</h1><p id="3d1d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">要清理<code class="du kw kx ky kz b">Pod</code>，运行:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="b0b5" class="lm ju hi kz b be ln lo l lp lq">kubectl delete pod see-db</span></pre><p id="c98e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要清理已调配的基础架构，您可以删除<code class="du kw kx ky kz b">PostgreSQLInstance</code> XRC:</p><pre class="le lf lg lh fd li kz lj bn lk ll bi"><span id="9bcf" class="lm ju hi kz b be ln lo l lp lq">kubectl delete postgresqlinstance my-db</span></pre><h1 id="7620" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="87a7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">与保存状态文件的<a class="ae jd" href="http://terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>和<a class="ae jd" href="http://pulumi.com/" rel="noopener ugc nofollow" target="_blank"> Pulumi </a>不同，Crossplane允许你在工具之外改变云基础设施(可能会带来毁灭性的后果)，Crossplane不会让你得逞。</p><p id="e97d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像<a class="ae jd" href="https://www.ansible.com/integrations/cloud" rel="noopener ugc nofollow" target="_blank"> Ansible </a>一样，它坚持基础设施即数据的原则，使用YAML来声明性地提供云资源。这绝对是我的好书。</p><p id="924d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Crossplane出现的时间并不长，它显示了这一点。虽然有很多对AWS资源的支持，但相比之下，对T2谷歌云的支持却很少。也就是说，我相信随着它在未来的加速发展。</p></div></div>    
</body>
</html>