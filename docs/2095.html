<html>
<head>
<title>Secure Deployments from Gitlab to Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Gitlab到Google云平台的安全部署</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/secure-deployments-from-gitlab-to-google-cloud-platform-81cc507ead3e?source=collection_archive---------1-----------------------#2022-02-08">https://medium.com/google-cloud/secure-deployments-from-gitlab-to-google-cloud-platform-81cc507ead3e?source=collection_archive---------1-----------------------#2022-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候坦白了:每当你为你的谷歌云平台服务账户生成密钥并上传到Gitlab用于你的Gitlab CI管道时，你会感到内疚吗？晚上，您是否会因为将所有服务帐户密钥以纯文本的形式放在CI变量中而失眠？你会开玩笑说黑客会不可避免地泄露你的密钥，也许会浪费数千美元用你雇主的钱挖掘加密货币吗？</p><p id="4db8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你现在这样做，只需要一个Gitlab权限配置错误，你的密钥就有暴露的风险。那你就真的有麻烦了。使用手动生成的密钥不会带来风险，它违反了服务帐户<a class="ae jd" href="https://cloud.google.com/iam/docs/best-practices-for-using-and-managing-service-accounts" rel="noopener ugc nofollow" target="_blank">最佳实践</a>的核心隐含原则之一:如无必要，不要使用手动生成的密钥！这是一个如此令人沮丧和明显的问题。一定有更好的方法来使用来自Gitlab的经过认证的Google APIs。</p><p id="a2fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现，当我赶时间时，总是最难做正确的事情，在我与谷歌云的许多客户合作的过程中，我总是试图以极大的紧迫感让管道运行起来——当时间非常宝贵时——在我的项目中，我最负担不起技术债务的时候！怎样才能用最少的力气做正确的事？</p><p id="c1e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我如何让Gitlab CI pipelines访问谷歌凭证<em class="je">而不</em>下载和上传手动生成的服务帐户密钥？</p><h1 id="aa80" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">跑自己的跑步者</h1><p id="63f5" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><a class="ae jd" href="https://docs.gitlab.com/runner/" rel="noopener ugc nofollow" target="_blank"> Gitlab Runner </a>是一个配合Gitlab CI/CD运行管道作业的应用程序，可以安装在自己的基础设施上。这意味着我们可以在任何GCP环境中将Gitlab Runner安装到我们控制下的实例中。通过安装到Google计算引擎实例，我们可以将用户管理的服务帐户与该实例相关联。安排到该主机的Gitlab Runner作业将自动采用与该主机关联的GCP服务帐户凭据，而无需手动生成、下载和上传服务帐户密钥。</p><p id="57a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您自己的环境中使用自托管runner的另一个好处是，您可以将runner放在您的GCP环境的网络上或附近，使jobs能够直接连接到在您的私有VPC中运行的服务。当<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters" rel="noopener ugc nofollow" target="_blank">集群控制平面被配置为完全私有</a>时，这对于将工作负载部署到Google Kubernetes引擎特别有用。通常，为了连接到完全私有的集群，用户必须创建并连接到一个bastion实例，该实例由<a class="ae jd" href="https://cloud.google.com/architecture/creating-kubernetes-engine-private-clusters-with-net-proxies" rel="noopener ugc nofollow" target="_blank">代理</a>流量通过您的私有网络到达控制平面端点。然而，当您的Gitlab Runner在您的VPC上时，您可以直接从您的Gitlab CI工作中连接—没有代理，没有偏头痛，没有压力。</p><p id="95a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不局限于只在GCE实例上安装Gitlab Runner它可以运行在任何通用计算环境上，包括GKE。</p><h1 id="5940" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">简单的方法</h1><p id="637e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">也许将Gitlab Runner集成到您的环境中最简单的方法是在运行<a class="ae jd" href="https://cloud.google.com/container-optimized-os/docs/concepts/features-and-benefits" rel="noopener ugc nofollow" target="_blank">容器优化操作系统</a>的GCE实例上使用Runner的<a class="ae jd" href="https://docs.gitlab.com/runner/executors/docker.html" rel="noopener ugc nofollow" target="_blank"> Docker执行器</a>。使用启动脚本安装并<a class="ae jd" href="https://docs.gitlab.com/runner/#runner-registration" rel="noopener ugc nofollow" target="_blank">注册</a>Gitlab runner，它连接到<a class="ae jd" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>的托管SaaS平台，或者可选地连接到运行在内部或另一个云平台中的自托管git lab。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/8712eb04b415f1057658872607fca69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57ruCZ2xokXSZWtyn2z2Wg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">示例:自托管Gitlab Runner将基础设施部署为代码</figcaption></figure><p id="2fb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们看到了最简单的示例架构，使用Gitlab Runner将基础架构作为代码部署到Google云平台。当<em class="je">代码</em>(如<em class="je">基础设施中的代码</em>)在Gitlab的SaaS平台上由GCP外部托管时，当一个运行者被注册时，它接受来自Gitlab SaaS的CI作业。在这种情况下，像Terraform这样将基础设施部署为代码的作业将从与runner实例相关联的服务帐户继承其Google身份。该服务帐户拥有在GCP部署其基础架构所需的IAM权限。无需手动生成、下载凭据或向CI作业公开凭据，GCP只是通过其元数据服务器向实例公开一个短期令牌。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ky"><img src="../Images/9fc829e7cad8d3a3b0a6c438f6e73ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bu_vQGnkhEKzpLYp9VEuaA.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">部署到GKE的自托管Gitlab Runner</figcaption></figure><p id="1232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Gitlab CI的另一个非常常见的用例是将Kubernetes工作负载部署到私有GKE集群，如上图所示。与前面的例子相反，这个架构的Gitlab runner与我们部署的目标集群相邻，具体来说，它位于同一个VPC中。这是必需的，因为创建GKE集群时，GCP会在集群节点所在的<em class="je">您的VPC </em>和集群私有端点所在的GCP服务提供商网络之间建立VPC对等连接。这在上图中用蓝色虚线表示。当集群是私有的时，它们的端点只能从对等连接的<em class="je">端访问，在你的私有VPC上，通过这个对等连接进入服务提供商网络。因此，当我们将runner放在与GKE集群相同的VPC上时，我们可以利用这个对等连接直接连接到集群的端点，以使用其API来部署我们的工作负载。</em></p><h1 id="242d" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">示例代码</h1><p id="b4e6" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">以下启动脚本旨在用于默认安装了Docker的映像，<a class="ae jd" href="https://cloud.google.com/container-optimized-os/docs/concepts/features-and-benefits" rel="noopener ugc nofollow" target="_blank">，如容器优化的OS </a>。唯一必须提供的数据是<a class="ae jd" href="https://cloud.google.com/container-optimized-os/docs/concepts/features-and-benefits" rel="noopener ugc nofollow" target="_blank"> Gitlab Runner注册令牌</a>，它可以注册为与<em class="je">您的所有</em>组和项目共享，或者最小化为一个项目。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">Gitlab Runner注册启动脚本</figcaption></figure><p id="c3d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了反映云资源部署的现代标准，让我们用一些我们可以模板化的东西使其更受支持，并用Terraform作为基础设施作为代码进行部署。下面是Terraform代码片段。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">Gitlab Runner启动脚本的Terraform模板文件资源</figcaption></figure><p id="2427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Terraform，我们可以自动创建具有最基本功能的Gitlab Runners。在上面的Terraform资源片段中，我们创建了一个可重用的启动脚本模板，我们可以在创建runner实例时引用它。下面，我们使用上面的启动脚本模板创建一个带有一个节点的<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups#managed_instance_groups" rel="noopener ugc nofollow" target="_blank">托管实例组</a>，以确保至少有一个Gitlab Runner实例始终运行以接受CI/CD作业:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">Gitlab Runner管理Terraform的实例组资源定义</figcaption></figure><p id="01af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:注意第17–21行</strong>中的服务帐户块。这是Gitlab Runner jobs将用来访问Google APIs的服务帐户。在上面的例子中——如果没有设置这个块——实例使用<a class="ae jd" href="https://cloud.google.com/compute/docs/access/service-accounts#default_service_account" rel="noopener ugc nofollow" target="_blank">计算默认服务帐户</a>,该帐户被设计为具有高度特权，并且可能根本不代表您希望分配给Gitlab Runner作业的IAM权限。请确保使用IAM权限创建您自己的服务帐户，其访问权限不超过执行CI/CD任务所需的范围。</p><h1 id="fd28" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">按环境隔离访问</h1><p id="eca8" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">到目前为止，我们已经了解了如何利用托管在GCE上的Gitlab运行程序，通过使用单个GCE实例运行Gitlab CI作业，给予Gitlab CI访问GCP的特权，而无需显式地创建、下载、然后上传服务凭证到Gitlab。很简单。</p><p id="2561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，我们如何快速调整我们刚刚学到的知识，以支持对GCP的更细粒度的访问，例如支持部署到单个环境中(如生产环境),而不同时<em class="je">和</em>授予IAM对所有其他环境的访问权限？</p><p id="81fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以利用的一个有用的特性是Gitlab <a class="ae jd" href="https://docs.gitlab.com/ee/ci/yaml/#tags" rel="noopener ugc nofollow" target="_blank"> CI tags </a>，它允许我们指定一个或者几个与Gitlab Runner实例相对应的标签。这确保了带有给定标签的作业——例如<code class="du lb lc ld le b">prod</code>—只在特定的运行程序上运行。</p><p id="ae87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个来自<code class="du lb lc ld le b"><a class="ae jd" href="https://docs.gitlab.com/ee/ci/yaml/" rel="noopener ugc nofollow" target="_blank">.gitlab-ci.yml</a></code>管道文件的示例块，演示了如何指定一个构建标签:</p><pre class="kj kk kl km fd lf le lg lh aw li bi"><span id="e17a" class="lj jg hi le b fi lk ll l lm ln">build-app:<br/> stage: build<br/> tags:<br/>   - prod</span></pre><p id="22e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们注册的Gitlab跑者怎么会知道自己负责跑的是哪些标签呢？这一点很重要:当我们向Gitlab注册跑步者时，我们必须指定这一点。请注意第6行和第7行中添加的关于标记的命令行参数:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">支持CI标签的Gitlab Runner注册</figcaption></figure><h1 id="d5f5" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">发展这一战略</h1><p id="6633" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">虽然使用Google Compute Engine托管Gitlab runners是一种合理的方法，但它也有一些明显的缺点。例如，这种策略不支持自动扩展，也不支持零扩展以节省成本。如果实例耗尽了计算资源，您的构建作业将不可避免地受到资源争用和速度减慢的影响。相反，如果没有构建作业可用，runner实例将继续永久运行，在没有活动计算工作支持的情况下增加计算费用。最后，可能也是最值得注意的，需要根据所需的<em class="je">隔离部署身份</em>创建一个实例、运行者注册和服务帐户。例如，如果您需要对许多部署进行隔离，在每个部署的基础上授予对GCP的最低特权访问，那么为每个部署创建一个GCE实例可能不太合理。</p><p id="8d6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工程师要做什么？</p><p id="b89d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的下一篇博客文章中，我们将讨论如何将我们所了解的关于定制Gitlab运行程序的知识与<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/concepts/kubernetes-engine-overview" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes引擎</a>和<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">Workload Identity Federation</a>相结合，这使得在GKE命名空间中运行的工作负载能够访问GCP身份，类似于Google Compute Engine上的工作负载获得访问权限的方式。这使人们能够利用Kubernetes和GKE(向上和向下)中可用的所有扩展解决方案，同时使跑步者能够使用最少数量的IAM特权访问身份，使用相对便宜和轻量级的东西——Kubernetes名称空间——而不是更笨重和昂贵的东西——计算实例。</p></div></div>    
</body>
</html>