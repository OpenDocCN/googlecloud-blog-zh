<html>
<head>
<title>Global ingress in practice on Google Container Engine — Part 1: Discussion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google容器引擎的全球入口实践—第1部分:讨论</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/global-ingress-in-practice-on-google-container-engine-part-1-discussion-ccc1e5b27bd0?source=collection_archive---------0-----------------------#2017-09-18">https://medium.com/google-cloud/global-ingress-in-practice-on-google-container-engine-part-1-discussion-ccc1e5b27bd0?source=collection_archive---------0-----------------------#2017-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8df7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将介绍在使用GCE ingress控制器将一个真实的应用程序部署到一个全局联合集群时，我所面临的各种挑战和我找到的解决方案。我已经在另一篇文章中讲述了如何分三步建立全球Kubernetes。本文将集中讨论一旦设置好如何使用它。在第1部分中，我将讨论这些概念，在第2部分<a class="ae jd" rel="noopener" href="/@cgrant/global-ingress-in-practice-on-google-container-engine-part-2-demo-cf587765702">中，我们将使用真实代码进行端到端部署。</a></p><p id="5cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内容:<br/> -简单示例<br/> -变化<br/> -全局IP <br/> -注释<br/> -健康检查<br/> -节点端口类型和端口<br/> -路径上下文<br/> -集群平衡</p><p id="dbc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让多个部署的服务在一个域名下响应是大型应用程序中的常见做法。通过Kubernetes，您可以使用ClusterIPs、NodePort和LoadBalancers将部署作为独立的服务公开。您还可以使用入口资源将多个服务公开为单个虚拟实体。</p><p id="7acb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理论上，Ingress资源简单易用，但在实践中，学习曲线可能会更陡。在本文中，我们将回顾创建入口资源的基础知识，以及您在现实生活中会遇到的一些怪癖。</p><h1 id="7ccb" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">简单的例子</h1><p id="320a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这个过程涉及三个主要资源:部署、it服务和入口本身。让我们回顾一个简单的Hello World入口。</p><p id="eb6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Kubernetes关于入口资源的文档中，我们可以看到许多关键元素</p><p id="edd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从文档导入示例Yaml</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1624" class="kq jf hi km b fi kr ks l kt ku">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>    ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  rules:<br/>  - host: foo.bar.com<br/>    http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /bar<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80</span></pre><p id="c188" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里只介绍一下，任何对主机foo.bar.com的请求都将由该块中包含的规则处理，<code class="du kv kw kx km b">foo.bar.com/foo</code>将路由到端口<code class="du kv kw kx km b">80</code>上的服务<code class="du kv kw kx km b">s1</code>，对<code class="du kv kw kx km b">foo.bar.com/bar</code>的请求将路由到端口<code class="du kv kw kx km b">80</code>上的服务<code class="du kv kw kx km b">s2</code>。</p><h1 id="7f31" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">文件中未明确列出的变更</h1><p id="085b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj">所有主机</strong></p><p id="0ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个例子</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="bc68" class="kq jf hi km b fi kr ks l kt ku">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>    ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /bar<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80</span></pre><p id="6ddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">默认后端</strong> <br/>文档讨论了一个<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#single-service-ingress" rel="noopener ugc nofollow" target="_blank">单一服务入口</a>选项，没有规则。您可以将它与路径规则结合起来，用附加规则定义您自己的默认后端。这里有一个例子。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="24cb" class="kq jf hi km b fi kr ks l kt ku">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>    ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  backend:<br/>    serviceName: testsvc<br/>    servicePort: 80<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /bar<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80</span></pre><p id="7146" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，对这个入口的任何请求用<code class="du kv kw kx km b">/foo</code>转到服务<code class="du kv kw kx km b">s1</code>，对<code class="du kv kw kx km b">/bar</code>的任何请求将路由到<code class="du kv kw kx km b">s2</code>，所有其他请求将路由到<code class="du kv kw kx km b"> testsvc</code></p><blockquote class="ky kz la"><p id="92b1" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">需要注意的是，如果你没有定义一个默认的后端，Kubernetes会在后台为你创建一个。此外，为您创建的后端仅存在于一个集群中，稍后查看在GCP创建的负载平衡器后端时，您会看到这一点。</p></blockquote><h1 id="c521" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">全球知识产权</h1><p id="02ff" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这是全球入口的另一个重要点。你需要明确地创建和使用谷歌的全球IP。创建的默认临时IP仅是区域性的，无法支持来自不同地区的后端服务。</p><blockquote class="ky kz la"><p id="c534" class="if ig lb ih b ii ij ik il im in io ip lc ir is it ld iv iw ix le iz ja jb jc hb bi translated">我花了很长时间在这上面，不要错过它</p></blockquote><p id="4502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从命令行创建一个全局IP</p><p id="3262" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kv kw kx km b">gcloud compute addresses create ingress-ip --global</code></p><p id="b7b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在ingress.yaml中将其作为注释引用，如下所示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8993" class="kq jf hi km b fi kr ks l kt ku">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>    kubernetes.io/ingress.global-static-ip-name: ingress-ip      <br/>    ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  backend:<br/>    serviceName: testsvc<br/>    servicePort: 80<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /bar<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80</span></pre><h1 id="ecc5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">入口注释</h1><p id="12f3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在入口定义的元数据部分，可以提供各种注释来帮助kubernetes更好地理解您的意图。</p><p id="8c28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">入口控制器</strong> <br/>根据您部署kubernetes的位置和方式，您可以选择在您提供的入口yaml定义上实际执行什么。许多文档将nginx称为入口控制器，但是对于这个例子，我将展示如何使用本地GCE。</p><p id="b9da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然不是必需的，但是添加一个注释来指出您打算使用哪个控制器是一个很好的做法。例如，如果在给定的环境中有多个选项，这是很有帮助的</p><p id="cfcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我想为这个入口控制器使用GCE，所以我将使用<code class="du kv kw kx km b">kubernetes.io/ingress.class: “gce”</code>注释显式地指定它</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8d54" class="kq jf hi km b fi kr ks l kt ku">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>     kubernetes.io/ingress.class: "gce"<br/>    ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  backend:<br/>    serviceName: testsvc<br/>    servicePort: 80<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /bar<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80</span></pre><h1 id="8ebc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">健康检查</h1><p id="7cca" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">默认情况下，ingress将通过ping您的服务的根来设置loadblancer健康检查。如果您选择不在服务中发送“/”，了解这一点很重要。为确保您的应用程序正确注册其健康状态，请提供一个“/”路径或<a class="ae jd" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="noopener ugc nofollow" target="_blank">根据您的需求配置活性和就绪探测器</a>。</p><p id="0887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，我最终只在应用程序中留下了根上下文</p><h1 id="19a1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">节点端口</h1><p id="8ec2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这是另一个在完成后完全有意义的项目。首先，使用GCE入口控制器需要一个通过NodePort公开的服务，它不能仅仅是ClusterIP。其次，当在联合集群中部署时，容器的节点端口需要在所有集群中相同，因此我们需要显式地定义它。默认情况下，每个容器都会为NodePort类型提供一个随机端口，但是在联邦模型中，我们需要它们是相同的，这样健康检查才是准确的。一旦启动并运行，您将看到运行状况检查在所有节点上为您的应用程序轮询同一个端口。</p><p id="db7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了定义这一点，我们将在部署的服务定义中指定我们想要的确切值。这里有一个例子</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d096" class="kq jf hi km b fi kr ks l kt ku">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: s1<br/>  labels:<br/>    app: app1<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>  - port: 80<br/>    nodePort: 30041<br/>  selector:<br/>    app: app1</span></pre><p id="324d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要为每个服务定义不同的节点端口，这样就不会发生冲突</p><h1 id="3f58" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">路径</strong>上下文</h1><p id="b33c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这可能是我遇到的最烦人的问题，只有在一个真正的应用中才会出现。到目前为止，所有的演示和hello world应用程序都运行良好。<code class="du kv kw kx km b">/foo</code>到<code class="du kv kw kx km b">svc1</code>的路线，<code class="du kv kw kx km b">/bar</code>到<code class="du kv kw kx km b">svc2</code>的路线。然而，当我部署一个真正的应用程序时，事情就不那么清楚了。我将获得我的服务的主页，但其他一切都将恢复到默认的负载平衡器。开始发现有一个【入口的怪癖】(<a class="ae jd" href="https://github.com/kubernetes/contrib/issues/885" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/contrib/issues/885</a>)Nginx和GCE入口控制器的工作方式不一样。</p><p id="1dac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上在Nginx上，<code class="du kv kw kx km b">/foo</code>正在寻找前缀为<code class="du kv kw kx km b">/foo</code>的任何东西，gce控制器将它视为显式映射。要解决这个问题，我们需要添加*映射到入口yaml中的规则路径，如下所示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7853" class="kq jf hi km b fi kr ks l kt ku">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>     kubernetes.io/ingress.class: "gce"<br/>    ## ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  backend:<br/>    serviceName: testsvc<br/>    servicePort: 80<br/>  rules:<br/>  - http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /foo/*<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /bar<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80<br/>      - path: /bar/*<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80</span></pre><p id="9029" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过添加额外的映射，对<code class="du kv kw kx km b">/foo</code>或<code class="du kv kw kx km b">/foo/baz/bar</code>的任何请求将正确地路由到服务<code class="du kv kw kx km b">s1</code>，对<code class="du kv kw kx km b">/bar</code>或<code class="du kv kw kx km b">/bar/baz/foo</code>的请求将路由到服务<code class="du kv kw kx km b">s2</code></p><h1 id="db7a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">集群平衡</h1><p id="f632" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在大多数情况下，kubernetes会尝试平衡集群，这样应用程序会均匀地分布在集群中，但是您可以使用如下的<code class="du kv kw kx km b">federation.kubernetes.io/deployment-preferences:</code>注释来反映您的意图</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0dd1" class="kq jf hi km b fi kr ks l kt ku">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  name: app1<br/>spec:<br/>  replicas: 4<br/>  template:<br/>    metadata:<br/>      annotations:<br/>        federation.kubernetes.io/deployment-preferences: |<br/>          {<br/>            "rebalance": true,<br/>            "clusters": {<br/>              "east-cluster": {<br/>                  "minReplicas": 1<br/>              },<br/>              "west-cluster": {<br/>                  "minReplicas": 1<br/>              }<br/>            }<br/>          }<br/>      labels:<br/>        app: app1<br/>    spec:<br/>      containers:<br/>        - name: app1<br/>          image: myrepo/appi:v7<br/>          ports:<br/>            - containerPort: 80<br/>          resources:<br/>            requests:<br/>              cpu: 100m<br/>              memory: 100Mi</span></pre><p id="b9b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的注释要求kubernetes重新平衡并在东部和西部各保留一个副本。</p><h1 id="46c5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="176c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Kubernetes入口控制器是一个强大的工具。几乎没有额外的洞察力，他们也成为一个简单的管理资源。利用GCE控制器类型，您可以在Google Container Engine上快速轻松地实现ingress，而不需要额外的资源。</p><p id="4793" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这能有所帮助，请务必查看<a class="ae jd" rel="noopener" href="/google-cloud/global-kubernetes-in-3-steps-on-gcp-8a3585ec8547">设置指南</a>和<a class="ae jd" rel="noopener" href="/@cgrant/global-ingress-in-practice-on-google-container-engine-part-2-demo-cf587765702">端到端演示</a>。</p></div></div>    
</body>
</html>