<html>
<head>
<title>Preserving Client IPs through Google Cloud’s global TCP and SSL Proxy Load Balancers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Google Cloud的全球TCP和SSL代理负载平衡器保护客户端IP</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/preserving-client-ips-through-google-clouds-global-tcp-and-ssl-proxy-load-balancers-3697d76feeb1?source=collection_archive---------0-----------------------#2020-12-24">https://medium.com/google-cloud/preserving-client-ips-through-google-clouds-global-tcp-and-ssl-proxy-load-balancers-3697d76feeb1?source=collection_archive---------0-----------------------#2020-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d4d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您构建包含反向代理(代表客户端连接到后端服务器的系统)的网络架构时，原始客户端请求的IP地址很可能在代理处“丢失”。如果您需要后端服务器上的客户端IP地址用于基于IP的客户端白名单/黑名单(例如游戏服务器)，用于基于IP的二级客户端身份验证，用于记录客户端请求或用于故障排除，这将是一个问题。</p><p id="9a2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud为TCP和SSL的全局负载平衡提供反向代理。在本文中，我将首先一步一步地向您展示如何使用在TCP有效负载中保留客户机IP地址的配置来配置这些负载平衡器。然后，我们将了解如何使用名为<a class="ae jd" href="https://github.com/path-network/go-mmproxy" rel="noopener ugc nofollow" target="_blank"> go-mmproxy </a>的OSS解决方案，结合GCP代理负载平衡器，将客户端IP透明地传递给运行在后端服务器上的应用程序。</p><p id="65ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> GCP TCP和SSL代理负载均衡</strong></p><p id="ba12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌云的<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/tcp" rel="noopener ugc nofollow" target="_blank"> TCP代理负载平衡器</a>和<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/ssl" rel="noopener ugc nofollow" target="_blank"> SSL代理负载平衡器</a>非常适合在全球范围内提供应用和服务。用户连接在负载平衡层终止，然后代理到后端实例。对于SSL代理负载平衡器，您可以在SSL和TCP之间选择从代理到后端服务器的连接。请注意，即使对于代理和后端服务器之间的TCP连接，到后端服务器的<a class="ae jd" href="https://cloud.google.com/security/encryption-in-transit#automatic_encryption_between_gfes_and_backends" rel="noopener ugc nofollow" target="_blank">流量也将被加密</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/2eabd518474ae5ef797eb95b7d078cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45J4wdAXv13LPgBAmM0X4Q.png"/></div></div></figure><p id="a291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GCP的全球TCP和SSL代理负载平衡器具有以下优势</p><ul class=""><li id="12dc" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">有了对任播IP的支持，您可以对全球所有用户使用一个外部IP地址，同时流量被路由到地理上离用户最近的后端</li><li id="02ca" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">如果一个区域的容量已满，新的连接将自动定向到另一个具有可用容量的区域</li><li id="9175" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">TCP和SSL代理负载平衡器可以终止IPv6连接</li><li id="b331" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">如果您对代理到后端的流量使用TCP，SSL代理负载平衡器可以保护不提供本地SSL支持的应用程序</li></ul><p id="0b6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您不确定TCP代理负载平衡器是否适合您的架构，GCP官方文档中的第<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/choosing-load-balancer" rel="noopener ugc nofollow" target="_blank">页</a>可以帮助您确定最适合您的用例的解决方案。</p><p id="e6ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TCP和SSL代理负载平衡不太适合HTTP(S)流量。对于HTTP(S)流量，使用外部<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/https" rel="noopener ugc nofollow" target="_blank"> HTTP(S)负载平衡</a>。使用HTTP(S)负载平衡器时，保留原始客户端IP也不成问题，因为它会在X-Forwarded-For标头中透明地设置客户端的IP地址。</p><p id="276c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> GCP TCP和SSL代理负载均衡概念</strong></p><p id="3f44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与上面的简化图不同，负载平衡器实际上包括多个组件。让我们放大一下将要配置的GCP结构。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ke"><img src="../Images/c8f973f737711999e86370f405999e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*704dYzlpW5_hf8oTSJ34AA.png"/></div></figure><p id="124b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对已配置端口上保留的外部IP的传入请求被转发到全局转发规则中定义的目标TCP/SSL代理。目标TCP/SSL代理终止TCP/SSL连接，并将流量转发到相关的后端服务。如果进行了相应的配置，目标TCP/SSL代理会将客户端IP保存在<a class="ae jd" href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" rel="noopener ugc nofollow" target="_blank">代理头</a>中。全局后端服务定义了如何分配流量，将流量路由到地理上最近的具有资源可用性的区域中的实例组。全局后端服务与实例组相关联，实例组是接受服务请求的所有虚拟机的区域分组。实例组被单独添加到后端服务中，每个实例组的负载平衡方案可以在添加到后端服务时指定。通过更新后端服务的运行状况检查来监控各个节点。</p><p id="beed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关更多详细信息，请查看GCP文档，其中提供了<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/tcp" rel="noopener ugc nofollow" target="_blank"> TCP代理负载平衡概述</a>和<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/ssl" rel="noopener ugc nofollow" target="_blank"> SSL代理负载平衡概述</a>。</p><p id="e6ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">配置和测试TCP和SSL代理负载平衡</strong></p><p id="c06b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，我们将在负载平衡器后面设置一个后端服务器。这种基本配置可以通过在不同地理位置添加实例组和虚拟机来轻松扩展，按照Google Cloud文档设置<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/tcp/setting-up-tcp" rel="noopener ugc nofollow" target="_blank"> TCP </a>和<a class="ae jd" href="https://cloud.google.com/load-balancing/docs/ssl/setting-up-ssl" rel="noopener ugc nofollow" target="_blank"> SSL </a>代理负载平衡器。</p><p id="2ba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">若要遵循，您必须能够在项目中创建实例和修改网络。您必须是项目所有者或编辑者，或者必须拥有以下所有计算引擎IAM角色</p><ul class=""><li id="9464" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><a class="ae jd" href="https://cloud.google.com/compute/docs/access/iam#compute.networkAdmin" rel="noopener ugc nofollow" target="_blank">网络管理员</a></li><li id="f255" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><a class="ae jd" href="https://cloud.google.com/compute/docs/access/iam#compute.securityAdmin" rel="noopener ugc nofollow" target="_blank">安全管理员</a></li><li id="e329" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><a class="ae jd" href="https://cloud.google.com/compute/docs/access/iam#compute.instanceAdmin" rel="noopener ugc nofollow" target="_blank">计算实例管理</a></li></ul><p id="cc8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> TCP和SSL代理</em></p><p id="c60c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先创建后端虚拟机实例</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="f2f8" class="kl km hi kh b fi kn ko l kp kq">gcloud compute instances create my-backend --image-project centos-cloud --image-family centos-7 --tags tcp-lb --zone us-central1-b</span></pre><p id="ff61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们创建一个实例组</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="bef3" class="kl km hi kh b fi kn ko l kp kq">gcloud compute instance-groups unmanaged create my-instance-group --zone us-central1-b</span></pre><p id="833a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为实例组创建一个命名的TCP端口，它是负载平衡器将流量定向到的端口的别名。我们将在稍后设置后端服务时使用这个命名端口。在本例中，我们选择了端口110。由于go-mmproxy不支持SSL/TLS，我们使用TCP进行SSL代理的代理到后端连接。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="5f96" class="kl km hi kh b fi kn ko l kp kq">gcloud compute instance-groups set-named-ports my-instance-group --named-ports tcp110:110 --zone us-central1-b</span></pre><p id="0b65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将后端虚拟机添加到实例组中。在真实的用例中，我们将在这里添加多个实例。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="7b3e" class="kl km hi kh b fi kn ko l kp kq">gcloud compute instance-groups unmanaged add-instances my-instance-group --instances my-backend --zone us-central1-b</span></pre><p id="3bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在有了一个实例组，该实例组公开了端口110，我们可以配置负载平衡器了。我们在端口110上创建健康检查。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="fef8" class="kl km hi kh b fi kn ko l kp kq">gcloud compute health-checks create tcp my-tcp-health-check --port 110</span></pre><p id="8c93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为实例组创建的命名端口tcp110创建了TCP的全局后端服务</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="f444" class="kl km hi kh b fi kn ko l kp kq">gcloud compute backend-services create my-tcp-lb --global-health-checks --global --protocol TCP --health-checks my-tcp-health-check --timeout 5m --port-name tcp110</span></pre><p id="2c66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以将实例组添加到后端服务中。我们将UTILIZATION指定为负载平衡方案，用于平衡实例组内实例间的流量。max-utilization定义后端实例组中后端实例平均利用率的最大目标。我们选择80%，这意味着如果平均利用率超过80%，流量将被重定向到其他实例组。有关更多详细信息，请查看添加后端的<a class="ae jd" href="https://cloud.google.com/sdk/gcloud/reference/compute/backend-services/add-backend" rel="noopener ugc nofollow" target="_blank"> gcloud文档</a>。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="2ab7" class="kl km hi kh b fi kn ko l kp kq">gcloud compute backend-services add-backend my-tcp-lb --global --instance-group my-instance-group --instance-group-zone us-central1-b --balancing-mode UTILIZATION --max-utilization 0.8</span></pre><p id="0e1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> TCP代理</em></p><p id="a07e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建目标TCP代理，指定我们需要在代理头中保留客户机IP</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="467b" class="kl km hi kh b fi kn ko l kp kq">gcloud compute target-tcp-proxies create my-tcp-lb-target-proxy --backend-service my-tcp-lb --proxy-header PROXY_V1</span></pre><p id="2f81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> SSL代理</em></p><p id="f5ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于SSL，我们需要从我们的证书文件中创建一个GCP SSL证书。fullchain.pem是我为我的域mypocketxp.com公开信任的x509证书，由<a class="ae jd" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密认证机构</a>生成。privkey.pem是相应的私钥。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="29e0" class="kl km hi kh b fi kn ko l kp kq">gcloud compute ssl-certificates create my-ssl-cert --certificate fullchain.pem --private-key privkey.pem</span></pre><p id="ca63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建一个SSL策略，指定服务器端对客户端和SSL代理负载平衡器之间连接的SSL特性的支持。MODERN profile支持广泛的SSL特性，允许modern clients协商SSL。要了解更多细节，请查看gcloud <a class="ae jd" href="https://cloud.google.com/sdk/gcloud/reference/compute/ssl-policies/create" rel="noopener ugc nofollow" target="_blank">关于SSL策略的文档</a>。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="9fa2" class="kl km hi kh b fi kn ko l kp kq">gcloud compute ssl-policies create my-ssl-policy --profile MODERN --min-tls-version 1.0</span></pre><p id="f666" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建SSL目标代理，通过代理头保留客户机IP，链接我们的证书并应用我们的SSL策略</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="0bd9" class="kl km hi kh b fi kn ko l kp kq">gcloud compute target-ssl-proxies create my-ssl-lb-target-proxy --backend-service my-tcp-lb --ssl-certificates my-ssl-cert --ssl-policy my-ssl-policy --proxy-header PROXY_V1</span></pre><p id="b501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> TCP和SSL代理</em></p><p id="68ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于SSL和TCP代理，我们保留我们的全球任播IP。在本例中，我们只分配了一个IPv4地址</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="f974" class="kl km hi kh b fi kn ko l kp kq">gcloud compute addresses create lb-static-ipv4 --ip-version=IPV4 --global</span></pre><p id="3724" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们查找保留的IP地址并配置全局转发规则</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="f522" class="kl km hi kh b fi kn ko l kp kq">gcloud compute addresses list</span></pre><p id="cad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> TCP代理</em></p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="7fb8" class="kl km hi kh b fi kn ko l kp kq">gcloud compute forwarding-rules create my-tcp-lb-ipv4-forwarding-rule --global --target-tcp-proxy my-tcp-lb-target-proxy --address &lt;reserved IP address&gt; --ports 110</span></pre><p id="6c0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> SSL代理</em></p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="8298" class="kl km hi kh b fi kn ko l kp kq">gcloud compute forwarding-rules create my-ssl-lb-ipv4-forwarding-rule --global --target-ssl-proxy my-ssl-lb-target-proxy --address &lt;reserved IP address&gt; --ports 110</span></pre><p id="f57b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> TCP和SSL代理</em></p><p id="322d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于SSL和TCP代理，我们需要启用从代理到后端虚拟机的流量。我们创建了一个防火墙规则，将GCP代理用于代理到虚拟机连接以及运行状况检查的源IP列入白名单。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="96be" class="kl km hi kh b fi kn ko l kp kq">gcloud compute firewall-rules create allow-lb-and-health --source-ranges 130.211.0.0/22,35.191.0.0/16 --target-tags tcp-lb --allow tcp:110</span></pre><p id="4db2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> TCP代理</em></p><p id="9a89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于TCP转发的基本测试，我们登录到后端服务器，并在我们的后端服务器上安装<a class="ae jd" href="https://iperf.fr/" rel="noopener ugc nofollow" target="_blank"> iperf </a>，这是一个广泛用于网络性能测量和调优的工具</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="a48d" class="kl km hi kh b fi kn ko l kp kq">gcloud compute ssh my-backend --zone us-central1-b</span><span id="6029" class="kl km hi kh b fi kr ko l kp kq">sudo yum install -y iperf</span></pre><p id="f3c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们在后端服务器上以服务器模式启动iperf</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="46d5" class="kl km hi kh b fi kn ko l kp kq">sudo iperf -s -p 110</span></pre><p id="1f25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约五秒钟后，您将会看到类似这样的条目，显示来自端口110上的健康检查的连接尝试，这是对后端服务的健康检查。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ks"><img src="../Images/7cabdf6e679ae8154037fd95830ea0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/0*B-BI-wl3HsfP8cuE"/></div></figure><p id="7172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以从客户端(即我们的本地系统)连接，通过代理检查与后端的连接</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="f4ce" class="kl km hi kh b fi kn ko l kp kq">iperf -c &lt;reserved address&gt; -p 110</span></pre><p id="f3bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约5-10秒后，我们看到连接已经建立，性能测试的数据已经交换。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kt"><img src="../Images/a536f04ef74f1d9ed3e42d284a65fe46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*AlR83YvutohSvP5Z"/></div></figure><p id="99ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在服务器端，您会看到一个如下所示的日志条目，表明与一个对等机建立了连接。我们看不到源IP，因为iperf忽略了TCP有效负载中的代理报头，只看到来自代理使用的IP范围(35.191.0.0/16)内的IP的连接。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/4e21c591330f6257c5626eff56ab797a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G7_0SZ-LhEmdUuSc"/></div></div></figure><p id="1341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> SSL代理</em></p><p id="9050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于iperf不支持SSL，我们需要以不同的方式测试SSL代理。使用下面的小python客户端代码，我们可以向后端服务器发送“Hello，world”。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="a329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码使用Python <a class="ae jd" href="https://docs.python.org/3/library/ssl.html" rel="noopener ugc nofollow" target="_blank"> SSL模块</a>为套接字对象提供TLS/SSL包装器。server_name必须与x509证书的“主题”行或“主题备用名”(SAN)中的公用名(CN)相匹配。您可以通过以下方式检查证书的内容</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="a50c" class="kl km hi kh b fi kn ko l kp kq">openssl x509 -in &lt;certificate file&gt; -text -noout</span></pre><p id="c44a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们想要验证根CA，所以我们使用load_verify_locations()将包含根CA证书的文件传递给SSL上下文。</p><p id="43f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要识别根CA的x509证书文件，您可以运行</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="9fd7" class="kl km hi kh b fi kn ko l kp kq">openssl s_client -connect &lt;reserved IP address&gt;:110</span></pre><p id="11ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用我们保留的IP地址并附加到上面的转发规则。这将向您显示信任根的证书链。在我的例子中，我看到一个带有一个中间证书的链:“DST根CA X3”→“让我们加密权威X3”→“mypocket XP . com”。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/ae7ec4326f54d140b69c7c1f62430c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*zFJyZNMgmrFlMlbe"/></div></div></figure><p id="9f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的笔记本电脑(Ubuntu 18.04.5 LTS)上，我可以在/etc/ssl/certs中找到根CA的证书文件DST_Root_CA_X3.pem。如果你找不到根CA证书文件，你可以使用根CA的CN搜索像<a class="ae jd" href="https://www.identrust.com/" rel="noopener ugc nofollow" target="_blank"> IdenTrust </a>这样的网站，在我们的例子中是DST根CA X3’，然后下载文件。然后你可以在这里安装证书<a class="ae jd" href="https://support.nmi.com/hc/en-gb/articles/360021544791-How-to-Check-If-the-Correct-Certificates-Are-Installed-on-Linux#Importing%20Missing%20Certificates" rel="noopener ugc nofollow" target="_blank">。您还可以在这篇</a><a class="ae jd" rel="noopener" href="/@superseb/get-your-certificate-chain-right-4b117a9c0fce">中型文章</a>中找到一篇关于证书验证的精彩文章。</p><p id="fe1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试连通性，我们在后端将ncat作为“服务器”运行。与nmap软件包一起安装的ncat</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="6dff" class="kl km hi kh b fi kn ko l kp kq">yum install -y nmap</span></pre><p id="3134" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ncat监听端口110。k选项确保ncat不会在连接关闭后终止</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="a83a" class="kl km hi kh b fi kn ko l kp kq">sudo ncat -v -l -k -p 110</span></pre><p id="d29d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们在本地主机上运行我们的客户端程序时，我们看到代理头显示了我们的客户端IP 209.52.88.4以及我们的消息。源IP 35.191.10.112是代理范围内的一个IP。消息上方和下方显示的连接是运行状况检查连接。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ky"><img src="../Images/4c7a6e446c5c033667f2be24c572a14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/0*vg5Lj1SfBihmT1hH"/></div></figure><p id="4344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您希望ncat绑定到特权端口，而不是以root用户身份运行，您可以为ncat设置<a class="ae jd" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank"> Linux功能</a> cap_net_bind_service</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="7ea3" class="kl km hi kh b fi kn ko l kp kq">setcap 'cap_net_bind_service=+eip' /usr/bin/ncat</span></pre></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="46d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Go-mmproxy </strong></p><p id="2a77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这种负载平衡配置通过代理标头保留了原始的客户端IP，但是我们如何将标头中的信息传递给后端服务器上的应用程序呢？理想情况下，我们希望这对于应用程序是完全透明的。这就是<a class="ae jd" href="https://github.com/path-network/go-mmproxy" rel="noopener ugc nofollow" target="_blank"> go-mmproxy </a>发挥作用的地方。</p><p id="f5c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">go-mmproxy是一个独立的应用程序，我们在后端服务器上运行。它监听远程连接，在我们的例子中是来自GCP代理负载平衡器。在为新的输入TCP连接完成TCP握手之后，go-mmproxy从第一个输入分组的有效载荷中读取<a class="ae jd" href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" rel="noopener ugc nofollow" target="_blank">代理协议报头</a>。Go-mmproxy然后创建一个新的套接字，<a class="ae jd" href="https://man7.org/linux/man-pages/man2/bind.2.html" rel="noopener ugc nofollow" target="_blank">将</a>绑定到它在代理协议头中找到的源IP。接下来，go-mmproxy使用此套接字在go-mmproxy启动时指定的端口上打开到主机环回网络接口(lo，IP 127.0.0.1)的连接。对于侦听该端口的应用程序，传入的连接将原始TCP客户端IP作为源地址。换句话说，go-mmproxy欺骗了连接的源IP，因此通过go-mmproxy到应用程序的连接似乎来自原始的TCP客户端IP地址。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lg"><img src="../Images/4bdd5d7581ffe8d46f018cbbd227a9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cPc9deAo6Vy2rrZ-"/></div></div></figure><p id="9b50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然本文的重点是将go-mmproxy用于TCP，但go-mmproxy也支持UDP流量。有关go-mmproxy实现细节的更多信息，请查看Cloudflare的<a class="ae jd" href="https://github.com/cloudflare/mmproxy" rel="noopener ugc nofollow" target="_blank"> mmproxy </a>上的这个<a class="ae jd" href="https://blog.cloudflare.com/mmproxy-creative-way-of-preserving-client-ips-in-spectrum/" rel="noopener ugc nofollow" target="_blank">博客</a>，它启发了go-mmproxy以及这篇<a class="ae jd" href="https://idea.popcount.org/2014-04-03-bind-before-connect/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="09be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在GCP上设置go-mm proxy</strong></p><p id="cd90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在基于Debian的系统上，有一个预构建的<a class="ae jd" href="https://manpages.debian.org/testing/go-mmproxy/go-mmproxy.1.en.html" rel="noopener ugc nofollow" target="_blank"> go-mmproxy包</a>可用。否则我们需要在我们的后端系统上安装git。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="9cfb" class="kl km hi kh b fi kn ko l kp kq">sudo yum install -y git</span></pre><p id="f268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们下载Go构建环境…</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="5ff6" class="kl km hi kh b fi kn ko l kp kq">curl -o go1.15.5.linux-amd64.tar.gz <a class="ae jd" href="https://dl.google.com/go/go1.15.5.linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank">https://dl.google.com/go/go1.15.5.linux-amd64.tar.gz</a></span></pre><p id="e04e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…并解压缩安装在/usr/local中的tarball</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="9a7a" class="kl km hi kh b fi kn ko l kp kq">sudo tar -C /usr/local -xzf go1.15.5.linux-amd64.tar.gz</span></pre><p id="c905" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Go现在已经安装好了，我们现在只需要把它添加到我们。bashrc或您喜欢的shell初始化脚本</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="7049" class="kl km hi kh b fi kn ko l kp kq">export PATH=$PATH:/usr/local/go/bin</span></pre><p id="a1aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用一个快速的“Hello，World”示例来测试安装，如这里的<a class="ae jd" href="https://linuxize.com/post/how-to-install-go-on-centos-7/#test-the-installation" rel="noopener ugc nofollow" target="_blank">所示</a>。</p><p id="d31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以提取go-mmproxy代码，并使用一个命令进行构建</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="f732" class="kl km hi kh b fi kn ko l kp kq">go get github.com/path-network/go-mmproxy</span></pre><p id="dcb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">go-mmproxy二进制文件位于go/bin子目录中。在启动go-mmproxy之前，我们需要修改后端服务器上的路由表。来自后端服务器上的应用程序的传出流量默认被路由到默认的互联网网关。该流量需要通过环回接口从应用程序路由回go-mmproxy。我们创建一个自定义路由表，强制将来自应用程序的返回流量路由到loopback lo，以便go-mmproxy可以将其作为来自loopback接口的传入流量进行处理。</p><p id="4a31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此命令确保表100中的自定义路由应用于来自应用程序的所有传出数据包</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="1901" class="kl km hi kh b fi kn ko l kp kq">sudo ip -4 rule add from 127.0.0.1/8 iif lo table 100</span></pre><p id="2155" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在表100中，我们将所有本地流量重定向回环回接口，而不考虑目的地IP (0.0.0.0 ),以支持go-mmproxy的处理。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="3405" class="kl km hi kh b fi kn ko l kp kq">sudo ip route add local 0.0.0.0/0 dev lo table 100</span></pre><p id="0fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要创建一个包含go-mmproxy接受流量的IP范围的文件。在我们的例子中，这些是GCP代理负载平衡器使用的IP范围。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="7965" class="kl km hi kh b fi kn ko l kp kq">echo 35.191.0.0/16 &gt; gcp-tcp-proxy-ip-range<br/>echo 130.211.0.0/22 &gt;&gt; gcp-tcp-proxy-ip-range</span></pre><p id="ce0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们启动go-mmproxy监听端口110，并将流量转发到端口112。我们需要以root用户身份启动，因为我们正在使用特权端口。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="e99b" class="kl km hi kh b fi kn ko l kp kq">sudo ./go/bin/go-mmproxy -l 0.0.0.0:110 -4 127.0.0.1:112 --allowed-subnets ./gcp-tcp-proxy-ip-range</span></pre><p id="cd4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> TCP代理</em></p><p id="4e59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们等待片刻，以确保GCP TCP代理健康检查已经注意到go-mmproxy正在侦听端口110，将实例组标记为健康。我们在后端服务器上启动iperf，监听端口112</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="a4b6" class="kl km hi kh b fi kn ko l kp kq">sudo iperf -s -p 112</span></pre><p id="cc69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并从客户端启动会话。保留地址是我们为全局TCP代理保留的IP，可通过“gcloud compute addresses list”获得</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="67fa" class="kl km hi kh b fi kn ko l kp kq">iperf -c &lt;reserved IP address&gt; -p 110</span></pre><p id="4537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在客户端，您应该会看到类似如下的输出</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lh"><img src="../Images/6f214c7437c2566ec2addc86fe3c1ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/0*9VW6yL3y3oq8VrMj"/></div></figure><p id="8e81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在服务器端，您将在端口112上看到来自原始客户端IP的连接</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es li"><img src="../Images/13c151219523257a228ed0f23dd1baf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/0*6ISZriY5LLHTq2Qr"/></div></figure><p id="6515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf"> SSL代理</em></p><p id="1859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试SSL代理，我们再次依赖我们的Python客户机和ncat。我们在后端服务器的端口112上启动ncat监听</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="b5ba" class="kl km hi kh b fi kn ko l kp kq">sudo ncat -v -l -k -p 112</span></pre><p id="b007" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并从本地客户端发送我们的消息。我们看到ncat将原始客户端IP记录为源地址</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lj"><img src="../Images/168b12b854a03a84f3ab667a43a83801.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/0*d57jgVPlTj0ogqYy"/></div></figure><p id="6f53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们一直以root用户身份运行go-mmproxy，就像我们使用特权端口(端口1–1023)一样。如果您担心这个问题，您应该担心，您可以使用非特权端口，并将CAP_NET_ADMIN <a class="ae jd" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank"> Linux功能</a>分配给go-mmproxy二进制文件。这并不是100%安全，但至少与以root用户身份运行可执行文件相比，潜在的爆炸半径更小。如果你想了解更多关于setcap的信息，看看这篇文章。</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="e79b" class="kl km hi kh b fi kn ko l kp kq">sudo setcap cap_net_admin+eip ./go/bin/go-mmproxy</span></pre><p id="1d31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意事项</strong></p><p id="e5d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的测试中，所提出的解决方案运行良好。在使用go-mmproxy测试GCPs TCP/SSL代理负载均衡器之前，有一些注意事项需要考虑</p><ul class=""><li id="34e0" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">TCP和SSL代理负载平衡仅支持端口25、43、110、143、195、443、465、587、700、993、995、1883、3389、5222、5432、5671、5672、5900、5901、6379、8085、8099、9092、9200和9300</li><li id="cd1b" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">我只测试了Redhat 7/CentOS 7后端服务器的设置</li><li id="cff7" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">有一个性能影响—来自path.net的<a class="ae jd" href="https://blog.path.net/introducing-go-mmproxy/" rel="noopener ugc nofollow" target="_blank">基准测试</a>显示吞吐量带宽大约有20%的性能影响</li></ul><p id="17c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="fc63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文的第一部分中，我们介绍了全局GCP TCP/SSL代理负载平衡器的基本配置。我们展示了如何通过在GCP的目标TCP/SSL代理上启用代理协议头来保留TCP有效负载中的客户端IP。在本文的第二部分中，我们看到了如何部署go-mmproxy来解开这个代理协议头，并为运行在后端服务器上的应用程序伪造原始的TCP客户机IP。</p><p id="3ce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新</strong></p><p id="2eb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使事情变得更简单，我编写了一个简单的启动脚本，它可以自动设置路由表，为连接日志配置rsyslogd和iptables，将编译好的go-mmproxy复制到/tmp并启动go-mmproxy。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="7d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该脚本在一个公共可读的桶中。如果您使用这个gcloud命令行创建一个虚拟机</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="0497" class="kl km hi kh b fi kn ko l kp kq">gcloud compute instances create my-backend --image-project centos-cloud --image-family centos-7 --tags tcp-lb --zone us-central1-b --metadata=startup-script-url="gs://startup-script-proxy/gommproxy-startup.bash"</span></pre><p id="6944" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切都“自动”运转。</p></div></div>    
</body>
</html>