<html>
<head>
<title>Load balancing with IPVS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过IPVS实现负载平衡</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/load-balancing-with-ipvs-1c0a48476c4d?source=collection_archive---------1-----------------------#2022-11-08">https://medium.com/google-cloud/load-balancing-with-ipvs-1c0a48476c4d?source=collection_archive---------1-----------------------#2022-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5972153f101bd0851e313d22b17f5f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bFQBByA8sfjlYMEFuD8Vvw.png"/></div></figure><p id="97f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">IP虚拟服务器(IPVS)直接在Linux内核中实现L4负载平衡。我需要让它在GCP发挥作用，心想这不会那么难。我有些头疼，但也很开心:)</p><h1 id="b0c0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">当生活变得容易时</h1><p id="0cec" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">像GCP这样的云环境非常好。最初，这有点令人困惑，因为网络还有其他的<em class="jk">规则</em>，但是你会开始喜欢它提供的所有抽象概念。例如，实现L4负载平衡是通过一种您可以配置的服务来完成的，但大多数情况下您会忘记，它就是有效的。</p><p id="fb46" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嗯，没错，这可能并不总是那么容易。但是除了检查配置之外，很少有情况下需要更深入地进行调试。有时候我需要求助于<em class="jk"> tcpdump </em>(我真的很喜欢)，这个故事就是这样开始的。但我没想到会是怎样的结局。</p><p id="707c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">手头的任务，运行L4负载平衡器。在云环境中，有时您无法完全获得所需的服务。在这种情况下，原因并不重要，我稍后会解释，但问题是我(我的客户)决定使用IPVS。它是<a class="ae ko" href="http://www.linuxvirtualserver.org/" rel="noopener ugc nofollow" target="_blank"> Linux虚拟服务器</a>项目的一部分，它作为传输层负载平衡器运行在服务器主机上，提供单个VIP来访问真实服务器的服务。如果你不知道，Kubernetes的kube-proxy组件使用IPVS。</p><p id="f2dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这不会有那么难…</p><h1 id="7aa0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">试一试</h1><p id="eb0c" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">所以我去了。我用三个虚拟机部署了一个非常简单的设置，我喜欢在测试时从简单开始。一台客户机，IPVS的虚拟服务器，和一台真正的服务器(LVS称之为T9)。是的，只有一台真正的服务器，负载平衡不难…</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/0f402a8f5eac7a3a1271a1d2fc99804b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*tMeaQ0eXyejaJp_7EJHfgQ.png"/></div></figure><p id="7b46" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虚拟服务器具有IP 10.1.0.6，这是我配置的服务的VIP。真实的服务器运行一个简单的基于python的HTTP服务器，监听端口8085并发出<em class="jk"> Hello！</em>消息。我通常选择8085这样的端口，因为如果您需要捕获数据包，它不会与80或443这样的典型端口中的其他流量混合。为了测试它，客户端应该能够接触到它。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/3de621a47d6c49db17d91c6c68dd7f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NNKfH5goYz65TK_hlOzmg.png"/></div></div></figure><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kz"><img src="../Images/86109254ad94f89de4085913d5c8ea57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFJeggBG_V7Nfp2RJdr0pg.png"/></div></div></figure><p id="ad64" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我在虚拟服务器中配置了IPVS。首先，我安装了ipvsadm，这是在内核中配置IPVS的工具，用它我建立了一个新的指向真实服务器的IPVS服务。</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="5ba3" class="lf jm hi lb b fi lg lh l li lj">sudo apt-get install ipvsadm<br/>sudo ipvsadm -A -t 10.1.0.6:8085<br/>sudo ipvsadm -a -t 10.1.0.6:8085 -r 10.1.0.50 -m</span></pre><p id="ceae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">IPVS支持TCP和UDP、三种数据包转发方法(DSR、ipip或伪装)、多种负载平衡或调度算法以及许多其他选项。除了使用TCP进行测试(<code class="du lk ll lm lb b">-t</code>)，我只对伪装/NAT ( <code class="du lk ll lm lb b">-m</code>)感兴趣，因为其他转发方法，尤其是DSR，不太适合在GCP运行，也不适合我的目的。对于其他选项，我保留默认值。您可以在<a class="ae ko" href="https://linux.die.net/man/8/ipvsadm" rel="noopener ugc nofollow" target="_blank"> IPVS手册页</a>中找到更多信息。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ln"><img src="../Images/347429c550268c6d70feb67b481727b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvdK4BLVQm8aU4aDutheVQ.png"/></div></div></figure><p id="3c26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很简单。是时候测试我是否可以通过虚拟服务器的VIP从客户端访问真实的服务器了…</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lo"><img src="../Images/65a0805be41632ff3cbccd7451b5dc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezU1_4PlNl1qcKNvShcI6g.png"/></div></div></figure><p id="2859" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">失败！</em> </strong></p><p id="7b0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">两秒钟后看不到回应，你就知道有问题了。好了，不用担心，是时候使用tcpdump了。</p><h1 id="7d5d" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">伪装到底是什么</h1><p id="cbf6" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我想，转储数据包应该能告诉我发生了什么。在三个虚拟机中运行tcpdump应该能让您了解全部情况，但是我只向您展示从虚拟服务器捕获的内容，因为它处于流量的中间。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lp"><img src="../Images/6b123de8a577a5c26b1dd6bba6f10a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOuZBpz3EkNXsP_Js771eg.png"/></div></div></figure><p id="1647" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虚拟服务器从客户端10.1.0.3收到一个目的地为VIP 10 . 1 . 0 . 6的数据包；也看看港口。然后，IPVS开始将数据包传输到真正的服务器10.1.0.50，并通过网络发送出去。但是，嘿，那是什么？源IP地址，还是10.1.0.3！</p><p id="1de3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我以为我配置了<em class="jk">伪装</em>。对于熟悉iptables的人来说，Masquerade是一个类似于SNAT的目标，其中源IP被转换为转发数据包的主机的IP，在本例中是虚拟服务器。</p><p id="b046" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">事实证明，IPVS并不是这样运作的。IPVS只做DNAT，这在一个叫做双臂负载均衡的模型中很有用。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/82c90b0bffd20f0107bfac9a5763d209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*s8wNZLdDSvljaoV5CiYUwA.png"/></div></figure><p id="399b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">只要有一点想象力，你就能明白为什么它被称为双臂。负载平衡器充当每个网络上的一个臂的路由器，这些网络之间的所有流量都通过负载平衡器。</p><p id="630a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">非常有用的模型。避免SNAT可以保护客户端IP，避免端口分配和耗尽的问题。但不是我所需要的，也不是我所期待的！IPVS说它使用伪装转发，对我来说这是误导。</p><p id="2c79" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那现在怎么办？</p><h1 id="1024" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">回归根本</h1><p id="31a8" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在这里，我开始越来越深入，首先求助于iptables，并认为这就足够了。我已经很久没有研究过这些主题了…</p><h2 id="921a" class="lf jm hi bd jn lr ls lt jr lu lv lw jv ix lx ly jz jb lz ma kd jf mb mc kh md bi translated">iptables规则</h2><p id="0411" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">IPVS不做SNAT，所以我想通过iptables手工做。我可以把SNAT或者假面舞会(马斯-QUE-拉德，你知道吗？).</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="e6f6" class="lf jm hi lb b fi lg lh l li lj">sudo iptables -t nat -A POSTROUTING -s 10.1.0.3 -j MASQUERADE</span></pre><p id="baee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个真实的场景需要考虑的不仅仅是客户端IP，而是所有的客户端，或者是目的地，但是对于我的测试来说已经足够了。然后通过curl从客户端发送一个请求…</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es me"><img src="../Images/a8f9ab75e851ce5cce0a33b76e8f6551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FosbrFoDvH4UprRZDh4zvg.png"/></div></div></figure><p id="f3d2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">怎么了？什么都没发生，就好像根本没有SNAT法则一样！真的，规则不是打了吗？</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mf"><img src="../Images/a720f2aaa8408fc407592ac370bccfbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJyJXN4mJcyQ0m4f50XYYA.png"/></div></div></figure><p id="bdbf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">没有:(<br/>这里我真的很迷惑。我的意思是，这是一个干净的环境，系统中没有其他iptables规则可以绕过这个规则，我尝试在其他表和链中设置规则，以便在没有观察到任何特殊情况的情况下跟踪进出的包。除了这条规则没有被击中。</p><p id="339c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我谷歌了一下，发现有一场IPVS的iptables比赛。我不喜欢在没有理解它们的情况下就离开，但我认为测试一下这个是个好主意。</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="3686" class="lf jm hi lb b fi lg lh l li lj">sudo iptables -t nat -A POSTROUTING -m ipvs --vaddr 10.1.0.6 -j MASQUERADE</span></pre><p id="d8b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你猜怎么着？同样的结果，或者同样的没有结果。规则也没有被击中。然而，读多了一点，我发现“配置_IP_VS_NFCT”应该启用，sysctl变量“连接跟踪”设置为1，无论这意味着什么。</p><h2 id="fee1" class="lf jm hi bd jn lr ls lt jr lu lv lw jv ix lx ly jz jb lz ma kd jf mb mc kh md bi translated">内核源代码和模块</h2><p id="7008" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">如果你玩过编译Linux内核，你会认识到配置格式。阅读资料时，我发现:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mg"><img src="../Images/c3c312dc1009eacc0fb54cdd630b373c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Koh1w_TLuK1Re6v0kw18lA.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">内核源文件<a class="ae ko" href="https://elixir.bootlin.com/linux/v5.10/source/net/netfilter/ipvs/Kconfig#L325" rel="noopener ugc nofollow" target="_blank">net/netfilter/ipvs/Kconfig</a></figcaption></figure><p id="8440" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">天啊，就是它了！<a class="ae ko" href="https://www.netfilter.org/" rel="noopener ugc nofollow" target="_blank"> Netfilter </a>是iptables、连接跟踪、IPVS等组件所依赖的包过滤的内核框架。似乎没有明确启用它，IPVS不允许从用户空间访问这个过滤。所以我检查了一下:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ml"><img src="../Images/94e3b9865c5660a6614318c97d7af313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6vTJTIB_PO18SYZAKda3w.png"/></div></div></figure><p id="dc80" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">奇怪，它被启用了，而且显然是内置在内核中的。我又挖了一点:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mm"><img src="../Images/1537d86faafb4324164ae8b60386e639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nvJmqHE1_92SWfBJ90f7g.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">内核源文件<a class="ae ko" href="https://elixir.bootlin.com/linux/v5.10/source/net/netfilter/ipvs/Makefile#L14" rel="noopener ugc nofollow" target="_blank"><em class="mn">net/netfilter/ipvs/Makefile</em></a></figcaption></figure><p id="9b7d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">哦，我明白了。这意味着IP_VS_NFCT的代码是内核对象IP_VS的一部分…</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kz"><img src="../Images/ebc90d0973a08c4bcc088512f2e4a5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*px7qrplmxNeuWB8OVxwLZg.png"/></div></div></figure><p id="d02c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…作为模块加载，而不是内置功能…</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mo"><img src="../Images/2a030c774a0786158370919de966760e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hl2bHpd_TEt3uLzGuq1GxQ.png"/></div></div></figure><p id="4559" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…但这也载入了正在运行的内核。如果您仔细观察，还可以看到xt_ipvs模块，它允许通过iptables匹配从用户空间配置的数据包的ipvs连接属性，无需使用modprobe。看起来一切都准备就绪了。</p><p id="d3e1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是等等，还有一个元素，sysctl变量“conntrack”:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/b6e71c1b1d69e6fd57ab3b7a0d87b0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqrERW1RcwDvyL91rgA7GA.png"/></div></div></figure><p id="3863" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它就在那里，在<em class="jk"> net.ipv4.vs </em>条目下，而且没有设置！我很幸运，因为只有当ipvsadm服务启动时，该条目才会出现，尽管我在内核源代码中也看到了它，而且您也有内核文档:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mp"><img src="../Images/f4ffec31753dccf92bf140af454c1b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*as9wqXxOO_6Bftan44FwRA.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx translated"><a class="ae ko" href="https://www.kernel.org/doc/html/v5.10/networking/ipvs-sysctl.html" rel="noopener ugc nofollow" target="_blank">ipvs-sysctl的Linux网络文档</a></figcaption></figure><p id="c1a2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如它所说，如果没有conntrack set，iptables就不能处理IPVS连接！所以我设置它，交叉手指，再次启动curl:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mq"><img src="../Images/138a871e949d2ba1ee790d830a7c1238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTRS9kCFNKi5dy9f_36aCQ.png"/></div></div></figure><p id="7a15" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">太好了，成功了！嘿，别这么快。SNAT完成了它的工作，您可以看到源IP 10.1.0.3转换为虚拟服务器IP 10.1.0.6的TCP SYN数据包。并且真实服务器向虚拟服务器发送相应的SYN-ACK。然而，通信在那个阶段停滞了，没有来自客户端的ACK回复。事实上，似乎SYN-ACK没有被NAT翻译回来，这是怎么回事？</p><p id="981b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">NAT的实现是有状态的，如果一个NAT的包出去和回来，它被处理以撤销NAT。我们可以通过连接跟踪系统检查这一点:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mr"><img src="../Images/9314789e04f4511dc63056aec1dbc4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOB2QO6nf0ibers-S-mQlg.png"/></div></div></figure><p id="6ab2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好的，所以conntrack系统确实处理了从10.1.0.50到10.1.0.6的SYN-ACK(它将连接更改为SYN_RECV状态)。那么，那个包裹后来怎么样了？它在某个时候被丢了，但是，我怎么才能找到它呢？</p><h2 id="6cb3" class="lf jm hi bd jn lr ls lt jr lu lv lw jv ix lx ly jz jb lz ma kd jf mb mc kh md bi translated">调试内核(是的)</h2><p id="6f62" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我知道，调试内核的想法听起来像掉进兔子洞，但在这一点上，我决定要弄清楚。我考虑了几个做内核追踪的工具:<a class="ae ko" href="https://www.kernel.org/doc/html/v5.10/dev-tools/kgdb.html" rel="noopener ugc nofollow" target="_blank"> Kgdb </a>，<a class="ae ko" href="https://sourceware.org/systemtap/" rel="noopener ugc nofollow" target="_blank"> SystemTap </a>，<a class="ae ko" href="https://perf.wiki.kernel.org/index.php/Main_Page" rel="noopener ugc nofollow" target="_blank"> perf </a>(那个我甚至稍微尝试了一下)，<a class="ae ko" href="https://ebpf.io/" rel="noopener ugc nofollow" target="_blank"> eBPF </a>。但我想保持简单，专注于这个问题。</p><p id="c520" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我想在内核中调试网络堆栈监控数据包丢弃，而没有太多麻烦，所以我使用了<a class="ae ko" href="https://github.com/nhorman/dropwatch" rel="noopener ugc nofollow" target="_blank"> Dropwatch </a>。这是一个简单的交互式实用程序。使用它需要安装一些软件包:</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="1ed2" class="lf jm hi lb b fi lg lh l li lj">sudo apt-get install git libpcap-dev libnl-3-dev libnl-genl-3-dev binutils-dev libreadline6-dev autoconf libtool pkg-config build-essential</span></pre><p id="e9ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您需要克隆项目的repo并编译它:</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="fd14" class="lf jm hi lb b fi lg lh l li lj">git clone <a class="ae ko" href="https://github.com/nhorman/dropwatch" rel="noopener ugc nofollow" target="_blank">https://github.com/nhorman/dropwatch</a><br/>cd dropwatch<br/>./autogen.sh<br/>./configure<br/>make<br/>sudo make install</span></pre><p id="0321" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当Dropwatch运行并检测到丢包时，它会告诉您发生丢包的原始指令指针，但这几乎没有用。将指令指针映射到内核的相应函数名是我所需要的，而<a class="ae ko" href="https://linux.die.net/man/1/dropwatch" rel="noopener ugc nofollow" target="_blank"> Dropwatch可以使用内核的符号文件<em class="jk"> kallsyms </em>来完成这个任务</a>:</p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="0a5c" class="lf jm hi lb b fi lg lh l li lj">sudo dropwatch -l kas</span></pre><p id="f9f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我启动它来报告丢失的数据包，并在客户机上启动curl:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ms"><img src="../Images/643cc1f194120c08c09b85d20875c221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKl_qelMTY-sPIJ8bOX6Pg.png"/></div></div></figure><p id="0a04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">哦，太美了，多么美好的回忆！函数符号和十六进制地址:)这表明数据包丢失发生在<a class="ae ko" href="https://elixir.bootlin.com/linux/v5.10/source/net/ipv4/route.c#L939" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> ip_error </em> </a>函数，偏移量0x7d。这个函数很短，很容易发现对释放套接字缓冲区的内核函数<em class="jk"> kfree_skb </em>的调用。</p><p id="1303" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更有趣的是ip_error在输入路径中被调用，并给出丢弃一个包的原因。特别是，它引起了我的注意<em class="jk">主机不可达</em>增加了<a class="ae ko" href="https://www.kernel.org/doc/html/latest/networking/snmp_counter.html" rel="noopener ugc nofollow" target="_blank"> SNMP计数器<em class="jk">ipinadderrors</em>T5】的情况。它处理“目的地IP地址不是本地地址并且IP转发未被启用”的情况。让我们思考一下这个问题:</a></p><ul class=""><li id="cb22" class="mt mu hi io b ip iq it iu ix mv jb mw jf mx jj my mz na nb bi translated">来自真实服务器10.1.0.50 ➔ 10.1.0.6的回复数据包被“捕捉”回10.1.0.50 ➔ 10.1.0.3</li><li id="bb74" class="mt mu hi io b ip nc it nd ix ne jb nf jf ng jj my mz na nb bi translated">我们期望IPVS处理回复信息包，将其翻译成相应的10.1.0.6 ➔ 10.1.0.3，但是IPVS在输入路径<strong class="io hj">开始，在</strong> SNAT之前</li><li id="54cf" class="mt mu hi io b ip nc it nd ix ne jb nf jf ng jj my mz na nb bi translated">现在，输入路径需要处理目的地为10.1.0.3的数据包，而不是该主机10.1.0.6。它不能，所以它放弃了</li></ul><p id="8873" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了测试我的理论，我在启动curl时使用了<em class="jk"> nstat </em> (netstat已被弃用),并观察了计数器是如何随着ip_error的每次下降而递增的:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es nh"><img src="../Images/42501737ff35190de037859f621ca93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWuIwmcpEYh3pjcKHAhL_A.png"/></div></div></figure><p id="5f8b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可能想知道，我怎么知道IPVS在SNAT之前开球？查看<a class="ae ko" href="https://elixir.bootlin.com/linux/v5.10/source/net/netfilter/ipvs/ip_vs_core.c#L2249" rel="noopener ugc nofollow" target="_blank">来源</a>。我也在那里找到了我需要的答案:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ni"><img src="../Images/ef5bcc4b8d2516c8baced71cd561e224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGDqLwD0Inc8h8U7LxfSQA.png"/></div></div></figure><p id="7025" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">IPVS在几个地方被钩住了(Netfilter钩子)，包括转发链。因此，我需要的是到达IPVS，在那里处理回复，而不是丢弃数据包，你猜怎么着:启用IP转发。</p><h1 id="c3f0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">最后一档</h1><p id="0dba" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">启用IP转发通常意味着主机将充当路由器。我最初没有启用它，因为情况并非如此，但无论如何它是需要的。请注意，在GCP有一个虚拟机设置，<em class="jk">如果您真的希望该虚拟机像路由器一样工作，但这不是重点，所以没有必要设置它。</em></p><pre class="kq kr ks kt fd la lb lc ld aw le bi"><span id="5434" class="lf jm hi lb b fi lg lh l li lj">sudo sysctl -w net.ipv4.ip_forward=1</span></pre><p id="291c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es nj"><img src="../Images/5e862c6f0fe122bcd91d355886d66929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YpOATi_cOFdddQtpisnIg.png"/></div></div></figure><p id="5005" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">\o/</p><h1 id="9ccd" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结束语</h1><p id="c5a0" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">哇，这是一个艰难的时刻。在最后敲定一些评论之前:</p><ul class=""><li id="56b1" class="mt mu hi io b ip iq it iu ix mv jb mw jf mx jj my mz na nb bi translated">LVS项目不仅由IPVS组成，还有更多组件来创建高度可伸缩和可用的服务器集群，具有诸如传输层和应用层负载平衡以及集群管理等功能。我只触及了表面。</li><li id="9ea7" class="mt mu hi io b ip nc it nd ix ne jb nf jf ng jj my mz na nb bi translated">其中一个组件保持活动状态，提供运行状况检查。如果您通过keepalived而不是ipvsadm配置虚拟和真实服务器，我在这里解释的完整NAT解决方案将无法工作。我没有调查原因。</li><li id="6095" class="mt mu hi io b ip nc it nd ix ne jb nf jf ng jj my mz na nb bi translated">虽然我只测试了TCP，但IPVS同时支持TCP和UDP。UDP的支持确实是推动这一进程的原因。我的客户需要对来自GCP客户端的TCP和UDP流量进行负载平衡。我们的<a class="ae ko" href="https://cloud.google.com/load-balancing/docs/internal" rel="noopener ugc nofollow" target="_blank">内部TCP/UDP负载均衡</a>不支持内部后端，<a class="ae ko" href="https://cloud.google.com/load-balancing/docs/tcp/internal-proxy" rel="noopener ugc nofollow" target="_blank">内部TCP代理负载均衡</a>支持内部后端，但不支持UDP。</li><li id="89cf" class="mt mu hi io b ip nc it nd ix ne jb nf jf ng jj my mz na nb bi translated">所解释的测试设置类似于单臂模型，其中负载平衡器、客户端和服务器共享同一个网络，并且需要完整的NAT。但是，如果您想避免SNAT或者需要保留客户端IP，可以创建一个具有多nic负载平衡器的双臂设置。</li><li id="fc3c" class="mt mu hi io b ip nc it nd ix ne jb nf jf ng jj my mz na nb bi translated">在<a class="ae ko" href="http://www.linuxvirtualserver.org/" rel="noopener ugc nofollow" target="_blank"> LVS官方页面</a>我发现了关于从Linux内核2.6.32开始在IPVS支持完全NAT模式的(旧)新闻。然而，我在最近的内核中没有找到任何代码来证明这种支持，也没有找到配置它的方法。</li></ul><p id="444d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我不得不说，总而言之，这是一次有趣的经历！</p></div></div>    
</body>
</html>