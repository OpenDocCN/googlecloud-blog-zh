<html>
<head>
<title>Build a blog application on Google App Engine: BlogPost module (part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google App Engine上构建博客应用程序:BlogPost模块(第4部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-blogpost-module-part-4-b929e212c899?source=collection_archive---------0-----------------------#2018-11-29">https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-blogpost-module-part-4-b929e212c899?source=collection_archive---------0-----------------------#2018-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db7064bf940ac11154f622da01139aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqONcla9wTKtqTvI-ZhvCw.jpeg"/></div></div></figure><p id="ed67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是关于如何使用<strong class="is hj">谷歌数据存储库</strong>在Node.js中构建博客应用程序并将其部署到<strong class="is hj">谷歌应用引擎</strong>的多部分教程的第四部分。如果你错过了开头，<a class="ae jo" rel="noopener" href="/@sebelga/build-a-blog-application-on-google-app-engine-setup-part-1-38dab981b779">跳到第一部分</a>，在那里我解释了如何建立这个项目，在那里你可以找到其他部分的链接。</p><p id="fd08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将用第一个模块创建我们的脏手:BlogPost模块。如果你还记得，在本教程的第2部分，我提到了一个<strong class="is hj"> Blog </strong>模块，而不是<em class="jp"> BlogPost… </em>这是因为我们的Blog模块将包含<strong class="is hj"> 2个子模块</strong> : <em class="jp"> BlogPost </em>和<em class="jp"> Comment </em>，我们正要构建第一个。让我们去吧！</p><p id="3072" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“<em class="jp"> modules/blog </em>”文件夹中添加一个“<em class="jp"> blog-post </em>文件夹，并创建其条目文件“<em class="jp">index . ts”</em>，内容如下:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="d87d" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/index.ts</span><span id="4b34" class="jz ka hi jv b fi kf kc l kd ke">import { Context, Modules } from "../models";</span><span id="49a7" class="jz ka hi jv b fi kf kc l kd ke">export * from "./models";</span><span id="b875" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogPostModule {}</span><span id="f7fc" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  context: Context,<br/>  modules: Modules<br/>): BlogPostModule =&gt; {<br/>  return {};<br/>};</span></pre><p id="5d18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，这个模块——像我们到目前为止的所有层一样——需要2个输入属性(<em class="jp">上下文</em>和<em class="jp">模块</em>)并返回<em class="jp"> BlogpostModule </em>接口。我们还没有创建<em class="jp">上下文</em>和<em class="jp">模块</em>类型，所以我们现在就开始吧。在<em class="jp"> Blog </em>模块的根目录下创建一个“<em class="jp"> models.ts </em>”文件，并添加以下内容:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="3201" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/models.ts</span><span id="8059" class="jz ka hi jv b fi kf kc l kd ke">import { Gstore } from "gstore-node";<br/>import { Logger } from "winston";<br/>import { ImagesModule } from '../images/index';<br/>import { UtilsModule } from '../utils/index';<br/>import { BlogPostModule } from "./blog-post";</span><span id="b2bd" class="jz ka hi jv b fi kf kc l kd ke">export type Context = {<br/>  gstore: Gstore,<br/>  logger: Logger<br/>};</span><span id="759f" class="jz ka hi jv b fi kf kc l kd ke">export type Modules = {<br/>  blogPost?: BlogPostModule;<br/>  images?: ImagesModule;<br/>  utils?: UtilsModule;<br/>};</span></pre><p id="ccdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能会问:“<em class="jp">为什么我们不使用我们已经在根“models.ts”文件</em>中声明的上下文类型？”。嗯，这将把我们的<em class="jp">博客</em>模块绑定到它被注入的应用程序(我们将不得不从模块<em class="jp">根</em> 之外的 <strong class="is hj">导入<em class="jp">上下文</em>类型<strong class="is hj">，其相对路径如下:<em class="jp">导入../../models.ts </em>"。这使得模块的可移植性降低，如果我们需要的话，我们不能把它作为一个单独的包(像npm)公开。</strong></strong></p><p id="1b93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建Typescript <em class="jp"> BlogPost </em>类型，它将在Google Datastore中定义我们的BlogPost <strong class="is hj">实体种类</strong>。在“<em class="jp"> modules/blog/blog-post </em>”文件夹中创建一个“<em class="jp"> models.ts </em>”文件，并添加以下内容:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="6399" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/models.ts</span><span id="4d72" class="jz ka hi jv b fi kf kc l kd ke">export type BlogPostType = {<br/>  title?: string,<br/>  createdOn?: Date,<br/>  modifiedOn?: Date,<br/>  content?: string,<br/>  contentToHtml?: string,<br/>  excerpt?: string,<br/>  posterUri?: string,<br/>  cloudStorageObject?: string<br/>};</span></pre><p id="0474" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里不多解释了。我们将以<strong class="is hj"> markdown </strong>格式<strong class="is hj">保存博文的<code class="du kg kh ki jv b">content</code>。然后我们将在运行时把它转换成HTML并存储在属性中。</strong></p><p id="3b4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们用<strong class="is hj">实例化我们的模块</strong>。打开“<em class="jp"> modules/blog/index.ts </em>”文件，并进行以下修改:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="a91d" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/index.ts</span><span id="433e" class="jz ka hi jv b fi kf kc l kd ke">import initBlogPost, { BlogPostModule } from "./blog-post";<br/>import { Context, Modules } from "./models";</span><span id="ced6" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogModule {<br/>  blogPost: BlogPostModule;<br/>}</span><span id="b922" class="jz ka hi jv b fi kf kc l kd ke">export default (context: Context, modules: Modules): BlogModule =&gt; {<br/>  const blogPost = initBlogPost(context, {});</span><span id="6d44" class="jz ka hi jv b fi kf kc l kd ke">  return {<br/>    blogPost,<br/>  };<br/>};</span></pre><p id="cd4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后要做的是<strong class="is hj">在我们实例化<em class="jp">博客</em>模块时提供<em class="jp">上下文</em>和<em class="jp">模块</em>输入</strong>。打开服务器<code class="du kg kh ki jv b">src</code>文件夹根目录下的“<em class="jp"> modules.ts </em>”文件，进行如下修改:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="4c88" class="jz ka hi jv b fi kb kc l kd ke">// modules.ts</span><span id="38c7" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="67f6" class="jz ka hi jv b fi kf kc l kd ke">export default (context: Context): AppModules =&gt; {<br/>  const utils = initUtilsModule();<br/>  const images = initImagesModule();<br/>  const blog = initBlogModule(context, { utils, images }); // Update<br/>  ...</span></pre><p id="5dc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了。我们已经初始化了我们的<em class="jp">博客</em>模块，提供了它的依赖关系(<em class="jp">实用程序</em>模块和<em class="jp">图像</em>模块)。然后<em class="jp"> Blog </em>模块初始化<em class="jp"> BlogPost </em>子模块，并将其实例作为<em class="jp"> BlogModule </em>类型的一部分返回。</p><h1 id="e009" class="kj ka hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">博客发布路由处理程序</h1><p id="fd96" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">现在让我们<strong class="is hj">为我们的博客帖子</strong>创建路由处理程序。当URL匹配时，快速路由器将调用这些处理程序。对于我们的<em class="jp">博客文章</em>，我们需要:</p><ul class=""><li id="a777" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><strong class="is hj">列出</strong>岗位(<code class="du kg kh ki jv b">GET /blog</code>路线)</li><li id="2b3d" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">查看<strong class="is hj">岗位详情</strong> ( <code class="du kg kh ki jv b">GET /blog/&lt;post-id&gt;</code>路线)</li></ul><p id="0129" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“<em class="jp">博文</em>”子模块中创建一个“<em class="jp">博文.路由-处理程序. ts </em>”文件，并添加以下内容:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="0482" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.routes-handlers.ts</span><span id="eca4" class="jz ka hi jv b fi kf kc l kd ke">import { Request, Response } from "express";<br/>import { Context, Modules } from "../models";</span><span id="989e" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogPostRoutesHandlers {<br/>  listPosts(req: Request, res: Response): any;<br/>  detailPost(req: Request, res: Response): any;<br/>}</span><span id="47c4" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  { gstore, logger }: Context,<br/>  modules: Modules<br/>): BlogPostRoutesHandlers =&gt; {<br/>  return {};<br/>};</span></pre><p id="eaba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先声明了routes handlers层的<strong class="is hj">接口</strong>，然后将其定义为<strong class="is hj">输出</strong>。像我们刚才做的那样先声明接口是一个好习惯，这样我们就不需要在以后的方法签名中添加任何类型。然后我们声明了<strong class="is hj">输入</strong> ( <em class="jp">上下文</em>和<em class="jp">模块</em>，并从<em class="jp">上下文</em>对象中解构了<code class="du kg kh ki jv b">gstore</code>和<code class="du kg kh ki jv b">logger</code>实例。现在让我们从我们的接口添加两个方法。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="397f" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.routes-handlers.ts</span><span id="58d5" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="da2b" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  { gstore, logger }: Context,<br/>  modules: Modules<br/>): BlogPostRoutesHandlers =&gt; {<br/>  return {<br/>    async listPosts(_, res) {<br/>      const template = "blog/index";</span><span id="2591" class="jz ka hi jv b fi kf kc l kd ke">      res.render(template, {<br/>        blogPosts: [],<br/>        pageId: "home"<br/>      });<br/>    },<br/>    async detailPost(req, res) {<br/>      const template = "blog/detail";</span><span id="c25b" class="jz ka hi jv b fi kf kc l kd ke">      return res.render(template, {<br/>        post: {},<br/>        pageId: "blogpost-view",<br/>      });<br/>    }<br/>  };<br/>};</span></pre><p id="4c5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经创建了2个routes处理程序，并声明它们为<strong class="is hj"> async </strong>，尽管——目前——它们中没有异步代码。让<strong class="is hj">实例化</strong>这一层<strong class="is hj">导出</strong>。从我们的博客帖子子模块中打开“<em class="jp"> index.ts </em>”。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="4ab6" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/index.ts</span><span id="25e9" class="jz ka hi jv b fi kf kc l kd ke">import initRoutes, {<br/>  BlogPostRoutesHandlers<br/>} from "./blog-post.routes-handlers";<br/>import { Context, Modules } from "../models";</span><span id="2963" class="jz ka hi jv b fi kf kc l kd ke">export * from "./models";</span><span id="2a35" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogPostModule {<br/>  routesHandlers: BlogPostRoutesHandlers;<br/>}</span><span id="cb87" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  context: Context,<br/>  modules: Modules<br/>): BlogPostModule =&gt; {<br/>  return {<br/>    routesHandlers: initRoutes(context, {})<br/>  };<br/>};</span></pre><p id="7c8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经创建了路由处理器，<strong class="is hj">我们需要一个路由器</strong>来连接它们。在<em class="jp"> Blog </em>模块的根目录下创建一个“<em class="jp"> blog.routes.ts </em>”文件。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="16d3" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog.routes.ts</span><span id="6aef" class="jz ka hi jv b fi kf kc l kd ke">import express from "express";<br/>import { Context, Modules } from "./models";</span><span id="6552" class="jz ka hi jv b fi kf kc l kd ke">export default (context: Context, { blogPost }: Modules) =&gt; {<br/>  // WEB<br/>  const webRouter = express.Router();</span><span id="23bc" class="jz ka hi jv b fi kf kc l kd ke">  webRouter.get("/", blogPost.routesHandlers.listPosts);<br/>  webRouter.get("/:id", blogPost.routesHandlers.detailPost);</span><span id="ec22" class="jz ka hi jv b fi kf kc l kd ke">  return {<br/>    webRouter<br/>  };<br/>};</span></pre><p id="179d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创建了一个快速路由器(我们称之为<code class="du kg kh ki jv b">webRouter</code>,因为稍后我们将为我们需要的API创建另一个路由器),并将我们的处理程序映射到“/”和“/:id”路径。这使得这个模块非常便携。父路由器将决定从哪条路径访问它。现在让我们实例化路由:从我们的<em class="jp">博客</em>模块中打开"<em class="jp"> index.ts </em>"文件，并进行以下修改:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="21e1" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/index.ts</span><span id="4f7b" class="jz ka hi jv b fi kf kc l kd ke">import { Router } from "express"; // Add this line<br/>import initRoutes from "./blog.routes"; // Add this line<br/>import initBlogPost, { BlogPostModule } from "./blog-post";<br/>import { Context, Modules } from "./models";</span><span id="f59b" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogModule {<br/>  webRouter: Router; // Add<br/>  blogPost: BlogPostModule;<br/>}</span><span id="45b8" class="jz ka hi jv b fi kf kc l kd ke">export default (context: Context, modules: Modules): BlogModule =&gt; {<br/>  const blogPost = initBlogPost(context, {});<br/>  const { webRouter } = initRoutes(context, { blogPost }); // Add</span><span id="741f" class="jz ka hi jv b fi kf kc l kd ke">return {<br/>    webRouter, // Add this line<br/>    blogPost<br/>  };<br/>};</span></pre><p id="53ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们需要将这个路由器连接到我们的主应用程序路由器。打开根目录下的“<em class="jp"> routes.ts </em>”文件，进行如下修改:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="47e3" class="jz ka hi jv b fi kb kc l kd ke">// routes.ts</span><span id="9cee" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="f654" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  { logger, config }: Context,<br/>  {<br/>    app,<br/>    modules: { blog, admin }<br/>  }: { app: Express, modules: AppModules }<br/>) =&gt; {<br/>  /**<br/>   * Web Routes<br/>   */<br/>  app.use("/blog", blog.webRouter); // update this line<br/>  ...<br/>};</span></pre><p id="edb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！如果你刷新你的浏览器窗口，<strong class="is hj">你应该在<code class="du kg kh ki jv b">/blog</code>网址看到我们博客的主页</strong>。如果你导航到<code class="du kg kh ki jv b">/blog/123</code>，你应该会看到我们的详细视图的框架。太好了！</p><p id="e68e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们暂停一下，快速回顾一下我们刚刚做的事情。</p><ol class=""><li id="fd64" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lz lr ls lt bi translated">主应用路由器→我们声明了一个<code class="du kg kh ki jv b">/blog</code>路径，让<strong class="is hj"> <em class="jp">博客</em>模块路由器处理</strong>。</li><li id="d4b0" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lz lr ls lt bi translated"><em class="jp">博客</em>模块路由器→我们已经导出了一个处理2个路由的web路由器:<code class="du kg kh ki jv b">/</code> <strong class="is hj">列出我们的帖子</strong>和<code class="du kg kh ki jv b">/:id</code>显示<strong class="is hj">一个帖子的细节</strong>。</li><li id="a4e1" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lz lr ls lt bi translated">我们在<em class="jp"> BlogPost </em>子模块中创建了两个<strong class="is hj"> routes处理程序</strong>，用于处理来自<em class="jp"> Blog </em>模块的路由。</li></ol><p id="8994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过将<strong class="is hj">关注点</strong>分离到每个模块和层，我们正在构建一个可以在代码方面轻松扩展的应用程序，同时使我们的模块非常便携。我们目前正在构建一个单片应用程序，因为在这个阶段创建微服务是多余的。但是如果时间到了，我们需要将我们的<em class="jp">图片</em>我们的<em class="jp">博客</em>模块作为一个独立的服务公开，这不会有太多的工作要做。</p><h1 id="2526" class="kj ka hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">博客发布数据库</h1><p id="572c" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">让我们<strong class="is hj">现在为我们的博客文章创建数据库访问层</strong>。终于可以与数据存储进行一些交互了！<br/>在<em class="jp"> BlogPost </em>子模块文件夹中创建一个“<em class="jp"> blog-post.db.ts </em>文件，并在其中添加以下内容:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="1b8b" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.db.ts</span><span id="156e" class="jz ka hi jv b fi kf kc l kd ke">import {<br/>  Entity,<br/>  QueryListOptions,<br/>  QueryResult,<br/>  DeleteResult<br/>} from "gstore-node";<br/>import { Context, Modules } from "../models";<br/>import { BlogPostType } from "./models";</span><span id="208f" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogPostDB {<br/>  getPosts(<br/>    options?: QueryListOptions<br/>  ): Promise&lt;QueryResult&lt;BlogPostType&gt;&gt;;<br/>  getPost(<br/>    id: number,<br/>    dataloader: any,<br/>    format?: string<br/>  ): Promise&lt;Entity&lt;BlogPostType&gt; | BlogPostType&gt;;<br/>  createPost(<br/>    data: BlogPostType,<br/>    dataloader: any<br/>  ): Promise&lt;Entity&lt;BlogPostType&gt;&gt;;<br/>  updatePost(<br/>    id: number,<br/>    data: any,<br/>    dataloader: any,<br/>    replace: boolean<br/>  ): Promise&lt;Entity&lt;BlogPostType&gt;&gt;;<br/>  deletePost(id: number): Promise&lt;DeleteResult&gt;;<br/>}</span><span id="628a" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>    context: Context,<br/>  { images, utils }: Modules<br/>): BlogPostDB =&gt; {<br/>  const { gstore } = context;</span><span id="a546" class="jz ka hi jv b fi kf kc l kd ke">  /**<br/>   * DB API<br/>   */<br/>  return {<br/>    // TODO<br/>  };<br/>};</span></pre><p id="24e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码很容易理解，但是让我们快速浏览一下它的内容。首先，我们从<code class="du kg kh ki jv b">gstore-node</code>和我们的"<em class="jp"> models.ts" </em>文件中导入<strong class="is hj">类型</strong>。然后我们<strong class="is hj">声明了这个层的接口</strong>。没有什么奇特的，正常的CRUD方法。<br/>你可能已经注意到，对于<code class="du kg kh ki jv b">getPost()</code>方法，返回类型是<em class="jp">要么是<strong class="is hj"> gstore实体</strong>实例<em class="jp">的</em>承诺，要么是<strong class="is hj"> BlogPostType </strong>的</em>承诺。这是因为，根据通过的<code class="du kg kh ki jv b">format</code>参数，我们将有两种不同的返回类型。</p><p id="d561" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du kg kh ki jv b">gstore-node</code>中与数据存储上的实体种类交互的第一件事是声明一个<strong class="is hj">模式</strong>。让我们这样做并创建<em class="jp"> BlogPost </em>模式:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="8d42" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.db.ts</span><span id="abed" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="220b" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  context: Context,<br/>  modules: Modules<br/>): BlogPostDB =&gt; {<br/>  const { gstore } = context;<br/>  const { Schema } = gstore;</span><span id="3ac4" class="jz ka hi jv b fi kf kc l kd ke">  /**<br/>   * Schema for the BlogPost entity Kind<br/>   */<br/>  const schema = new Schema&lt;BlogPostType&gt;({<br/>    title: { type: String },<br/>    createdOn: {<br/>      type: Date,<br/>      default: gstore.defaultValues.NOW,<br/>      read: false,<br/>      write: false<br/>    },<br/>    modifiedOn: { type: Date, default: gstore.defaultValues.NOW },<br/>    content: { type: String, excludeFromIndexes: true },<br/>    excerpt: { type: String, excludeFromIndexes: true },<br/>    posterUri: { type: String },<br/>    cloudStorageObject: { type: String }<br/>  });</span><span id="b729" class="jz ka hi jv b fi kf kc l kd ke">  const ancestor = ['Blog', 'default'];</span><span id="7fde" class="jz ka hi jv b fi kf kc l kd ke">  /**<br/>   * Configuration for our Model.list() query shortcut<br/>   */<br/>  schema.queries('list', {<br/>    order: { property: 'modifiedOn', descending: true },<br/>    ancestors: ancestor,<br/>  });</span><span id="f21a" class="jz ka hi jv b fi kf kc l kd ke">  ...</span></pre><p id="49e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创建了一个提供Typescript类型的<code class="du kg kh ki jv b">gstore</code>模式(<code class="du kg kh ki jv b">Schema&lt;BlogPostType&gt;</code>)。<strong class="is hj">我们确实定义了两次类型</strong>(一次在<em class="jp"> Typescript </em>中，一次在<code class="du kg kh ki jv b">gstore</code>模式中)，但是每一次都有不同的目的。Typescript <strong class="is hj"> </strong>将在开发和编译时验证类型<strong class="is hj">，让我们立即知道<em class="jp"> </em>是否违约。但是<strong class="is hj">阻止我们将无效数据</strong> <strong class="is hj">插入数据存储</strong>的是<code class="du kg kh ki jv b">gstore</code>类型。有关模式声明和配置的所有信息，请参考<a class="ae jo" href="https://sebloix.gitbook.io/gstore-node/schema/index" rel="noopener ugc nofollow" target="_blank">gstore-node文档</a>。</strong></p><p id="f90a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">声明了上面的模式后，不能向数据存储中的<em class="jp"> BlogPost </em>实体种类添加任何其他属性。太棒了。</p><p id="a23a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我一会儿会解释什么是<code class="du kg kh ki jv b">ancestor</code>变量。就在下面，我们配置了<a class="ae jo" href="https://sebloix.gitbook.io/gstore-node/queries/list" rel="noopener ugc nofollow" target="_blank"> gstore Model.list()查询快捷方式</a>，这将<strong class="is hj">允许我们方便地查询我们的<em class="jp"> BlogPosts </em>实体</strong>，并通过<code class="du kg kh ki jv b">modifiedOn</code>属性对它们进行排序。</p><p id="3a38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在需要<strong class="is hj">为我们的模式</strong>创建一个gstore模型。在<code class="du kg kh ki jv b">schema.queries('list')</code>调用的正下方添加以下内容:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="1e1c" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.db.ts</span><span id="2159" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="bdab" class="jz ka hi jv b fi kf kc l kd ke">/**<br/> * Create a "BlogPost" Entity Kind Model<br/> */<br/>const BlogPost = gstore.model("BlogPost", schema);</span><span id="303e" class="jz ka hi jv b fi kf kc l kd ke">...</span></pre><p id="2b92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，现在我们有了模型，我们可以构建我们的<em class="jp"> BlogPostDB </em>接口了。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="0013" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.db.ts</span><span id="6801" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="f95c" class="jz ka hi jv b fi kf kc l kd ke">const BlogPost = gstore.model("BlogPost", schema);</span><span id="7911" class="jz ka hi jv b fi kf kc l kd ke">/**<br/> * DB API<br/> */<br/>return {<br/>  getPosts: BlogPost.list.bind(BlogPost),<br/>  getPost(id, dataloader, format = "JSON") {<br/>    return BlogPost.get(id, ancestor, null, null, {<br/>      dataloader<br/>    }).then(entity =&gt; {<br/>      if (format === "JSON") {<br/>        // Transform the gstore "Entity" instance<br/>        // to a plain object (adding an "id" prop to it)<br/>        return entity.plain();<br/>      }<br/>      return entity;<br/>    });<br/>  },<br/>  createPost(data, dataloader) {<br/>    const post = new BlogPost(data, null, ancestor);</span><span id="7479" class="jz ka hi jv b fi kf kc l kd ke">  // We add the DataLoader instance to our entity context<br/>    // so it is available in our "pre" Hooks<br/>    post.context.dataloader = dataloader;<br/>    return post.save();<br/>  },<br/>  updatePost(id, data, dataloader, replace) {<br/>    return BlogPost.update(id, data, ancestor, null, null, {<br/>      dataloader,<br/>      replace<br/>    });<br/>  },<br/>  deletePost(id) {<br/>    return BlogPost.delete(id, ancestor);<br/>  },<br/>};</span></pre><p id="5617" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看在CRUD接口的每个方法中发生了什么。</p><h2 id="a90b" class="jz ka hi bd kk ma mb mc ko md me mf ks jb mg mh kw jf mi mj la jj mk ml le mm bi translated">getPosts()</h2><p id="9e05" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">这个方法只是一个<a class="ae jo" href="https://sebloix.gitbook.io/gstore-node/queries/list" rel="noopener ugc nofollow" target="_blank"> gstore Model.list() </a>快捷查询的代理。请参考文档以了解它接受哪些参数。</p><h2 id="5cc7" class="jz ka hi bd kk ma mb mc ko md me mf ks jb mg mh kw jf mi mj la jj mk ml le mm bi translated">getPost()</h2><p id="ff7a" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">该方法接受3个参数。<br/> -要检索的帖子的<code class="du kg kh ki jv b">id</code>。<br/> -一个<code class="du kg kh ki jv b">dataloader</code>实例。</p><blockquote class="mn mo mp"><p id="2dfb" class="iq ir jp is b it iu iv iw ix iy iz ja mq jc jd je mr jg jh ji ms jk jl jm jn hb bi translated">Dataloader是一个实用程序，它通过<strong class="is hj">将多个db访问调用</strong>(发生在事件循环的一个节拍内)聚集成一个调用(对于Google Datastore来说是完美的，因为我们可以在一个调用中通过键获得多个实体)并通过<strong class="is hj">缓存这些请求的结果</strong>来优化从数据库获取实体。它并不打算用作LRU缓存层，而是优化单个Http请求中发生的数据获取。</p></blockquote><p id="4df9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">详细解释，<a class="ae jo" href="https://sebloix.gitbook.io/gstore-node/cache-dataloader/dataloader" rel="noopener ugc nofollow" target="_blank">看这里</a>或者<a class="ae jo" href="https://github.com/facebook/dataloader" rel="noopener ugc nofollow" target="_blank">官方回购</a>。<br/>——回应的<code class="du kg kh ki jv b">format</code>。它可以是存储在数据存储中的数据的普通JSON对象，也可以是一个<code class="du kg kh ki jv b">gstore</code> <em class="jp">实体</em>实例。</p><h2 id="6391" class="jz ka hi bd kk ma mb mc ko md me mf ks jb mg mh kw jf mi mj la jj mk ml le mm bi translated">createPost()</h2><p id="08c0" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">这里不多说了。我们提供要保存的实体数据和可选的数据加载器实例。</p><h2 id="387c" class="jz ka hi bd kk ma mb mc ko md me mf ks jb mg mh kw jf mi mj la jj mk ml le mm bi translated">更新发布()</h2><p id="9dbd" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">类似于<code class="du kg kh ki jv b">createPost()</code>，但显然这里我们需要提供一个<code class="du kg kh ki jv b">id</code>来更新帖子。我们还可以指定是否要完全替换数据存储中的数据，或者是否要将提供的数据与当前数据存储中的数据合并。</p><h2 id="4276" class="jz ka hi bd kk ma mb mc ko md me mf ks jb mg mh kw jf mi mj la jj mk ml le mm bi translated">删除帖子()</h2><p id="42d7" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我们只是简单地调用相应的<code class="du kg kh ki jv b">gstore</code> <em class="jp"> Model.delete() </em>方法。</p><h2 id="6d7f" class="jz ka hi bd kk ma mb mc ko md me mf ks jb mg mh kw jf mi mj la jj mk ml le mm bi translated">实施强一致性</h2><p id="55c4" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">你已经注意到我们在多个地方使用了变量<code class="du kg kh ki jv b">ancestor</code>。我们将所有的BlogPosts保存在<a class="ae jo" href="https://cloud.google.com/appengine/docs/standard/python/datastore/entities#Python_Ancestor_paths" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">数据存储祖先路径</strong> </a> : <code class="du kg kh ki jv b">["Blog", “default"]</code>，<em class="jp"> </em>下，其中<strong class="is hj">对应于父<em class="jp"> Blog </em>实体种类</strong>，我们给它一个“默认”名称。这个实体<strong class="is hj">不需要存在于数据存储库</strong>中，我们只是将我们的所有帖子保存为它的一个子节点<strong class="is hj">，因此在同一个实体组</strong>中。通过这样做，我们在数据存储上获得了<strong class="is hj">强一致性</strong>。你可以在谷歌云上了解更多信息。</p><p id="a5db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们现在初始化这一层。为此，请打开我们博客文章文件夹中的“<em class="jp">索引。</em></p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="16bf" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/index.ts</span><span id="dc84" class="jz ka hi jv b fi kf kc l kd ke">import initDB from "./blog-post.db"; // Add this line<br/>import initRoutes, {<br/>  BlogPostRoutesHandlers<br/>} from "./blog-post.routes-handlers";</span><span id="1c1f" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="12c1" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  context: Context,<br/>  modules: Modules<br/>): BlogPostModule =&gt; {<br/>  const blogPostDB = initDB(context, modules); // Add this line</span><span id="6500" class="jz ka hi jv b fi kf kc l kd ke">  return {<br/>    routesHandlers: initRoutes(context, {})<br/>  };<br/>};</span></pre><h1 id="4cca" class="kj ka hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">博客发布域</h1><p id="11c6" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我们已经创建了我们的<strong class="is hj">路由处理程序</strong>，我们有一个<strong class="is hj">数据库层</strong>来与数据存储交互。我们现在需要<strong class="is hj">一个域层将一个连接到另一个</strong>。让我们去吧！</p><p id="6ee9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在blog-post文件夹中创建一个“<em class="jp"> blog-post.domain.ts </em>”文件，并添加以下内容:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="b49f" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.domain.ts</span><span id="17f6" class="jz ka hi jv b fi kf kc l kd ke">import marked from "marked";<br/>import Boom from "boom";<br/>import {<br/>  Entity,<br/>  QueryListOptions,<br/>  QueryResult,<br/>  DeleteResult<br/>} from "gstore-node";<br/>import { Context, Modules } from "../models";<br/>import { BlogPostType } from "./models";</span><span id="ed50" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogPostDomain {<br/>  getPosts(<br/>    options?: QueryListOptions<br/>  ): Promise&lt;QueryResult&lt;BlogPostType&gt;&gt;;<br/>  getPost(<br/>    id: number | string,<br/>    dataLoader: any<br/>  ): Promise&lt;Entity&lt;BlogPostType&gt;&gt;;<br/>  createPost(<br/>    data: BlogPostType,<br/>    dataLoader: any<br/>  ): Promise&lt;Entity&lt;BlogPostType&gt;&gt;;<br/>  updatePost(<br/>    id: string | number,<br/>    data: BlogPostType,<br/>    dataloader: any,<br/>    overwrite?: boolean<br/>  ): Promise&lt;Entity&lt;BlogPostType&gt;&gt;;<br/>  deletePost(id: string | number): Promise&lt;DeleteResult&gt;;<br/>}</span><span id="77f2" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  context: Context,<br/>  { blogPostDB }: Modules<br/>): BlogPostDomain =&gt; {<br/>  return {};<br/>};</span></pre><p id="d546" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里没有什么特别的，我们声明接口并返回层初始化器。我们可以看到，我们从<em class="jp">模块</em>类型依赖于<code class="du kg kh ki jv b">blogPostDB</code>层。赶紧补充一下吧。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="6e88" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/models.ts</span><span id="a693" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="e774" class="jz ka hi jv b fi kf kc l kd ke">import { BlogPostModule } from "./blog-post";<br/>import { BlogPostDB } from "./blog-post/blog-post.db"; // Add this</span><span id="33cb" class="jz ka hi jv b fi kf kc l kd ke">export type Context = {<br/>  gstore: Gstore;<br/>  logger: Logger;<br/>};</span><span id="4e32" class="jz ka hi jv b fi kf kc l kd ke">export type Modules = {<br/>  blogPost?: BlogPostModule;<br/>  blogPostDB?: BlogPostDB; // Add this line<br/>  images?: ImagesModule;<br/>  utils?: UtilsModule;<br/>};</span></pre><p id="91e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了，我们现在可以完成<em class="jp"> BlogPostDomain </em>接口了</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="34db" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.domain.ts</span><span id="f28f" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="0d42" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  context: Context,<br/>  { blogPostDB }: Modules<br/>): BlogPostDomain =&gt; {<br/>  return {<br/>    /**<br/>     * Get a list of BlogPosts<br/>     */<br/>    getPosts(options = {}) {<br/>      return blogPostDB.getPosts(options);<br/>    },<br/>    /**<br/>     * Get a BlogPost<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} id Id of the BlogPost to fetch<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} dataloader optional. A Dataloader instance<br/>     */<br/>    async getPost(id, dataloader) {<br/>      id = +id;<br/>      if (isNaN(id)) {<br/>        throw new Error("BlogPost id must be an integer");<br/>      }</span><span id="9ae3" class="jz ka hi jv b fi kf kc l kd ke">      let post: Entity&lt;BlogPostType&gt;;<br/>      try {<br/>        post = &lt;Entity&lt;BlogPostType&gt;&gt;(<br/>          await blogPostDB.getPost(id, dataloader)<br/>        );<br/>      } catch (err) {<br/>        throw err;<br/>      }</span><span id="72d2" class="jz ka hi jv b fi kf kc l kd ke">      if (post &amp;&amp; post.content) {<br/>        // Convert markdown to Html<br/>        post.contentToHtml = marked(post.content);<br/>      }</span><span id="810c" class="jz ka hi jv b fi kf kc l kd ke">      return post;<br/>    },<br/>    /**<br/>     * Create a BlogPost<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} data BlogPost entity data<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} dataloader optional Dataloader instance<br/>     */<br/>    createPost(data: BlogPostType, dataloader: any) {<br/>      return blogPostDB.createPost(data, dataloader);<br/>    },<br/>    /**<br/>     * Update a BlogPost entity in the Datastore<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {number} id Id of the BlogPost to update<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} data BlogPost entity data<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Dataloader} dataloader optional Dataloader instance<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {boolean} overwrite overwrite the entity in Datastore<br/>     */<br/>    updatePost(id, data, dataloader, overwrite = false) {<br/>      id = +id;<br/>      if (isNaN(id)) {<br/>        throw new Boom("BlogPost id must be an integer", {<br/>          statusCode: 400<br/>        });<br/>      }</span><span id="fea7" class="jz ka hi jv b fi kf kc l kd ke">      return blogPostDB.updatePost(id, data, dataloader, overwrite);<br/>    },<br/>    /**<br/>     * Delete a BlogPost entity in the Datastore<br/>     * <a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {number} id Id of the BlogPost to delete<br/>     */<br/>    deletePost(id) {<br/>      return blogPostDB.deletePost(+id);<br/>    }<br/>  };<br/>};</span></pre><p id="ac74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不会深入研究代码，因为我认为它是不言自明的。我将只强调这一层的重要性。这就是我们的应用程序特有的逻辑<strong class="is hj">所在的地方。路由处理器只是从快速路由器到这一层的连接器。数据库层只是该层对于数据存储的一个门面。这里是所有魔法发生的地方</strong></p><p id="4220" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然我们现在只需要列出文章和查看文章细节，但是我们已经声明了构建<em class="jp"> Admin </em>模块时需要的其他操作(创建、更新、删除)。现在让我们<strong class="is hj">将路由处理器连接到我们新定义的域方法</strong>。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="1be6" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/blog-post.routes-handlers.ts</span><span id="f11d" class="jz ka hi jv b fi kf kc l kd ke">import { Request, Response } from 'express';<br/>import { Entity, QueryResult, DeleteResult } from 'gstore-node';<br/>import { BlogPostType } from './models';<br/>import { Context, Modules } from '../models';</span><span id="e22f" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="2ee5" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  { gstore }: Context,<br/>  { blogPostDomain }: Modules<br/>): BlogPostRoutesHandlers =&gt; {<br/>  return {<br/>    async listPosts(_, res) {<br/>      const template = "blog/index";<br/>      let posts: QueryResult&lt;BlogPostType&gt;;</span><span id="11c4" class="jz ka hi jv b fi kf kc l kd ke">      try {<br/>        posts = await blogPostDomain.getPosts();<br/>      } catch (error) {<br/>        return res.render(template, {<br/>          blogPosts: [],<br/>          error<br/>        });<br/>      }</span><span id="4e2e" class="jz ka hi jv b fi kf kc l kd ke">      res.render(template, {<br/>        blogPosts: posts.entities,<br/>        pageId: "home"<br/>      });<br/>    },<br/>    async detailPost(req, res) {<br/>      /**<br/>       * Create Dataloader instance, unique to this Http Request<br/>       */<br/>      const dataloader = gstore.createDataLoader();<br/>      const template = "blog/detail";</span><span id="714f" class="jz ka hi jv b fi kf kc l kd ke">      let blogPost: Entity&lt;BlogPostType&gt;;<br/>      try {<br/>        blogPost = await blogPostDomain.getPost(<br/>          req.params.id,<br/>          dataloader<br/>        );<br/>      } catch (error) {<br/>        if (error.code === "ERR_ENTITY_NOT_FOUND") {<br/>          return res.redirect("/404");<br/>        }<br/>        return res.render(template, { post: null, error });<br/>      }</span><span id="b17f" class="jz ka hi jv b fi kf kc l kd ke">      return res.render(template, {<br/>        pageId: "blogpost-view",<br/>        blogPost<br/>      });<br/>    }<br/>  };<br/>};</span></pre><p id="a10a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们<strong class="is hj">初始化这个层</strong>并在我们的<em class="jp">模块</em>类型中提供它。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="1782" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/blog-post/index.ts</span><span id="f4d3" class="jz ka hi jv b fi kf kc l kd ke">import initDB from "./blog-post.db";<br/>import initRoutes, {<br/>  BlogPostRoutesHandlers<br/>} from "./blog-post.routes-handlers";<br/>import initDomain, { BlogPostDomain } from "./blog-post.domain";</span><span id="2289" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="8dc4" class="jz ka hi jv b fi kf kc l kd ke">export interface BlogPostModule {<br/>  blogPostDomain: BlogPostDomain; // Add this line<br/>  routesHandlers: BlogPostRoutesHandlers;<br/>}</span><span id="5838" class="jz ka hi jv b fi kf kc l kd ke">export default (<br/>  context: Context,<br/>  modules: Modules<br/>): BlogPostModule =&gt; {<br/>  const blogPostDB = initDB(context, modules);<br/>  const blogPostDomain = initDomain(context, { blogPostDB }); // Add</span><span id="522f" class="jz ka hi jv b fi kf kc l kd ke">  return {<br/>    blogPostDomain, // Add this line<br/>    routesHandlers: initRoutes(context, { blogPostDomain })<br/>  };<br/>};</span></pre><p id="9446" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并更新我们的类型…</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="45c4" class="jz ka hi jv b fi kb kc l kd ke">// modules/blog/models.ts</span><span id="fc29" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="8ac6" class="jz ka hi jv b fi kf kc l kd ke">import { BlogPostDB } from './blog-post/blog-post.db';<br/>import { BlogPostDomain } from './blog-post/blog-post.domain';// Add</span><span id="02b2" class="jz ka hi jv b fi kf kc l kd ke">...</span><span id="60d3" class="jz ka hi jv b fi kf kc l kd ke">export type Modules = {<br/>  blogPost?: BlogPostModule;<br/>  blogPostDB?: BlogPostDB;<br/>  blogPostDomain?: BlogPostDomain; // Add this line<br/>  images?: ImagesModule;<br/>  utils?: UtilsModule;<br/>};</span></pre><p id="c9dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们已经完成了<em class="jp"> BlogPost </em>模块。这是一个很长的帖子，因为我试图解释所有的移动部分。我希望我没有让你迷路。像往常一样，如果有什么不清楚的地方，请在下面的评论中联系我们。</p><p id="943e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于我们将要构建的下一个模块，我不会详细介绍，因为我们将遵循这里看到的完全相同的模式。</p><p id="c4c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是时候<strong class="is hj">开始为我们的博客创造一些内容了</strong>！这是我们将在本教程的下一部分做的事情:<a class="ae jo" rel="noopener" href="/@sebelga/build-a-blog-application-on-google-app-engine-admin-module-part-5-d6b008855f69">构建<strong class="is hj">一个<em class="jp">管理</em>模块来管理我们的帖子。</strong>T9】</a></p><p id="875a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>