<html>
<head>
<title>Using GitLab and Cloud Build to achieve CI/CD for Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用GitLab和云构建实现云运行的CI/CD</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-gitlab-and-cloud-build-to-achieve-ci-cd-for-cloud-run-4c6db26f04ed?source=collection_archive---------0-----------------------#2021-09-20">https://medium.com/google-cloud/using-gitlab-and-cloud-build-to-achieve-ci-cd-for-cloud-run-4c6db26f04ed?source=collection_archive---------0-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c12682645690a7f00932bf997dba37cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GW5ADK4RnorpcKDSwfDww.png"/></div></div></figure><p id="1f67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个客户找到我，说“我有这个Python代码，我想定期运行它，所以我想把它打包到Cloud Run中，并使用Cloud Scheduler来调用它。这个管用。然而，我不想每次修改程序源代码时都要手动重新构建容器映像。我们能否自动化这些任务以实现CI/CD？”。</p><p id="22a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道它应该如何工作的理论，但没有机会在实践中使用它。在翻阅书籍并做了一点研究后，我发现它像广告上说的那样有效，但是有很多步骤。本文向我们展示了让它从头开始运行的活动。如果你愿意，你可以跟随或者观看文章结尾的视频。</p><p id="abfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整体架构如下:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/57dedec9ada745c021e808767bbfa383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UkVkjIGN8tW-IcLV"/></div></div></figure><p id="db02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解释该图的方式是，当应用程序发出REST请求时，执行Python代码的是Cloud Run。云运行需要一个Docker映像来执行，并将向工件存储库请求该映像。工件存储库随后将提供该图像。正是Docker映像将<em class="jt">实际上</em>包含用于执行的Python代码。现在让我们来看看Docker图像是从哪里来的。我们假设客户端使用GitLab作为源代码管理系统。一旦源文件发生变化，可以导出、编辑代码，然后提交回GitLab存储库。将更改推回到GitLab的行为可以用来触发云构建来完成它的部分。云构建是CI/CD故事的核心。它将从Gitlab中克隆最新的源代码，并从代码中生成一个新的Docker映像。云构建将导致新构建的映像存储在工件存储库中，并最终指示云运行开始使用新构建的映像。所有这些都将是自动化的，这意味着对代码进行更改的开发人员不需要了解导致代码被部署的过程。</p><p id="ce39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将:</p><ul class=""><li id="4c36" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">创建一个GCP项目</li><li id="bfbb" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">启用一组GCP API</li><li id="e766" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">创建工件注册库</li><li id="456b" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">创建云构建触发器</li><li id="0bcd" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">创建SSH密钥</li><li id="c5c3" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">创造GCP秘密经理的秘密</li><li id="f5a4" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">从云市场安装和配置GitLab</li><li id="0e53" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">将它们连接在一起并进行测试</li></ul><p id="1ddc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在…食谱…</p><ol class=""><li id="dbc8" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn ki ka kb kc bi translated">创建项目</li></ol><p id="b044" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要一个在其中工作的GCP项目。在这个演示中，我们将假设一个全新的项目，并在这里创建一个。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/21239168124804003d5966064c05be0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DQz8ZX9Rf_10m2lc"/></div></div></figure><p id="7083" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创造一个VPC</p><p id="ab4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">遵循谷歌的最佳实践，我们不会假设使用默认的VPC网络，而是我们会为自己创建一个。首先，我们启用计算引擎API:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/391763c0fc5407eb2dabcfc1039cedbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HRo3aA5GexO6Frkg"/></div></div></figure><p id="2e30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来我们创建一个VPC，我们称之为<code class="du kl km kn ko b">my-vpc</code>。我们在<code class="du kl km kn ko b">us-central1</code>区域工作。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/e2a83cc119dc534aeacf61066f68f5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*deiE7FwMo1uurKaZ"/></div></div></figure><p id="601d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.创建允许端口22 (SSH)的防火墙规则</p><p id="bf2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本练习中，我们需要为新的VPC启用一个防火墙设置。这将允许使用SSH协议的入口(传入连接)。当我们安装GitLab时，我们将使用SSH协议与之交互。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/4fc5731e2e9b36b700aa56cb31f0ad7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6NEO1cT4Jb5p5VLU"/></div></div></figure><p id="f1b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.从Bitnami安装GitLab CE</p><p id="316e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然我们可以假设客户端已经安装并配置了GitLab，但在这个练习中，我们想要一个GitLab沙箱，可以用来测试代码更改和云构建执行之间的联系。GCP市场让我们只需点击几下鼠标就可以安装一个完全配置好的GitLab社区版。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/3944935e34e40654f3095b07415710e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bxYOQ4OPtHcGul-N"/></div></div></figure><p id="dcc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在安装过程中，我们会被要求启用一些GCP API。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/08405a21e71b43631f522b2de020cae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-8wC0heZxfiDdIFJ"/></div></div></figure><p id="c028" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们同意使用API，就会为我们将要创建的GitLab实例显示一个配置页面。我们将它安装到的区域命名为GCP区域(<code class="du kl km kn ko b">us-central1-a</code>)。我们还指定要使用多大的机器来运行它。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/dfdf0187ad95e4cde7c3eb1b7eb9cb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xA-MRZgrzkNx70u4"/></div></div></figure><p id="0670" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们单击“部署”时，GCP市场环境会创建一个计算引擎实例，并将GitLab安装和配置到该虚拟机中。不幸的是，在我的测试中，安装<em class="jt">似乎</em>停止了…然而，一切都工作正常，我怀疑这是我公司的组织政策非常严格的结果。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/85f9e797b0c924bfc23ff25c088fb1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*avV_PJq5XMCktd5R"/></div></div></figure><p id="6b6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成安装和配置大约需要10分钟。</p><p id="41f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.记下GitLab机器的IP地址(如<code class="du kl km kn ko b">34.68.171.109</code>)</p><p id="0c82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们已经有了一个GitLab实例并正在运行。为了使用它，我们必须确定实例的公共IP地址。我们访问云控制台中的计算引擎页面，并查找具有GitLab实例名称的虚拟机。记下公共外部IP地址。在后续步骤中，我们将多次需要这个值。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/b9597f0c1052a5d8b0e019602bd31b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_kT9o5jZAU4WP77o"/></div></div></figure><p id="a947" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.使用root/密码登录</p><p id="80bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在匿名浏览器窗口中，访问IP地址为虚拟机实例的<code class="du kl km kn ko b">http://&lt;IP Address&gt;</code>。您可能会得到一个SSL警告，只需接受并继续。使用“T3”的用户id和市场安装屏幕中显示的管理员密码登录(例如…如我们的截图所示— <code class="du kl km kn ko b">a17XHUq71y4f</code>)。</p><p id="847c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.更改root密码</p><p id="10ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根密码是随机的，这一步让我们把它改成一个容易记忆的值。</p><p id="d813" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择菜单&gt;管理</p><p id="d014" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后</p><p id="d1f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">概述&gt;用户</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/3f6c616e48cbc1411a23227e75c4b8c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GDDJ9_Wf9z5Lfau7"/></div></div></figure><p id="bf61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编辑管理员用户并提供新密码:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/1cf87008031611fc2468d2438f9e3905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sPlcm90CieBgojaV"/></div></div></figure><p id="08e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将立即被注销。使用root用户和新密码再次登录。</p><p id="c6b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.创建一个名为gcpbuild的GitLab用户</p><p id="6815" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">进入菜单&gt;管理</p><p id="7d35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后</p><p id="8dea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">概述&gt;用户</p><p id="1d9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单击“新建用户”按钮:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/f8f7f90579c6a021d8fe9b0f25e2164b.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/0*KnXCrDj15LP0kn10"/></div></figure><p id="9bb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将用户名设为<code class="du kl km kn ko b">gcpbuild</code>，并为电子邮件字段指定一个垃圾邮件地址。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/05c2e91c3ca39b2d2c44f019cc0aafbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kfn1EAapylauhUS2"/></div></div></figure><p id="2327" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建后，返回概览&gt;用户并编辑新的“<code class="du kl km kn ko b">gcpbuild</code>”用户。你现在会发现你可以设置一个密码。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/a36b055f374ff247f171ef4297dd71be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mFmIGQVZcd34C7kq"/></div></div></figure><p id="5ad6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">9.变成<code class="du kl km kn ko b">gcpbuild</code></p><p id="a548" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注销root用户，以<code class="du kl km kn ko b">gcpbuild</code>用户身份登录。系统将提示您设置新密码。我发现我可以将密码设置为刚才输入的密码。</p><p id="26a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">10.创建一个名为<code class="du kl km kn ko b">myproject</code>的gitlab项目</p><p id="f9cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经启动并运行了GitLab，并且有了一个可以登录的用户，我们可以创建一个项目来托管我们的源文件。在我们的例子中，我们称我们的项目为<code class="du kl km kn ko b">myproject</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/0bd992f3723413064ecab452b6072d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U5XF7r672APjk6CX"/></div></div></figure><p id="d4c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">11.打开一个GCP云壳</p><p id="2504" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步，我们将创建一些SSH密钥，并为我们提供一个可以编辑源代码的环境。我建议开一个GCP云壳。</p><p id="a39b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">12.创建一些SSH密钥</p><p id="115f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GitLab要求发送给它的请求必须经过认证。实现这一点最简单的方法是使用SSH认证。这意味着我们创建一些SSH密钥(公共的和私有的)。我们会把公钥交给GitLab，自己持有私钥。以下命令在<code class="du kl km kn ko b">.ssh</code>目录中创建一个键和一个配置文件。需要编辑配置文件以包含GitLab IP地址:</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="a56d" class="ld le hi ko b fi lf lg l lh li">cd ~/.ssh<br/>ssh-keygen -t ed25519 -f gitlab_key -q -N ""<br/>cat &lt;&lt; EOF &gt;&gt; config<br/>Host [GITLAB_IP]<br/>  IdentityFile ~/.ssh/gitlab_key<br/>EOF</span></pre><p id="06c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编辑配置文件并设置GitLab服务器的IP地址，替换为“<code class="du kl km kn ko b">[GITLAB_IP]</code></p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="f08e" class="ld le hi ko b fi lf lg l lh li">Host [GITLAB_IP]<br/>  IdentityFile ~/.ssh/gitlab_key</span></pre><p id="9ea8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">13.添加SSH密钥(公钥)</p><p id="08d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要将刚刚创建的公钥(文件<code class="du kl km kn ko b">gitlab_key.pub</code>的内容)与<code class="du kl km kn ko b">gcpbuild</code>用户关联起来。回到GitLab浏览器窗口，我们会看到一个按钮<code class="du kl km kn ko b">Add SSH Key</code>:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/36ccfe7ef51e9392d66d1abce50299a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*fysE0Z2US_5PihFv"/></div></figure><p id="f01c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将<code class="du kl km kn ko b">gitlab_key.pub</code>(SSH密钥对的公共部分)的内容粘贴到密钥文本区域，然后单击<code class="du kl km kn ko b">Add key</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/7685ebc9c893759359c772dfcf2491b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EvMgxCxUWVnzNyLy"/></div></div></figure><p id="30c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过从云Shell运行以下命令来测试安全性设置是否正确:</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="0690" class="ld le hi ko b fi lf lg l lh li">ssh -T git@[GITLAB_IP]</span></pre><p id="7589" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">14.制作工作目录</p><p id="a2d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在开始用文件填充GitLab项目。创建一个工作目录，我们将在其中放置工件。</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="52b8" class="ld le hi ko b fi lf lg l lh li">cd ~<br/>mkdir gitlab<br/>cd gitlab</span></pre><p id="0758" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">15.签出项目</p><p id="e6dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以克隆我们的项目了。</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="c95e" class="ld le hi ko b fi lf lg l lh li">git clone git@[GITLAB_IP]:gcpbuild/myproject.git</span></pre><p id="2db1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建一个名为<code class="du kl km kn ko b">myproject</code>的本地文件夹。切换到该文件夹:</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="9cc0" class="ld le hi ko b fi lf lg l lh li">cd myproject</span></pre><p id="d052" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">16.将以下文件添加到GitLab项目中。</p><p id="9808" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将添加一个<code class="du kl km kn ko b">Dockerfile</code>，一个python应用(<code class="du kl km kn ko b">app.py</code>)和一个Python需求文件(<code class="du kl km kn ko b">requirements.txt</code>)</p><p id="428d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Dockerfile文件</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="04f9" class="ld le hi ko b fi lf lg l lh li">FROM python:3<br/>WORKDIR /usr/src/app<br/>COPY app.py ./<br/>COPY requirements.txt ./<br/>RUN pip install --no-cache-dir -r requirements.txt<br/>CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 --timeout 0 app:app</span></pre><p id="945c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">app.py</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="0bfd" class="ld le hi ko b fi lf lg l lh li">from google.cloud import logging<br/>import os<br/>from flask import Flask</span><span id="63a6" class="ld le hi ko b fi ll lg l lh li">app = Flask(__name__)</span><span id="a2bd" class="ld le hi ko b fi ll lg l lh li"><a class="ae lm" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def runApp():<br/>    print("Starting!")<br/>    logging_client = logging.Client()<br/>    log_name = "my-log"<br/>    logger = logging_client.logger(log_name)<br/>    text = "Hello, world! - said the Python app!"<br/>    logger.log_text(text)<br/>    print("Logged a record to the log called my-log")<br/>    return "All Done"</span><span id="4181" class="ld le hi ko b fi ll lg l lh li">if __name__ == '__main__':<br/>    server_port = os.environ.get('PORT', '8080')<br/>    app.run(debug=False, port=server_port, host='0.0.0.0')</span></pre><p id="caa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">requirements.txt</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="43c3" class="ld le hi ko b fi lf lg l lh li">google-cloud-logging<br/>Flask<br/>gunicorn</span></pre><p id="dbba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例应用程序在Google Cloud Logging中记录一条记录，并向调用者返回一个文本字符串。应用程序做什么远没有我们在CI/CD方面展示的重要。</p><p id="78e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">17.提交和推送文件</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="e035" class="ld le hi ko b fi lf lg l lh li">git add .<br/>git commit -m ""<br/>git push</span></pre><p id="dcfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">18.启用云运行API</p><p id="5dcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在准备开始充实CI/CD任务。其中之一是启用云运行，以便它准备好开始为客户端调用提供应用程序。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/bc5436dfef7bd4b58cdcc18be65d2c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*0c_wRmbojmzT3Acw"/></div></figure><p id="b4c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">19.启用机密管理器API</p><p id="920e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为我们故事的一部分，我们将创造两个GCP的秘密。一个用于验证传入的请求是否有权开始云运行构建。当代码改变时，这将从GitLab到达。第二个秘密用于保存名为<code class="du kl km kn ko b">gcpbuild</code>的gitlab用户的私钥。云构建将使用它来检索源代码的最新版本。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/000364ce5744adf07ff5a77cf3a02df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tjDkiqbN0QAQ-wJN"/></div></div></figure><p id="844e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">20.创建一个名为<code class="du kl km kn ko b">gitlab-key</code>的秘密</p><p id="0b95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创造了第一个秘密。第一个叫做<code class="du kl km kn ko b">gitlab-key</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/d1eb85b416b7463a7837015a2e24f09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YZg13SZz2zWamfL3"/></div></div></figure><p id="a536" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">21.上传gitlab私钥文件或复制其数据</p><p id="8779" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将私钥文件数据复制到秘密的值中。这是GCP保密的秘密，供云构建使用。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/931bab8125a0e5a446aa541269890dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0jepa8edYRHZ4KMS"/></div></div></figure><p id="16c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">22.启用云构建API</p><p id="0493" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在使用云构建之前，我们必须启用它的API。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/f3c58acc90c24ba9769879eda406dca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/0*xmVRs1Ql0JwkMBEg"/></div></figure><p id="0a03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">23.更改设置以允许云运行和云机密</p><p id="4d7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云构建可能需要额外的权限才能执行其任务。我们需要启用“云运行”和“秘密管理器”。这为云构建授予了IAM权限，以创建/修改云运行定义并从Secret Manager中检索值。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/be9d8f836bbcc69f4d2115ec93d39d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FNqNJl7O9uuv_6Cn"/></div></div></figure><p id="8a6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">24.启用工件注册API。</p><p id="ceef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将把构建的Docker映像存储在工件注册中心的存储库中。我们必须先启用注册表API，然后才能使用它。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/2eb361f65d7f4d239d3d44e9134be357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*tJ6Wq7O-fLGmKjgt"/></div></figure><p id="1721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">25.创建一个名为my-repo的工件存储库。</p><p id="f632" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">启用工件注册中心后，我们现在在其中创建一个命名的存储库，可以保存Docker图像。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/d5eae6846646f8db7ed236a081b5670a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jDgqTkqN8R2cZMgv"/></div></div></figure><p id="76be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">26.在云构建中创建WebHook触发器</p><p id="486c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经接近尾声了。当来自GitLab的请求通知我们源代码已经更改时，我们希望Cloud Build执行并构建Docker映像。GitLab能够在检测到变化时调用WebHook。我们在Cloud Build中创建一个将与GitLab关联的触发器。触发器还指定了我们希望云构建运行的方法。在本文中，我们不打算讨论云构建的细节，但重要的是要理解，您必须修改<code class="du kl km kn ko b">_GITLAB_IP</code>和<code class="du kl km kn ko b">_PROJECT_NUMBER</code>值，以对应您的GitLab实例的IP地址和您的GCP项目编号。</p><p id="a9ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配方中包含的最高级别的步骤是:</p><ul class=""><li id="8e66" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">复制私有密钥，允许Git运行在Cloud Build许可中来克隆项目。</li><li id="ec97" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">将项目从GitLab克隆到本地目录。</li><li id="e434" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">从Docker文件和GitLab项目中的工件构建Docker映像。</li><li id="8c72" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">将得到的Docker图像推送到工件注册中心</li><li id="819d" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">将新的Docker映像部署到我们的云运行环境中</li></ul><p id="a86e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">名称:<code class="du kl km kn ko b">mytrigger</code> <br/>事件:<code class="du kl km kn ko b">Webhook URL</code> <br/>秘密:<code class="du kl km kn ko b">CREATE SECRET</code> <br/>配置:内联如下</p><pre class="jp jq jr js fd kz ko la lb aw lc bi"><span id="9668" class="ld le hi ko b fi lf lg l lh li">steps:<br/>  - name: gcr.io/cloud-builders/git<br/>    args:<br/>      - '-c'<br/>      - |<br/>        echo "$$SSHKEY" &gt; /root/.ssh/id_rsa<br/>        chmod 400 /root/.ssh/id_rsa<br/>        ssh-keyscan ${_GITLAB_IP} &gt; /root/.ssh/known_hosts<br/>    entrypoint: bash<br/>    secretEnv:<br/>      - SSHKEY<br/>    volumes:<br/>      - name: ssh<br/>        path: /root/.ssh<br/>  - name: gcr.io/cloud-builders/git<br/>    args:<br/>      - clone<br/>      - 'git@${_GITLAB_IP}:${_GITLAB_NAME}.git'<br/>      - .<br/>    volumes:<br/>      - name: ssh<br/>        path: /root/.ssh<br/>  - name: gcr.io/cloud-builders/docker<br/>    args:<br/>      - build<br/>      - '-t'<br/>      - '${_ARTIFACT_REPO}'<br/>      - .<br/>  - name: gcr.io/cloud-builders/docker<br/>    args:<br/>      - push<br/>      - '${_ARTIFACT_REPO}'<br/>  - name: gcr.io/google.com/cloudsdktool/cloud-sdk<br/>    args:<br/>      - run<br/>      - deploy<br/>      - my-service<br/>      - '--image'<br/>      - '${_ARTIFACT_REPO}'<br/>      - '--region'<br/>      - us-central1<br/>      - '--allow-unauthenticated'<br/>    entrypoint: gcloud<br/>substitutions:<br/>  _PROJECT_NUMBER: '689284316634'<br/>  _GITLAB_IP: 34.123.168.233<br/>  _ARTIFACT_REPO: 'us-central1-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REPO_NAME}/myimg'<br/>  _GITLAB_NAME: gcpbuild/myproject<br/>  _ARTIFACT_REPO_NAME: my-repo<br/>availableSecrets:<br/>  secretManager:<br/>    - versionName: 'projects/${_PROJECT_NUMBER}/secrets/gitlab-key/versions/1'<br/>      env: SSHKEY</span></pre><p id="8d63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">27.授予<code class="du kl km kn ko b">[PROJECT_NUMBER]-compute@developer.gserviceaccount.com</code>日志作者角色</p><p id="bc54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们希望在云运行中运行的应用程序希望写入云日志。因此，我们必须允许云运行写入云日志。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/ddbd8900cbee65c3bc97f404da52c486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h0ATVQ9ZNRhT8lo8"/></div></div></figure><p id="5b6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">28.在Gitlab中创建WebHook触发器</p><p id="64ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在云构建中创建了触发器，当被调用时，它将重建映像并部署到云运行。现在我们必须配置GitLab来调用WebHook，从而触发云构建:</p><p id="95f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在设置&gt; Webhooks下</p><p id="e153" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从云构建触发器获取URL:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/918a69cf2ef02c3a6a81fe205a99783d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RxZ977TAUt5T01el"/></div></div></figure><p id="bb42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">29.在GitLab中测试webhook。</p><p id="8b43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GitLab有自己的测试环境来对WebHook进行单元测试。</p><p id="f01d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">30.运行云运行功能，并显示其有效。</p><p id="9011" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当重建完成后，我们可以运行云运行功能，并看到它的工作。</p><p id="8ed5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">31.更改代码并查看云构建运行和更改发生的情况。</p><p id="40c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在GitLab中，我们现在可以更改源代码，并看到新代码被重新部署到Cloud Run。</p><p id="d05e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，在我们的说明性故事中，许多步骤都有一个重要的目的。作为辅助，这里再次是同一个故事，但这一次作为一个录音走过执行GCP与额外的评论。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>