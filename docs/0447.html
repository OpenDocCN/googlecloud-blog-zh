<html>
<head>
<title>Using Microservices and Kubernetes Pods to hide Google Pub/Sub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用微服务和Kubernetes Pods隐藏谷歌发布/订阅</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-microservice-and-kubernetes-pods-to-hide-google-pub-sub-f00a18fa3159?source=collection_archive---------1-----------------------#2017-11-30">https://medium.com/google-cloud/using-microservice-and-kubernetes-pods-to-hide-google-pub-sub-f00a18fa3159?source=collection_archive---------1-----------------------#2017-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c18a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<a class="ae jd" rel="noopener" href="/citerus/microservices-events-and-cqrs-at-klarity-f9ca6c0855eb">事件驱动系统</a>运行在谷歌云上，使我们能够传递所有这些事件的核心是谷歌的消息服务<a class="ae jd" href="https://cloud.google.com/pubsub/docs/overview" rel="noopener ugc nofollow" target="_blank"> Pub/Sub </a>。从很多方面来说，这都是一次很棒的经历，但是有些事情让我们很恼火。其中之一是它使用起来有点麻烦，SDK(在我们的例子中是Java)并不那么直观，它还处于测试阶段(当我们开始使用它的时候是Alpha版本)，而且事情还在不断变化。</p><p id="77cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们试图通过创建一个库来解决这个问题，在这里我们创建了一些抽象来隐藏Pub/Sub SDK的本质细节。这使它稍微好了一点，但我们仍然有其他问题。例如传递依赖(远离库的好理由)。我们的发布/订阅SDK的测试版与我们的<a class="ae jd" href="https://cloud.google.com/datastore/docs/concepts/overview" rel="noopener ugc nofollow" target="_blank">数据存储</a> SDK的1.0版本冲突。</p><p id="ee36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一天在上班的公交车上，我有一个想法，为什么不把这个(发布/订阅集成)放在微服务中呢？我们已经在几乎所有的事情上这样做了，为什么不呢？我们使用<a class="ae jd" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Kubernetes引擎</a>并将我们所有的服务部署为Docker容器。在Kubernetes中有一个概念叫做Pod，它是一组共享网络和存储的容器。Pod中的两个容器可以通过本地主机相互通信。很好，那么让我们给所有与Pub/Sub对话的服务一个伙伴，以Pub/Sub桥服务的形式运行在同一个Pod中。不再与Pub/Sub直接交互，只需http。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f863a8339783e696ee45f54afc8651f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bW7ACogCitHo0OYzI--X0g.png"/></div></div></figure><p id="0aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Pub/Sub bridge服务可以配置任意多的订阅或发布者(但对我们来说，通常只有一个订阅或一个发布者，我们的服务毕竟很小)。</p><p id="6f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实证明，这种方法给我们带来了很多好处。</p><ul class=""><li id="caf6" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">松散耦合意味着没有传递依赖性的噩梦。</li><li id="b332" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">这也意味着我们可以很容易地切换出Pub/Sub，并使用其他东西进行消息传输。</li><li id="e44d" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">我们变得与语言无关，为out Node.js服务添加发布/订阅集成将变得轻而易举。</li><li id="acff" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">黑盒测试业务服务变得更加容易和确定，因为我们现在可以使用同步http而不是异步消息传递。</li><li id="9d81" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">我们可以使用内置在web应用程序框架中的基于路径的路由逻辑，这使得订阅更加容易。</li></ul><p id="ab0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了支持最后一点，我们在配置订阅者时可以在url中使用发布/订阅消息属性，因此您可以使用类似于<a class="ae jd" href="http://localhost:8080/{attribute:aggregateType}/events/{attribute:aggregateType}" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/{ attribute:aggregate type }/events/{ attribute:event type }</a>的内容，这些占位符将替换为相应的消息属性值。</p><p id="1ffa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们现在可以有:</p><pre class="jf jg jh ji fd ke kf kg kh aw ki bi"><span id="ee75" class="kj kk hi kf b fi kl km l kn ko">@PostMapping("/case/events/case_created_event")<br/>fun caseCreated(@RequestBody event: CaseCreatedEvent) {<br/>    // Do something<br/>}<br/><br/>@PostMapping("/case/events/description_added_event")<br/>fun descriptionAdded(@RequestBody event: CaseDescriptionAddedEvent) {<br/>    // Do something<br/>}</span></pre><p id="34a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而不是像这样:</p><pre class="jf jg jh ji fd ke kf kg kh aw ki bi"><span id="d65c" class="kj kk hi kf b fi kl km l kn ko">override fun receiveMessage(message: PubsubMessage, consumer: AckReplyConsumer) {<br/>    val eventType = message.getAttributesOrThrow("eventType")<br/>    when(eventType) {<br/>        "case_created_event" -&gt; handleCaseCreated(consumer, message.<em class="kp">attributesMap</em>, convert(message.<em class="kp">data</em>, CaseCreatedEvent::class.<em class="kp">java</em>)) <br/>        "description_added_event" -&gt; handleDescriptionAdded(consumer, message.<em class="kp">attributesMap</em>, convert(message.<em class="kp">data</em>, DescritionAddedEvent::class.<em class="kp">java</em>)) <br/>    }<br/>}</span></pre><p id="93bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干净多了！</p><p id="9750" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发布/订阅桥服务将根据它从http POST到业务服务的响应来确认/否定消息。Http 503或连接问题，它将否定它(因此消息将在以后重新传递)，对于任何其他错误，它将只记录它并确认消息。当你拒绝信息时，你应该始终保持警惕，如果信息实际上已经损坏，并且永远无法处理，它会阻塞你的话题。发生在我们身上…</p><p id="8b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，这就是我们所做的，让Pub/Sub提供我们想要的所有价值，同时减少我们的负担。到目前为止，我们很高兴，但我们只是刚刚实施它，我们将在一个月后看看我们的感觉。</p></div></div>    
</body>
</html>