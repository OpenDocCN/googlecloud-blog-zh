<html>
<head>
<title>Kubernetes w/ Let’s Encrypt &amp; Cloud DNS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes让我们加密和云DNS</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-w-lets-encrypt-cloud-dns-c888b2ff8c0e?source=collection_archive---------0-----------------------#2018-05-17">https://medium.com/google-cloud/kubernetes-w-lets-encrypt-cloud-dns-c888b2ff8c0e?source=collection_archive---------0-----------------------#2018-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="dd44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能已经做得太多了，但是我没有使用自动化的方法来为Kubernetes服务生成证书，并且<code class="du jd je jf jg b">cert-manager</code>承认它的文档需要改进:</p><p id="6ea9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jh" href="https://cert-manager.readthedocs.io/en/latest/tutorials/acme/dns-validation.html" rel="noopener ugc nofollow" target="_blank">https://cert-manager . readthedocs . io/en/latest/tutorials/acme/DNS-validation . html</a></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/e3caf880188197c285166c5284a7e9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIktmCBEjPU7jE2AUwmpkA.png"/></div></div></figure><p id="2ee0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我偶然看到了Ross Kukulinski的帖子“<a class="ae jh" href="https://kukulinski.com/lets-encrypt-kubernetes/" rel="noopener ugc nofollow" target="_blank">让我们加密Kubernetes </a>”，但承诺已久的使用“让我们加密”的“第二部分”尚未发布。所以，这篇文章就是其中的一大部分。</p><p id="7ad7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在完全公开的情况下，我没有(可能是错误地)使用Kelsey Hightower的<a class="ae jh" href="https://github.com/kelseyhightower/kube-cert-manager" rel="noopener ugc nofollow" target="_blank"> Kubernetes证书管理器</a>。如果我有时间，我也会利用这段时间更新这篇文章。</p><p id="d3af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，下面是我如何能够使用Jetstack的<a class="ae jh" href="https://github.com/jetstack/cert-manager" rel="noopener ugc nofollow" target="_blank"> cert-manager </a>来生成cert，使用<a class="ae jh" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">来加密</a>，使用<a class="ae jh" href="https://cloud.google.com/dns" rel="noopener ugc nofollow" target="_blank">云DNS </a>和<a class="ae jh" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Kubernetes引擎</a>来保护(带有警告)一个普通的Golang http服务。</p><blockquote class="ju jv jw"><p id="7ad5" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">注意事项</strong>:我使用了Let ' s Encrypt staging not production service；我在本地转发服务，而不是公开它来测试结果。当我有时间的时候，我会解决这两个限制。</p></blockquote><h2 id="fbb4" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated"><strong class="ak">更新18–05–17</strong></h2><p id="79a3" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">帖子现在从四个方面描述了解决方案:</p><ul class=""><li id="69c2" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">自签名证书</li><li id="06df" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">带有TLS后端的网络负载平衡器</li><li id="bf23" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">带有非TLS后端的HTTPS负载平衡器</li><li id="1e03" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">带有TLS后端的HTTPS负载平衡器。</li></ul><h2 id="1f32" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">设置</h2><p id="6e8c" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">给自己拿一个新的Kubernetes(引擎),并对其进行认证。给自己太多的机会(**除了个人发展/测试* *，不要这样做)RBAC信条:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="4f2b" class="kb kc hi jg b fi lt lu l lv lw">PROJECT=[[YOUR-PROJECT]]<br/>REGION=[[YOUR-REGION]]<br/>CLUSTER=[[YOUR-CLUSTER]]<br/>BILLING=[[YOUR-BILLING]]<br/>LATEST=[[SEE-NOTE-BELOW]]</span><span id="d059" class="kb kc hi jg b fi lx lu l lv lw">gcloud projects create $PROJECT<br/>gcloud beta billing projects link $PROJECT \<br/>--billing-account=$BILLING</span><span id="0291" class="kb kc hi jg b fi lx lu l lv lw">gcloud services enable container.googleapis.com \<br/>--project=$PROJECT</span><span id="6bba" class="kb kc hi jg b fi lx lu l lv lw">gcloud beta container clusters create $CLUSTER \<br/>--username="" \<br/>--cluster-version=${LATEST} \<br/>--machine-type=custom-1-4096 \<br/>--image-type=COS \<br/>--num-nodes=1 \<br/>--enable-autorepair \<br/>--enable-autoscaling \<br/>--enable-autoupgrade \<br/>--enable-cloud-logging \<br/>--enable-cloud-monitoring \<br/>--min-nodes=1 \<br/>--max-nodes=2 \<br/>--region=${REGION} \<br/>--project=${PROJECT} \<br/>--preemptible \<br/>--scopes="<a class="ae jh" href="https://www.googleapis.com/auth/cloud-platform" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-platform</a>"</span><span id="2973" class="kb kc hi jg b fi lx lu l lv lw">gcloud beta container clusters get-credentials $CLUSTER \<br/>--project=${PROJECT} \<br/>--region=${REGION}</span><span id="5ffa" class="kb kc hi jg b fi lx lu l lv lw">kubectl create clusterrolebinding $(whoami)-cluster-admin-binding \<br/>--clusterrole=cluster-admin \<br/>--user=$(gcloud config get-value account)</span></pre><blockquote class="ju jv jw"><p id="0ba7" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong> I <a class="ae jh" rel="noopener" href="/google-cloud/kubernetes-engine-master-node-versions-b5ecd9ed0b35">最近写了</a>关于自动确定最近(或最新)主节点版本的方法。使用您喜欢的版本或查看帖子中描述的3种方法来确定<code class="du jd je jf jg b">${LATEST}</code>的值。</p></blockquote><p id="f70c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复制一份Ross的Golang代码，或者——如果你愿意的话——使用他的Docker图像(<code class="du jd je jf jg b">rosskukulinski/secure-go-app</code>)。我没有使用过他的图像，也不能证明这一点。或者，如果你愿意这样做，可以抓取我的Docker图片(<code class="du jd je jf jg b">dazwilkin/securego</code>)。</p><blockquote class="ju jv jw"><p id="e916" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">罗斯的图像使用<code class="du jd je jf jg b">443</code>端口，而我的图像使用<code class="du jd je jf jg b">8443</code>端口，这只是一个偏好。</p></blockquote><h2 id="c133" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">自签名证书</h2><p id="b976" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我喜欢罗斯的方法。他逐步构建。通常，我会在本地运行代码，然后在本地但被容器化，然后部署到Kubernetes。但是，让我们切入正题，把它留给你的家庭作业。如果您这样做，我建议您考虑参数化证书和密钥的位置。</p><p id="fc5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将首先创建一个自签名证书，将其作为一个秘密部署到Kubernetes，然后将装载了该秘密的映像作为一个卷部署(在<code class="du jd je jf jg b">/secure/</code>上)</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="8b0f" class="kb kc hi jg b fi lt lu l lv lw">PREFIX=securego<br/>DOMAIN=[[YOUR-DOMAIN]]<br/>NAME=${PREFIX}.${DOMAIN}<br/>openssl req \<br/>-x509 \<br/>-nodes \<br/>-days 365 \<br/>-newkey rsa:2048 \<br/>-keyout ${NAME}.key \<br/>-out ${NAME}.crt \<br/>-subj "/CN=${NAME}"</span></pre><blockquote class="ju jv jw"><p id="5cca" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>你需要访问一个域，这一切才能工作。有很多方法可以获得这些。我使用<a class="ae jh" href="https://domains.google/" rel="noopener ugc nofollow" target="_blank">谷歌域名</a>并且——上一次我检查过——谷歌(我的雇主)实际上并没有把这些域名和谷歌云域名系统结合起来使用。这篇文章假设您正在使用云DNS来管理您的域，但是这并不是工具的要求。</p></blockquote><p id="a49f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在为自己工作，但我喜欢让我的X509证书和密钥按照它们的域明确命名，这样我就可以区分它们。当我们为证书和密钥创建Kubernetes secret时，它希望文件被称为<code class="du jd je jf jg b">tls.crt</code>和<code class="du jd je jf jg b">tls.key</code>，因此请注意下面命令中的<code class="du jd je jf jg b">— from-file</code>映射:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="c41a" class="kb kc hi jg b fi lt lu l lv lw">kubectl create secret generic selfsigned \<br/>--from-file=tls.key=./${NAME}.key \<br/>--from-file=tls.crt=./${NAME}.crt</span></pre><p id="cffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需要一个结合了映像、其端口以及我们的证书和密钥的部署规范:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5983" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="fe2f" class="kb kc hi jg b fi lt lu l lv lw">kubectl apply --filename=securego.deployment.yaml</span></pre><p id="bb58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其将部署作为服务公开，不如使用kubectl将部署创建的pod进行移植。然后，我们可以局部地卷曲向前端口:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="8928" class="kb kc hi jg b fi lt lu l lv lw">POD=$(\<br/>kubectl get pods \<br/>--selector=app=securego \<br/>--output=jsonpath="{.items[0].metadata.name}")</span><span id="18cd" class="kb kc hi jg b fi lx lu l lv lw">kubectl port-forward ${POD} 8443:8443</span></pre><p id="913d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从一个单独的外壳中:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="def4" class="kb kc hi jg b fi lt lu l lv lw">curl --insecure <a class="ae jh" href="https://localhost:8443" rel="noopener ugc nofollow" target="_blank">https://localhost:8443</a></span></pre><p id="815a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您使用我的图像，您应该会收到:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="7ad4" class="kb kc hi jg b fi lt lu l lv lw">Hello Henry!</span></pre><h2 id="8f67" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">证书管理器</h2><p id="7e29" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">你可以使用头盔展开<code class="du jd je jf jg b">cert-manager</code>。Helm是Kubernetes事实上的“包装”经理。它非常优秀，如果您还没有这样做，我建议您对它进行评估。我很懒，所以我使用Kubernetes规范直接部署了cert-manager:</p><p id="469f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jh" href="https://cert-manager.readthedocs.io/en/latest/getting-started/2-installing.html#with-static-manifests" rel="noopener ugc nofollow" target="_blank">https://cert-manager . readthedocs . io/en/latest/getting-started/2-installing . html # with-static-manifests</a></p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="e6da" class="kb kc hi jg b fi lt lu l lv lw">go get github.com/jetstack/cert-manager<br/>cd ../jetstack/cert-manager/<br/>cd contrib/manifests/cert-manager/rbac</span><span id="7bc9" class="kb kc hi jg b fi lx lu l lv lw">kubectl apply --filename=.</span></pre><blockquote class="ju jv jw"><p id="4a92" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:如果您依赖于上一步中的Docker图像，即您之前没有使用Golang代码，您将需要设置一个Golang工作空间。</p></blockquote><p id="43f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切正常，<code class="du jd je jf jg b">cert-manager</code>应该已经创建了一个名为<code class="du jd je jf jg b">cert-manager</code>的名称空间，其中包含一个名为<code class="du jd je jf jg b">cert-manager</code>的部署:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ma"><img src="../Images/c59a929445d308c9cc5bd44bb7f47385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TK-6-mmWaOr6J8kFblZJbg.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">证书管理器</figcaption></figure><p id="fcf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在必须配置cert-manager来自动为我们创建证书。这需要配置一个(n) <code class="du jd je jf jg b">[Cluster]Issuer</code>和一个<code class="du jd je jf jg b">Certificate</code>。在我的例子中，这是最费时的部分，所以我会试着解释你需要什么和在哪里。</p><p id="f2a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用的是ClusterIssuer，它将为集群中的任何名称空间提供证书。我觉得你也应该用这个。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ly lz l"/></div></figure><blockquote class="ju jv jw"><p id="c3e0" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>在我的例子中，包含我的云DNS区域的项目不同于包含Kubernetes引擎集群的项目。这是完全可能的情况。</p><p id="d4ae" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">提供一个合法的电子邮件地址，让我们加密你可能收到的邮件。</p><p id="dc72" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">NB</strong>T5<code class="du jd je jf jg b">cert-manager</code>使用。您不需要为自己创建名为<code class="du jd je jf jg b">letsencrypt-staging</code>的秘密。我建议你保持原样。</p><p id="fe36" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">你确实需要创建<code class="du jd je jf jg b">clouddns</code> <code class="du jd je jf jg b">serviceAccountSecretRef</code>条目(见下文)。</p></blockquote><p id="8ee6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">cert-manager</code>使用服务帐户向DNS添加|删除条目，以向Let's Encrypt服务证明您对该域的所有权。为此，我们必须创建一个服务帐户，为其分配适当的权限，并将服务帐户公开给<code class="du jd je jf jg b">cert-manager</code>部署(作为Kubernetes的秘密)。</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="9d66" class="kb kc hi jg b fi lt lu l lv lw">ROBOT=clouddns<br/>DNS=[[YOUR-CLOUD-DNS-PROJECT]]</span><span id="de28" class="kb kc hi jg b fi lx lu l lv lw">gcloud iam service-accounts create ${ROBOT} \<br/>--display-name=${ROBOT} \<br/>--project=${DNS}</span><span id="fab1" class="kb kc hi jg b fi lx lu l lv lw">gcloud iam service-accounts keys create ./${ROBOT}.key.json \<br/>--iam-account=clouddns@${DNS}.iam.gserviceaccount.com \<br/>--project=${DNS}</span><span id="c88b" class="kb kc hi jg b fi lx lu l lv lw">gcloud projects add-iam-policy-binding ${DNS} \<br/>--member=serviceAccount:${ROBOT}@${DNS}.iam.gserviceaccount.com \<br/>--role=roles/dns.admin</span><span id="c525" class="kb kc hi jg b fi lx lu l lv lw">kubectl create secret generic clouddns \<br/>--from-file=./clouddns.key.json \<br/>--namespace=cert-manager</span></pre><blockquote class="ju jv jw"><p id="5dd2" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>上图中<code class="du jd je jf jg b">DNS</code>的值很可能与<code class="du jd je jf jg b">PROJECT</code>的值相同；如果<code class="du jd je jf jg b">${DNS}</code> == <code class="du jd je jf jg b">${PROJECT}</code>，那也行。如果您的DNS项目不同，请确保正确设置值。</p></blockquote><p id="b9e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在cert-manager可以访问服务帐户，您可以部署颁发者:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="f3fb" class="kb kc hi jg b fi lt lu l lv lw">kubectl apply --filename=certmanager.issuer.yaml</span></pre><p id="f141" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用Google Cloud Console中的Kubernetes工作负载浏览器来查看Pod(！idspnonenote)的日志条目。)是证书管理器部署的基础。如果您检查日志，您应该会看到类似下面的内容:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mf"><img src="../Images/5684837c6b7286c7415887783db7c106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_AucBrbNGB5nrby7jHx5g.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">证书管理器的Pod(成功)日志</figcaption></figure><p id="c521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以将证书请求应用到证书管理器发行者。这是橡胶上路的地方，如果一切顺利，我们的证书不仅会被创建，而且还会被配置为Kubernetes的秘密，供我们使用。以下是证书规范:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="73cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>在我这里，<code class="du jd je jf jg b">[[YOUR-DOMAIN]]</code>的值是<code class="du jd je jf jg b">dazwilkin.com</code>。这个文件多次重复了<code class="du jd je jf jg b">[[YOUR-DOMAIN]]</code>条目，可能不需要全部。这是适合我的配置。</p><p id="e121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切正常，您现在应该有一个叫做<code class="du jd je jf jg b">securego</code>的Kubernetes秘密。</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="c9d5" class="kb kc hi jg b fi lt lu l lv lw">kubectl get secrets/securego<br/>NAME                     TYPE                DATA      AGE<br/>securego                 kubernetes.io/tls   2         2h</span></pre><p id="d3eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以通过。这是我的修订结果:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="95d4" class="kb kc hi jg b fi lt lu l lv lw">kubectl describe certificate/securego-dazwilkin-com</span><span id="77f3" class="kb kc hi jg b fi lx lu l lv lw">Name:         securego<br/>Namespace:    default<br/>API Version:  certmanager.k8s.io/v1alpha1<br/>Kind:         Certificate<br/>Metadata:<br/>  Cluster Name:        <br/>  Creation Timestamp:  2018-05-16T21:54:22Z<br/>  Generation:          0<br/>  Resource Version:    49010<br/>Spec:<br/>  Acme:<br/>    Config:<br/>      Dns 01:<br/>        Provider:  clouddns<br/>      Domains:<br/>        securego.dazwilkin.com<br/>  Common Name:  securego.dazwilkin.com<br/>  Dns Names:<br/>    securego.dazwilkin.com<br/>  Issuer Ref:<br/>    Kind:       ClusterIssuer<br/>    Name:       letsencrypt-staging<br/>  Secret Name:  securego<br/>Status:<br/>  Acme:<br/>    Order:<br/>  Conditions:<br/>    Last Transition Time:  2018-05-16T21:56:56Z<br/>    Message:               Certificate issued successfully<br/>    Reason:                CertIssued<br/>    Status:                True<br/>    Type:                  Ready<br/>    Last Transition Time:  &lt;nil&gt;<br/>    Message:               Order validated<br/>    Reason:                OrderValidated<br/>    Status:                False<br/>    Type:                  ValidateFailed<br/>Events:                    &lt;none&gt;</span></pre><p id="c108" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且，您可以修改<code class="du jd je jf jg b">securego</code>部署来反映这个新证书:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ly lz l"/></div></figure><blockquote class="ju jv jw"><p id="3c85" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>单数变化是第27行的secretName。从<code class="du jd je jf jg b">selfsigned</code>到<code class="du jd je jf jg b">securego</code>。</p></blockquote><p id="808b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您不会立即注意到任何差异，因为服务已经由证书保护。因此，让我们先检查一下提供给我们的证书，然后再换成<code class="du jd je jf jg b">cert-manager</code>为我们提供的加密证书:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="c29a" class="kb kc hi jg b fi lt lu l lv lw">POD=$(\<br/>kubectl get pods \<br/>--selector=app=securego \<br/>--output=jsonpath="{.items[0].metadata.name}")</span><span id="b1cb" class="kb kc hi jg b fi lx lu l lv lw">kubectl port-forward ${POD} 8443:8443</span></pre><p id="652f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，从另一个壳里:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="ed3d" class="kb kc hi jg b fi lt lu l lv lw">openssl s_client \<br/>-servername securego.[[YOUR-DOMAIN]] \<br/>-connect localhost:8443 \<br/>| less</span></pre><p id="0a7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该会看到类似如下的内容:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="845b" class="kb kc hi jg b fi lt lu l lv lw">verify error:num=18:self signed certificate<br/>verify return:1<br/>depth=0 CN = securego.[[YOUR-DOMAIN]]<br/>verify return:1<br/>CONNECTED(00000003)<br/>---<br/>Certificate chain<br/> 0 s:/CN=securego.[[YOUR-DOMAIN]]<br/>   i:/CN=securego.[[YOUR-DOMAIN]]<br/>---<br/>Server certificate<br/>-----BEGIN CERTIFICATE-----<br/>...<br/>-----END CERTIFICATE-----<br/>subject=/CN=securego.[[YOUR-DOMAIN]]<br/>issuer=/CN=securego.[[YOUR-DOMAIN]]</span></pre><p id="2d44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>它报告<code class="du jd je jf jg b">self signed certificate</code>。您还应该看到您的域以我们在开始时使用的<code class="du jd je jf jg b">securego</code>主机为前缀。</p><p id="220a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在您可以应用基于加密的部署了:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="f411" class="kb kc hi jg b fi lt lu l lv lw">kubectl apply --filename=securego.deployment.yaml</span></pre><p id="f7de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署将替换Pod，因此，一旦稳定下来，重复获取Pod并进行端口转发的命令，然后重复<code class="du jd je jf jg b">openssl</code>查找。这一次，您应该会看到类似如下的内容:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="1570" class="kb kc hi jg b fi lt lu l lv lw">CONNECTED(00000003)<br/>---<br/>Certificate chain<br/> 0 s:/CN=securego.[[YOUR-DOMAIN]]<br/>   i:/CN=Fake LE Intermediate X1<br/> 1 s:/CN=Fake LE Intermediate X1<br/>   i:/CN=Fake LE Root X1<br/>---<br/>Server certificate<br/>-----BEGIN CERTIFICATE-----<br/>...<br/>-----END CERTIFICATE-----<br/>subject=/CN=securego.[[YOUR-DOMAIN]]<br/>issuer=/CN=Fake LE Intermediate X1<br/>---</span></pre><p id="27ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>链条现在包括<code class="du jd je jf jg b">Fake LE Intermediate X1</code>和<code class="du jd je jf jg b">Fake LE Root X1</code>。这些是由Let's Encrypt的staging(！idspnonenote)使用的合法证书。)环境。发行人也是<code class="du jd je jf jg b">Fake LE Intermediate X1</code>。</p><h2 id="ebca" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">网络LB和云DNS</h2><p id="593f" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">好吧，我在帖子的顶部提到过，我没有通过Kubernetes服务和公共负载平衡器测试过这个。所以，让我们开始吧。</p><blockquote class="ju jv jw"><p id="d15d" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">如您所知，支持我们Kubernetes服务的Docker容器期望流量通过TLS。L7|HTTPS负载平衡器终止TLS连接。然后，它可以为其后端重新加密流量，但这不是我们所建立的。相反，我们必须有一个网络负载平衡器，因为这只会将流量路由到后端，而不会终止TLS。网络LBs在Kubernetes中用<code class="du jd je jf jg b"> — type=LoadBalancer</code>表示。</p></blockquote><p id="4e7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有3个步骤。首先，我们必须将服务公开为<code class="du jd je jf jg b">— type=LoadBalancer</code>。其次，我们必须用为我们配置的负载平衡器的端点来配置我们的DNS。第三，我们使用curl和openssl查找服务的证书。</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="3c1d" class="kb kc hi jg b fi lt lu l lv lw">kubectl expose deployment/securego \<br/>--port=443 \<br/>--target-port=8443 \<br/>--type=LoadBalancer</span></pre><blockquote class="ju jv jw"><p id="e5cc" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>我们可以通过服务重新映射端口。在上面的例子中，我公开了端口443上的服务，尽管容器在端口8443上。</p></blockquote><p id="ebe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这导致了网络LB</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mg"><img src="../Images/c69716d12eafbc6b3290634325b16396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzQiF51AdemJM2vg0X_7cg.png"/></div></div></figure><p id="8121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，还必须在DNS服务中配置一个端点(公共IP)作为<code class="du jd je jf jg b">securego.[[YOUR-DOMAIN]]</code>的别名。在我的例子中，<code class="du jd je jf jg b">35.233.171.159</code>被映射到云DNS中的<code class="du jd je jf jg b">securego.dazwilkin.com</code>:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mh"><img src="../Images/4ea76cba4652c9f3b3a32bbde6e7a6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXfh9ZD0wNMLvPMh0BdFoQ.png"/></div></div></figure><p id="8d22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦DNS条目被更改，我们必须等待它的传播，您可以定期检查它以更新:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="6aec" class="kb kc hi jg b fi lt lu l lv lw">nslookup securego.[[YOUR-DOMAIN]] 8.8.8.8</span></pre><p id="607c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相对而言，我很快就会收到:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="345c" class="kb kc hi jg b fi lt lu l lv lw">Server:         8.8.8.8<br/>Address:        8.8.8.8#53</span><span id="2195" class="kb kc hi jg b fi lx lu l lv lw">Non-authoritative answer:<br/>Name:   securego.dazwilkin.com<br/>Address: 35.233.171.159            # Your IP will differ</span></pre><p id="eee6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="d1d3" class="kb kc hi jg b fi lt lu l lv lw">curl --insecure <a class="ae jh" href="https://securego.dazwilkin.com" rel="noopener ugc nofollow" target="_blank">https://securego.[</a>[YOUR-DOMAIN]]<br/>Hello Henry!</span></pre><p id="dfde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更有用的是:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="5184" class="kb kc hi jg b fi lt lu l lv lw">openssl s_client \<br/>-servername secure.dazwilkin.com \<br/>-connect 35.233.171.159:443           # Your IP will differ</span></pre><h2 id="5528" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">日志</h2><p id="b12d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">您可能希望从命令行查看日志:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="3abd" class="kb kc hi jg b fi lt lu l lv lw">FILTER="resource.type=\"container\" resource.labels.cluster_name=\"letsencrypt-01\" resource.labels.namespace_id=\"cert-manager\""</span><span id="2a0e" class="kb kc hi jg b fi lx lu l lv lw">gcloud beta  logging read "$FILTER" \<br/>--order=asc \<br/>--project=$PROJECT \<br/>--format="json" \<br/>| jq --raw-output .[].textPayload</span></pre><p id="911d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是使用我的配置成功运行的例子:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="6de0" class="kb kc hi jg b fi lt lu l lv lw">Calling GetOrder<br/>Calling GetAuthorization<br/>Calling DNS01ChallengeRecord<br/>Cleaning up old/expired challenges for Certificate default/securego-dazwilkin-com<br/>Calling GetChallenge<br/>Checking DNS propagation for "securego.dazwilkin.com" using name servers: [10.19.240.10:53]<br/>Waiting DNS record TTL (60s) to allow propagation of DNS record for domain "_acme-challenge.securego.dazwilkin.com."<br/>ACME DNS01 validation record propagated for "_acme-challenge.securego.dazwilkin.com."<br/>Accepting challenge for domain "securego.dazwilkin.com"<br/>Calling AcceptChallenge<br/>Waiting for authorization for domain "securego.dazwilkin.com"<br/>Calling WaitAuthorization<br/>Successfully authorized domain "securego.dazwilkin.com"<br/>Cleaning up challenge for domain "securego.dazwilkin.com" as part of Certificate default/securego-dazwilkin-com<br/>Issuing certificate...<br/>getting private key (letsencrypt-staging-&gt;tls.key) for acme issuer cert-manager/letsencrypt-staging<br/>Calling GetOrder<br/>Calling FinalizeOrder<br/>successfully obtained certificate: cn="securego.dazwilkin.com" altNames=[securego.dazwilkin.com] url="<a class="ae jh" href="https://acme-staging-v02.api.letsencrypt.org/acme/order/6100788/1013320" rel="noopener ugc nofollow" target="_blank">https://acme-staging-v02.api.letsencrypt.org/acme/order/6100788/1013320</a>"<br/>Certificate issued successfully<br/>Found status change for Certificate "securego-dazwilkin-com" condition "Ready": "False" -&gt; "True"; setting lastTransitionTime to 2018-05-16 21:56:56.842909838 +0000 UTC m=+7058.901958015<br/>Certificate default/securego-dazwilkin-com scheduled for renewal in 1438 hours<br/>certificates controller: Finished processing work item "default/securego-dazwilkin-com"<br/>certificates controller: syncing item 'default/securego-dazwilkin-com'<br/>Certificate default/securego-dazwilkin-com scheduled for renewal in 1438 hours<br/>certificates controller: Finished processing work item "default/securego-dazwilkin-com"</span></pre><h2 id="1e5b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">结论</h2><p id="b63e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">cert-manager警告说，这种功能还不能用于生产部署，但是将Kubernetes与自动生成和管理证书的机制结合起来是非常好的！您没有理由不对所有工作负载使用合法的(非临时加密或您的首选CA)证书。</p><p id="e2b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总是寻求反馈</p><p id="6a99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p><h2 id="c25c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">18–05–17更新:</h2><h2 id="cfe9" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">带有非TLS后端的HTTPS负载平衡器</h2><p id="8440" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">在这个变体中，我们从Kubernetes部署中删除了TLS，并将由Let's Encrypt生成的证书应用到Google Cloud HTTPS负载平衡器。</p><p id="3f12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面包括了更简单的<code class="du jd je jf jg b">main.go</code>和一个Dockerfile文件，假设你已经构建了它的二进制文件。我已经将图像作为<code class="du jd je jf jg b">dazwilkin/nontlsgo</code>推送到DockerHub。所以你可以直接引用它。</p><p id="e446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将部署<code class="du jd je jf jg b">nontlsgo.deployment.yaml</code>应用到您的集群。假设您保留了前面步骤中的cert-manager部署，您可以重用颁发者，但是您必须应用这里提供的新的<code class="du jd je jf jg b">certmanager.certificate.yaml</code>。此证书申请是针对<code class="du jd je jf jg b">nontlsgo</code>的。这是我们将在入口中用于供应HTTPS负载平衡器的证书。一旦您能够确认证书已创建，应用<code class="du jd je jf jg b">ingress.yaml</code>来提供GCLB。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="4906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我能够将cert-manager提供的Let's Encrypt challenge捕获到云DNS中，以便Let's Encrypt服务能够确认我对<code class="du jd je jf jg b">dazwilkin.com</code>的所有权:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mi"><img src="../Images/344e17b1a7f6e5e090ace108a0e82e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQo2bYKnVG0Ri9GipeOAEQ.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">云DNS展示让我们加密的极致挑战</figcaption></figure><p id="26e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是成功提供证书的日志输出:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mj"><img src="../Images/9a9b34a6cb7f99237a8b2da08d5b06b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kep7E6Ns4fLslZTYMF8DMw.png"/></div></div></figure><p id="81be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能够查询证书:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="c937" class="kb kc hi jg b fi lt lu l lv lw">kubectl get certificate/nontlsgo</span><span id="0927" class="kb kc hi jg b fi lx lu l lv lw">NAME       AGE<br/>nontlsgo   7m</span></pre><p id="5901" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要将我们的部署公开为<code class="du jd je jf jg b">— type=NodePort</code>的服务:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="1454" class="kb kc hi jg b fi lt lu l lv lw">kubectl expose deployment/nontlsgo \<br/>--port=8080 \<br/>--target-port=8080 \<br/>--type=NodePort</span></pre><p id="3b40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，我们将在Kubernetes引擎中提供一个入口，该入口将提供一个谷歌云HTTPS负载平衡器。</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="1c08" class="kb kc hi jg b fi lt lu l lv lw">kubectl apply --filename=ingress.yaml</span></pre><p id="0125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是云控制台服务栏的视图，因为入口正在配置谷歌云HTTPS负载平衡器(GCLB):</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ma"><img src="../Images/4c147fbb6ef9631386bfd5cfba174e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SLtYuFYS4ydbmRmBeSnVw.png"/></div></div></figure><p id="7a8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以通过控制台的负载平衡器栏看到这一点:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ma"><img src="../Images/01e9b029ae35b206be2ed3838e750793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjTX61tlBv2R-SzAjiihGQ.png"/></div></div></figure><p id="0780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>HTTP(在端口<code class="du jd je jf jg b">80</code>上)和HTTPS(在端口<code class="du jd je jf jg b">443</code>上)都在VIP <code class="du jd je jf jg b">35.190.27.1</code>上启用。对于HTTPS，Kubernetes也提供了<code class="du jd je jf jg b">nontlsgo</code>秘密作为LB的证书。</p><p id="3909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调配好GCLB后，我们应该能够到达终点:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="9ce8" class="kb kc hi jg b fi lt lu l lv lw">curl --insecure <a class="ae jh" href="https://35.190.27.1" rel="noopener ugc nofollow" target="_blank">https://35.190.27.1</a><br/>Hello Henry!</span></pre><p id="4731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和以前一样，我们可以检查它提供的证书:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="e6af" class="kb kc hi jg b fi lt lu l lv lw">openssl s_client \<br/>-servername nontlsgo.[[YOUR-DOMAIN]] \<br/>-connect 35.190.27.1:443 \<br/>| less</span></pre><p id="cd05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和以前一样:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="6c12" class="kb kc hi jg b fi lt lu l lv lw">CONNECTED(00000003)<br/>---<br/>Certificate chain<br/> 0 s:/CN=nontlsgo.[[YOUR-DOMAIN]]<br/>   i:/CN=Fake LE Intermediate X1<br/> 1 s:/CN=Fake LE Intermediate X1<br/>   i:/CN=Fake LE Root X1<br/>---<br/>Server certificate<br/>-----BEGIN CERTIFICATE-----<br/>...<br/>-----END CERTIFICATE-----<br/>subject=/CN=nontlsgo.[[YOUR-DOMAIN]]<br/>issuer=/CN=Fake LE Intermediate X1</span></pre><p id="155d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们的后端服务不受TLS的保护，但我们使用需要TLS的GCLB作为前端服务。</p><h2 id="f403" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">带有TLS后端的HTTPS负载平衡器</h2><p id="634f" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">啊哈！在GCLB运行HTTPS的情况下，有一些Alpha工作来实现对TLS后端的支持，让我们来探索一下:</p><p id="bb64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jh" href="https://github.com/kubernetes/ingress-gce/blob/master/README.md#backend-https" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/ingress-GCE/blob/master/readme . MD # back end-https</a></p><p id="bc93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有用！</p><p id="3e52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很抱歉，我的命名会使这看起来更加混乱，但我们要做的是重用上面的入口配置(使用<code class="du jd je jf jg b">nontlsgo</code>证书)，这次我们将使用securego服务(使用<code class="du jd je jf jg b">securego</code>证书)作为后端。因此，GCLB终止外部TLS连接(使用证书<code class="du jd je jf jg b">nontlsgo</code>),然后GCLB使用证书<code class="du jd je jf jg b">securego</code>重新加密流量(作为客户端)以路由到TLS(！)为基础的<code class="du jd je jf jg b">securego</code>服务。</p><p id="e8d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重用之前的所有内容，并使用下面的<code class="du jd je jf jg b">service.yaml</code>和<code class="du jd je jf jg b">ingress.yaml</code>:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ly lz l"/></div></figure><blockquote class="ju jv jw"><p id="e5b4" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>我从服务容器的<code class="du jd je jf jg b">8443</code> → <code class="du jd je jf jg b">443</code>重新映射服务中的端口。这是因为阿尔法入口引用端口<code class="du jd je jf jg b">443</code>，我不想改变太多，打破了一些东西。我也试试用<code class="du jd je jf jg b">8443</code>。</p><p id="617e" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>入口包含Alpha注释，支持后端服务使用TLS:<code class="du jd je jf jg b">service.alpha.kubernetes.io/app-protocols</code>。该值采用我们命名为<code class="du jd je jf jg b">https-port</code>的端口，并指定<code class="du jd je jf jg b">HTTPS</code>。</p></blockquote><p id="1d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是入口产生的GCLB:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mk"><img src="../Images/5778a3dd852f468ae4201d4cee6b7b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--B-wjp0bnXZQAaNXpaS8Q.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">一路安全！</figcaption></figure><p id="47bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如所料:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="a4b4" class="kb kc hi jg b fi lt lu l lv lw">curl --insecure <a class="ae jh" href="https://35.186.202.30" rel="noopener ugc nofollow" target="_blank">https://35.186.202.30</a><br/>Hello Henry!</span></pre><p id="68c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如所料，我们得到了<code class="du jd je jf jg b">nontlsgo</code>证书，因为我们与HTTPS负载平衡器进行了交互。如果我们能看到绿色窗帘后面，我们会看到负载平衡器本身在与Kubernetes后端服务对话时接收到了<code class="du jd je jf jg b">securego</code>证书。</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="44cf" class="kb kc hi jg b fi lt lu l lv lw">openssl s_client \<br/>-servername nontlsgo.dazwilkin.com \<br/>-connect 35.186.202.30:443 \<br/>| less</span></pre><p id="7236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="f5c1" class="kb kc hi jg b fi lt lu l lv lw">CONNECTED(00000003)<br/>---<br/>Certificate chain<br/> 0 s:/CN=nontlsgo.[[YOUR-DOMAIN]]<br/>   i:/CN=Fake LE Intermediate X1<br/> 1 s:/CN=Fake LE Intermediate X1<br/>   i:/CN=Fake LE Root X1<br/>---<br/>Server certificate<br/>-----BEGIN CERTIFICATE-----<br/>...<br/>-----END CERTIFICATE-----<br/>subject=/CN=nontlsgo.[[YOUR-DOMAIN]]<br/>issuer=/CN=Fake LE Intermediate X1<br/>---</span></pre><h2 id="9a4c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">生产</h2><p id="8413" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">为了完整起见，让我们去掉对<code class="du jd je jf jg b">curl — insecure</code>的需求。</p><p id="0c6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是脚本:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="ea89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">NB</strong>secure go服务正在端口<code class="du jd je jf jg b">8443</code>上运行。这证明了像之前质疑的那样做(而不使用<code class="du jd je jf jg b">443</code>)是可能的。</p><p id="7d6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>入口重用|假设基于TLS的服务存在(端口<code class="du jd je jf jg b">8443</code>上的<code class="du jd je jf jg b">securego</code></p><p id="5155" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦端点可用，您将需要更新DNS记录集以反映它，然后:</p><pre class="jj jk jl jm fd lp jg lq lr aw ls bi"><span id="16e4" class="kb kc hi jg b fi lt lu l lv lw">curl <a class="ae jh" href="https://tlsprdgo.dazwilkin.com" rel="noopener ugc nofollow" target="_blank">https://tlsprdgo.[</a>[YOUR-DOMAIN]]<br/>Hello Henry!</span></pre><p id="dc94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p></div></div>    
</body>
</html>