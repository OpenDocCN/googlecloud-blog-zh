<html>
<head>
<title>Building and using an inventory of your Google Cloud Storage objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建和使用谷歌云存储对象的清单</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/building-and-using-an-inventory-of-your-google-cloud-storage-objects-in-bigquery-1afae4333351?source=collection_archive---------0-----------------------#2020-01-08">https://medium.com/google-cloud/building-and-using-an-inventory-of-your-google-cloud-storage-objects-in-bigquery-1afae4333351?source=collection_archive---------0-----------------------#2020-01-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="0262" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">放弃</h1><p id="d093" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我是一名谷歌人，具体在谷歌云工作。这里陈述的所有观点都是我自己的，而不是谷歌公司的。</p><h1 id="2e89" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="494f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">听到这个可能会让您感到惊讶，但是许多对象存储客户并不真正知道他们的存储桶中有什么数据。就像您在搜索桌面文件系统的偏远角落时一样，当他们开始寻找时，他们会发现令他们惊讶的东西。在对象存储的情况下，这在最好的情况下会导致存储费用的浪费，在最坏的情况下会导致敏感数据的泄露。很多时候，客户知道他们有这个问题，但他们对自己的数据了解不够，甚至没有开始清理。</p><p id="8a56" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果这听起来像是你可能遇到的问题，那么有一个好消息。通过建立一个可以用BigQuery这样强大的数据库查询的对象清单，你可以很容易地<a class="ae kg" href="https://www.youtube.com/watch?v=c71nqMqmiaw" rel="noopener ugc nofollow" target="_blank">知道</a>你得到了什么，并做出明智的决定。<em class="kh">你不需要写任何代码就可以开始。</em></p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="6a95" class="if ig hi bd ih ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc bi translated">如何做到这一点</h1><h2 id="f24b" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">拥有谷歌云平台账号和存储对象</h2><p id="dda1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">大多数想走这条路的人已经有了一个GCP账户，但是如果这是云平台评估的一部分，或者你正在考虑使用BigQuery来清点另一个对象存储产品，那么<a class="ae kg" href="https://cloud.google.com/start/" rel="noopener ugc nofollow" target="_blank">很容易就能从GCP </a>开始。至于你可能期望的费用，<a class="ae kg" href="https://cloud.google.com/storage/pricing" rel="noopener ugc nofollow" target="_blank">存储有持续的月费用</a>取决于你存储了多少。它也有运营费用，但在这种情况下，这些费用可以忽略不计。BigQuery 也有持续的每月存储成本，并且查询是按使用付费的。</p><p id="63d3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于大多数用户来说，与对象存储成本相比，BigQuery的存储和查询成本相对较低。如果您只是尝试一下，那么只需要几个对象——只需在UI中上传几张照片。</p><h2 id="6a2b" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">用我为此编写的工具克隆repo并运行它</h2><figure class="li lj lk ll fd lm"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">我的戏剧化，希望能节省你的时间和精力。</figcaption></figure><p id="f6de" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了节省您大量的时间和精力，<strong class="jf hj">我继续编写了</strong> <a class="ae kg" href="https://github.com/domZippilli/gcs-inventory-loader" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">命令行实用程序，它列出对象并将它们流式传输到BigQuery </strong> </a>。在一个相当大的(~32 vCPU)虚拟机上，它应该每150秒运行大约1，000，000个对象。我建议从GCE虚拟机中这样做，以获得最佳吞吐量并避免任何出口费用，但它也可以在家中或内部工作。</p><p id="c2df" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该实用程序是为<strong class="jf hj"> Python 3.6 </strong>编写的。操作原理非常简单。一次最多列出两个存储桶，并且存储桶列表的每一页(大约1，000个对象)都被分派到池中的一个单独的线程。这使得该实用程序可以非常快速地获取大量对象信息，然后将其传输给BigQuery。</p><p id="9f0e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">默认情况下，该实用程序将收集指定项目中所有存储桶的清单。如果您的项目中有一个<em class="kh"> lot </em>对象，您可以提供特定的存储桶，以便按存储桶“分割”列表工作。您还可以使用这个特性来列出多个项目的存储桶。</p><p id="1cd3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您需要分割一个非常大的桶的列表，您还可以提供一个前缀来过滤列表。</p><p id="f27b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">按照<strong class="jf hj"> README.md </strong>中的步骤安装和配置该工具，对于大多数用户来说，不需要任何选项就可以运行它:</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="8e5c" class="ku ig hi lu b fi ly lz l ma mb">gcs_inventory load</span></pre><p id="25fd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您应该得到输出，通知您对象计数的进度。因为它事先不知道你有多少个对象，所以它不会给出进度指示器，尽管你可以通过检查<code class="du mc md me lu b">storage/object_count</code> <a class="ae kg" href="https://cloud.google.com/monitoring/api/metrics_gcp#gcp-storage" rel="noopener ugc nofollow" target="_blank"> Stackdriver度量</a>来了解你有多少个对象。</p><h2 id="f089" class="ku ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">最后，打开BigQuery，尽情享受吧</h2><figure class="li lj lk ll fd lm"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">Arvind，是时候用SQL从我们的数据中收集见解了！</figcaption></figure><p id="4d58" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦实用程序运行完毕，您就可以开始查询数据了(从技术上讲，您可以在它运行完毕之前进行查询，但是数据将是不完整的)。这里有一些BigQuery SQL将帮助您找到关于GCS对象的有趣内容。至少对我来说，发现有趣的东西总是很有趣。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="7b04" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">我最大的10个对象是什么，以GB为单位？</strong>该查询将向您展示。</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="9273" class="ku ig hi lu b fi ly lz l ma mb">SELECT<br/>  name,<br/>  ROUND(size / 1000 / 1000 / 1000, 1) as sizeGB,<br/>  storageClass<br/>FROM `project.dataset.table`<br/>ORDER BY size DESC<br/>LIMIT 10</span></pre><p id="6f67" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从这里，我可以看到我的开发项目中有一堆2GB的文件:</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="d9d6" class="ku ig hi lu b fi ly lz l ma mb">name       sizeGB storageClass<br/>&lt;redacted&gt; 2.2    NEARLINE<br/>&lt;redacted&gt; 2.2    NEARLINE<br/>&lt;redacted&gt; 2.1    NEARLINE<br/>&lt;redacted&gt; 2.1    NEARLINE<br/>&lt;redacted&gt; 2.1    NEARLINE<br/>[...]</span></pre><p id="5b8e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">也许这些物品不再有用了？它们占了很大空间，现在我知道了，所以我可以调查一下。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="6975" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">我有重复的对象吗？</strong>使用每个对象的MD5或CRC32C校验和来检测重复数据。在这个例子中，我将使用CRC32C，因为所有对象都有它(组合对象没有MD5)。</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="1ad1" class="ku ig hi lu b fi ly lz l ma mb">SELECT<br/>  crc32c,<br/>  size,<br/>  COUNT(crc32c) AS copies<br/>FROM `project.dataset.table`<br/>GROUP BY crc32c, size<br/>ORDER BY copies DESC</span></pre><p id="893c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由此，我可以看到我有一堆具有相同大小和校验和的对象——这些几乎肯定是重复的。</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="c1b3" class="ku ig hi lu b fi ly lz l ma mb">crc32c   size     copies<br/>IlUZiA== 51130562 12<br/>j0uDyA== 51130562 12<br/>OVgmZA== 51130562 12<br/>i2S8Ww== 1073741792 12<br/>i2pspw== 51130562 12<br/>RnLi+Q== 51130562 10<br/>[...]</span></pre><p id="f4ee" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我将使用这个查询和我的库存执行一个内部连接，以生成一个重复对象的“命中列表”:</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="18ca" class="ku ig hi lu b fi ly lz l ma mb">SELECT<br/>  object.name,<br/>  object.crc32c,<br/>  object.size<br/>FROM<br/>  `project.dataset.table` AS object<br/>INNER JOIN (<br/>  SELECT<br/>    crc32c,<br/>    COUNT(crc32c) AS copies<br/>  FROM<br/>    `project.dataset.table`<br/>  GROUP BY crc32c<br/>  ORDER BY copies DESC<br/>) AS checksums<br/>ON<br/>  object.crc32c = checksums.crc32c AND checksums.copies &gt; 1<br/>ORDER BY object.size DESC</span></pre><p id="b82b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，我有了一组可以进一步研究并考虑进行重复数据消除的对象:</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="83c5" class="ku ig hi lu b fi ly lz l ma mb">name       crc32c   size<br/>&lt;redacted&gt; z/SBzA== 2150214565<br/>&lt;redacted&gt; z/SBzA== 2150214565<br/>&lt;redacted&gt; L4Z8vg== 2148600803<br/>&lt;redacted&gt; L4Z8vg== 2148600803<br/>&lt;redacted&gt; pb4tWw== 2147908484<br/>&lt;redacted&gt; pb4tWw== 2147908484<br/>&lt;redacted&gt; Mi8Jnw== 2145435876<br/>&lt;redacted&gt; Mi8Jnw== 2145435876<br/>&lt;redacted&gt; rs+BzQ== 2142987458<br/>&lt;redacted&gt; rs+BzQ== 2142987458<br/>[...]</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="5902" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">我的数据是否在不该在的地方？</strong>我可以使用对象元数据来查找可能不应该在公共访问桶中的文件:</p><pre class="li lj lk ll fd lt lu lv lw aw lx bi"><span id="d7eb" class="ku ig hi lu b fi ly lz l ma mb">SELECT <br/>  name, <br/>  bucket <br/>FROM `project.dataset.table` <br/>WHERE SUBSTR(name, LENGTH(name) - 2) IN (".db") OR<br/>      SUBSTR(name, LENGTH(name) - 3) IN (".csv", ".txt") OR<br/>      SUBSTR(name, LENGTH(name) - 4) IN (".json") AND<br/>      bucket = "very-public-bucket"</span></pre><p id="6469" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一个恶意的演员可以很容易地回避这一点，但这样的定期检查可以捕捉诚实的错误…许多大问题都是从这些开始的。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="af28" class="if ig hi bd ih ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc bi translated">下一步是什么</h1><p id="8dcd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">请继续关注更多的文章，这些文章描述了您可以利用这些信息和类似的数据源来更好地管理GCS中的数据。</p><p id="ad8e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">此外，元数据加载器的一些改进也即将出现。第一个是包括ACL和IAM绑定，但是我仍然处于“可行性”阶段。</p><h1 id="8b17" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">已知问题</h1><p id="f012" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个已知的问题是，如果您正在开发而不仅仅是使用这个实用程序，您更有可能遇到这个问题，即<a class="ae kg" href="https://github.com/googleapis/java-bigquery/issues/15#issuecomment-569300832" rel="noopener ugc nofollow" target="_blank">如果您删除并重新创建一个表，并且在那之后不久就开始向其中传输数据，一些记录可能不会进入新表</a>。我不确定一个被删除的表会有多长时间的影响，但是每次运行这个函数时，您可能希望将新的清单加载到一个新的表中。</p><h1 id="997a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">警告</h1><ol class=""><li id="713c" class="mf mg hi jf b jg jh jk jl jo mh js mi jw mj ka mk ml mm mn bi translated">许可证文件中已经说明了这一点，但是<code class="du mc md me lu b">gcs-inventory-loader</code> repo中的所有代码都是按原样提供的，没有任何保证。<strong class="jf hj">谷歌</strong>不支持该实用程序。在运行代码之前，请确保您彻底理解了代码，这样您就知道它不会给您带来问题。</li><li id="231d" class="mf mg hi jf b jg mo jk mp jo mq js mr jw ms ka mk ml mm mn bi translated">这样创建的库存<strong class="jf hj">不是快照</strong>。差别很微妙，但很重要。“快照”指的是在特定时间点一致的GCS元数据清单。列表API不是这样工作的；每个页面都是实时元数据的一部分，因此当您浏览页面时，其余的元数据可能会发生变化。对象可能会被您遗漏或删除，并显示在您的清单中。产生一致的快照在技术上是可能的，但是方法是完全不同的，并且现在需要大量的基础工作。那是改天的话题。</li></ol><figure class="li lj lk ll fd lm er es paragraph-image"><div class="er es mt"><img src="../Images/ca09775d510cfc354bae19406b5eb6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/0*s5dfh_kRKLezVzBg.jpg"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">在谷歌数据中心里。我想我看到你的东西了！</figcaption></figure></div></div>    
</body>
</html>