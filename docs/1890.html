<html>
<head>
<title>Using Cloud Pub/Sub on Node.js from Kotlin/JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kotlin/JS的Node.js上使用云发布/订阅</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/using-cloud-pub-sub-on-node-js-from-kotlin-js-46ad79739bbf?source=collection_archive---------1-----------------------#2021-06-01">https://medium.com/google-cloud/using-cloud-pub-sub-on-node-js-from-kotlin-js-46ad79739bbf?source=collection_archive---------1-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/80c4643c2991c3e1bd318f868d2f283c.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/0*iGV7ScBFk4K5_G8Q"/></div></figure><figure class="in io ip iq fd ij er es paragraph-image"><div class="er es im"><img src="../Images/ebde679592cd816cd3e5be7c92a7725f.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*4M0nuzReVcFZCBa4"/></div></figure><figure class="in io ip iq fd ij er es paragraph-image"><div class="er es ir"><img src="../Images/38c651629433c63ebff9e2f8568299b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*ARUQelkPpC1LwNFN"/></div></figure><h1 id="88d1" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">为什么是Kotlin/JS？</h1><p id="9f1f" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">Kotlin通常用于前端JVM工作，但是正如前面关于Kotlin和JVM的文章所示，Kotlin在服务器端也可以很好地工作。为了在web应用程序中维护完整的Kotlin堆栈，开发了<a class="ae ko" href="https://kotlinlang.org/docs/reference/js-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin/JS </a>。</p><p id="6dda" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">Kotlin/JS基本上是一个标准的Kotlin编译器，但它不是写入JVM字节码，而是将files *转换成JavaScript。在这种情况下，它的作用与TypeScript差不多，为一些常见的操作提供类型安全和语法糖。像TypeScript一样，它也为JavaScript库提供了外部类型的概念。使用Dukat实用程序，还可以将TypeScript类型转换为Kotlin类型，这使得在Kotlin/JS应用程序中获得完全的类型安全变得非常容易。</p><blockquote class="ku kv kw"><p id="130d" class="jq jr kx js b jt kp jv jw jx kq jz ka ky kr kd ke kz ks kh ki la kt kl km kn hb bi translated">* Transpilation类似于编译，但从一种人类可读语言转换为另一种语言，而不是二进制代码。</p></blockquote><p id="4ded" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">Kotlin位于客户端和服务器端，通常分别使用React和JVM，可以直接共享一些代码，比如通用业务逻辑和数据类。开发垂直应用程序堆栈的团队也可以利用Kotlin中现有的能力。</p><h1 id="6a54" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Kotlin/JS …在Node上？</h1><p id="b5e9" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">是的，是真的！因为Kotlin/JS只是一个transpiler，所以也可以使用Node.js运行时来运行结果代码。这使您能够使用npm/yarn中所有现有的节点兼容库<strong class="js hj">构建非常轻量级的服务器进程，同时在Kotlin中运行整个应用程序</strong>。</p><h1 id="7a94" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">警告</h1><p id="12ea" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">本文将带您构建一个运行在Node.js中的Kotlin/JS应用程序，并使用Node.js发布/订阅库与<a class="ae ko" href="https://cloud.google.com/pubsub" rel="noopener ugc nofollow" target="_blank"> Google Cloud发布/订阅</a>通信。请注意<strong class="js hj">我们不建议此时为您的生产工作执行此操作</strong>；这篇文章主要是为了好奇！</p><h1 id="5b7b" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">项目设置</h1><p id="2759" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">首先安装一个最新版本的<a class="ae ko" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>。您也可以使用<a class="ae ko" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank"> nvm </a>安装它，但是您需要在下面的项目设置中设置npm的路径。</p><p id="8b2d" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">打开<a class="ae ko" href="https://www.jetbrains.com/idea/" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA </a>或<a class="ae ko" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> Android Studio </a>并创建一个针对Node.js的Kotlin/JS项目。截至目前，新的<strong class="js hj"> IR </strong>编译器仍处于试验阶段，因此我建议使用<strong class="js hj">传统的</strong>以保持简单。(当你读到这里时，情况可能并非如此。)</p><figure class="in io ip iq fd ij er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/b7ca969a85bfa2b9cd55629d18c7e70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lDPM1hYFH8zzTfVh"/></div></div></figure><figure class="in io ip iq fd ij er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/71a59dc72b62023fab5001378f282a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yrc917IvdWKtxWCS"/></div></div></figure><p id="a589" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">要使用发布/订阅库，我们必须将它们添加到我们的Gradle构建配置中。编辑<strong class="js hj"> build.gradle.kts </strong>文件，并添加以下行:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="5cd7" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">正如评论所建议的，您通常可以启用generateExternals，它会调用Dukat来自动转换<strong class="js hj"> @google-cloud/pubsub </strong>中的任何TypeScript类型。不幸的是，<a class="ae ko" href="https://github.com/Kotlin/dukat/issues/426" rel="noopener ugc nofollow" target="_blank">它目前正在失败</a>，所以我们将做我们自己的非常简单的打字！</p><h1 id="7dfa" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">科特林/JS打字</h1><p id="6f9b" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为了以类型安全的方式调用<a class="ae ko" href="https://github.com/googleapis/nodejs-pubsub" rel="noopener ugc nofollow" target="_blank">发布/订阅库</a>，我们需要添加一些类型。我喜欢创建一个与TypeScript具有相同命名约定的文件，比如<strong class="js hj"> pubsub.d.kt </strong>，但您的喜好可能会有所不同。</p><p id="6e89" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">像这样开始文件<strong class="js hj"> pubsub.d.kt </strong>:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="8ee5" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">这告诉编译器几件事:</p><ul class=""><li id="dede" class="li lj hi js b jt kp jx kq kb lk kf ll kj lm kn ln lo lp lq bi translated">这个文件包含了<strong class="js hj"> @google-cloud/pubsub </strong>图书馆的类型</li><li id="50e6" class="li lj hi js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated">这些类型可以在Kotlin/JS模块设置之外使用</li><li id="1c11" class="li lj hi js b jt lr jx ls kb lt kf lu kj lv kn ln lo lp lq bi translated">描述的项目应该有一个Kotlin名称空间<strong class="js hj"> google.cloud.pubsub </strong></li></ul><p id="e4ba" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">我们的类型将使用JavaScript<strong class="js hj">Promise&lt;&gt;</strong>对象，所以我们还需要导入那些类型:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="1226" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">最后，实际的打字。你可以在这里找到完整的例子，例如，对于PubSub类:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="762f" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">我还喜欢为我们通常会传入的JSON blobs创建一个Kotlin惯用的数据类。这些不能在同一个文件中，你必须为其创建一个单独的非外部文件。</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7b4e" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">在JavaScript中，这将变成一个标准的<strong class="js hj"> { projectId: null，apiEndpoint: null } </strong>对象。</p><h1 id="be98" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">与发布/订阅接口</h1><p id="d259" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们现在可以用或多或少正常的方式调用Node.js发布/订阅库。此示例使用模拟器:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="9761" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">这太好了！<strong class="js hj"> subClient.on() </strong>调用变成了类似“use”的Kotlin运算符。</p><h1 id="618b" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Kotlin/JS和协同程序</h1><p id="1d70" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">让我们来看看另一个可能常见的操作:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="c624" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">可惜这返回的是一个<strong class="js hj">承诺&lt; &gt; </strong>，不是我们想要的值。您可以用普通的JavaScript方式与它交互:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="57da" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">同样，由于Kotlin lambda参数语法，这看起来相当不错。但是我们可以做得更好。</p><p id="1f85" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">在TypeScript中，你可以简单地使用<strong class="js hj">异步</strong>和<strong class="js hj">等待</strong>。Kotlin/JS目前不支持JavaScript原生<strong class="js hj">异步</strong>和<strong class="js hj">等待</strong>。但是，它确实提供了Kotlin协程！而且事实证明<a class="ae ko" href="https://discuss.kotlinlang.org/t/async-await-on-the-client-javascript/2412" rel="noopener ugc nofollow" target="_blank">把两个</a>联系起来也不是太难。这个讨论是不久前的事了，协程已经从实验阶段出来了，所以还需要一点工作来更新它。</p><p id="585e" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">首先，我们需要一个JavaScript<strong class="js hj">Promise&lt;&gt;</strong>和Kotlin协程之间的适配器。这个扩展函数将让您调用<strong class="js hj">。await() </strong> on任一<strong class="js hj">承诺&lt; &gt; </strong>，调用变为<strong class="js hj">暂停</strong>函数调用:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7c2b" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">由于Kotlin/JS没有在JVM上运行，我们不能使用JVM本地操作，比如<a class="ae ko" href="https://kotlinlang.org/docs/coroutines-basics.html#bridging-blocking-and-non-blocking-worlds" rel="noopener ugc nofollow" target="_blank"> runBlocking </a>。因此，这实现了从非<strong class="js hj">挂起</strong>代码到<strong class="js hj">挂起</strong>函数的桥梁，有点像在JavaScript中调用<strong class="js hj">异步</strong>函数，而没有<strong class="js hj">等待</strong>:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="477f" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">现在我们可以做这样的事情:</p><figure class="in io ip iq fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="9046" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">嘿，实际上，看起来不错！我们又回到了TypeScript <strong class="js hj"> async </strong>和<strong class="js hj"> await </strong>的易用性，但我们也在编写Kotlin。这将优雅地转换成一个无需JVM就可以在Node.js上运行的应用程序。</p><h1 id="a925" class="is it hi bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">后续步骤</h1><p id="e6c3" class="pw-post-body-paragraph jq jr hi js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">查看在发布/订阅仿真器上运行的<a class="ae ko" href="https://github.com/feywind/kotlinjs-pubsub" rel="noopener ugc nofollow" target="_blank">完整工作示例。</a></p><p id="3cc3" class="pw-post-body-paragraph jq jr hi js b jt kp jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kt kl km kn hb bi translated">用Node.js在服务器端用过Kotlin/JS吗？你觉得这很有趣并希望听到更多吗？请随意对这篇文章发表评论，或者对你在Google云平台上发现的关于Kotlin和Kotlin/JS的有趣/有前途的事情发表评论！</p></div></div>    
</body>
</html>