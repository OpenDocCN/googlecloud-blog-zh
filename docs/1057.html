<html>
<head>
<title>Stackdriver Resiliency and Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈驱动弹性和代理</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/stackdriver-resiliency-and-proxies-132602747801?source=collection_archive---------0-----------------------#2019-07-02">https://medium.com/google-cloud/stackdriver-resiliency-and-proxies-132602747801?source=collection_archive---------0-----------------------#2019-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="a05b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="d4a1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有时候你不能直接连接到GCP API，而是需要使用代理。这可能有多种原因。</p><blockquote class="kb kc kd"><p id="9d8c" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated">您如何知道您的应用程序——在这种情况下是登录到stack driver——对您的代理有弹性？你如何测试它？</p></blockquote><p id="20de" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这篇博客将带您一步一步地使用nginx代理设置一个简单的测试，证明您正在使用代理，并展示Stackdriver Python客户端库对代理(和网络)的弹性。</p><h1 id="f966" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">要求</h1><ul class=""><li id="6051" class="kn ko hi jf b jg jh jk jl jo kp js kq jw kr ka ks kt ku kv bi translated">你用的是Linux</li><li id="585b" class="kn ko hi jf b jg kw jk kx jo ky js kz jw la ka ks kt ku kv bi translated">您已经安装了nginx</li><li id="e797" class="kn ko hi jf b jg kw jk kx jo ky js kz jw la ka ks kt ku kv bi translated">您机器的端口443 (https)上没有运行任何东西</li><li id="b1ba" class="kn ko hi jf b jg kw jk kx jo ky js kz jw la ka ks kt ku kv bi translated">您可以访问/etc/hosts和nginx配置</li><li id="8a63" class="kn ko hi jf b jg kw jk kx jo ky js kz jw la ka ks kt ku kv bi translated">你已经认证了gcloud，一个项目，并且可以访问Stackdriver</li></ul><h1 id="534e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设置代理</h1><h2 id="649f" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">编辑nginx配置</h2><p id="2c7d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">添加下面的配置/etc/nginx/nginx.conf。这将在端口443上获取到nginx(在本地机器上)的所有传入连接，并创建到googleapis.l.google.com端口443的转发连接(原始TCP/IP)。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="fe19" class="lb ig hi lu b fi ly lz l ma mb">stream {<br/>  server {<br/>    listen 443;<br/>    proxy_pass <a class="ae mc" href="http://googleapis.l.google.com:443/" rel="noopener ugc nofollow" target="_blank">googleapis.l.google.com:443</a>;<br/>  }<br/>}</span></pre><p id="1c5f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">请注意，由于它是一个原始转发连接，因此不会干扰SSL端到端连接。这只是转发数据，而不是解密和重新加密数据。</p><h2 id="279d" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">重启nginx</h2><p id="b111" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="ke">这里假设你使用的是systemd(现代Linux)。</em></p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="0e43" class="lb ig hi lu b fi ly lz l ma mb">service nginx restart</span></pre><h2 id="d676" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">配置DNS</h2><p id="e967" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">编辑/etc/hosts允许您只为本地机器重新配置DNS。这仅用于测试目的。添加下面的映射。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="3b7e" class="lb ig hi lu b fi ly lz l ma mb">; temporary<br/>127.0.0.1       logging.googleapis.com</span></pre><p id="8e74" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这将导致所有到logging.googleapis.com和logging.googleapis.com的连接被路由到127.0.0.1。</p><p id="674d" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">测试这一点最简单(也是最古老)的方法是使用telnet，如果您安装了它的话:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="a568" class="lb ig hi lu b fi ly lz l ma mb">telnet logging.googleapis.com 443</span></pre><p id="85fc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">您应该会在顶部看到“正在尝试127.0.0.1 ”,并且应该会建立连接。这个连接通过nginx代理重定向到本地主机，并连接到googleapis.l.google.com端口443。</p><h2 id="e19f" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">为什么会这样？</h2><p id="cdaa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这有点棘手。首先，您应该使用host来查看logging.googleapis.com的真实DNS:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="a1db" class="lb ig hi lu b fi ly lz l ma mb">host logging.googleapis.com</span></pre><p id="fdee" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">截至发稿时，结果如下:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="393f" class="lb ig hi lu b fi ly lz l ma mb">logging.googleapis.com is an alias for googleapis.l.google.com.<br/>googleapis.l.google.com has address 74.125.140.95<br/>googleapis.l.google.com has address 173.194.76.95<br/>googleapis.l.google.com has address 64.233.167.95<br/>googleapis.l.google.com has IPv6 address 2a00:1450:400c:c00::5f</span></pre><p id="a232" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">所以logging.googleapis.com是googleapis.l.google.com的别名。这样我们就可以把东西直接传给googleapis.l.google.com。</p><p id="f407" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">客户端<strong class="jf hj">认为</strong>正在连接到logging.googleapis.com。它实际上是到本地主机，然后通过代理传输到Google APIs . l . Google。SSL加密像正常一样进行，证书被验证，代理没有办法解密通过的数据。</p><h1 id="232b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">测试it —基础</h1><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="2ceb" class="lb ig hi lu b fi ly lz l ma mb">TOKEN=$(gcloud auth print-access-token)<br/>DATE=$(date)<br/>PROJECT=$(gcloud config get-value project)<br/>DATA="<br/>{<br/>  'entries': [<br/>    {<br/>      'logName': 'projects/${PROJECT}/logs/curl',<br/>      'resource': {<br/>         'type': 'global',<br/>         'labels': { 'project_id': '${PROJECT}' } },<br/>      'textPayload': 'API Write at ${DATE}'<br/>    }<br/>  ],<br/>}<br/>"</span><span id="7744" class="lb ig hi lu b fi md lz l ma mb">curl -v -X "POST" \<br/>        -H "Content-Type: application/json" \<br/>        --data "${DATA}" \<br/>        -H "Authorization: Bearer ${TOKEN}" \<br/>        -H "Content-Type: application/http" \<br/>           "<a class="ae mc" href="https://logging.googleapis.com/v2/entries:write" rel="noopener ugc nofollow" target="_blank">https://logging.googleapis.com/v2/entries:write</a>"</span></pre><p id="3e2b" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这将从gcloud、当前默认项目、当前日期获取您当前的不记名令牌，创建一个JSON消息，然后使用<a class="ae mc" href="https://cloud.google.com/logging/docs/reference/v2/rest/v2/entries/write" rel="noopener ugc nofollow" target="_blank"> write方法</a>写入日志消息。</p><h2 id="8ae1" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">堆栈驱动程序日志消息</h2><p id="7da0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然后您可以进入Stackdriver控制台，应该会看到消息出现在默认项目的“Global”过滤器中。可能需要几分钟才能显示出来。</p><figure class="lp lq lr ls fd mf er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es me"><img src="../Images/883383eca8d957be4a05e8cbe1652c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgVGcFWR944R-SxZufVbMA.png"/></div></div></figure><p id="1c93" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">注意receiveTimestamp和textPayload中的时间戳。这是Stackdriver(从REST API)收到消息和生成日志消息之间的延迟。这里是相同的时间(在一秒钟之内)。</p><h1 id="1cae" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">测试it —高级</h1><p id="9600" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们从一个小的Python脚本开始——使用google-cloud-logging pip包——写入Stackdriver。这要求您使用gcloud进行身份验证，或者运行在具有写入Stackdriver日志记录范围的GCE实例上。</p><p id="aa4e" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">运行该脚本将每秒生成日志消息，日志消息文本包含日志消息生成的时间。这与Stackdriver可能收到的消息不同。(虽然通常延迟很短！)</p><p id="7b87" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">我用Python 3.6.5和1.11.0运行这个。</p><h2 id="fa39" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">Python脚本:</h2><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="5361" class="lb ig hi lu b fi ly lz l ma mb">import time<br/>import logging<br/>import datetime</span><span id="5cc7" class="lb ig hi lu b fi md lz l ma mb"># Imports the Google Cloud client library<br/>import google.cloud.logging</span><span id="6ec2" class="lb ig hi lu b fi md lz l ma mb"># Instantiates a client<br/>client = google.cloud.logging.Client()</span><span id="9e68" class="lb ig hi lu b fi md lz l ma mb">client.setup_logging()</span><span id="6af9" class="lb ig hi lu b fi md lz l ma mb">logger = logging.getLogger()<br/>logger.setLevel(logging.INFO)</span><span id="5aab" class="lb ig hi lu b fi md lz l ma mb">while True:<br/>    time.sleep(1)<br/>    n = str(datetime.datetime.now())<br/>    <a class="ae mc" href="http://logger.info/" rel="noopener ugc nofollow" target="_blank">logger.info</a>('drip at {}'.format(n))</span></pre><p id="48a6" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">一旦开始运行这个脚本，您就可以返回到Stackdriver日志记录，并看到出现的日志消息。</p><h2 id="c237" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">日志消息—正常工作的代理:</h2><figure class="lp lq lr ls fd mf er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mm"><img src="../Images/cbd961fe7d189f3611368410d8dee8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiaF5sHhRfU47AovimSyMA.png"/></div></div></figure><h2 id="b418" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">中断代理</h2><p id="6404" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">但是现在变得有趣了。让我们停止并启动nginx代理15秒钟，看看会发生什么。</p><p id="3990" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">在一个单独的shell中——让您的python脚本继续运行，密切关注它——运行以下代码:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="e002" class="lb ig hi lu b fi ly lz l ma mb">sudo systemctl stop nginx</span></pre><p id="2a4c" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">然后你可以看到你的程序像平常一样继续运行。(注意，早期版本的google-cloud-logging可能会有不同的表现)大约一分钟后，重新启用nginx代理:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="faf7" class="lb ig hi lu b fi ly lz l ma mb">sudo systemctl start nginx</span></pre><p id="f468" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">现在检查Stackdriver日志消息。</p><h2 id="3619" class="lb ig hi bd ih lc ld le il lf lg lh ip jo li lj it js lk ll ix jw lm ln jb lo bi translated">堆栈驱动程序日志消息</h2><figure class="lp lq lr ls fd mf er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mn"><img src="../Images/06b81312c7871126f5b688aa26796c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMbra7fXMw65r0G-CYDdNQ.png"/></div></div></figure><p id="9e47" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">您可以看到，前几条消息的日志接收时间戳(左栏)与日志消息本身相似。但是，您也可以看到13:01:21和13:02:34之间的间隔，其中所有以下日志消息都具有相同的接收时间戳。日志消息继续其正常的时间增量。</p><h1 id="6eec" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="e118" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，您已经在使用Stackdriver编写日志消息时使用nginx代理进行了测试，并看到它是如何从中断的连接中恢复的。</p><p id="b8f2" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><em class="ke">一定要清理你的/etc/hosts！你不想破坏你的系统。</em></p></div></div>    
</body>
</html>