<html>
<head>
<title>Debugging Maven plugin in IntelliJ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在IntelliJ中调试Maven插件</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/debugging-maven-plugin-in-intellij-7dc7080b9a45?source=collection_archive---------0-----------------------#2020-03-24">https://medium.com/google-cloud/debugging-maven-plugin-in-intellij-7dc7080b9a45?source=collection_archive---------0-----------------------#2020-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0fa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你是否使用Maven来管理你的Java项目，发现了一个非常酷的Maven插件，但是意识到它并不完全适合你的项目？您是Maven新手，想更好地了解它吗？您是否对开源软件开发感兴趣，并且可能考虑为其做出贡献？</p><p id="27f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你并不孤单。三个月前，我开始在Maven工作，在我的谷歌云客户端库<a class="ae jd" href="https://github.com/googleapis/java-bigquerystorage" rel="noopener ugc nofollow" target="_blank">项目</a>中遇到了各种各样的依赖性管理问题，所以我开始探索改进我们管理依赖性的方法。</p><p id="5985" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在谷歌会见了<a class="ae jd" href="https://twitter.com/saturnism" rel="noopener ugc nofollow" target="_blank"> Ray Tsang </a>，讨论了我们一直面临的一些问题和他可能有的建议。经过几次卓有成效的对话，我们决定使用<a class="ae jd" href="https://www.mojohaus.org/flatten-maven-plugin/" rel="noopener ugc nofollow" target="_blank"> Flatten </a>插件来扁平化客户端库项目POM，以消除传递性依赖。这是由Ray <a class="ae jd" href="https://github.com/mojohaus/flatten-maven-plugin/issues/92" rel="noopener ugc nofollow" target="_blank">最近为<a class="ae jd" href="https://www.mojohaus.org/flatten-maven-plugin/" rel="noopener ugc nofollow" target="_blank"> Flatten </a>插件贡献了</a>的新配置<code class="du je jf jg jh b">&lt;flattenDependencyMode&gt;all&lt;/flattenDependencyMode&gt;</code>实现的。</p><p id="c7f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个强大的新特性，它可以帮助我们解决由<code class="du je jf jg jh b">&lt;dependencyManagement&gt;</code>部分管理时传递依赖版本丢失的问题，并允许我们为客户端库消费者提供一个更干净和完全解析的依赖树。</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jn jo l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">从扁平pom构建的依赖关系树</figcaption></figure><p id="bf8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我非常渴望在我的项目<a class="ae jd" href="https://github.com/googleapis/java-bigquerystorage" rel="noopener ugc nofollow" target="_blank"> BigQueryStorage Java客户端</a>中实现它。然而，经过一些测试，我们很快发现了Ray最初贡献的两个问题:1)<a class="ae jd" href="https://github.com/mojohaus/flatten-maven-plugin/issues/131" rel="noopener ugc nofollow" target="_blank">平序颠倒了</a>；以及2) <a class="ae jd" href="https://github.com/mojohaus/flatten-maven-plugin/issues/132" rel="noopener ugc nofollow" target="_blank">一个依赖项(gax-grpc)从展平的POM中缺失。</a></p><p id="6f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章记录了我从增强和贡献Maven插件的过程中学到的东西。</p><h1 id="4946" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">入门指南</h1><p id="05b0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">首先在项目的父POM中按照推荐的配置插件<a class="ae jd" href="https://github.com/saturnism/dependency-conflict-examples/blob/9bfe61ed4572fa91d5e8e449806dfa1b2f00203c/example-5b-depmgmt-flatten/pom.xml#L76" rel="noopener ugc nofollow" target="_blank">，运行<code class="du je jf jg jh b">mvn verify</code>获取项目根目录中的<code class="du je jf jg jh b">.flattened.pom</code>。</a></p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jn jo l"/></div></figure><p id="a580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了开始调试插件，派生并克隆<a class="ae jd" href="https://github.com/mojohaus/flatten-maven-plugin" rel="noopener ugc nofollow" target="_blank"> flatten-maven-plugin </a>的源代码。</p><p id="0c84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本地分叉和克隆项目后，确保首先运行<code class="du je jf jg jh b">mvn verify</code>,看看项目是否可以编译和构建。它应该没有任何错误。然后是时候检查项目的结构，找出代码和测试的位置。</p><h1 id="6e21" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">从高层次理解代码</h1><p id="3e0c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">项目结构看起来非常清晰明了。<code class="du je jf jg jh b">src/it</code>目录包含了所有的集成测试。它被进一步分解为<code class="du je jf jg jh b">mrm</code>和<code class="du je jf jg jh b">project</code>目录，其中<code class="du je jf jg jh b">mrm</code>提供所有的测试依赖关系，而<code class="du je jf jg jh b">project</code>提供所有利用测试依赖关系的集成测试。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es kw"><img src="../Images/31bf9997e780788f897697fe83093681.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*9mLYF6MddxZXAyAEH9Nadg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">项目结构— mrm和项目目录</figcaption></figure><p id="9b6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在<code class="du je jf jg jh b">project</code>的集成测试中检查几个POM，您将会看到它们正在使用<code class="du je jf jg jh b">mrm</code>中创建的测试依赖关系。这是一个很好的开始！</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="f6de" class="jt ju hi bd jv jw lg jy jz ka lh kc kd ke li kg kh ki lj kk kl km lk ko kp kq bi translated">排除故障</h1><p id="364a" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">接下来，我们如何开始实际的调试呢？好吧，我们确实知道的一件事是错误——在代码的某个地方，逻辑被破坏了，这导致了错误。因此，如果我们能够以集成测试的形式重现错误，那么我们也许可以设置断点并调试代码，以找出是哪个方法以及哪一行导致了错误。听起来像个计划！</p><h1 id="0059" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">第一步:从最简单的错误开始</h1><p id="75f4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">总是从容易解决的问题开始。这不仅能让你快速接触到代码库，还能让你树立信心，在以后解决更难更复杂的问题。</p><p id="e08d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的两个问题中，逆序错误中的依赖解决看起来像是一个低挂的水果。我们最初的猜测是，在代码中的某个地方，使用了stack而不是queue，因此当构造结果数据结构时，对象以LIFO顺序弹出，而不是以FIFO顺序轮询，这导致了相反的顺序。我们需要做的就是找出这个结果数据结构在代码中的构造位置，并在那里进行修复。</p><h1 id="4004" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">步骤2:编写一个集成测试</h1><p id="0a1b" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">首先编写一个集成测试，测试可能会失败的预期行为。这给了我们一个代码库的入口点，然后允许我们通过放置断点和检查调试器返回的语句来定位有问题的逻辑。</p><p id="c00c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要知道如何编写一个合适的集成测试，参考一些已经在<code class="du je jf jg jh b">src/it</code>目录中编写的其他集成测试。一旦你适应了，就写一个简单而全面的单元测试:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jn jo l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">单元测试源pom.xml</figcaption></figure><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jn jo l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">单元测试验证. groovy</figcaption></figure><p id="d616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，此处编写的测试只是验证扁平化pom的解析顺序应该是自然顺序，即artifact id“dep”的依赖关系在artifact id“test”的依赖关系之前被解析。</p><p id="0677" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要运行集成测试，有几个选项。您可以:</p><ol class=""><li id="dfea" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">运行单一测试:</li></ol><p id="d178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">mvn verify -Dinvoker.test=flatten-dependency-all-resolution-order</code></p><p id="d567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.运行名称中共享一个公共字符串的多个测试:</p><p id="ab13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">mvn verify -Dinvoker.test=flatten-dependency-all-*</code></p><p id="5b1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.运行所有集成测试:</p><p id="581f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">mvn verify</code></p><p id="4afb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续运行预期行为的单元测试。例如，运行<code class="du je jf jg jh b">flatten-dependency-all-resolution-order</code>给了我们一个失败，其中“测试”首先被解决。这正是我们想要的，所以我们可以继续。</p><h1 id="da91" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">步骤3:配置调试器</h1><p id="415c" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">接下来，我们需要确定哪一行代码导致了问题。为此，我们需要首先设置调试器，放置一些断点，然后再次触发测试，以查看每行返回的内容。</p><p id="4b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要设置调试器，您只需转到顶部菜单栏中的“编辑配置”并从“+”下拉菜单中选择“远程”。给调试器一个名称，然后将端口更新为8000。根据您正在开发的内容选择合适的JDK版本。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/b07a2de9fcb9ee889aaf018dbd2e848a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2A_rbOSZSXfCVRa8eo5QXw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">IntelliJ调试器配置</figcaption></figure><p id="b299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置好调试器后，您可以在调试器模式下运行测试:</p><p id="8414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">mvn verify -Dinvoker.test=flatten-dependency-all-resolution-order -Dinvoker.mavenExecutable=mvnDebug</code></p><p id="131f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在每个集成测试中停止并挂起，以监听调试器连接—单击顶部菜单栏中的绿色bug图标以启动调试器。</p><p id="01c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有任何断点，调试器将运行、通过/失败并退出。这时，在您怀疑导致问题的方法上设置断点并检查每行返回的内容非常有用。</p><h1 id="1915" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">第四步:添加断点</strong></h1><p id="8e1d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">检查插件使用的配置并阅读代码。根据经验猜测哪种方法与您正在使用的特性相关，并设置几个断点，看看运行集成测试是否有所收获。</p><p id="f77b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，我们很快发现我们感兴趣的大多数方法都存在于<code class="du je jf jg jh b">FlattenMojo.java</code>中。我们能够放置断点来缩小有问题的区域，并最终确定导致问题的确切方法。</p><p id="6817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦找到了有问题的逻辑，进行修复就相对简单了。你只需要通读代码，理解发生了什么，查看调试器的输出，然后修改代码。做出更改后，再次运行集成测试，查看新的输出以及集成测试是否通过。反复经历这个过程，进行小的、渐进的改变。</p><h1 id="2213" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">第五步:运行所有的集成测试</strong></h1><p id="5317" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">一旦您对您的更改有信心，确保在提交任何代码更改之前运行<code class="du je jf jg jh b">mvn verify</code>。这确保您的修复不会破坏任何其他东西。</p><p id="4a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有兴趣了解更多，这里是对这两个错误的<a class="ae jd" href="https://github.com/mojohaus/flatten-maven-plugin/pull/134" rel="noopener ugc nofollow" target="_blank">修复</a>。</p><h1 id="2c21" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后的想法</h1><p id="d3e5" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">测试、测试和测试——确保添加足够多的单元测试，以覆盖您的基础和任何其他可能与您的修复直接或间接相关的场景。例如，在我们的例子中，我们固定了依赖解析顺序，所以我们也决定为具有复杂传递依赖的POM编写<a class="ae jd" href="https://github.com/mojohaus/flatten-maven-plugin/pull/134/commits/a37d5f21eb971f1bd15fc4a7090efa2987ea2c02" rel="noopener ugc nofollow" target="_blank">附加测试</a>。这是为了确保我们在修复现有错误的同时不会引入新的错误。这确实是说起来容易做起来难的事情。如果需要，一定要花时间仔细考虑并添加测试用例。</p><p id="a9bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别感谢<a class="ae jd" href="https://github.com/saturnism" rel="noopener ugc nofollow" target="_blank"> Ray Tsang </a>的贡献！如果你想了解更多关于Maven依赖性管理策略的信息，请查看Ray和Apache Maven主席Robert Scholte的谈话。</p><p id="ef90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，<em class="lz">调试愉快，享受学习的乐趣</em>！🙂</p><p id="b9c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在推特上关注我王思的最新消息。</p></div></div>    
</body>
</html>