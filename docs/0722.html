<html>
<head>
<title>Kubernetes Engine access and audit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes引擎访问和审计</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-engine-access-and-audit-b979bbba50d0?source=collection_archive---------0-----------------------#2018-08-10">https://medium.com/google-cloud/kubernetes-engine-access-and-audit-b979bbba50d0?source=collection_archive---------0-----------------------#2018-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="352d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">库伯内特斯历险记</h2></div><p id="3ba0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我一直在探索与可信的外部开发人员共享集群访问权限的方法。这些开发者需要的不仅仅是纯粹的Kubernetes访问，他们还希望能够<code class="du jt ju jv jw b">ssh</code>进入节点。</p><h2 id="1fa7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">有用的分流:gcloud — account=[[ACCOUNT]]</h2><p id="7f39" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">本周我发现有一个<code class="du jt ju jv jw b">gcloud</code>(代表GCP)标志来指定用于该命令范围的Google帐户。如果你希望明确哪个账户正在被使用(就像我对GCP项目和Kubernetes集群所做的那样，见<a class="ae kx" rel="noopener" href="/google-cloud/context-light-gcloud-and-kubectl-89185d38ce82">故事</a>)，这个特性是有用的，但是它更容易允许动态切换账户。</p><p id="286a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="58b1" class="jx jy hi jw b fi lg lh l li lj">gcloud auth list</span><span id="79c6" class="jx jy hi jw b fi lk lh l li lj">ACTIVE  ACCOUNT<br/>*       <a class="ae kx" href="mailto:daz.wilkin@gmail.com" rel="noopener ugc nofollow" target="_blank">my</a>@gmail.com<br/>        my@<a class="ae kx" href="mailto:dazwilkin@cloud-sce.com" rel="noopener ugc nofollow" target="_blank">o</a>ther.com<br/>        my@google.com</span><span id="0f9b" class="jx jy hi jw b fi lk lh l li lj">To set the active account, run:<br/>    $ gcloud config set account `ACCOUNT`</span></pre><p id="be8f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了方便起见，我有一个默认的(<code class="du jt ju jv jw b">active</code> ) <code class="du jt ju jv jw b">gcloud</code>账户。这是最近的<code class="du jt ju jv jw b">gcloud auth login</code>账户，但也可以使用<code class="du jt ju jv jw b">gcloud config set account [ACCOUNT]</code>设置。</p><p id="1f39" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直到本周，我都会表演这种舞蹈:</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="d1c5" class="jx jy hi jw b fi lg lh l li lj">gcloud config set account my@google.com<br/>gcloud some-command<br/>gcloud config set account my@gmail.com<br/>gcloud some-command</span></pre><p id="2529" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我知道了有可能(而且更优雅地)做到:</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="94ce" class="jx jy hi jw b fi lg lh l li lj">gcloud some-command --account=my@google.com<br/>gcloud some-command --account=my@gmail.com</span></pre><p id="ae79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了测试开发者的访问权限，我使用我的Gmail账户作为代理。</p><h2 id="378f" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">谷歌群组</h2><p id="8659" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在GCP项目中使用Google Groups进行IAM角色分配是一个很好的做法。一般(！)您可以使用在您的组织域(例如<code class="du jt ju jv jw b">acme.com</code>)上创建的Google Groups来创建这些组。在我的例子中，因为开发人员不是谷歌人，而且因为我们(通常)不被允许向在<code class="du jt ju jv jw b">google.com</code>上创建的组添加非<code class="du jt ju jv jw b">@google.com</code>帐户，我将使用公共的谷歌组域(<code class="du jt ju jv jw b">googlegroups.com</code>)。</p><p id="b7b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我的Gmail帐户创建了这个组，所以它自动成为该组的成员，我可以立即开始测试。我需要添加开发人员的谷歌帐户到这个开发人员的工作小组。但是(！)因为我使用的是一个组，并且将IAM角色分配给该组，所以我可以确信我的Gmail帐户和他们的Google帐户在项目中将具有功能上等同的角色:</p><figure class="ky kz la lb fd lm er es paragraph-image"><div class="er es ll"><img src="../Images/e7f7fd4636acc0293bf8521c19e223a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*rSMGgiG49INg6sVS4-Z8LA.png"/></div></figure><h2 id="a864" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">InternationalAssociationofMachinists国际机械师协会</h2><p id="8c50" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">这是该组在项目中的权限的快照。您可以使用云控制台UI来创建它，或者，我将向您展示如何从命令行完成此操作。首先我们需要创建第二个角色<code class="du jt ju jv jw b">instance-ssh</code>。</p><figure class="ky kz la lb fd lm er es paragraph-image"><div class="er es lp"><img src="../Images/fc82427cb9a747f98546bf2003f92565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*DWZfndGzZrGBIy6Q1oWDFg.png"/></div></figure><p id="292a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个角色是<code class="du jt ju jv jw b"><a class="ae kx" href="https://cloud.google.com/kubernetes-engine/docs/how-to/iam#predefined" rel="noopener ugc nofollow" target="_blank">Kubernetes Engine Developer</a></code>。这为开发人员提供了对集群的访问，但是我也希望开发人员能够进入集群的节点。节点是计算引擎虚拟机，没有现成的角色提供仅<code class="du jt ju jv jw b">ssh</code>访问。因此，我使用自定义角色创建了一个:</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="1269" class="jx jy hi jw b fi lg lh l li lj">gcloud iam roles create instance_ssh \<br/>--project=${PROJECT} <br/>--file=instance_ssh.role.yaml</span></pre><p id="84a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和YAML:</p><figure class="ky kz la lb fd lm"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="8232" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这4个权限允许具有该角色的帐户列出项目中的实例并<code class="du jt ju jv jw b">ssh</code>进入其中。<code class="du jt ju jv jw b">setMetadata</code>权限支持<code class="du jt ju jv jw b">gcloud compute ssh</code>向项目的元数据服务添加帐户的公钥。这些帐户还必须能够使用计算引擎服务帐户(虽然这是一个必要的功能，但有点令人困惑；我们将服务帐户视为一种资源):</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="564e" class="jx jy hi jw b fi lg lh l li lj">gcloud iam service-accounts add-iam-policy-binding \<br/>${PROJECT_NUMBER}-compute@developer.gserviceaccount.com \ <br/>--member=group:${GROUP}@googlegroups.com \<br/>--role=roles/iam.serviceAccountUser \<br/>--project=${PROJECT}</span></pre><p id="9658" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">计算引擎服务帐户是自动生成的，如果其名称是由您的GCP项目的编号(不是ID)和“<code class="du jt ju jv jw b">-compute@developer.gserviceaccount.com</code>”组合而成的，则会自动生成。从云控制台查看电子邮件地址最简单:</p><figure class="ky kz la lb fd lm er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/eff75ce8199adebf3041f94a33fb77e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEhBgKNv_8_N9kazmuEofA.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">确定项目的默认计算引擎服务帐户</figcaption></figure><h2 id="9d77" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">Kubernetes发动机用户</h2><p id="cdb5" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">要知道，一旦通过了<code class="du jt ju jv jw b">gcloud</code>的认证，谷歌账户仍然可以被操作系统用户使用。在我的情况下，在我的工作机器上(当我登录时)，我可以在显示的3个谷歌账户之间切换，只需使用<code class="du jt ju jv jw b">--account=[[ACCOUNT]]</code>标志。</p><blockquote class="mb mc md"><p id="cd1d" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>您必须<code class="du jt ju jv jw b">gcloud auth revoke [[ACCCOUNT]]</code>删除缓存的凭证。</p></blockquote><p id="fb9d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一事实也与Kubernetes发动机相关。虽然Kubernetes维护自己的授权机制，但Kubernetes引擎支持Google的OAuth，一旦用户拥有<code class="du jt ju jv jw b">gcloud container clusters get-credentials</code>……这就是问题所在……*任何*由gcloud认证并拥有集群适当权限的帐户都可以使用它。推论:不仅仅是帐户被<code class="du jt ju jv jw b">get-credentials</code>命令使用。</p><p id="1d77" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果<code class="du jt ju jv jw b">my@google.com</code>创建了集群并获得了凭证，因为我已经按照上面的说明为同一个项目对<code class="du jt ju jv jw b">my@gmail.com</code>进行了访问控制，所以作为<code class="du jt ju jv jw b">gcloud</code>的活动帐户的帐户将成为<code class="du jt ju jv jw b">kubectl</code>(!)用途。</p><p id="1a0a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哇哦！？？</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="10fd" class="jx jy hi jw b fi lg lh l li lj">gcloud config set account my@gmail.com<br/>kubectl apply --filename=${DEPLOYMENT-1} \<br/>--namespace=${NAMESPACE} \<br/>--context=${CONTEXT}<br/>gcloud config set account my@google.com<br/>kubectl apply --filename=${DEPLOYMENT-2} \<br/>--namespace=${NAMESPACE} \<br/>--context=${CONTEXT}</span></pre><p id="1796" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将<code class="du jt ju jv jw b">{DEPLOYMENT-1}</code>部署为<code class="du jt ju jv jw b">my@gmail.com</code>，<code class="du jt ju jv jw b">${DEPLOYMENT-2}</code>部署为<code class="du jt ju jv jw b">my@google.com</code>。</p><p id="5fd4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我如何能确认这一点？日志。</p><h2 id="c97a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">审计日志</h2><p id="6f9f" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">没有任何东西通过审计日志记录器。我们想做的是确定谁在何时做了什么？这很简单:</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="16ef" class="jx jy hi jw b fi lg lh l li lj">PROJECT=[[YOUR-PROJECT]]<br/>ACCOUNT=[[YOUR-ACCOUNT]]</span><span id="a5af" class="jx jy hi jw b fi lk lh l li lj">LOG="cloudaudit.googleapis.com%2Factivity"<br/>FILTER="logName=\"projects/${PROJECT}/logs/${LOG}\" "\<br/>"resource.type=\"k8s_cluster\""</span><span id="de9e" class="jx jy hi jw b fi lk lh l li lj">gcloud logging read "${FILTER}" \<br/>--freshness=1h \<br/>--project=${PROJECT} \<br/>--account=${ACCOUNT} \<br/>--format=json \<br/>| jq --raw-output <strong class="jw hj">'.[].protoPayload.methodName'</strong> \<br/>| sort \<br/>| uniq</span><span id="c918" class="jx jy hi jw b fi lk lh l li lj">io.k8s.apiextensions.v1beta1.customresourcedefinitions.create<br/>io.k8s.apiextensions.v1beta1.customresourcedefinitions.patch<br/>io.k8s.apiregistration.v1.apiservices.create<br/>io.k8s.apps.v1.deployments.create<br/>io.k8s.app.v1alpha1.applications.create<br/>io.k8s.authorization.rbac.v1.clusterrolebindings.patch<br/>io.k8s.batch.v1.jobs.create<br/>io.k8s.certificates.v1beta1.certificatesigningrequests.delete<br/>io.k8s.core.v1.configmaps.create<br/>io.k8s.core.v1.configmaps.update<br/>io.k8s.core.v1.endpoints.create<br/>io.k8s.core.v1.endpoints.update<br/>io.k8s.core.v1.namespaces.create<br/>io.k8s.core.v1.persistentvolumeclaims.create<br/>io.k8s.core.v1.persistentvolumeclaims.update<br/>io.k8s.core.v1.persistentvolumes.create<br/>io.k8s.core.v1.persistentvolumes.update<br/>io.k8s.core.v1.pods.binding.create<br/>io.k8s.core.v1.pods.create<br/>io.k8s.core.v1.secrets.create<br/>io.k8s.core.v1.serviceaccounts.create<br/>io.k8s.core.v1.serviceaccounts.update<br/>io.k8s.core.v1.services.create<br/>io.k8s.extensions.v1beta1.deployments.create<br/>io.k8s.extensions.v1beta1.deployments.patch<br/>io.k8s.extensions.v1beta1.replicasets.create<br/>io.k8s.storage.v1.storageclasses.create<br/>io.k8s.storage.v1.storageclasses.patch</span><span id="4f3b" class="jx jy hi jw b fi lk lh l li lj">gcloud logging read "${FILTER}" \<br/>--freshness=1h \<br/>--project=${PROJECT} \<br/>--account=${ACCOUNT} \<br/>--format=json \<br/>| jq --raw-output <strong class="jw hj">'.[].protoPayload | { email:.authenticationInfo.principalEmail, method:.methodName }'</strong></span><span id="7afc" class="jx jy hi jw b fi lk lh l li lj">gcloud logging read "${FILTER}" \<br/>--freshness=1h \<br/>--project=${PROJECT} \<br/>--account=${ACCOUNT} \<br/>--format=json \<br/>| jq --raw-output <strong class="jw hj">'.[].protoPayload | .authenticationInfo.principalEmail + " " + .methodName '</strong> \<br/>| sort \<br/>| uniq</span><span id="bd7c" class="jx jy hi jw b fi lk lh l li lj">cluster-autoscaler io.k8s.core.v1.configmaps.update<br/>cluster-autoscaler io.k8s.core.v1.endpoints.update<br/>my@gmail.com io.k8s.apps.v1.deployments.create<br/>my@gmail.comio.k8s.app.v1alpha1.applications.create<br/>my@gmail.comio.k8s.batch.v1.jobs.create<br/>my@gmail.comio.k8s.core.v1.configmaps.create<br/>my@gmail.comio.k8s.core.v1.namespaces.create<br/>my@gmail.comio.k8s.core.v1.persistentvolumeclaims.create<br/>my@gmail.comio.k8s.core.v1.persistentvolumes.create<br/>my@gmail.comio.k8s.core.v1.pods.create<br/>my@gmail.comio.k8s.core.v1.services.create<br/>my@gmail.comio.k8s.extensions.v1beta1.deployments.create<br/>my@gmail.comio.k8s.storage.v1.storageclasses.create<br/>my@gmail.comio.k8s.storage.v1.storageclasses.patch<br/>system:apiserver io.k8s.apiregistration.v1.apiservices.create<br/>system:kube-controller-manager io.k8s.core.v1.secrets.create<br/>system:kube-controller-manager io.k8s.core.v1.serviceaccounts.update<br/>system:kube-scheduler io.k8s.core.v1.pods.binding.create<br/>...<br/>system:unsecured io.k8s.core.v1.configmaps.update<br/>system:unsecured io.k8s.extensions.v1beta1.deployments.patch</span></pre><blockquote class="mb mc md"><p id="d181" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>(审计)日志快速增长。通过包含<code class="du jt ju jv jw b">--freshness</code>标志来限制您<code class="du jt ju jv jw b">read</code>的日志是一个很好的做法。这里设定为一小时。</p></blockquote><p id="013d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些都是为Kubernetes引擎记录的，在这里:</p><p id="2eab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae kx" href="https://cloud.google.com/kubernetes-engine/docs/how-to/audit-logging" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/kubernetes-engine/docs/how-to/audit-logging</a></p><h2 id="e4c7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">japan quarterly 日本季刊</h2><p id="eca4" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">因此，我感兴趣的是如何最好地转换日志数据以获得用户的方法:</p><pre class="ky kz la lb fd lc jw ld le aw lf bi"><span id="916f" class="jx jy hi jw b fi lg lh l li lj">gcloud logging read "${FILTER}" \<br/>--freshness=1d \<br/>--project=${PROJECT} \<br/>--account=${ACCOUNT} \<br/>--format=json \<br/>| jq --raw-output '[.[].protoPayload | { email:.authenticationInfo.principalEmail, method:.methodName }]' \<br/>| jq 'group_by(.email)' \<br/>| jq 'map({"email": .[0].email, "method": map(.method) | unique})'</span></pre><p id="0b5e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">漂亮得像个要点:</p><figure class="ky kz la lb fd lm"><div class="bz dy l di"><div class="lq lr l"/></div></figure><blockquote class="mb mc md"><p id="3254" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>当然，jq命令可以组成一个单独的jq语句，但是，这代表了我构建管道的方式，所以我保留了它。</p></blockquote><p id="779f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整洁！它丢失信息(什么部署？)但是……它显示了用户方法的范围。</p><h2 id="f01f" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jg ki kj kk jk kl km kn jo ko kp kq kr bi translated">结论</h2><p id="369f" class="pw-post-body-paragraph ix iy hi iz b ja ks ij jc jd kt im jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在这个故事中，我们已经讲述了<code class="du jt ju jv jw b">gcloud</code>的有用的<code class="du jt ju jv jw b">account</code>标志。简要介绍了Kubernetes引擎认证的工作原理，并简单介绍了GCP的IAM，包括自定义角色，最后介绍了一些审计日志功能。</p><p id="3550" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>