<html>
<head>
<title>Hands on Knative — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动手实践—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/hands-on-knative-part-2-a27729f4d756?source=collection_archive---------0-----------------------#2019-02-11">https://medium.com/google-cloud/hands-on-knative-part-2-a27729f4d756?source=collection_archive---------0-----------------------#2019-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6ede" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的<a class="ae jd" rel="noopener" href="/google-cloud/hands-on-knative-part-1-f2d5ce89944e">上一篇文章</a>中，我谈到了用于快速部署和自动伸缩无服务器容器的<a class="ae jd" href="https://github.com/knative/docs/tree/master/serving" rel="noopener ugc nofollow" target="_blank">主动服务</a>。如果您希望您的服务由HTTP调用同步触发，那么Knative Serving非常有用。然而，在无服务器的微服务世界中，异步触发器更加常见和有用。这时候<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing" rel="noopener ugc nofollow" target="_blank"> Knative Eventing </a>开始发挥作用。</p><p id="36fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Knative系列实践的第二部分中，我想介绍Knative Eventing，并展示一些来自我的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial" rel="noopener ugc nofollow" target="_blank"> Knative教程</a>的关于如何将其与各种服务集成的例子。</p><h1 id="c09a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是Knative Eventing？</h1><p id="8e0c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Knative Eventing与Knative Serving一起工作，它为松散耦合的事件驱动服务提供了原语。典型的Knative事件架构如下所示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/bde8d14b579f9a6e6cd5e84916a7140b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RXDaXeCERZ9db3AN-R26Q.png"/></div></div></figure><p id="0901" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有4个主要组件:</p><ul class=""><li id="cf82" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj"> Source </strong>(又名Producer)从实际的源中读取事件，并向下游转发到通道，或者直接转发到服务。</li><li id="5910" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">通道</strong>从源接收事件，保存到它的底层存储(稍后将详细介绍)并扇出到所有订阅者。</li><li id="7f07" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">订阅</strong>沟通渠道和服务(或另一个渠道)。</li><li id="c072" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">服务</strong>(又名消费者)是消费事件流的Knative服务。</li></ul><p id="aa60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更详细地看看这些。</p><h1 id="24b8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">来源、渠道和订阅</h1><p id="fdc4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Knative Eventing的最终目标是将事件从一个源路由到一个服务，它使用我之前提到的原语来完成:源、通道和订阅。</p><p id="0319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Source </strong>从实际来源读取事件，并将它们转发到下游。截至今天，Knative支持从<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing#kuberneteseventsource" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>、<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing#githubsource" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing#gcppubsubsource" rel="noopener ugc nofollow" target="_blank"> Google Cloud Pub/Sub </a>、<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing#awssqssource" rel="noopener ugc nofollow" target="_blank"> AWS SQS主题</a>、<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing#awssqssource" rel="noopener ugc nofollow" target="_blank">容器</a>和<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing#cronjobsource" rel="noopener ugc nofollow" target="_blank"> CronJobs </a>中读取事件。</p><p id="2bc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦事件被拉入Knative，它需要保存在内存中或更持久的地方，如Kafka或Google Cloud Pub/Sub。这发生在<strong class="ih hj">通道上。</strong>它有多个<a class="ae jd" href="https://github.com/knative/docs/tree/master/eventing/channels" rel="noopener ugc nofollow" target="_blank">实现</a>来支持不同的选项。</p><p id="6f67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从通道，事件被传递到所有感兴趣的Knative服务或其他通道。这可能是一对一或扇出。<strong class="ih hj">订阅</strong>决定了这种交付的性质，在渠道和Knative服务之间起到了桥梁的作用。</p><p id="f7da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经了解了Knative eventing的基础，让我们来看一个具体的例子。</p><h1 id="2651" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">你好世界活动</h1><p id="6e09" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对于Hello World Eventing，让我们从Google Cloud Pub/Sub读取消息，并在Knative服务中将其注销。我的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/06-helloworldeventing.md" rel="noopener ugc nofollow" target="_blank"> Hello World Eventing教程</a>有所有的细节，但在这里重述一下，这是我们需要设置的:</p><ol class=""><li id="7cdf" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc lh kz la lb bi translated">一个<strong class="ih hj"> GcpPubSubSource </strong>从Google Cloud Pub/Sub读取消息。</li><li id="66aa" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lh kz la lb bi translated">一个<strong class="ih hj">通道</strong>将消息保存在内存中。</li><li id="1470" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lh kz la lb bi translated">一个<strong class="ih hj">订阅</strong>将频道链接到Knative服务。</li><li id="95c8" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc lh kz la lb bi translated">一个<strong class="ih hj"> Knative服务</strong>用于接收消息和注销。</li></ol><p id="cfff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ll b">gcp-pubsub-source.yaml</code>定义GcpPubSubSource。它指向一个名为<code class="du li lj lk ll b">testing</code>的发布/订阅主题，它拥有访问发布/订阅的凭证，并且还指定了应该将哪些通道事件转发给它，如下所示:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="3c13" class="lq jf hi ll b fi lr ls l lt lu">apiVersion: sources.eventing.knative.dev/v1alpha1<br/>kind: GcpPubSubSource<br/>metadata:<br/>  name: testing-source<br/>spec:<br/>  <strong class="ll hj">gcpCredsSecret</strong>:  # A secret in the knative-sources namespace<br/>    name: google-cloud-key<br/>    key: key.json<br/>  googleCloudProject: knative-atamel  # Replace this<br/>  <strong class="ll hj">topic: testing</strong><br/>  sink:<br/>    apiVersion: eventing.knative.dev/v1alpha1<br/><strong class="ll hj">    kind: Channel<br/>    name: pubsub-test</strong></span></pre><p id="924d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们用<code class="du li lj lk ll b">channel.yaml</code>定义通道。在这种情况下，我们只是将消息保存在内存中:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="4e95" class="lq jf hi ll b fi lr ls l lt lu">apiVersion: eventing.knative.dev/v1alpha1<br/>kind: Channel<br/>metadata:<br/>  name: pubsub-test<br/>spec:<br/>  provisioner:<br/>    apiVersion: eventing.knative.dev/v1alpha1<br/>    kind: ClusterChannelProvisioner<br/>    name: in-memory-channel</span></pre><p id="857c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续创建源和通道:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="c2d4" class="lq jf hi ll b fi lr ls l lt lu">kubectl apply -f gcp-pubsub-source.yaml<br/>kubectl apply -f channel.yaml</span></pre><p id="be0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到源和通道已创建，并且还创建了一个源窗格:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="4da2" class="lq jf hi ll b fi lr ls l lt lu">kubectl get gcppubsubsource<br/>NAME             AGE<br/>testing-source   1m</span><span id="d952" class="lq jf hi ll b fi lv ls l lt lu">kubectl get channel<br/>NAME          AGE<br/>pubsub-test   1m</span><span id="3c8c" class="lq jf hi ll b fi lv ls l lt lu">kubectl get pods<br/>NAME                                              READY     STATUS    <br/>gcppubsub-testing-source-qjvnk-64fd74df6b-ffzmt   2/2       Running</span></pre><p id="405c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以创建Knative服务，并在一个<code class="du li lj lk ll b">subscriber.yaml</code>文件中将它链接到订阅频道:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="5503" class="lq jf hi ll b fi lr ls l lt lu">apiVersion: serving.knative.dev/v1alpha1<br/>kind: <strong class="ll hj">Service</strong><br/>metadata:<br/>  name: message-dumper-csharp<br/>spec:<br/>  runLatest:<br/>    configuration:<br/>      revisionTemplate:<br/>        spec:<br/>          container:<br/>            # Replace {username} with your actual DockerHub<br/>            image: docker.io/{username}/message-dumper-csharp:v1</span><span id="de4f" class="lq jf hi ll b fi lv ls l lt lu">---<br/>apiVersion: eventing.knative.dev/v1alpha1<br/>kind: Subscription<br/>metadata:<br/>  name: gcppubsub-source-sample-csharp<br/>spec:<br/>  channel:<br/>    apiVersion: eventing.knative.dev/v1alpha1<br/><strong class="ll hj">    kind: Channel<br/>    name: pubsub-test</strong><br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1alpha1<br/><strong class="ll hj">      kind: Service<br/>      name: message-dumper-csharp</strong></span></pre><p id="91a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，<code class="du li lj lk ll b">message-dumper-csharp</code>只是一个常规的Knative服务，但它是通过订阅的Knative事件异步触发的。</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="d464" class="lq jf hi ll b fi lr ls l lt lu">kubectl apply -f subscriber.yaml</span><span id="b12f" class="lq jf hi ll b fi lv ls l lt lu">service.serving.knative.dev "message-dumper-csharp" created<br/>subscription.eventing.knative.dev "gcppubsub-source-sample-csharp" configured</span></pre><p id="f193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你<code class="du li lj lk ll b">kubectl apply</code>了所有的yaml文件，你就可以使用gcloud向Pub/Sub topic发送消息:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="611d" class="lq jf hi ll b fi lr ls l lt lu">gcloud pubsub topics publish testing --message="Hello World"</span></pre><p id="efac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该能够看到为该服务创建的窗格:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="72e9" class="lq jf hi ll b fi lr ls l lt lu">kubectl get pods<br/>NAME                                                      READY<br/>gcppubsub-testing-source-qjvnk-64fd74df6b-ffzmt           2/2       Running   0          3m<br/><strong class="ll hj">message-dumper-csharp-00001-deployment-568cdd4bbb-grnzq </strong>  3/3       Running   0          30s</span></pre><p id="a3a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该服务将Base64编码的消息记录在<code class="du li lj lk ll b">Data</code>下:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="f7bc" class="lq jf hi ll b fi lr ls l lt lu">info: message_dumper_csharp.Startup[0]<br/>      C# Message Dumper received message: {"ID":"198012587785403","Data":"SGVsbG8gV29ybGQ=","Attributes":null,"PublishTime":"2019-01-21T15:25:58.25Z"}<br/>info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]<br/>      Request finished in 29.9881ms 200</span></pre><p id="76df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看我的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/06-helloworldeventing.md" rel="noopener ugc nofollow" target="_blank"> Hello World Eventing教程</a>，了解更多关于步骤和实际代码的细节。</p><h1 id="0aa6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">与云存储和Vision API集成</h1><p id="2575" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当您试图以无缝方式连接完全不相关的服务时，Knative Eventing确实大放异彩。在我的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/08-visioneventing.md" rel="noopener ugc nofollow" target="_blank">与Vision API集成教程</a>中，我展示了如何使用Knative Eventing连接Google云存储和Google Cloud Vision API。</p><p id="6b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">云存储是一种全球可用的数据存储服务。存储桶可以配置为在保存图像时发出发布/订阅消息。然后，我们可以使用Knative Eventing监听这些发布/订阅消息，并将它们传递给Knative服务。在服务中，我们使用图像进行视觉API调用，并使用机器学习从图像中提取标签。所有的细节在教程中都有解释，但是我想在这里指出一些事情。</p><p id="c686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，在Knative中，所有出站流量都被默认阻止。这意味着默认情况下，您甚至不能从Knative服务调用Vision API。这最初让我感到惊讶，所以请确保您<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/06-helloworldeventing.md#configuring-outbound-network-access" rel="noopener ugc nofollow" target="_blank">配置了网络出站访问</a>。</p><p id="1663" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，每当一个图像被保存到云存储时，它都会发出<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/08-visioneventing.md#define-cloud-events" rel="noopener ugc nofollow" target="_blank"> CloudEvents </a>。Knative Eventing通常适用于CloudEvents。您需要将传入的请求解析为CloudEvents，并提取您需要的信息，例如事件类型和图像文件的位置:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="aa14" class="lq jf hi ll b fi lr ls l lt lu">var cloudEvent = JsonConvert.DeserializeObject&lt;CloudEvent&gt;(content);</span><span id="285e" class="lq jf hi ll b fi lv ls l lt lu">var eventType = cloudEvent.Attributes["eventType"];</span><span id="d2b4" class="lq jf hi ll b fi lv ls l lt lu">var storageUrl = ConstructStorageUrl(cloudEvent);</span></pre><p id="7175" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些信息，很容易为图像构造一个存储URL，并使用该URL进行Vision API调用。完整的源代码在这里<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/08-visioneventing.md#add-vision-api" rel="noopener ugc nofollow" target="_blank">解释</a>，但这里是相关部分:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="c9b5" class="lq jf hi ll b fi lr ls l lt lu">var visionClient = ImageAnnotatorClient.Create();<br/>var labels = await visionClient.DetectLabelsAsync(Image.FromUri(storageUrl), maxResults: 10);</span></pre><p id="d39c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦代码准备好了，我们就可以通过定义一个<code class="du li lj lk ll b">subscriber.yaml</code>来将我们的服务与Knative Eventing挂钩。和以前很像。我们正在重用现有的源和通道，所以我们不必重新创建它们。我们刚刚创建了一个新的订阅，指向我们新的包含Vision API容器的Knative服务:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="dc81" class="lq jf hi ll b fi lr ls l lt lu">apiVersion: serving.knative.dev/v1alpha1<br/>kind: <strong class="ll hj">Service</strong><br/>metadata:<br/>  name: vision-csharp<br/>spec:<br/>  runLatest:<br/>    configuration:<br/>      revisionTemplate:<br/>        spec:<br/>          container:<br/>            # Replace {username} with your actual DockerHub<br/>            image: docker.io/{username}/<strong class="ll hj">vision-csharp:v1</strong><br/>---<br/>apiVersion: eventing.knative.dev/v1alpha1<br/>kind: <strong class="ll hj">Subscription</strong><br/>metadata:<br/>  name: gcppubsub-source-vision-csharp<br/>spec:<br/>  channel:<br/>    apiVersion: eventing.knative.dev/v1alpha1<br/><strong class="ll hj">    kind: Channel<br/>    name: pubsub-test</strong><br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1alpha1<br/><strong class="ll hj">      kind: Service<br/>      name: vision-csharp</strong></span></pre><p id="a352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦用<code class="du li lj lk ll b">kubectl apply</code>创建了所有东西，每当您将一个映像保存到云存储桶时，您应该会看到该映像的Knative service日志标签。</p><p id="b645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我有一张我最喜欢的地方的照片:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lw"><img src="../Images/8fee5deaf70e51763d918e071095f663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxMYWYRr3-_KjFZNxbI5dQ.jpeg"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">里约热内卢的伊帕内马海滩</figcaption></figure><p id="1238" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我将该图像保存到存储桶时，我可以在日志中看到来自Vision API的以下标签:</p><pre class="ki kj kk kl fd lm ll ln lo aw lp bi"><span id="76e1" class="lq jf hi ll b fi lr ls l lt lu">info: vision_csharp.Startup[0]<br/>      This picture is labelled: Sea,Coast,Water,Sunset,Horizon<br/>info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]<br/>      Request finished in 1948.3204ms 200</span></pre><p id="64fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们使用Knative Eventing将一个服务(云存储)连接到另一个服务(Vision API)。这只是一个例子，但可能性是无限的。在教程的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/07-translationeventing.md" rel="noopener ugc nofollow" target="_blank">集成翻译API </a>部分，我展示了如何将发布/订阅连接到翻译API。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="43a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是失败事件。在这个系列的下一篇也是最后一篇文章中，我将讨论Knative Build。</p></div></div>    
</body>
</html>