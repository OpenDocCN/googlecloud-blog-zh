<html>
<head>
<title>Kubernetes Engine from scratch 2/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes发动机从零开始2/2</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-engine-from-scratch-2-ac229df87851?source=collection_archive---------1-----------------------#2018-08-16">https://medium.com/google-cloud/kubernetes-engine-from-scratch-2-ac229df87851?source=collection_archive---------1-----------------------#2018-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f3bb" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">库伯内特斯历险记</h2></div><p id="ac4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到我的Noogler(参见<a class="ae jt" rel="noopener" href="/google-cloud/kubernetes-engine-from-scratch-2c2369c46841">第一部分</a>)那里，他有兴趣在各种类型的控制器上部署一些pod。</p><h2 id="a77a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">一个集装箱</h2><p id="b821" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">让我们从最小部署开始。我将使用他构建的<a class="ku kv ge" href="https://medium.com/u/b78c1a5c6205?source=post_page-----ac229df87851--------------------------------" rel="noopener" target="_blank">sal maan Rashid</a>“knowning”节点示例来探索Istio，因为它使用向下API并支持简单的前端-后端配置。</p><p id="083b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Downward API为Kubernetes Pods提供了一种方式来确定有关其(Kubernetes)运行时环境的信息，而不会危及“第四堵墙”。</p><p id="4ad6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是萨尔代码的一个变体:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="e86e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了省去你的麻烦，我为你构建并推送到docker hub(<code class="du ld le lf lg b">dazwilkin/knowingnode:0</code>)。您应该能够:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="7107" class="ju jv hi lg b fi ll lm l ln lo">docker run \<br/>--interactive \<br/>--tty \<br/>--publish=8080:8080 \<br/>dazwilkin/knowingnode:0</span></pre><p id="3cc8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="96ec" class="ju jv hi lg b fi ll lm l ln lo">google-chrome http://localhost:8080</span></pre><p id="388b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请看:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lp"><img src="../Images/40f0c303ac3630d5a1220abec9828c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzS3Imvjld7vCQ3JrAh96g.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">“已知节点”容器</figcaption></figure><p id="030a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>点开。在本地部署容器时，并非所有链接都有效。</p><h2 id="b03e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">一个豆荚</h2><p id="3d4c" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">为自己创建一个集群，然后:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="8c96" class="ju jv hi lg b fi ll lm l ln lo">kubectl run knowingnode --image=dazwilkin/knowingnode:0</span></pre><p id="ecb0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Kubernetes发动机控制台:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es ma"><img src="../Images/4bb627113615428ba6b2f22e427a361c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4E3N8FN--HfGia4oaOGTA.png"/></div></div></figure><p id="3ed0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，您应该能够:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="cd9c" class="ju jv hi lg b fi ll lm l ln lo">POD=$(kubectl get pod \<br/>--selector=run=knowingnode \<br/>--output=jsonpath="{ .items[0].metadata.name }") &amp;&amp; echo ${POD}<br/><strong class="lg hj">knowingnode-946fb96b-v78wp</strong></span></pre><p id="d0d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是<code class="du ld le lf lg b">kubectl</code>的一个强大功能。在之前的故事中，我使用了<code class="du ld le lf lg b">output=yaml</code>，但是你也可以使用<code class="du ld le lf lg b">— output=json</code>。如果您获得JSON，那么您可以将结果通过管道传输到<code class="du ld le lf lg b">jq</code>并使用它创造奇迹。然而，在这种情况下，我能够用JSONPATH完成我需要的JSON处理。我们拿到了豆荚的名字。</p><blockquote class="mb mc md"><p id="3359" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>有一个output=name，但它以资源类型为前缀。</p></blockquote><p id="b2e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="30a4" class="ju jv hi lg b fi ll lm l ln lo">kubectl port-forward ${POD} 8080:8080</span></pre><p id="ff91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，您应该能够刷新您的浏览器选项卡…但继续从容器的页面获得空结果。这是因为我们还没有配置向下的API值，所以它无法检索这些值。让我们这样做:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="90e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和之前的故事一样，我通过<code class="du ld le lf lg b">kubectl get deployment/knowingnode --output=yaml</code>和编辑开始了这个YAML。这里要注意的区域是容器的<code class="du ld le lf lg b">env</code>部分。这里我们为容器定义环境变量。请暂时忽略<code class="du ld le lf lg b">SERVICE_NAME</code>。接下来的4个变量(<code class="du ld le lf lg b">NODE_NAME</code>、<code class="du ld le lf lg b">NODE_IP</code>、<code class="du ld le lf lg b">POD_NAME</code>和<code class="du ld le lf lg b">POD_IP</code>)都使用向下API来收集这个Pod及其节点的状态数据。有不同的方法来合并向下API。这种方法使用环境变量。变量值(这里是<code class="du ld le lf lg b">fieldPath</code>)是对Pod元数据的引用。这里可以看到<code class="du ld le lf lg b">metadata.name</code>被重用。</p><p id="3164" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管Downward API提供了特定于Kubernetes的数据。向下API和容器之间有一个清晰的分离。容器不知道向下API。但是容器理解环境变量。我们没有对容器进行任何更改。容器图像可以在任何地方工作。当它被部署在这里时，它会显示Downward API提供给它的值。整洁！</p><h2 id="f481" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak">一次部署</strong></h2><p id="b839" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">将此修改后的部署应用到您的群集:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="0d04" class="ju jv hi lg b fi ll lm l ln lo">kubectl apply --filename=deployment.yaml</span></pre><p id="3273" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您将需要重新运行命令来获取<code class="du ld le lf lg b">${POD}</code>值和<code class="du ld le lf lg b">port-foward</code>，因为当我们应用更新的部署时，部署终止了原始Pod并替换了它。</p><p id="36c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您应该能够浏览<code class="du ld le lf lg b">/backend</code>端点并查看相关信息。就我而言:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mi"><img src="../Images/0e2fb082a17a65be57c3aa48b8c620d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*u9riSgI_REByqus5ol2NiQ.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">正在使用的向下API</figcaption></figure><p id="5c53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，您可能已经注意到了，部署也包括3个副本。我们正在使用第一个(0 ),但我们真的应该创建一个服务和…</p><p id="ba09" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和服务部门谈谈！</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="a830" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该服务创建一个<code class="du ld le lf lg b">NodePort</code>。一个<code class="du ld le lf lg b"> NodePort</code>是一个服务端点，它在集群中每个<strong class="iz hj">节点</strong>的同一个端口上可用。您可以访问任何集群节点，我们的服务将在<code class="du ld le lf lg b">NodePort</code>可用。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mj"><img src="../Images/7985b4789c8d0e427d460d09a49ac1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*MVCR2_tVx-5h7NGoftnSSw.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">服务“已知节点”</figcaption></figure><p id="1497" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，我们必须首先到达节点。Kubernetes引擎节点是一个计算引擎虚拟机。我们可以<code class="du ld le lf lg b">ssh</code>轻松进入计算引擎虚拟机，但我们需要知道节点名称，即虚拟机实例名称:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="b014" class="ju jv hi lg b fi ll lm l ln lo">kubectl get nodes --output=jsonpath="{.items[*].metadata.name}"<br/>--output=jsonpath="{.items[*].metadata.name}"<br/>gke-...-045e36a8-lzxl<br/>gke-...-802a34dc-g589<br/>gke-...-89d5b7a9-fvjb</span></pre><p id="4a38" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过将<code class="du ld le lf lg b">*</code>替换为数字(如<code class="du ld le lf lg b">0</code>)来抓取特定节点。或者，你可以随便抓一个:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="9ed9" class="ju jv hi lg b fi ll lm l ln lo">NODE=$(shuf \<br/>--head-count=1 \<br/>--echo $(\<br/>  kubectl get nodes \<br/>  --output=jsonpath="{.items[*].metadata.name}")\<br/>) &amp;&amp; echo ${NODE}</span></pre><p id="d81e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们还必须确定分配给我们的服务的节点端口。这也很简单:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="a900" class="ju jv hi lg b fi ll lm l ln lo">PORT=$(\<br/>  kubectl get service/knowingnode \<br/>  --output=jsonpath="{.spec.ports[0].nodePort}" &amp;&amp; echo ${PORT}</span></pre><blockquote class="mb mc md"><p id="3f53" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>我不只是知道这些路径语句。我要做的是用<code class="du ld le lf lg b">— output=json</code>或<code class="du ld le lf lg b">— output=yaml</code>运行命令，然后构建正确的过滤器。所以你可以看到你需要<code class="du ld le lf lg b">--output=jsonpath="{.spec}"</code>，并进化你的过滤器，直到它满足你的需要。</p></blockquote><p id="bdc1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们有了<code class="du ld le lf lg b">${NODE}</code>和<code class="du ld le lf lg b">${PORT}</code>，我们可以:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="9fbb" class="ju jv hi lg b fi ll lm l ln lo">gcloud compute ssh ${NODE} \<br/>--ssh-flag="-L ${PORT}:localhost:${PORT}" \<br/>--project=${PROJECT}</span></pre><blockquote class="mb mc md"><p id="a8b5" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>为了简单起见，我将节点端口映射到本地的同一个端口(如上)。但是，如果您愿意，您可以使用<code class="du ld le lf lg b">8080:localhost:{$PORT}</code>在本地映射到<code class="du ld le lf lg b">8080</code>。</p></blockquote><p id="884e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，您需要:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="b3d3" class="ju jv hi lg b fi ll lm l ln lo">google-chrome http://localhost:<strong class="lg hj">${PORT}</strong></span></pre><h2 id="5294" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">一次部署-部署</h2><p id="f553" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">一种非常常见的部署模式是前端和后端的结合，例如web服务器和数据库。一个反模式是捆绑前端和后端。前端和后端最好独立扩展。我们将在本文的剩余部分使用这种前端-后端配置，从一个部署对一个部署开始。</p><p id="1d1d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更准确地说，一个部署中的pod访问代理由另一个部署创建的pod的服务；-)</p><p id="ede9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们之前创建了一个代理部署的服务。这个服务叫做<code class="du ld le lf lg b">knowingnode</code>。所以，让我们利用这一点。我们将创建一个<code class="du ld le lf lg b">knowingnodes</code>(是的，相同的容器)的前端部署(使用前面提到的<code class="du ld le lf lg b">SERVICE_NAME</code>)来与我们现有的服务对话。</p><p id="5f10" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您还记得，服务在集群中是通过它们的<code class="du ld le lf lg b">[name].[namespace].svc.cluster.info</code>命名的(DNS ),可以缩写为<code class="du ld le lf lg b">[name].[namespace]</code>,而对于<code class="du ld le lf lg b">Default</code>命名空间，只需<code class="du ld le lf lg b">[name].</code></p><p id="dccb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们将调整我们的部署。因此:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="6ad7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这主要与之前的部署文件相同。它为<code class="du ld le lf lg b">SERVICE_NAME</code>指定了一个值，该值对应于我们之前创建的服务。我们已经更改了此部署的标签。对于部署本身和它将管理的单元都是如此。我们需要确保此部署的选择器与这些pod匹配。我发现最简单的方法是将部署的标签复制到Pod的标签上，从而复制选择器的标签。</p><p id="7ba2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您愿意，可以为此部署创建一个服务。为了简单起见，我将移植到单个Pod:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="0cd6" class="ju jv hi lg b fi ll lm l ln lo">POD=$(kubectl get pod \<br/>--selector=<strong class="lg hj">component=frontend,controlling=deployment</strong> \<br/>--output=jsonpath="{ .items[0].metadata.name }") &amp;&amp; echo ${POD}</span><span id="be14" class="ju jv hi lg b fi mk lm l ln lo">kubectl port-forward ${POD} 8080:8080</span></pre><p id="df92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后浏览端点。如果您使用Pod端口转发，我们将返回到<code class="du ld le lf lg b">8080</code>。除非您选择了不同的本地端口。</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="7a5e" class="ju jv hi lg b fi ll lm l ln lo">google-chrome http://localhost:8080<strong class="lg hj">/hostz</strong></span></pre><p id="c909" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们正在查看<code class="du ld le lf lg b">/hostz</code>端点。这个端点背后的代码对端点<code class="du ld le lf lg b">${SERVICE_NAME}</code>和<code class="du ld le lf lg b">GET</code>进行通用DNS查找。我们的前端服务正在调用我们的后端服务:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ml"><img src="../Images/27a35ff01794506cfed3fa1fa854d6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*QZaVEKOHSNMkcBEm1guRrQ.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">一切都好！</figcaption></figure><p id="2a0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成功！</p><h2 id="8432" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">一次部署-DaemonSet</h2><p id="90b8" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">您会记得DaemonSet与部署的不同之处在于，它为集群中的每个节点生成一个Pod。这使得我们可以直接通过节点来访问pod。让我们试试那个。首先是恶魔集:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="c8b6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我再次注意避免命名和(更重要的)标签冲突，我们在这里使用了<code class="du ld le lf lg b">knowingnode<strong class="iz hj">d</strong></code>。但是，请注意添加了一个ports部分并包含了一个<code class="du ld le lf lg b">hostPort</code>值(与我们的<code class="du ld le lf lg b">containerPort</code>相匹配)。</p><p id="dd46" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通常不会期望Kubernetes集群的节点在端口<code class="du ld le lf lg b">8080</code>上公开容器。它融合了吗？让我们随机选择一个节点，然后浏览它的端口<code class="du ld le lf lg b">8080</code>。</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="77ec" class="ju jv hi lg b fi ll lm l ln lo">NODE=$(shuf \<br/>--head-count=1 \<br/>--echo $(\<br/>  kubectl get nodes \<br/>  --output=jsonpath="{.items[*].metadata.name}")\<br/>) &amp;&amp; echo ${NODE}</span></pre><p id="fb62" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后端口转发给它:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="5e1d" class="ju jv hi lg b fi ll lm l ln lo">gcloud compute ssh ${NODE} \<br/>--ssh-flag="-L 8080:localhost:<strong class="lg hj">8080</strong>" \<br/>--project=${PROJECT}</span></pre><blockquote class="mb mc md"><p id="cd5c" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>这一次，我们没有在节点上使用节点端口。</p></blockquote><p id="2fbf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="39ce" class="ju jv hi lg b fi ll lm l ln lo">google-chrome http://localhost:<strong class="lg hj">8080</strong></span></pre><p id="624d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mm"><img src="../Images/f90670419a0bf2c097b1a607a2e59e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*gxA0Puo6AlXFkmxdh2KEeg.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">通过节点访问DaemonSet Pod</figcaption></figure><blockquote class="mb mc md"><p id="894e" class="ix iy me iz b ja jb ij jc jd je im jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><strong class="iz hj">NB</strong>Pod是knowingnoded，这证明我们正在攻击DaemonSet的一个Pod，我们正在通过节点的(！)端口。</p></blockquote><p id="c64e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，您不太可能构建一个配置，其中一个Kubernetes控制器的pod访问由DaemonSet控制的pod。守护进程通常用于提供特定于主机的功能，例如审计、安全、监控和日志记录。然而，我们可以将无头服务应用于DaemonSet。</p><p id="1670" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们这样做，然后修改我们的前端指向它。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="f031" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们想要一个修改过的前端部署，不再让<code class="du ld le lf lg b">SERVICE_NAME</code>指向<code class="du ld le lf lg b">knowingnode</code>服务，而是指向<code class="du ld le lf lg b">knowingnoded</code>服务。为了确保我们标记的东西是正确的，我们还将修改标签<code class="du ld le lf lg b">controlling</code>的值为<code class="du ld le lf lg b">daemonset</code>。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="3150" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后随机抓取一个Pod并将其转接到端口:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="244a" class="ju jv hi lg b fi ll lm l ln lo">POD=$(kubectl get pod \<br/>--selector=component=frontend,<strong class="lg hj">controlling=daemonset</strong> \<br/>--output=jsonpath="{ .items[0].metadata.name }") &amp;&amp; echo ${POD}</span><span id="9302" class="ju jv hi lg b fi mk lm l ln lo">kubectl port-forward ${POD} 8080:8080</span></pre><p id="fdaf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，如果我们这次浏览<code class="du ld le lf lg b">/hostz</code>端点，前端将解析为DaemonSet中3个pod的DNS名称，而不是接收VIP的DNS名称:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es mn"><img src="../Images/68323fa6fdcc3121cdb3907faa5a2c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lnpd2EYx6Qeu4M5I6oWPag.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">无头服务的DNS SRV解析</figcaption></figure><p id="8644" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成功！</p><h2 id="f87f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">一个部署状态集</h2><p id="cc67" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">好了，我们快到了。我们感兴趣的最后一种控制器是StatefulSets。这些包括由应用于其名称的计数器区分的pod，它们在死亡时以相同的名称(和DNS名称)等重新创建。，并将被映射回同一个永久存储器。状态集与定义其命名的服务定义成对出现</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="188e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">状态集的一个前提是每个Pod都是“独特的”。StatesfulSet的一个常见用途是托管数据库碎片。在这样的场景中，我们希望客户端被映射到同一个碎片上，这通常是通过散列一些客户端属性来将其映射到一组碎片上实现的。</p><p id="8bb6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">理想情况下，我们此时要做的是选择StatefulSet Pods，并配置前端始终指向它。我们可以寻址一个特定的Pod，因为我们能够预先确定它的DNS名称。该名称采用<code class="du ld le lf lg b">[name]-x.[serviceName]</code>的形式。</p><p id="a557" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，我想得不够远。虽然Kubernetes为StatefulSet中的每个Pod创建了一个DNS名称(与其他控制器不同)，但是Golang示例假定这些名称是作为SRV记录创建的，并且因为这些是Pod，所以它们不是作为SRV记录创建的。因此，我将配置前端来调用StatefulSet的端点，并希望您相信我的话，对于除SRV解析之外的所有内容，您都能够指向特定的Pod。</p><p id="0f47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将创建最终部署:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="e241" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们将抓住它的一个吊舱和港口前进:</p><pre class="kw kx ky kz fd lh lg li lj aw lk bi"><span id="2525" class="ju jv hi lg b fi ll lm l ln lo">POD=$(kubectl get pod \<br/>--selector=component=frontend,<strong class="lg hj">controlling=statefulset</strong> \<br/>--output=jsonpath="{ .items[0].metadata.name }") &amp;&amp; echo ${POD}</span><span id="80ce" class="ju jv hi lg b fi mk lm l ln lo">kubectl port-forward ${POD} 8080:8080</span></pre><p id="8086" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mo"><img src="../Images/0f2600763b3c775bc88ecaed1e8ef4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*rmmeMFd143OCongDd97PYQ.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">状态集中的每个Pod都有自己的DNS名称</figcaption></figure><p id="eb7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成功了！</p><h2 id="43b9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论</h2><p id="87a2" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">一旦您可以将部署绑定到Kubernetes中的服务，递归链意味着您可以构建任何配置。在前面故事的简短扩展中，我们展示了如何将集群中的“服务”(部署)连接到其他集群服务，无论这些服务是部署、守护集还是状态集。</p><p id="8df2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>