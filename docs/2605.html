<html>
<head>
<title>Automated Sync among GCP secrets &amp; GKE workload</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP机密和GKE工作负载之间的自动同步</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/automated-sync-among-gcp-secrets-gke-workload-4797913576f2?source=collection_archive---------0-----------------------#2022-12-09">https://medium.com/google-cloud/automated-sync-among-gcp-secrets-gke-workload-4797913576f2?source=collection_archive---------0-----------------------#2022-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5a03485c4b505e0609c4ee45553975d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeEVXdopjA8k8GjmLXMlxA.png"/></div></div></figure><p id="229f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将使用<strong class="is hj">外部秘密操作符</strong>集成GCP秘密管理器和GKE(K8s)秘密，这是一个开源的K8s操作符。<br/>我们还将涉及一个非常重要的需求，在使用K8s及其秘密时，我们可能至少会遇到一次，每当我们更新Kubernetes中作为环境变量传递的秘密时，我们都需要重启pod以获取更改。我们将通过使用名为<strong class="is hj"> Reloader的控制器来解决这个问题。</strong></p><p id="dd11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">执行步骤:</strong></p><p id="8e1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要求1:将GCP秘密管理器整合到K8s秘密中</p><p id="894d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。1.</strong>创建新的私有GKE集群<br/> <strong class="is hj"> 1。2.</strong>在<strong class="is hj"> GCP秘密管理器<br/> 1中创建一个秘密。3.</strong>在GKE集群<br/> <strong class="is hj"> 1上启用<strong class="is hj">工作负载标识</strong>。4.</strong>使用<br/> <strong class="is hj"> 1舵安装外部秘密操作器。5.</strong>部署清单文件<br/>T24】1。6.验证</p><p id="77c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要求2:秘密更新时滚动升级</p><p id="c02a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。1.</strong> Stakater <strong class="is hj"> </strong>重装器安装<br/> <strong class="is hj"> 2。2.</strong>更新清单文件以使用stakater reloader注释<br/> <strong class="is hj"> 2。3.</strong>验证</p><p id="a9fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们试着详细理解这两个要求。</p><h2 id="29c0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">要求1:将GCP秘笈管理器整合到K8s秘笈</strong></h2><p id="0191" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我们需要储存在GCP秘密管理中的秘密在GKE舱中使用。为了完成这个要求，我们将使用<strong class="is hj">外部秘密操作符。</strong>那么是什么呢？如何实施？下面是答案…来看看吧！！</p><p id="3a44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">外部秘密运营商</strong>是一个Kubernetes运营商，集成了外部秘密管理系统，如<a class="ae ko" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank"> AWS Secrets Manager </a>、<a class="ae ko" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> HashiCorp Vault </a>、<a class="ae ko" href="https://cloud.google.com/secret-manager" rel="noopener ugc nofollow" target="_blank"> Google Secrets Manager </a>、<a class="ae ko" href="https://azure.microsoft.com/en-us/services/key-vault/" rel="noopener ugc nofollow" target="_blank"> Azure Key Vault </a>、<a class="ae ko" href="https://www.ibm.com/cloud/secrets-manager" rel="noopener ugc nofollow" target="_blank"> IBM Cloud Secrets Manager </a>等等。操作员从外部API读取信息，并自动将值注入到一个<a class="ae ko" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes秘密</a>中。</p><p id="467c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ESO是自定义API资源的集合——external secret、SecretStore和ClusterSecretStore，它们为存储和管理机密生命周期的外部API提供了用户友好的抽象。</p><p id="c4c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经理解了我们的第一个要求，让我们来完成它。<br/>我们将从我们需要的<strong class="is hj">先决条件</strong>开始:-</p><p id="0e7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。1.创建新的私有GKE集群</strong> <br/>使用下面的gcloud命令创建集群并获取其凭证。</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="3b5b" class="ky jp hi ku b be kz la l lb lc">$ gcloud container clusters create dev-private-cluster-01 \<br/> --network &lt;vpc-name&gt;\<br/> --subnetwork &lt;subnet-name&gt; \<br/> --cluster-secondary-range-name &lt;cluster-secondary-range-name&gt; \<br/> --services-secondary-range-name &lt;services-secondary-range-name&gt; \<br/> --enable-private-nodes \<br/> --enable-ip-alias \<br/> --master-ipv4-cidr 172.16.0.16/28 \<br/> --enable-master-global-access - zone us-central1-b --num-nodes=1 --project=&lt;PROJECT_ID&gt; \<br/> --no-enable-master-authorized-networks --workload-pool=PROJECT_ID.svc.id.goog</span></pre><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/63bd6ad2fbee5b6c9ebb755260d29b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sh2dEwIqdpCe7J1M7UX_Eg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jq">确保在GKE集群上启用工作负载标识</strong></figcaption></figure><p id="1fde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取群集的凭据:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="2956" class="ky jp hi ku b be kz la l lb lc">$ gcloud container clusters get-credentials CLUSTER_NAME</span></pre><p id="bb9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将CLUSTER_NAME替换为启用了工作负载标识的集群的名称。<br/>确保您已经配置了提供传出连接的云NAT。<br/>更多详情请查看云NAT:<br/><a class="ae ko" href="https://cloud.google.com/nat/docs/overview" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/nat/docs/overview</a></p><p id="efd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。2.在GCP秘密管理器中创建一个秘密<br/> </strong>从控制台创建秘密，我们需要通过我们在GKE内部运行的pod来访问它。以下是一些快照…</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/a702a59caad972dee853e318451ce01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSP7lJEuW_-EQQKndUbPFg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jq">点击创建密码按钮</strong></figcaption></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/880b9f93bb153a25c563069bb830270f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nKsAjWia48pI58dh"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jq">填写秘密的细节</strong></figcaption></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/09c184ada4c2eb60f04aeb9dcd8faacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OPvQeF6q3flikVDDSLsxw.png"/></div></div></figure><p id="33fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:-我们将在后面的步骤中通过进入GKE pod来验证秘密的值，因为现在我们有一个样本值“样本-秘密-值”。</p><p id="2763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们已经准备好集群和GCP机密，我们将继续安装ESO，并部署一些工作负载来访问机密。</p><p id="ec4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。3.在GKE集群上启用工作负载标识</strong></p><p id="0dde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在您的Google Kubernetes引擎(GKE)集群上启用和配置工作负载标识。工作负载身份允许GKE集群中的工作负载模拟身份和访问管理(IAM)服务帐户来访问Google云服务。要了解更多关于工作负载标识的工作原理，请参见<a class="ae ko" href="https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity" rel="noopener ugc nofollow" target="_blank">工作负载标识</a>。</p><p id="362c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GKE豆荚将需要访问我们的GCP秘密经理，并与此服务认证，我们将使用WKI。注意，在我们的例子中，我们已经在初始集群创建命令中处理了这一点，现在让我们来配置它。</p><p id="5b93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">配置工作负载标识</strong></p><p id="b2bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下步骤向您展示了如何配置您的应用程序以使用工作负载标识(如果在集群上启用了工作负载标识)。</p><p id="9457" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个用于Kubernetes服务帐户的名称空间。您也可以使用默认的名称空间或任何现有的名称空间。</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="0ba5" class="ky jp hi ku b be kz la l lb lc">$ kubectl create namespace NAMESPACE</span></pre><p id="8070" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个Kubernetes服务帐户供您的应用程序使用。您还可以在默认或任何现有的名称空间中使用默认的Kubernetes服务帐户。</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="1ce1" class="ky jp hi ku b be kz la l lb lc">$ kubectl create serviceaccount KSA_NAME \<br/> --namespace NAMESPACE</span></pre><p id="07f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">替换以下内容:</p><p id="3fba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">KSA _姓名:您的新Kubernetes服务帐户的名称。(workload-identity-ksa) <br/>名称空间:服务帐户的Kubernetes名称空间的名称。(开发)</p><p id="a120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为您的应用程序创建一个IAM服务帐户，或者使用现有的IAM服务帐户。您可以在组织中的任何项目中使用任何IAM服务帐户。对于配置连接器，请为您选择的服务帐户应用IAMServiceAccount对象。</p><p id="e0f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用gcloud CLI创建新的IAM服务帐户，请运行以下命令。</p><p id="2845" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll">注意:如果您在gcloud CLI中使用现有的IAM服务帐户，请跳过这一步。</em></p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="3e90" class="ky jp hi ku b be kz la l lb lc">$ gcloud iam service-accounts create GSA_NAME \<br/> --project=GSA_PROJECT</span></pre><p id="b5e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">替换以下内容:</p><p id="a76d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GSA_NAME:新IAM服务帐户的名称。<br/> GSA_PROJECT:您的IAM服务帐户的Google Cloud项目的项目ID。</p><p id="a979" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关授权IAM服务帐户访问Google Cloud APIs的信息，请参见<a class="ae ko" href="https://cloud.google.com/iam/docs/understanding-service-accounts" rel="noopener ugc nofollow" target="_blank">了解服务帐户</a>。</p><p id="523c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保您的IAM服务帐户具有所需的角色。您可以使用以下命令授予其他角色:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="7712" class="ky jp hi ku b be kz la l lb lc">$ gcloud projects add-iam-policy-binding PROJECT_ID \<br/> --member "serviceAccount:GSA_NAME@GSA_PROJECT.iam.gserviceaccount.com" \<br/> --role "ROLE_NAME"</span></pre><p id="873d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">替换以下内容:</p><p id="c06b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PROJECT_ID:您的Google Cloud项目ID。GSA_NAME:您的IAM服务帐户的名称。<br/> GSA_PROJECT:您的IAM服务帐户的Google Cloud项目的项目ID。<br/> ROLE_NAME:分配给你的服务帐户的IAM角色，如roles/spanner.viewer. <br/>确保服务帐户有<strong class="is hj">roles/secret manager . secret accessor</strong>从GCP秘密管理器获取秘密。</p><p id="70b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过在两个服务帐户之间添加IAM策略绑定，允许Kubernetes服务帐户模拟IAM服务帐户。这个绑定允许Kubernetes服务帐户充当IAM服务帐户。</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="79f2" class="ky jp hi ku b be kz la l lb lc">$ gcloud iam service-accounts add-iam-policy-binding GSA_NAME@GSA_PROJECT.iam.gserviceaccount.com \<br/> --role roles/iam.workloadIdentityUser \<br/> --member "serviceAccount:PROJECT_ID.svc.id.goog[NAMESPACE/KSA_NAME]"</span></pre><p id="4afa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用IAM服务帐户的电子邮件地址注释Kubernetes服务帐户。</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="1c60" class="ky jp hi ku b be kz la l lb lc">$ kubectl annotate serviceaccount KSA_NAME \<br/> --namespace NAMESPACE \<br/>iam.gke.io/gcp-service-account=GSA_NAME@GSA_PROJECT.iam.gserviceaccount.com</span></pre><p id="4480" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。4.使用舵安装外部秘密操作器</strong></p><p id="4532" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是安装ESO的舵命令。</p><p id="ec6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll">注意:-要自动安装和管理CRDs作为您的舵版本的一部分，您必须在您的舵安装命令中添加set installCRDs = true标志。</em></p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="2173" class="ky jp hi ku b be kz la l lb lc">$ helm repo add external-secrets https://charts.external-secrets.io</span></pre><pre class="lm kt ku kv bn kw kx bi"><span id="396b" class="ky jp hi ku b be kz la l lb lc">$ helm install external-secrets \<br/>external-secrets/external-secrets \<br/>-n external-secrets --create-namespace \<br/>--set installCRDs=true</span></pre><p id="7eef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经配置了WKI，安装了外部机密让我们了解我们将在哪里使用它。当我们开始与外部秘密运营商合作时，我们有两个主要组件，一个是<strong class="is hj"> SecretStore </strong>，另一个是<strong class="is hj">外部秘密</strong>。这两个是K8s中的对象类型，属于API version<em class="ll">external-secrets.io/vebeta1.<br/></em>我们将研究它们中的每一个，并同时配置它们。</p><p id="a501" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。5.部署清单文件</strong></p><h2 id="b2ee" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">秘密商店</h2><p id="5340" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated"><a class="ae ko" href="https://external-secrets.io/v0.7.0-rc1/api/secretstore/" rel="noopener ugc nofollow" target="_blank"> SecretStore </a>资源背后的理念是将身份验证/访问与工作负载所需的实际秘密和配置分开。ExternalSecret指定获取什么，SecretStore指定如何访问。这个资源是有名称空间的。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">SecretStore.yaml</figcaption></figure><p id="4bf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用以下命令部署秘密存储:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="f457" class="ky jp hi ku b be kz la l lb lc">$ kubectl apply -f SecretStore.yaml</span></pre><h2 id="a6d9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">外部保密</h2><p id="1eb2" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">一个<a class="ae ko" href="https://external-secrets.io/v0.7.0-rc1/api/externalsecret/" rel="noopener ugc nofollow" target="_blank"> ExternalSecret </a>声明获取什么数据。它引用了一个知道如何访问数据的SecretStore。控制器使用该外部秘密作为创建秘密的蓝图。</p><p id="d6a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">External-secrets作为部署资源在Kubernetes集群中运行。它利用CustomResourceDefinitions来配置通过SecretStore资源对secret提供者的访问，并使用ExternalSecret资源管理Kubernetes secret资源。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">外部秘密. yaml</figcaption></figure><p id="7e0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用以下命令创建ExternalSecret:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="e283" class="ky jp hi ku b be kz la l lb lc">$ kubectl apply -f ExternalSecret.yaml</span></pre><p id="ccb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建后，确保外部机密处于机密同步和就绪状态:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="dfba" class="ky jp hi ku b be kz la l lb lc">$ kubectl get externalsecret -n dev</span></pre><p id="06ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll">注意:ExternalSecret的工作是创建名为workload-secret的秘密，其密钥为k8s中的</em><strong class="is hj"><em class="ll">k8s-secret-key-test secret</em></strong><em class="ll">，引用名为</em><strong class="is hj"><em class="ll">GCP-secret-key-test secret。</em> </strong> <em class="ll"> <br/>是时候将秘密传递给我们的pod，并验证存储在GCP秘密管理器中的秘密是否被正确地反映给GKE pod了。</em></p><p id="b74a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是示例部署文件:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">deployment.yaml文件</figcaption></figure><p id="9026" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过执行以下命令，在dev名称空间中创建名为myapp的示例部署，并使用nginx映像:<br/> <em class="ll">注意</em>:我们将秘密作为名为WORKLOAD_SA的环境变量进行传递。</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="1d34" class="ky jp hi ku b be kz la l lb lc">$ kubectl apply -f deploy.yaml</span></pre><p id="6b8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。6.验证</strong> <br/>通过执行以下命令来验证秘密数据，该命令应与我们的GCP秘密值(即样本秘密值)相匹配:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="5627" class="ky jp hi ku b be kz la l lb lc">$ kubectl get secret workload-secret -n dev -o jsonpath='{.data.testsecret}' | base64 -d</span></pre><p id="88e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们知道，秘密可以作为数据卷挂载，或者作为环境变量公开，供Pod中的容器使用。</p><p id="5e1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我们将秘密值存储在ENV变量WORKLOAD_SA中，让我们使用以下命令验证我们新创建的pod是否具有GCP秘密值:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="76f0" class="ky jp hi ku b be kz la l lb lc">$ kubectl get pod -n dev<br/>$ kubectl exec -i -t myapp-7d579d9894-zgwxc -n dev -- /bin/sh -c 'echo $WORKLOAD_SA'</span></pre><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/ff83a0a22e4ace63981d1cd987c501b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIAmaqF3yXh2me5XivD-Sg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">kubectl命令输出</figcaption></figure><p id="dfda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ll">耶！！我们已经成功地实现了我们的第一个要求。听起来不错吧？。没时间停下了，伙计！！…让我们也理解我们的第二个目标，然后我们也将着手实现它。</em></strong></p><h2 id="fc32" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">需求2:秘密更新时滚动升级</strong></h2><p id="944c" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">至此，我们已经成功地将GCP秘密管理器与GKE (K8s)秘密集成在一起，但是如果有人更新了GCP秘密管理器中的秘密呢？pod会自动更新更改吗？不幸的是，没有。因为我们已经将密码作为环境变量传递，所以使更改生效的唯一方法是重启pod，这对于devops人员来说听起来不太好，因为如果我们有数百个pod需要在每次密码更新后重启，这是不可行的。有一些第三方解决方案可以在密码更改时触发重启。</p><p id="4c6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll">注意:使用密码作为子路径卷装载的容器不接收自动密码更新。</em></p><p id="8392" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用的解决方案是<strong class="is hj">重装器</strong></p><h2 id="16eb" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">斯塔卡特重装机</h2><p id="1a3c" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">重新加载器可以监视配置图和密码中的更改，并对pod及其相关的部署配置、部署、守护程序集、状态集和部署进行滚动升级。</p><p id="60ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，重新加载器部署在默认命名空间中，并监视所有命名空间中的机密和配置映射的更改。</p><p id="6168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。1.您可以从我们的公共图表库中添加一个重装程序到helm，并使用下面提到的命令通过helm部署它。</strong></p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="4177" class="ky jp hi ku b be kz la l lb lc">$ helm repo add stakater https://stakater.github.io/stakater-charts</span></pre><pre class="lm kt ku kv bn kw kx bi"><span id="2208" class="ky jp hi ku b be kz la l lb lc">$ helm repo update</span></pre><pre class="lm kt ku kv bn kw kx bi"><span id="deb7" class="ky jp hi ku b be kz la l lb lc">$ helm install reloader stakater/reloader # For helm3 add - generate-name flag or set the release name</span></pre><p id="1a08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要仅在特定机密发生更改时执行滚动升级，请使用下面的批注。</p><p id="fcbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。2.更新清单文件以使用stakater reloader注释</strong></p><p id="8d9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于一个名为myapp的部署，我们在前面的步骤中创建了一个名为workload-secret的秘密，然后将这个注释更新到您的部署的主元数据:-</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="eaca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用逗号分隔的列表来定义多个机密。</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="430a" class="ky jp hi ku b be kz la l lb lc">kind: Deployment<br/>metadata:<br/>annotations:<br/>secret.reloader.stakater.com/reload: "foo-secret,bar-secret,baz-secret"<br/>spec:<br/>template:<br/>metadata:</span></pre><p id="e067" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且在修改任何像这样注释的配置映射或秘密(在我们的例子中是Externalsecret)时，重新加载器将触发滚动升级:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="cbfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll"> refreshInterval: 1m - </em>这样会每一分钟刷新一次秘笈。你可以按照你的要求保存时间。</p><p id="b5ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用以下命令更新部署和外部密码值:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="5df5" class="ky jp hi ku b be kz la l lb lc">$ kubectl apply -f deploy_after_reloader.yaml<br/>$ kubectl apply -f ExternalSecret_reloader.yaml</span></pre><p id="7b79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。3.验证</strong> <br/>我们的秘密现在从GCP同步到了Kubernetes，让我们通过更新GCP控制台中的秘密值来验证。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/c9b0a7a07d2dbf6d21f120d0e71b82ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RaAk5K9uO1iKMwZs-wGk9A.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jq">点击+新版本</strong></figcaption></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/50926c1505938cfe9d379967bf10f397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzxAKDFsSDoqSQquNT-Rxw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jq">更新秘密值</strong></figcaption></figure><p id="74ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用以下命令验证pod已重新启动并且密码值已更新:</p><pre class="kp kq kr ks fd kt ku kv bn kw kx bi"><span id="99db" class="ky jp hi ku b be kz la l lb lc">$ kubectl get pod -n dev<br/>$ kubectl exec -i -t myapp-845ffcddc7–2bslz -n dev -- /bin/bash -c 'echo $WORLOAD_SA'</span></pre><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/09f96700acbe934ad87757b223a0452d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ghrp4pxdU9j8hOscMFoKPg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">输出</figcaption></figure><p id="2be7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ll">牛逼！！</em> </strong>我们已经成功更新了pod内的秘密，这些秘密是按照我们的第二个要求通过滚动升级从GCP秘密管理器作为环境变量挂载的。</p><p id="8b2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们实现了GCP机密和GKE工作负载之间的自动同步。</p><h2 id="54d3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">参考</h2><ul class=""><li id="84d3" class="lt lu hi is b it kj ix kk jb lv jf lw jj lx jn ly lz ma mb bi translated"><a class="ae ko" href="https://external-secrets.io/v0.7.0-rc1/" rel="noopener ugc nofollow" target="_blank">https://external-secrets.io/v0.7.0-rc1/</a></li><li id="af01" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated"><a class="ae ko" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/kubernetes-engine/docs/how-to/workload-identity</a></li><li id="7fcd" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated">https://github.com/stakater/Reloader<a class="ae ko" href="https://github.com/stakater/Reloader" rel="noopener ugc nofollow" target="_blank"/></li><li id="d9bc" class="lt lu hi is b it mc ix md jb me jf mf jj mg jn ly lz ma mb bi translated">【https://kubernetes.io/docs/concepts/configuration/secret/ T4】</li></ul><h2 id="72d2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">开源代码库</h2><p id="e7a8" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated"><a class="ae ko" href="https://github.com/prajaktashete7/External-Secrets-and-Reloader" rel="noopener ugc nofollow" target="_blank">https://github . com/prajaktashete 7/External-Secrets-and-Reloader</a></p><h2 id="5b57" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">有问题吗？</h2><p id="a1c6" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">如果你有任何问题，我很乐意在评论中阅读。在<a class="ae ko" rel="noopener" href="/@prajaktashete24">中</a>或<a class="ae ko" href="https://www.linkedin.com/in/prajakta-shete-075b511b5/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p></div></div>    
</body>
</html>