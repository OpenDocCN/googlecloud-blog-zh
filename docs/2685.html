<html>
<head>
<title>Configuring mTLS for Apigee X Southbound Traffic Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Apigee X南行流量配置mTLS</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/configuring-mtls-for-apigee-x-southbound-traffic-flow-eb91f381b60f?source=collection_archive---------3-----------------------#2022-12-27">https://medium.com/google-cloud/configuring-mtls-for-apigee-x-southbound-traffic-flow-eb91f381b60f?source=collection_archive---------3-----------------------#2022-12-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5b63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入研究mTLS之前，让我们先了解一下单向TLS是如何工作的。</p><h1 id="5223" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">单向TLS</h1><p id="abfa" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如图1所示，在单向传输层安全性(TLS)中只验证服务器的身份。首先，客户端向服务器发起一个会话请求。然后，服务器用其证书进行响应，客户端在开始与服务器传输数据之前验证该证书。要对证书进行身份验证，客户端可以向证书颁发机构(CA)请求验证，或者根据存储在其信任库中的证书验证证书(如果TLS服务器使用的是自签名证书或者不是由可信CA签名的证书)。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/84c68f437740142e78ff5ef764d2423e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtRTebkCMf22FzUt49r8oQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图1 .单向TLS握手</figcaption></figure><p id="a48d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，Keystore(在服务器端)保存着TLS证书和私钥，用于在TLS握手过程中标识实体。另一方面，信任库(在客户端)包含用于验证TLS握手期间收到的证书的证书。</p><h1 id="2489" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">mTLS和TLS有什么不同？</h1><p id="b8df" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">mTLS (mutual TLS)是TLS(传输层安全性)协议的变体，它通过要求客户端和服务器在TLS握手过程中出示自己的TLS证书和密钥来提供增强的安全性。相反，在单向TLS中，只要求服务器提供其TLS证书和密钥，而不验证客户端的身份。</p><p id="e3a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在mTLS握手中，TLS服务器首先将其包含公钥的证书提供给TLS客户端。然后，客户端通过对照受信任的证书列表(如存储在信任库中的那些列表)检查证书来验证服务器的身份。一旦服务器的身份得到验证，客户端就向服务器出示自己的证书和公钥，以便通过身份验证。如果服务器验证了客户端的身份，数据传输就可以开始了。</p><p id="f0d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了客户端和服务器之间的mTLS握手过程。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kw"><img src="../Images/5d1bf699bae6e9398012b174de77bcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzr44Ita5Aueu7LfV4UviA.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图2 .相互TLS握手</figcaption></figure><p id="a367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使用mTLS进行相互身份验证，客户端和服务器都需要维护一个包含它们自己的TLS证书和私钥的密钥库。此外，如果用于身份验证的证书是自签名的，那么客户端和服务器都需要一个包含可信证书列表的信任库。</p><h1 id="45c5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Apigee X中的MTL</h1><p id="cfce" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在Apigee X中，对后端系统的任何请求(通过Apigee API代理)都可以分为两部分:用户对Apigee实例的请求，以及Apigee实例对后端系统的请求。下图显示了这一过程:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kx"><img src="../Images/8ff602d32fdcc7262e1da6a12f388ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zfUrp4GcCNfwbTFv"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图3 .顶点X中的最大允许长度</figcaption></figure><p id="6594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Apigee X的上下文中，术语“北向”是指客户端和Apigee实例之间的流量，而“南向”是指Apigee实例和代理后端之间的流量。可以为北向和南向流量流启用mTLS(本文仅涵盖南向mTLS的配置)；北向流量的mTLS配置目前需要在外部负载平衡器和Apigee运行时之间建立一个网桥(如<a class="ae ky" href="https://github.com/apigee/terraform-modules/tree/main/samples/x-l4xlb-mtls" rel="noopener ugc nofollow" target="_blank"> Envoy proxy </a>)。在外部负载平衡器[HTTP(s)]上实施的mTLS正在预览中。</p><p id="ef42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为南行请求启用mTLS允许Apigee实例和代理后端之间的安全通信，确保在传输数据之前验证双方的身份。</p><p id="dca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文将讨论如何在Apigee X中为南行请求配置mTLS。</p><h1 id="0b47" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">配置南行mTLS</h1><p id="cc90" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在Apigee中，南行mTLS可用于保护运行时实例(充当TLS客户端)与代理目标和后端(充当TLS服务器)之间的请求。Mutual TLS支持运行时实例和后端之间的相互认证，确保只有授权方才能访问API。</p><p id="c132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，借助一个例子，我们将演示如何使用Nginx服务器作为代理目标，在Apigee中启用南行mTLS。这个参考演示展示了OpenSSL证书的使用。你可以参考<a class="ae ky" href="https://www.ibm.com/docs/en/api-connect/10.0.1.x?topic=overview-generating-self-signed-certificate-using-openssl" rel="noopener ugc nofollow" target="_blank">这篇</a>来了解如何生成OpenSSL证书。</p><p id="63c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kz">顶点代理</em> </strong></p><p id="0d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看如何在Apigee代理级别配置mTLS。为此，我们需要对<em class="kz"> TargetEndpoint </em>配置进行更改，添加一个<em class="kz"> SSLInfo </em>块(示例配置如下所示),其中包含关于用于相互TLS握手的密钥库和信任库的信息。</p><pre class="kh ki kj kk fd la lb lc bn ld le bi"><span id="2fee" class="lf je hi lb b be lg lh l li lj">&lt;TargetEndpoint name="default"&gt;<br/>    &lt;PreFlow name="PreFlow"&gt;<br/>        &lt;Request/&gt;<br/>        &lt;Response/&gt;<br/>    &lt;/PreFlow&gt;<br/>    &lt;Flows/&gt;<br/>    &lt;PostFlow name="PostFlow"&gt;<br/>        &lt;Request/&gt;<br/>        &lt;Response/&gt;<br/>    &lt;/PostFlow&gt;<br/>    &lt;HTTPTargetConnection&gt;<br/>        &lt;URL&gt;https://nginx.example.com&lt;/URL&gt;<br/>        &lt;SSLInfo&gt;<br/>            &lt;Enabled&gt;true&lt;/Enabled&gt;<br/>            &lt;ClientAuthEnabled&gt;true&lt;/ClientAuthEnabled&gt;<br/>            &lt;KeyStore&gt;ref://ks-apigee-gateway-ref&lt;/KeyStore&gt;<br/>            &lt;KeyAlias&gt;ks-apigee-gateway-alias&lt;/KeyAlias&gt;<br/>            &lt;TrustStore&gt;ref://ts-apigee-gateway-ref&lt;/TrustStore&gt;<br/>            &lt;IgnoreValidationErrors&gt;false&lt;/IgnoreValidationErrors&gt;<br/>        &lt;/SSLInfo&gt;<br/>    &lt;/HTTPTargetConnection&gt;<br/>&lt;/TargetEndpoint&gt;</span></pre><p id="39bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看<sslinfo>块中需要添加的用于配置MTL的各种标签。</sslinfo></p><p id="906d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><enables>标签支持Apigee运行时实例和目标后端之间的单向TLS，而<clientauthenabled>标签支持双向TLS。<keystore>和<truststore>标记允许您指定用于相互TLS握手的密钥库和信任库，方法是直接提供密钥库和信任库的名称，或者使用对它们的引用。引用是包含密钥库或信任库名称的变量。首选方法是使用引用，这样，如果有一天您的证书在密钥库中过期，您只需更改引用以指向新的密钥库，如果您保持新密钥库的名称与以前的名称相同，则不需要在代理中进行任何更改。<keyalias>标记指定了将证书和私钥添加到密钥库中时分配给它们的别名。<ignorevalidationerrors>标记，如果设置为true，允许您忽略TLS证书错误。</ignorevalidationerrors></keyalias></truststore></keystore></clientauthenabled></enables></p><p id="99f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建信任库和密钥库，可以使用Apigee UI。</p><blockquote class="lk ll lm"><p id="c40f" class="if ig kz ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:在Apigee UI中，您只在Keystore部分下配置Keystore和Truststore。信任库是一个仅包含证书或证书链的密钥库。因此，每当您上传密钥库中的证书和密钥时，它将被用作密钥库，如果您只上传证书，它可以被用作信任库。此外，您不需要为信任库指定别名，因为它不用于存储私钥。请记住，每当您将证书和密钥上传到密钥库时，您都需要为它指定一个别名。</p></blockquote><p id="d384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kz">代理后端</em> </strong></p><p id="3c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了为后端服务启用mTLS，使用了一个默认接受所有HTTP请求的Nginx服务器。该服务器需要配置为侦听端口443，为此，必须创建一个密钥库。此外，配置mTLS需要一个信任库，因为本演示涉及使用OpenSSL的自签名证书生成pem和密钥文件。下面的代码片段应该添加到Nginx服务器的配置文件中，以启用mTLS。</p><pre class="kh ki kj kk fd la lb lc bn ld le bi"><span id="b216" class="lf je hi lb b be lg lh l li lj">server{<br/>        listen 443 ssl;<br/>        server_name nginx.payaljindal.com;<br/>        ssl_certificate /etc/nginx/client-certis/nginx_server.pem;<br/>        ssl_certificate_key /etc/nginx/client-certis/nginx_server.key;<br/>        ssl_client_certificate /etc/nginx/client-certis/RootCA.pem;<br/>        ssl_verify_client on;<br/>}</span></pre><p id="d806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在提供的代码中，密钥库由<em class="kz"> ssl_certificate </em>和<em class="kz"> ssl_certificate_key </em>组成。<em class="kz"> ssl_client_certificate </em>包含将用于验证由Apigee实例作为信任库发送的证书的证书。通过将ssl_verify_client设置为“on”来启用双向TLS。</p><blockquote class="lk ll lm"><p id="6758" class="if ig kz ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:如果您使用不同的目标后端，此配置可能会有所不同，但是我们上传的文件/证书将保持不变。</p></blockquote><p id="9dc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="kz">测试</em> </strong></p><p id="7acf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经完成了向Apigee代理及其后端添加信任库和密钥库配置的过程，我们可以继续测试设置了。</p><p id="39e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们需要在端口443上向Nginx服务器发送一个包含所有请求的证书。让我们尝试直接从浏览器点击端口443上的Nginx服务器，它给出如下所示的响应</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lq"><img src="../Images/07231f5a62b6732a56997660df52d223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5gjamD1-ftM5l-zN2ejuA.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图4 .从浏览器访问Nginx服务器</figcaption></figure><p id="ab7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">错误的原因是浏览器没有发送任何证书，但Nginx服务器需要一个证书，如错误消息“没有发送所需的SSL证书”所示。</p><p id="730f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果请求是从Apigee代理发送到Nginx服务器的，并且Nginx服务器是目标后端，那么它将按预期工作，因为Apigee代理已经配置为发送必要的证书，如下图所示。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lr"><img src="../Images/f9820cef9d024703e4d0a733714a5316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCufYywCZRgZUcOeANb7_w.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图5 .通过Apigee代理访问Nginx服务器</figcaption></figure><p id="3f2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以在顶点代理级别启用南行mTLS。希望这篇文章对你有帮助！</p><p id="be90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐学习！！</p></div></div>    
</body>
</html>