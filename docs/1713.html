<html>
<head>
<title>Day #8 with Cloud Workflows: calling an HTTP endpoint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云工作流的第8天:调用HTTP端点</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/day-8-with-cloud-workflows-calling-an-http-endpoint-2dfad3a7cffb?source=collection_archive---------0-----------------------#2020-12-15">https://medium.com/google-cloud/day-8-with-cloud-workflows-calling-an-http-endpoint-2dfad3a7cffb?source=collection_archive---------0-----------------------#2020-12-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="dd3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候做一些非常方便的事情了:从Google Cloud Workflows定义中调用HTTP端点。无论是调用特定于GCP的API(如ML APIs)、其他产品(如Cloud Firestore)的REST APIs，还是调用您自己的服务、第三方、外部API，此功能都可以让您将业务流程与外部世界相连接！</p><p id="11d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入下面的细节之前，让我们在下面的视频中看看如何调用HTTP端点:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="0e43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，当创建一个新的工作流定义时，会提供一个默认的片段/示例供您参考。在这篇文章中，我们将研究一下它。实际上有两个HTTP端点调用，后者依赖于前者:第一步(getCurrentTime)是一个返回星期几的云函数，而第二步(readWikipedia)在维基百科中搜索关于星期几的文章。</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="ab6f" class="jp jq hi jl b fi jr js l jt ju">- getCurrentTime:<br/>    call: http.get<br/>    args:<br/>        url: https://us-central1-workflowsample.cloudfunctions.net/datetime<br/>    result: CurrentDateTime</span></pre><p id="bac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">getCurrentTime步骤包含http.get类型的call属性，用于向API端点发出HTTP GET请求。您可以调用:http.get或call: http.post。对于其他方法，您必须调用:http.request，并在args下添加另一个键/值对，使用方法:GET、POST、PATCH或DELETE。现在，在args下，我们只放HTTP端点的URL。最后一个键将是结果，它给出了一个新变量的名称，该变量将包含我们的HTTP请求的响应。</p><p id="1517" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用我们的星期几搜索查询打电话给维基百科:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="4a8d" class="jp jq hi jl b fi jr js l jt ju">- readWikipedia:<br/>    call: http.get<br/>    args:<br/>        url: <a class="ae jv" href="https://en.wikipedia.org/w/api.php" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/w/api.php</a><br/>        query:<br/>            action: opensearch<br/>            search: ${CurrentDateTime.body.dayOfTheWeek}<br/>    result: WikiResult</span></pre><p id="54a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">call和args.url也是如此，但是，我们有一个查询，您可以在其中为Wikipedia API定义查询参数。还要注意我们如何传递来自上一步函数调用的数据:current date time . body . day oftheweek。我们检索前一个调用的响应体，并从那里获得结果JSON文档中的dayOfTheWeek键。然后我们返回WikiResult，这是新API端点调用的响应。</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="2de6" class="jp jq hi jl b fi jr js l jt ju">- returnOutput:<br/>    return: ${WikiResult.body[1]}</span></pre><p id="218b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，最后一步是返回我们搜索的结果。我们检索响应的主体。响应的主体是一个数组，第一项是搜索查询，第二项是下面的文档名称数组，这是我们的工作流执行将返回的内容:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="ffb1" class="jp jq hi jl b fi jr js l jt ju">[<br/>  "Monday",<br/>  "Monday Night Football",<br/>  "Monday Night Wars",<br/>  "Monday Night Countdown",<br/>  "Monday Morning (newsletter)",<br/>  "Monday Night Golf",<br/>  "Monday Mornings",<br/>  "Monday (The X-Files)",<br/>  "Monday's Child",<br/>  "Monday.com"<br/>]</span></pre><p id="1873" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们的整个工作流能够一个接一个地编排两个独立的API端点。云工作流不是有两个API通过某种消息传递机制耦合在一起，或者更糟，通过显式调用一个或另一个，而是在这里组织这两个调用。这是一种编排方法，而不是服务的编排(参见我之前关于<a class="ae jv" href="https://glaforge.appspot.com/article/orchestrating-microservices-with-cloud-workflows" rel="noopener ugc nofollow" target="_blank">编排与编排</a>的文章，以及我同事关于<a class="ae jv" href="https://cloud.google.com/blog/topics/developers-practitioners/better-service-orchestration-workflows" rel="noopener ugc nofollow" target="_blank">利用云工作流实现更好的服务编排</a>的文章)。</p><p id="e344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到API端点调用的细节，下面是它们的结构:</p><pre class="jd je jf jg fd jk jl jm jn aw jo bi"><span id="850f" class="jp jq hi jl b fi jr js l jt ju">- STEP_NAME:<br/>    call: {http.get|http.post|http.request}<br/>    args:<br/>        url: URL_VALUE<br/>        [method: REQUEST_METHOD]<br/>        [headers:<br/>            KEY:VALUE ...]<br/>        [body:<br/>            KEY:VALUE ...]<br/>        [query:<br/>            KEY:VALUE ...]<br/>        [auth:<br/>            type:{OIDC|OAuth2}]<br/>        [timeout: VALUE_IN_SECONDS]<br/>    [result: RESPONSE_VALUE]</span></pre><p id="c3a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了URL、方法和查询之外，请注意，您还可以传递头和主体。还有一个与GCP API一起工作的内置认证机制:认证是透明完成的。如果您希望快速失败，而不是永远等待永远不会到来的响应，您也可以指定以秒为单位的超时。但是，在我们即将发表的一些文章中，我们将回头讨论错误处理。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="bf5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【http://glaforge.appspot.com】最初发表于<a class="ae jv" href="http://glaforge.appspot.com/article/day-8-with-cloud-workflows-calling-an-http-endpoint" rel="noopener ugc nofollow" target="_blank"><em class="kd"/></a><em class="kd">。</em></p></div></div>    
</body>
</html>