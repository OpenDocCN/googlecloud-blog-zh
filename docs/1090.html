<html>
<head>
<title>BigQuery Surrogate Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery代理键</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-surrogate-keys-672b2e110f80?source=collection_archive---------0-----------------------#2019-07-24">https://medium.com/google-cloud/bigquery-surrogate-keys-672b2e110f80?source=collection_archive---------0-----------------------#2019-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9a9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Surrogate_key" rel="noopener ugc nofollow" target="_blank">代理键</a>是传统数据仓库中常见的概念，但在BigData中并不常见。生成一个连续递增的数字是很难并行化的，替代方法，如HASH或CONCAT，可以提供类似的唯一标识符。</p><p id="e08f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用以下模式探索BigQuery中的一个特定场景:</p><ul class=""><li id="cca2" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">三个键(key1、key2、key3)和创建代理键(id)的需要。</li><li id="64a0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">带有预分配代理键的传入数据和现有数据。</li></ul><p id="482c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:您需要在项目中创建<strong class="ih hj">代理键</strong>作为数据集，以便SQL运行。</p><h1 id="92d4" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建测试数据</h1><h2 id="9db3" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">输入数据</h2><p id="a3d2" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">用(key1，key2，key3)和数据创建一个表<strong class="ih hj">。这将具有与现有代理键部分匹配的键分布。</strong></p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="ffff" class="kq jt hi lo b fi ls lt l lu lv">CREATE OR REPLACE TABLE `surrogatekey.incoming_data` AS<br/>SELECT<br/>  -- Actual keys; need a synthetic key<br/>  CAST(k1 AS STRING) AS key1,<br/>  CAST(k2 AS STRING) AS key2,<br/>  CAST(k3 AS STRING) AS key3,</span><span id="a5dc" class="kq jt hi lo b fi lw lt l lu lv">  -- Data<br/>  CAST(FLOOR(1000 * RAND()) AS STRING) AS col1,<br/>  CAST(FLOOR(1000 * RAND()) AS STRING) AS col2,<br/>  'x' AS col3,<br/>  'y' AS col4<br/>FROM<br/>  UNNEST(GENERATE_ARRAY(5, 20)) k1<br/>  CROSS JOIN UNNEST(GENERATE_ARRAY(5, 20)) k2<br/>  CROSS JOIN UNNEST(GENERATE_ARRAY(5, 20)) k3;</span></pre><h2 id="9b4f" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">现有数据—增加</h2><p id="d265" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">创建一个已有预分配(递增)代理键的现有数据表。这将部分匹配输入的数据。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="f5f7" class="kq jt hi lo b fi ls lt l lu lv">CREATE OR REPLACE TABLE `surrogatekey.existing_data` AS<br/>SELECT<br/>  -- Existing surrogate<br/>  k3+(k2*10)+(k1*100) AS id,</span><span id="1c53" class="kq jt hi lo b fi lw lt l lu lv">  -- Actual keys; need a synthetic key<br/>  CAST(k1 AS STRING) AS key1,<br/>  CAST(k2 AS STRING) AS key2,<br/>  CAST(k3 AS STRING) AS key3,</span><span id="1b89" class="kq jt hi lo b fi lw lt l lu lv">  -- Data<br/>  CAST(FLOOR(1000 * RAND()) AS STRING) AS col1,<br/>  CAST(FLOOR(1000 * RAND()) AS STRING) AS col2,<br/>  'x' AS col3,<br/>  'y' AS col4<br/>FROM<br/>  UNNEST(GENERATE_ARRAY(1, 10)) k1<br/>  CROSS JOIN UNNEST(GENERATE_ARRAY(1, 10)) k2<br/>  CROSS JOIN UNNEST(GENERATE_ARRAY(1, 10)) k3;</span></pre><h2 id="c98f" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">现有数据—哈希</h2><p id="63ba" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">创建一个现有的数据表<strong class="ih hj">surrogate key . existing _ data _ hash</strong>，但是，这一次，创建一个HASH。这将获取结构中的键(key1，key2，key3)，使用TO_JSON_STRING将其转换为一个单独的字符串和FARM_FINGERPRINT。这将产生一个INT64值，冲突几率极低。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="677c" class="kq jt hi lo b fi ls lt l lu lv">CREATE OR REPLACE TABLE `surrogatekey.existing_data_hash` AS<br/>SELECT<br/>  -- Existing surrogate is a HASH<br/>  FARM_FINGERPRINT(TO_JSON_STRING(STRUCT(<br/>      CAST(k1 AS STRING),<br/>      CAST(k2 AS STRING),<br/>      CAST(k3 AS STRING)<br/>  ))) AS id,</span><span id="efaf" class="kq jt hi lo b fi lw lt l lu lv">  -- Actual keys<br/>  CAST(k1 AS STRING) AS key1,<br/>  CAST(k2 AS STRING) AS key2,<br/>  CAST(k3 AS STRING) AS key3,</span><span id="212e" class="kq jt hi lo b fi lw lt l lu lv">  -- Data<br/>  CAST(FLOOR(1000 * RAND()) AS STRING) AS col1,<br/>  CAST(FLOOR(1000 * RAND()) AS STRING) AS col2,<br/>  'x' AS col3,<br/>  'y' AS col4<br/>FROM<br/>  UNNEST(GENERATE_ARRAY(1, 10)) k1<br/>  CROSS JOIN UNNEST(GENERATE_ARRAY(1, 10)) k2<br/>  CROSS JOIN UNNEST(GENERATE_ARRAY(1, 10)) k3;</span></pre><h1 id="91c2" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">更新和插入数据—递增</h1><h2 id="b505" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">处理输入数据</h2><p id="f5e7" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">首先，传入的数据将被处理到<strong class="ih hj">代理密钥. staging_data </strong>中。这将联接预先存在的代理键或分配一个新的代理键(递增)。</p><p id="3384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了分配新的密钥，我们使用现有密钥的最大值和传入数据的递增ROW_NUMBER()。我们按照id对传入的数据进行排序，因此NULL首先出现。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="07ed" class="kq jt hi lo b fi ls lt l lu lv">CREATE OR REPLACE TABLE `surrogatekey.staging_data` AS<br/>SELECT<br/>  e.id IS NULL AS IsNew,<br/>  IFNULL(e.id,<br/>    maxId + ROW_NUMBER() OVER (<br/>      ORDER BY<br/>        e.id<br/>    )<br/>  ) AS id,<br/>  i.*<br/>FROM<br/>  `surrogatekey.incoming_data` i<br/>  LEFT JOIN `surrogatekey.existing_data` e<br/>  USING (key1, key2, key3)<br/>  CROSS JOIN (<br/>    SELECT<br/>      MAX(id) AS maxId<br/>    FROM<br/>      `surrogatekey.existing_data`<br/>  ) m</span></pre><h2 id="88a8" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">处理传入的数据—大数据</h2><p id="782b" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在前面的步骤中，为所有的incoming_data计算了ROW_NUMBER()。这不是并行的，如果它占用了太多的内存，你可能会得到超过资源。我们可以修改查询，只为需要新代理键的新行计算ROW_NUMBER()。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="6903" class="kq jt hi lo b fi ls lt l lu lv">CREATE OR REPLACE TABLE `surrogatekey.staging_data` AS<br/>WITH<br/>  -- Join with existing surrogatekey<br/>  JoinedData AS (<br/>    SELECT<br/>      e.id,<br/>      i.*<br/>    FROM<br/>      `surrogatekey.incoming_data` i<br/>      LEFT JOIN `surrogatekey.existing_data` e<br/>      USING (key1, key2, key3)<br/>  ),<br/>  -- Replace NULL using ROW_NUMBER and previous max<br/>  NewKeyedData AS (<br/>    SELECT<br/>      m.maxId + ROW_NUMBER() OVER () AS id,<br/>      j.* EXCEPT (id)<br/>    FROM<br/>      JoinedData j<br/>      CROSS JOIN (<br/>        SELECT<br/>          IFNULL(MAX(id), 0) AS maxId<br/>        FROM<br/>          `surrogatekey.existing_data`<br/>      ) m<br/>    WHERE<br/>      j.id IS NULL<br/>  )<br/>-- Union together existing and new surrogate keys<br/>SELECT<br/>  *<br/>FROM<br/>  JoinedData<br/>WHERE<br/>  id IS NOT NULL<br/>UNION ALL<br/>SELECT<br/>  *<br/>FROM<br/>  NewKeyedData;</span></pre><h2 id="8109" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">处理传入的数据—较大的数据</h2><p id="756d" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在大数据步骤中，为需要新代理键的传入数据计算ROW_NUMBER()。但是，所有的列都被处理了。这一次只处理关键列，并与最终数据重新连接。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="bc68" class="kq jt hi lo b fi ls lt l lu lv">CREATE OR REPLACE TABLE `surrogatekey.staging_data` AS<br/>WITH<br/>  JoinedData AS (<br/>    SELECT<br/>      e.id,<br/>      i.*<br/>    FROM<br/>      `surrogatekey.incoming_data` i<br/>      LEFT JOIN `surrogatekey.existing_data` e<br/>      USING (key1, key2, key3)<br/>  ),<br/>  NewKeyedData AS (<br/>    SELECT<br/>      m.maxId + ROW_NUMBER() OVER () AS id,<br/>      j.key1,<br/>      j.key2,<br/>      j.key3<br/>    FROM<br/>      JoinedData j<br/>      CROSS JOIN (<br/>        SELECT<br/>          IFNULL(MAX(id), 0) AS maxId<br/>        FROM<br/>          `surrogatekey.existing_data`<br/>      ) m<br/>    WHERE<br/>      j.id IS NULL<br/>  )<br/>SELECT<br/>  IFNULL(j.id, n.id) AS id,<br/>  j.* EXCEPT (id)<br/>FROM<br/>  JoinedData j<br/>  LEFT JOIN NewKeyedData n<br/>  USING (key1, key2, key3);</span></pre><h2 id="6a4b" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">更新现有数据</h2><p id="53f7" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">按id更新现有数据。我们不需要根据它是否是新的进行过滤，因为这仅适用于连接有效的情况。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="695e" class="kq jt hi lo b fi ls lt l lu lv">UPDATE `surrogatekey.existing_data` e<br/>SET<br/>  col1 = s.col1,<br/>  col2 = s.col2,<br/>  col3 = s.col3,<br/>  col4 = s.col4<br/>FROM<br/>  `surrogatekey.staging_data` s<br/>WHERE<br/>  e.id = s.id;</span></pre><h2 id="fdc6" class="kq jt hi bd ju kr ks kt jy ku kv kw kc iq kx ky kg iu kz la kk iy lb lc ko ld bi translated">插入新数据</h2><p id="7dd1" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在新行的位置插入新行。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="52c8" class="kq jt hi lo b fi ls lt l lu lv">INSERT INTO  `surrogatekey.existing_data`<br/>  (id, key1, key2, key3, col1, col2, col3, col4)<br/>SELECT<br/>  * EXCEPT (IsNew)<br/>FROM<br/>  `surrogatekey.staging_data`<br/>WHERE<br/>  IsNew;</span></pre><h1 id="fc9a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">合并数据—递增</h1><p id="dc87" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">或者，一个MERGE语句根据需要生成一个新的代理键，并更新/插入到现有的表中。这是将以前的SQL放在一起，而不需要复杂地跟踪它是否是一个新行。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="ab80" class="kq jt hi lo b fi ls lt l lu lv">MERGE INTO `surrogatekey.existing_data` AS e<br/>USING (<br/>  SELECT<br/>    IFNULL(e.id,<br/>      maxId + ROW_NUMBER() OVER (<br/>        ORDER BY<br/>          e.id<br/>      )<br/>    ) AS Id,<br/>    i.*<br/>  FROM<br/>    `surrogatekey.incoming_data` i<br/>    LEFT JOIN `surrogatekey.existing_data` e<br/>    USING (key1, key2, key3)<br/>    CROSS JOIN (<br/>      SELECT<br/>        MAX(id) AS maxId<br/>      FROM<br/>        `surrogatekey.existing_data`<br/>    ) m<br/>) s<br/>ON e.id=s.id<br/>WHEN MATCHED THEN<br/>  UPDATE SET<br/>    col1 = s.col1,<br/>    col2 = s.col2,<br/>    col3 = s.col3,<br/>    col4 = s.col4<br/>WHEN NOT MATCHED THEN<br/>  INSERT ROW</span></pre><h1 id="943b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">合并数据—哈希</h1><p id="6685" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">使用散列甚至更简单——只需根据传入数据适当地更新或插入，因为散列可以由每一行计算。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="bcef" class="kq jt hi lo b fi ls lt l lu lv">MERGE INTO `surrogatekey.existing_data_hash` AS e<br/>USING (<br/>  SELECT<br/>    FARM_FINGERPRINT(TO_JSON_STRING(STRUCT(key1, key2, key3)))<br/>      AS id,<br/>    *<br/>  FROM<br/>    `surrogatekey.incoming_data` AS i<br/>) AS i<br/>ON (e.id=i.id)<br/>WHEN MATCHED THEN<br/>  UPDATE SET<br/>    col1 = i.col1,<br/>    col2 = i.col2,<br/>    col3 = i.col3,<br/>    col4 = i.col4<br/>WHEN NOT MATCHED THEN<br/>  INSERT ROW</span></pre><h1 id="9e84" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">合并数据—串联</h1><p id="4899" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">散列可能非常强大和简单，但是另一种方法是将所有的键连接在一起作为一个大字符串。这有保证唯一性的好处(只要构造得好)，并且通过查看键也是可以解释的。</p><p id="b357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用id作为字符串而不是INT64，它可以按如下方式计算:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="24f4" class="kq jt hi lo b fi ls lt l lu lv">CONCAT(<br/>      CAST(key1 AS STRING), '-',<br/>      CAST(key2 AS STRING), '-',<br/>      CAST(key3 AS STRING)<br/>    ) AS id,</span></pre><h1 id="e564" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="dec6" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">代理键可能是有用的，但是也值得考虑它们是如何被使用的以及它们引入的复杂性。虽然性能可能很重要，但查询模式可能是最重要的。</p><p id="6f11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">研究散列替代方案——或者更好的是，不使用代理键——是值得考虑的。</p></div></div>    
</body>
</html>