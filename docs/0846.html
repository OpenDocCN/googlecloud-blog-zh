<html>
<head>
<title>Google Drive Policy Alerting And Remediation v2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Drive策略警报和补救v2</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-drive-policy-monitoring-and-remediation-v2-1faed83105b9?source=collection_archive---------2-----------------------#2018-12-12">https://medium.com/google-cloud/google-drive-policy-monitoring-and-remediation-v2-1faed83105b9?source=collection_archive---------2-----------------------#2018-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bca3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">借助Go多线程提高速度和规模</h2></div><p id="a616" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章继承了之前的<a class="ae jt" rel="noopener" href="/@fargyle/google-drive-policy-monitoring-and-enforcement-330989ce0d15"> Apps脚本文章</a>的不足。</p><p id="7c1b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">概括地说，目的是检测、通知和补救不符合策略的文件夹和文件权限。</p><ul class=""><li id="ecfe" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">它沿着<a class="ae jt" href="https://github.com/GoogleCloudPlatform/forseti-security" rel="noopener ugc nofollow" target="_blank">凡赛堤</a>的路线工作，允许你通过文件夹和域定义想要的共享策略，然后对此进行协调；策略向下继承以匹配驱动器的继承。</li><li id="3b9b" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">配置开关允许您删除权限或只是通知。</li></ul><p id="4b77" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最初的Apps脚本工具有三个主要限制:</p><ul class=""><li id="9d0b" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">它将文件报告为不符合策略，这些文件具有<a class="ae jt" href="https://www.labnol.org/internet/add-files-multiple-drive-folders/28715/" rel="noopener ugc nofollow" target="_blank">多个祖先</a>，并且在其中一个分支上共享是允许的。假阳性。</li><li id="f23a" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">策略是在代码中定义的，这使得它很难维护，特别是对于团队来说。</li><li id="9a5f" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">它很慢，所以它超过了Apps脚本对大文件夹结构的执行时间限制。</li></ul><p id="a35d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个限制是通过仅在所有权限累积后进行验证来解决的，而不是沿着每个分支进行验证。</p><p id="6446" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个限制是通过从Google电子表格中读取策略来解决的。</p><p id="7fb5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Go解决了第三个限制；与<a class="ae jt" rel="noopener" href="/google-cloud/load-testing-google-cloud-apis-889e393139ca">负载测试实用程序</a>类似，Go例程的多线程能力在这里是一个巨大的优势:它允许代码并行导航文件夹层次结构的所有分支，将执行时间从半小时减少到几十秒。</p><p id="6fc1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，许多由应用程序脚本抽象的复杂性必须在Go中明确解决。本文描述了在这一过程中获得的一些经验教训；这里可以直接去码<a class="ae jt" href="https://github.com/demoforwork/public/tree/master/DrivePolicyV2" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="aaa5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和往常一样，请测试以确保它的行为符合您的预期；正如您将在下面的驱动部分中读到的那样，这个工具也是如此。</p><h1 id="2ce3" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">谷歌服务</h1><h2 id="2475" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">批准</h2><p id="21f5" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">Apps脚本自动发现作用域，并引导您完成适当的授权对话；Go库抽象了用户交互和授权流，但是您仍然需要自己明确定义范围，并使用适当的凭证调用授权。</p><p id="a3c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Google Cloud不提供向服务帐户授予G Suite作用域(如Drive)的能力，因此您要么需要拥有该域的管理权限，以向服务帐户授予<a class="ae jt" href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation" rel="noopener ugc nofollow" target="_blank">域范围的授权</a>，要么通过<a class="ae jt" href="https://developers.google.com/drive/api/v3/quickstart/go" rel="noopener ugc nofollow" target="_blank">快速入门</a>中所示的3脚OAuth作为用户进行授权。因为这个工具是针对部门用户的，所以它使用三脚OAuth。</p><p id="8d67" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Apps脚本还自动提供Stackdriver日志记录；你需要在Go中自己实现这个。您可以向服务帐户授予Stackdriver作用域，如<a class="ae jt" href="https://cloud.google.com/logging/docs/setup/go" rel="noopener ugc nofollow" target="_blank">文档</a>中所述；但是这需要管理多个凭证:Stackdriver的服务帐户凭证和Google Drive API的OAuth凭证。利用OAuth流进行Stackdriver auth，如<a class="ae jt" href="https://www.jkawamoto.info/blogs/use-access-token-from-google-cloud-go/" rel="noopener ugc nofollow" target="_blank">裴军·川本的帖子</a>中所述，可以让你整合到一个凭证上。您仍然需要项目id来授权Stackdriver您可以使用OAuth包的tokenFromFile()函数从OAuth凭证中提取它，而不是对它进行硬编码；您需要包括一个副本，因为该函数是不可导出的。</p><p id="9cae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，授权代码看起来有点像这样:</p><figure class="lt lu lv lw fd lx"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="831a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们讨论一下最小特权。该实用程序使用其使用所需的最少特权，即。默认情况下，电子表格和驱动器读取范围以及日志写入范围。只有当您指定标志来修复权限或发送通知时，它才会请求这些操作的作用域。</p><h2 id="f1e4" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">错误处理</h2><p id="1535" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">正如Go Blog的<a class="ae jt" href="https://blog.golang.org/error-handling-and-go" rel="noopener ugc nofollow" target="_blank">错误处理部分</a>所述，错误类型是一种接口类型，最常用的错误实现是errors包的未导出errorString类型。</p><p id="0c79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，您会注意到，对于Google API错误，错误字符串包含一个错误代码。此代码有助于错误处理；您可以解析字符串中的错误代码，但这是不优雅和脆弱的；相反，您希望断言正确的接口类型。这里的关键在错误消息的另一部分:“googleapi: Error”。</p><p id="248c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您需要导入<a class="ae jt" href="https://github.com/googleapis/google-api-go-client/blob/master/googleapi/googleapi.go" rel="noopener ugc nofollow" target="_blank">google.golang.org/api/googleapi</a>包并声明适当的类型。您可以检查这个包，或者使用类似<a class="ae jt" rel="noopener" href="/capital-one-tech/learning-to-use-go-reflection-822a0aed74b7"> Examiner </a>的实用程序来发现这个结构(这也是一个很有启发性的反射例子)；然后，您将在错误处理中断言代码类型:</p><figure class="lt lu lv lw fd lx"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="117b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢<a class="ae jt" href="https://stackoverflow.com/users/1276480/rayfenwindspear" rel="noopener ugc nofollow" target="_blank"> RayfenWindspear </a>对此的协助…</p><h2 id="307a" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">驱动API</h2><p id="41d4" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">各种驱动程序API版本在一些有意义的方面有所不同。方法和响应模式(字段标签及其在层次结构中的级别)不同；对于该实用程序来说，最有意义的是，返回的实际权限结果有所不同。</p><ul class=""><li id="28bc" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">v2 API返回运行该实用工具的用户是其读者的文件的权限信息；只有当用户是编辑者时，v3 API才返回这些信息。</li><li id="349d" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">v2 API总是填充域字段；对于个人用户的共享，这是用户电子邮件地址的域。v3 API仅填充域共享的域；您需要解析用户的电子邮件地址，以便在共享给个人用户的情况下确定域。</li></ul><p id="5877" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该实用程序使用v2 API您可能希望通过注释/取消注释相关的行来更新到v3 API。这带来了一个有趣的问题:由于Go严格的编译时检查，您不能在检查全局变量的If语句中封装不同版本的API调用。</p><p id="488f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，API的行为是不断发展的，因此您需要定期根据一组已知的权限对您的实用程序进行回归测试。</p><h2 id="5eb8" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">驱动配额</h2><p id="6b79" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">驱动器配额也是乐趣的来源:Go例程的多线程吞吐量超过了大文件夹结构的默认驱动器API配额。默认的配额是<a class="ae jt" href="https://cloud.google.com/console/apis/api/drive.googleapis.com/quotas" rel="noopener ugc nofollow" target="_blank">描述为</a>每个用户每100秒1k次查询，但似乎在更短的时间内实现，因为如果不增加<a class="ae jt" href="https://support.google.com/code/contact/drive_quota" rel="noopener ugc nofollow" target="_blank">配额</a>，该实用程序将在不到200次查询的情况下超过配额；指数补偿只是增加了具有恒定负载的批处理实用程序的负载，因此该实用程序实现了一个命令行等待标志，它使每个go例程休眠指定的秒数。</p><h2 id="7019" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">电子邮件</h2><p id="52a7" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">我猜这听起来很熟悉；与Apps脚本不同，您需要在Go中运行自己的脚本。您可以使用Go的<a class="ae jt" href="https://golang.org/pkg/html/template/" rel="noopener ugc nofollow" target="_blank"> HTML模板</a>获得类似于Apps脚本的结果，但仍然需要自己完成大量实际的邮件撰写工作。<a class="ae jt" href="http://www.blog.labouardy.com/sending-html-email-using-go/" rel="noopener ugc nofollow" target="_blank"> Mohamed Labouardy的帖子</a>提供了一个很好的介绍。</p><p id="a69d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你需要添加几个额外的部分来<a class="ae jt" href="https://stackoverflow.com/questions/37523884/send-email-with-attachment-using-gmail-api-in-golang" rel="noopener ugc nofollow" target="_blank">编码复杂的邮件模板</a>并嵌套它们。对于更复杂的需求，你可能想看看像Jordan Wright的包。</p><p id="3631" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您的邮件功能将如下所示:</p><figure class="lt lu lv lw fd lx"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="1d70" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里您会注意到的一件有趣的事情是<a class="ae jt" href="https://gobyexample.com/variadic-functions" rel="noopener ugc nofollow" target="_blank">可变函数</a>的调用语法。</p><h2 id="f596" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">行程安排</h2><p id="970f" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">应用程序脚本提供了触发器，使您可以轻松地每天或每周运行您的实用程序。你需要使用OS工具，比如cron或者部署到App Engine Standard并使用它的调度器。</p><p id="f364" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用的是cron，那么在运行该工具之前，您需要使用一个shell文件来切换到适当的目录；否则，即使您对路径进行了硬编码，它也不会正确读取令牌文件，这与凭证文件不同。</p><figure class="lt lu lv lw fd lx"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="f6bd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在crontab -e中，每天午夜运行bash文件，并将控制台输出发送到日志文件，如下所示。</p><figure class="lt lu lv lw fd lx"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h1 id="e352" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">Golang特征</h1><h2 id="b403" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">结构和反射</h2><p id="b0ed" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">这个实用程序使用<a class="ae jt" href="http://github.com/jawher/mow.cli" rel="noopener ugc nofollow" target="_blank"> mow.cli命令行包</a>，它将标志值分配给字符串指针；为了能够在通知邮件中显示它们，需要一种迭代它们的方法；实现这一点的方法之一是将它们赋给一个<a class="ae jt" href="https://gobyexample.com/structs" rel="noopener ugc nofollow" target="_blank">结构</a>，然后遍历该结构；事实证明，迭代指针结构的值是非常重要的。<a class="ae jt" href="https://stackoverflow.com/questions/23350173/how-do-you-loop-through-the-fields-in-a-golang-struct-to-get-and-set-values-in-a" rel="noopener ugc nofollow" target="_blank">这篇Stackoverflow文章</a>提供了一个有用的例子(<a class="ae jt" href="https://stackoverflow.com/questions/18926303/iterate-through-the-fields-of-a-struct-in-go" rel="noopener ugc nofollow" target="_blank">这篇文章</a>提供了一个更简单的方法，但是它要求struct字段是可导出的)；因为struct字段本身就是指针，所以需要额外调用Elem()。</p><p id="9c07" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以CLI和反射代码看起来像这样:</p><figure class="lt lu lv lw fd lx"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="2af0" class="la kj hi bd kk lb lc ld ko le lf lg ks jg lh li ku jk lj lk kw jo ll lm ky ln bi translated">映射键存在检查</h2><p id="61bc" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">这个工具使用大量的地图；这意味着要检查一个键是否存在，这在<a class="ae jt" href="https://stackoverflow.com/questions/2050391/how-to-check-if-a-map-contains-a-key-in-go" rel="noopener ugc nofollow" target="_blank">这个Stackoverflow帖子</a>中有描述。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h1 id="99f1" class="ki kj hi bd kk kl mh kn ko kp mi kr ks io mj ip ku ir mk is kw iu ml iv ky kz bi translated">后续步骤</h1><p id="f42d" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">该实用程序的良好扩展是:</p><ul class=""><li id="b747" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">支持基于谷歌组以及域的政策。</li><li id="7649" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">支持团队驱动。</li><li id="fe87" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">将通知映射推送到表单，这样您就可以每小时扫描一次，每天通知一次。</li></ul></div></div>    
</body>
</html>