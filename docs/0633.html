<html>
<head>
<title>Kubernetes: Horizontal Pod Scaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:水平Pod缩放</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-horizontal-pod-scaling-190e95c258f5?source=collection_archive---------0-----------------------#2018-06-05">https://medium.com/google-cloud/kubernetes-horizontal-pod-scaling-190e95c258f5?source=collection_archive---------0-----------------------#2018-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3620" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过Pod自动扩展，您的Kubernetes集群可以监控现有Pod的负载，并确定我们是否需要更多Pod。这是使用Kubernetes的最大好处之一，因为您可以避免单个pod过载，这将导致意外的代码行为和各种错误。您可以通过多种方式来控制这个Pod自动扩展，以及围绕它的最佳实践。这就是本文的目的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/db9bd72c5dae89de9d2409a05dbf6478.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*7RpptfaN7Q-54tw7BCqcPw.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">复制舱！</figcaption></figure><p id="398a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jp">如果你还没有通读甚至阅读过本系列</em>  <em class="jp">的第一部分</em> <a class="ae jq" rel="noopener" href="/@jonbcampos/kubernetes-day-one-30a80b5dcb29"> <em class="jp">，你可能会感到困惑，不知道代码在哪里，或者之前做了什么。记住这里假设你正在使用</em> </a><a class="ae jq" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> GCP </em> </a> <em class="jp">和</em><a class="ae jq" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"><em class="jp">GKE</em></a><em class="jp">。我将始终提供代码和如何测试代码是按预期工作。</em></p><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-day-one-30a80b5dcb29"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:第一天</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="ke l kf kg kh kd ki jj ju"/></div></div></a></div><h1 id="60b9" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Pod自动缩放</h1><p id="aa9b" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">正如我们之前所讨论的，Kubernetes在一个称为Pod的Kubernetes容器中使用Docker容器来管理Kubernetes集群中的资源。通过自动缩放，Kubernetes会观察每个单元的<em class="jp">资源指标</em>，并确定我们是否需要更多或更少的单元。我说“资源度量”是故意含糊其辞，因为您可以根据应用程序的需求创建定制的度量。最常见的是CPU利用率。</p><blockquote class="lm ln lo"><p id="8daf" class="if ig jp ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">也就是说，Kubernetes将观察X秒内的平均CPU利用率，并根据利用率添加或删除pod。我们使用平均CPU利用率来降低峰值噪声。</p></blockquote><h1 id="9020" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">向集群添加水平窗格自动缩放</h1><p id="1031" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">Kubernetes集群准备就绪后，您可以添加一个水平Pod自动缩放器(也称为HPA ),以便您的集群根据资源指标在必要时添加和删除Pod。添加这个HPA非常简单，只需下面的脚本行。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="d7db" class="lx kk hi lt b fi ly lz l ma mb">echo "sets autoscale logic"<strong class="lt hj"><br/><em class="jp">kubectl </em>autoscale deployment endpoints --cpu-percent=50 --min=1 --max=10</strong></span></pre><p id="36c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道了什么是HPA，我们可以专注于制作我们自己的HPA，并在GCP上测试我们的集群。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/32a2ddfd306294c9a5bf5fb6c0ba3d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*xgHe3gDinGnUt4gIfJk8mg.jpeg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">不要做这种人</figcaption></figure><h1 id="27a6" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">带负荷测试</h1><p id="4db8" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">你现在可以成为两个开发者之一。</p><ol class=""><li id="4053" class="md me hi ih b ii ij im in iq mf iu mg iy mh jc mi mj mk ml bi translated">你可以把一切都推出去，相信它会起作用。</li><li id="a029" class="md me hi ih b ii mm im mn iq mo iu mp iy mq jc mi mj mk ml bi translated">在你因为没有验证你的工作而陷入麻烦之前，你可以验证事情已经设置好了。</li></ol><p id="529f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没错。我们现在将成为第二号开发人员，测试我们的Kubernetes集群在事情开始变得棘手时是否会像预期的那样扩展。为此，我们将创建一个全新的Kubernetes集群，模拟来自完全不同的GCP区域的负载。我们将以这种方式进行测试，因为它将充分模拟来自另一个位置的负载，同时专注于我们可以真正影响的代码，并且没有太多的测试污染。</p><p id="09c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:这个使用Locust的解决方案在<a class="ae jq" href="https://cloud.google.com/solutions/distributed-load-testing-using-kubernetes" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中有详细介绍。我刚为你写了一个很好的剧本。</p><p id="20d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们的环境运行起来。您可以选择默认创建自动缩放，或者运行两个替代命令来添加自动缩放。如果你对这个集群定标器感兴趣，我推荐你看看我在<a class="ae jq" rel="noopener" href="/@jonbcampos/kubernetes-cluster-autoscaler-f1948a0f686d"> Kubernetes集群定标器</a>上发布的另一个帖子。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="b3dc" class="lx kk hi lt b fi ly lz l ma mb">$ git clone <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series.git" rel="noopener ugc nofollow" target="_blank">https://github.com/jonbcampos/kubernetes-series.git</a><br/>$ cd ~/<a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/tree/master/autoscaling/scripts" rel="noopener ugc nofollow" target="_blank">kubernetes-series/autoscaling/scripts</a><br/>$ sh <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/startup.sh" rel="noopener ugc nofollow" target="_blank">startup.sh</a> # with autoscaling<br/>$ # sh <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/startup_wo_autoscaling.sh" rel="noopener ugc nofollow" target="_blank">startup_wo_autoscaling.sh</a> # without autoscaling<br/>$ # sh <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/add_autoscaling.sh" rel="noopener ugc nofollow" target="_blank">add_autoscaling.sh</a> # add autoscaling <strong class="lt hj">after</strong> creation</span></pre><p id="9c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇，这些命令解决了很多问题，不是吗！？现在是时候创建我们的负载测试Kubernetes集群了，构建我们的Docker文件，其中包含我们的runner测试，最后部署我们的负载测试代码。为了让这变得简单，我把它放到了一个脚本中，你可以<a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/startup_load_runner.sh" rel="noopener ugc nofollow" target="_blank">一头扎进去，看看神奇的</a>。</p><p id="8e91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您会注意到，我们在脚本中添加了一个参数，以便负载运行器知道要测试什么地址。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="e22a" class="lx kk hi lt b fi ly lz l ma mb">cd ~/kubernetes-series/autoscaling/scripts # if necessary<br/># You’ll notice that we added an argument to our <br/># script so that the load runner knows what address to test<br/>$ sh <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/startup_load_runner.sh" rel="noopener ugc nofollow" target="_blank">startup_load_runner.sh</a> 100.101.102.103</span></pre><p id="b630" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成此过程后，您应该会看到一个提示，告诉您在哪里可以查看和访问您的群集。是时候转到该链接并启动您的负载运行器了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es mr"><img src="../Images/bb38994866a09067d133b5a85675de67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvNqbKRQzEcs5xjKwi4HZA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">可从[您的群集ip地址]:8089获得</figcaption></figure><p id="e997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是有趣的部分。您可以输入想要模拟的用户数量及其速度，然后设置一个Kubernetes集群开始攻击另一个。</p><p id="5e7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你在玩负重跑的时候，你可能想在你的吊舱中增加一个观察器。这样，您可以看到负载何时开始变大，自动缩放何时开始。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="7126" class="lx kk hi lt b fi ly lz l ma mb"># view specific cluster details<br/>$ <strong class="lt hj">gcloud container clusters get-credentials autoscaling-cluster </strong><strong class="lt hj">--zone</strong><strong class="lt hj">=us-central1-a</strong><br/># show horizontal pod autoscaling details<br/>$ <strong class="lt hj">watch kubectl get hpa</strong> # ctrl+c to stop</span></pre><p id="787e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您真的想让您的集群变得紧张，您可能还想使用我为您设置的以下复制脚本来添加更多的工作线程。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="5dea" class="lx kk hi lt b fi ly lz l ma mb">$ cd ~/kubernetes-series/autoscaling/scripts # if necessary<br/>$ sh <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/scale_load_runner.sh" rel="noopener ugc nofollow" target="_blank">scale_load_runner.sh</a> X # &lt;-- number of replicas to make</span></pre><p id="d3e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了它，你就大功告成了！您已经创建了一个集群，您已经将集群设置为自动扩展，最后您已经通过使用负载运行器来测试集群的扩展。说真的，太神奇了。</p><p id="00f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">额外收获:如果你想享受看着吊舱下降的过程，你可以在观看hpa的同时清空负载运行器。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="e9dc" class="lx kk hi lt b fi ly lz l ma mb">$ cd ~/kubernetes-series/autoscaling/scripts # if necessary<br/>$ sh <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/teardown_load_runner.sh" rel="noopener ugc nofollow" target="_blank">teardown_load_runner.sh</a></span></pre><p id="96e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">额外阅读:如果你对Locust有点好奇，我推荐你看看我的另一个链接<a class="ae jq" rel="noopener" href="/@jonbcampos/locust-customize-task-runner-f5a6c59476ff">，在那里我给出了更多关于编辑Locust文件的细节</a>。</p><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/@jonbcampos/locust-customize-task-runner-f5a6c59476ff"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">蝗虫:自定义任务运行器</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">这篇文章是我刚刚在Kubernetes上发布的另一系列文章的副产品:集群自动缩放器和…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div></div></a></div><h1 id="3ea5" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">拆卸</h1><p id="1a77" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">在您离开之前，请确保清理您的项目，这样您就不会为您用来运行群集的虚拟机付费。返回到云Shell并运行teardown脚本来清理您的项目。这将删除您的集群和我们构建的容器。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="8f29" class="lx kk hi lt b fi ly lz l ma mb">$ cd ~/kubernetes-series/autoscaling/scripts # if necessary<br/>$ sh <a class="ae jq" href="https://github.com/jonbcampos/kubernetes-series/blob/master/autoscaling/scripts/teardown.sh" rel="noopener ugc nofollow" target="_blank">teardown.sh</a></span></pre><h1 id="1185" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">关闭</h1><p id="4ec9" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">这篇文章与围绕<a class="ae jq" rel="noopener" href="/@jonbcampos/kubernetes-cluster-autoscaler-f1948a0f686d">集群自动缩放器</a>的另一篇文章齐头并进。如果这激发了你对扩展的兴趣，我会推荐你朝那个方向前进。</p></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><h1 id="1463" class="kj kk hi bd kl km nd ko kp kq ne ks kt ku nf kw kx ky ng la lb lc nh le lf lg bi translated">本系列的其他文章</h1><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-running-background-tasks-with-batch-jobs-56482fbc853"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:使用批处理作业运行后台任务</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">当构建令人惊叹的应用程序时，有时您可能想要处理用户之外的动作…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="ni l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-run-a-pod-per-node-with-daemon-sets-f77ce3f36bf1"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:用守护进程集在每个节点上运行一个Pod</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">我最初给这篇文章起的标题只是“守护进程集”,并假设它足以抓住要点…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="nj l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-cron-jobs-455fdc32e81a"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">库伯内特:克朗·乔布斯</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">有时候你的工作不是事务性的。我们不再等待用户点击按钮让系统亮起来…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="nk l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-dns-proxy-with-services-d7d9e800c329"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:带服务的DNS代理</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">构建应用程序时，通常需要与外部服务进行交互来完成业务…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="nl l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-routing-internal-services-through-fqdn-d98db92b79d3"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:通过FQDN路由内部服务</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">我记得当我第一次进入Kubernetes时。一切都是崭新的、闪亮的、有规模的。当我继续的时候…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="nm l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-liveness-checks-4e73c631661f"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:活性检查</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">最近，我整理了一篇关于Kubernetes就绪性调查以及它对您的集群有多重要的文章…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="nn l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-day-one-30a80b5dcb29"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:第一天</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="ke l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-cluster-autoscaler-f1948a0f686d"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:集群自动缩放</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">自动缩放是Kubernetes的一个巨大的(并且已经上市的)特性。当你的网站/应用程序/应用程序接口/项目变得越来越大时，洪水…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="no l kf kg kh kd ki jj ju"/></div></div></a></div><div class="jr js ez fb jt ju"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-readiness-probe-83f8a06d33d3"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hj fi z dy jz ea eb ka ed ef hh bi translated">Kubernetes:就绪探测</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">如果对这个特性有任何疑问，我写这篇文章是为了说明这不是一个…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">medium.com</p></div></div><div class="kd l"><div class="np l kf kg kh kd ki jj ju"/></div></div></a></div></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="ed62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jq" href="http://jonbcampos.com/" rel="noopener ugc nofollow" target="_blank"> Jonathan Campos </a>是一个狂热的开发者，喜欢学习新事物。我相信我们应该不断学习、成长和失败。我总是开发社区的支持者，并且总是愿意提供帮助。因此，如果你对这个故事有任何问题或意见，请在下面提出。在<a class="ae jq" href="https://www.linkedin.com/in/jonbcampos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae jq" href="https://twitter.com/jonbcampos" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，并提及这个故事。</p></div></div>    
</body>
</html>