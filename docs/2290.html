<html>
<head>
<title>Optimizing BigQuery Queries Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化BigQuery查询性能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/optimizing-bigquery-queries-performance-bb42eb7f7429?source=collection_archive---------0-----------------------#2022-08-06">https://medium.com/google-cloud/optimizing-bigquery-queries-performance-bb42eb7f7429?source=collection_archive---------0-----------------------#2022-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8a61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BigQuery的性能调优通常是因为我们希望减少查询执行运行时的次数或成本。</p><p id="acc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最小化输入/输出</strong></p><ul class=""><li id="ca41" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">选择时要有目的。由于BigQuery使用列式文件格式，因此在SELECT中读取的列越少，需要读取的数据量就越少。如果您几乎需要一个表中的所有列，可以考虑使用SELECT * EXCEPT，这样就不会读取不需要的列。</li><li id="2e17" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">减少正在读取的数据。一个可能的改进是使用过滤和分组。</li><li id="ca3b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">减少昂贵的计算次数</li></ul><p id="6c5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缓存以前查询的结果</strong></p><p id="9c88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BigQueey会自动将查询结果缓存在一个临时表中大约24小时。然而，有一些注意事项。查询缓存基于精确的字符串比较。因此，即使是空白也可能导致缓存未命中。</p><ul class=""><li id="ddf0" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">缓存即时结果。利用这一事实，我们可以创建临时表和物化视图来提高整体性能。</li><li id="4ce6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">使用BI引擎加速查询。这将自动在内存中存储相关的数据片段(或者是表中的实际列，或者是派生的结果)，并将使用专门的查询处理器来处理大部分内存中的数据。</li></ul><p id="c1f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">执行高效连接</strong></p><ul class=""><li id="6084" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">反规格化</li><li id="b490" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">避免大型表的自连接。当表与自身连接时，会发生自连接。</li><li id="b143" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">减少被连接的数据</li><li id="6ded" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">使用窗口函数代替自连接</li><li id="8fed" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">用预先计算的值连接。有时，在较小的表上预先计算函数，然后用预先计算的值进行联接，而不是每次都重复一次昂贵的计算，会很有帮助。</li></ul><p id="3735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">避免过度使用单个工人</strong></p><ul class=""><li id="cac6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">限制大型排序</li><li id="f387" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">数据偏差。当我们将ARRAY_AGG与GROUP BY一起使用时，其中一个键比其他键更常见，就会发生这种情况。</li></ul><p id="450e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用合适的聚合函数</strong></p><ul class=""><li id="d9e8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">近似计数。仅在大型数据集上，近似算法比精确算法有效得多，并且推荐用于误差约为1%的可容忍用例。</li></ul></div></div>    
</body>
</html>