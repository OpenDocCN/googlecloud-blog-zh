<html>
<head>
<title>Calming down Kubernetes Autoscaler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">平息Kubernetes自动缩放器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/calming-down-kubernetes-autoscaler-fbdba52adba6?source=collection_archive---------0-----------------------#2018-06-06">https://medium.com/google-cloud/calming-down-kubernetes-autoscaler-fbdba52adba6?source=collection_archive---------0-----------------------#2018-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/kubernetes/autoscaler" rel="noopener ugc nofollow" target="_blank"> Kubernetes Autoscaler </a>是一个巨大的省钱省！它会持续监控集群，并在可能的情况下尝试重新分配单元，以最大限度地利用节点。不幸的是，有时它太咄咄逼人，但<strong class="ih hj">用一个小技巧Kubernetes Autoscaler可以平静下来！</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="8b6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，<a class="ae jd" href="https://cirrus-ci.org/" rel="noopener ugc nofollow" target="_blank"> Cirrus CI </a>可以在Google Kubernetes引擎集群上运行CI任务。Cirrus CI使用Kubernetes Jobs API为每个CI任务安排一个作业。当我们刚刚提出这种方法并对其进行负载测试时，似乎Kubernetes Autoscaler正在<strong class="ih hj">杀死活动作业</strong>并在其他节点上重新启动它们以最大化整体利用率。一般来说，这对于长时间运行的作业和pod是有意义的，但是在我们的例子中，我们确实知道CI作业有超时，并且通常在几分钟内完成。没有理由在另一个节点上重新启动CI作业。</p><p id="b201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入研究了Kubernetes Autoscaler 的<a class="ae jd" href="https://github.com/kubernetes/autoscaler/blob/fae2c903a3a6615fc53b748e7a17398128b60745/cluster-autoscaler/utils/drain/drain.go#L197-L199" rel="noopener ugc nofollow" target="_blank">内部之后，似乎默认情况下它并不驱逐具有本地存储的pod。所以<strong class="ih hj">只要安装一个</strong> <code class="du jl jm jn jo b"><strong class="ih hj">emptyDir</strong></code> <strong class="ih hj">就可以避免驱逐！</strong></a></p><pre class="je jf jg jh fd jp jo jq jr aw js bi"><span id="544d" class="jt ju hi jo b fi jv jw l jx jy"><strong class="jo hj">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: test-pd<br/>spec:<br/>  containers:<br/>  - image: k8s.gcr.io/test-webserver<br/>    name: test-container<br/>    volumeMounts:<br/>    - mountPath: /tmp<br/>      name: temp-volume<br/>  volumes:<br/>  - name: temp-volume<br/>    emptyDir: {}</strong></span></pre><p id="8d81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！现在Kubernetes Autoscaler不会碰你的豆荚！但是如果您仍然希望对一些pod进行例外处理，您可以简单地向这些pod添加<code class="du jl jm jn jo b">cluster-autoscaler.kubernetes.io/safe-to-evict: true</code>注释。</p><p id="022c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">更新(09/28/2018): </strong> <code class="du jl jm jn jo b">cluster-autoscaler.kubernetes.io/safe-to-evict: false</code>现在注释作品。</p><p id="b087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请阅读Kubernetes Autoscaler 上的<a class="ae jd" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#when-does-cluster-autoscaler-change-the-size-of-a-cluster" rel="noopener ugc nofollow" target="_blank">常见问题解答，了解更多详细信息。我希望这篇小博文能够帮助您避免集群中的意外驱逐！</a></p></div></div>    
</body>
</html>