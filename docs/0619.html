<html>
<head>
<title>Understanding OAuth2 and Building a Basic Authorization Server of Your Own: A Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解OAuth2并构建自己的基本授权服务器:初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/understanding-oauth2-and-building-a-basic-authorization-server-of-your-own-a-beginners-guide-cf7451a16f66?source=collection_archive---------0-----------------------#2018-05-26">https://medium.com/google-cloud/understanding-oauth2-and-building-a-basic-authorization-server-of-your-own-a-beginners-guide-cf7451a16f66?source=collection_archive---------0-----------------------#2018-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="286c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这本初学者指南提供了OAuth2的基本概述，并讨论了如何构建一个简单的OAuth2授权服务器。</p><p id="088e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关在Google云平台上部署基本OAuth2认证服务的分步教程，请参见<a class="ae jd" rel="noopener" href="/@ratrosy/understanding-oauth2-and-deploying-a-basic-oauth2-authorization-service-to-cloud-functions-812e3643f94d">了解OAuth2并将基本OAuth2授权服务部署到云功能的教程</a>。</p><h1 id="2097" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">背景</h1><p id="15f5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">许多授权过程涉及用户提供的凭证，最常见的形式是用户名/密码组合。早期的网站通常通过HTML表单要求凭证，浏览器会将凭证发送到服务器。服务器验证信息并在cookie中写入一个会话值；只要会话仍标记为活动，用户就可以访问受保护的功能和资源。由于其简单性和有效性，这个过程至今仍被许多web应用程序和服务所使用。</p><p id="3ca4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管基于cookie的授权可能很受欢迎，但它有几个缺点:</p><ul class=""><li id="285c" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">基于Cookie授权通常是有状态的。服务器必须保存活动会话的记录，并在每次请求到达时检查数据库，这需要服务器端的一些开销。将授权过程与应用服务器分离也很困难。</li><li id="572c" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Cookies通常与域捆绑在一起。如果您的应用程序与多个域交互，可能需要额外的配置。</li><li id="f51f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">基于Cookie的授权不适合移动客户端。</li><li id="12a7" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">基于Cookie的授权不能很好地适应一个产品或服务的用户想要授权第三方客户访问他们在平台上的信息的用例。</li></ul><p id="f483" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth解决了这些问题。作为一种授权框架，它使应用程序能够从各种服务中访问资源，在web上得到广泛应用。目前OAuth有两个版本的协议，OAuth 1.0 ( <a class="ae jd" href="https://tools.ietf.org/html/rfc5849" rel="noopener ugc nofollow" target="_blank"> RFC 5849 </a>)和OAuth 2.0 ( <a class="ae jd" href="https://tools.ietf.org/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> RFC 6749 </a>)。本指南重点介绍2.0版本。实质上，OAuth 2.0允许任意的<strong class="ih hj">客户端</strong>(例如，第一方iOS应用程序或第三方web应用程序)通过<strong class="ih hj">授权服务器</strong>以安全、可靠和高效的方式访问<strong class="ih hj">资源服务器</strong>上用户<strong class="ih hj">资源所有者</strong>的资源。</p><blockquote class="kv kw kx"><p id="c463" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">OAuth 2.0不向后兼容以前的版本。关于选择OAuth 2.0而不是OAuth 1.0的优缺点仍然是一个争论的话题。</p></blockquote><p id="4387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth 2.0规范定义了4种类型的授权流:</p><ul class=""><li id="30fc" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><strong class="ih hj">授权码</strong></li><li id="3abf" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">资源所有者密码凭证</strong></li><li id="dc5a" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">含蓄</strong></li><li id="ba89" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><strong class="ih hj">客户凭证</strong></li></ul><p id="259d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隐式</strong>和<strong class="ih hj">客户端凭证</strong>是通常为特殊类型的客户端保留的流。更具体地说，</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="958c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于其他客户端，根据其可信度，可以使用以下流程:</p><figure class="lc ld le lf fd lg"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="c91e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不严格地说，如果你计划<strong class="ih hj">建立一个第三方</strong> <strong class="ih hj">应用和服务可以访问其资源</strong>的平台，就按照授权代码流程走；另一方面，您可以使用资源所有者密码凭证流<strong class="ih hj">为您自己的服务</strong>构建一个客户端(一个web/移动应用程序)。</p><p id="7b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">令牌在OAuth 2.0中起着重要的作用。有两种类型的令牌:访问令牌和刷新令牌。任何拥有有效访问令牌的人都可以访问受保护的资源；通常它是短暂的，因此即使出现安全漏洞和访问令牌泄露，也可以快速控制损害。当访问令牌过期时，开发人员可以使用可选的刷新令牌来请求新的访问令牌，而不必要求用户再次输入他们的凭据。</p><h1 id="e6a4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">授权流程</h1><h2 id="1a32" class="lj jf hi bd jg lk ll lm jk ln lo lp jo iq lq lr js iu ls lt jw iy lu lv ka lw bi translated">资源所有者密码凭据</h2><p id="ab94" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">资源所有者密码凭证流程有以下要求:</p><ul class=""><li id="d928" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">客户端必须是高度可信的，因为它直接处理用户凭据。大多数情况下，客户端应该是第一方app。</li></ul><p id="6f1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该流程包括以下步骤:</p><ol class=""><li id="e368" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc lx kn ko kp bi translated"><strong class="ih hj">客户端</strong>提示<strong class="ih hj">用户</strong>输入他们的凭证(例如，用户名/密码组合)。</li><li id="ff9f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lx kn ko kp bi translated"><strong class="ih hj">客户端</strong>向<strong class="ih hj">授权服务器</strong>发送凭证及其自身标识。<strong class="ih hj">授权服务器</strong>验证信息，然后返回访问令牌和可选的刷新令牌。</li><li id="3773" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lx kn ko kp bi translated"><strong class="ih hj">客户端</strong>使用访问令牌访问<strong class="ih hj">资源服务器</strong>上的资源。</li></ol><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/cc2381d1998e66e042cf668d04de300f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IsGZosgvxFHqNJYA."/></div></div></figure><h2 id="42f1" class="lj jf hi bd jg lk ll lm jk ln lo lp jo iq lq lr js iu ls lt jw iy lu lv ka lw bi translated">授权代码</h2><p id="5f10" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">授权代码流有以下要求:</p><ul class=""><li id="d661" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">客户端必须能够与环境中的用户代理(浏览器)进行交互。</li></ul><p id="e0fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该流程包括以下步骤:</p><ol class=""><li id="d773" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc lx kn ko kp bi translated"><strong class="ih hj">客户端</strong>准备到<strong class="ih hj">授权服务器</strong>的链接，并在<strong class="ih hj">用户代理</strong>(浏览器)中为用户打开链接。该链接包括允许授权服务器识别和响应客户端的信息。</li><li id="73ee" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lx kn ko kp bi translated">用户在新页面上输入他们的凭据。</li><li id="f287" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lx kn ko kp bi translated">凭证通过用户代理(浏览器)发送到授权服务器。</li><li id="dcf9" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lx kn ko kp bi translated"><strong class="ih hj">授权服务器</strong>验证凭证，并使用授权码将用户重定向回<strong class="ih hj">客户端</strong>。</li><li id="e4c1" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lx kn ko kp bi translated">客户端与<strong class="ih hj">授权服务器</strong>对话，确认其身份，并将授权码交换为访问令牌和可选的刷新令牌。</li><li id="20f8" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc lx kn ko kp bi translated"><strong class="ih hj">客户端</strong>使用访问令牌访问<strong class="ih hj">资源服务器</strong>上的资源。</li></ol><p id="98ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，出于安全考虑，尽管移动应用程序客户端和web应用程序客户端都可以使用授权代码流，但它们在流中标识自己的方法是不同的。Web应用客户端通常使用客户端id和客户端机密，<strong class="ih hj">而移动应用客户端需要采用代码交换证明密钥(PKCE)技术，并利用代码质询和代码验证器。</strong></p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mf"><img src="../Images/620ed0f74dfe975dbbcc74b70634cc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LCiX2ep4e2QVo-Pu."/></div></div></figure><h2 id="44ad" class="lj jf hi bd jg lk ll lm jk ln lo lp jo iq lq lr js iu ls lt jw iy lu lv ka lw bi translated">隐式凭据和客户端凭据</h2><p id="9a9f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如前所述，隐式流是为单页Javascript应用程序设计的。除了涉及授权代码的部分之外，这个流程与授权代码流程非常相似。出于安全考虑，在这个流程中，客户端不再从授权服务器接收授权码；相反，在用户代理成功传输凭证后，授权服务器会将访问令牌直接返回给客户端。隐式流中不允许刷新令牌。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mf"><img src="../Images/aa4cbfeac2fe943a55cbeafc0d414aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sj1vaRSwveqUPyuL."/></div></div></figure><p id="5290" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，客户端凭据流更接近于资源所有者密码凭据流。这个流中的客户端使用客户端id和机密来标识自己，并与授权服务器交换访问令牌。您也不应该在这个流中使用刷新令牌。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mf"><img src="../Images/93c8851e837783bf18d9ef059e7e7904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jZtQNpjpoKkkSjsE."/></div></div></figure><h1 id="5d3b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">JWT (JSON Web令牌)</h1><p id="4f0d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">您可能已经意识到，尽管在OAuth 2.0中经常引用令牌，但是到目前为止，很少有人谈到它们的生成和使用。事实是，OAuth 2.0框架并没有指定访问令牌和刷新令牌应该采用什么格式，而是由开发人员自己决定是否将令牌集成到他们选择的授权流中。从理论上讲，您可以使用一个永远不会过期的预定义字符串作为访问令牌，尽管它显然不是非常安全；然而在现实中，许多开发人员选择使用<a class="ae jd" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> JWT (JSON Web Token) </a>格式。JWT是独立的，允许服务器验证令牌而无需查询数据源。</p><p id="b7ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JWT包括三个部分:</p><ul class=""><li id="869c" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">描述令牌类型及其使用的哈希算法的标头</li><li id="c00d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">包含数据的有效载荷</li><li id="8fee" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">用于验证令牌的签名</li></ul><p id="8bcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这三个部分都应该进行<code class="du mg mh mi mj b">Base64URL</code>编码，以便它们可以在查询字符串中安全地传输。</p><p id="7c79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在JWT中使用许多哈希算法，有效载荷有各种预定义的字段(也称为<a class="ae jd" href="https://tools.ietf.org/html/rfc7519#section-4.1" rel="noopener ugc nofollow" target="_blank">注册声明名称</a>)。这本初学者指南使用了<code class="du mg mh mi mj b">RS256</code>(带SHA-256的RSA签名)算法，并在有效负载中指定了两个注册声明:<code class="du mg mh mi mj b">exp</code>(令牌何时过期)，以及<code class="du mg mh mi mj b">iss</code>(令牌由谁发布)。除了受支持的声明之外，您还可以在有效负载中定义自己的声明，比如令牌的范围。</p><p id="558b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次JWT到达服务器时，系统首先解析JWT，并验证是否支持报头中指定的算法；然后检查签名以确保JWT是有效的，最后，确认注册的声明(如果存在)是有效的。在本指南中，这意味着确保JWT没有过期(<code class="du mg mh mi mj b">exp</code>)，并且来自预期的来源(<code class="du mg mh mi mj b">iss</code>)。自定义声明(如范围)可以从令牌中提取并手动验证。</p><h2 id="b109" class="lj jf hi bd jg lk ll lm jk ln lo lp jo iq lq lr js iu ls lt jw iy lu lv ka lw bi translated">到期日期和刷新令牌</h2><p id="da8f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">此外，开发人员可以控制访问令牌的生命周期和刷新令牌的使用。一般来说，如果您正在构建一个保护关键资源的授权服务器，那么最好远离刷新令牌，并保持访问令牌的短暂性。不过，对于不太重要的资源，启用刷新令牌并让访问令牌存在更长时间是可以的。抵制创造常青代币的诱惑；长期访问令牌确实使开发更容易，但是在安全性和便利性之间总是有一个折衷。</p><h1 id="3d9f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">下一步是什么</h1><p id="f739" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">本初学者指南包括详细解释每个授权流程如何工作的示例:</p><ul class=""><li id="1f7b" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><a class="ae jd" rel="noopener" href="/@ratrosy/building-a-basic-authorization-server-using-resource-owner-password-credentials-flow-a666d06900fb">资源所有者密码凭证</a></li><li id="e435" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae jd" rel="noopener" href="/@ratrosy/building-a-basic-authorization-server-using-authorization-code-flow-c06866859fb1">授权代码流程</a></li><li id="a004" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae jd" rel="noopener" href="/@ratrosy/building-a-basic-authorization-server-using-authorization-code-flow-pkce-3155e843466">授权码流程(PKCE) </a></li><li id="9021" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae jd" rel="noopener" href="/@ratrosy/building-a-basic-authorization-server-with-implicit-flow-3f474eb2a306">隐式流</a></li><li id="ece3" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae jd" rel="noopener" href="/@ratrosy/building-a-basic-authorization-server-using-client-credentials-flow-db353d6debdf">客户凭证流程</a></li></ul><p id="3ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些文档在很大程度上是相互独立的。如果您已经决定了使用哪个授权流，请随意从您选择的示例开始。为了全面了解OAuth 2.0的运行情况，建议从授权代码流开始。</p><p id="de60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，<a class="ae jd" rel="noopener" href="/@ratrosy/understanding-oauth2-and-deploying-a-basic-oauth2-authorization-service-to-cloud-functions-812e3643f94d">了解OAuth2并构建一个具有云功能的基本OAuth2授权服务器</a>教程展示了如何使用一个无服务器解决方案，<a class="ae jd" href="https://cloud.google.com/functions/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Functions </a>，将一个定制的OAuth 2.0授权服务部署到云上。</p></div></div>    
</body>
</html>