<html>
<head>
<title>Connecting MicroPython devices to Google Cloud IoT Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将MicroPython设备连接到谷歌云物联网核心</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/connecting-micropython-devices-to-google-cloud-iot-core-3680e632681e?source=collection_archive---------1-----------------------#2019-06-12">https://medium.com/google-cloud/connecting-micropython-devices-to-google-cloud-iot-core-3680e632681e?source=collection_archive---------1-----------------------#2019-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/21ac4cbc86d62b8311987a8b51e8a0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SfdS0wt7VnkVt7bk0LU5g.png"/></div></div></figure><h1 id="51cf" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="6373" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">几周前，我开始建设另一个物联网项目。(稍后会有更多的内容)当布置所有的组件并决定如何设置它时，我花了一点时间来考虑软件方面的事情。我看到了两条主要的前进道路。一方面，我可以走Arduino C/C++路线，这是一条很好的记录，在很多情况下是一条好路线。但另一方面，我听说过MicroPython，但从未尝试过。我也找不到任何关于使用MicroPython和Google Cloud IoT Core的好信息。</p><p id="af1e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，这篇博客的目标是一步步地分享如何获得一个兼容MicroPython的微控制器，在这里是一个ESP32，配置为通过MQTT连接和发送事件到Google Cloud IoT核心。</p><h1 id="2c47" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">选择一个设备</h1><p id="7bd1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">正如我之前提到的，我们将从ESP32开发板开始。这些可以在易贝、邦古德、速卖通等网站上找到，价格相当便宜。不过，我在亚马逊上捡到了一个lolin32。在任何情况下，大多数(如果不是全部)ESP32开发板都应该可以工作。</p><p id="708d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因为您的设备可能还没有安装MicroPython，所以我们需要刷新它。别担心，这是一个非常简单的过程。在我的例子中，我使用的是当前最新的stable(esp32–2019 05 29-v 1.11 . bin)，但如果你愿意，也许值得看看最新最棒的。你可以在MicroPython网站上找到二进制文件:<a class="ae kr" href="http://micropython.org/download#esp32" rel="noopener ugc nofollow" target="_blank">http://micropython.org/download#esp32</a></p><p id="f0a7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在您选择并下载了MicroPython二进制文件之后，我们需要确保您拥有esptool，它允许您轻松地与设备的ROM引导加载程序进行通信。代码位于<a class="ae kr" href="https://github.com/espressif/esptool" rel="noopener ugc nofollow" target="_blank">这里</a>，但是你可以使用pip很容易地安装它。此外，我们还希望有一个可以通过串行通信和控制MicroPython板的工具。这个工具叫做ampy，我们现在也要安装它。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5403" class="lb ir hi kx b fi lc ld l le lf">pip install esptool adafruit-ampy</span></pre><p id="ad59" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在您已经安装了esptool，您需要将该板插入到您的计算机中，并找出它位于哪个串行端口上。因为我用的是Mac，所以我会这样做:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b5fc" class="lb ir hi kx b fi lc ld l le lf">ls /dev/ | grep -i "tty" | grep -i "usb"</span></pre><p id="553b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在我的例子中，串行端口以<code class="du lg lh li kx b">/dev/tty.SLAB_USBtoUART</code>结束，然而你的可能会不同，这取决于你的操作系统。我们可以将它存储在一个环境变量中，这样会简单一些。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c851" class="lb ir hi kx b fi lc ld l le lf">export SERIALPORT="/dev/tty.SLAB_USBtoUART"</span></pre><p id="ede9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，您可以通过对设备进行检查来确认一切正常:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="852f" class="lb ir hi kx b fi lc ld l le lf">esptool.py —-port $SERIALPORT flash_id</span></pre><p id="f158" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这应该会打印出一些关于ESP32芯片的细节。</p><p id="743f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此时，我们准备擦除当前在板上的flash，并继续使用MicroPython刷新它。下面是完成这项工作的两个命令。[注意:这假定您的MicroPython文件在您的主目录下载文件夹中，并且您的串行端口可能与下面列出的不同]</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="201d" class="lb ir hi kx b fi lc ld l le lf">esptool.py —-chip esp32 —-port $SERIALPORT erase_flash</span><span id="4cc8" class="lb ir hi kx b fi lj ld l le lf">esptool.py —-chip esp32 —-port $SERIALPORT —-baud 460800 write_flash -z 0x1000 ~/Downloads/esp32–20190529-v1.11.bin</span></pre><p id="39f9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">完成后…成功！现在，您的ESP32板上已经安装了MicroPython。您可以使用ampy查看当前设备上的文件。应该只有一个名为boot.py的文件，每次设备启动时都会加载该文件。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="16e8" class="lb ir hi kx b fi lc ld l le lf">ampy —-port $SERIALPORT -—baud 115200 ls</span></pre><p id="7451" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在是生成RSA公钥/私钥对的时候了。您可以通过运行以下两个命令来实现这一点。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="56e6" class="lb ir hi kx b fi lc ld l le lf">openssl genrsa -out rsa_private.pem 2048</span><span id="f4aa" class="lb ir hi kx b fi lj ld l le lf">openssl rsa -in rsa_private.pem -pubout -out rsa_public.pem</span></pre><p id="c37d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这将输出两个文件<code class="du lg lh li kx b">rsa_private.pem</code>和<code class="du lg lh li kx b">rsa_public.pem</code>。在下一步中，您将需要这些，但请确保它们是私有的。</p><h1 id="0ff9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">配置谷歌云物联网核心</h1><p id="65ed" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们现在需要设置Google Cloud物联网核心，以便我们在配置设备时拥有所需的所有值。登录到https://console.cloud.google.com的<a class="ae kr" href="https://console.cloud.google.com" rel="noopener ugc nofollow" target="_blank"/>。如果您还没有帐户，可以免费试用。</p><p id="e8ed" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在左侧，您需要导航至“物联网核心”。如果这是您第一次，您需要启用API。</p><p id="3714" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，您需要创建一个注册表，并填写以下信息:</p><p id="4979" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">注册表ID </strong> —这是一个注册表，包含一个或多个您想要连接的设备。</p><p id="9b5f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">地区</strong> —选择最适合您的地区。在我的情况下，我将使用美国中心1，因为它离我最近。</p><p id="7b32" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">选择遥测和状态的发布/订阅主题。(您可以为每一项创建一个新的)</p><p id="a6d8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">创建注册表后，我们现在可以在注册表中为esp32板创建一个器件。转到“设备”，然后“创建新设备”。在本节中，我们将配置设备。给它一个唯一的设备ID，对于这个设置，我只是使用了类似<code class="du lg lh li kx b">esp32-dev-1</code>的东西，但是你可以使用任何你想要的ID。我们将保持默认值不变。</p><p id="4a07" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">设备通信—允许<br/>认证—手动输入<br/>公钥格式— RS256。</p><p id="fe34" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在公钥值中，我们将粘贴上一步中创建的文件<code class="du lg lh li kx b">rsa_public.pem</code>的内容。此时，我们可以单击“创建”,我们已经在Google Cloud端设置好了。</p><h1 id="7b99" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">设备设置</h1><p id="87ed" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">酷毙了。现在我们准备在这个设备上安装一些代码。为此，我们将使用下面的一些示例代码:<a class="ae kr" href="https://github.com/GoogleCloudPlatform/iot-core-micropython" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">https://github.com/GoogleCloudPlatform/iot-core-micropython</strong></a></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a8a2" class="lb ir hi kx b fi lc ld l le lf">git clone https://github.com/GoogleCloudPlatform/iot-core-micropython</span><span id="1ba7" class="lb ir hi kx b fi lj ld l le lf">cd iot-core-micropython/</span></pre><p id="1126" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在这个repo中将有一个名为<code class="du lg lh li kx b">config.py.example</code>的文件。这是一个模板配置，您需要用您的信息进行更新。当您到达<code class="du lg lh li kx b">jwt_config</code>部分时，我们将不得不做一些工作来使其工作。由于内存限制，我无法让pyasn1库在MicroPython的ESP32上运行。(但是，这在将来可能会改变)这用于将ASN.1数据类型编码和解码为PEM或DER格式，这是RSA使用的格式。为了解决这个问题，我们必须使用本地机器来解码私钥，并将密钥的组成部分存储在一个元组中。然后我们将把它用于RSA库。要读取这些值，您可以运行:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9665" class="lb ir hi kx b fi lc ld l le lf">pip install rsa</span><span id="36f1" class="lb ir hi kx b fi lj ld l le lf">python utils/decode_rsa.py</span></pre><p id="9823" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它应该在括号内输出5个(非常大的)整数。您需要将这个值复制并粘贴到<code class="du lg lh li kx b">private_key</code>值的<code class="du lg lh li kx b">jwt_config</code>部分。更新完信息后，你需要将文件重命名为<code class="du lg lh li kx b">config.py</code>。</p><p id="8807" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，我们将使用<code class="du lg lh li kx b">ampy</code>将文件复制到设备。我们将通过发出以下3个命令来实现这一点。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d36f" class="lb ir hi kx b fi lc ld l le lf">ampy —-port $SERIALPORT —-baud 115200 put lib</span><span id="08fb" class="lb ir hi kx b fi lj ld l le lf">ampy —-port $SERIALPORT —-baud 115200 put config.py</span><span id="ba5b" class="lb ir hi kx b fi lj ld l le lf">ampy —-port $SERIALPORT —-baud 115200 put main.py</span></pre><p id="708c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您可以使用<code class="du lg lh li kx b">ampy</code> ls命令来验证文件是否在板上。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f09b" class="lb ir hi kx b fi lc ld l le lf">ampy —-port /dev/tty.SLAB_USBtoUART —-baud 115200 ls</span><span id="27f9" class="lb ir hi kx b fi lj ld l le lf">/boot.py<br/>/config.py<br/>/lib<br/>/main.py</span></pre><p id="fd2f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此时，您可以重置您的电路板，并使用screen查看输出。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cbeb" class="lb ir hi kx b fi lc ld l le lf">screen -L /dev/tty.SLAB_USBtoUART 115200 -L</span></pre><p id="4202" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果一切顺利，您应该会看到如下所示的输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0e46" class="lb ir hi kx b fi lc ld l le lf">Publishing message {“temp”: 113, “device_id”: “esp32-oled-1”}<br/>Publishing message {“temp”: 114, “device_id”: “esp32-oled-1”}<br/>Publishing message {“temp”: 114, “device_id”: “esp32-oled-1”}</span></pre><h1 id="ebcb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">包扎</h1><p id="1db9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">恭喜你！现在，您的设备正在向物联网核心发送数据。您可以通过打开云shell并运行以下命令来查看消息:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4d1c" class="lb ir hi kx b fi lc ld l le lf">gcloud pubsub subscriptions pull —-limit=10 —-auto-ack projects/[your-project-id]/subscriptions/[your-subscription-id]</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/7cce4ed621c225cb64a3ad79d97e6f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iBPUUO9EeQhrUn9p"/></div></div></figure></div></div>    
</body>
</html>