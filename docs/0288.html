<html>
<head>
<title>Google Cloud Functions, follow up.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云功能，跟进。</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-functions-follow-up-f9c6e4b9694b?source=collection_archive---------2-----------------------#2017-05-18">https://medium.com/google-cloud/google-cloud-functions-follow-up-f9c6e4b9694b?source=collection_archive---------2-----------------------#2017-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c5af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">功能即服务是一个惊人的概念。这种暗示起初可能看起来不明显，但是有很多。</p><p id="c83f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章(<a class="ae jd" rel="noopener" href="/google-cloud/creating-a-mongodb-crud-backend-on-google-cloud-functions-88bb5c1cef77">https://medium . com/Google-cloud/creating-a-mongodb-crud-back end-on-Google-cloud-functions-88 bb 5 C1 cef 77</a>)中，我试图展示使用GCF从MongoDB数据库中存储和检索数据来实现后端API是多么容易。在这样做的时候，我想我把巴贝利斯(【http://babeljs.io/】)加入进来，把必要的步骤搞得有点复杂了。</p><p id="5609" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拥有ES6特性是很好的，但是对于所示的例子来说并不是必需的。我认为，除非你想要一些漂亮的ES6特性(导入、异步/等待等)或者使用Flow(【https://flow.org/】)来添加静态类型检查。</p><p id="545d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je"> index.js </em>和<em class="je"> package.json </em>的简化版本是:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jk jl l"/></div></figure><p id="9c0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及<em class="je"> package.json </em>:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="a213" class="jr js hi jn b fi jt ju l jv jw">{<br/>  "name": "gcf-hello",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "deploy": "gcloud beta functions deploy hello-world --entry-point handler --trigger-http --stage-bucket medium-post-functions --memory=256MB"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "dotenv": "^4.0.0",<br/>    "mongodb": "^2.2.26"<br/>  }<br/>}</span></pre><p id="3020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更简单对吗？</p><p id="d57d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在写这篇文章时，出现了几个考虑因素，包括版本、内存选择、NPM包、URL、本地运行时、配置/环境等。我会试着在这里集合他们。</p><h2 id="05d0" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">用于部署的打包</h2><p id="29dc" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">部署脚本的第一步是打包我们的云函数根文件夹(您也可以使用`— local-path '参数来指定不同的根文件夹)。当然，<em class="je"> node_modules </em>文件夹没有打包，但是，遗憾的是，其他文件夹都打包了，比如<em class="je">。git </em>(这大概是我个人在GCF的bug追踪上备案的一个bug)。为什么这很重要？<em class="je">。git </em>文件夹往往会随着时间的推移而增长，随着时间的推移会增加到兆字节。不幸的是，这使得我们的部署包比它们应该的要大。他们也有一个250Mb的限制，使部署速度较慢。</p><p id="d088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的观点是，我们应该能够控制是否包含在我们正在部署的包中。</p><p id="2366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想查看部署中打包了什么，只需使用<em class="je"> gsutil </em>命令将包从GC上的deploy bucket复制到您的本地机器上:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="7f18" class="jr js hi jn b fi jt ju l jv jw">$ gsutil cp gs://path-to-file.zip .</span></pre><p id="d76c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次成功部署后，都会显示<em class="je">文件路径</em>部分。这是一个普通的zip文件，所以你可以自己试一下，看看里面都有什么。</p><h2 id="b17b" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">NPM或纱或…</h2><p id="0ddf" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">由于部署包中没有包含<em class="je"> node_modules </em>文件夹<em class="je"> </em>和<em class="je"> </em>，我们必须假设GCF平台会在部署过程中安装我们的函数依赖项。这实际上并不是一件坏事，可以加快部署速度。缺点是现在我们实际上不能控制如何安装这些依赖项。更重要的是，当我们现在有几种选择来做这件事的时候，<strong class="ih hj"> NPM </strong>是默认的和最常用的，而<strong class="ih hj">纱</strong>(我个人更喜欢)。</p><p id="7b67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我找不到GCF使用的是哪一个，但是，经过反复试验，我必须假设这两个都不是。NPM和Yarn都支持使用(git+ssh)语法从git安装软件包。我试了一下，发现它失败了，并显示了一条神秘的错误消息。(对此也有一个bug备案)。</p><p id="93df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，目前我们可以猜测是NPM，但是，也缺乏对私人回购的支持。因此，向其他一些包中添加私有函数依赖甚至是分叉仍然很困难。</p><h2 id="9414" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">版本控制和/或标记</h2><p id="a533" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">GCF缺乏对版本和/或标记的支持。但是，因为我们可以用自定义名称来命名我们的函数，所以这不是什么大问题。我们完全可以在函数名上使用微格式来表示版本，比如:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="e854" class="jr js hi jn b fi jt ju l jv jw">$ gcloud beta functions deploy hello-world-0_1_4 --entry-point handler --trigger-http --stage-bucket medium-post-functions --memory=256MB</span></pre><p id="d1b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我没有在版本号上使用点。</p><p id="e2cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"函数名必须只包含小写拉丁字母、数字和连字符(-)。它必须以字母开头，不得以连字符结尾，并且长度不得超过63个字符。</p><p id="d0f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们可以有这样一个端点:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="6fe8" class="jr js hi jn b fi jt ju l jv jw">https://us-central1-revelatio-165320.cloudfunctions.net/hello-world-0_1_4</span></pre><p id="8fa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来这其实是件好事。</p><h2 id="a107" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">URL路由和其他请求属性</h2><p id="9143" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">因为我们正在编写一个HTTP函数，所以我们可以访问常规的请求属性。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="44ef" class="jr js hi jn b fi jt ju l jv jw">{<br/>  "httpVersionMajor": 1,<br/>  "httpVersionMinor": 1,<br/>  "httpVersion": "1.1",<br/>  "headers": {<br/>    "host": "us-central1-revelatio-165320.cloudfunctions.net",<br/>    "user-agent": "curl/7.43.0 AppEngine-Google; (+http://code.google.com/appengine; appid: s~gcf-http-proxy)",<br/>    "accept": "*/*",<br/>    "function-execution-id": "iwwhmh5om3tq",<br/>    "x-appengine-api-ticket": "c8972c61af61e994",<br/>    "x-appengine-city": "san francisco",<br/>    "x-appengine-citylatlong": "37.774929,-122.419416",<br/>    "x-appengine-country": "ZZ",<br/>    "x-appengine-https": "on",<br/>    "x-appengine-inbound-appid": "gcf-http-proxy",<br/>    "x-appengine-region": "ca",<br/>    "x-appengine-user-ip": "0.1.0.40",<br/>    "x-cloud-trace-context": "d4106ea1f08a0ec355e6014fcc600464/18238227398167355466",<br/>    "x-forwarded-for": "2607:f598:b199:eb00:1919:d4c:c1e0:c4e0",<br/>    "x-zoo": "app-id=gcf-http-proxy,domain=gmail.com,host=*.cloudfunctions.net",<br/>    "accept-encoding": "gzip"<br/>  },<br/>  "url": "",<br/>  "method": "GET",<br/>  "baseUrl": "",<br/>  "originalUrl": "",<br/>  "params": {<br/>    "0": ""<br/>  },<br/>  "query": {},<br/>  "body": {}<br/>}</span></pre><p id="b2e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不错啊。我们可以直接使用<strong class="ih hj"> req.body </strong>(就像我们在上一篇文章中看到的)来访问发布的和数据。<strong class="ih hj"> req.url、req.params、req.query </strong>和<strong class="ih hj"> req.method </strong>也做一些基本的路由。但是，由于我们无法访问更高级的上下文应用程序(比如在Expressjs中),所以我们需要在单个函数中完成所有的路由。这方面有一些好的库，微路由器(<a class="ae jd" href="https://www.npmjs.com/package/microrouter" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/microrouter</a>)是我关注的一个。它甚至支持async/await，因此为我们的路由创建异步处理程序变得很容易。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jk jl l"/></div></figure><p id="6287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的HTTP函数的根路径将在req.url中作为空字符串传递给我们，所以如果您使用某种路由库，请确保包含这种情况，否则您的函数将超时并失败。</p><h2 id="8041" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">部署配置/环境</h2><p id="7fae" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在部署我们的HTTP函数时，还没有办法定义环境属性，例如MongoDB数据库连接参数。在我们找到最终的解决方案之前，我们可以使用<em class="je">dotenv</em>(【https://www.npmjs.com/package/dotenv】T2)一个简单的nodejs包从一个文件(通常是<em class="je">)加载属性。env </em>)变成<em class="je"> process.env. </em> <strong class="ih hj">我们只需要记住不要版本。环境文件</strong></p><h2 id="37e4" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">内存就是钱！</h2><p id="a7d6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">到目前为止，我一直使用分配内存中第二低的内存值来部署我的函数。所有可能的值为:128MB、256MB、512MB、1024MB和2048MB。这意味着什么？我如何选择我的函数需要多少内存？</p><p id="af73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是……看情况。取决于你的功能。很高兴看到约束消失，GCF随着时间的推移自动建议并使用我的函数可能需要的最佳内存参数。</p><p id="9442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直观上，我们可以测试响应时间来进行选择。Apache Bench是一种简单的方法，如果您愿意，也可以手动完成。只需获取云函数日志，查看您的函数响应需要多长时间。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/f8a9d4cc7006d77df70e46cd87accaca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPLOZUfgHyP2NlNxln-w7g.png"/></div></div></figure><p id="c4d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，我们有2057 ms到877 ms运行我们的函数，分配了256Mb内存。</p><p id="4a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将内存分配增加到2048MB会怎么样？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lc"><img src="../Images/12e68b02c17b993d36b2500b9ffb559b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVYhYW7Ec9ynAx_O5KpFlQ.png"/></div></div></figure><p id="3f31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，我们有更快的执行功能。请注意，账单在这里很重要。您可以使用Google Cloud提供的估算计算器，根据不同的参数集来计算成本。</p><p id="cd08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">《出埃及记》在aprox 700 ms中运行并且具有2Mb网络带宽的2048MB函数的100万次调用花费大约257美元，而在aprox 1500 ms中运行256MB的相同函数花费大约237美元</p><p id="efb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于<a class="ae jd" href="https://cloud.google.com/functions/pricing" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/functions/pricing</a>定价的更详细信息</p><h2 id="2607" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">记录</h2><p id="a811" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">这个很简单，每个<strong class="ih hj">控制台. log </strong>或<strong class="ih hj">控制台. error </strong>都会被记录。不错！</p><h2 id="b443" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">本地运行时</h2><p id="2e98" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">如果我想在本地运行我的函数呢？提供了一个本地仿真器。这辆车有点大，但很好用。</p><div class="ld le ez fb lf lg"><a href="https://cloud.google.com/functions/docs/emulator" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hj fi z dy ll ea eb lm ed ef hh bi translated">云函数本地仿真器|云函数文档| Google云平台</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">云函数仿真器是一个Node.js应用程序，它实现了云函数REST和gRPC APIs，并且…</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">cloud.google.com</p></div></div></div></a></div><p id="4b1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，命令<strong class="ih hj">函数</strong>已经存在，所以我必须将模拟器重命名为<strong class="ih hj"> gfunctions。</strong></p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="5091" class="jr js hi jn b fi jt ju l jv jw">$ <strong class="jn hj">gfunctions start</strong></span><span id="fd65" class="jr js hi jn b fi lp ju l jv jw">Starting Google Cloud Functions Emulator...<br/>Google Cloud Functions Emulator STARTED</span><span id="ce00" class="jr js hi jn b fi lp ju l jv jw">$ <strong class="jn hj">gfunctions deploy hello-world -e handler --trigger-http</strong></span><span id="812e" class="jr js hi jn b fi lp ju l jv jw">Copying file:///var/folders/f9/_xttz7rs7t10grd6_q_8s1dr0000gn/T/us-central1-hello-world-62471iys5P7qVjGo7.zip...<br/>Waiting for operation to finish...done.<br/>Deploying function.......done.<br/>Function hello-world deployed.<br/>Name        │ hello-world                                                                                           <br/>Entry Point │ handler<br/>Trigger     │ HTTP<br/>Resource    │ <a class="ae jd" href="http://localhost:8010/revelatio-165320/us-central1/hello-world" rel="noopener ugc nofollow" target="_blank">http://localhost:8010/revelatio-165320/us-central1/hello-world</a><br/>Timeout     │ 60 seconds<br/>Local path  │ /Users/ernestofreyre/Documents/revelatio/gcf-hello<br/>Archive     │ file:///var/folders/f9/_xttz7rs7t10grd6_q_8s1dr0000gn/T/us-central1-hello-world-62471iys5P7qVjGo7.zip</span><span id="3966" class="jr js hi jn b fi lp ju l jv jw">$ <strong class="jn hj">curl </strong><a class="ae jd" href="http://localhost:8010/revelatio-165320/us-central1/hello-world" rel="noopener ugc nofollow" target="_blank"><strong class="jn hj">http://localhost:8010/revelatio-165320/us-central1/hello-world</strong></a></span><span id="e7c2" class="jr js hi jn b fi lp ju l jv jw">[{"_id":"591bf40e734d1d38b5b63d51","name":"Ernesto Freyre","email":"<a class="ae jd" href="mailto:ernestofreyreg@gmail.com" rel="noopener ugc nofollow" target="_blank">ernestofreyreg@gmail.com</a>"}]</span><span id="05e0" class="jr js hi jn b fi lp ju l jv jw">$</span></pre><h2 id="a2d4" class="jr js hi bd jx jy jz ka kb kc kd ke kf iq kg kh ki iu kj kk kl iy km kn ko kp bi translated">最后删除</h2><p id="818c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">是的，我的好东西应该是删除一个不再需要的功能。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="5c11" class="jr js hi jn b fi jt ju l jv jw">$ gcloud beta functions delete hello-world-0_1_4</span></pre><p id="6ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我希望GCF走出beta版的不确定性。谷歌应该加大油门，扩大他们的GCF产品。更多的语言(当然要去)，更好的文档和更多的内部细节。</p></div></div>    
</body>
</html>