<html>
<head>
<title>Docker Swarm on Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云平台上的Docker Swarm</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/docker-swarm-on-google-cloud-platform-c9925bd7863c?source=collection_archive---------0-----------------------#2016-06-23">https://medium.com/google-cloud/docker-swarm-on-google-cloud-platform-c9925bd7863c?source=collection_archive---------0-----------------------#2016-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2a7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的<a class="ae jd" href="https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/" rel="noopener ugc nofollow" target="_blank"> Docker 1.12版本</a>发生了一些有趣的事情。Docker正在将Swarm捆绑到Docker本身，同时用更成熟的容器编排能力升级Swarm。</p><p id="bd89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swarm现在加入了<a class="ae jd" href="http://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>、<a class="ae jd" href="http://mesos.apache.org/" rel="noopener ugc nofollow" target="_blank"> Mesos </a>和<a class="ae jd" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> Nomad </a>的行列，成为一个成熟的编排引擎。有了这些新的编排能力，我想再看看Swarm。我也喜欢“虫群”这个名字；)</p><p id="2466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swarm在谷歌云上还没有现成的选项。希望这很快被添加，但在此之前，让我们看看如何在Google云平台上手动设置一个Swarm集群。</p><p id="4d84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总而言之，您应该在大约15分钟内拥有一个全功能的Swarm集群！</strong></p><p id="d8d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，Google Compute Engine在配置虚拟机方面非常快，如果您并行运行节点创建和设置，您可以在大约五分钟内创建一个集群！疯狂的快！</p><blockquote class="je"><p id="665b" class="jf jg hi bd jh ji jj jk jl jm jn jc dx translated"><a class="ae jd" href="https://github.com/thesandlord/google-cloud-swarm" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">使用此脚本进行全自动安装</strong> </a> <strong class="ak">！</strong></p></blockquote><p id="ce6f" class="pw-post-body-paragraph if ig hi ih b ii jo ik il im jp io ip iq jq is it iu jr iw ix iy js ja jb jc hb bi translated"><strong class="ih hj"> <em class="jt">注:</em> </strong> <em class="jt"> Swarm 1.12还很年轻。文档很少，并且仍在发展。我希望情况很快会好转。</em></p><h1 id="acd6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">先决条件</h1><p id="0463" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">你需要Docker 1.12来获得升级的Swarm特性。以下是我所知道的:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5728" class="lg jv hi lc b fi lh li l lj lk">$ docker -v<br/>Docker version 1.12.0-rc2, build 906eacd, experimental</span><span id="d993" class="lg jv hi lc b fi ll li l lj lk">$ docker-machine -v<br/>docker-machine version 0.8.0-rc1, build fffa6c9</span></pre><p id="6e1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你还需要安装<a class="ae jd" href="http://cloud.google.com/sdk" rel="noopener ugc nofollow" target="_blank">谷歌云SDK </a>，以及一个<a class="ae jd" href="http://console.cloud.google.com/project" rel="noopener ugc nofollow" target="_blank">谷歌云项目</a>。完成后，请确保登录:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="1809" class="lg jv hi lc b fi lh li l lj lk">$ gcloud init</span></pre><h1 id="6709" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创造蜂群</h1><p id="dc2f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">第一步是创建群节点。</p><p id="60c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想情况下，您将使用一个<a class="ae jd" href="https://cloud.google.com/compute/docs/instance-groups/" rel="noopener ugc nofollow" target="_blank">托管实例组</a>，但是我将把它留到另一个教程中。</p><p id="847f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个管理节点和一个工作节点。</p><h2 id="c64c" class="lg jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">管理器节点设置</h2><p id="6624" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用docker-machine创建管理器节点:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="3776" class="lg jv hi lc b fi lh li l lj lk">$ docker-machine create swarm-manager \<br/>    --engine-install-url experimental.docker.com \<br/>    -d google \<br/>    --google-machine-type n1-standard-1 \<br/>    --google-zone us-central1-f \<br/>    --google-disk-size "500" \<br/>    --google-tags swarm-cluster \<br/>    --google-project &lt;YOUR_PROJECT_ID&gt;</span></pre><p id="712e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用您的项目ID替换<your_project_id>。还可以随意更改区域、机器类型和磁盘大小。要做的重要事情是用“swarm-cluster”标记这个实例，这将让我们稍后打开防火墙端口。</your_project_id></p><p id="1723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约五分钟后，管理器将被创建。</p><p id="02e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要将这台机器设置为群组管理器</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="004f" class="lg jv hi lc b fi lh li l lj lk">$ eval $(docker-machine env swarm-manager)<br/>$ docker swarm init</span></pre><p id="660a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的经理现已创建！</p><h2 id="b0b4" class="lg jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">工作节点设置</h2><p id="843c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">以与管理器相同的方式创建一个工作节点:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="fe9c" class="lg jv hi lc b fi lh li l lj lk">$ docker-machine create swarm-worker-1 \<br/>    --engine-install-url experimental.docker.com \<br/>    -d google \<br/>    --google-machine-type n1-standard-1 \<br/>    --google-zone us-central1-f \<br/>    --google-disk-size "500" \<br/>    --google-tags swarm-cluster \<br/>    --google-project &lt;YOUR_PROJECT_ID&gt;</span></pre><p id="4d33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要获得经理的IP地址，这样我们就可以加入群。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="c2b7" class="lg jv hi lc b fi lh li l lj lk">$ gcloud compute instances list<br/>NAME           ZONE          MACHINE_TYPE  INTERNAL_IP EXTERNAL_IP<br/>swarm-manager  us-central1-f n1-standard-1 10.240.0.0  130.x.x.x<br/>swarm-worker-1 us-central1-f n1-standard-1 10.240.0.1  104.x.x.x </span></pre><p id="fda3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用群管理器的内部IP将您的工人连接到群。默认网络设置会打开内部子网上的所有端口，这样您就不必扰乱防火墙规则。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6fe3" class="lg jv hi lc b fi lh li l lj lk">$ eval $(docker-machine env swarm-worker-1)<br/>$ docker swarm join &lt;SWARM_MANAGER_INTERNAL_IP&gt;:2377</span></pre><p id="5d4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复这些步骤，将更多的工人添加到群体中。</p><p id="8040" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重新登录群管理器，开始执行命令。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="281b" class="lg jv hi lc b fi lh li l lj lk">$ eval $(docker-machine env swarm-manager)</span></pre><p id="35e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，您可以看到群中的所有节点:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0f2c" class="lg jv hi lc b fi lh li l lj lk">$ docker node ls<br/>ID    NAME           MEMBERSHIP STATUS AVAILABILITY MANAGER STATUS<br/>xxx * swarm-manager  Accepted   Ready  Active       Leader<br/>yyy   swarm-worker-1 Accepted   Ready  Active</span></pre><p id="0a1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集群设置已经完成！</p><h1 id="e03d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创建服务</h1><p id="c0d5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">创建服务很简单。这基本上和你在普通Docker中使用的命令是一样的。</p><p id="87bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，要在端口80上启动一台nginx服务器，请运行:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="9567" class="lg jv hi lc b fi lh li l lj lk">$ docker service create --replicas 1 -p 80:80/tcp --name nginx nginx</span></pre><p id="4cc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到这个过程在运行。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="a4d8" class="lg jv hi lc b fi lh li l lj lk">$ docker service ls<br/>ID            NAME   REPLICAS  IMAGE  COMMAND<br/>2umwwwc6tu9d  nginx  1/1       nginx</span></pre><p id="22dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swarm将确保副本始终运行。我们还可以使用一个命令来增加或减少副本的数量:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="a622" class="lg jv hi lc b fi lh li l lj lk">$ docker service scale nginx=10</span></pre><p id="6e05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很酷的东西！您可以做更复杂的事情，但是文档很少。<a class="ae jd" href="https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/" rel="noopener ugc nofollow" target="_blank">发布博文</a>拥有迄今为止最好的信息。</p><h1 id="9b0f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">公开服务</h1><p id="3d15" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在你有nginx在你的群中运行，你必须向外界开放它。默认情况下，Swarm将在Swarm中的每个节点上的指定端口上公开服务。这非常类似于用NodePort 在Kubernetes中创建一个<a class="ae jd" href="http://kubernetes.io/docs/user-guide/services/#type-nodeport" rel="noopener ugc nofollow" target="_blank">服务。我们需要暴露这个端口！</a></p><p id="31c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt">补充说明:我真的希望Docker增加对谷歌云平台的本地支持，这样这些东西就可以自动运行，就像它们在Kubernetes中的功能一样。</em></p><h2 id="e93c" class="lg jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">选项1 —公开单个节点:</h2><p id="d956" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">最简单的方法是打开一个节点上的端口，并为您的网站或服务使用该节点的IP地址。</p><p id="f76e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于只有一个经理和几个工人的小型集群，我会使用这个选项。</p><p id="f6c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开Swarm实例上的端口</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="59f4" class="lg jv hi lc b fi lh li l lj lk">$ gcloud compute firewall-rules create nginx-swarm \<br/>  --allow tcp:80 \<br/>  --description "nginx swarm service" \<br/>  --target-tags swarm-cluster</span></pre><p id="dded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在获取节点的外部IP地址。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="78e8" class="lg jv hi lc b fi lh li l lj lk">$ gcloud compute instances list<br/>NAME           ZONE          MACHINE_TYPE  INTERNAL_IP EXTERNAL_IP<br/>swarm-manager  us-central1-f n1-standard-1 10.240.0.0  130.x.x.x<br/>swarm-worker-1 us-central1-f n1-standard-1 10.240.0.1  104.x.x.x</span></pre><p id="6fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用其中一个节点的外部IP来访问您的服务。我建议使用经理的IP地址。</p><h2 id="3e94" class="lg jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">选项2—循环域名系统:</h2><p id="3226" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用与选项一相同的步骤，您可以将<em class="jt">所有</em>外部IP地址与<a class="ae jd" href="https://en.wikipedia.org/wiki/Round-robin_DNS" rel="noopener ugc nofollow" target="_blank">循环DNS </a>一起使用。这基本上给了你一种免费的负载平衡形式！唯一的问题是，如果您开始在集群中删除或添加节点，每次都需要更新DNS设置。DNS客户端也大量缓存，因此如果您缩小规模，您的用户可能会遇到不再存在的节点。</p><p id="8397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果您有多个管理器，我会使用这种方法来提供一种简单的负载平衡和容错形式。</strong></p><h2 id="3b95" class="lg jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">选项3— Google云负载平衡器:</h2><p id="24bd" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是最健壮的，但也是最复杂的公开服务的方法。当你创建一个网络负载平衡器时，你得到一个单一的IP地址，但是流量被发送到集群中的所有节点。此外，您可以设置运行状况检查，以便在某个节点出现故障时，不会向其发送流量。</p><p id="2aac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要最好的可靠性，或者拥有可能分布在多个区域以实现高可用性的较大集群，我推荐这个选项。</p><p id="35e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将设置一个<a class="ae jd" href="https://cloud.google.com/compute/docs/load-balancing/network/" rel="noopener ugc nofollow" target="_blank"> TCP负载均衡器</a>。如果适合您的服务，您还可以设置一个更强大的<a class="ae jd" href="https://cloud.google.com/compute/docs/load-balancing/http/" rel="noopener ugc nofollow" target="_blank"> HTTPS负载平衡器</a>。</p><p id="a94f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然你可以在命令行上这样做，但我觉得用户界面更直观。</p><p id="da12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开<a class="ae jd" href="http://console.cloud.google.com/networking/loadbalancing/list" rel="noopener ugc nofollow" target="_blank">负载平衡器页面</a>。</p><p id="1770" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单击“创建负载平衡器”</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lz"><img src="../Images/6d46a76750e371dd8c9d0cb5e22cef3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ1-5Q6tjQDAHbu46sjUnA.png"/></div></div></figure><p id="da84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，单击TCP负载平衡器的“开始配置”</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lz"><img src="../Images/27ddaa5a90a4bdee07d2a82b947dc540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sno6SxcllYXrtb839zTcYg.png"/></div></div></figure><p id="2818" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为您的负载平衡器命名</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lz"><img src="../Images/e56b225f6e2c8f6edf6b8f6da13f62c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qt-B0V565uJW8Va1i8jU1A.png"/></div></div></figure><p id="a0fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在点击“后端配置”</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lz"><img src="../Images/ac25352af8cf48748fd491a458413656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oso0NC6ypffHM4URBIAoCw.png"/></div></div></figure><p id="f64e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择你的群所在的区域，然后点击“选择现有实例”添加所有的群节点。</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mh"><img src="../Images/5db85f9744867f908cf108a573cb98a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujoXvPBPChBuH3L4crPXlA.png"/></div></div></figure><p id="3153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在创建一个健康检查。</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mi"><img src="../Images/b0ba01391ce5aa535918ffac6966ed4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DN2EoJf4azHKK64KmgbbzQ.png"/></div></div></figure><p id="e587" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给你的健康检查一个名字，并配置你认为合适的数字。我使用了默认值。我们将每5秒钟ping端口nginx服务所在的位置),以确保节点是健康的。保存并继续。</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lz"><img src="../Images/f255a4b38dcba61370f27b8a14970300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZfj9tssd64U2HLLdL4Pgw.png"/></div></div></figure><p id="c524" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在转到前端配置，并为您的Swarm服务指定端口。</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lz"><img src="../Images/c995c566d04703b543fe98c530c09d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hi-fRsawYBupyb3OEUs5qA.png"/></div></div></figure><p id="d7de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，单击“Create”，负载平衡器将在几分钟后启动。</p><p id="f286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下命令获取负载平衡器的IP地址:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2b4d" class="lg jv hi lc b fi lh li l lj lk">$ gcloud compute forwarding-rules list<br/>NAME        REGION      IP_ADDRESS      IP_PROTOCOL TARGET<br/>nginx-swarm us-central1 104.xxx.xxx.xxx TCP         xxx</span></pre><h1 id="6e1b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="0db0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有了Docker的1.12新版本，Swarm非常容易安装和使用。一旦正式发布，那就更轻松了。Docker团队做得很好！</p><p id="864d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望Docker添加更多的文档和示例，我真的希望他们添加对原生Google Cloud特性的支持，这样人们就不需要去摆弄防火墙和负载平衡器了！</p><p id="955d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还计划在Swarm和Kubernetes之间做一个比较。我发现有很多不同和相似之处。敬请关注！</p></div></div>    
</body>
</html>