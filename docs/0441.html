<html>
<head>
<title>Deploy Go application to Kubernetes in 30 seconds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在30秒内将Go应用程序部署到Kubernetes</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploy-go-application-to-kubernetes-in-30-seconds-ebff0f51d67b?source=collection_archive---------0-----------------------#2017-11-23">https://medium.com/google-cloud/deploy-go-application-to-kubernetes-in-30-seconds-ebff0f51d67b?source=collection_archive---------0-----------------------#2017-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ccf07ce777aaad16920cf1721468c164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyemvyVt7JI25k-_cTKMcg.png"/></div></div></figure><div class=""/><p id="0572" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我一直在用<a class="ae jo" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>编写一个简单的网络应用，托管在<a class="ae jo" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Cloud </a>，使用<a class="ae jo" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Google Kubernetes引擎</a>。这是一次非常棒的经历，我不能错过分享的机会。我花了不到一个小时的时间第一次设置好东西，阅读文档并试图弄清楚事情是如何工作的。但是，一旦我完成了，我可以在30秒内部署我的应用程序的新版本！</p><p id="63bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将要部署的应用程序是一个简单的RESTful内容服务器，是更大的微服务设置的一部分。它将暴露很少的API来发布和获取新闻。数据将存储在MySQL数据库中。不过，目前我将把数据库部分放在一边，只关注将应用程序交付给服务器。</p><p id="6f23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序配置在YAML文件中，该文件包含数据库DSN和一些其他参数。</p><p id="889e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">源代码可从<a class="ae jo" href="https://github.com/skolodyazhnyy/30-seconds-deployment" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。</p><h1 id="6745" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">部署</h1><p id="e75b" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们的部署流程将运行测试，构建二进制文件，将其打包到<a class="ae jo" href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/" rel="noopener ugc nofollow" target="_blank"> docker映像</a>，上传到<a class="ae jo" href="https://docs.docker.com/registry/" rel="noopener ugc nofollow" target="_blank"> docker注册表</a>，然后使用<a class="ae jo" href="https://kubernetes.io/docs/user-guide/kubectl-overview/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>将docker映像部署到<a class="ae jo" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群。</p><p id="0e12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先创建一个<a class="ae jo" href="https://www.gnu.org/software/make/manual/make.html#Overview" rel="noopener ugc nofollow" target="_blank"> Makefile </a>来保存每个部署步骤的指令。我喜欢Makefiles，它们简单却非常强大。Makefiles由<code class="du ks kt ku kv b">make</code>执行。这是一个轻量级的应用程序，几乎在任何地方都预装了它。</p><p id="bd6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要我们的构建、工件和部署的一些标识符，某种版本。我们可以使用语义版本控制或者顺序构建号，但是我发现使用git提交的散列更简单。它足够独特，有助于获得提交日志和工件之间的关系，并且最重要的是不需要太多的工作来生成。让我们在Makefile中定义一个变量来保存我们的版本名</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="cefb" class="le jq ht kv b fi lf lg l lh li">TAG?=$(shell git rev-list HEAD --max-count=1 --abbrev-commit)<br/><strong class="kv hu">export </strong>TAG</span></pre><p id="de0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用little <a class="ae jo" href="https://www.gnu.org/software/make/manual/html_node/Shell-Function.html" rel="noopener ugc nofollow" target="_blank"> shell magic </a>我们已经定义了标签变量，可以在运行make时手动设置，或者，如果没有设置，它将使用上次git提交的一个短散列(前7个符号)。然后，我们导出这个变量，这样它就可以在make运行的命令中使用。</p><h2 id="b368" class="le jq ht bd jr lj lk ll jv lm ln lo jz jb lp lq kd jf lr ls kh jj lt lu kl lv bi translated">试验</h2><p id="e7f5" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">通过运行测试来开始部署似乎是个好主意。它会阻止我们制造破碎的艺术品。让我们创建目标<code class="du ks kt ku kv b">test</code>，它将简单地运行<code class="du ks kt ku kv b">go test ./...</code>。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="f59e" class="le jq ht kv b fi lf lg l lh li">test:<br/>   go test ./...</span></pre><h2 id="cee2" class="le jq ht bd jr lj lk ll jv lm ln lo jz jb lp lq kd jf lr ls kh jj lt lu kl lv bi translated">建设</h2><p id="f7bc" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在，我们需要构建一个二进制文件。我们将定义<code class="du ks kt ku kv b">build</code>目标，它将简单地用很少的参数运行<code class="du ks kt ku kv b">go build</code>。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="bd1a" class="le jq ht kv b fi lf lg l lh li">build:<br/>   go build -ldflags "-X main.version=$(TAG)" -o news .</span></pre><p id="3c96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Go将构建一个二进制文件，静态链接运行它所需的一切。但是我们仍然需要一些可部署的单位，一些我们可以很容易分发的单位。这就是<a class="ae jo" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> docker </a>发挥作用的地方，<a class="ae jo" href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/" rel="noopener ugc nofollow" target="_blank"> docker图像</a>和<a class="ae jo" href="https://docs.docker.com/registry/" rel="noopener ugc nofollow" target="_blank"> docker注册表</a>非常适合我们的目标。</p><p id="3a41" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建<a class="ae jo" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>以便能够将我们的应用程序打包到docker映像中</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="417f" class="le jq ht kv b fi lf lg l lh li"><strong class="kv hu">FROM </strong>alpine:3.4<br/><br/><strong class="kv hu">RUN </strong>apk <strong class="kv hu">-</strong>U add ca-certificates<br/><br/><strong class="kv hu">EXPOSE </strong>8080<br/><br/><strong class="kv hu">ADD </strong>news <strong class="kv hu">/</strong>bin<strong class="kv hu">/</strong>news<br/><strong class="kv hu">ADD </strong>config.yml.dist <strong class="kv hu">/</strong>etc<strong class="kv hu">/</strong>news<strong class="kv hu">/</strong>config.yml<br/><br/><strong class="kv hu">CMD </strong>["news", "-config", "/etc/news/config.yml"]</span></pre><p id="f5b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以从头开始创建一个映像<a class="ae jo" href="https://docs.docker.com/engine/userguide/eng-image/baseimages/#create-a-simple-parent-image-using-scratch" rel="noopener ugc nofollow" target="_blank"/>，但是我更喜欢将<a class="ae jo" href="https://alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> alpine </a>作为基础映像，只需要几个额外的MB，我们就可以得到包管理器和<a class="ae jo" href="https://busybox.net/about.html" rel="noopener ugc nofollow" target="_blank"> busybox </a>。</p><p id="a9d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的映像构建过程安装<em class="lw"> ca-certificates </em>，公开端口8080，添加我们在上一步中构建的二进制文件，以及一些默认配置。最后，我们定义运行应用程序所需命令。</p><p id="085d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要Makefile中的另一个目标来构建docker映像。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="20eb" class="le jq ht kv b fi lf lg l lh li">pack: build<br/>   docker build -t gcr.io/myproject/news-service:$(TAG) .</span></pre><p id="d4f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在制作映像之前，构建一个二进制文件是很重要的，否则，docker构建会失败，或者会使用错误的应用程序版本。这就是为什么我们将<code class="du ks kt ku kv b">build</code>步骤定义为<code class="du ks kt ku kv b">pack</code>的依赖项。步骤本身将运行<code class="du ks kt ku kv b">docker build</code>并使用我们的标签变量标记图像。</p><p id="54c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我用的是<a class="ae jo" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">谷歌容器注册表</a>，因为它能更好地与其他谷歌云服务集成，但任何docker注册表都可以。</p><p id="c45f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是把我们的图像放到注册表中，让我们为它设定一个目标</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d75d" class="le jq ht kv b fi lf lg l lh li">upload:<br/>   docker push gcr.io/myproject/news-service:$(TAG)</span></pre><h2 id="404b" class="le jq ht bd jr lj lk ll jv lm ln lo jz jb lp lq kd jf lr ls kh jj lt lu kl lv bi translated">部署</h2><p id="07b9" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将把我们的应用程序部署到Kubernetes集群，有许多方法可以设置。您可以使用<a class="ae jo" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"> minikube </a>设置本地环境，或者使用<a class="ae jo" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> kops </a>在<a class="ae jo" href="https://aws.amazon.com" rel="noopener ugc nofollow" target="_blank"> AWS </a>中设置集群。我将使用<a class="ae jo" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a>，它很容易设置，并完全由<a class="ae jo" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云</a>管理。</p><p id="7488" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何设置Kubernetes集群并不重要，但在继续之前，请确保<code class="du ks kt ku kv b">kubectl</code>已连接到您想要用来部署应用程序的集群。</p><p id="ae49" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云中的应用程序需要一个配置文件，因此它知道如何连接到数据库和其他参数。我们可以在docker映像中放置适当的配置，但这并不实际。如果我们这样做，我们的映像将是环境感知的，更改配置将需要重建映像，如果我们希望将应用程序部署到不同的Kubernetes集群(例如，登台和生产环境)，我们将需要构建不同的映像。</p><p id="4362" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，我们将使用<a class="ae jo" href="https://kubernetes.io/docs/tasks/configure-pod-container/configmap/" rel="noopener ugc nofollow" target="_blank"> Kubernetes ConfigMap </a>，一个将保持我们的配置的对象。我们将把它作为一个文件安装在应用程序容器中。</p><p id="9a09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的部署过程将只部署应用程序容器。该配置将作为群集配置的一部分单独部署。</p><p id="c548" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我更喜欢单独保存配置，而不是和应用程序代码放在同一个存储库中。它应该是群集配置过程的一部分，而不是应用程序本身。</p><p id="cdbf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我的配置映射对象:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="a642" class="le jq ht kv b fi lf lg l lh li"><strong class="kv hu">kind: </strong>ConfigMap<br/><strong class="kv hu">apiVersion: </strong>v1<br/><strong class="kv hu">metadata:<br/>  name: </strong>news-config<br/><strong class="kv hu">data:<br/>  config.yml: </strong>|-<br/>    server:<br/>     idletimeout: 5s<br/>     readtimeout: 5s<br/>     writetimeout: 5s<br/>     addr: ":8080"<br/><br/>    database:<br/>     dsn: "proxyuser:password@(localhost:3306)/news"</span></pre><p id="f724" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用<code class="du ks kt ku kv b">kubectl apply -f configmap.yml</code>来部署它。或者，使用<code class="du ks kt ku kv b">kubectl create</code>命令创建ConfigMap，这不会有太大的区别。</p><p id="a839" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据我的经验，描述你在YAML的kubernetes资源是一个更好的选择。它允许你跟踪变化，你可以把它们存储在版本控制系统中。总的来说，YAML似乎比shell脚本中的一批<code class="du ks kt ku kv b">kubectl create</code>命令更加一致和明确。但是用你认为更合适的。</p><p id="c430" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们回到我们的应用程序，为我们的pod和服务创建一个定义。我将在我们的应用程序存储库中创建<code class="du ks kt ku kv b">k8s</code>文件夹，以跟踪运行我们的应用程序所需的所有kubernetes资源。</p><p id="0631" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们在文件<code class="du ks kt ku kv b">k8s/deployment.yml</code>中创建<a class="ae jo" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署</a></p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="9d15" class="le jq ht kv b fi lf lg l lh li"><strong class="kv hu">apiVersion: </strong>apps/v1beta1<br/><strong class="kv hu">kind: </strong>Deployment<br/><strong class="kv hu">metadata:<br/>  name: </strong>news<br/>  <strong class="kv hu">labels:</strong> {app: news}<br/><strong class="kv hu">spec:<br/>  replicas: </strong>1<br/>  <strong class="kv hu">template:<br/>    metadata: </strong>{labels: {app: news}}<br/>    <strong class="kv hu">spec:<br/>      containers:<br/>      </strong>- <strong class="kv hu">name: </strong>news<br/>        <strong class="kv hu">image: </strong>gcr.io/myproject/news-service:<strong class="kv hu"><em class="lw">${TAG}</em></strong><br/>        <strong class="kv hu">command:<br/>        ports:<br/>          </strong>- <strong class="kv hu">containerPort: </strong>8080<br/>        <strong class="kv hu">volumeMounts:<br/>          </strong>- <strong class="kv hu">name: </strong>news-config<br/>            <strong class="kv hu">mountPath: </strong>/etc/news/<br/>            <strong class="kv hu">readOnly: </strong>true<br/>      <strong class="kv hu">volumes:<br/>        </strong>- <strong class="kv hu">name: </strong>news-config<br/>          <strong class="kv hu">configMap:</strong> { name: news-config }</span></pre><p id="82f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它定义了应用程序所需的所有容器的规范。目前我们只需要一个容器，它将运行我们的应用程序映像。它将公开端口8080，我们将挂载之前部署的配置。</p><p id="0d26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我使用<code class="du ks kt ku kv b">${TAG}</code>占位符来定义容器图像，因为我们将为每个部署使用不同的标签。我们可以放入类似<code class="du ks kt ku kv b">latest</code>的东西，但是这样Kubernetes就看不到部署之间的区别，而且我们会引入关于我们想要部署什么的模糊性。相反，我更喜欢使用占位符和<code class="du ks kt ku kv b">envsubst</code>在部署期间用实际值替换占位符。</p><p id="6600" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要的另一个东西是Kubernetes服务，一个能够从外部访问我们的API的负载平衡器。所以，让我们在<code class="du ks kt ku kv b">k8s/deployment.yml </code>后面加上以下内容</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="f6f9" class="le jq ht kv b fi lf lg l lh li"><strong class="kv hu">---<br/>kind: </strong>Service<br/><strong class="kv hu">apiVersion: </strong>v1<br/><strong class="kv hu">metadata:<br/>  name: </strong>news<br/><strong class="kv hu">spec:<br/>  type: </strong>LoadBalancer<br/>  <strong class="kv hu">selector:<br/>    app: </strong>news<br/>  <strong class="kv hu">ports:<br/>  </strong>- <strong class="kv hu">protocol: </strong>TCP<br/>    <strong class="kv hu">port: </strong>80<br/>    <strong class="kv hu">targetPort: </strong>8080</span></pre><p id="11ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它定义了负载平衡器应该如何发现目标pods以及使用哪些端口。</p><p id="7c6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，就这样，我们准备将应用程序部署到集群中。让我们在Makefile中创建最后一个目标</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="6dea" class="le jq ht kv b fi lf lg l lh li">deploy:<br/>   envsubst &lt; k8s/deployment.yml | kubectl apply -f -</span></pre><p id="a2c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一步中，我们将使用<code class="du ks kt ku kv b">envsubst</code>将YAML中的占位符替换为实际值，然后使用<code class="du ks kt ku kv b">kubectl apply</code>将更改应用到集群。</p><p id="aaae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，让我们通过运行所有步骤来部署应用程序</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d385" class="le jq ht kv b fi lf lg l lh li">make test pack upload deploy</span></pre><p id="bc81" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者，我们可以定义另一个目标来运行所有步骤，这样您就不需要输入太多内容</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d90a" class="le jq ht kv b fi lf lg l lh li">ship: test pack upload deploy</span></pre><p id="aecc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了它，我们只需运行</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="4f97" class="le jq ht kv b fi lf lg l lh li">make ship</span></pre><p id="3441" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第一次部署之后，您需要等待Google Cloud(或其他Kubernetes提供商)来创建您的负载平衡器。运行<code class="du ks kt ku kv b">kubectl get service</code>获取负载平衡器外部IP。然后，在浏览器中输入这个IP，您应该会看到带有应用程序版本的JSON。</p><p id="7cb0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://github.com/skolodyazhnyy/30-seconds-deployment/blob/master/Makefile" rel="noopener ugc nofollow" target="_blank"> Github </a>查看完整的Makefile。</p><p id="4804" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在，让我们计时:)</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="9f73" class="le jq ht kv b fi lf lg l lh li">$ time make ship</span><span id="bf9c" class="le jq ht kv b fi lx lg l lh li">...<br/>real    0m23.103s<br/>user    0m3.622s<br/>sys     0m2.087s</span></pre><p id="0eff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">利润！我们实际上在不到30秒的时间内部署了新版本的应用程序。当然，随着应用程序的增长，您会添加更多的测试，事情会变得更加复杂，部署时间也会增加。但如果你问我，这仍然是一个很好的开始。</p></div></div>    
</body>
</html>