<html>
<head>
<title>Kubernetes 120: Networking Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 120:网络基础</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-120-networking-basics-3b903f13093a?source=collection_archive---------0-----------------------#2018-08-20">https://medium.com/google-cloud/kubernetes-120-networking-basics-3b903f13093a?source=collection_archive---------0-----------------------#2018-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8d66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您已经阅读了本系列的前一篇文章<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-110-your-first-deployment-bf123c1d3f8">，</a>,那么您现在应该已经有一个Gitea部署在您的集群上成功运行了。下一步是通过网络浏览器访问它。这篇文章将介绍一些基本的Kubernetes网络主题，并在这个过程中，使我们的Gitea容器可以通过公共互联网访问</p><h2 id="8638" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">开放集装箱港口</h2><p id="2571" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">默认情况下，pod基本上是与外界隔离的。为了将流量路由到我们的应用程序，我们需要打开我们计划用于容器的一组端口。</p><p id="c6ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的Gitea容器中的软件被设计成在端口3000上监听HTTP请求，在端口22上监听SSH连接(到克隆存储库)。让我们通过YAML文件打开容器中的这些端口:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="68ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将更新的文件应用到群集:</p><pre class="ke kf kg kh fd kl km kn ko aw kp bi"><span id="ddc0" class="je jf hi km b fi kq kr l ks kt">$ kubectl apply -f gitea.yaml</span></pre><p id="a5f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们应该能够运行<code class="du ku kv kw km b">kubectl describe deployment</code>来查看部署摘要中列出的新开放的端口。我们的pod应该打开端口3000和22进行连接。</p><pre class="ke kf kg kh fd kl km kn ko aw kp bi"><span id="2890" class="je jf hi km b fi kq kr l ks kt">$ kubectl describe deployment | grep Ports<br/>    Ports:        3000/TCP, 22/TCP</span></pre><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/e8cb9fb16808dad36d9b4216c671c0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SmTu4HGwrjOAV2AztQd1xQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">端口3000和22现在在容器本身上是开放的，但是还没有暴露给开放的互联网</figcaption></figure><h2 id="f7b7" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">使用端口转发进行调试</h2><p id="b500" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我们的容器上的端口现在应该是开放的，但是我们仍然需要一种方法来与集群中的pod通信。出于调试目的，我们可以使用<code class="du ku kv kw km b">kubectl port-forward</code>连接到我们的pod</p><pre class="ke kf kg kh fd kl km kn ko aw kp bi"><span id="dccf" class="je jf hi km b fi kq kr l ks kt"># grab the name of your active pod<br/>$ PODNAME=$(kubectl get pods --output=template \<br/>     --template="{{with index .items 0}}{{.metadata.name}}{{end}}")</span><span id="06f6" class="je jf hi km b fi li kr l ks kt"># open a port-forward session to the pod<br/>$ kubectl port-forward $PODNAME 3000:3000</span></pre><p id="fe21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，<code class="du ku kv kw km b">kubectl</code>会将本地机器上3000端口上的所有连接转发到云中运行的pod。如果您在web浏览器中打开<a class="ae jd" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，您应该能够与服务器进行交互，就像它在本地运行一样。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/0d5e3a4bf4486684d698ba55cdd84f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dK29wdVMg2Smn2ghenrhA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><em class="lj"> "kubectl port-forward" </em>在单个pod和您的本地主机之间创建一个临时的直接连接</figcaption></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lk"><img src="../Images/fc1163cb64185eee672b327146e650c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxNXFU_bKtQu-xijlVGAeA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">连接到<a class="ae jd" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>应该会显示Gitea注册页面</figcaption></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="6396" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">创建外部负载平衡器</h2><p id="fec2" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">现在我们知道我们的pod正在工作，让它可以访问公共互联网。为此，我们需要添加一个新的Kubernetes资源，它将提供一个公共的公共IP地址，并将传入的请求路由到我们的pod。这可以通过使用一个叫做服务的Kubernetes资源来实现。我们可以使用<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0">几种不同类型的服务</a>，但是对于我们的用例，我们将使用负载平衡器。<a class="ae jd" href="#7ab2" rel="noopener ugc nofollow"> </a></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="7a00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与部署一样，该服务使用选择器(第29–30行)。这个选择器告诉负载平衡器将流量路由到哪个pods。当负载平衡器收到请求时，它会智能地将负载分配给所有与选择器匹配的pods。在我们的例子中，负载平衡很容易，因为我们只有一个pod。</p><p id="8ce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第31–39行定义了负载平衡器管理的端口。除了唯一的名称和协议类型(TCP/UDP)之外，您还必须定义“端口”和“目标端口”。这两个字段定义了从外部IP上的端口(port)到容器使用的端口(targetPort)的映射。<a class="ae jd" href="#6a2a" rel="noopener ugc nofollow"> </a>在第33行和第34行，我们说负载均衡器将监听端口80(您的web浏览器用来查看网站的默认端口)上的请求，并将请求传递到我们的pod上的端口3000。</p><p id="387d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们需要将我们的更新应用到集群</p><pre class="ke kf kg kh fd kl km kn ko aw kp bi"><span id="b089" class="je jf hi km b fi kq kr l ks kt">$ kubectl apply -f gitea.yaml</span></pre><p id="77fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在等待几分钟传播您的更改后，检查您的服务</p><pre class="ke kf kg kh fd kl km kn ko aw kp bi"><span id="8aa9" class="je jf hi km b fi kq kr l ks kt">$ kubectl get service</span><span id="f3ee" class="je jf hi km b fi li kr l ks kt">NAME            TYPE           CLUSTER-IP     EXTERNAL_IP    AGE<br/>gitea-service   LoadBalancer   10.27.240.34   35.192.x.x     2m</span></pre><p id="a08d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几分钟后，您应该会看到一个外部IP自动添加到您的服务中。将此IP输入您的web浏览器，您就可以与pod托管的web服务器进行交互。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/debcae40a3bc48453648ba391130ef60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*achzuYXYoyAtfsSo2wx7XA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">新的负载平衡器公开了一个外部IP地址。端口80上的传入请求将被路由到Gitea pod上的端口3000。Gitea注册页面现在应该可以通过开放的互联网访问了。</figcaption></figure><h2 id="ee45" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">Pod间通信:集群IP服务</h2><p id="5622" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">如果你试着浏览一下Gitea注册页面，你会发现还缺少一些东西:Gitea需要一个数据库来运行。为了解决这个问题，我们可以在Gitea pod中添加一个MySQL容器作为<a class="ae jd" href="https://www.voxxed.com/2015/01/use-container-sidecar-microservices/" rel="noopener ugc nofollow" target="_blank">侧车</a>，或者我们可以单独为MySQL创建一个新的pod。<a class="ae jd" href="#b5ad" rel="noopener ugc nofollow"> </a>这两种方法可能各有利弊，取决于你的需求。出于本教程的目的，我们将创建一个新的pod。</p><p id="5891" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们启动一个名为<em class="ls"> mysql.yaml </em>的新YAML文件来管理数据库:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="37fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这其中的大部分应该看起来很熟悉。我们再次声明一个部署来管理我们的单个pod，并且我们通过一个服务来管理网络连接。在这种情况下，服务的类型是“cluster IP”；这仅仅意味着IP仅在集群内部公开，而不是像我们为Gitea服务所做的那样通过负载平衡器对外公开。</p><p id="b345" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将这个新的YAML文件应用到集群</p><pre class="ke kf kg kh fd kl km kn ko aw kp bi"><span id="4aeb" class="je jf hi km b fi kq kr l ks kt">$ kubectl apply -f mysql.yaml</span></pre><p id="7a2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您应该看到一个新的pod、部署和服务添加到了您的集群中</p><pre class="ke kf kg kh fd kl km kn ko aw kp bi"><span id="892c" class="je jf hi km b fi kq kr l ks kt">$ kubectl get pods<br/>NAME        READY     STATUS    RESTARTS   AGE<br/>gitea-pod   1/1       Running   0          9m<br/>mysql-pod   1/1       Running   0          9s</span><span id="4602" class="je jf hi km b fi li kr l ks kt">$ kubectl get deployments<br/>NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>gitea-deployment   1         1         1            1           11m<br/>mysql-deployment   1         1         1            1           5m</span><span id="b790" class="je jf hi km b fi li kr l ks kt">$ kubectl get services<br/>NAME            TYPE           CLUSTER-IP     EXTERNAL_IP    AGE<br/>gitea-service   LoadBalancer   10.27.240.34   35.192.x.x  2m<br/>mysql-service   ClusterIP      10.27.254.69   &lt;none&gt;         6m</span></pre><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/34491f84169ba76e1eebf0c9810c8006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTdLPGP2x40zfYvZ_-VvcA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">MySQL现在被部署为集群中的一个独立单元。它的ClusterIP服务可以由集群中的Gitea pod访问，但是它不会在公共互联网上公开</figcaption></figure><p id="a1f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ClusterIP服务将自动为我们生成一个内部IP地址，在控制台输出中列为“CLUSTER-IP”。集群中的任何容器都可以使用这个地址访问我们的MySQL pod。然而，直接使用这些内部IP地址是一种不好的做法。相反，Kubernetes有一个更简单的方法来访问我们的新服务:我们可以简单地在地址栏中输入“mysql-service”。这是因为一个名为<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" rel="noopener ugc nofollow" target="_blank">“kube-dns”</a>的内置pod，它管理所有服务的内部DNS解析。<a class="ae jd" href="#c3e8" rel="noopener ugc nofollow"> ⁴ </a>通过这种方式，您可以忽略短暂的内部IP地址，而是使用静态的、人类可读的服务名。</p><p id="769e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要允许Gitea与MySQL pod通信，只需在web UI的“host”字段中写入服务的名称和端口。如果一切正常，您应该会看到一个“拒绝访问”错误。这意味着我们的pod可以成功通信，但它们需要更多配置才能成功认证。敬请关注下一篇文章，了解如何做到这一点。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lt"><img src="../Images/9fbd596f891ca04ca6f2ccc4d69b99ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiZn3YSfPHCVVwymcWRRNw.png"/></div></div></figure><h2 id="05b2" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">下一步是什么</h2><p id="14fe" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">这篇文章介绍了Kubernetes网络的一些基础知识，包括容器端口、端口转发、负载平衡器和集群IP服务，以及kube-dns。当然，网络是一个巨大的话题，所以还有很多没有说。如果你想了解Kubernetes中网络是如何实现的，可以看看<a class="ae jd" rel="noopener" href="/google-cloud/understanding-kubernetes-networking-pods-7117dd28727">这个系列</a>。如果您对控制哪些pods可以在您的集群中通信感兴趣，您应该研究一下<a class="ae jd" href="https://github.com/ahmetb/kubernetes-network-policy-recipes" rel="noopener ugc nofollow" target="_blank">网络策略。</a>如果你想更好地控制服务之间的通信方式，可以考虑像<a class="ae jd" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>这样的服务网状产品。</p><p id="5da9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一如既往，在Medium和<a class="ae jd" href="https://twitter.com/DanSanche21" rel="noopener ugc nofollow" target="_blank"> Twitter (@DanSanche21) </a>上关注我，以便在有新文章发布时收到通知。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="fc92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">脚注</p><ol class=""><li id="7ab2" class="lu lv hi ih b ii ij im in iq lw iu lx iy ly jc lz ma mb mc bi translated"><a class="ae jd" href="#fec2" rel="noopener ugc nofollow"> ^ </a>负载平衡器在像GCP这样的云服务上工作得很好，但是如果你在<a class="ae jd" href="https://blog.docker.com/2018/01/docker-mac-kubernetes/" rel="noopener ugc nofollow" target="_blank"> Docker </a>或<a class="ae jd" href="https://kubernetes.io/docs/setup/minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>上运行本地集群，你可能需要使用<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank">节点端口服务</a>来代替</li><li id="6a2a" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><a class="ae jd" href="#8ce7" rel="noopener ugc nofollow"> ^ </a>面向外部的端口可以设置为任何值，但是请记住，如果您想使用非标准的方式访问，可能需要在GKE上设置<a class="ae jd" href="https://cloud.google.com/vpc/docs/firewalls" rel="noopener ugc nofollow" target="_blank">防火墙规则</a></li><li id="b5ad" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated"><a class="ae jd" href="#5622" rel="noopener ugc nofollow"> ^ </a>这里使用了MySQL，因为这是Gitea的设计初衷。MySQL是一个遗留服务，它并没有考虑到Kubernetes。如果您正在从头开始设计应用程序，可能有其他存储解决方案会更适合您。</li><li id="c3e8" class="lu lv hi ih b ii md im me iq mf iu mg iy mh jc lz ma mb mc bi translated">^管理着许多像这样的隐藏单元和服务。要查看它们，运行<code class="du ku kv kw km b">kubectl get pods --namespace=kube-system</code></li></ol></div></div>    
</body>
</html>