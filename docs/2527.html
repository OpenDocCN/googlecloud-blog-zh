<html>
<head>
<title>Running Terraform CICD pipelines On GCP with Gitlab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gitlab运行GCP的Terraform CICD管道</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/running-terraform-cicd-pipelines-on-gcp-with-gitlab-5611d3a87a46?source=collection_archive---------0-----------------------#2022-11-21">https://medium.com/google-cloud/running-terraform-cicd-pipelines-on-gcp-with-gitlab-5611d3a87a46?source=collection_archive---------0-----------------------#2022-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基础设施即代码已经迅速成为在云上调配和管理资源的默认流程。它快速、一致、易于复制并与GitOps结合，易于控制、跟踪和审计从源代码库中做出的更改。越来越多的团队开始使用IaC和CICD作为他们的基础设施。</p><p id="b955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，让我们看看如何利用GitOps和terraform来自动化Google云平台上的资源部署和管理。</p><h1 id="52d5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">先决条件</h1><ol class=""><li id="0951" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">对IaC、基本地形概念和命令有基本的了解</li><li id="8c70" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">Git和一般CICD机制的知识</li><li id="f207" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">有权创建实例的GCP项目和用户帐户以及服务帐户</li><li id="caf6" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">企业或SaaS Gitlab帐户，有权创建存储库和管道</li></ol><h1 id="5e49" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">设置</h1><ol class=""><li id="30a3" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">在计算引擎实例上运行的Gitlab实例。但是，这同样适用于公共Gitlab和内部托管版本(在网络方面做了一些改动)</li><li id="04b0" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">包含terraform代码的Gitlab存储库</li><li id="c943" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">一个Gitlab runner托管在docker上的一个计算引擎实例中。它将被配置为与支持CICD的存储库一起工作。这个runner实例应该具有到Gitlab实例的网络连接</li><li id="2b5e" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">Terraform代码将在此runner上执行，因此建议将其托管在GCP计算引擎实例上。这允许使用与实例相关联的基础服务帐户在GCP授权和创建资源。该实例应该启用了所需的API范围，并且具有必要的权限</li><li id="b9ad" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">如果运行者不在GCP上，则需要创建一个服务帐户密钥，并将其作为一个秘密变量传递给管道，以对terraform进行身份验证，这并不理想。在这种情况下，我们必须维护和旋转密钥</li></ol><h1 id="aaed" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">地形代码</h1><p id="1c12" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><a class="ae ku" href="https://github.com/kkram01/terraform-gitlab-cicd" rel="noopener ugc nofollow" target="_blank">代码库链接</a></p><p id="c980" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，我们将使用快照从永久磁盘创建计算映像。这是克隆迁移过程中经常出现的一个用例。</p><p id="ea78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个最佳实践，terraform状态在GCS bucket上作为远程后端进行管理，支持开箱即用的状态锁定。</p><h1 id="045d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">工作流程和管道概述</h1><p id="3f93" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">下面的例子为CICD工作流使用了Github分支策略。更多关于这个和各种git分支策略的详细信息<a class="ae ku" href="https://www.flagship.io/git-branching-strategies/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="916a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，Github流有两个分支。主分支和基于主分支的特征分支。任何代码更改都会提交到本地特性分支，并推送到其远程特性分支。一旦工作准备好被部署，对主分支的合并请求(也称为拉请求)就被打开。审批通过后将被审核并合并到总分行。Terraform apply仅在通过合并请求合并到主分支时执行。为了防止直接的代码推送，主分支应该是受保护的分支。</p><p id="e5af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Gitlab管道作业触发器定义了管道的执行顺序和阶段，在<em class="kv">中声明。gitlab-ci.yaml </em>配置文件，它位于存储库的根目录下。</p><p id="5682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个示例配置文件</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="de90" class="lf je hi lb b be lg lh l li lj"># Workflow image<br/>image:<br/>  name: hashicorp/terraform:0.13.2<br/>  entrypoint:<br/>    - "/usr/bin/env"<br/>    - "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br/><br/># Workflow variables. They can be overwritten by passing pipeline Variables in Gitlab repository<br/>variables:     <br/>  TF_ROOT: $CI_PROJECT_DIR/image-creation<br/>  TF_LOG: WARN<br/>  TF_TIMEOUT: "-lock-timeout=600s"<br/>  TF_PLAN_NAME: plan.tfplan<br/>  TF_PLAN_JSON: plan.json<br/>  REFRESH: -refresh=true<br/>  ENVIRONMENT_NAME: "prod" <br/><br/># Provides the Terraform version and reconfigures the backend state during init<br/># Note: The leading dot (.) ignores this as a "job" while the ampersand (&amp;) is an Anchor declaring the script as a variable to use elsewhere<br/>.terraform-ver-init: &amp;terraform-ver-init<br/>  - cd $TF_ROOT<br/>  - terraform version<br/>  - terraform init --upgrade=True<br/><br/>#terraform init is run before any stage jobs<br/>before_script:<br/>  - *terraform-ver-init<br/><br/># Cache files between jobs<br/>cache:<br/>  key: "$CI_COMMIT_SHA"<br/>  # Globally caches the .terraform folder across each job in this workflow<br/>  paths:<br/>    - $TF_ROOT/.terraform<br/><br/># Provides a list of stages for this GitLab workflow<br/>stages:<br/>  - validate<br/>  - plan<br/>  - apply<br/><br/>#Job: tf-fmt | Stage: validate<br/>#Purpose: check the format (fmt) as a sort of linting test<br/>tf-fmt:<br/>  stage: validate<br/>  script:<br/>    - terraform fmt -recursive -check<br/>  only:<br/>    changes:<br/>      - "*.tf"<br/>      - "**/*.tf"<br/>    <br/># Job: Validate | Stage: Validate<br/># Purpose: Syntax Validation for the Terraform configuration files<br/>validate:<br/>  stage: validate<br/>  script:<br/>    - terraform validate<br/>  only:<br/>    changes:<br/>      - "*.tf"<br/>      - "**/*.tf"<br/>      - "**/*.tfvars"<br/><br/>#Job: plan | Stage: Plan<br/>#Runs terraform plan and outputs the plan and a json summary to <br/>#local files which are later made available as artifacts.<br/>plan: <br/>  stage: plan<br/>  dependencies:<br/>    - validate<br/>  before_script:<br/>    - *terraform-ver-init<br/>    - apk --no-cache add jq<br/>    - alias convert_report="jq -r '([.resource_changes[]?.change.actions?]|flatten)|{\"create\":(map(select(.==\"create\"))|length),\"update\":(map(select(.==\"update\"))|length),\"delete\":(map(select(.==\"delete\"))|length)}'"<br/>  script:<br/>    - cd $TF_ROOT<br/>    - terraform plan -out=$TF_PLAN_NAME $REFRESH<br/>    - terraform show --json $TF_PLAN_NAME | convert_report &gt; $TF_PLAN_JSON<br/><br/>  only:<br/>    changes:<br/>      - "*.tf"<br/>      - "**/*.tf"<br/>      - "**/*.tfvars"<br/><br/>  artifacts:<br/>    reports:<br/>      terraform: ${TF_ROOT}/$TF_PLAN_JSON<br/>    paths:<br/>      - ${TF_ROOT}/$TF_PLAN_NAME<br/>      - ${TF_ROOT}/$TF_PLAN_JSON<br/>    expire_in: 7 days   #optional. Gitlab stores artifacts of successful pipelines for the most recent commit on each ref. If needed, enable "Keep artifacts from most recent successful jobs"  in CI/CD settings of the repository.<br/><br/>#Stage:apply | job: apply<br/># purpose: executes the plan from the file created in the plan stage<br/>apply:<br/>  stage: apply<br/>  dependencies:<br/>    - plan<br/>  script:<br/>    - cd $TF_ROOT<br/>    - terraform apply -auto-approve $TF_PLAN_NAME <br/>  only:<br/>    - main</span></pre><p id="a07e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看上面控制工作流的文件的一些重要组件。</p><p id="cd3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在before_script下运行terraform init作业可确保它在任何其他阶段定义的作业之前执行。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="f0dc" class="lf je hi lb b be lg lh l li lj">.terraform-ver-init: &amp;terraform-ver-init<br/>  - cd $TF_ROOT<br/>  - terraform version<br/>  - terraform init --upgrade=True<br/><br/>before_script:<br/>  - *terraform-ver-init</span></pre><p id="e1a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的块定义了只有对以结尾的文件进行更改时才会触发作业。tf，。tfvars文件。这很有用，因为我们不会为不相关的变更(如文档更新)触发管道。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="82c1" class="lf je hi lb b be lg lh l li lj">only:<br/>    changes:<br/>      - "*.tf"<br/>      - "**/*.tf"<br/>      - "**/*.tfvars"</span></pre><p id="7262" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">terraform计划输出及其简化的json摘要可以作为报告和工件进行访问。</p><pre class="kw kx ky kz fd la lb lc bn ld le bi"><span id="1976" class="lf je hi lb b be lg lh l li lj">artifacts:<br/>    reports:<br/>      terraform: ${TF_ROOT}/$TF_PLAN_JSON<br/>    paths:<br/>      - ${TF_ROOT}/$TF_PLAN_NAME<br/>      - ${TF_ROOT}/$TF_PLAN_JSON<br/>    expire_in: 7 days</span></pre><p id="043b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">详细解释配置文件支持的关键字是<a class="ae ku" href="https://docs.gitlab.com/ee/ci/yaml/" rel="noopener ugc nofollow" target="_blank">这里是</a></p><h1 id="e2d8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">履行</h1><p id="a20a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">上述配置文件的典型端到端工作流如下所示:</p><ol class=""><li id="5e67" class="kb kc hi ih b ii ij im in iq lk iu ll iy lm jc ki kj kk kl bi translated">对代码库的更改被提交到功能分支</li><li id="f1ed" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">管道在推送至要素分支时触发，并在语法验证和格式检查后运行terraform init和plan</li></ol><figure class="kw kx ky kz fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ln"><img src="../Images/866834fb5e4234aed1ad85ec060caaee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYRtJJGsulWDP6AF1oSCfw.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">功能分支上的管道运行验证和计划阶段</figcaption></figure><p id="9805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.一旦计划输出被验证并准备好被部署，一个合并请求被提交到主分支。包含计划文件和json摘要的计划执行输出和工件显示在合并请求上</p><figure class="kw kx ky kz fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lz"><img src="../Images/547e7f5aecdb38277b75ed1266d6470b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-2-0n92Gyy83aBRpY8xoQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Terraform计划日志和工件显示在合并请求上</figcaption></figure><p id="2bae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.一旦合并请求被批准，代码被合并到主分支，管道运行验证、计划，并对生成的计划运行terraform apply，并创建指定的资源，在这种情况下是来自持久磁盘的快照和映像</p><figure class="kw kx ky kz fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ma"><img src="../Images/f3d52dfec868068152d1e847ebb5c09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUhHR4vyPu3ZiPtvbDgOnA.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">触发器在主分支上应用stage并创建资源</figcaption></figure><h1 id="f49d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">后续步骤</h1><p id="e1e8" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">现在我们有了一个工作管道，有一些事情需要考虑，以使它足够健壮，并针对生产环境进行优化。</p><ol class=""><li id="7c35" class="kb kc hi ih b ii ij im in iq lk iu ll iy lm jc ki kj kk kl bi translated">多环境管道的分支或文件夹结构策略</li><li id="e87c" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">将地形测试作为管道的一部分</li><li id="b193" class="kb kc hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">集成静态代码分析工具，如checkov、SonarQube</li></ol></div></div>    
</body>
</html>