<html>
<head>
<title>Building and deploying Java 17 apps on Cloud Run with cloud native buildpacks on Temurin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云上构建和部署Java 17应用使用Temurin上的云原生构建包运行</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/building-and-deploying-java-17-apps-on-cloud-run-with-cloud-native-buildpacks-on-temurin-ed56586cc764?source=collection_archive---------1-----------------------#2022-10-24">https://medium.com/google-cloud/building-and-deploying-java-17-apps-on-cloud-run-with-cloud-native-buildpacks-on-temurin-ed56586cc764?source=collection_archive---------1-----------------------#2022-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a467" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，让我们重温一下在<a class="ae jd" href="https://cloud.run/" rel="noopener ugc nofollow" target="_blank">云运行</a>上部署Java应用的主题。特别是我会部署一个<a class="ae jd" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a> app，用<a class="ae jd" href="https://jdk.java.net/17/" rel="noopener ugc nofollow" target="_blank"> Java 17 </a> (Adoptium的Temurin)编写，用<a class="ae jd" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>构建。</p><p id="814f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">带自定义Dockerfile文件</strong></p><p id="9d00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Cloud Run上，您部署容器化的应用程序，因此您必须决定您想要为您的应用程序构建容器的方式。在<a class="ae jd" href="https://glaforge.appspot.com/article/start-the-fun-with-java-14-and-micronaut-inside-serverless-containers-on-cloud-run" rel="noopener ugc nofollow" target="_blank">以前的文章</a>中，我展示了一个使用您自己的Dockerfile的例子，对于OpenJDK 17看起来如下，并启用了该语言的预览功能:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e431" class="jn jo hi jj b fi jp jq l jr js">FROM openjdk:17<br/>WORKDIR /app<br/>COPY ./ ./<br/>RUN ./gradlew shadowJar<br/>EXPOSE 8080<br/>CMD ["java", " - enable-preview", "-jar", "build/libs/app-0.1-all.jar"]</span></pre><p id="9033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进一步改进Docker文件，您可以使用多级Docker构建器，首先用Gradle在一个步骤中构建应用程序，然后在第二个步骤中运行它。此外，由于JAR文件名是硬编码的，您可能希望将命令参数化。</p><p id="4cdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要构建映像，您可以使用Docker在本地构建它，然后将其推送到容器注册表，然后部署它:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="75b7" class="jn jo hi jj b fi jp jq l jr js"># gcloud auth configure-docker<br/># gcloud components install docker-credential-gcr</span><span id="9429" class="jn jo hi jj b fi jt jq l jr js">docker build . - tag gcr.io/YOUR_PROJECT_ID/IMAGE_NAME<br/>docker push gcr.io/YOUR_PROJECT_ID/IMAGE_NAME</span><span id="9c56" class="jn jo hi jj b fi jt jq l jr js">gcloud run deploy myservice \<br/>       -image gcr.io/YOUR_PROJECT_ID/IMAGE_NAME</span></pre><p id="dd87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了使用Docker在本地构建，您还可以让<a class="ae jd" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank">云构建</a>为您完成:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="fbfc" class="jn jo hi jj b fi jp jq l jr js">gcloud builds submit . - tag gcr.io/YOUR_PROJECT_ID/SERVICE_NAME</span></pre><p id="1cbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">带起重臂</strong></p><p id="33c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了使用Dockerfiles，您还可以让<a class="ae jd" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> JIB </a>为您创建容器，就像我在<a class="ae jd" href="https://glaforge.appspot.com/article/running-micronaut-serverlessly-on-google-cloud-platform" rel="noopener ugc nofollow" target="_blank">另一篇文章</a>中写的那样。您配置Gradle使用JIB插件:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ae6b" class="jn jo hi jj b fi jp jq l jr js">plugins {<br/>    …<br/>    id “com.google.cloud.tools.jib” version “2.8.0”<br/>}<br/>…<br/>tasks {<br/>    jib {<br/>       from {<br/>          image = “gcr.io/distroless/java17-debian11”<br/>       }<br/>       to {<br/>          image = “gcr.io/YOUR_PROJECT_ID/SERVICE_NAME”<br/>       }<br/>    }<br/>}</span></pre><p id="4b69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您指定了插件的版本，但是您也通过选择具有相同版本的基础映像来表明您想要使用Java 17。请确保更改项目ID和服务名称的占位符。请随意查阅关于JIB Gradle插件的<a class="ae jd" href="https://github.com/GoogleContainerTools/jib/tree/master/jib-gradle-plugin" rel="noopener ugc nofollow" target="_blank">文档</a>。然后，您可以让Gradle用。/gradlew jib，或与。/gradlew jibDockerBuild，如果您希望使用本地Docker守护程序。</p><p id="8f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">采用云原生构建包</strong></p><p id="3062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经讨论了其他方法，让我们来关注使用<a class="ae jd" href="https://buildpacks.io/" rel="noopener ugc nofollow" target="_blank">云本地构建包</a>来代替，特别是<a class="ae jd" href="https://github.com/GoogleCloudPlatform/buildpacks" rel="noopener ugc nofollow" target="_blank">谷歌云本地构建包</a>。有了buildpacks，您就不必在部署服务之前为docker文件或构建容器而烦恼了。您让Cloud Run使用buildpacks从源代码构建、封装和部署您的应用程序。</p><p id="c421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开箱即用，buildpack实际上是针对Java 8或Java 11的。但我对用Java 17运行Java的最新LTS版本感兴趣，以便利用一些预览功能，如记录、密封类、开关表达式等。</p><p id="e851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的Gradle build中，我指定我使用的是Java 17，但也启用了预览功能:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e8ee" class="jn jo hi jj b fi jp jq l jr js">java {<br/>    toolchain {<br/>        languageVersion.set(JavaLanguageVersion.of(17))<br/>    }<br/>}</span></pre><p id="f2ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像塞德里克·尚皮乌斯在<a class="ae jd" href="https://melix.github.io/blog/2020/06/java-feature-previews-gradle.html" rel="noopener ugc nofollow" target="_blank">的博客文章</a>中所说的那样，要启用预览功能，你还应该告诉格雷尔你想让它们执行编译、测试和执行任务:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="5fe5" class="jn jo hi jj b fi jp jq l jr js">tasks.withType(JavaCompile).configureEach {<br/>    options.compilerArgs.add(“--enable-preview”)<br/>}</span><span id="21f0" class="jn jo hi jj b fi jt jq l jr js">tasks.withType(Test).configureEach {<br/>    useJUnitPlatform()<br/>    jvmArgs(“--enable-preview”)<br/>}</span><span id="b013" class="jn jo hi jj b fi jt jq l jr js">tasks.withType(JavaExec).configureEach {<br/>    jvmArgs(“ — enable-preview”)<br/>}</span></pre><p id="4fac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止还不错，但是正如我所说的，默认的本机buildpack没有使用Java 17，我想指定我使用预览功能。因此，当我试图使用buildpack从源代码中部署我的云运行应用程序时，只需运行gcloud deploy命令，我就会得到一个错误。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="f75a" class="jn jo hi jj b fi jp jq l jr js">gcloud beta run deploy SERVICE_NAME</span></pre><p id="006a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我必须添加一个配置文件，以指示buildpack使用Java 17。我在项目的根目录下创建了一个project.toml文件:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1f7f" class="jn jo hi jj b fi jp jq l jr js">[[build.env]]<br/>name = “GOOGLE_RUNTIME_VERSION”<br/>value = “17”<br/>[[build.env]]<br/>name = “GOOGLE_ENTRYPOINT”<br/>value = “java — enable-preview -jar /workspace/build/libs/app-0.1-all.jar”</span></pre><p id="af4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我指定运行时版本必须使用Java 17。但是我还添加了— enable-preview标志，以便在运行时启用预览功能。</p><p id="55bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">采用终端打开JDK 17 </strong></p><p id="8e17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">锦上添花的是，这个版本使用的是OpenJDK 17的Adoptium版本，正如我们最近宣布的！如果您查看云构建中的构建日志，您应该会看到一些提到它的输出，比如:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b4ef" class="jn jo hi jj b fi jp jq l jr js">{<br/>    "link": "<a class="ae jd" href="https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.4.1%2B1/OpenJDK17U-jdk-sources_17.0.4.1_1.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.4.1%2B1/OpenJDK17U-jdk-sources_17.0.4.1_1.tar.gz</a>",<br/>    "name": "OpenJDK17U-jdk-sources_17.0.4.1_1.tar.gz",<br/>    "size": 105784017<br/>}</span></pre><p id="9113" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好样的。Java 17 Micronaut app，部署在云Run上的Temurin多亏了云原生buildpacks！我赢了时髦的宾果游戏🙂</p></div></div>    
</body>
</html>