<html>
<head>
<title>Executing bash scripts with a webhook in Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google Cloud中使用webhook执行bash脚本</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/executing-bash-scripts-with-a-webhook-in-google-cloud-75ea4b173c9?source=collection_archive---------0-----------------------#2020-04-27">https://medium.com/google-cloud/executing-bash-scripts-with-a-webhook-in-google-cloud-75ea4b173c9?source=collection_archive---------0-----------------------#2020-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3c19f92a4040ff783cd953e9f432ca95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OfZpid_3WPl6Ngf1Xcdyw.png"/></div></div></figure><p id="191d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最近在GCP遇到了一个关于自动化的有趣问题:<em class="jo">我怎样才能触发一个webhook的bash脚本？</em>这似乎是一个常见的自动化挑战，但解决方案并不十分明显。</p><p id="22c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您有一个更复杂的带有某些二进制依赖的bash脚本时，这变得特别棘手。这个问题的一个很好的例子是运行一个脚本来扫描你的谷歌云组织的公共可用功能，这是一个挑战，<a class="ae jp" href="http://www.medium.com/@truble" rel="noopener">托马斯·卢布</a>在他的<a class="ae jp" rel="noopener" href="/@truble/scan-your-google-cloud-projects-for-open-cloud-functions-531a57304ade">媒体文章</a>中解决了这个问题。这是一篇有趣的文章，如果你还没有看过的话，就来看看吧！</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated"><strong class="ak"> <em class="ka">注</em> </strong> <em class="ka">:这个bash脚本出自Thomas Ruble的</em> <a class="ae jp" rel="noopener" href="/@truble/scan-your-google-cloud-projects-for-open-cloud-functions-531a57304ade"> <em class="ka">中文章</em> </a> <em class="ka">关于扫描公有云函数</em>。</figcaption></figure><p id="2234" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我想采用Thomas的脚本化解决方案，并使用webhook触发它的执行，会怎么样呢？本质上，端到端解决方案能够发送一个HTTP请求，在有效负载中包含必要的脚本参数，执行脚本，并在json响应中返回结果。这将为更多自动化、服务到服务集成和管道创建打开大门。</p><p id="d7ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们更好地理解了我们要解决的挑战，让我们开始吧！</p><h2 id="ba44" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">我们可以在云函数中运行bash脚本吗？</h2><p id="ec29" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">乍一看，<a class="ae jp" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Google Cloud Functions</strong></a>似乎非常适合这个用例。如果你不熟悉的话，Google Cloud Functions是一个轻量级的、<strong class="is hj">无服务器</strong>平台，用于<strong class="is hj">事件驱动的</strong>功能，具有完全管理的运行时环境，你的代码在其中执行。我们可以设置一个云函数来响应HTTP触发器来运行我们的代码。目前，云功能支持以下运行时:</p><ul class=""><li id="f2d7" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">节点. js</li><li id="04ba" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">计算机编程语言</li><li id="4cf4" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">去</li></ul><p id="a0a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看起来我们可以把我们的脚本交给一个云函数，我们会做得很好，但是正如你所看到的,<strong class="is hj"> bash </strong>不是一个可用的运行时环境。下一个合乎逻辑的步骤似乎是在云函数中打开一个子进程，以便执行我们的bash命令。尽管这种方法可行，但缺点是运行时环境中可用的<a class="ae jp" href="https://cloud.google.com/functions/docs/reference/python-system-packages" rel="noopener ugc nofollow" target="_blank">系统包受到设计的限制，因此我们无法使用定制的二进制文件执行任何bash命令。</a></p><h2 id="7be0" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">云构建呢？</h2><p id="961f" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated"><a class="ae jp" href="https://cloud.google.com/cloud-build" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">谷歌云构建</strong> </a>是在谷歌基础设施上执行的持续构建、测试和部署服务。使用云构建，您可以定义<em class="jo">定制构建步骤</em>来执行您的构建，每个步骤都发生在docker容器中。通过编写您自己的构建步骤，您可以将您的依赖项打包到一个容器中，并运行您的shell脚本。云构建文档中有一个<a class="ae jp" href="https://cloud.google.com/cloud-build/docs/create-custom-build-steps#example_executing_a_shell_script_from_your_source" rel="noopener ugc nofollow" target="_blank">用例</a>的好例子。</p><p id="3c3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是网钩呢？尽管可以通过调用云构建API来调用云构建管道，但这并不适合我们的用例。云构建对于运行一次性脚本来说是笨拙的，因为它的语义与源代码和工件生产联系在一起。此外，使用API调用将<em class="jo">参数</em>传递给我们的bash脚本并不好。在任何情况下，云构建都不是我们问题的最佳答案。这就是云运行的用武之地！</p><h2 id="f2a6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">云运行</h2><p id="9179" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">谷歌的<a class="ae jp" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">云运行</strong> </a> <strong class="is hj"> </strong>服务是谷歌云的<strong class="is hj">无服务器</strong>产品中的另一个，也是最适合我们挑战的解决方案。Cloud Run是一个完全托管计算平台，它运行支持HTTP的无状态容器。只需为您的容器提供云运行，云运行将在端口8080上侦听请求或事件。阅读<a class="ae jp" href="https://cloud.google.com/run/docs" rel="noopener ugc nofollow" target="_blank">云运行文档</a>中的云运行概念和教程。</p><h1 id="12f4" class="lp kc hi bd kd lq lr ls kh lt lu lv kl lw lx ly ko lz ma mb kr mc md me ku mf bi translated">云运行中的Bash脚本</h1><h2 id="34df" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">创建web服务器来侦听HTTP请求</h2><p id="856c" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">我们的第一步是设置一个简单的web服务器来监听我们在端口8080上接收到的HTTP请求。由于我们的应用程序将被容器化，我们可以用我们最喜欢的语言编写我们的服务器。在这个例子中，我选择使用<a class="ae jp" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>创建一个轻量级Python服务器。使用Flask，我们可以为应用程序创建一个路由来处理HTTP POST方法。</p><p id="8086" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们可以在刚刚创建的方法中添加逻辑来解析和清理bash脚本所需的任何参数的请求体。我们可以使用os.environ将这些参数设置为容器环境变量，然后bash脚本可以使用这些变量。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated"><strong class="ak"> <em class="ka">注意</em></strong><em class="ka">:Flask服务器必须监听</em> <a class="ae jp" href="https://cloud.google.com/run/docs/reference/container-contract" rel="noopener ugc nofollow" target="_blank"> <em class="ka">容器契约</em> </a> <em class="ka">指定的端口环境变量。</em></figcaption></figure><h2 id="b874" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">应用程序的容器化和部署</h2><p id="746d" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">现在我们已经编写了执行bash脚本的web服务器，下一步是将应用程序容器化。请记住，Cloud Run管理无状态容器，所以我们需要创建一个docker文件，其中包含如何构建容器的说明。在这里，我们可以将所需的二进制文件包含在容器映像中，以便bash脚本可以使用它。因为Cloud Run接受容器映像作为部署单元，所以我们可以向映像添加任何可执行文件或系统库，并在我们的应用程序中使用它。换句话说，我们可以打包bash脚本的所有依赖项，并将其发送到Cloud Run——在这种情况下，我们将在环境中包含Google Cloud SDK。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="0d70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们已经容器化了我们的应用程序，我们可以构建我们的容器，将其推送到GCR，并将其部署到Cloud Run。我们还将配置服务以防止未经身份验证的访问，这样我们就可以使用<a class="ae jp" href="https://cloud.google.com/run/docs/securing/managing-access" rel="noopener ugc nofollow" target="_blank"> IAM策略</a>来控制谁有权调用服务。这两个gcloud命令将为我们完成这些步骤:</p><pre class="jq jr js jt fd mg mh mi mj aw mk bi"><span id="e345" class="kb kc hi mh b fi ml mm l mn mo">gcloud builds submit --tag gcr.io/<strong class="mh hj">$PROJECT_ID</strong>/<strong class="mh hj">$IMAGE</strong><br/>gcloud run deploy --image gcr.io/<strong class="mh hj">$PROJECT_ID</strong>/<strong class="mh hj">$IMAGE</strong> --platform managed --no-allow-unauthenticated --region us-central1 <strong class="mh hj">${SERVICE_NAME}</strong></span></pre><p id="87e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">差不多结束了！我们现在已经成功地设置了一个webhook来执行我们的函数扫描器。</p></div></div>    
</body>
</html>