<html>
<head>
<title>Analyzing Go code with BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用BigQuery分析Go代码</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/analyzing-go-code-with-bigquery-485c70c3b451?source=collection_archive---------0-----------------------#2016-06-29">https://medium.com/google-cloud/analyzing-go-code-with-bigquery-485c70c3b451?source=collection_archive---------0-----------------------#2016-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="efe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近我的同事<a class="ae jd" href="http://twitter.com/felipehoffa" rel="noopener ugc nofollow" target="_blank"> Felipe Hoffa </a>告诉我关于<a class="ae jd" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>中一个新的公共数据集:所有<a class="ae jd" rel="noopener" href="/@hoffa/github-on-bigquery-analyze-all-the-code-b3576fd2b150">公共GITHUB代码</a>！</p><h2 id="6f5b" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">计数Go文件</h2><p id="e66b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">作为一个gopher，我的第一反应是检查数据集中有多少Go文件。我的SQL并不出色，但我能做到！</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="e953" class="je jf hi kj b fi kn ko l kp kq">SELECT COUNT(*)<br/>FROM [bigquery-public-data:github_repos.files]<br/>WHERE RIGHT(path, 3) = ‘.go’</span></pre><p id="f5d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行该查询，我看到数据集中有超过1200万个扩展名为. go的文件。太多了！但是等等…我刚刚在20亿行上运行了那个查询，它在6秒内就完成了？哇！😮</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kr"><img src="../Images/2f50aebab4aad0f86abe01ce1aaded77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2UnTLij6qBR6kYhPuD8fw.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">统计所有的文件。GitHub上的go扩展</figcaption></figure><p id="f6ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，太棒了！但是我也处理了105GB，由于我是查询的<a class="ae jd" href="https://cloud.google.com/bigquery/pricing" rel="noopener ugc nofollow" target="_blank">成本</a>与被查询数据的大小成比例(即使每月的第一个TB是空闲的),所以创建一个<a class="ae jd" href="https://cloud.google.com/bigquery/quickstart-web-ui#create_a_dataset" rel="noopener ugc nofollow" target="_blank">新数据集</a>和一个<a class="ae jd" href="https://cloud.google.com/bigquery/querying-data#storing_synchronous_results_in_a_permanent_table" rel="noopener ugc nofollow" target="_blank">新表</a>来最小化成本可能是个好主意，该新表只包含扩展名为. go的文件。</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ld"><img src="../Images/1e791c64d8b26becb9663615c44e2776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96_Zu5erD7LZ8pYMO-i40Q.png"/></div></div></figure><p id="dee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搞定了。在21秒内，我创建了一个只包含Go文件的新表。计算有多少Go文件现在更简单了:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="18ce" class="je jf hi kj b fi kn ko l kp kq">SELECT COUNT(*)<br/>FROM [go_files:files]</span></pre><p id="707d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好的部分是它处理零字节，因为元数据不算。</p><h2 id="70c9" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">最流行的文件名</h2><p id="cddf" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">为了解决这个问题，我们需要从路径中提取文件名。BigQuery有一些惊人的文本处理功能，使这变得很容易。使用SPLIT和LAST，我们可以很容易地获得每个文件的名称。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="eae3" class="je jf hi kj b fi kn ko l kp kq">SELECT LAST(SPLIT(path, ‘/’)) as filename<br/>FROM [go_files.files]</span></pre><p id="1c34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了文件名，我将计算每个不同的文件名出现的次数，并按降序排列结果。或者在SQL中:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="acb4" class="je jf hi kj b fi kn ko l kp kq">SELECT filename, COUNT(*) as n<br/>FROM (<br/>    SELECT LAST(SPLIT(path, ‘/’)) as filename<br/>    FROM [go_files.files]<br/>)<br/>GROUP BY filename<br/>ORDER BY n DESC<br/>LIMIT 10</span></pre><p id="0de4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是结果:</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es le"><img src="../Images/31a0123049fb70c155a2e6a4fad2ab6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*7aH0sOXnxndz96kwGqgNag.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">GitHub上Go文件的十大名字</figcaption></figure><p id="0db7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然地鼠喜欢文档。</p><h2 id="7bf7" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">最流行的包装名称</h2><p id="15b8" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">接下来，我想确定最流行的包名。为此，我们需要读取文件的内容。为了避免遍历GitHub上的所有文件(显然有很多)，我将创建一个只包含Go文件内容的表。</p><p id="1084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">警告:</strong>这是一个昂贵的查询(大约7美元)，可能需要几分钟才能完成，而不是创建您自己的表，只需在这里使用<a class="ae jd" href="https://bigquery.cloud.google.com/table/fh-bigquery:github_extracts.contents_go" rel="noopener ugc nofollow" target="_blank">此表</a>。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="1faf" class="je jf hi kj b fi kn ko l kp kq">SELECT *<br/>FROM [bigquery-public-data:github_repos.contents]<br/>WHERE id IN (SELECT id FROM go_files.files)</span></pre><p id="d741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了，现在我可以简单地找到那些包含“包xxx”的文件中的所有行，并按它分组…简单！</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="e74f" class="je jf hi kj b fi kn ko l kp kq">SELECT SPLIT(content, ‘\n’) as line<br/>FROM go_files.contents<br/>HAVING LEFT(line, 8) = ‘package ‘</span></pre><p id="2a9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们从这些行中提取包名并计数。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="0c1b" class="je jf hi kj b fi kn ko l kp kq">SELECT SUBSTR(line, 8) as name, count(*) as n<br/>FROM (<br/> SELECT SPLIT(content, ‘\n’) as line<br/> FROM go_files.contents<br/> HAVING LEFT(line, 8) = ‘package ‘<br/>)<br/>GROUP BY name<br/>ORDER BY n DESC<br/>LIMIT 10</span></pre><p id="92b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们的结果:</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es lf"><img src="../Images/d9e040a9ad30bbe5c94d4df804d138c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*Xh8w_QvXYQR5ps_E_kLy2Q.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">GitHub上Go包的十大名字</figcaption></figure><h2 id="2154" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">最进口的包装</h2><p id="dd57" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">好的，这应该很简单，对吧？就像我们之前做的那样找到所有以“import”开头的行？</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="ec09" class="je jf hi kj b fi kn ko l kp kq">SELECT line, count(*) as n<br/>FROM (<br/> SELECT SPLIT(content, ‘\n’) as line<br/> FROM go_files.contents<br/> HAVING LEFT(line, 7) = ‘import ‘<br/>)<br/>GROUP BY line<br/>ORDER BY n DESC<br/>LIMIT 10</span></pre><p id="bf5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到:</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es lg"><img src="../Images/8f3815907234d3bcc7dac10505039872.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*-oSv29LgHzsSftefVcG7IA.png"/></div></figure><p id="5446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，让我们来分析结果:</p><ol class=""><li id="af99" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">import语句可以跨多行，人们显然喜欢这样。</li><li id="4e8c" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">有些人使用包别名…甚至在不需要的时候？</li></ol><p id="b7bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">奇怪的事情正在发生:有两个结果以“import(，为什么？让我们看看这个JSON查询的结果:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="fcc9" class="je jf hi kj b fi kn ko l kp kq">[<br/><strong class="kj hj"> { “line”: “import (“, “n”: “745978” },<br/></strong> { “line”: “import \”fmt\””, “n”: “14673” },<br/> { “line”: “import \”C\””, “n”: “10235” },<br/> { “line”: “import \”testing\””, “n”: “8682” },<br/> { “line”: “import math \”math\””, “n”: “4298” },<br/><strong class="kj hj"> { “line”: “import (\r”, “n”: “4027” },<br/></strong> { “line”: “import \”unsafe\””, “n”: “3833” },<br/> { “line”: “import \”time\””, “n”: “3709” },<br/> { “line”: “import fmt \”fmt\””, “n”: “3054” },<br/> { “line”: “import \”os\””, “n”: “2654” }<br/>]</span></pre><p id="cea0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有“导入(”和“导入(\r”)。啊，换行符太棒了。我们也应该考虑到这一点。</p><p id="f1bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时想起XKCD的一集。</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es lv"><img src="../Images/a9fd2b1e380476588edec3299c44426b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*oGaYyDJNEZ6UL5nN-43YMg.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated"><a class="ae jd" href="http://xkcd.com/208/" rel="noopener ugc nofollow" target="_blank">http://xkcd.com/208/</a></figcaption></figure><p id="5d74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我可以使用下面的正则表达式在多行import语句中提取导入包的列表:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="1dad" class="je jf hi kj b fi kn ko l kp kq">r"(?s)import \(([^\]*)\)"</span></pre><p id="d7a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">字符串开头的r是为了让BigQuery知道这是一个正则表达式。的(？s)用于允许正则表达式匹配多行，这是我们需要的。剩下的就是捕获两个括号之间的所有文本。</p><p id="3e37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用该正则表达式，我们可以使用以下查询提取导入语句:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="4afa" class="je jf hi kj b fi kn ko l kp kq">SELECT SPLIT(<br/>  REGEXP_EXTRACT(<br/>    content,<br/>    r'(?s)import \(([^\)]*)\)'<br/>  ), '\n') as pkg<br/>FROM go_files.contents<br/>HAVING pkg IS NOT NULL</span></pre><p id="2508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们提取导入包的列表，然后按行分割它们。不错！然后，我们可以通过如下包装该查询来提取导入路径(忽略可能的别名):</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="191b" class="je jf hi kj b fi kn ko l kp kq">SELECT REGEXP_EXTRACT(line, '.*\"(.*)\".*') as pkg<br/>FROM (<br/>  SELECT SPLIT(<br/>    REGEXP_EXTRACT(<br/>      content,<br/>      r'(?s)import \(([^\)]*)\)'<br/>    ), '\n') as line<br/>  FROM go_files.contents<br/>  HAVING line IS NOT NULL<br/>)</span></pre><p id="c1e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有一个包的导入语句怎么办？我们可以使用不同的正则表达式:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="a904" class="je jf hi kj b fi kn ko l kp kq">r'import.*\"(.*)\"'</span></pre><p id="a540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的查询中，我们将文件内容分成几行，并对每一行应用正则表达式。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="13f9" class="je jf hi kj b fi kn ko l kp kq">SELECT REGEXP_EXTRACT(line, r'import.*\"(.*)\"') as pkg<br/>FROM (<br/>  SELECT SPLIT(content, '\n') as line<br/>  FROM go_files.contents<br/>)<br/>HAVING pkg is not null</span></pre><p id="0254" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还剩下什么？好了，我们准备把两套导入路径都加入进来，统计一下，按人气排序！</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="7f31" class="je jf hi kj b fi kn ko l kp kq">SELECT pkg, count(*) as n<br/>FROM <br/>(<br/>  SELECT REGEXP_EXTRACT(line, '.*\"(.*)\".*') as pkg<br/>  FROM (<br/>    SELECT SPLIT(<br/>      REGEXP_EXTRACT(<br/>        content,<br/>        r'(?s)import \(([^\)]*)\)'<br/>      ), '\n') as line<br/>    FROM go_files.contents<br/>    HAVING line IS NOT NULL<br/>  )<br/>), (<br/>  SELECT REGEXP_EXTRACT(line, r'import.*\"(.*)\"') as pkg<br/>  FROM (<br/>    SELECT SPLIT(content, '\n') as line<br/>    FROM go_files.contents<br/>  )<br/>  HAVING pkg is not null<br/>)<br/>GROUP BY pkg<br/>ORDER BY n DESC<br/>LIMIT 10</span></pre><p id="9fa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过7.2秒和5.96 GB的处理后，结果是:</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es lw"><img src="../Images/3f50896296098edea4b3234c24c26a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*F9JGn4tmmlvSf7lIBe6JcQ.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">fmt FTW！</figcaption></figure><p id="214c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入路径以github开头的最流行的包呢？只需用粗体添加一行:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9cce" class="je jf hi kj b fi kn ko l kp kq">SELECT pkg, count(*) as n<br/>FROM <br/>(<br/>  SELECT REGEXP_EXTRACT(line, '.*\"(.*)\".*') as pkg<br/>  FROM (<br/>    SELECT SPLIT(<br/>      REGEXP_EXTRACT(<br/>        content,<br/>        r'(?s)import \(([^\)]*)\)'<br/>      ), '\n') as line<br/>    FROM go_files.contents<br/>    HAVING line IS NOT NULL<br/>  )<br/>), (<br/>  SELECT REGEXP_EXTRACT(line, r'import.*\"(.*)\"') as pkg<br/>  FROM (<br/>    SELECT SPLIT(content, '\n') as line<br/>    FROM go_files.contents<br/>  )<br/>  HAVING pkg is not null<br/>)<br/><strong class="kj hj">WHERE LEFT(pkg, 6) = 'github'<br/></strong>GROUP BY pkg<br/>ORDER BY n DESC<br/>LIMIT 10</span></pre><p id="efd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是:</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es lx"><img src="../Images/e0bf268c70409082317f46bf038c44ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*GnKM_HINb6ZeVLcKjmwuLQ.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">GitHub中从GitHub导入最多的10个包</figcaption></figure><p id="83e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ly">更新</em>:在和一个朋友交谈后不久，我修改了这个分析，请看帖子末尾的新结果。</p><h2 id="4a34" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">导出的函数返回未导出的类型？</h2><p id="b4d7" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">有趣的是，在完成这篇文章的细节时，我在twitter上进行了一次有趣的对话。从这里开始:</p><figure class="ke kf kg kh fd ks"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="a9df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想知道，有人这样做吗？从公共函数返回私有类型似乎有悖直觉…</p><p id="818e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想出来能有多难？有了BigQuery，就不多了🎉只需找到所有大写名称的函数，这些函数返回以小写开头的类型，并且不是Go中预先声明的类型。</p><p id="fe06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还加入了<em class="ly">文件</em>表来获取<em class="ly"> repo_name </em>和<em class="ly"> path </em>。如果你愿意，可以说是一种<em class="ly">怪</em>。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="f313" class="je jf hi kj b fi kn ko l kp kq">SELECT line, repo_name, path<br/>FROM<br/>(<br/>  SELECT line, id<br/>  FROM (<br/>    SELECT SPLIT(content, "\n") as line, id<br/>    FROM [go_files.contents]<br/>    HAVING length(line) &gt; 2<br/>  )<br/>  WHERE REGEXP_MATCH(line, r"func [A-Z].*\(.*\) [a-z][a-zA-Z]* {")<br/>  AND REGEXP_EXTRACT(line, r"func [A-Z].*\(.*\) ([a-z][a-zA-Z]*) {") NOT IN<br/>    (<br/>      "bool", "byte", "complex64", "complex128", "error",<br/>      "float32", "float64", "int", "int8", "int16", "int32",<br/>      "int64", "rune", "string", "uint", "uint8", "uint16",<br/>      "uint32", "uint64", "uintptr", "interface"<br/>    )<br/>) AS lines<br/>JOIN [go_files.files] as files<br/>ON files.id = lines.id<br/>LIMIT 100</span></pre><p id="7928" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是，Kubernetes经常使用这种风格！</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mb"><img src="../Images/2fc11e4514798e482afadb551e71c3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pcqgFsF3O68Sqai9r3GiQg.png"/></div></div></figure><h2 id="87bb" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">想要更多吗？</h2><p id="cdf4" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">可以分析的东西有很多，但是很快你就会意识到使用正则表达式来解析Go是相当困难的。幸运的是BigQuery支持的不仅仅是SQL！</p><p id="6575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" href="https://cloud.google.com/bigquery/user-defined-functions" rel="noopener ugc nofollow" target="_blank"> BigQuery用户定义函数</a>你可以执行任意的JavaScript！这让我想到…我们能不能用<a class="ae jd" href="https://github.com/gopherjs/gopherjs" rel="noopener ugc nofollow" target="_blank"> GopherJS </a>把“go/types”转换成JavaScript，然后在BigQuery上运行它？</p><p id="325a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">去看看这篇文章，Felipe告诉了我们更多关于你可以用这个惊人的数据集和BigQuery的能力做什么。</p><h2 id="40c7" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">更新更新</h2><p id="bf27" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">和我的朋友Matt Aimonetti聊天时，我们意识到如果一个大的组织使用一个软件包，那么它将会在我的排名中非常靠前。知道每个包有多少不同的GitHub用户名导入可能会很有趣。</p><p id="5dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我同意，所以我创建了一个新的查询:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="6c72" class="je jf hi kj b fi kn ko l kp kq">SELECT pkg, COUNT(distinct REGEXP_EXTRACT(repo_name, "(.*)/.*")) as n<br/>FROM (<br/>  SELECT pkg, id<br/>  FROM <br/>  (<br/>    SELECT REGEXP_EXTRACT(line, '.*\"(.*)\".*') as pkg, id<br/>    FROM (<br/>      SELECT SPLIT(<br/>        REGEXP_EXTRACT(<br/>          content,<br/>          r'(?s)import \(([^\)]*)\)'<br/>        ), '\n') as line, id<br/>      FROM go_files.contents<br/>      HAVING line IS NOT NULL<br/>    )<br/>  ), (<br/>    SELECT REGEXP_EXTRACT(line, r'import.*\"(.*)\"') as pkg, id<br/>    FROM (<br/>      SELECT SPLIT(content, '\n') as line, id<br/>      FROM go_files.contents<br/>    )<br/>    HAVING pkg is not null<br/>  )<br/>  WHERE REGEXP_MATCH(pkg, "github.com/.*")  <br/>)  as imports JOIN [go_files.files] as files<br/>ON files.id = imports.id<br/>GROUP BY pkg<br/>ORDER BY n desc<br/>LIMIT 10</span></pre><p id="75d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没什么特别的，只是从存储库中提取GitHub用户名，并使用这些用户名进行计数，而没有重复(因此不同)。</p><p id="ecde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果也很有意思！</p><figure class="ke kf kg kh fd ks er es paragraph-image"><div class="er es mc"><img src="../Images/82df26117de126b8264808e97641b5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*s0oZbnlPJoxp2dPa7k7nAw.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">大多数流行的软件包只计算一次每个用户名！</figcaption></figure><div class="md me ez fb mf mg"><a rel="noopener follow" target="_blank" href="/@hoffa/github-on-bigquery-analyze-all-the-code-b3576fd2b150"><div class="mh ab dw"><div class="mi ab mj cl cj mk"><h2 class="bd hj fi z dy ml ea eb mm ed ef hh bi translated">GitHub中的所有开源代码现在都在BigQuery内共享:分析所有代码！</h2><div class="mn l"><h3 class="bd b fi z dy ml ea eb mm ed ef dx translated">GitHub中的所有开源代码现在都可以在BigQuery中获得。</h3></div><div class="mo l"><p class="bd b fp z dy ml ea eb mm ed ef dx translated">medium.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu kx mg"/></div></div></a></div></div></div>    
</body>
</html>