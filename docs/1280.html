<html>
<head>
<title>Connecting Cloud SQL - Kubernetes Sidecar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接云SQL - Kubernetes Sidecar</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/connecting-cloud-sql-kubernetes-sidecar-46e016e07bb4?source=collection_archive---------0-----------------------#2020-02-07">https://medium.com/google-cloud/connecting-cloud-sql-kubernetes-sidecar-46e016e07bb4?source=collection_archive---------0-----------------------#2020-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/23ae89e680f61cca63c0c7af884f9bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efvnGXZbvpu0ib5qBdUfuQ.png"/></div></div></figure><p id="c6a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗨，朋友们！</p><p id="3d85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个博客比我通常的操作方法要长一点，因为我们要处理很多移动的部分。我们有云SQL、云SQL代理、Docker和containers、Google Container Registry、Kubernetes，以及云中的数据库凭证等管理机密，因此您不必将它们暴露在任何配置文件或环境变量中。</p><p id="7ab6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是不要被吓倒！我是从一个初学者的角度来看这个问题的，所以我会解释很多细节。如果你有很多这方面的经验，不要担心，我已经把很多分成了独立的博客文章，我一路上都在链接，所以你应该能够很快进入文章的核心。</p><p id="dc2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您完全没有经验，欢迎来到Kubernetes和云SQL的广阔世界！虽然你不会成为一个专家(我离Kubernetes专家还很远)，但希望你能掌握一些基本知识，以及如何开始。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/683454e18d3cae53b8a91211a64d65b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*fy-2ZdZsjI-HXKqZYT4cDQ.jpeg"/></div></figure><p id="dc5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，什么是边车？我们说的不是摩托车边车，而是这种格局因此而得名。</p><p id="df2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes sidecar模式是将一个支持容器附加到应用程序的容器上，以便在某种程度上使您的生活更轻松。在我们的例子中，这指的是将运行<a class="ae jt" href="https://cloud.google.com/sql/docs/mysql/sql-proxy" rel="noopener ugc nofollow" target="_blank">云SQL代理</a>的容器附加到您的应用程序中。使用代理有很多好处，这是我们推荐的连接到<a class="ae jt" href="https://cloud.google.com/sql/" rel="noopener ugc nofollow" target="_blank">谷歌云SQL </a>的最佳实践。</p><p id="1db2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，除了边车模式，还有其他方法可以做到这一点。在后续的博客中，我将深入探讨不同模式的利弊。</p><p id="0b70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博文中，我写了一个时髦的(对我来说)应用程序，为MySQL伪造数据库数据。你可以在GitHub 上找到我的脚本<a class="ae jt" href="https://github.com/GabeWeiss/sql_data_randomizer" rel="noopener ugc nofollow" target="_blank">，还有一个关于它的博客和它的用法</a><a class="ae jt" rel="noopener" href="/@GabeWeiss/creating-sample-data-for-mysql-databases-38e3eff4a91b">在这里</a>。</p><p id="fac3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想了解更多关于云SQL连接的背景知识，请查看我的<a class="ae jt" rel="noopener" href="/@GabeWeiss/connecting-google-cloud-sql-94025ba27071">连接介绍</a>博文。这篇文章还链接到更多关于不同用例和方法的分步文章，以及为什么您可能想要选择一种方法而不是另一种方法。</p><p id="b171" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先决条件:我假设你已经有了自己的谷歌云平台(GCP)项目，并设置了计费。如果没有，请点击此处的<a class="ae jt" href="https://console.cloud.google.com/freetrial" rel="noopener ugc nofollow" target="_blank">按钮</a>开始项目，或点击此处的<a class="ae jt" href="https://console.cloud.google.com/billing" rel="noopener ugc nofollow" target="_blank">按钮</a>为项目设置账单。如果你打算在本地运行这些(codelab在控制台外壳的<a class="ae jt" href="http://console.cloud.google.com" rel="noopener ugc nofollow" target="_blank"> GCP </a>上运行，这是Linux，所以默认安装了它)你需要在你的机器上安装并提供<a class="ae jt" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/2ab92a0a52e138edf5ebc7d216434c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mGO3h79ZbIoFmSygp6GFg.jpeg"/></div></div></figure><h1 id="c223" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">该应用程序</h1><p id="8100" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><a class="ae jt" href="https://github.com/GoogleCloudPlatform/gmemegen" rel="noopener ugc nofollow" target="_blank"> codelab </a>展示了一个允许你创建和存储迷因的应用程序。它有一个由flask和SQLAlchemy提供的web用户界面。</p><p id="cf43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我写的<a class="ae jt" href="https://github.com/GabeWeiss/sql_data_randomizer" rel="noopener ugc nofollow" target="_blank">app</a>明显更简单。我只是想要一个展示一件事的应用程序:连接到云SQL并将一些虚假的人数据转储到数据库中。</p><p id="484d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，如果你也编写了自己的应用程序，那么一切都适用。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/b4117b6dfe4b5a91f5bf9b054823ceeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*SOb_BmIVbhEVjxq-UNy60A.jpeg"/></div></figure><h1 id="3637" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">用集装箱装</h1><p id="4c33" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">写这篇博文时，我遇到的一个问题是找到一条简单的路径，从“我有一个应用程序”到“它正在Kubernetes上运行”。现在我们有一个应用程序要运行。</p><p id="8709" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在Kubernetes中运行，我们需要一个容器(在我们的例子中是多个容器)。如果你已经知道如何构建一个容器，耶！如果没有，我写了一个单独的博客<a class="ae jt" rel="noopener" href="/@GabeWeiss/breaking-down-containers-9b0eb94cc0cd">来讲述我是如何用我的应用程序脚本创建一个容器的，并并排分解了在codelab中创建的容器，以帮助导航你需要做什么来用你想在Kubernetes和代理sidecar中运行的任何东西创建一个容器。</a></p><p id="d69b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论哪种方式，浏览博客文章获得一个容器，或者使用自己的容器。现在，故事的核心是:用代理sidecar部署应用程序！</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/077f08591f429f1fdcaa2ecf7df03ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*WKxbx81rtM_p355F50iT9w.png"/></div></figure><h1 id="d4bb" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">扩展应用程序</h1><p id="35d4" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><em class="la">本节:</em></p><ol class=""><li id="4c34" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated"><a class="ae jt" href="#b736" rel="noopener ugc nofollow"> <em class="la">用谷歌容器注册表</em> </a>安装并授权gcloud(谷歌云SDK命令行工具)</li><li id="9f40" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated"><a class="ae jt" href="#c797" rel="noopener ugc nofollow"> <em class="la">准备，并将容器上传到Google容器注册表</em> </a></li><li id="aa89" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated"><a class="ae jt" href="#f4ce" rel="noopener ugc nofollow"> <em class="la">创建Google Kubernetes引擎(GKE)集群</em> </a></li><li id="98a3" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated"><a class="ae jt" href="#3298" rel="noopener ugc nofollow"> <em class="la">用Kubernetes Secrets </em> </a>替换Dockerfile中的ENV变量</li><li id="90ca" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated"><a class="ae jt" href="#d201" rel="noopener ugc nofollow"> <em class="la">分解Kubernetes yaml部署文件</em> </a></li><li id="554a" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated"><a class="ae jt" href="#6ab7" rel="noopener ugc nofollow"> <em class="la">将应用部署到Kubernetes集群</em> </a></li><li id="6d6b" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated"><a class="ae jt" href="#7310" rel="noopener ugc nofollow"> <em class="la">上下伸缩</em> </a></li><li id="a82c" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated"><a class="ae jt" href="#ce93" rel="noopener ugc nofollow"> <em class="la">故障排除</em> </a></li></ol><p id="b736" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步，让我们把应用程序容器放到云中。<a class="ae jt" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank"> GCR (Google容器注册表)</a>是一种安全的存储容器的方式，使它们可以从云中访问。我们将使用<a class="ae jt" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> GKE(谷歌Kubernetes引擎)</a>来扩大规模。我们需要配置docker来使用GCR。我要用<code class="du lp lq lr ls b">gcloud</code>来做这件事。如果你不熟悉Google Cloud SDK，你应该熟悉！万物云平台的命令行界面。安装文档可以在<a class="ae jt" href="https://cloud.google.com/sdk/install" rel="noopener ugc nofollow" target="_blank">这里</a>找到，我在之前的博文<a class="ae jt" rel="noopener" href="/google-cloud/cloud-iot-step-by-step-quality-of-life-tip-the-command-line-ce23046867d4#016c">这里</a>中详细介绍了它的安装和配置。去做吧，然后回来。</p><p id="f2e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，运行命令，用GCR: <code class="du lp lq lr ls b">gcloud auth configure-docker</code>对<code class="du lp lq lr ls b">gcloud</code>进行授权。您将看到如下所示的输出:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="ea97" class="lx jw hi ls b fi ly lz l ma mb">The following settings will be added to your Docker config file<br/>located at [/Users/&lt;user&gt;/.docker/config.json]:<br/>{<br/>  "credHelpers": {<br/>    "gcr.io": "gcloud",<br/>    "us.gcr.io": "gcloud",<br/>    "eu.gcr.io": "gcloud",<br/>    "asia.gcr.io": "gcloud",<br/>    "staging-k8s.gcr.io": "gcloud",<br/>    "marketplace.gcr.io": "gcloud"<br/>  }<br/>}</span><span id="1084" class="lx jw hi ls b fi mc lz l ma mb">Do you want to continue (Y/n)?</span></pre><p id="bcac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，根据Docker的安装位置和安装方式，config.json的路径可能会有所不同，但其余部分应该是相同的。继续按“Y”键。</p><p id="a53e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们上传容器之前，我们需要编辑和重建它。请记住，我们不希望密码写在云中的任何地方，所以在我们上传容器之前，我们希望以明文形式消除密码的任何痕迹。删除Dockerfile文件中的ENV行。</p><p id="54a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行以下命令，用GCR uri标记您的容器。如果你之前给你的容器命名了不同于<code class="du lp lq lr ls b">randomizer</code>的名字，在下面的命令中用它代替randomizer，并且用你在gcloud中使用的任何项目代替<code class="du lp lq lr ls b">$PROJECT_ID</code>:</p><p id="0d47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lp lq lr ls b">docker tag randomizer gcr.io/$PROJECT_ID/randomizer</code></p><p id="4150" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想多次重新构建容器，不要忘记标记步骤。如果你不这样做，那么它不会上传新版本的容器到GCR。</p><p id="ee22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过以下方式将您的集装箱推送到您的GCR仓库:</p><p id="5e1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lp lq lr ls b">docker push gcr.io/$PROJECT_ID/randomizer</code></p><p id="f10f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦完成，你的集装箱就准备好了，可以被Kubernetes拉走了。当然，GCR并不是让你的容器进入云端被拉入的唯一方式。你可以使用Docker Hub，建立自己的提供商。GCR只是让它从GKE变得容易。</p><p id="06d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们在GKE创建我们的Kubernetes集群:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="14d0" class="lx jw hi ls b fi ly lz l ma mb">gcloud container clusters create randomizer-cluster --zone us-central1-f --machine-type=n1-standard-1 --max-nodes=10 --min-nodes=1</span></pre><p id="8f96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请确保选择一个离您和/或您希望应用程序运行的地方很近的区域。你可以在这里看到区域列表<a class="ae jt" href="https://cloud.google.com/compute/docs/regions-zones/#available" rel="noopener ugc nofollow" target="_blank">。机器类型映射到集群中运行的机器的功能有多强大。您可以点击</a><a class="ae jt" href="https://cloud.google.com/compute/docs/machine-types" rel="noopener ugc nofollow" target="_blank">此处</a>查看不同机器类型的更多详情。<code class="du lp lq lr ls b">n1-standard-1</code>是一个具有3.75GB内存的vCPU，对于我们的目的来说足够了。最后，最小/最大节点对集群的扩展设置了一些限制。</p><p id="bec3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继续运行该命令，然后通过运行<code class="du lp lq lr ls b">gcloud container clusters list</code>来验证集群创建是否正常。</p><p id="cafb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要确保<code class="du lp lq lr ls b">kubectl</code>(命令行工具，我们将通过它与k8s集群进行交互)通过了GKE认证。运行以下程序进行身份验证:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="f777" class="lx jw hi ls b fi ly lz l ma mb">gcloud container clusters get-credentials randomizer-cluster --zone us-central1-f</span></pre><p id="be79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">确保您更改了集群的名称和区域，以匹配您在设置集群时使用的名称和区域。您应该看到:</p><p id="f19e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lp lq lr ls b">kubeconfig entry generated for randomizer-cluster</code></p><p id="3298" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在为了混淆我们的数据库凭证。有几种方法可以做到这一点，我不打算在这里介绍它们。几年前，我的老队友写了一篇很棒的分为两部分的博客文章<a class="ae jt" rel="noopener" href="/google-cloud/kubernetes-configmaps-and-secrets-68d061f7ab5b">,介绍了一些背景和基本知识。从那以后，有了更多的方法。我可能会写或找一篇后续文章来介绍它们。现在，我们将使用Kubernetes的秘密来做到这一点。</a></p><p id="3db1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的容器需要两组凭证:数据库用户凭证，以及服务帐户凭证。云SQL代理使用服务帐户连接到我们的云SQL实例。</p><p id="43c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以将服务帐户json文件转换成Kubernetes秘密，该秘密可以传递到容器中并由代理使用。</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="6386" class="lx jw hi ls b fi ly lz l ma mb">kubectl create secret generic cloudsql-instance-credentials --from-file=sql_credentials.json=&lt;service_account_json_file&gt;</span></pre><p id="9b40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并创建我们的数据库凭证:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="9291" class="lx jw hi ls b fi ly lz l ma mb">kubectl create secret generic cloudsql-db-credentials --from-literal=username=[DB_USER] --from-literal=password=[DB_PASS] --from-literal=dbname=[DB_NAME]</span></pre><p id="a8f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用这些秘密来设置环境变量，作为我们部署的一部分，然后由我们的脚本获取，我们就可以开始了！</p><p id="544e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的应用程序的部署yaml看起来与codelab非常相似，所以我将遍历我的部署YAML并分解正在发生的事情(注意，完整的文件在<a class="ae jt" href="https://github.com/GabeWeiss/sql_data_randomizer/blob/master/randomizer_deployment.yaml" rel="noopener ugc nofollow" target="_blank"> repo </a>中，我只是抽出相关的部分)。</p><p id="1ecf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">containers部分定义了我们将哪些容器放入k8s集群的每个节点。对于我们来说，我们使用了两个容器。我们用我们的应用程序创建的容器，然后是已经在GCR为我们设置好的SQL代理容器。</p><p id="a327" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在随机数发生器容器部分，你可以看到我们是如何使用之前上传的来自GCR的图片URL的。记得将<project_id>值更改为您的项目id。env部分定义了部署容器时将在容器上设置的环境变量。在我们的例子中，它是来自我们创建的秘密的数据库凭证。记住，我们没有使用SQL_HOST变量，因为我们使用了代理，所以脚本代码默认使用localhost。</project_id></p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="499a" class="lx jw hi ls b fi ly lz l ma mb">      containers:<br/>        - name: randomizer<br/>          image: gcr.io/[PROJECT_ID]/randomizer<br/>        # Set env variables used for database connection<br/>        env:<br/>          - name: DB_USER<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: cloudsql-db-credentials<br/>                key: username<br/>          - name: DB_PASS<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: cloudsql-db-credentials<br/>                key: password<br/>          - name: DB_NAME<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: cloudsql-db-credentials<br/>                key: dbname</span></pre><p id="bb49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lp lq lr ls b">cloudsql-proxy</code>容器中，图像标签告诉Kubernetes在哪里获取它。写这篇文章的时候，我已经设置了图片的最新版本(<code class="du lp lq lr ls b">1.16</code>)。检查<a class="ae jt" href="https://console.cloud.google.com/gcr/images/cloudsql-docker/GLOBAL/gce-proxy?gcrImageListsize=30&amp;pli=1" rel="noopener ugc nofollow" target="_blank">这里</a>的容器列表，看看最新版本是什么。更新线图像:<code class="du lp lq lr ls b">gcr.io/cloudsql-docker/gce-proxy:1.16</code>用最新版本替换<code class="du lp lq lr ls b">1.16</code>。要运行该命令，请确保使用您的云SQL实例的连接名称来更改<code class="du lp lq lr ls b">&lt;INSTANCE_CONNECTION_NAME&gt;</code>。如果您正在查看云SQL实例的概述页面，您会在Connect to this instance标题下看到它。看起来会像<code class="du lp lq lr ls b">&lt;project id:region:instance id&gt;</code>。因为代理需要一个json文件作为服务帐户承载令牌，所以我们用我们之前创建的服务帐户秘密设置一个mount，并将该路径传递给启动代理的命令。</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="7955" class="lx jw hi ls b fi ly lz l ma mb">- name: cloudsql-proxy<br/>        image: gcr.io/cloudsql-docker/gce-proxy:1.16<br/>        command: ["/cloud_sql_proxy",<br/>          "-instances=&lt;INSTANCE_CONNECTION_NAME&gt;=tcp:3306",<br/>          "-credential_file=/secrets/cloudsql/sql_credentials.json"]<br/>        volumeMounts:<br/>          - name: my-secrets-volume<br/>            mountPath: /secrets/cloudsql<br/>            readOnly: true<br/>    volumes:<br/>      - name: my-secrets-volume<br/>        secret:<br/>          secretName: cloudsql-instance-credentials</span></pre><p id="3de4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在部署我们的应用程序之前，我想描述一下它运行时将要发生的事情，这意味着我需要解释一下Kubernetes是如何运行容器的。当Kubernetes启动pod时，您的容器将运行应用程序，这将生成1，000条雇员记录，然后退出。Kubernetes会监控pod的健康状况，以确定是否需要重启它们。其中一种方法叫做<em class="la">活性探测</em>。它检查容器是否空闲，如果是，就重新启动它。这是一个过于简单的问题，它比那更复杂，如果你想知道更多，文档在这里<a class="ae jt" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="dd8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来会发生什么:应用程序将运行，活性探测器将看到应用程序已经退出，容器处于空闲状态，因此Kubernetes将重启容器。</p><p id="b5b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着容器将重新启动，脚本将再次运行！因此，它将再增加1000名员工，冲洗并重复。</p><p id="e3cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">长话短说(太晚了)，让我们开始吧！要部署的命令是:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="1a52" class="lx jw hi ls b fi ly lz l ma mb">kubectl create -f randomizer_deployment.yaml</span></pre><p id="fc3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将我们的应用程序的单个副本启动到GKE。如果你想更深入地了解Kubernetes，副本、节点、荚等都是你想要学习的术语。简而言之，节点代表运行pod的机器，pod代表容器。这些节点由我们刚刚创建的部署控制，它定义了节点的行为方式。</p><p id="defa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几乎立刻，你应该能跑:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="e9d0" class="lx jw hi ls b fi ly lz l ma mb">kubectl get pods</span></pre><p id="5b00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将会看到如下输出:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="8f20" class="lx jw hi ls b fi ly lz l ma mb">$kubectl get pods</span><span id="e7f3" class="lx jw hi ls b fi mc lz l ma mb">NAME                         READY   STATUS    RESTARTS   AGE<br/>randomizer-7b7845c7d-8vjgq   2/2     Running   0          3s</span></pre><p id="7f48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当它从GCR抓取集装箱时，它可能会先说<code class="du lp lq lr ls b">ContainerConstruction</code>一会儿。如果它显示<code class="du lp lq lr ls b">Running</code>,那就意味着我们已经出发了！你应该能够连接到你的数据库(我只是在shell中使用了<code class="du lp lq lr ls b">mysql</code>，切换到你在我们为<code class="du lp lq lr ls b">DB_NAME</code>创建的秘密中定义的数据库，并运行<code class="du lp lq lr ls b">SELECT * FROM employee;</code>。正如我提到的，由于Kubernetes的工作方式，您会看到行数随着时间的推移不断增加。</p><p id="7310" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这一切都很好，但在这一点上，我们并不比仅仅在本地运行脚本更快。这是因为我们只使用了一个副本。那么现在会发生什么呢？让我们把功率开大一点。为了阻止Kubernetes集群运行脚本，我发现的最简单的方法(可能有更好的方法，再说一次，我不是Kubernetes高手)是将集群的规模缩小到0。您可以通过运行以下命令来实现:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="233b" class="lx jw hi ls b fi ly lz l ma mb">kubectl scale --replicas=0 -f randomizer_deployment.yaml</span></pre><p id="78a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这告诉集群运行零个副本，从而终止现有的运行节点。现在运行<code class="du lp lq lr ls b">kubectl get pods</code>，你会看到你的节点状态为<code class="du lp lq lr ls b">Terminating</code>，或者<code class="du lp lq lr ls b">No resources found.</code>你可能已经看到了它的走向。要扩展我们的应用程序，我们可以运行:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="d7f7" class="lx jw hi ls b fi ly lz l ma mb">kubectl scale --replicas=20 -f randomizer_deployment.yaml</span></pre><p id="9266" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您将看到类似这样的内容:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="815c" class="lx jw hi ls b fi ly lz l ma mb">$ kubectl get pods</span><span id="e1a5" class="lx jw hi ls b fi mc lz l ma mb">NAME                        READY  STATUS             RESTARTS  AGE<br/>randomizer-7b7845c7d-2w6vx  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-2xnmp  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-5g6cc  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-8rc94  2/2    Running            0         4s<br/>randomizer-7b7845c7d-cmv9m  2/2    Running            0         4s<br/>randomizer-7b7845c7d-cqzl8  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-ddskl  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-fbxxc  2/2    Running            0         4s<br/>randomizer-7b7845c7d-hhfm4  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-hxnnd  2/2    Running            0         4s<br/>randomizer-7b7845c7d-jbm2c  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-jxfhk  2/2    Running            0         4s<br/>randomizer-7b7845c7d-m6zwz  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-mhgxn  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-sgvd5  2/2    Running            0         4s<br/>randomizer-7b7845c7d-ss5fm  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-tllg8  0/2    ContainerCreating  0         4s<br/>randomizer-7b7845c7d-xnm96  2/2    Running            0         4s<br/>randomizer-7b7845c7d-xtwd6  2/2    Running            0         4s<br/>randomizer-7b7845c7d-z2528  0/2    ContainerCreating  0         4s</span></pre><p id="df36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在这里，同时运行应用程序的20个实例，愉快地做着它们的事情，被GKE标记为空闲，重新启动，并继续向我们的数据库输入数据。现在，如果您连接到您的数据库并开始运行几次那个<code class="du lp lq lr ls b">SELECT</code>语句，您将看到我们的行数比以前增加得快了很多。</p><p id="ce93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一点故障排除…如果pod的状态显示<code class="du lp lq lr ls b">Error</code>,这通常意味着容器中有东西崩溃或失败。在Kubernetes中调试东西可能会…很困难。到目前为止，我发现的最简单的方法是知道打印到容器中的stdout的任何内容都会被记录，您可以使用<code class="du lp lq lr ls b">kubectl</code>来检索该日志。假设我上面的一个pod:<code class="du lp lq lr ls b">randomizer-7b7845c7d-ss5fm</code>的状态是<code class="du lp lq lr ls b">Error</code>。我可以用这个命令找出是怎么回事:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="1063" class="lx jw hi ls b fi ly lz l ma mb">kubectl logs randomizer-7b7845c7d-ss5fm randomizer</span></pre><p id="284b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>如果您已经缩减到零个副本，这将不起作用。它必须在一个运行的吊舱上。我必须在该命令中再次指定<code class="du lp lq lr ls b">randomizer</code>，因为我们在每个pod中运行两个容器，所以当我请求一个节点的日志时，我必须指定我指的是哪个容器的日志，因为它们是分开保存的。当我运行日志时，作为容器运行的一部分进入stdout/stderr的任何内容都将被转储。在准备这个博客的时候，我有一个<code class="du lp lq lr ls b">Couldn’t connect to the MySQL instance</code>让我困惑了很久。我最终意识到，这是因为在我的脚本启动之前，云SQL代理还没有在其容器中启动。这就是为什么(您将在我的脚本中看到)我在连接数据库时增加了指数后退重试。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es md"><img src="../Images/5b6f7253bf310878273f3085a4c6ab33.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*XImvQ42GFU6df09raDLnKg.png"/></div></figure><h1 id="c03c" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">总结</h1><p id="9ffb" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">所以你有它！使用Kubernetes sidecar模式运行云SQL代理，作为水平扩展应用程序的连接点。希望现在，在gmemegen codelab和我的data faker脚本这两个例子之间，你已经有了一个坚实的基础来启动和运行你自己的应用程序！</p><p id="4439" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要进行清理，您需要删除集群:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="f6e7" class="lx jw hi ls b fi ly lz l ma mb">gcloud container clusters delete randomizer-cluster</span></pre><p id="2dc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，如果你真的想彻底清理门户，删除我们从GCR上传的容器:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="2d4c" class="lx jw hi ls b fi ly lz l ma mb">gcloud container images delete gcr.io/$PROJECT_ID/randomizer</span></pre><p id="ed02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是等等，如果你多次上传容器，你可能会得到一些孤立的图片。两个选项:1)进入控制台<a class="ae jt" href="https://console.cloud.google.com/gcr/images" rel="noopener ugc nofollow" target="_blank">这里</a>(别着急，会说找不到网址，点左边<code class="du lp lq lr ls b">images</code>就行)，手动删除。或者2)运行:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="3d46" class="lx jw hi ls b fi ly lz l ma mb">gcloud container images list-tags gcr.io/$PROJECT_ID/randomizer --filter='-tags:*' --format='get(digest)' --limit=100</span></pre><p id="7c27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后对于每个sha值，像这样运行<code class="du lp lq lr ls b">images delete</code>命令:</p><pre class="jp jq jr js fd lt ls lu lv aw lw bi"><span id="7045" class="lx jw hi ls b fi ly lz l ma mb">gcloud container images delete gcr.io/$PROJECT_ID/randomizer@sha256:cd53812d71ed6e264788cc60d3413774f8553a877ef78b3eacb5c3334c653fc8</span></pre><p id="e8cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应该就是这样了，你的项目现在已经重置，并清除了我们在这篇博客中所做的内容！</p><p id="de3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一点，如果你想像k8s <code class="du lp lq lr ls b">Job</code>一样运行，而不是作为一个连续的集群，请注意有一个问题:代理边盘不会退出，因为它正在愉快地运行，所以<code class="du lp lq lr ls b">Job</code>永远不会完成。有几种方法可以解决这个问题，特别是<a class="ae jt" href="https://stackoverflow.com/questions/41679364/kubernetes-stop-cloudsql-proxy-sidecar-container-in-multi-container-pod-job/64650086#64650086" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出</a>问题有一些很好的讨论和解决方案，当应用程序的其余部分完成工作时，使用<code class="du lp lq lr ls b">SYS_PTRACE</code>安全上下文来杀死代理。</p><p id="18d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">遇到什么问题了吗？请让我知道！请在下面的评论中回复，或者在Twitter上联系我。我的DMs打开了！</p></div></div>    
</body>
</html>