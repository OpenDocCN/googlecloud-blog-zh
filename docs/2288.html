<html>
<head>
<title>Creating Workflows that pause and wait for events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建暂停和等待事件的工作流</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/creating-workflows-that-pause-and-wait-for-events-4da201741f2a?source=collection_archive---------2-----------------------#2022-08-05">https://medium.com/google-cloud/creating-workflows-that-pause-and-wait-for-events-4da201741f2a?source=collection_archive---------2-----------------------#2022-08-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ff6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://cloud.google.com/workflows" rel="noopener ugc nofollow" target="_blank">工作流</a>中，很容易将各种服务链接到一个自动化的工作流中。对于某些用例，您可能需要暂停工作流执行并等待一些输入。这个输入可以是人工批准，也可以是外部服务回调完成工作流所需的数据。</p><p id="08f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过工作流<a class="ae jd" href="https://cloud.google.com/workflows/docs/creating-callback-endpoints" rel="noopener ugc nofollow" target="_blank">回调</a>，工作流可以创建一个HTTP端点并暂停执行，直到它接收到对该端点的HTTP回调。这对于创建中间型工作流非常有用。在之前的<a class="ae jd" href="https://cloud.google.com/blog/topics/developers-practitioners/introducing-workflows-callbacks" rel="noopener ugc nofollow" target="_blank">博客文章</a>，<a class="ae jd" href="https://twitter.com/glaforge" rel="noopener ugc nofollow" target="_blank">中，Guillaume Laforge </a>展示了如何使用回调建立一个带有人工验证的自动化翻译工作流程。</p><p id="884a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回调是很好的，但是必须有人(或某些服务)知道回调端点并对该端点进行HTTP调用。而且，许多服务发送或生成事件，而不是调用HTTP端点。如果您能在收到特定事件时暂停工作流的执行并恢复，那不是很好吗？例如，您可以使用此功能创建工作流，暂停并等待来自发布/订阅主题的新消息或云存储桶中创建的新文件。</p><h1 id="c940" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">事件回调</h1><p id="e40c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">虽然工作流不提供现成的事件回调，但可以通过使用回调、Firestore和Eventarc让工作流执行等待事件。</p><p id="c70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其思想是使用Firestore来存储来自原始工作流的回调细节，使用Eventarc来侦听来自各种事件源的事件，并使用第二个事件触发的工作流来接收来自Eventarc的事件并回调原始工作流中的回调端点。</p><h1 id="c213" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">体系结构</h1><p id="7351" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">以下是更详细的设置:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/47116bf17f551ff5df96009654e8074f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1pyl7NeYZ2gNcLwb.png"/></div></div></figure><ol class=""><li id="448f" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">一个<code class="du lc ld le lf b">callback-event-sample</code>工作流(<a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/blob/master/callback-event/callback-event-sample.yaml" rel="noopener ugc nofollow" target="_blank"> yaml </a>)为一个事件源创建一个回调，它对来自该事件源的等待事件感兴趣。</li><li id="e877" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">它将事件源的回调信息存储在Firestore的一个文档中。</li><li id="5439" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">它继续它的工作流，并在某个时候，开始等待一个事件。</li><li id="d1cf" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">同时，<code class="du lc ld le lf b">callback-event-listener</code> ( <a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/blob/master/callback-event/callback-event-listener.yaml" rel="noopener ugc nofollow" target="_blank"> yaml </a>)准备好被来自一个发布/订阅主题和一个带有Eventarc的云存储桶的事件触发。</li><li id="af12" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">在某些时候，Eventarc接收到一个事件并触发事件监听器。</li><li id="1ee3" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">事件监听器在Firestore中查找事件源的文档。</li><li id="29b3" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">事件监听器回调注册到该事件源的所有回调URL。<code class="du lc ld le lf b">callback-event-sample</code>工作流通过其回调端点接收事件并停止等待。</li><li id="373c" class="kt ku hi ih b ii lg im lh iq li iu lj iy lk jc ky kz la lb bi translated">它从Firestore中删除回调URL并继续执行。</li></ol><p id="f933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">详细的设置说明以及YAML工作流定义在<a class="ae jd" href="https://github.com/GoogleCloudPlatform/workflows-demos/tree/master/callback-event" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><h1 id="3e4e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">试验</h1><p id="17ad" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">要测试事件回调，首先执行示例工作流:</p><pre class="ki kj kk kl fd ll lf lm ln aw lo bi"><span id="fd81" class="lp jf hi lf b fi lq lr l ls lt">gcloud workflows run callback-event-sample</span></pre><p id="4dd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦启动，工作流将暂停并等待，您可以通过Google Cloud Console上的运行状态来确认这一点:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lu"><img src="../Images/4c830407ce005513e88083bcc009cb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/0*KlX3uTEevempyUBl.png"/></div></figure><p id="75d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要测试发布/订阅回调，请发送发布/订阅消息:</p><pre class="ki kj kk kl fd ll lf lm ln aw lo bi"><span id="a6c4" class="lp jf hi lf b fi lq lr l ls lt">TOPIC =topic-callback<br/>gcloud pubsub topics publish $TOPIC --message= "Hello World"</span></pre><p id="afa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在工作流日志中，您应该看到工作流开始和停止等待事件:</p><pre class="ki kj kk kl fd ll lf lm ln aw lo bi"><span id="9dcc" class="lp jf hi lf b fi lq lr l ls lt">Started waiting for an event from source topic-callback<br/>Stopped waiting for an event from source topic-callback</span></pre><p id="d5aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要测试云存储事件，请向云存储上传一个新文件:</p><pre class="ki kj kk kl fd ll lf lm ln aw lo bi"><span id="3a2a" class="lp jf hi lf b fi lq lr l ls lt">BUCKET = $PROJECT_ID-bucket-callback<br/>echo "Hello World" &gt; random.txt gsutil cp random.txt<br/>gs://$BUCKET/random.txt</span></pre><p id="cd3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该看到工作流开始并停止等待事件:</p><pre class="ki kj kk kl fd ll lf lm ln aw lo bi"><span id="5af0" class="lp jf hi lf b fi lq lr l ls lt">Started waiting for an event from source $PROJECT_ID-bucket-callback Stopped waiting for an event from source $PROJECT_ID-bucket-callback</span></pre><p id="7098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，工作流应该停止执行，您还应该在输出中看到接收到的发布/订阅和云存储事件:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lv"><img src="../Images/53893b03e8113f6e58f4520582555e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4vvxt9_Cadff8yud.png"/></div></div></figure><p id="3d3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文讲述了如何使用回调、Firestore和Eventarc创建等待发布/订阅和云存储事件的工作流。您可以扩展示例来监听Eventarc支持的任何<a class="ae jd" href="https://cloud.google.com/eventarc/docs/reference/supported-events" rel="noopener ugc nofollow" target="_blank">事件</a>。如有任何问题或反馈，请随时在Twitter <a class="ae jd" href="https://twitter.com/meteatamel" rel="noopener ugc nofollow" target="_blank"> @meteatamel </a>上联系我。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="1415" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="md">原发布于</em><a class="ae jd" href="https://atamel.dev/posts/2022/08-05_workflows_that_pause_for_events/" rel="noopener ugc nofollow" target="_blank"><em class="md">https://atamel . dev</em></a><em class="md">。</em></p></div></div>    
</body>
</html>