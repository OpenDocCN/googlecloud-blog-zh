<html>
<head>
<title>Golang Before||After Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang前| |后模块</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/golang-before-after-modules-273b5a5df838?source=collection_archive---------2-----------------------#2019-07-08">https://medium.com/google-cloud/golang-before-after-modules-273b5a5df838?source=collection_archive---------2-----------------------#2019-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="07c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我很熟悉(也很喜欢)旧的<code class="du jd je jf jg b">${GOPATH}</code>方法，但为了保持最新，也因为它有很多好处，我已经开始使用Go模块。</p><p id="e6a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和其他人一样，我发现这种转换令人困惑。所以…</p><h2 id="b64d" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">模块之前</h2><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="f2fc" class="jh ji hi jg b fi kk kl l km kn">WORKDIR=[[PATH-TO-YOUR-WORKING-DIRECTORY]]</span><span id="0a8c" class="jh ji hi jg b fi ko kl l km kn">mkdir -p ${WORKDIR}/go<br/>export GOPATH=${WORKDIR}/go<br/>export PATH=${GOPATH}/bin:${PATH}</span><span id="6e79" class="jh ji hi jg b fi ko kl l km kn">mkdir -p {${WORKDIR}/go/src/foo, ${WORKDIR}/go/src/foo/bar}</span></pre><p id="120d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后创建<code class="du jd je jf jg b">${WORKDIR}/go/src/foo/bar/library.go</code>:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="8237" class="jh ji hi jg b fi kk kl l km kn">package bar</span><span id="b368" class="jh ji hi jg b fi ko kl l km kn">func Something() (string) {<br/>    return "Hello Freddie"<br/>}</span></pre><p id="7d2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后创造<code class="du jd je jf jg b">${WORKDIR}/go/src/foo/main.go</code>:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="ebb5" class="jh ji hi jg b fi kk kl l km kn">package main</span><span id="c642" class="jh ji hi jg b fi ko kl l km kn">import (<br/>    "fmt"<br/>    "foo/bar"<br/>)</span><span id="38f0" class="jh ji hi jg b fi ko kl l km kn">func main() {<br/>    fmt.Printf("%s", bar.Something())<br/>}</span></pre><p id="bb45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会有这样一个结构:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="31bc" class="jh ji hi jg b fi kk kl l km kn">.<br/>└── go<br/>    └── src<br/>        └── foo<br/>            ├── bar<br/>            │   └── library.go<br/>            └── main.go</span></pre><p id="eaa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以通过以下任何一种方式运行它:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="fd34" class="jh ji hi jg b fi kk kl l km kn">GO111MODULE=<strong class="jg hj">off</strong> go run ${WORKDIR}/go/src/foo/main.go<br/>Hello Freddie!</span><span id="d1be" class="jh ji hi jg b fi ko kl l km kn">cd ${WORKDIR}/go/src/foo<br/>GO111MODULE=<strong class="jg hj">off</strong> go run main.go<br/>Hello Freddie!</span><span id="1383" class="jh ji hi jg b fi ko kl l km kn">GO111MODULE=<strong class="jg hj">off</strong> go run foo<br/>Hello Freddie!</span></pre><blockquote class="kp kq kr"><p id="4bfb" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>对于上述内容，您可以省略<code class="du jd je jf jg b">GO111MODULE=off</code>，因为当源在<code class="du jd je jf jg b">${GOPATH}</code>内时，这是隐含的。我将它包含在内是为了明确其意图。</p></blockquote><h2 id="3e6a" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">模块后</h2><p id="0a68" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">假设你做到了以上几点！</p><p id="c11a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您不需要执行此步骤，但这是新的最佳实践。我们正在将我们的资源转移到<code class="du jd je jf jg b">${GOPATH}</code>之外。<code class="du jd je jf jg b">${GOPATH}</code>仍然用于存储我们的版本化包。</p><blockquote class="kp kq kr"><p id="721d" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>在这个简单的例子中，我们没有使用外部包，所以<code class="du jd je jf jg b">${GOPATH}</code>保持为空。参见结尾部分的示例。</p></blockquote><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="aa9b" class="jh ji hi jg b fi kk kl l km kn">mv ${WORKDIR}/go/src/foo ${WORKDIR}<br/>rm ${WORKDIR}/go/src</span></pre><p id="5dff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该有这样的结构:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="16a9" class="jh ji hi jg b fi kk kl l km kn">.<br/>├── <strong class="jg hj">foo</strong><br/>│   ├── bar<br/>│   │   └── library.go<br/>│   └── main.go<br/>└── go</span></pre><blockquote class="kp kq kr"><p id="f570" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><strong class="ih hj"> NB </strong>我们植根于<code class="du jd je jf jg b"><strong class="ih hj">foo</strong></code>的资源现在在<code class="du jd je jf jg b">${GOPATH}</code>之外</p></blockquote><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="ab3c" class="jh ji hi jg b fi kk kl l km kn">cd ${WORKDIR}/foo</span><span id="c325" class="jh ji hi jg b fi ko kl l km kn">GO111MODULE=<strong class="jg hj">on</strong> go mod init foo<br/>more go.mod<br/>module foo</span><span id="d0ba" class="jh ji hi jg b fi ko kl l km kn">go 1.12</span><span id="7214" class="jh ji hi jg b fi ko kl l km kn">GO111MODULE=<strong class="jg hj">on</strong> go run foo<br/>Hello Freddie!</span><span id="d2e5" class="jh ji hi jg b fi ko kl l km kn">GO111MODULE=<strong class="jg hj">on</strong> go run main.go<br/>Hello Freddie!</span></pre><h2 id="9f32" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">为了完整性</h2><p id="6123" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">以显示与外部包装的区别。不使用模块，<code class="du jd je jf jg b">go get</code>将包的最新版本拉入<code class="du jd je jf jg b">${GOPATH}/src</code>:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="4d4d" class="jh ji hi jg b fi kk kl l km kn">GO111MODULE=<strong class="jg hj">off</strong> go get github.com/golang/glog</span><span id="80df" class="jh ji hi jg b fi ko kl l km kn">.<br/>├── foo<br/>│   ├── bar<br/>│   │   └── library.go<br/>│   ├── go.mod<br/>│   ├── go.sum<br/>│   └── main.go<br/>└── <strong class="jg hj">go</strong><br/>    └── <strong class="jg hj">src</strong><br/>        └── github.com<br/>            └── golang<br/>                └── glog<br/>                    ├── glog_file.go<br/>                    ├── glog.go<br/>                    ├── glog_test.go<br/>                    ├── LICENSE<br/>                    └── README</span></pre><p id="af68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与使用模块相比，将包的一个特定版本(或多个版本)放入<code class="du jd je jf jg b">${GOPATH}/pkg</code>:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="c17a" class="jh ji hi jg b fi kk kl l km kn">GO111MODULE=<strong class="jg hj">on</strong> go get github.com/golang/glog</span><span id="734b" class="jh ji hi jg b fi ko kl l km kn">.<br/>├── foo<br/>│   ├── bar<br/>│   │   └── library.go<br/>│   ├── go.mod<br/>│   ├── go.sum<br/>│   └── main.go<br/>└── go<br/>    └── <strong class="jg hj">pkg</strong><br/>        ├── linux_amd64<br/>        │   └── github.com<br/>        │       └── golang<br/>        │           └── glog.a<br/>        └── mod<br/>            ├── cache<br/>            │   ├── download<br/>            │   │   └── github.com<br/>            │   │       └── golang<br/>            │   │           └── glog<br/>            └── github.com<br/>                └── golang<br/>                    └── glog@v0.0.0-20160126235308-23def4e6c14b<br/>                        ├── glog_file.go<br/>                        ├── glog.go<br/>                        ├── glog_test.go<br/>                        ├── LICENSE<br/>                        └── README</span></pre><h2 id="1429" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">Go模块镜像</h2><p id="e02f" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">参见<code class="du jd je jf jg b"><a class="ae lb" href="https://proxy.golang.org/" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org/</a></code></p><p id="82f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将<code class="du jd je jf jg b">PROXY=https://proxy.golang.org</code>包含在所有上述命令中，以利用Golang团队的(基于Google Trillian的)镜像:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="e401" class="jh ji hi jg b fi kk kl l km kn">GO111MODULE=on \<br/>GOPROXY=https://proxy.golang.org \<br/>go get github.com/golang/glog</span></pre><h2 id="79f5" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">欺骗</h2><p id="c241" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">多亏了这个<a class="ae lb" href="https://www.reddit.com/r/golang/comments/9blgn0/using_go_modules_with_vendorprovided_protobuf/" rel="noopener ugc nofollow" target="_blank">链接</a>这个有用的技巧，当使用模块时，可以找到将要安装在<code class="du jd je jf jg b">go/pkg/mod</code>中某处的包:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="33c4" class="jh ji hi jg b fi kk kl l km kn">GO111MODULE=on \<br/>go list -f '{{ .Dir }}' github.com/golang/glog</span><span id="6e58" class="jh ji hi jg b fi ko kl l km kn">go: finding github.com/golang/glog latest<br/>/path/to/go/pkg/mod/github.com/golang/glog@v0.0.0-20160126235308-23def4e6c14b</span></pre><h2 id="8e22" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">Visual Studio代码</h2><p id="749e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">一些人询问我对Visual Studio代码w/ Go模块的配置设置。以下是我所知道的:</p><pre class="kc kd ke kf fd kg jg kh ki aw kj bi"><span id="c72e" class="jh ji hi jg b fi kk kl l km kn">{<br/>    "go.autocompleteUnimportedPackages": true,<br/>    "go.useLanguageServer": true,<br/>    "[go]": {<br/>        "editor.snippetSuggestions": "none",<br/>        "editor.formatOnSave": true,<br/>        "editor.codeActionsOnSave": {<br/>            "source.organizeImports": true<br/>        }<br/>    },<br/>    "gopls": {<br/>        "usePlaceholders": true // add parameter placeholders when completing a function<br/>    },<br/>    "files.eol": "\n", // formatting only supports LF line endings    <br/>    "go.toolsEnvVars": {<br/>        "GO111MODULE": "on",<br/>        "GOPROXY": "<a class="ae lb" href="https://proxy.golang.org" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org</a>"<br/>    },<br/>}</span></pre><p id="7462" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个<a class="ae lb" href="https://github.com/Microsoft/vscode-go/wiki/Go-modules-support-in-Visual-Studio-Code" rel="noopener ugc nofollow" target="_blank">页面</a>的帮助和这个<a class="ae lb" href="https://github.com/golang/go/issues/32903#issuecomment-507817147" rel="noopener ugc nofollow" target="_blank">来自谷歌工程师的回复</a>的组合。我试着跟上潮流，但是Golang团队的gopls完全忽略了我:(</p><p id="ae2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b"><a class="ae lb" href="https://github.com/golang/go/wiki/gopls" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/go/wiki/gopls</a></code></p><h2 id="66e7" class="jh ji hi bd jj jk jl jm jn jo jp jq jr iq js jt ju iu jv jw jx iy jy jz ka kb bi translated">结论</h2><p id="a8d3" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">模块是Golang包管理的<a class="ae lb" href="https://github.com/golang/go/wiki/Modules" rel="noopener ugc nofollow" target="_blank">未来</a>。现在开始暴跌，我主要看到了好处。即使使用我简单的Golang repos，也可以定义导入的包的特定版本。</p><p id="f0eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，我不理解(也许现在仍然不理解)不把我的源代码包含在<code class="du jd je jf jg b">${GOPATH}</code>下的好处，但是，一个好处是，它变得更加明显，哪些源代码是我的源代码，哪些是其他的包。当一切都在<code class="du jd je jf jg b">${GOPATH}</code>之下时，这是令人困惑的。</p><p id="5bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某种程度上，语义版本化(又名SemVer)的使用也意味着，一旦您已经<code class="du jd je jf jg b">go get useful-package@v1.0.0</code>您应该(！)再也不需要重新<code class="du jd je jf jg b">get</code>它了。我以前总是按照项目来区分我的<code class="du jd je jf jg b">${GOPATH}</code>目录，以保持代码隔离。但是，通过将我的源代码从<code class="du jd je jf jg b">${GOPATH}</code>中取出来，因为我只需要一份<code class="du jd je jf jg b">useful-package@v1.0.0</code>的副本。)因为我知道这个包是不可变的，所以我现在将开始为我的所有项目使用一个单一的中央<code class="du jd je jf jg b">${GOPATH}</code>。</p><p id="01ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！</p></div></div>    
</body>
</html>