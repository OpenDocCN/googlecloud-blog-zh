<html>
<head>
<title>Accessing GKE private clusters through IAP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过IAP访问GKE专用集群</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/accessing-gke-private-clusters-through-iap-14fedad694f8?source=collection_archive---------0-----------------------#2021-10-26">https://medium.com/google-cloud/accessing-gke-private-clusters-through-iap-14fedad694f8?source=collection_archive---------0-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="356b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">TL；博士</strong></h1><p id="aed0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">本文展示了如何利用代理和IAP隧道连接到GKE专用集群的控制平面。</p><h1 id="b32b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">相关工作和动机</h1><p id="de2a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在写这篇文章的时候，我发现了一些有趣的工作，我希望你能把它们看作是这篇文章的补充，在决定可能适合你的道路之前，它们绝对值得回顾。</p><p id="f677" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae kg" href="https://cloud.google.com/architecture/creating-kubernetes-engine-private-clusters-with-net-proxies" rel="noopener ugc nofollow" target="_blank">官方谷歌云文档</a>提供了访问私有集群的教程，利用直接安装在GKE集群上的代理。<br/>虽然这种方法比本文中描述的方法更轻量级，但随着时间的推移，我注意到它并不适用于每个人，因为不同的用户更喜欢将代理与他们的集群分开，所以如果集群本身有问题，他们不会冒险失去对它的访问。</p><p id="c05e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">更令人惊讶的是，几乎在我写作的最后，我发现了一篇由<a class="kh ki ge" href="https://medium.com/u/e263b759b3b0?source=post_page-----14fedad694f8--------------------------------" rel="noopener" target="_blank"> Peter Hrvola </a>撰写的<a class="ae kg" rel="noopener" href="/google-cloud/gke-private-cluster-with-a-bastion-host-5480b44793a7">旧文章</a>提出了与我描述的相同的方法。虽然我确保了我在本文中使用的命令的语法一致，以避免产生混淆(基本上是修改参数的顺序)，但我觉得围绕同一个解决方案给出类似的视图可能仍然为读者增加了价值。然后我决定在这里提到<a class="ae kg" rel="noopener" href="/google-cloud/gke-private-cluster-with-a-bastion-host-5480b44793a7"> Peter的文章</a>，并继续出版。</p><p id="024a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">下面提供的例子与一些工作平台代码相关，这些代码可以在</strong> <a class="ae kg" href="https://github.com/terraform-google-modules/cloud-foundation-fabric/tree/master/examples/networking/shared-vpc-gke" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> <em class="kj">云基础结构库</em> </strong> </a> <strong class="jf hj">中找到。示例代码允许创建一个共享的VPC、一个GKE集群和一个安装了TinyProxy的bastion主机。</strong></p><h1 id="13df" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak"> GKE私人集群</strong></h1><p id="9c6d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">GKE私有集群正变得越来越重要，尤其是在生产部署方面。</p><p id="7dc1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">虽然私有集群是提供主节点和工作节点与互联网更强隔离的重要资源，但它们的配置有时看起来更复杂和混乱。这包括管理员如何从他们的客户端连接到控制平面，以便与Kubernetes APIs进行交互。</p><p id="9db6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">私有集群利用<a class="ae kg" href="https://cloud.google.com/vpc/docs/vpc-peering" rel="noopener ugc nofollow" target="_blank"> VPC对等</a>来连接控制平面和工人。因此，只能从工作人员居住的VPC通过私有IP地址访问主节点。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/d4e1b037c013d99a93c782f3f6effa63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RoJNNOIyal4hKN6n_1EMiw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">典型的GKE集群部署</figcaption></figure><p id="c098" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">重要的是要记住，VPC peering是不可传递的连接。此外，从内部客户端到主服务器的路径可能仍然很长且很复杂，因此需要非常重要的布线(路由、NAT规则、防火墙规则等等)。<br/>用户怎样才能安全、私密地连接到控制平面，而不经过复杂的网络设置？</p><h1 id="d5a1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">身份感知代理(IAP)隧道</strong></h1><p id="d330" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae kg" href="https://cloud.google.com/iap/docs/using-tcp-forwarding" rel="noopener ugc nofollow" target="_blank">身份感知代理(IAP)隧道</a>允许用户将来自Google外部的TCP流量转发到他们的GCE实例，而不会直接暴露在互联网上。<br/>用户不是直接连接到终端机器，而是通过gcloud或控制台调用公共的Google Cloud API，这将创建一个WebSocket隧道来封装私有流量。Google对请求进行授权，并充当用户与其虚拟机之间的桥梁。</p><p id="a4b3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">就像普通的SSH一样，IAP隧道也可以用来建立到其他主机的连接，“跳过”用户连接的第一台机器。让我们看一个例子:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es la"><img src="../Images/b668b64d7d1720ad91ee4cef0c01fc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUkzgmJ1TGNCAI2oK9P5Dg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">管理员连接到目标虚拟机，利用通过jump-vm的IAP隧道。两台机器都只配置了私有IP。</figcaption></figure><p id="f81b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在本例中，客户端利用通过跳转主机创建的IAP隧道，从本地连接到目标虚拟机。这很容易实现，只需在客户机上键入几个命令:</p><pre class="kl km kn ko fd lb lc ld le aw lf bi"><span id="79bc" class="lg ig hi lc b fi lh li l lj lk"><em class="kj"># Create the SSH tunnel<br/>gcloud compute ssh jump-vm \<br/>  --project my-test-project \<br/>  --zone europe-west1-b \<br/>  -- -L 2222:192.168.0.200:22 -N -q -f</em></span><span id="9262" class="lg ig hi lc b fi ll li l lj lk"># Connect to the destination VM<br/>ssh 127.0.0.1 -p 2222</span></pre><p id="db04" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">需要注意的是，为了让这个例子工作，应该在VPC中设置两个入口<a class="ae kg" href="https://cloud.google.com/vpc/docs/firewalls" rel="noopener ugc nofollow" target="_blank">防火墙规则</a>:</p><ul class=""><li id="641e" class="lm ln hi jf b jg kb jk kc jo lo js lp jw lq ka lr ls lt lu bi translated"><a class="ae kg" href="https://cloud.google.com/iap/docs/using-tcp-forwarding" rel="noopener ugc nofollow" target="_blank">允许从<em class="kj">35 . 235 . 240 . 0/20</em>(Google IAP知名IP范围)</a>进入jump-vm，端口<em class="kj"> TCP 2222 </em></li><li id="7798" class="lm ln hi jf b jg lv jk lw jo lx js ly jw lz ka lr ls lt lu bi translated">允许从<em class="kj"> 192.168.0.100/32 </em>进入目的地虚拟机，端口<em class="kj"> TCP 22 </em></li></ul><h1 id="ca2a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">解决方案</strong></h1><p id="45e9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们开始把几个概念放在一起:</p><ul class=""><li id="5909" class="lm ln hi jf b jg kb jk kc jo lo js lp jw lq ka lr ls lt lu bi translated">Kubernetes客户端通过HTTPS连接到Kubernetes APIs。这意味着连接可以被代理！</li><li id="0e77" class="lm ln hi jf b jg lv jk lw jo lx js ly jw lz ka lr ls lt lu bi translated">为了在TCP 443端口上建立HTTPS连接，我们可以利用IAP隧道，如上所述</li></ul><p id="2b58" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这让我们想到了解决方案:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ma"><img src="../Images/8183ad9c73aea35d628642aad5849d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1ZIc9mlZNtzvLT1O8XdYA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">管理员连接到GKE控制平面，利用通过jump-vm的IAP隧道。</figcaption></figure><p id="e19b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这个例子中，我们将使用大多数Linux发行版免费提供的<a class="ae kg" href="http://tinyproxy.github.io/" rel="noopener ugc nofollow" target="_blank"> TinyProxy </a>。</p><p id="5207" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，让我们<strong class="jf hj">部署一个连接到工人居住的同一个VPC的虚拟机。</strong>一旦安装完毕，让我们<strong class="jf hj">设置TinyProxy </strong></p><pre class="kl km kn ko fd lb lc ld le aw lf bi"><span id="cbaf" class="lg ig hi lc b fi lh li l lj lk"><em class="kj">apt update<br/>apt install -y tinyproxy</em></span><span id="a1a7" class="lg ig hi lc b fi ll li l lj lk"><em class="kj"># Edit the /etc/tinyproxy/tinyproxy.conf adding this line<br/>Allow localhost</em></span><span id="9986" class="lg ig hi lc b fi ll li l lj lk"><em class="kj">service tinyproxy restart</em></span></pre><p id="18f0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这也可以通过幂等函数<a class="ae kg" href="https://cloud.google.com/compute/docs/instances/startup-scripts/linux" rel="noopener ugc nofollow" target="_blank">启动脚本</a>自动完成:</p><pre class="kl km kn ko fd lb lc ld le aw lf bi"><span id="d508" class="lg ig hi lc b fi lh li l lj lk"><em class="kj">#! /bin/bash<br/>apt-get update<br/>apt-get install -y tinyproxy<br/>grep -qxF ‘Allow localhost’ /etc/tinyproxy/tinyproxy.conf || echo ‘Allow localhost’ &gt;&gt; /etc/tinyproxy/tinyproxy.conf<br/>service tinyproxy restart</em></span></pre><p id="a6ac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在GCP，让我们<a class="ae kg" href="https://cloud.google.com/vpc/docs/using-firewalls" rel="noopener ugc nofollow" target="_blank">添加一个防火墙规则</a>来允许从<a class="ae kg" href="https://cloud.google.com/iap/docs/using-tcp-forwarding" rel="noopener ugc nofollow" target="_blank"><em class="kj">35 . 235 . 240 . 0/20</em>IAP范围</a>到代理机器的连接。</p><p id="3aed" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">我们现在可以转移到本地客户端机器</strong>，其中安装了<a class="ae kg" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> gcloud </em> </a>和<a class="ae kg" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> kubectl </em> </a>。</p><p id="6844" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，让我们<a class="ae kg" href="https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-access-for-kubectl" rel="noopener ugc nofollow" target="_blank">下载Kubernetes集群配置</a>:</p><pre class="kl km kn ko fd lb lc ld le aw lf bi"><span id="8950" class="lg ig hi lc b fi lh li l lj lk"><em class="kj">gcloud container clusters get-credentials my-test-cluster \<br/>  --zone europe-west1-b \<br/>  --project my-test-project \<br/>  --internal-ip</em></span></pre><p id="529e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">利用IAP创建一个隧道(默认情况下，TinyProxy监听端口8888):</p><pre class="kl km kn ko fd lb lc ld le aw lf bi"><span id="9aef" class="lg ig hi lc b fi lh li l lj lk"><em class="kj">gcloud compute ssh my-bastion-vm \<br/>  --project my-test-project \<br/>  --zone europe-west1-b \<br/>  -- -L 8888:localhost:8888 -N -q -f</em></span></pre><p id="7195" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们现在可以利用代理运行kubectl并访问Kubernetes APIs:</p><pre class="kl km kn ko fd lb lc ld le aw lf bi"><span id="1203" class="lg ig hi lc b fi lh li l lj lk"><em class="kj">HTTPS_PROXY=localhost:8888 kubectl get pods<br/></em>NAME        READY   STATUS    RESTARTS   AGE<br/>demo        1/1     Running   0          19h<br/>nginx       1/1     Running   0          24h</span></pre><p id="22bf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kj">HTTPS _代理</em>变量也可以导出(<em class="kj">导出HTTPS _代理=… </em>)，不用每次运行kubectl前都输入。无论如何，这将使所有的连接都通过代理，包括那些不指定给kubectl的连接，直到变量不被重置。这两种形式中的哪一种最适合他们的需求，这取决于用户。</p><h1 id="b1b8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">后续行动</h1><p id="a5e6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在下一篇文章中，我们将看到如何类似地利用代理，以便从其他VPC连接到GKE私有集群的控制平面。</p><p id="b292" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kj">感谢</em><a class="kh ki ge" href="https://medium.com/u/4eb6c1562d42?source=post_page-----14fedad694f8--------------------------------" rel="noopener" target="_blank"><em class="kj">Ludovico magno avallo</em></a><em class="kj">帮我复习这篇文章！</em></p></div></div>    
</body>
</html>