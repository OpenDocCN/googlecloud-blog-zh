<html>
<head>
<title>Ruby Meets BigQuery: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby遇上BigQuery:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/ruby-meets-bigquery-part-2-2798b21133a0?source=collection_archive---------6-----------------------#2016-07-15">https://medium.com/google-cloud/ruby-meets-bigquery-part-2-2798b21133a0?source=collection_archive---------6-----------------------#2016-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="00f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的文章中，我展示了我如何使用BigQuery根据下载量计算出哪些宝石是最受欢迎的。我还展示了如何找出哪个版本的gems最受欢迎。但是使用下载数据有一些缺点。一家拥有大量服务器并经常更新的大公司(假设他们不出售gems或使用机器映像)很容易扭曲数据。幸运的是，还有另一个数据来源。</p><h2 id="6915" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">BigQuery中的GitHub数据</h2><p id="2b6b" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">最近，谷歌云平台和GitHub在BigQuery上提供了来自近300万个开源存储库的数据。这个数据提供了另一种衡量宝石受欢迎程度的方法。我对此很兴奋，因为这给了我另一种方法来衡量宝石的受欢迎程度。除了查看它被下载的原始次数，我还可以看到有多少项目在他们的Gemfile中包含了它(假设他们有一个)。</p><p id="68c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://cloud.google.com/bigquery/public-data/github" rel="noopener ugc nofollow" target="_blank">GitHub数据集</a>很大(超过3TB)。BigQuery可以快速查询整个数据集。我的大多数查询不到30秒。但是对于每个查询，我都要检查数百万不包含不必要的Ruby文件的行。此外，查询整个数据集可能会很昂贵。</p><p id="ef9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让我的查询稍微快一点并且便宜很多，我需要限制我的查询，只需要查看Gemfiles、Rakefiles和。rb文件。一种简单的方法是将这些行提取到它们自己的数据集中。</p><p id="e70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是提取所有名为Gemfile、Gemfile.lock或Rakefile的文件的查询。我把它们放在新数据集中的一个表中。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="d537" class="je jf hi kj b fi kn ko l kp kq">SELECT * <br/>FROM [bigquery-public-data:github_repos.files] <br/>WHERE path IN ('Gemfile', 'Gemfile.lock', 'Rakefile')</span></pre><p id="89eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个查询提取所有的。rb文件。我使用正确的命令将文件路径的最后三个字符与字符串'进行比较。rb '。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="d599" class="je jf hi kj b fi kn ko l kp kq">SELECT * <br/>FROM [bigquery-public-data:github_repos.files] <br/>WHERE RIGHT(path, 3) = '.rb'</span></pre><p id="1f91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些进了另一张桌子。我把宝石锉和耙子锉从。rb文件因为格式不同，所以需要不同的查询来分析。</p><h2 id="5c38" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">查询数据集</h2><p id="84fc" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">让我们看看有多少。rb文件已被提取。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="8812" class="je jf hi kj b fi kn ko l kp kq">SELECT count(*) as num <br/>FROM [rb_files]</span><span id="3a14" class="je jf hi kj b fi kr ko l kp kq">|   num    |<br/>|----------|<br/>| 19861839 |</span></pre><p id="35cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以GitHub数据集中有19，861，839个以. rb结尾的文件。gem file偶尔会被非Ruby项目使用(例如Cocoapods ),所以我预计还有相当数量的gem file和Rakefiles。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="8cb8" class="je jf hi kj b fi kn ko l kp kq">SELECT count(*) as num <br/>FROM [gem_rake_contents]</span><span id="ccd7" class="je jf hi kj b fi kr ko l kp kq">|  num   |<br/>|--------|<br/>| 251420 |</span></pre><p id="02f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些数字并不特别有趣。我想知道最常见的宝石是什么。一种方法是解析gem文件并提取gem名称。为此，首先我需要将Gemfile的内容分成几行，这可以用split函数来完成。在我分割了这些行之后，我可以使用REGEXP_EXTRACT来提取宝石名称。最后，因为我想包括依赖项和指定的gem，所以我将只在Gemfile.lock上运行这个查询。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="d4ae" class="je jf hi kj b fi kn ko l kp kq">SELECT REGEXP_EXTRACT(line, r"\s*gem\s['\"](.*?)['\"]") as gem <br/>FROM ( <br/>  SELECT SPLIT(content, '\n') as line <br/>  FROM github_ruby.gem_rake_contents <br/>) <br/>HAVING gem IS NOT NULL</span><span id="c3a7" class="je jf hi kj b fi kr ko l kp kq">|     gem       |<br/>|---------------|<br/>| sinatra       |<br/>| mongoid       |<br/>| thin          |<br/>| rake          |<br/>| bcrypt-ruby   |<br/>| rspec         |<br/>| rack-test     |<br/>| mongoid-rspec |<br/>| simplecov     |<br/>| fivemat       |<br/>| factory_girl  |<br/>| timecop       |</span></pre><p id="ef98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了我们宝石的名字，但它没有给我们任何排序。它只是列出了所有宝石的名称。为了找出最受欢迎的宝石，我需要做一些分组。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9e43" class="je jf hi kj b fi kn ko l kp kq">SELECT gem, COUNT(*) AS n <br/>FROM ( <br/>  SELECT REGEXP_EXTRACT(line, r"\s*gem\s['\"](.*?)['\"]") AS gem<br/>  FROM ( <br/>    SELECT SPLIT(content, '\n') AS line <br/>    FROM github_ruby.gem_rake_contents <br/>  ) <br/>  HAVING gem IS NOT NULL <br/>) <br/>GROUP BY gem <br/>ORDER BY n DESC <br/>LIMIT 10</span><span id="0c6e" class="je jf hi kj b fi kr ko l kp kq">| gem          |     n |<br/>|--------------+-------|<br/>| rails        | 33227 |<br/>| jquery-rails | 19709 |<br/>| uglifier     | 18369 |<br/>| sass-rails   | 17857 |<br/>| coffee-rails | 16145 |<br/>| rspec        | 15829 |<br/>| rake         | 15683 |<br/>| therubyracer | 14081 |<br/>| pg           | 14029 |<br/>| unicorn      | 13696 |</span></pre><h2 id="9559" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">结论</h2><p id="b31d" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">使用Rubygems.org下载数据，最流行的gem是rake、rack、multi_json、json和bundler。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9cb1" class="je jf hi kj b fi kn ko l kp kq">| name       | count       |<br/>|------------+-------------|<br/>| rake       | 214,152,212 |<br/>| rack       | 201,911,759 |<br/>| multi_json | 200,342,260 |<br/>| json       | 191,430,173 |<br/>| bundler    | 186,172,479 |</span></pre><p id="dc5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用GitHub数据，最流行的gem是rails、jquery-rails、uglifier和sass-rails。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="ee91" class="je jf hi kj b fi kn ko l kp kq">| gem          |     n |<br/>|--------------+-------|<br/>| rails        | 33227 |<br/>| jquery-rails | 19709 |<br/>| uglifier     | 18369 |<br/>| sass-rails   | 17857 |<br/>| coffee-rails | 16145 |<br/>| rspec        | 15829 |<br/>| rake         | 15683 |<br/>| therubyracer | 14081 |<br/>| pg           | 14029 |<br/>| unicorn      | 13696 |</span></pre><p id="31f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最受欢迎的宝石并不总是一致的。这可能是因为一些gem(rake和json)是每次Ruby安装时安装的默认gem。这将导致它们比任何其他gem都有更高的下载量，并且不会出现在gem文件中，因为它们被认为已经被下载了。</p><p id="9127" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种差异就是为什么使用两个或更多的数据源是一个好主意，如果你试图概括什么是最流行的。在选举季节<a class="ae jd" href="http://fivethirtyeight.com/" rel="noopener ugc nofollow" target="_blank">人们做预测</a>结合来自几次民意调查的信息，并使用其他数据得出他们的结论。我们可以通过结合Rubygems.org和GitHub的数据来确定最受欢迎的红宝石。</p><p id="b526" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想玩GitHub数据，你可以访问它<a class="ae jd" href="https://cloudplatform.googleblog.com/2016/06/GitHub-on-BigQuery-analyze-all-the-open-source-code.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1e95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">07/15/16</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="3e88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kz">原载于2016年7月15日</em><a class="ae jd" href="http://www.thagomizer.com/blog/2016/07/15/ruby-meets-bigquery-part-two.html" rel="noopener ugc nofollow" target="_blank"><em class="kz">www.thagomizer.com</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>