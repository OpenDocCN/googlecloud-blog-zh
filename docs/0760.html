<html>
<head>
<title>Firebase: Developing an App Engine service with Python and Cloud Firestore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase:使用Python和云Firestore开发应用引擎服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/firebase-developing-an-app-engine-service-with-python-and-cloud-firestore-1640f92e14f4?source=collection_archive---------0-----------------------#2018-09-10">https://medium.com/google-cloud/firebase-developing-an-app-engine-service-with-python-and-cloud-firestore-1640f92e14f4?source=collection_archive---------0-----------------------#2018-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d3e9819aea38221812d23a42683526a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUR9qHxLhL5iQjqlQlqq2Q.jpeg"/></div></div></figure><div class=""/><p id="414d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我之前的文章<a class="ae jo" rel="noopener" href="/@hiranya911/firebase-using-the-python-admin-sdk-on-google-cloud-functions-590f50226286"/>中，我展示了如何使用<a class="ae jo" href="https://cloud.google.com/functions/" rel="noopener ugc nofollow" target="_blank">谷歌云功能</a>部署Python web服务。该服务使用<a class="ae jo" href="https://firebase.google.com/docs/admin/setup" rel="noopener ugc nofollow" target="_blank"> Firebase管理SDK </a>来读写<a class="ae jo" href="https://firebase.google.com/docs/database/" rel="noopener ugc nofollow" target="_blank"> Firebase实时数据库</a>。在这篇文章中，我们将把同样的服务迁移到<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">谷歌应用引擎(GAE) </a>标准环境中。但更重要的是，我们将通过使用<a class="ae jo" href="https://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank">谷歌云Firestore </a>而不是实时数据库来增加赌注。</p><p id="44b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一件大事，因为开发人员在很长一段时间内无法从GAE标准环境中访问云Firestore。谷歌云Firestore的Python客户端使用多线程，这在GAE标准中是不允许的。那么是什么改变了呢？</p><p id="a3a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谷歌云平台最近为GAE推出了第二代Python 3.7运行时<a class="ae jo" href="https://cloud.google.com/blog/products/gcp/introducing-app-engine-second-generation-runtimes-and-python-3-7" rel="noopener ugc nofollow" target="_blank">。这个新的运行时没有旧的Python 2.7运行时的线程限制。它还放松了其他几个恼人的限制，这些限制过去常常让开发者抓狂。具体来说，新的运行时允许开发人员使用任何依赖项，直接访问远程端点，甚至访问本地文件系统的<code class="du jp jq jr js b">/tmp</code>目录。旧运行时</a>的限制可以追溯到2008年左右，有很好的理由——主要是为了确保运行在共享基础设施上的应用程序的安全性和隔离性。但是从那以后，容器和用户空间内核技术，如<a class="ae jo" href="https://github.com/google/gvisor" rel="noopener ugc nofollow" target="_blank"> gVisor </a>开始发挥作用。因此，开发人员现在可以享受更多的自由和权力，同时保持与以前相同的安全和隔离级别。</p><p id="b603" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住这一点，让我们继续实现一个从GAE标准环境连接到Firestore的web服务。</p><h2 id="928e" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">设置开发环境</h2><p id="f856" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">您将需要一个启用计费的Firebase项目，以及一个本地安装的<code class="du jp jq jr js b"><a class="ae jo" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank">gcloud</a></code>命令行工具。如果你的项目是全新的，确保为它启用<a class="ae jo" href="https://firebase.google.com/docs/firestore/quickstart" rel="noopener ugc nofollow" target="_blank"> Firestore支持</a>和<a class="ae jo" href="https://cloud.google.com/appengine/docs/standard/python3/quickstart" rel="noopener ugc nofollow" target="_blank"> App引擎支持</a>。您还需要Python 3和<code class="du jp jq jr js b"><a class="ae jo" href="https://virtualenv.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank">virtualenv</a></code>实用程序。在Linux/Unix shell中执行以下命令来设置开发环境。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="a263" class="jt ju ht js b fi lb lc l ld le">$ gcloud config set project &lt;your-project-id&gt;<br/>$ virtualenv -p python3 env<br/>$ source env/bin/activate<br/>(env) $ mkdir heroes<br/>(env) $ cd heroes/</span></pre><p id="9ac1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些命令为您的应用程序创建一个新的<code class="du jp jq jr js b">virtualenv</code>沙箱，并创建一个名为<code class="du jp jq jr js b">heroes</code>的新的空目录。我们将使用这个目录来存放与您的服务相关的所有源文件。</p><p id="6e23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，您需要设置Google <a class="ae jo" href="https://cloud.google.com/docs/authentication/production" rel="noopener ugc nofollow" target="_blank">应用程序默认凭证</a>。这使您能够在将服务部署到GAE之前对其进行本地测试。本地测试确实产生了一些额外的工作，但是从长远来看，它节省了大量的时间和精力。为您的Firebase项目下载一个<a class="ae jo" href="https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk" rel="noopener ugc nofollow" target="_blank">服务帐户</a> JSON文件，并设置<code class="du jp jq jr js b">GOOGLE_APPLICATION_CREDENTIALS</code>环境变量指向它。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="68b6" class="jt ju ht js b fi lb lc l ld le">(env) $ export GOOGLE_APPLICATION_CREDENTIALS=path/to/creds.json</span></pre><p id="3f1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务帐户JSON文件不应与您的应用程序在同一个目录中。单独保存，确保不会不小心上传到云端。</p><h2 id="32d4" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">实现服务</h2><p id="3c46" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们的web服务将只包含3个文件:</p><ul class=""><li id="b9de" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><code class="du jp jq jr js b">requirements.txt</code> —声明所需的依赖关系</li><li id="e0cc" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><code class="du jp jq jr js b">main.py</code> —包含实现我们服务的Python源代码</li><li id="d1e8" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><code class="du jp jq jr js b">app.yaml</code>—GAE部署描述符</li></ul><p id="4570" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从创建<code class="du jp jq jr js b">requirements.txt</code>文件开始。过去开发者不得不将<a class="ae jo" href="https://cloud.google.com/appengine/docs/standard/python/tools/using-libraries-python-27" rel="noopener ugc nofollow" target="_blank">厂商在</a>的所有依赖项放到一个单独的子目录中，并将其作为应用程序的一部分上传。但是对于新的运行时，我们只是在一个<code class="du jp jq jr js b">requirements.txt</code>文件中声明依赖关系。GAE自动获取并安装以这种方式声明的依赖项。清单1显示了这个文件在我们的例子中应该是什么样子。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单1:依赖声明(requirements.txt)</figcaption></figure><p id="bc5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常你不需要宣布<code class="du jp jq jr js b">google-cloud-firestore</code>为属地。Firebase Admin SDK应该会自动为您安装。但是有一个<a class="ae jo" href="https://github.com/firebase/firebase-admin-python/issues/184" rel="noopener ugc nofollow" target="_blank">已知问题</a>是由 <code class="du jp jq jr js b"><a class="ae jo" href="https://github.com/pypa/pip/issues/4957" rel="noopener ugc nofollow" target="_blank">pip</a></code>中的<a class="ae jo" href="https://github.com/pypa/pip/issues/4957" rel="noopener ugc nofollow" target="_blank"> bug引起的，这有时会阻止它正确工作。解决这个问题最简单的方法是将<code class="du jp jq jr js b">google-cloud-firestore</code>声明为直接依赖。清单1就绪后，运行下面的命令在开发环境中安装依赖项，这样就可以在本地测试服务了。</a></p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="d667" class="jt ju ht js b fi lb lc l ld le">(env) $ pip install -r requirements.txt</span></pre><p id="fce0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候编写我们的web服务了。我们使用Flask来处理所有的请求路由，使用Firebase Admin SDK来初始化Firestore客户端实例。清单2展示了完整的实现。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单2: Web服务实现(main.py)</figcaption></figure><p id="7bb0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，这几乎与几个月前我们为Google计算引擎环境<a class="ae jo" rel="noopener" href="/google-cloud/firebase-developing-a-web-service-with-admin-sdk-flask-and-google-cloud-6fb97eb38b80">实现的Python应用程序</a>相同。事实上，如果将该实现中的实时数据库调用替换为Firestore调用，就会得到清单2。<code class="du jp jq jr js b">__main__</code>部分仅在本地测试期间被调用。在生产环境中，GAE将为您提供合适的应用服务器，如<code class="du jp jq jr js b">gunicorn</code>。</p><p id="231c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们创建名为<code class="du jp jq jr js b">app.yaml</code>的GAE部署描述符。这里唯一需要注意的是<code class="du jp jq jr js b">runtime: python37</code>条目。清单3显示了最终结果。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">清单3: GAE部署描述符(app.yaml)</figcaption></figure><h2 id="063b" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">在本地测试</h2><p id="9aee" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">是时候去兜一圈了。只需按如下方式启动<code class="du jp jq jr js b">main.py</code>即可启动并运行服务。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="22ce" class="jt ju ht js b fi lb lc l ld le">(env) $ python main.py</span></pre><p id="4cf2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将启动一个监听端口8080的web服务器。您可以向它发送几个请求，以确保一切按预期运行。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="39de" class="jt ju ht js b fi lb lc l ld le">(env) $ curl -v -X POST -d '{"name":"Spider-Man"}' -H "Content-type: application/json" <a class="ae jo" href="http://localhost:5000/heroes" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/heroes</a><br/>&lt; HTTP/1.0 201 CREATED<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 35<br/>&lt; Server: Werkzeug/0.14.1 Python/3.6.1<br/>&lt; Date: Fri, 07 Sep 2018 22:54:57 GMT<br/>&lt;<br/>{<br/>   "id": "oit8FKTbPVHgrtTtgKZ7"<br/>}</span><span id="1ca8" class="jt ju ht js b fi lz lc l ld le">(env) $ curl -v <a class="ae jo" href="http://localhost:8080/heroes/oit8FKTbPVHgrtTtgKZ7" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/heroes/oit8FKTbPVHgrtTtgKZ7</a><br/>&lt; HTTP/1.0 200 OK<br/>&lt; Content-Type: application/json<br/>&lt; Content-Length: 35<br/>&lt; Server: Werkzeug/0.14.1 Python/3.6.1<br/>&lt; Date: Fri, 07 Sep 2018 22:55:30 GMT<br/>&lt;<br/>{<br/>  "name": "Spider-Man"<br/>}</span></pre><p id="08e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您与web服务交互时，通过Firebase控制台检查您的云Firestore数据库的内容。您应该会看到<code class="du jp jq jr js b">superheroes</code>集合中的数据随着您的请求而改变。</p><h2 id="7556" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">部署到GAE</h2><p id="9e57" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">使用<code class="du jp jq jr js b">gcloud</code>命令行实用程序将代码部署到GAE。从与您的<code class="du jp jq jr js b">app.yaml</code>文件相同的目录中运行以下命令。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="b6f5" class="jt ju ht js b fi lb lc l ld le">(env) $ gcloud app deploy</span></pre><p id="7363" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署需要几分钟时间。回想一下，GAE必须基于<code class="du jp jq jr js b">requirements.txt</code>文件在云中安装依赖项。完成后，CLI会记录实时应用程序的URL。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="8724" class="jt ju ht js b fi lb lc l ld le">Beginning deployment of service [heroes]...<br/>╔════════════════════════════════════════════════════════════╗<br/>╠═ Uploading 2 files to Google Cloud Storage                ═╣<br/>╚════════════════════════════════════════════════════════════╝</span><span id="a77f" class="jt ju ht js b fi lz lc l ld le">File upload done.<br/>Updating service [heroes]...done.<br/>Setting traffic split for service [heroes]...done.<br/>Deployed service [heroes] to [https://heroes-dot-my-project.appspot.com]</span></pre><p id="c4a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过进行几个HTTP调用来结束工作，以确保一切正常。第一次请求可能会多花一两秒钟，因为GAE·莱希会在第一次请求时加载应用程序。</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="888e" class="jt ju ht js b fi lb lc l ld le">(env) $ curl -v -X POST -d '{"name":"Spider-Man"}' -H "Content-type: application/json" <a class="ae jo" href="https://heroes-dot-fireflicks-io.appspot.com/heroes" rel="noopener ugc nofollow" target="_blank">https://heroes-dot-my-project.appspot.com/heroes</a><br/>&lt; HTTP/2 201<br/>&lt; content-type: application/json<br/>&lt; date: Fri, 07 Sep 2018 23:00:23 GMT<br/>&lt; server: Google Frontend<br/>...<br/>&lt;<br/>{"id":"ZWJcJNCLSw7L2WxOqguQ"}</span></pre><p id="ea2b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以运行以下命令直接在控制台上流式传输应用程序日志:</p><pre class="kt ku kv kw fd kx js ky kz aw la bi"><span id="6d4f" class="jt ju ht js b fi lb lc l ld le">(env) $ gcloud app logs tail -s heroes<br/>Waiting for new log entries...<br/>2018-09-07 23:00:18 heroes[20180907t155731]  "POST /heroes HTTP/1.1" 201<br/>2018-09-07 23:01:41 heroes[20180907t155731]  "GET /heroes/ZWJcJNCLSw7L2WxOqguQ HTTP/1.1" 200<br/>2018-09-07 23:01:53 heroes[20180907t155731]  "DELETE /heroes/ZWJcJNCLSw7L2WxOqguQ HTTP/1.1" 200</span></pre><h2 id="2724" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">结论</h2><p id="812f" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我是谷歌应用引擎的长期用户。实际上，我为我的研究生研究学习了它的架构和操作(<a class="ae jo" href="https://dl.acm.org/citation.cfm?id=2806842" rel="noopener ugc nofollow" target="_blank">例如</a>)。在许多方面，GAE是将PaaS和无服务器带入主流的技术。看到不同的GAE语言运行时是如何随着时间的推移而演变的令人耳目一新。他们放宽了过去的许多限制，从而给了开发者更多的自由。与此同时，GAE作为一个平台，通过更好的工具、监控、日志和模块化，极大地改进了对应用治理的支持。</p><p id="1fa3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GAE的新Python 3.7运行时是构建与Firebase交互的微服务的绝佳平台。我希望你和我一样觉得它强大而令人兴奋。</p></div></div>    
</body>
</html>