<html>
<head>
<title>What a beautiful stream !!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多美的小溪啊！！</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/what-a-beautiful-stream-40319ac3aaff?source=collection_archive---------3-----------------------#2022-07-15">https://medium.com/google-cloud/what-a-beautiful-stream-40319ac3aaff?source=collection_archive---------3-----------------------#2022-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/967a0d8dcc4d41015051a464559124b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHniVUNLSr6ofC38KZn6Kg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">近义词:小河，小溪，小溪</figcaption></figure><p id="9a25" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在是印度的季风季节..大部分地方都下起了倾盆大雨..到处都是绿色..<strong class="iw hj">到处都是溪水</strong>..<strong class="iw hj">湖泊</strong>灌满了..该去野餐了！！</p><p id="925a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让人不禁想知道这些湖泊怎么会这么快被填满..是雨水，还是地下水，还是流入湖中的溪流！</p><p id="c8d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">“另一种类型”的湖泊也是如此..<strong class="iw hj">数据湖</strong>..所有这些都来自于从各种渠道获得的多种数据来源..</p><p id="b1f0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">作为一名数据工程师，我总是发现数据抽取是一个非常棘手的问题。考虑延迟、提取类型(即API)、基于文件的数据源推送、基于审计列等。特别是如果数据源是一个定制的应用程序，那么与应用程序数据库的数据库管理员之间的对话将会围绕提取方法无休无止地进行。<strong class="iw hj">变更数据捕获(CDC) </strong>工具的确是解决这些挑战的救星。虽然CDC技术已经存在了一段时间，但是许多这类产品的设置&amp;操作一直是一项繁琐的工作..</p><p id="1578" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">再也不是了！</strong></p><p id="5890" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谷歌云最近让<a class="ae js" href="https://cloud.google.com/datastream" rel="noopener ugc nofollow" target="_blank">数据流</a> CDC普遍可用！像许多其他数据分析产品一样，它也是无服务器的！最好的部分是数据流同时解决了<strong class="iw hj">提取</strong>和<strong class="iw hj">摄取</strong>。</p><p id="84fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们试着用6个简单的步骤创建一个流。</p><p id="23ab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一步:定义一个流。选择源和目标类型。目前源端支持Oracle和MySQL，目标端支持云存储。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/31886ebe8358c3f91614750421e3b107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCGS2-T99e-AmTMCQJy4vA.png"/></div></div></figure><p id="a072" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们坚信在您所在的地方(您的数据)与您会面！MySQL作为源代码在其他云上也受到支持。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/f025d3cf0b0b9959fc0811d7e8dd6378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4XvCTozYoDdCFw1fOyOOg.png"/></div></div></figure><p id="c3e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">步骤2: </strong>创建一个到MySQL源代码的连接并测试它。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/a97b6f15ac0ae93347dab21aeed244fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSDPCjtbiaBNoaigdaThLA.png"/></div></div></figure><p id="600d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第三步:这里有一件有趣的事情..模式和表(包括未来的)的选择非常容易..简单..尽管这不是数据工程师的日常活动！</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/452834250f9a8ccfcf7252fc41f97656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsog8Iid-NclQ1YL5WmLfg.png"/></div></div></figure><p id="bba8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">步骤4 &amp; 5: </strong>创建一个到目标存储桶/文件夹的连接，增量数据将从该存储桶/文件夹中获取。目前，支持avro和JSON(包括压缩功能)文件格式。这个桶/文件夹位置通常可以是数据湖上的原始区域。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/374a004a6a895d93b9f9a189d64a5ad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6dSg9cRZ7yU6yuqJD8Q8g.png"/></div></div></figure><p id="0fe5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第六步:回顾流程..准备起飞！</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/494faae909622b19236d73f912ea4e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcprPum7isuqSkhjl4_mwA.png"/></div></div></figure><p id="f34f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看巡航高度上的东西。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/d41eec500f1a7ad8c11375dfc15f3cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nu0qg95QwY9AWB0PL_d4hA.jpeg"/></div></div></figure><p id="d15a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该流现在显示“运行”状态。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/22a2fabbc54d6c981188b64f0071e379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwGKYyoxkvSZQI_HyXdoGA.png"/></div></div></figure><p id="c8bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">嘿，我们需要对现有数据进行初始加载！没问题，数据流确实支持带有<strong class="iw hj">启动回填</strong>功能的初始加载。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/1b6145c3bb8d8181e0ea79fafe6bb34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_2qgOcOzGjguNUWXVzogg.png"/></div></div></figure><p id="1636" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们对核心场景——插入、更新和删除——的数据流进行测试。在下面的例子中，我们为插入操作执行一个初始加载..这之后是对其中一个记录的更新..随后通过后端对同一记录进行删除操作。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/8216763ae60776f03dbdb837b955dbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckq0ORrI5CsYd04F170YaA.png"/></div></div></figure><p id="d370" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么我们如何在目的端处理来自MySQL的<strong class="iw hj">增量数据</strong>？数据流按日期和时间在目标桶中创建分区文件夹结构。所有这三个数据库操作都被捕获为三个不同文件夹中的独立JSON文件。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/90c64e5678076c397476d32326b9d54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9CAQHcNVWL3XCoabTLSXw.png"/></div></div></figure><p id="9dc3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">增量数据存放在<strong class="iw hj">多个</strong> <strong class="iw hj">文件夹</strong>中，对于目标加载/处理，是否有更简单的方法来处理这个问题？</p><p id="0c2d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有多种方法可以解决这个问题。我更喜欢这里的大湖。虽然<strong class="iw hj"> BigLake </strong>本身是一个无所不包的平台，但这里我们有一个BigLake表，它覆盖了包含所有增量数据的根文件夹。</p><p id="ef70" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们所看到的，有三行对应于三个不同的数据记录实例。CDC的时间戳、变更类型和其他操作元数据进一步帮助<strong class="iw hj">将</strong>变更<strong class="iw hj">捕获</strong>和<strong class="iw hj">传播到目标表上。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/1e6076ca2257fdef059271c5f6a484eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMKdqc8p0L0zB__S0zn3Vw.png"/></div></div></figure><p id="aece" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">总之，Datastream让CDC的实现变得极其简单、敏捷和直观(T21)。技术的无服务器方面已经封装了ops的整个复杂性。我内心的数据工程师无疑被赋予了权力；-)</p></div></div>    
</body>
</html>