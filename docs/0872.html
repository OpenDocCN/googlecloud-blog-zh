<html>
<head>
<title>Developing a cryptocurrency price monitor using Firebase and Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Firebase和Google云平台开发加密货币价格监测器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/developing-a-cryptocurrency-price-monitor-using-firebase-and-google-cloud-platform-34d5538f73f6?source=collection_archive---------0-----------------------#2019-01-07">https://medium.com/google-cloud/developing-a-cryptocurrency-price-monitor-using-firebase-and-google-cloud-platform-34d5538f73f6?source=collection_archive---------0-----------------------#2019-01-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/93f7d5a35e10045c5da774bf24bc12c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnCDEb-w3Qp7WUt3-on4iw.jpeg"/></div></div></figure><div class=""/><p id="28e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我演示了如何使用<a class="ae jo" href="https://firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase </a>和<a class="ae jo" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>构建一个加密货币价格监控应用。每当市场上比特币或以太坊的价格发生变化时，该应用都会收到通知。用户可以为每种加密货币配置最低和最高价格阈值，我们使用这些设置来确定任何给定的价格变化要通知哪些用户。</p><p id="818c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这款应用的灵感来自Pusher社区发布的一篇文章(点击此处阅读<a class="ae jo" href="https://pusher.com/tutorials/cryptocurrency-kotlin-go-part-1" rel="noopener ugc nofollow" target="_blank">第1部分</a>和<a class="ae jo" href="https://pusher.com/tutorials/cryptocurrency-kotlin-go-part-2" rel="noopener ugc nofollow" target="_blank">第2部分</a>)。他们的加密货币价格提醒应用程序使用<a class="ae jo" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank">推送器</a>来发送通知，这似乎是在引擎盖下使用<a class="ae jo" href="https://firebase.google.com/docs/cloud-messaging/" rel="noopener ugc nofollow" target="_blank"> Firebase云消息(FCM) </a>。此外，他们使用SQLite数据库和在Go中开发的独立后端服务器来实现必要的功能。当我读那篇文章的时候，我不禁想到这个用例也可以作为Firebase和GCP的一个很好的演示。这篇文章和相关的应用程序就是这个想法的结果。</p><p id="7c15" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们开发的应用程序版本不需要部署独立的数据库或后端服务器。我们使用各种平台即服务(PaaS)和无服务器产品实施所有服务器端功能，这些产品在Firebase和GCP生态系统中随时可用。具体来说，我们的示例应用程序展示了以下特性。</p><ul class=""><li id="1fb9" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">在<a class="ae jo" href="https://firebase.google.com/docs/firestore/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Firestore </a>中存储加密货币价格和每用户阈值设置。</li><li id="404b" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用<a class="ae jo" href="https://cloud.google.com/appengine/" rel="noopener ugc nofollow" target="_blank">谷歌应用引擎</a>服务定期检查加密货币的市场价格。</li><li id="9529" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用<a class="ae jo" href="https://cloud.google.com/functions/" rel="noopener ugc nofollow" target="_blank"> Google Cloud函数</a>来确定每次价格变化要通知哪些用户。</li><li id="eb89" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">通过FCM发送推送通知。</li></ul><p id="8c09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在客户端，我们使用<a class="ae jo" href="https://firebase.google.com/docs/android/setup" rel="noopener ugc nofollow" target="_blank"> Firebase Android SDK </a>直接与Firestore和FCM交互。这排除了实现单独的REST API的需要，或者在Android应用程序中编写任何HTTP交互的需要。</p><h2 id="b188" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx bi translated">Firestore</h2><p id="fd9e" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">我们的应用程序使用两个Firestore系列。</p><ul class=""><li id="cb64" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du ld le lf lg b">prices</code>集合用于存储最新的加密货币价格。它只有两个文档——我们希望监控的每种货币一个文档。我们将分别给它们分配id<code class="du ld le lf lg b">btc</code>和<code class="du ld le lf lg b">eth</code>。</li><li id="f427" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du ld le lf lg b">prefs</code>集合是我们存储每个用户设置的地方。每个应用程序实例在这个集合中创建一个文档，使用其唯一的<a class="ae jo" href="https://firebase.google.com/docs/reference/android/com/google/firebase/iid/FirebaseInstanceId" rel="noopener ugc nofollow" target="_blank"> Firebase实例ID </a>作为文档标识符。</li></ul><p id="748f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不需要手动创建这些集合。它们是在我们的应用程序开始运行时自动创建的。但是如果您希望通过添加一些样本数据来测试应用程序，图1显示了您的Firestore数据库应该是什么样子。</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lh"><img src="../Images/512a2e1013077ecf1c27408f315cb2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srt7Mxc_6LLn86dpCA34DA.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">图1:应用程序使用的Firestore集合</figcaption></figure><p id="ece7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为建立Firestore的一部分，我们部署了以下<a class="ae jo" href="https://firebase.google.com/docs/firestore/security/get-started" rel="noopener ugc nofollow" target="_blank">安全规则</a>。这些基本上使得<code class="du ld le lf lg b">prices</code>集合是只读的，而<code class="du ld le lf lg b">prefs</code>集合是可读写的。你碰巧在同一个Firestore数据库中的任何其他收藏将无法被该应用程序访问。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="5d65" class="kd ke ht lg b fi lu lv l lw lx">service cloud.firestore {<br/>  match /databases/{database}/documents {<br/>    match /prices/{currency} {<br/>      allow read;<br/>      allow write: if false;<br/>    }<br/>    match /prefs/{device} {<br/>      allow read, write;<br/>    }<br/>  }<br/>}</span></pre><p id="ced9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在这个演示中没有实现用户认证，但是使用<a class="ae jo" href="https://firebase.google.com/docs/auth/" rel="noopener ugc nofollow" target="_blank"> Firebase Auth </a>来实现是相当简单的。如果您决定探索这个选项，您可以使用Firebase Auth提供的惟一用户id作为<code class="du ld le lf lg b">prefs</code>集合中的文档id。这也将允许您进一步收紧您的安全规则，允许每个用户只写他们指定的文档。</p><p id="63a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另请注意，Firebase安全规则仅适用于客户端应用程序(本例中为Android用户)。在后端，我们使用<a class="ae jo" href="https://firebase.google.com/docs/admin/setup" rel="noopener ugc nofollow" target="_blank">Firebase Admin SDK</a>，它绕过安全规则，以特权用户的身份访问数据库。</p><h2 id="1e86" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx bi translated">Android客户端应用程序</h2><p id="ce28" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">该应用的完整源代码可以在我的<a class="ae jo" href="https://github.com/hiranya911/firecloud/tree/master/crypto-fire-alert/android-app" rel="noopener ugc nofollow" target="_blank"> firecloud GitHub repo </a>中找到。整个事情相当于大约170行Kotlin代码，加上通常的Android资源和清单文件。当应用程序启动时，我们在<code class="du ld le lf lg b">prices</code>集合上启动Firestore <a class="ae jo" href="https://firebase.google.com/docs/firestore/query-data/listen" rel="noopener ugc nofollow" target="_blank">实时监听器</a>。通过这种方式，应用程序总是显示Firestore中存储的最新加密货币价格。清单1展示了来自<code class="du ld le lf lg b">MainActivity</code>的相关代码片段。</p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单1:使用Firestore Android SDK接收实时更新</figcaption></figure><p id="de4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ld le lf lg b">MainActivity</code>布局包含两个文本视图，id分别为<code class="du ld le lf lg b">btc</code>和<code class="du ld le lf lg b">eth</code>。请注意，我们对<code class="du ld le lf lg b">prices</code>集合中的Firestore文档使用相同的id。因此，我们可以使用第16–18行中的技巧将每个Firestore文档映射到UI中的文本视图。</p><p id="6b09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击文本视图启动相应加密货币的设置对话框。用户可以指定最小和最大阈值，并保存设置。这个想法是，每当价格低于最低阈值或超过最高阈值时，应用程序都会通知用户。清单2显示了将设置保存到Firestore的方法。</p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单2:将用户偏好保存到Firestore</figcaption></figure><p id="490b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了阈值，我们还将应用程序实例的注册令牌保存到Firestore(第6行)。稍后当我们想要通过FCM通知设备时，会用到它。我们使用稳定的Firebase实例ID作为文档标识符。在实现用户认证的应用中，我们可以使用这里的唯一用户ID。</p><p id="a2f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">清单3中使用的<code class="du ld le lf lg b">await()</code>方法(第2行和第9行)是我们添加到Android GMS核心的<code class="du ld le lf lg b"><a class="ae jo" href="https://developers.google.com/android/reference/com/google/android/gms/tasks/Task" rel="noopener ugc nofollow" target="_blank">Task</a></code> <a class="ae jo" href="https://developers.google.com/android/reference/com/google/android/gms/tasks/Task" rel="noopener ugc nofollow" target="_blank">类</a>中的扩展方法。这使得在Kotlin协程中使用<code class="du ld le lf lg b">Task</code> API更加容易。清单3展示了<code class="du ld le lf lg b">await()</code>方法的实现。</p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单3:添加到Android任务API的Suspendable扩展方法</figcaption></figure><p id="bdbb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将<a class="ae jo" href="https://firebase.google.com/docs/cloud-messaging/android/client" rel="noopener ugc nofollow" target="_blank"> FCM Android SDK </a>添加到应用程序中，并如清单4所示扩展<code class="du ld le lf lg b">FirebaseMessagingService</code>以接收推送通知。</p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单4:在Android中接收FCM推送通知</figcaption></figure><p id="336b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当应用程序在前台时，该服务处理传入的推送通知。它显示一个带有通知有效负载的简单弹出窗口。当应用程序在后台时，通知将被发送到Android的系统通知托盘。</p><p id="dac7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这几乎是客户端应用程序中所有令人兴奋的部分。现在让我们看看应用程序的后端组件。</p><h2 id="9287" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx bi translated">加密货币价格检查器</h2><p id="a400" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">我们在Go (v1.11)中实现了一个应用引擎服务，以定期检查加密货币的市场价格，并将结果保存到Firestore。我们的实现由以下文件组成:</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="681a" class="kd ke ht lg b fi lu lv l lw lx">cryptocron/<br/>├── cryptocron.go (core functionality of the service)<br/>└── web/<br/>    ├── app.yaml  (App Engine deployment descriptor)<br/>    ├── cron.yaml (App Engine cron configuration)<br/>    └── main.go   (main function that exposes the service over HTTP)</span></pre><p id="ab28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该服务的完整源代码可以在<a class="ae jo" href="https://github.com/hiranya911/firecloud/tree/master/crypto-fire-alert/cryptocron" rel="noopener ugc nofollow" target="_blank"> firecloud repo </a>中找到。您可以运行下面的命令将代码直接导入到您的<code class="du ld le lf lg b">GOPATH</code>中:</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="f28e" class="kd ke ht lg b fi lu lv l lw lx">$ go get github.com/hiranya911/firecloud/crypto-fire-alert/cryptocron</span></pre><p id="fdb7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">价格检查器服务使用<a class="ae jo" href="https://firebase.google.com/go" rel="noopener ugc nofollow" target="_blank"> Firebase Admin SDK for Go </a>访问Firestore。由于我们的代码将部署在App Engine中，我们可以让SDK自动发现Google <a class="ae jo" href="https://cloud.google.com/docs/authentication/production" rel="noopener ugc nofollow" target="_blank">应用默认凭证(ADC) </a>来授权Firestore API调用。这意味着我们可以用清单5所示的最小配置来初始化Admin SDK。</p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单5:为Firestore访问初始化Admin Go SDK</figcaption></figure><p id="02db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们只将一个<code class="du ld le lf lg b">Context</code>传递给了<code class="du ld le lf lg b">firebase.NewApp()</code>函数。SDK能够自动发现访问Firestore所需的授权凭证和任何其他设置(例如GCP项目ID)。我们随后在第19行获得的<code class="du ld le lf lg b">firestore.Client</code>提供了对Android客户端应用程序使用的同一个Firestore数据库的访问。</p><p id="e1f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<a class="ae jo" href="https://min-api.cryptocompare.com/" rel="noopener ugc nofollow" target="_blank"> CryptoCompare REST API </a>获取比特币和以太坊的最新价格。清单6展示了如何将发现的价格保存到Firestore。</p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单6:将加密货币价格从Go保存到Firestore</figcaption></figure><p id="79d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在Firestore上执行批量写操作，在一次操作中更新比特币和以太坊的价格。由于我们的Android应用程序已经<em class="ma">在</em>监听<code class="du ld le lf lg b">prices</code>集合中的更新，这些变化会立即被用户看到。</p><p id="4deb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在URL路径<code class="du ld le lf lg b">/fetch</code>将该服务公开为HTTP端点。接下来，为了让我们的应用程序数据保持最新，我们需要指示Google App Engine定期调用我们的服务。这是通过编写清单7所示的<code class="du ld le lf lg b"><a class="ae jo" href="https://cloud.google.com/appengine/docs/standard/go111/scheduling-jobs-with-cron-yaml" rel="noopener ugc nofollow" target="_blank">cron.yaml</a></code> <a class="ae jo" href="https://cloud.google.com/appengine/docs/standard/go111/scheduling-jobs-with-cron-yaml" rel="noopener ugc nofollow" target="_blank">文件</a>来完成的。</p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单7:应用引擎cron作业配置</figcaption></figure><p id="a469" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要在本地测试这个服务，将<code class="du ld le lf lg b">GOOGLE_APPLICATION_CREDENTIALS</code>环境变量设置为指向从Firebase项目下载的<a class="ae jo" href="https://firebase.google.com/docs/admin/setup#add_firebase_to_your_app" rel="noopener ugc nofollow" target="_blank">服务帐户</a> JSON文件。然后执行服务的<code class="du ld le lf lg b">main.go</code>文件:</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="c985" class="kd ke ht lg b fi lu lv l lw lx">$ export GOOGLE_APPLICATION_CREDENTIALS=path/to/serviceAccount.json<br/>$ go run main.go</span></pre><p id="57dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将启动端口8080上的服务，您可以通过向<code class="du ld le lf lg b">http://localhost:8080/fetch</code>发送请求来尝试一下。结果，您将看到Firebase控制台中的价格集合得到了更新。这些更新还会出现在Android客户端应用程序上，如果它碰巧正在运行的话。注意，在本地测试时，您必须手动调用服务的<code class="du ld le lf lg b">/fetch</code>端点。<code class="du ld le lf lg b">cron.yaml</code>文件只有在部署到云中后才会生效。</p><p id="3075" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在测试该服务时，加密货币价格在现实世界中的变化率可能不足以触发许多更新。如果这成为一个问题，您可以放弃CryptoCompare API，让服务在每次调用时产生随机定价数据。在启动服务之前设置以下环境变量以启用此功能。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="ee81" class="kd ke ht lg b fi lu lv l lw lx">$ export SIMULATE_MODE=1</span></pre><p id="7bdd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要将服务部署到App Engine，请安装并设置<a class="ae jo" href="https://cloud.google.com/sdk/" rel="noopener ugc nofollow" target="_blank"> Google Cloud SDK </a>。确保配置了<code class="du ld le lf lg b">gcloud</code>命令行实用程序来管理您的GCP/Firebase项目。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="f671" class="kd ke ht lg b fi lu lv l lw lx">$ gcloud config set project &lt;your-project-id&gt;</span></pre><p id="dddb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后从与<code class="du ld le lf lg b">app.yaml</code>文件相同的目录中运行以下命令。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="bf5b" class="kd ke ht lg b fi lu lv l lw lx">$ gcloud app deploy<br/>$ gcloud app deploy cron.yaml</span></pre><p id="1749" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个命令部署服务实现。后者启动定期调用服务的计划任务。此后不久，您将在应用引擎日志中看到类似以下内容的条目。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="a869" class="kd ke ht lg b fi lu lv l lw lx">2018-12-26 13:47:19.926 PST GET 200 203 B 688 ms AppEngine-Google; /fetch<br/>2018-12-26 13:47:20.613 PST 2018/12/26 21:47:20 Price of btc = 3820.57 USD<br/>2018-12-26 13:47:20.613 PST 2018/12/26 21:47:20 Price of eth = 130.76 USD</span></pre><p id="f1fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还将我们的服务编程为只接受来自App Engine cron scheduler的请求。试图手动调用云中的HTTP端点将产生一个<code class="du ld le lf lg b">404 Not Found</code>响应。您可以通过从<code class="du ld le lf lg b">app.yaml</code>文件中删除<code class="du ld le lf lg b">CRON_ONLY</code>环境变量来改变这种行为。</p><h2 id="61f0" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx bi translated">通知发送者</h2><p id="930f" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">我们需要完成我们的应用程序的最后一部分是在加密货币价格变化时通知感兴趣的用户的服务。我们已经有了更新Firestore价格的服务。因此，我们可以使用Firebase 的<a class="ae jo" href="https://firebase.google.com/docs/functions/" rel="noopener ugc nofollow" target="_blank">云函数来实现一个无服务器函数，每当有新价格写入Firestore的<code class="du ld le lf lg b">prices</code>集合时，该函数就会发出通知。清单8展示了这个实现的样子。</a></p><figure class="li lj lk ll fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">清单8:使用Firebase的云功能发送目标通知</figcaption></figure><p id="7a53" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们为<code class="du ld le lf lg b">prices</code>集合中的文档定义了一个<code class="du ld le lf lg b">onUpdate</code> Firestore触发器。正在更新的文档的ID(即<code class="du ld le lf lg b">btc</code>或<code class="du ld le lf lg b">eth</code>)及其价格值可以从传递给触发器的参数中获得。我们将这些值传递给<code class="du ld le lf lg b">findTargetDevices()</code> helper方法，该方法查询Firestore中的<code class="du ld le lf lg b">prefs</code>集合，以确定应该通知哪些用户价格发生了变化。</p><p id="0f3a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们希望通知用户其最低阈值高于当前价格，或其最高阈值低于当前价格。由于Firestore不支持析取查询(即<code class="du ld le lf lg b">OR</code>查询)，我们运行两个单独的查询(第33–34行)，并汇总结果。这也是我们引用Android客户端保存在Firestore中的设备注册令牌的地方。最后，我们使用Admin SDK中的FCM API向选定的用户发送推送通知。</p><p id="4e79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，请注意，我们正在用最少的配置初始化Firebase Admin SDK(第4–5行)。SDK自动发现有效的授权凭证，并连接到Android客户端和App Engine服务使用的相同Firestore数据库。</p><p id="4372" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">云功能的完整实现可以在<a class="ae jo" href="https://github.com/hiranya911/firecloud/tree/master/crypto-fire-alert/notification-sender" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。使用<a class="ae jo" href="https://firebase.google.com/docs/functions/local-emulator" rel="noopener ugc nofollow" target="_blank"> Firebase函数模拟器</a>在本地测试代码。从项目的<code class="du ld le lf lg b">functions/</code>目录运行以下命令。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="f184" class="kd ke ht lg b fi lu lv l lw lx">$ export GOOGLE_APPLICATION_CREDENTIALS=path/to/serviceAccount.json<br/>$ npm run shell</span></pre><p id="cecd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将启动Firebase模拟器外壳。现在，您可以使用一些示例数据直接调用该函数，如下所示。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="c2fe" class="kd ke ht lg b fi lu lv l lw lx">firebase &gt; sendCryptoAlerts({before: {}, after: {value: 5000, name: 'BTC'}}, {params: {currency: 'btc'}})</span><span id="08bf" class="kd ke ht lg b fi mb lv l lw lx">'Successfully invoked function.'<br/>info: User function triggered, starting execution<br/>info: Price of btc changed to USD 5000<br/>info: Execution took 2263 ms, user function completed successfully</span></pre><p id="3e54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在验证了我们的功能按预期工作之后，我们可以使用Firebase CLI将其部署到云中。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="ed3c" class="kd ke ht lg b fi lu lv l lw lx">$ firebase deploy --only functions</span></pre><p id="d3ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以等待App Engine服务更新加密货币价格，或者手动在Firestore中输入一些样本价格。也可以使用GCP控制台手动运行App Engine cron作业。无论哪种方式，云功能都将被触发，您将能够在Firebase控制台中看到相应的日志。</p><pre class="li lj lk ll fd lq lg lr ls aw lt bi"><span id="c055" class="kd ke ht lg b fi lu lv l lw lx">1:47:21.821 PM sendCryptoAlerts Function execution took 145 ms, finished with status: 'ok'<br/>1:47:21.740 PM sendCryptoAlerts Notifying 1 devices<br/>1:47:21.679 PM sendCryptoAlerts Price of eth changed to USD 130.76<br/>1:47:21.677 PM sendCryptoAlerts Function execution starte<br/>1:47:21.673 PM sendCryptoAlerts Function execution took 516 ms, finished with status: 'ok'<br/>1:47:21.444 PM sendCryptoAlerts Notifying 1 devices<br/>1:47:21.258 PM sendCryptoAlerts Price of btc changed to USD 3820.57<br/>1:47:21.158 PM sendCryptoAlerts Function execution started</span></pre><p id="9245" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图2是GCP控制台的屏幕截图，在同一个窗口中显示了App Engine和云函数日志。此图中显示的所有条目都是由App Engine服务的一次运行生成的。</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/72b9a53c9c4ba3444ac432784b92f208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSliBzgQXxVUI25aKMi2eQ.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">图2:价格变化产生的应用引擎和云功能日志</figcaption></figure><p id="46b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图3显示了Android客户端应用程序的各种屏幕，包括当应用程序在后台时如何发送通知。</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/b722b65eb8e5ee3c270db57803e7e4e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WocCNTrrQm21TLXD0Qk3tg.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">图3: Android客户端应用程序UI</figcaption></figure><h2 id="febf" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx bi translated">结论</h2><p id="bed9" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">在这篇文章中，我们看了如何使用几个Firebase和GCP产品开发一个加密货币价格监控应用程序。我们使用Firebase Android SDK直接与Google Cloud Firestore和FCM进行交互。我们在Google App Engine中实现了一项服务，定期查看比特币和以太坊的市场价格。最后，我们实现了一个Google Cloud函数，它根据单个用户配置的价格阈值通知用户价格变化。整个练习花了我几个小时，你可以在GitHub上找到完整的实现。</p><p id="5a0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该应用的后端功能在谷歌应用引擎和谷歌云功能之间拆分。但是，也可以单独使用App Engine来实现所有后端功能。我们可以对Go服务进行编程，使其在每次更新加密货币价格时发送推送通知。其实我实现的服务已经支持这个了，只是默认是禁用的。查看代码，看看是否能找出如何在App Engine服务中启用推送通知。</p><p id="2fa5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就我个人而言，我非常倾向于使用不同的服务来检查加密货币的价格，并发送推送通知。这使得关注点的分离更加明确，同时导致更加松散耦合的实现。它还使得每个服务可以独立测试和部署，从而使我们更接近微服务架构。例如，想象一下试图改变我们的应用程序检查加密货币价格的方式。有了两个不同的服务，我们可以简单地更新价格检查服务，而不必接触通知发送者。</p><p id="2ead" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章和相关的演示应用程序对你有用。欢迎提出任何问题或反馈。如果你有任何想让我尝试和实现的演示应用想法，我也很想听听。一如既往，我们也欢迎您通过各种开源Firebase库参与到<a class="ae jo" href="https://firebaseopensource.com/" rel="noopener ugc nofollow" target="_blank"> Firebase社区</a>中来。</p></div></div>    
</body>
</html>