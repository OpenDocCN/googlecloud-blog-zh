<html>
<head>
<title>Day #14 with Cloud Workflows: Subworkflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云工作流的第14天:子工作流</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/day-14-with-cloud-workflows-subworkflows-77fd9780add7?source=collection_archive---------1-----------------------#2021-02-03">https://medium.com/google-cloud/day-14-with-cloud-workflows-subworkflows-77fd9780add7?source=collection_archive---------1-----------------------#2021-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7619" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工作流由一系列步骤和分支组成。有时，一些特定的步骤序列可以重复，在工作流定义中避免容易出错的重复是一个好主意(特别是如果您在一个地方进行了更改，而忘记在另一个地方进行更改)。您可以通过创建子工作流来模块化您的定义，有点像编程语言中的子例程或函数。例如，昨天，我们看了一下<a class="ae jd" href="http://glaforge.appspot.com/article/day-13-with-cloud-workflows-logging-with-cloud-logging" rel="noopener ugc nofollow" target="_blank">如何登录云日志</a>:如果你想在工作流的几个地方登录，你可以在子工作流中提取那个例程。</p><p id="0d0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在下面的视频中看到这一点，之后你可以阅读所有的解释:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="02b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们回过头来看看工作流定义的结构。您直接在主YAML文件中编写一系列步骤。借助，您可以在步骤之间来回移动，但是使用跳转来模拟子例程并不方便(还记得BASIC及其gotos的辉煌过去吗？).相反，云工作流允许你在一个“主”下分离步骤，子例程在它们自己的子例程名称下。</p><p id="bd93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们只有一系列步骤:</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="c9f7" class="jq jr hi jm b fi js jt l ju jv">main:<br/>    steps:<br/>        - stepOne:<br/>            ...<br/>        - stepTwo:<br/>            ...<br/>        - stepThree:<br/>           ...</span></pre><p id="c473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些步骤隐含在主例程中。下面是如何通过主程序块及其下面的步骤来明确显示这个主例程:</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="a044" class="jq jr hi jm b fi js jt l ju jv">subWorkflow:<br/>    params: [param1, param2, param3: "default value"]<br/>    steps:<br/>        - stepOne:<br/>            ...<br/>        - stepTwo:<br/>            ...<br/>        - stepThree:<br/>           ...</span></pre><p id="03b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建子工作流，我们遵循相同的结构，但是使用不同的名称，但是您也可以像这样传递参数:</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="168e" class="jq jr hi jm b fi js jt l ju jv">main:<br/>    steps:<br/>        - greet:<br/>            call: greet<br/>            args:<br/>                greeting: "Hello"<br/>                name: "Guillaume"<br/>            result: concatenation<br/>        - returning:<br/>            return: ${concatenation}</span><span id="4c55" class="jq jr hi jm b fi jw jt l ju jv">greet:<br/>    params: [greeting, name: "World"]<br/>    steps:<br/>        - append:<br/>            return: ${greeting + ", " + name + "!"}</span></pre><p id="646d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，您可以传递几个参数，并且当调用站点没有提供该参数时，参数可以有默认值。</p><p id="5585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在您的主流程中，您可以使用call指令调用该子工作流。让我们来看一个具体的例子，它只是连接了两个字符串:</p><p id="c231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在call指令中，我们传递问候语和名称参数，结果将包含子工作流调用的输出。在子工作流中，我们定义了我们的参数，并且我们有一个单独的步骤，只需返回一个表达式，它就是所需的问候消息连接。</p><p id="9f20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个例子，但可能比连接字符串更有用！让我们把昨天的云日志集成变成一个可重用的子工作流。这样，您将能够在您的主工作流定义中根据需要多次调用日志子工作流，而无需重复您自己:</p><pre class="je jf jg jh fd jl jm jn jo aw jp bi"><span id="7ee5" class="jq jr hi jm b fi js jt l ju jv">main:<br/>  steps:<br/>    - first_log_msg:<br/>        call: logMessage<br/>        args:<br/>          msg: "First message"<br/>    - second_log_msg:<br/>        call: logMessage<br/>        args:<br/>          msg: "Second message"<br/>    <br/>logMessage:<br/>  params: [msg]<br/>  steps:<br/>    - log:<br/>        call: http.post<br/>        args:<br/>            url: <a class="ae jd" href="https://logging.googleapis.com/v2/entries:write" rel="noopener ugc nofollow" target="_blank">https://logging.googleapis.com/v2/entries:write</a><br/>            auth:<br/>                type: OAuth2<br/>            body:<br/>                entries:<br/>                    - logName: ${"projects/" + sys.get_env("GOOGLE_CLOUD_PROJECT_ID") + "/logs/workflow_logger"}<br/>                      resource:<br/>                        type: "audited_resource"<br/>                        labels: {}<br/>                      textPayload: ${msg}</span></pre><p id="8a4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧啊。我们在主工作流中调用了两次logMessage子工作流，只是传递文本消息来登录云日志。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="be6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ke">最初发表于</em><a class="ae jd" href="http://glaforge.appspot.com/article/day-14-with-cloud-workflows-subworkflows" rel="noopener ugc nofollow" target="_blank">T5【http://glaforge.appspot.com】</a><em class="ke">。</em></p></div></div>    
</body>
</html>