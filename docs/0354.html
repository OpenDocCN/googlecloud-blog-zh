<html>
<head>
<title>Kubernetes ConfigMaps and Secrets Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes配置图和秘密第2部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-configmaps-and-secrets-part-2-3dc37111f0dc?source=collection_archive---------0-----------------------#2017-08-08">https://medium.com/google-cloud/kubernetes-configmaps-and-secrets-part-2-3dc37111f0dc?source=collection_archive---------0-----------------------#2017-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是第一部的延续。</p><p id="85fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然环境变量对于小部分信息来说非常有用，但有时您可能有大量数据需要传递给应用程序。一个常见的解决方案是将这些数据分组到一个文件中，并让您的应用程序从该文件中读取。</p><p id="98bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes允许您将配置图和机密作为文件挂载。与环境变量不同，如果这些文件发生变化，新文件将被推送到正在运行的pods中，而不需要重启，因此它们更加强大。您还可以将多个文件映射到一个ConfigMap或Secret，并将它们作为一个目录一次性挂载！</p><h1 id="7be5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">从文件中读取</h1><p id="e519" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">让我们修改<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-configmaps-and-secrets-68d061f7ab5b">第1部分</a>中的代码，从文件而不是环境变量中读取。</p><p id="e282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，创建名为“config”和“secret”的两个子目录，并使用我们在第一部分中使用的数据创建config.json和secret.json文件:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5c35" class="kq jf hi km b fi kr ks l kt ku">mkdir config &amp;&amp; mkdir secret</span><span id="63fe" class="kq jf hi km b fi kv ks l kt ku">echo '{"LANGUAGE":"English"}' &gt; ./config/config.json</span><span id="0612" class="kq jf hi km b fi kv ks l kt ku">echo '{"API_KEY":"123-456-789"}' &gt; ./secret/secret.json</span></pre><p id="2128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，编辑代码，让它读入这些文件，而不是环境变量。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/825b2737873d8d935d2921862af2752f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8w_K5sRCZo9XJGq33QK-w.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><a class="ae jd" href="https://gist.github.com/thesandlord/6e297d7ceb807e6f0243255ab7885d83#file-file-js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/the sand Lord/6e 297d 7 CEB 807 e6f 0243255 ab 7885d 83 # file-file-js</a></figcaption></figure><blockquote class="li lj lk"><p id="a8f6" class="if ig ll ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih hj">重要提示:</strong>这段代码将在每次请求时重新读取文件。如果您在程序启动时读取该文件一次，将不会捕获对该文件的更新，您将需要重新启动容器来更新这些文件。比每次重新读取文件更有效的一种常见模式是使用文件监视器，它只在文件发生变化时才重新加载文件。</p></blockquote><h1 id="bf35" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用Docker卷挂载文件</h1><p id="1c98" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">第一步是通过使用Docker卷模拟配置图和机密来测试一切工作。</p><p id="b75a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重建容器:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4037" class="kq jf hi km b fi kr ks l kt ku">docker build -t envtest .</span></pre><p id="a07c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建容器后，使用以下命令运行它:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ccb4" class="kq jf hi km b fi kr ks l kt ku">docker run -p 3000:3000 -ti \<br/>  -v $(pwd)/secret/:/usr/src/app/secret/ \<br/>  -v $(pwd)/config/:/usr/src/app/config/ \<br/>  envtest</span></pre><p id="1bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将运行Docker容器，并将数据文件夹装入容器。</p><blockquote class="li lj lk"><p id="0238" class="if ig ll ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>用于基本映像的<a class="ae jd" href="https://github.com/nodejs/docker-node/blob/master/6.11/onbuild/Dockerfile#L4" rel="noopener ugc nofollow" target="_blank"> onbuild </a>容器将代码放入/usr/src/app目录。这就是为什么文件夹被安装在那里。</p></blockquote><p id="24ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你访问localhost:3000 <!-- -->容器应该提供流量服务。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lp"><img src="../Images/23f2ffb8c90a6f2fad7afa7ced3d9709.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*qqUtUpXoe9DRiMUtcrf0kw.png"/></div></figure><p id="c5f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为文件被装载到容器中，并且代码在每次请求时都重新读取文件，所以您可以更改文件并看到更改，而无需重新启动任何东西！</p><p id="88d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4988" class="kq jf hi km b fi kr ks l kt ku">echo '{"LANGUAGE":"Spanish"}' &gt; ./config/config.json</span></pre><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es lq"><img src="../Images/6324137e5dba4b28b831b9251a81530f.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*j_sIOIcnmgevdo7zI__XEA.png"/></div></figure><h1 id="ce01" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">创建配置映射和密码</h1><p id="8680" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">从文件中创建秘密</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e2fd" class="kq jf hi km b fi kr ks l kt ku">kubectl create secret generic my-secret \<br/>  --from-file=./secret/secret.json</span></pre><p id="81b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后从另一个文件创建配置映射</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="16c8" class="kq jf hi km b fi kr ks l kt ku">kubectl create configmap my-config --from-file=./config/config.json</span></pre><p id="999f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下命令检查这些文件是否已创建:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d14b" class="kq jf hi km b fi kr ks l kt ku">kubectl get secret</span></pre><figure class="kh ki kj kk fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lr"><img src="../Images/bf00b141cd96024b7c07c7c1cd76692b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njqq9Jd_ZGOqFjavK_xrQ.png"/></div></div></figure><p id="70ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2cb2" class="kq jf hi km b fi kr ks l kt ku">kubectl get configmap</span></pre><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es ls"><img src="../Images/7cee1911f30178720f51098a679b39f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*e0kcgWCdGy8gMqxz5JTAUw.png"/></div></figure><h1 id="8f0c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">将配置映射和机密用作文件</h1><p id="373a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最后一步是使用创建一个部署，该部署将使用配置映射和密码作为一个文件，而不是一个环境变量</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="bc7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>记住您需要更新并推送注册中心中的Docker映像，以使用新代码。如果你使用Google Cloud，你可以使用这个命令。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ec99" class="kq jf hi km b fi kr ks l kt ku">gcloud container builds submit --tag gcr.io/$(gcloud config list project --format=text | awk '{print $2}')/envtest:file .</span></pre></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="0a4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的部署YAML中，您可以将配置图和密码用作卷。这将自动把它们作为一个目录挂载到你的容器中，就像Docker一样。</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/fbb08cf8f0e90f319f550f7f11362bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pSYEK_iysSJ30ugoVXvHQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><a class="ae jd" href="https://gist.github.com/thesandlord/6e297d7ceb807e6f0243255ab7885d83#file-file-yaml" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/the sand Lord/6e 297d 7 CEB 807 e6f 0243255 ab 7885d 83 # file-file-YAML</a></figcaption></figure><p id="2c44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，Secret和ConfigMap被映射到卷，这些卷用于容器规范的volumeMount部分。</p><h1 id="cdcc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">无停机更新！</h1><p id="12fd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-configmaps-and-secrets-68d061f7ab5b"> Part </a> 1的环境变量不同，卷可以动态地重新挂载到正在运行的容器中。这意味着新的ConfigMap和Secret值将可用于容器，而无需重新启动正在运行的进程。</p><p id="96bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，将语言更改为克林贡语并更新配置图。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5bcf" class="kq jf hi km b fi kr ks l kt ku">echo '{"LANGUAGE":"Klingon"}' &gt; ./config/config.json</span><span id="a506" class="kq jf hi km b fi kv ks l kt ku">kubectl create configmap my-config \<br/>  --from-file=./config/config.json \<br/>  -o yaml --dry-run | kubectl replace -f -</span></pre><p id="7068" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在几秒钟内(根据缓存的不同，最多一分钟)，新文件将被自动推送到正在运行的容器中！</p><figure class="kh ki kj kk fd kx er es paragraph-image"><div class="er es ma"><img src="../Images/7e10f93f69c97f24e52f4dd3b22e8756.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/1*wGebNWPZ_I_x0ruXA0ttrQ.gif"/></div></figure><p id="78b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要更新密码，您可以遵循相同的过程:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d0a0" class="kq jf hi km b fi kr ks l kt ku">echo '{"API_KEY":"0987654321"}' &gt; ./secret/secret.json</span><span id="8d3b" class="kq jf hi km b fi kv ks l kt ku">kubectl create secret generic my-secret \<br/>  --from-file=./secret/secret.json \<br/>  -o yaml --dry-run | kubectl replace -f -</span></pre><blockquote class="li lj lk"><p id="872f" class="if ig ll ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>这些更新最终是一致的。有可能一些容器在其他容器之前获得更新，从而在您的部署中造成不一致。如果这是一个问题，请不要使用自动更新功能。相反，创建新的配置映射或密码，并更新或创建新的部署以使用新的配置映射或密码。</p></blockquote></div></div>    
</body>
</html>