<html>
<head>
<title>How to load XML data into BigQuery using Python Dataflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python数据流将XML数据加载到BigQuery中</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-load-xml-data-into-bigquery-using-python-dataflow-fd1580e4af48?source=collection_archive---------1-----------------------#2020-06-29">https://medium.com/google-cloud/how-to-load-xml-data-into-bigquery-using-python-dataflow-fd1580e4af48?source=collection_archive---------1-----------------------#2020-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b5eb" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将XML解析成Python字典，并使用Apache Beam的BigQueryIO</h2></div><p id="0b32" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你的数据在Avro，JSON，Parquet等。将其加载到BigQuery中就像运行联邦查询或使用bq load一样简单。但是如果您的数据是XML格式的呢？</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/e11d31a4e4ca0f261f1abf4aa9280321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*gTPBqrZCUUkn6BcepL3rcw.gif"/></div></figure><p id="e13a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文的代码在GitHub 上的《BigQuery:权威指南》一书中。</p><h2 id="b1c0" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">输入XML文档</h2><p id="561b" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">假设数据存在于一个名为orders.xml的文件中，该文件包含一个订单示例文档(该示例摘自<a class="ae kb" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/sample-xsd-file-customers-and-orders1" rel="noopener ugc nofollow" target="_blank">微软的XSD文档</a>):</p><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="bc9e" class="kc kd hi ld b fi lh li l lj lk">&lt;Root&gt;<br/>&lt;Orders&gt;  <br/>    &lt;Order&gt;  <br/>      &lt;CustomerID&gt;GREAL&lt;/CustomerID&gt;  <br/>      &lt;EmployeeID&gt;6&lt;/EmployeeID&gt;  <br/>      &lt;OrderDate&gt;1997-05-06T00:00:00&lt;/OrderDate&gt;  <br/>      &lt;RequiredDate&gt;1997-05-20T00:00:00&lt;/RequiredDate&gt;  <br/>      &lt;ShipInfo ShippedDate="1997-05-09T00:00:00"&gt;  <br/>        &lt;ShipVia&gt;2&lt;/ShipVia&gt;  <br/>        &lt;Freight&gt;3.35&lt;/Freight&gt;  <br/>        &lt;ShipName&gt;Great Lakes Food Market&lt;/ShipName&gt;  <br/>        &lt;ShipAddress&gt;2732 Baker Blvd.&lt;/ShipAddress&gt;  <br/>        &lt;ShipCity&gt;Eugene&lt;/ShipCity&gt;  <br/>        &lt;ShipRegion&gt;OR&lt;/ShipRegion&gt;  <br/>        &lt;ShipPostalCode&gt;97403&lt;/ShipPostalCode&gt;  <br/>        &lt;ShipCountry&gt;USA&lt;/ShipCountry&gt;  <br/>      &lt;/ShipInfo&gt;  <br/>    &lt;/Order&gt;<br/>    &lt;Order&gt;<br/>    ...<br/>&lt;/Orders&gt;<br/>&lt;/Root&gt;</span></pre><h2 id="7419" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">解析成Python字典</h2><p id="2517" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">为了将它解析到Python字典中，我们将使用一个名为xmltodict的Python包:</p><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="c239" class="kc kd hi ld b fi lh li l lj lk">def parse_into_dict(xmlfile):<br/>    import xmltodict<br/>    with open(xmlfile) as ifp:<br/>        doc = xmltodict.parse(ifp.read())<br/>        return doc</span></pre><p id="1830" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到这一点，我们可以简单地遵从项目来获取值。例如，要获得第一个订单，我们需要:</p><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="b62c" class="kc kd hi ld b fi lh li l lj lk">doc = parse_into_dict('orders.xml')<br/>doc['Root']['Orders']['Order'][0] # first order</span></pre><h2 id="7099" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">指定架构</h2><p id="f722" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">在BigQuery中指定输出表的模式。该表将包含订单信息，因此我们只需表示订单的结构。因为xmltodict创建OrderedDict，所以保持元素在订单的XML表示中出现的准确顺序非常重要:</p><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="fe8a" class="kc kd hi ld b fi lh li l lj lk">table_schema = {<br/>    'fields': [<br/>        {'name' : <strong class="ld hj">'CustomerID'</strong>, 'type': 'STRING', 'mode': 'NULLABLE'},<br/>        {'name' : <strong class="ld hj">'EmployeeID'</strong>, 'type': 'STRING', 'mode': 'NULLABLE'},<br/>        {'name' : 'OrderDate', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>        {'name' : 'RequiredDate', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>        <strong class="ld hj">{'name' : 'ShipInfo', 'type': 'RECORD',</strong> 'mode': 'NULLABLE', 'fields': [<br/>            {'name' : 'ShipVia', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : 'Freight', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : 'ShipName', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : 'ShipAddress', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : 'ShipCity', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : 'ShipRegion', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : 'ShipPostalCode', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : 'ShipCountry', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>            {'name' : '<strong class="ld hj">ShippedDate</strong>', 'type': 'STRING', 'mode': 'NULLABLE'},<br/>        ]},<br/>    ]<br/>}</span></pre><p id="7599" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意一些事情:</p><ul class=""><li id="cc50" class="ll lm hi iz b ja jb jd je jg ln jk lo jo lp js lq lr ls lt bi translated">像CustomerID、EmployeeID等字段。被定义为基本字段。</li><li id="bf30" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">示例文档将EmployeeID存储为<EmployeeID> 3 </EmployeeID>，因此，xmltodict将其视为文本字段。因此，我们必须将其定义为字符串。</li><li id="1364" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">ShipInfo有子元素，所以我们在BigQuery中让它成为一个记录(struct)</li><li id="d55e" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">属性ShippedDate位于所有子元素的最后。xmltodict实际上将这些存储为\@ShippedDate，但是@符号不是合法的BigQuery列名，因此我们必须对其进行清理以删除该符号:</li></ul><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="a1c2" class="kc kd hi ld b fi lh li l lj lk">def cleanup(x):<br/>    import copy<br/>    y = copy.deepcopy(x)<br/>    if '<a class="ae kb" href="http://twitter.com/ShippedDate" rel="noopener ugc nofollow" target="_blank">@ShippedDate</a>' in x['ShipInfo']: # optional attribute<br/>        y['ShipInfo']['ShippedDate'] = x['ShipInfo']['<a class="ae kb" href="http://twitter.com/ShippedDate" rel="noopener ugc nofollow" target="_blank">@ShippedDate</a>']<br/>        del y['ShipInfo']['<a class="ae kb" href="http://twitter.com/ShippedDate" rel="noopener ugc nofollow" target="_blank">@ShippedDate</a>']<br/>    return y</span></pre><p id="aca5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定XML文档，我们可以使用以下方法逐个获取订单:</p><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="7256" class="kc kd hi ld b fi lh li l lj lk">def get_orders(doc):<br/>    for order in doc['Root']['Orders']['Order']:<br/>        yield cleanup(order)</span></pre><h2 id="3ed5" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">波束管道</h2><p id="832a" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">将所有这些放在一起，获取XML文件并使用它来填充BigQuery表的Beam管道是:</p><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="addd" class="kc kd hi ld b fi lh li l lj lk">with beam.Pipeline(argv=pipeline_args) as p:<br/>        orders = (p <br/>             | 'files' &gt;&gt; beam.Create(['orders.xml'])<br/>             | 'parse' &gt;&gt; beam.Map(lambda filename: <strong class="ld hj">parse_into_dict</strong>(filename))<br/>             | 'orders' &gt;&gt; beam.FlatMap(lambda doc: <strong class="ld hj">get_orders</strong>(doc)))<br/>             | 'tobq' &gt;&gt; beam.io.<strong class="ld hj">WriteToBigQuery</strong>(known_args.output,<br/>    <strong class="ld hj">schema=table_schema</strong>,                  <br/>    write_disposition=beam.io.BigQueryDisposition.WRITE_APPEND, <br/>    create_disposition=beam.io.BigQueryDisposition.CREATE_IF_NEEDED)</span></pre><h2 id="2ea1" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">输出BigQuery表</h2><p id="ab7c" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当Beam作业运行时(无论是在本地还是在数据流中)，表被填充，您可以查询它。例如:</p><pre class="ju jv jw jx fd lc ld le lf aw lg bi"><span id="410a" class="kc kd hi ld b fi lh li l lj lk">SELECT * EXCEPT(ShipInfo), ShipInfo.* <br/>FROM advdata.fromxml <br/>WHERE CustomerID = 'LETSS'</span></pre><p id="ba46" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给了我们:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/da0e149ee69a3ee4b6cb04eab7eba726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPylzdJY4awnGjWbLfHhJw.png"/></div></div></figure><h2 id="838e" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">后续步骤</h2><ol class=""><li id="385d" class="ll lm hi iz b ja kx jd ky jg me jk mf jo mg js mh lr ls lt bi translated">在AI平台笔记本中尝试<a class="ae kb" href="https://github.com/GoogleCloudPlatform/bigquery-oreilly-book/blob/master/blogs/xmlload/xmlload.ipynb" rel="noopener ugc nofollow" target="_blank">完整代码(可在GitHub </a>中获得)。</li><li id="ba70" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js mh lr ls lt bi translated">将<em class="mi"> - runner DataflowRunner </em>添加到代码中，以在数据流中运行它</li><li id="3b54" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js mh lr ls lt bi translated">要了解更多关于将数据加载到BigQuery的信息，请阅读《BigQuery:权威指南》的第4章。这本书会定期更新这些博客文章，以保持权威性。</li></ol><p id="b607" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽情享受吧！</p></div></div>    
</body>
</html>