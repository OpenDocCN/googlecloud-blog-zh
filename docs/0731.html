<html>
<head>
<title>Bootstrapping Google Kubernetes Engine after creating it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Google Kubernetes引擎后引导它</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bootstrapping-google-kubernetes-engine-after-creating-it-dca595f830a1?source=collection_archive---------0-----------------------#2018-08-18">https://medium.com/google-cloud/bootstrapping-google-kubernetes-engine-after-creating-it-dca595f830a1?source=collection_archive---------0-----------------------#2018-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3a0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我遇到了一个相当恼人的问题:<strong class="ih hj">在我通过Terraform在Google Cloud上创建了</strong>我的托管<strong class="ih hj"> Kubernetes集群</strong>之后，<strong class="ih hj">我想在同一次运行中为它们提供一些默认设置</strong>。因此，如果我重新部署整个集群，我不想手动运行<code class="du jd je jf jg b">kubectl apply</code>或创建我的名称空间、应用我的RBAC规则等的不同CI管道。</p><p id="606f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这被证明是一个相当令人沮丧的任务，尝试使用<code class="du jd je jf jg b">local-exec</code>、<code class="du jd je jf jg b">Terraform in Terraform</code>提供者、嵌套<code class="du jd je jf jg b">gcloud</code>命令来获取GKE凭证、手工构建定制的<code class="du jd je jf jg b">kubeconfig</code>文件，等等。最后，我找到了一个非常干净漂亮的解决方案，让我与你分享。</p></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/0889c4e38c63e4463dcbcd6020185c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uakPfGXWxauy6JNi"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">当你意识到它其实有多简单的时候！(照片由<a class="ae ke" href="https://unsplash.com/@mehdizadeh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mubariz Mehdizadeh </a>在<a class="ae ke" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</figcaption></figure><p id="2c19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案实际上隐藏在Terraform Google provider网站的一个数据源<a class="ae ke" href="https://www.terraform.io/docs/providers/google/d/datasource_client_config.html" rel="noopener ugc nofollow" target="_blank">示例</a>中。</p><h1 id="e0fa" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用官方K8s提供商</h1><p id="7ea7" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">简而言之:</p><ul class=""><li id="b6f2" class="li lj hi ih b ii ij im in iq lk iu ll iy lm jc ln lo lp lq bi translated">您可以动态地引用您的<code class="du jd je jf jg b">cluster’s IP address and CA certificate</code>(这将很好地处理资源依赖性，例如，首先创建您的集群，然后尝试在其上应用东西)</li><li id="90c2" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">您可以查询您的<code class="du jd je jf jg b">gcloud OAuth token</code>(这似乎是所有其他解决方案中最难发明的一个)</li></ul><pre class="jp jq jr js fd lw jg lx ly aw lz bi"><span id="023b" class="ma kg hi jg b fi mb mc l md me"># Query my Terraform service account from GCP<br/>data "google_client_config" "current" {}</span><span id="cb4d" class="ma kg hi jg b fi mf mc l md me">provider "kubernetes" {<br/>  load_config_file = false</span><span id="c58c" class="ma kg hi jg b fi mf mc l md me">  host = "<a class="ae ke" href="https://${module.cluster_gke1.endpoint" rel="noopener ugc nofollow" target="_blank">https://${module.gke_cluster.endpoint</a>}"<br/>  cluster_ca_certificate = "${base64decode(module.gke_cluster.cluster_ca_certificate)}"</span><span id="df45" class="ma kg hi jg b fi mf mc l md me">  token = "${data.google_client_config.current.access_token}"<br/>}</span></pre><p id="c5c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您就可以调配资源了！</p><pre class="jp jq jr js fd lw jg lx ly aw lz bi"><span id="f3a3" class="ma kg hi jg b fi mb mc l md me">resource "kubernetes_namespace" "test" {<br/>  metadata {<br/>    name = "test"<br/>  }<br/>}</span></pre><h1 id="7a28" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">同一Terraform工作流中的多个集群</h1><p id="91a9" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">那么，如果您创建了多个GKE集群会怎么样呢？<a class="ae ke" href="https://www.terraform.io/docs/configuration/providers.html#multiple-provider-instances" rel="noopener ugc nofollow" target="_blank">提供商化名</a>前来救援！</p><pre class="jp jq jr js fd lw jg lx ly aw lz bi"><span id="d489" class="ma kg hi jg b fi mb mc l md me">provider "kubernetes" {<br/>  <strong class="jg hj">alias = "gke1"</strong></span><span id="18e3" class="ma kg hi jg b fi mf mc l md me">  load_config_file = false</span><span id="0e07" class="ma kg hi jg b fi mf mc l md me">  host = "<a class="ae ke" href="https://${module.cluster_gke1.endpoint" rel="noopener ugc nofollow" target="_blank">https://${module.gke_cluster1.endpoint</a>}"<br/>  cluster_ca_certificate = "${base64decode(module.gke_cluster1.cluster_ca_certificate)}"</span><span id="b01a" class="ma kg hi jg b fi mf mc l md me">  token = "${data.google_client_config.current.access_token}"<br/>}</span></pre><p id="9a88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您调用一个资源时，您只需添加一个额外的<code class="du jd je jf jg b">provider</code>行:</p><pre class="jp jq jr js fd lw jg lx ly aw lz bi"><span id="1d55" class="ma kg hi jg b fi mb mc l md me">resource "kubernetes_namespace" "test" {<br/>  <strong class="jg hj">provider = "kubernetes.gke1"</strong></span><span id="12fd" class="ma kg hi jg b fi mf mc l md me">  metadata {<br/>    name = "test"<br/>  }<br/>}</span></pre></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="7175" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…也许这就是你意识到官方的Kubernetes供应商是多么缺乏维护的地方。</p><p id="bbdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它几乎没有任何你可能想要提供的有用资源。仅举几个例子:角色绑定、集群角色、部署、守护进程、入口…基本上只有<strong class="ih hj">重要的东西没有</strong>！:D</p><h1 id="9ffb" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用社区维护的K8s提供程序</h1><p id="c863" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">很幸运，我撞上了官方插件的一个惊人分叉:<a class="ae ke" href="https://github.com/sl1pm4t/terraform-provider-kubernetes" rel="noopener ugc nofollow" target="_blank">https://github.com/sl1pm4t/terraform-provider-kubernetes</a></p><p id="f065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置是相当棘手的，因为你实际上必须手动包含提供者二进制文件，但是你仍然需要从互联网上下载其他插件。当你使用定制插件时，这工作得相当完美。但是！</p><blockquote class="mg mh mi"><p id="fd46" class="if ig mj ih b ii ij ik il im in io ip mk ir is it ml iv iw ix mm iz ja jb jc hb bi translated">当自定义插件与官方插件同名时……Terraform将总是下载官方插件，而完全忽略您的自定义二进制文件。</p></blockquote><pre class="jp jq jr js fd lw jg lx ly aw lz bi"><span id="51bf" class="ma kg hi jg b fi mb mc l md me">provider "kubernetes" {<br/>  # We use a custom plugin here because the official is very outdated. Please note the -custom suffix, it's important!<br/>  # Download from <a class="ae ke" href="https://github.com/sl1pm4t/terraform-provider-kubernetes/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/sl1pm4t/terraform-provider-kubernetes/releases</a> and <strong class="jg hj">unzip to</strong> the current<br/>  # TF workspace under <strong class="jg hj">terraform.d/plugins/&lt;your architecture&gt;</strong> (darwin_amd64, linux_amd64)<br/>  <strong class="jg hj">version =</strong> "1.2.0<strong class="jg hj">-custom</strong>"</span><span id="48ce" class="ma kg hi jg b fi mf mc l md me"><br/>  load_config_file = false</span><span id="7764" class="ma kg hi jg b fi mf mc l md me">  host = "<a class="ae ke" href="https://${module.cluster_gke1.endpoint" rel="noopener ugc nofollow" target="_blank">https://${module.cluster_gke1.endpoint</a>}"<br/>  cluster_ca_certificate = "${base64decode(module.cluster_gke1.cluster_ca_certificate)}"</span><span id="fdf1" class="ma kg hi jg b fi mf mc l md me">  token = "${data.google_client_config.current.access_token}"<br/>}</span></pre><h2 id="cc7f" class="ma kg hi bd kh mn mo mp kl mq mr ms kp iq mt mu kt iu mv mw kx iy mx my lb mz bi translated">插件自动发现的诀窍</h2><p id="c6e4" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">所以这里的魔法只是</p><ul class=""><li id="6f9a" class="li lj hi ih b ii ij im in iq lk iu ll iy lm jc ln lo lp lq bi translated">下载并解压缩定制的二进制文件</li><li id="18a0" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">让Terraform <strong class="ih hj">自动发现</strong>你的插件</li></ul><p id="8666" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你遵循GitHub文档并在<code class="du jd je jf jg b">terraform init -plugin-dir=&lt;custom plugin folder&gt;</code>之前进行<strong class="ih hj">手动发现</strong>，它<strong class="ih hj">将会破解</strong>所有需要下载官方提供商的东西，例如谷歌云提供商。</p><p id="1700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，你可以做的是:在你当前的Terraform工作目录<em class="mj">中创建一个<code class="du jd je jf jg b">terraform.d/plugins/darwin_amd64/</code>(或<code class="du jd je jf jg b">linux_amd64</code>)文件夹(别忘了把它放进去。gitignore) </em>并在那里解压插件。</p><p id="669b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在初始化Kubernetes提供者将会完全忽略你的文件夹并下载官方的…这是因为他们有相同的名字。即使你把<code class="du jd je jf jg b">version ~&gt; 1.12</code>，因为他们现在都有相同的发布版本，将默认为官方。</p><p id="090e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一点提示:<strong class="ih hj">给你请求的插件版本添加</strong> <code class="du jd je jf jg b"><strong class="ih hj">-custom</strong></code> <strong class="ih hj">后缀。这将确保它回落到你自己的二进制。(相反，缺点是你将来必须手动更新插件。)</strong></p><p id="ff7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Terraform，您可以在Kubernetes中做更多的事情:</p><pre class="jp jq jr js fd lw jg lx ly aw lz bi"><span id="25b8" class="ma kg hi jg b fi mb mc l md me">resource "kubernetes_cluster_role_binding" "admin" {<br/>  # docs: <a class="ae ke" href="https://github.com/sl1pm4t/terraform-provider-kubernetes/pull/39" rel="noopener ugc nofollow" target="_blank">https://github.com/sl1pm4t/terraform-provider-kubernetes/pull/39</a><br/>  metadata {<br/>    name = "tf-admin"<br/>  }</span><span id="26f9" class="ma kg hi jg b fi mf mc l md me">  role_ref {<br/>    name  = "cluster-admin"<br/>    kind  = "ClusterRole"<br/>  }<br/>  subject {<br/>    kind = "User"</span><span id="feb7" class="ma kg hi jg b fi mf mc l md me">    # this is actually my TF service account in GCP<br/>    name = "<a class="ae ke" href="mailto:terraform-lab@edo-tf-resources.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">terraform@&lt;my gcp project&gt;.iam.gserviceaccount.com</a>"<br/>  }<br/>}</span></pre><p id="f368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在撰写本文时，这个提供者的一个缺点是:<em class="mj">实际上没有文档</em>——您要么阅读语法代码，要么浏览GitHub问题/拉请求。都在那里，只需要做一些额外的回合。</p></div><div class="ab cl jh ji gp jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hb hc hd he hf"><p id="24cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你发现这个快速指南至少对我有用！如果您在创建集群的同时发现了其他动态获取Kubernetes凭证的解决方案，请在下面的评论中告诉我。</p></div></div>    
</body>
</html>