<html>
<head>
<title>Coordinating VM Clusters with Google Compute Engine’s Metadata Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协调虚拟机集群与谷歌计算引擎的元数据服务器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/coordinating-vm-clusters-with-google-compute-engines-metadata-server-d13e4a5075d?source=collection_archive---------0-----------------------#2018-02-09">https://medium.com/google-cloud/coordinating-vm-clusters-with-google-compute-engines-metadata-server-d13e4a5075d?source=collection_archive---------0-----------------------#2018-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你是谷歌计算引擎的新手，你可能已经注意到了一个特性，那就是为运行中的图像标记自定义元数据的能力。在编辑单个虚拟机的对话框中，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/cfd23b2eb00a433d0a133c55840f7341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*Y2tTmYYEAZ1C-jcGWqnmsw.png"/></div></figure><p id="3eeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文涵盖了您可以用它做什么以及它为什么有用。我们将研究其背后的原因，然后介绍一个非常有用的协调用例，您可以通过使用该功能来完成，即让多个虚拟机都参与到同一个集群中，以便在启动时相互识别。</p><h1 id="7964" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">元数据服务器的背景</h1><p id="5968" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">计算引擎的文档包括一个关于<a class="ae ko" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata" rel="noopener ugc nofollow" target="_blank">存储和检索实例元数据</a>的章节，您可以看到:</p><blockquote class="kp kq kr"><p id="3520" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">每个实例都将其元数据存储在元数据服务器上。您可以从实例内部和计算引擎API以编程方式查询此元数据服务器，以获取有关实例的信息，如实例的主机名、实例ID、启动和关闭脚本、自定义元数据和服务帐户信息。(…)当您请求从元数据服务器获取信息时，您的请求和后续元数据响应永远不会离开运行虚拟机实例的物理主机。元数据信息在传输到虚拟机主机的过程中也会被加密，因此您可以确保您的元数据信息始终是安全的。</p></blockquote><p id="9559" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的截图中，我将niftySetting设置为5。在VM中，我们可以使用常规curl获取这个值。记住要包括Metadata-Flavor头，这是获取值所必需的，并使服务器以application/text的形式返回结果。</p><pre class="je jf jg jh fd kw kx ky kz aw la bi"><span id="76ec" class="lb jm hi kx b fi lc ld l le lf">$ curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/attributes/niftySetting</span><span id="0f97" class="lb jm hi kx b fi lg ld l le lf">5</span></pre><p id="e315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了能够像这样获取自定义元数据之外，重要的是，您想要了解的关于VM的一系列事情已经提供给您了。例如:</p><ul class=""><li id="31dc" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">您的外部有效IP可通过<a class="ae ko" href="http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip" rel="noopener ugc nofollow" target="_blank">http://metadata . Google . internal/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-IP</a>访问</li><li id="54f4" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">您的内部主机名是<a class="ae ko" href="http://metadata.google.internal/computeMetadata/v1/instance/hostname" rel="noopener ugc nofollow" target="_blank">http://metadata . Google . internal/computeMetadata/v1/instance/hostname</a>(同一网络中的其他虚拟机可以使用此地址，但这不是互联网范围内的有效地址)</li></ul><p id="5302" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了在虚拟机上点击“编辑”并直接添加键/值之外，您还可以像这样使用gcloud工具:</p><pre class="je jf jg jh fd kw kx ky kz aw la bi"><span id="842a" class="lb jm hi kx b fi lc ld l le lf">gcloud compute instances add-metadata my-instance \<br/>  --metadata niftySetting=5</span></pre><p id="3e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为第二种选择，也可以定义项目级元数据，它向下传播到项目中的所有实例，如下所示:</p><pre class="je jf jg jh fd kw kx ky kz aw la bi"><span id="85f6" class="lb jm hi kx b fi lc ld l le lf">gcloud config set-project my-project-id<br/>gcloud compute project-info add-metadata --metadata projectSetting=42</span></pre><p id="3801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果以这种方式完成，所有虚拟机都将看到projectSetting=42。</p><h1 id="e711" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">虚拟机协调</h1><p id="9045" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">这种元数据的一个常见用例是可以从外部传递给启动的虚拟机的配置参数。在容器世界中，更典型的做法是在启动时将环境变量传递给容器。传递环境变量对虚拟机不起作用，但是您可以通过在虚拟机上设置元数据，然后在虚拟机上放置一个简单的bash脚本来完成类似的事情，该脚本在启动时使用curl针对元数据服务器获取这些变量的值，并执行您需要的任何配置。</p><h2 id="b7b9" class="lb jm hi bd jn lv lw lx jr ly lz ma jv iq mb mc jz iu md me kd iy mf mg kh mh bi translated">Neo4j因果聚类示例</h2><p id="e2c8" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在我的例子中，我致力于部署<a class="ae ko" href="https://neo4j.com/docs/operations-manual/current/clustering/causal-clustering/" rel="noopener ugc nofollow" target="_blank"> Neo4j因果集群实例</a>，它们只是3个不同的虚拟机，参与一个高可用性和容错的图形数据库集群。然而，当第一次启动Neo4j集群时，<a class="ae ko" href="https://neo4j.com/docs/operations-manual/current/clustering/causal-clustering/lifecycle/" rel="noopener ugc nofollow" target="_blank">发现协议需要被告知</a>彼此，以便它们可以在网络上发现彼此并形成集群。通常，您可以通过配置特定的地址或DNS名称来实现这一点。Neo4j要求将此作为一个恰当命名的设置<strong class="ih hj">causal _ clustering . initial _ discovery _ members</strong>的一部分。</p><p id="9688" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在部署新虚拟机的情况下，很难知道地址应该是什么，因为在虚拟机启动之前不会分配地址。</p><h2 id="6065" class="lb jm hi bd jn lv lw lx jr ly lz ma jv iq mb mc jz iu md me kd iy mf mg kh mh bi translated">通过内部DNS进行协调</h2><p id="47aa" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">为了部署集群，我们使用了一个<a class="ae ko" href="https://cloud.google.com/deployment-manager/docs/" rel="noopener ugc nofollow" target="_blank">部署管理器模板</a>，它允许我们为每个虚拟机指定元数据。因为我们正在部署3个实例，所以我们将知道模板中的实例名称。实例名称依次映射到google compute内部的本地DNS名称，如下所示:</p><pre class="je jf jg jh fd kw kx ky kz aw la bi"><span id="094d" class="lb jm hi kx b fi lc ld l le lf">$ ping -c 1 node1</span><span id="27be" class="lb jm hi kx b fi lg ld l le lf">PING node1.c.my-gcp-project.internal (10.142.0.2) 56(84) bytes of data.</span><span id="59c3" class="lb jm hi kx b fi lg ld l le lf">64 bytes from node1.c.my-gcp-project.internal (10.142.0.2): icmp_seq=1 ttl=64 time=0.019 ms</span></pre><p id="e84d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对这部分是如何工作的或者为什么工作感到好奇，请看<a class="ae ko" href="https://cloud.google.com/compute/docs/internal-dns" rel="noopener ugc nofollow" target="_blank">内部DNS文档</a>。</p><h2 id="0324" class="lb jm hi bd jn lv lw lx jr ly lz ma jv iq mb mc jz iu md me kd iy mf mg kh mh bi translated">部署管理器模板元数据</h2><p id="343a" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">然后，在部署管理器模板中，为每个虚拟机设置一个变量，在jinja模板中，如下所示:</p><pre class="je jf jg jh fd kw kx ky kz aw la bi"><span id="85e0" class="lb jm hi kx b fi lc ld l le lf">metadata:<br/>    items:<br/>        - key: causal_clustering_initial_discovery_members<br/>          value: {{instanceName}}-1:5000,{{instanceName}}-2:5000,{{instanceName}}-3:5000</span></pre><p id="785d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚拟机本身是使用google提供的<a class="ae ko" href="https://github.com/GoogleCloudPlatform/deploymentmanager-samples/blob/master/templates/vm_multiple_instances.py" rel="noopener ugc nofollow" target="_blank">VM _ multiple _ instances . py</a>模块作为示例在jinja模板中创建的。</p><p id="23c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在每个虚拟机上，一个shell脚本从元数据服务器中选取该变量，并将其插入标准的<a class="ae ko" href="https://neo4j.com/docs/operations-manual/current/configuration/" rel="noopener ugc nofollow" target="_blank"> Neo4j配置文件</a>，确保集群成员即使事先不知道其IP或主机名也能正常通信。这种知识是由部署管理器模板在部署时提供的。</p><p id="8d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也可以通过项目级别的设置来完成，但是请注意，如果我们可能在一个项目中部署多组相互链接的资源，您将更喜欢通过VM级别的设置来完成，以免混淆多个资源集。</p><h1 id="6a67" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">何时不使用实例元数据</h1><p id="10ab" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">最好的用例可能是动态配置(正如我们在上面提到的)，也可能是虚拟机静态描述之类的用例(例如，该虚拟机运行Neo4j Enterprise的3.3.2版本)</p><p id="bd06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于各种原因，使用元数据作为虚拟机之间的通信渠道并不是一个好主意。例如，多个虚拟机设置项目元数据并查询它。这种方法将是高复杂性、高延迟的，并且基本上归结为使用一组全局变量来协调状态，这是软件中众所周知的问题来源。</p><p id="8ddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元数据服务器有一个“<a class="ae ko" href="https://cloud.google.com/compute/docs/storing-retrieving-metadata#waitforchange" rel="noopener ugc nofollow" target="_blank">等待更新</a>”功能，允许在值发生变化时通知虚拟机，但这很容易被滥用。当然，这取决于您的用例，但是如果您发现自己非常需要这种功能，那么您可能更适合使用更好的解决方案，比如消息队列或其他类似的组件，最好避免将它们用作发布/订阅通道。</p></div></div>    
</body>
</html>