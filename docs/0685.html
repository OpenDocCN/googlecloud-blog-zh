<html>
<head>
<title>Kubernetes: Routing Internal Services Through FQDN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:通过FQDN路由内部服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-routing-internal-services-through-fqdn-d98db92b79d3?source=collection_archive---------1-----------------------#2018-07-10">https://medium.com/google-cloud/kubernetes-routing-internal-services-through-fqdn-d98db92b79d3?source=collection_archive---------1-----------------------#2018-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2f0b5b1f990cea739047b5c6f483a20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pAPC21GmxdfmGlUU"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@jasonrosewell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰森·罗斯韦尔</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5653" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我记得当我第一次进入Kubernetes时。一切都是崭新的、闪亮的、有规模的。当我继续开发在Kubernetes上运行的云原生应用程序时，我发现有一小段文字说Kubernetes有一个内置的DNS服务器。</p><p id="ff6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然了，这很有道理。</p><p id="f744" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是现在有了内置的DNS服务器，这就带来了很多机会。在我们的集群内以新的复杂方式路由和屏蔽路由。</p><p id="f9db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将了解如何在集群内定制路由，以简化集群间的通信。</p><p id="38a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">如果你还没有通读或者甚至没有阅读过本系列</em>  <em class="jt">的第一部分，你可能会感到困惑，对代码在哪里或者之前做了什么有疑问。记住这里假设你正在使用</em><a class="ae iu" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a><em class="jt">和</em><a class="ae iu" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a><em class="jt">。我将始终提供代码和如何测试代码是按预期工作。</em></p><div class="ju jv ez fb jw jx"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-day-one-30a80b5dcb29"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hj fi z dy kc ea eb kd ed ef hh bi translated">Kubernetes:第一天</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">medium.com</p></div></div><div class="kg l"><div class="kh l ki kj kk kg kl io jx"/></div></div></a></div><h1 id="3b00" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">通过FQDN路由内部服务看起来像什么？</h1><p id="399a" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">当调用外部服务时，您可能习惯于编写完全限定的域名(FQDN)，如下所示。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="0922" class="ly kn hi lu b fi lz ma l mb mc"><strong class="lu hj">// FQDN = some.url.com<br/>// port = 80<br/>// endpoint =  /service</strong><br/><br/>http.get(<strong class="lu hj">'some.url.com/service'</strong>, (response) =&gt; {<br/>   //simplified<br/>   res.status(200).json(response);<br/>});</span></pre><p id="d289" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，当您在集群中发出请求时，您希望它如何工作？pod是短暂的，因此URL会随着pod的创建和销毁而频繁更改。不是解决方案。</p><p id="ed24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用由服务公开的负载平衡器提供的外部URL。但是那样的话，你就多做了一次跳跃，浪费了时间和处理。</p><p id="6624" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们想要与我们的其他服务进行通信而不进行不必要的跳跃，那么您只需要使用Kubernetes内置的内部通信方案。查看部分服务yaml文件，我们可以提取FQDN的值。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="1617" class="ly kn hi lu b fi lz ma l mb mc">apiVersion: v1<br/>kind: Service # a way for the outside world to reach the Pods<br/>metadata:<br/>  # any Pods with matching labels are included in this Service<br/>  name: <strong class="lu hj">service-1 # service name</strong><br/>spec:<br/>  # Service ports<br/>  ports:</span></pre><p id="2bf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于此服务，根据服务名称，FQDN将是:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="b118" class="ly kn hi lu b fi lz ma l mb mc"><strong class="lu hj">service-1</strong>.default.svc.cluster.local</span></pre><p id="696f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其他部分呢？</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="3adc" class="ly kn hi lu b fi lz ma l mb mc">service-1.<strong class="lu hj">default</strong>.svc.cluster.local</span></pre><p id="4aa4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们针对的pod的名称空间。因为我没有设置名称空间，所以名称空间是<code class="du md me mf lu b">default</code>。</p><p id="3983" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您也可以通过移除<code class="du md me mf lu b">svc.cluster.local</code>来缩短FQDN。留给你:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="6d17" class="ly kn hi lu b fi lz ma l mb mc">service-1.default</span></pre><h1 id="5081" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为什么在您的应用中使用FQDN路由？</h1><p id="51c5" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">正如您将从下面提供的示例中看到的，将参数化路由插入到您的应用程序中非常简单。这对于Kubernetes非常有用，因为您可能希望根据环境或其他规则进行稍微不同的路由。</p><h1 id="d886" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">运行FQDN国内航线</h1><p id="5588" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">我创建了一个示例项目来突出这个特性。对于这个例子，我使用了<a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series/blob/6c00cc949d56604ff557ba3c73ce98125143a962/communication/k8s/deployment_1.yaml#L52-L65" rel="noopener ugc nofollow" target="_blank"> pod环境变量和一个应用程序来将必要的变量注入到应用程序</a>中，这样我们就可以看到一个服务如何调用另一个服务。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="6ee5" class="ly kn hi lu b fi lz ma l mb mc">- name: <strong class="lu hj">FOREIGN_SERVICE</strong><br/>  value: <strong class="lu hj">service-2.default.svc.cluster.local</strong><br/>- name: <strong class="lu hj">FOREIGN_PATH</strong><br/>  value: <strong class="lu hj">/service-2</strong></span></pre><p id="ba46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series/blob/master/communication/routes.js#L48-L61" rel="noopener ugc nofollow" target="_blank">应用程序代码中，值被注入以定制代码</a>。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="7817" class="ly kn hi lu b fi lz ma l mb mc">router.get('<strong class="lu hj">/foreign</strong>', function (req, res, next) {<br/>    const url = <strong class="lu hj">config.get('FOREIGN_SERVICE') +    config.get('FOREIGN_PATH')</strong>;<br/>    http.get(url, response =&gt; {<br/>        let data = '';<br/>        response.on('data', chunk =&gt; {<br/>            data += chunk;<br/>        });<br/>        response.on('end', () =&gt; {<br/>            res.status(200).json(JSON.parse(data));<br/>        });<br/>    }).on('error', err =&gt; {<br/>        throw err;<br/>    });<br/>});</span></pre><p id="8859" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这段代码中，我使用<code class="du md me mf lu b">service-1</code>通过<code class="du md me mf lu b">/foreign</code>端点调用<code class="du md me mf lu b">service-2</code>。我还设置了反向，以便<code class="du md me mf lu b">service-2</code>可以呼叫<code class="du md me mf lu b">service-1</code>。您可以通过在Cloud Shell中运行以下命令来运行代码。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="dd0c" class="ly kn hi lu b fi lz ma l mb mc">$ git clone <a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series.git" rel="noopener ugc nofollow" target="_blank">https://github.com/jonbcampos/kubernetes-series.git</a><br/>$ cd ~/kubernetes-series/communication/scripts<br/>$ sh <a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series/blob/master/communication/scripts/startup.sh" rel="noopener ugc nofollow" target="_blank">startup.sh</a><br/>$ sh <a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series/blob/master/communication/scripts/deploy.sh" rel="noopener ugc nofollow" target="_blank">deploy.sh</a><br/>$ sh <a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series/blob/master/communication/scripts/check-endpoint.sh" rel="noopener ugc nofollow" target="_blank">check-endpoint.sh</a> service-1</span></pre><p id="db9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将为准备就绪的<code class="du md me mf lu b">service-1</code>产生一个IP地址。如果点击<code class="du md me mf lu b">/foreign</code>终点，您将看到以下结果。</p><p id="d1a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du md me mf lu b">http://[service-1 IP Address]/foreign</code></p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/275518fd507cf5608333a04a33e2a0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4XAGgRZEu-kD18driCVVw.png"/></div></div></figure><p id="3203" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您将看到<code class="du md me mf lu b">service-1</code>直接调用<code class="du md me mf lu b">service-2</code>就像访问任何其他端点一样简单。这种奇妙的魔法让构建微服务变得更加容易。</p><h1 id="2ffd" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">拆卸</h1><p id="3a77" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">在您离开之前，请确保清理您的项目，这样您就不会为您用来运行群集的虚拟机付费。返回到云Shell并运行teardown脚本来清理您的项目。这将删除您的集群和我们构建的容器。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="8f29" class="ly kn hi lu b fi lz ma l mb mc">$ cd ~<a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series/tree/master/communication/scripts" rel="noopener ugc nofollow" target="_blank">/kubernetes-series/communication/scripts</a> # if necessary<br/>$ sh <a class="ae iu" href="https://github.com/jonbcampos/kubernetes-series/blob/master/communication/scripts/teardown.sh" rel="noopener ugc nofollow" target="_blank">teardown.sh</a></span></pre></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="c71a" class="km kn hi bd ko kp mo kr ks kt mp kv kw kx mq kz la lb mr ld le lf ms lh li lj bi translated">本系列的其他文章</h1><div class="ju jv ez fb jw jx"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-cluster-autoscaler-f1948a0f686d"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hj fi z dy kc ea eb kd ed ef hh bi translated">Kubernetes:集群自动缩放</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">自动缩放是Kubernetes的一个巨大的(并且已经上市的)特性。当你的网站/应用程序/应用程序接口/项目变得越来越大时，洪水…</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">medium.com</p></div></div><div class="kg l"><div class="mt l ki kj kk kg kl io jx"/></div></div></a></div><div class="ju jv ez fb jw jx"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-horizontal-pod-scaling-190e95c258f5"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hj fi z dy kc ea eb kd ed ef hh bi translated">Kubernetes:水平Pod缩放</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">通过Pod自动扩展，您的Kubernetes集群可以监控现有Pod的负载，并确定我们是否需要更多…</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">medium.com</p></div></div><div class="kg l"><div class="mu l ki kj kk kg kl io jx"/></div></div></a></div><div class="ju jv ez fb jw jx"><a href="https://itnext.io/kubernetes-readiness-probe-83f8a06d33d3" rel="noopener  ugc nofollow" target="_blank"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hj fi z dy kc ea eb kd ed ef hh bi translated">Kubernetes:就绪探测</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">如果对这个特性有任何疑问，我写这篇文章是为了说明这不是一个…</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">itnext.io</p></div></div><div class="kg l"><div class="mv l ki kj kk kg kl io jx"/></div></div></a></div><div class="ju jv ez fb jw jx"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-liveness-checks-4e73c631661f"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hj fi z dy kc ea eb kd ed ef hh bi translated">Kubernetes:活性检查</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">最近，我整理了一篇关于Kubernetes就绪性调查以及它对您的集群有多重要的文章…</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">medium.com</p></div></div><div class="kg l"><div class="mw l ki kj kk kg kl io jx"/></div></div></a></div></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="a615" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Jonathan Campos 是一个狂热的开发者，也是学习新事物的爱好者。我相信我们应该不断学习、成长和失败。我总是开发社区的支持者，并且总是愿意提供帮助。因此，如果你对这个故事有任何问题或意见，请在下面提出。在<a class="ae iu" href="https://www.linkedin.com/in/jonbcampos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae iu" href="https://twitter.com/jonbcampos" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，并提及这个故事。</p></div></div>    
</body>
</html>