<html>
<head>
<title>Event-Driven Image Processing Pipeline with Knative Eventing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Knative事件的事件驱动图像处理流水线</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/event-driven-image-processing-pipeline-with-knative-eventing-2b12254f37bb?source=collection_archive---------1-----------------------#2020-06-05">https://medium.com/google-cloud/event-driven-image-processing-pipeline-with-knative-eventing-2b12254f37bb?source=collection_archive---------1-----------------------#2020-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="aab1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我想谈谈我最近使用<a class="ae jd" href="https://knative.dev/docs/eventing/" rel="noopener ugc nofollow" target="_blank"> Knative Eventing </a>构建的一个事件驱动的图像处理管道。在这个过程中，我将告诉您Knative提供的事件源、自定义事件和其他组件，它们简化了事件驱动架构的开发。</p><h1 id="2795" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">要求</h1><p id="4ed0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">让我们首先谈谈我对图像处理管道的基本要求:</p><ol class=""><li id="6865" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">用户将文件上传到输入桶，并在输出桶中获得处理过的图像。</li><li id="c444" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">上传的图像在通过管道发送之前经过过滤(例如，没有成人或暴力图像)。</li><li id="8050" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">管道可以包含任意数量的处理服务，可以根据需要添加或删除这些服务。对于最初的管道，我决定用3个服务:resizer、watermarker和labeler。resizer将调整大图像的大小。watermarker将为调整大小的图像添加水印，贴标机将提取有关图像(标签)的信息并保存。</li></ol><p id="4846" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要求#3尤其重要。我希望能够在需要时将服务添加到管道中，或者创建多个管道，将不同的服务链接在一起。</p><h1 id="e9e9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Knative Eventing善良</h1><p id="dd6f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Knative Eventing提供了许多有助于构建(如管道)的组件，即:</p><ol class=""><li id="4768" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><a class="ae jd" href="https://knative.dev/docs/eventing/sources/" rel="noopener ugc nofollow" target="_blank">事件源</a>允许您读取集群中的外部事件，而<a class="ae jd" href="https://github.com/google/knative-gcp#knative-gcp-sources" rel="noopener ugc nofollow" target="_blank"> Knative-GCP源</a>提供了许多事件源，可以随时从各种谷歌云资源中读取事件。</li><li id="0684" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><a class="ae jd" href="https://knative.dev/docs/eventing/broker/" rel="noopener ugc nofollow" target="_blank"> Broker和Trigger </a>提供了一个事件中枢，在这里正确的事件被交付给正确的事件消费者，而生产者或消费者不必知道事件是如何被路由的。</li><li id="71bc" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated"><em class="kv">自定义事件和事件回复</em>:在Knative中，所有事件都是<a class="ae jd" href="https://cloudevents.io/" rel="noopener ugc nofollow" target="_blank"> CloudEvents </a>。有一个标准的事件格式和各种SDK来读/写它们是很有用的。此外，Knative支持自定义事件和事件回复。任何服务都可以接收一个事件，进行一些处理，用新数据创建一个定制事件，并回复给<code class="du kw kx ky kz b">Broker</code>以供其他服务读取定制事件。这在管道中非常有用，在管道中每个服务做一点工作并向前传递消息。</li></ol><h1 id="a0dd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">体系结构</h1><p id="e75d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这是图像处理流水线的架构。它被部署到谷歌云上的谷歌Kubernetes引擎(GKE ):</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es la"><img src="../Images/2a3c7d34b0763e9fbe49141d74f0fe29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yWku-PRLLyKs_aZ_.png"/></div></div></figure><ol class=""><li id="7213" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">图像被保存到输入云存储桶。</li><li id="fe7f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">云存储更新事件由<a class="ae jd" href="https://github.com/google/knative-gcp/blob/master/docs/examples/cloudstoragesource/README.md" rel="noopener ugc nofollow" target="_blank"> CloudStorageSource </a>读入Knative。</li><li id="550f" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">过滤服务接收云存储事件。它使用Vision API来确定图像是否安全。如果是这样，它创建一个类型为<code class="du kw kx ky kz b">dev.knative.samples.fileuploaded</code>的自定义<code class="du kw kx ky kz b">CloudEvent</code>并将其向前传递。</li><li id="5d07" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">Resizer服务接收<code class="du kw kx ky kz b">fileuploaded</code>事件，使用<a class="ae jd" href="https://github.com/SixLabors/ImageSharp" rel="noopener ugc nofollow" target="_blank"> ImageSharp </a>库调整图像大小，将调整后的图像保存到输出桶，创建一个<code class="du kw kx ky kz b">dev.knative.samples.fileresized</code>类型的自定义<code class="du kw kx ky kz b">CloudEvent</code>，并将事件向前传递。</li><li id="c31e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">水印服务接收<code class="du kw kx ky kz b">fileresized</code>事件，使用<a class="ae jd" href="https://github.com/SixLabors/ImageSharp" rel="noopener ugc nofollow" target="_blank"> ImageSharp </a>库为图像添加水印，并将图像保存到输出桶。</li><li id="4231" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">贴标机接收<code class="du kw kx ky kz b">fileuploaded</code>事件，用Vision API提取图像的标签，并将标签保存到输出桶。</li></ol><h1 id="f28c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">建造管道</h1><p id="bb45" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在我的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/" rel="noopener ugc nofollow" target="_blank">技能教程</a>中，我有关于如何构建管道的<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/image-processing-pipeline.md" rel="noopener ugc nofollow" target="_blank">指令</a>以及<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/tree/master/eventing/processing-pipelines/image" rel="noopener ugc nofollow" target="_blank">代码和配置</a>。让我强调一下主要部分。</p><h1 id="d91e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">读取云存储事件</h1><p id="5363" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">要读取Google云存储事件，您需要创建一个<code class="du kw kx ky kz b">CloudStorageSource</code>并指向您想要从中监听事件的存储桶:</p><pre class="lb lc ld le fd lm kz ln lo aw lp bi"><span id="c049" class="lq jf hi kz b fi lr ls l lt lu">apiVersion: events.cloud.google.com/v1alpha1<br/>kind: CloudStorageSource<br/>metadata:<br/>  name: storagesource-images-input<br/>spec:<br/>  bucket: knative-atamel-images-input<br/>  sink:<br/>    ref:<br/>      apiVersion: eventing.knative.dev/v1beta1<br/>      kind: Broker<br/>      name: default</span></pre><p id="c872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦事件被读入，它们就被输入到默认名称空间中的<code class="du kw kx ky kz b">Broker</code>中。</p><h1 id="e983" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">过滤服务</h1><p id="4379" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">过滤服务将获取所有存储事件，并决定哪些图像可以安全传递。</p><p id="6ad6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，您需要创建一个<code class="du kw kx ky kz b">Trigger</code>来监听<code class="du kw kx ky kz b">com.google.cloud.storage.object.finalize</code>事件:</p><pre class="lb lc ld le fd lm kz ln lo aw lp bi"><span id="494d" class="lq jf hi kz b fi lr ls l lt lu">apiVersion: eventing.knative.dev/v1beta1<br/>kind: Trigger<br/>metadata:<br/>  name: trigger-filter<br/>spec:<br/>  filter:<br/>    attributes:<br/>      type: com.google.cloud.storage.object.finalize<br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1<br/>      kind: Service<br/>      name: filter</span></pre><p id="6501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，创建Knative服务来处理这些事件:</p><pre class="lb lc ld le fd lm kz ln lo aw lp bi"><span id="ed76" class="lq jf hi kz b fi lr ls l lt lu">apiVersion: serving.knative.dev/v1<br/>kind: Service<br/>metadata:<br/>  name: filter<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - image: docker.io/meteatamel/filter:v1<br/>          env:<br/>            - name: BUCKET<br/>              value: "knative-atamel-images-input"</span></pre><p id="5a28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码在<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/tree/master/eventing/processing-pipelines/image/filter" rel="noopener ugc nofollow" target="_blank">过滤器</a>中，但是服务基本上使用视觉API来检测图像的安全性，如下所示:</p><p id="3910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦过滤器服务确定图片是安全的，它就发出一个类型为<code class="du kw kx ky kz b">dev.knative.samples.fileuploaded</code>的自定义CloudEvent，CloudEvent的数据字段只是桶和文件名:</p><h1 id="049d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">调整大小服务</h1><p id="40ff" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">代码在这里为<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/eventing/processing-pipelines/image/resizer" rel="noopener ugc nofollow" target="_blank"> resizer </a>。</p><p id="6e58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它只响应其触发器中定义的<code class="du kw kx ky kz b">dev.knative.samples.fileuploaded</code>事件:</p><pre class="lb lc ld le fd lm kz ln lo aw lp bi"><span id="11e9" class="lq jf hi kz b fi lr ls l lt lu">apiVersion: eventing.knative.dev/v1beta1<br/>kind: Trigger<br/>metadata:<br/>  name: trigger-resizer<br/>spec:<br/>  filter:<br/>    attributes:<br/>      type: dev.knative.samples.fileuploaded<br/>  subscriber:<br/>    ref:<br/>      apiVersion: serving.knative.dev/v1<br/>      kind: Service<br/>      name: resizer</span></pre><p id="ddd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它使用<code class="du kw kx ky kz b">ImageSharp</code>读取图像并调整其大小，并发出另一个定制事件<code class="du kw kx ky kz b">dev.knative.samples.fileresized</code>供下一个服务水印拾取。</p><h1 id="db51" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">水印服务</h1><p id="5093" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">您可以在<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/tree/master/eventing/processing-pipelines/image/watermarker" rel="noopener ugc nofollow" target="_blank"> watermarker </a>文件夹中查看Watermarker服务的详细信息，但简单来说，它从resizer接收事件，读取调整大小的图像，并在将图像保存到桶之前为图像添加一个<code class="du kw kx ky kz b">Google Cloud Platform</code>水印。</p><h1 id="f45a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">贴标机服务</h1><p id="8c4c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Labeler接收的事件与resizer接收的事件相同。相反，它使用Vision API从图像中提取标签，如下所示:</p><pre class="lb lc ld le fd lm kz ln lo aw lp bi"><span id="5df8" class="lq jf hi kz b fi lr ls l lt lu">private async Task&lt;string&gt; ExtractLabelsAsync(string storageUrl)<br/>{<br/>    var visionClient = ImageAnnotatorClient.Create();<br/>    var labels = await visionClient.DetectLabelsAsync(Image.FromUri(storageUrl), maxResults: 10);</span><span id="b41c" class="lq jf hi kz b fi lv ls l lt lu">var orderedLabels = labels<br/>        .OrderByDescending(x =&gt; x.Score)<br/>        .TakeWhile((x, i) =&gt; i &lt;= 2 || x.Score &gt; 0.50)<br/>        .Select(x =&gt; x.Description)<br/>        .ToList();</span><span id="d660" class="lq jf hi kz b fi lv ls l lt lu">return string.Join(",", orderedLabels.ToArray());<br/>}</span></pre><p id="df1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，它将这些标签保存到输出桶中的一个文本文件中。</p><h1 id="03d5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">测试管道</h1><p id="2bf6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果一切设置正确，您可以看到触发器处于<code class="du kw kx ky kz b">READY</code>状态:</p><pre class="lb lc ld le fd lm kz ln lo aw lp bi"><span id="79c5" class="lq jf hi kz b fi lr ls l lt lu">kubectl get trigger NAME READY REASON BROKER SUBSCRIBER_URI trigger-filter True default http://filter.default.svc.cluster.local trigger-labeler True default http://labeler.default.svc.cluster.local trigger-resizer True default http://resizer.default.svc.cluster.local trigger-watermarker True default <a class="ae jd" href="http://watermarker.default.svc.cluster.local" rel="noopener ugc nofollow" target="_blank">http://watermarker.default.svc.cluster.local</a></span></pre><p id="575a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我把下面这张来自我最喜欢的海滩(里约热内卢的伊帕内马)的照片上传到了水桶里:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es la"><img src="../Images/4b990e668941f3f57a828e2ea531fa40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YYszn6TqkhBO0Pmt.jpg"/></div></div></figure><p id="df75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几秒钟后，我在输出桶中看到3个文件:</p><pre class="lb lc ld le fd lm kz ln lo aw lp bi"><span id="1cca" class="lq jf hi kz b fi lr ls l lt lu">gsutil ls gs://knative-atamel-images-output gs://knative-atamel-images-output/beach-400x400-watermark.jpeg gs://knative-atamel-images-output/beach-400x400.png gs://knative-atamel-images-output/beach-labels.txt</span></pre><p id="a7ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到文本文件中的标签<code class="du kw kx ky kz b">Sky,Body of water,Sea,Nature,Coast,Water,Sunset,Horizon,Cloud,Shore</code>和下面的调整大小和水印图像:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es lw"><img src="../Images/d900da5fbc3fcba01b9c64f71ca75694.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*R4hY7sJTBvwXeprI.jpeg"/></div></figure><h1 id="2bc0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">包裹</h1><p id="82c1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如我提到的，<a class="ae jd" href="https://github.com/meteatamel/knative-tutorial/blob/master/docs/image-processing-pipeline.md" rel="noopener ugc nofollow" target="_blank">完整示例</a>在我的Knative Tutorial repo上。我们的映像管道非常灵活，您可以通过触发器随意添加和删除服务。这就是事件驱动架构的美妙之处。尽管读写事件(在本例中是<code class="du kw kx ky kz b">CloudEvents</code>)需要更多的工作，但它允许高度的灵活性。</p><p id="2f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有问题/评论，欢迎在Twitter上联系我(<a class="ae jd" href="https://twitter.com/meteatamel" rel="noopener ugc nofollow" target="_blank"> @meteatamel </a>)。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="2d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv">最初发布于</em><a class="ae jd" href="https://atamel.dev/posts/2020/06-05_event-driven-image-processing-pipeline-knative/" rel="noopener ugc nofollow" target="_blank"><em class="kv">https://atamel . dev</em></a><em class="kv">。</em></p></div></div>    
</body>
</html>