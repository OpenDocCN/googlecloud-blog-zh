<html>
<head>
<title>Understanding the Container Storage Interface (CSI)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解集装箱存储接口(CSI)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/understanding-the-container-storage-interface-csi-ddbeb966a3b?source=collection_archive---------1-----------------------#2018-08-12">https://medium.com/google-cloud/understanding-the-container-storage-interface-csi-ddbeb966a3b?source=collection_archive---------1-----------------------#2018-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0545bc1478cf853b4bcf18601fa249b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*rpWeeneAYFD8mqz7MdySYA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">集装箱存储接口</figcaption></figure><h1 id="903f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="c94a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">容器存储接口(CSI)是一项旨在统一Kubernetes、Mesos、Docker swarm、cloud foundry等容器编排系统(COs)的存储接口的计划。与Ceph、Portworx、NetApp等存储供应商相结合。这意味着，为一家存储供应商实施单一CSI可以保证适用于所有COs。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es km"><img src="../Images/8ff8bdb89ae4d362d4630c107cf08611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhFEJLBlQ24LLyHvG4ssaw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:<a class="ae kv" href="https://schd.ws/hosted_files/kccnceu18/fb/CloudNativeCon%20EU%202018%20CSI%20Jie%20Yu.pdf" rel="noopener ugc nofollow" target="_blank"> CloudNativeCon EU 2018 CSI于婕</a></figcaption></figure><p id="4dd1" class="pw-post-body-paragraph jo jp hi jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl hb bi translated">请注意，在本文中，我们只讨论动态预配置。预配置卷和灵活卷不在本文讨论范围之内。如果你知道我在说什么，在这里阅读更多关于他们的<a class="ae kv" href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/" rel="noopener ugc nofollow" target="_blank"/>。此外，本文不打算深入研究CSI的实现细节。该文档提供了一个很好的高层次概述，是开始实施CSI的一个很好的先决条件。此外，示例和参考资料基于Kubernetes COs。</p><p id="8d6f" class="pw-post-body-paragraph jo jp hi jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl hb bi translated">在我们开始之前，我们应该知道Kubernetes的边车集装箱是什么。边车集装箱扩展和增强了“主”集装箱。它们与“主”容器存在于同一个容器中，与“主”容器共享存储和网络。</p><p id="4c14" class="pw-post-body-paragraph jo jp hi jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl hb bi translated">在撰写本文时，以下是CSI组件的版本状态。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="8315" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在CSI之前</h1><p id="5c5a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">CSI v0.1第一次发布是在2017年12月。当然，在CSI出现之前，在COs中提供外部存储是可能的。在Kubernetes的情况下，卷插件服务于容器工作负载的存储需求。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es km"><img src="../Images/0bf71fb696b91e55e7f3e1250b99c747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsxMjNGNd6C_L9Vd3zYMWA.png"/></div></div></figure><p id="e5f0" class="pw-post-body-paragraph jo jp hi jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl hb bi translated">卷插件是COs核心的一部分，如上图所示。因此，它具有CSI设计文件中提到的以下缺点:</p><ul class=""><li id="f410" class="ld le hi jq b jr kw jv kx jz lf kd lg kh lh kl li lj lk ll bi translated">批量插件开发是紧密耦合的，并且依赖于Kubernetes版本。</li><li id="03b9" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">Kubernetes开发者/社区负责测试和维护所有批量插件，而不仅仅是测试和维护一个稳定的插件API。</li><li id="0ba9" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">批量插件中的错误会导致关键的Kubernetes组件崩溃，而不仅仅是插件。</li><li id="0ac7" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">卷插件获得kubernetes组件(kubelet和kube-controller-manager)的全部权限。</li><li id="dfc1" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">插件开发者被迫提供插件源代码，并且不能选择只发布二进制代码。</li></ul><h1 id="c4cc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">了解CSI</h1><p id="ffc4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在引入CSI时，Kubernetes团队发布了一些外部组件，它们不是核心的一部分，但可以与供应商实现的外部组件进行交互。它们通过域套接字上的<a class="ae kv" href="https://grpc.io" rel="noopener ugc nofollow" target="_blank"> gRPC </a>相互通信。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es km"><img src="../Images/b78a5b6c0f76e6b4eee642f1611bab4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMgMPjx0obXKlaItZOkRfA.png"/></div></div></figure><h2 id="9075" class="lr ir hi bd is ls lt lu iw lv lw lx ja jz ly lz je kd ma mb ji kh mc md jm me bi translated">Kubernetes外部组件</h2><p id="fd6d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这完全由Kubernetes团队实现和维护。这些将kubernetes的行动扩展到了kubernetes之外。供应商根本不需要担心实现细节。它们由三个子组件组成。</p><ul class=""><li id="4af7" class="ld le hi jq b jr kw jv kx jz lf kd lg kh lh kl li lj lk ll bi translated">driver registrar——是一个sidecar容器，它向kubelet注册CSI驱动程序，并将驱动程序的自定义NodeId添加到Kubernetes节点API对象的标签中。它通过与CSI驱动程序上的身份服务通信并调用CSI GetNodeId操作来实现这一点。</li><li id="4ed1" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">外部置备程序—是一个sidecar容器，用于监视Kubernetes PersistentVolumeClaim对象，并针对驱动程序端点触发CSI CreateVolume和DeleteVolume操作。</li><li id="86a6" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">外部附加器—是一个sidecar容器，它监视Kubernetes卷附件对象，并针对驱动程序端点触发CSI控制器发布和控制器取消发布操作</li></ul><h2 id="0287" class="lr ir hi bd is ls lt lu iw lv lw lx ja jz ly lz je kd ma mb ji kh mc md jm me bi translated">存储供应商/第三方外部组件</h2><p id="5c9c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是供应商特定的实现。每个供应商都应在gRPC服务功能中实施各自的API。例如<a class="ae kv" href="https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver" rel="noopener ugc nofollow" target="_blank"> GCE PD </a>、<a class="ae kv" href="https://github.com/ceph/ceph-csi" rel="noopener ugc nofollow" target="_blank"> Ceph </a>等的实现。它们也由三个子组件组成。</p><ul class=""><li id="2a40" class="ld le hi jq b jr kw jv kx jz lf kd lg kh lh kl li lj lk ll bi translated"><em class="mf"> CSI身份</em>——主要用于识别插件服务，确保其健康，并返回插件本身的基本信息。</li></ul><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><ul class=""><li id="67f4" class="ld le hi jq b jr kw jv kx jz lf kd lg kh lh kl li lj lk ll bi translated"><em class="mf"> CSI控制器</em> —负责控制和管理卷，如:创建、删除、附加/分离、快照等。</li></ul><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><ul class=""><li id="e9d1" class="ld le hi jq b jr kw jv kx jz lf kd lg kh lh kl li lj lk ll bi translated"><em class="mf"> CSI节点</em> —负责控制kubernetes节点中的long volume的动作。</li></ul><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="ba7e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="9e39" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">随着CSI的引入，COs和存储供应商明显受益。由于其定义良好的接口，它还可以帮助开发人员和未来的COs轻松实现和测试CSI。此时，如果您决定开始实施自己的CSI，这是一个很好的起点:<a class="ae kv" href="https://arslan.io/2018/06/21/how-to-write-a-container-storage-interface-csi-plugin/" rel="noopener ugc nofollow" target="_blank">如何实施FatihArlsan的CSI</a>。</p><h1 id="6f5c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">参考</h1><ol class=""><li id="03c5" class="ld le hi jq b jr js jv jw jz mg kd mh kh mi kl mj lj lk ll bi translated">CSI规范:<a class="ae kv" href="https://github.com/container-storage-interface/spec/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank">https://github . com/container-storage-interface/spec/blob/master/spec . MD</a></li><li id="29ee" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl mj lj lk ll bi translated">Kubernetes sidecar容器:<a class="ae kv" href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/blog/2015/06/the-distributed-system-toolkit-patterns/</a></li><li id="64b8" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl mj lj lk ll bi translated">kube con EU:<a class="ae kv" href="https://schd.ws/hosted_files/kccnceu18/fb/CloudNativeCon%20EU%202018%20CSI%20Jie%20Yu.pdf" rel="noopener ugc nofollow" target="_blank">CloudNativeCon EU 2018 CSI于婕</a></li><li id="3daf" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl mj lj lk ll bi translated">CSI设计文档:<a class="ae kv" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#attaching-and-detaching" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface . MD</a></li><li id="f40d" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl mj lj lk ll bi translated">CSI文件:【https://kubernetes-csi.github.io/docs/ T4】</li><li id="d653" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl mj lj lk ll bi translated">CSI文档(已弃用):<a class="ae kv" href="https://github.com/kubernetes-csi/docs/wiki/Usage" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-csi/docs/wiki/Usage</a></li></ol></div></div>    
</body>
</html>