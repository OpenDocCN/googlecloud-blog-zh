<html>
<head>
<title>Java frameworks performances on Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java框架在云上的性能</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/java-frameworks-performances-on-cloud-run-eb243fd84a5c?source=collection_archive---------0-----------------------#2019-07-15">https://medium.com/google-cloud/java-frameworks-performances-on-cloud-run-eb243fd84a5c?source=collection_archive---------0-----------------------#2019-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f9f2303a346d61044bb95df86ebcde15.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*xxaaQwfSt8ycCx4OoC20Jw.png"/></div></figure><p id="d183" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2018年夏天，在旧金山的Google Next，我和我的同事有机会见到了<a class="jk jl ge" href="https://medium.com/u/ef2e4caf305a?source=post_page-----eb243fd84a5c--------------------------------" rel="noopener" target="_blank"> Steren </a>。他跟我们谈了一个新产品，并允许我们在alpha计划中试用。那是第一版<a class="ae jm" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">云跑</a>T4。</p><p id="f3c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我很高兴也很享受这个荣誉，我把我最喜欢的Spring Boot应用程序打包到一个容器中，部署它，然后… <strong class="io hj">什么</strong> <strong class="io hj">？</strong> <em class="jn"> 30秒的冷启动… </em></p><p id="d1c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">绝望中，我继续测试产品，主要是用新的应用程序(<a class="ae jm" rel="noopener" href="/@guillaume.blaquiere/cloud-run-and-cloud-function-what-i-use-and-why-12bb5d3798e1">主要是打包到容器中的python函数</a>)我甚至学习了Go来获得良好的冷启动和处理性能。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="5377" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，我从事Java开发已经15年了，我不接受因为在无服务器世界的第一次糟糕经历而离开这门语言。此外，在我的团队中，不安全类型的语言，比如Python，变得越来越低效和错误百出。Go太“新”了，不能雇佣有经验的开发人员。<strong class="io hj">因此，Java仍然是最好的权衡之一。</strong></p><blockquote class="jv"><p id="db29" class="jw jx hi bd jy jz ka kb kc kd ke jj dx translated">如果非要我选一个Java框架，哪个性能最好？</p></blockquote><h1 id="f225" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">如何比较框架</h1><p id="e56b" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">我是一名高级Java开发人员，但我并不了解所有不同框架的所有技巧和优化。顺便说一下，为了保持中立，我选择用两个主要框架编写一个<strong class="io hj"> HelloWorld HTTP GET端点:Spring Boot和Micronaut。</strong></p><p id="78bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">事实上，我什么也没写，我只是为它们中的每一个提供了现成的例子。<em class="jn">我不会在这里描述如何构建这些hello world示例，框架网站确实有据可查！我在故事的结尾提供了代码</em></p><p id="dad5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我还用纯Java写了一个HTTP端点，没有框架T21来衡量框架对性能的影响。</p><p id="34d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个测试都被打包到一个容器中，并部署在完全托管的云上。</p><h2 id="90f2" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">Spring Boot</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lw"><img src="../Images/950d9f80f4efa37f04a7d28653ef6f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ip7XmSfDmS3B16ADQ8-ZUg.png"/></div></div></figure><p id="2132" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring Boot是我最喜欢的框架。我已经用它开发了很多年，我仍然喜欢它的方便和简单。你有特别的事情要做？没问题，弹簧组件就是为此而存在的！对此进行注释，并享受！</p><p id="093b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它的优势之一是自动加载。只需添加一个依赖项，Spring boot就会在启动时自动扫描并加载所有的库！你们班是注射豆？不需要声明它，注释它，它会自动加载！当然，依赖项越多，需要扫描的文件就越多，启动时间也就越长。</p><p id="4b41" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这种优势在不可扩展的环境中非常完美，就像我的内部环境一样。我启动我的应用程序一次，它会一直运行到下一次修改。当然启动时间挺长的(20到30秒)，但是一个月一次，完全可以接受！</p><p id="9bc6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，库扫描强度，以及隐含的额外启动时间，是无服务器、自动扩展和扩展到0环境中的主要难点。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mf"><img src="../Images/9b3d6a64b118e52e09a748a238ceb904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rcNsZ8Pl4yU1SyrNFwnRwQ.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">SpringBoot HelloWorld</figcaption></figure><h2 id="bb76" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">微型机器人</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/2e2e27d4244f8bf7b92fbaf69f5b38b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*ZRHvGvVEAANthrjjLJjapg.png"/></div></figure><p id="1091" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">三藩市的春天，我在第一次参加Next 19 的<a class="ae jm" href="https://www.youtube.com/watch?v=RdemnsW6sOQ" rel="noopener ugc nofollow" target="_blank">会议时发现了</a><a class="ae jm" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>。我只是尝试了一下，没有用Micronaut搭建真正的app，但它似乎是SpringBoot的一个很好的替代方案。</p><p id="c007" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注释语法类似于Spring Boot，您也可以在框架中导入Spring Boot注释包装器。有许多与Spring Boot等效的功能。与SpringBoot的区别和Micronaut的最大优势在于<strong class="io hj">库扫描是在编译时</strong>执行的。因此，在启动时，应用程序知道加载哪些包，而不必扫描所有文件。</p><p id="f570" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，启动时间比Spring Boot好，但我猜(但我没有测试过)，启动时间应该很稳定，即使你添加了很多新的库和文件。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es ml"><img src="../Images/ca20e4523d82849afc8c289625f9982e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0T59APVRQHucHtXUEs38w.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">微型机器人HelloWorld</figcaption></figure><h2 id="3272" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">Micronaut + GraalVM</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mm"><img src="../Images/ca8df8401a6186248dba55274ea0e49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPljrKVvbqY1ayA7dgG-Zw.jpeg"/></div></div></figure><p id="0b03" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Micronaut还能够与<a class="ae jm" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a>封装在一起。这种<strong class="io hj"> AOT(提前)封装</strong>改善了启动时间和内存占用。</p><p id="e7a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了Micronaut，我还发现尝试这些表演很有趣</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mn"><img src="../Images/6aad8dc5be5632d0c44a476e5a219c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JcyeASb0ewmYWyp30W3BeQ.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">micronaut+GraalVM docker文件</figcaption></figure><h2 id="650e" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">Java servlet</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/3f134efa50569f5d5fb1f7ae4bab4caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*SI_GBcfdpCMi1S1gdmWL3A.png"/></div></figure><p id="2e24" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于开发者来说，框架是有用的，强大的，非常酷的。但通常，它们很麻烦，并且会消耗大量内存和CPU(影响启动时间)用于一些未使用的功能。</p><p id="b9fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于一个简单的helloWorld HTTP端点，我选择用Jetty webserver用纯Java开发。这里，<strong class="io hj">没有注释，只有Java，继承和覆盖</strong>！我不得不全靠自己。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mp"><img src="../Images/28f720f46954df9505f4789c686d5217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2FAkaUZk4xXDo7orfjl1g.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">Servlet Hello World</figcaption></figure><h2 id="64d5" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">Spring Boot网络流量</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lw"><img src="../Images/6e6ce490ac3b48126423a59d08236aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wjKWPqPdsfCq_UZW7JxkwQ.jpeg"/></div></div></figure><p id="11ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">又是Spring Boot？是的。正如您在观察结果中看到的，Spring Boot开箱即用示例的性能很差。我对此很恼火，因为我真的很喜欢这个框架。</p><p id="1c40" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在Youtube上看了下一次与T2的会面。他解释了如何在GCP身上使用SpringBoot，并提出如果我们有问题可以在Twitter上联系他，我照做了。Ray非常酷，他用webflux和pom.xml技巧帮助我提高了Spring Boot HelloWorld <strong class="io hj">的性能。这就是为什么我也想分享这些改进。</strong></p><h2 id="1827" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">关于JIB插件的一句话</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mq"><img src="../Images/3b07c789b034e7d7c711f95c92cbdc6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoUBsL0JfdKAiHrh1PVuTA.png"/></div></div></figure><p id="9454" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除了GraalVM打包，我总是使用Dockerfile和JIB打包容器来比较性能。</p><p id="8237" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae jm" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> JIB </a>是一个<a class="ae jm" href="https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin" rel="noopener ugc nofollow" target="_blank"> Maven </a>和<a class="ae jm" href="https://github.com/GoogleContainerTools/jib/tree/master/jib-gradle-plugin" rel="noopener ugc nofollow" target="_blank"> Gradle </a>插件，由Googlers员工开发，用于<strong class="io hj">轻松高效地将Java代码打包到一个容器中。</strong>您不需要编写docker文件，如果您想定制它，只需要一些配置参数。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mr"><img src="../Images/04c1a28e86a6d0b39e740c798e3a7649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUyEgj_dBuNKMXiixq31wA.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx translated">JIB maven插件</figcaption></figure><h1 id="4521" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq ms ks kt ku mt kw kx ky mu la lb lc bi translated">表演</h1><h2 id="693f" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">测试程序和测量</h2><p id="2bfc" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">所有测试都是在美国中部地区的<strong class="io hj">云上进行的。容器部署在<strong class="io hj">安全模式</strong>(禁用allow-unauthenticated选项)下，并使用<strong class="io hj">默认参数</strong>(内存、无环境变量、默认服务帐户……)</strong></p><p id="faad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个版本的启动时间都经过了3次测试。该值在云运行日志中提供，并带有注释“<em class="jn">该请求导致一个新的容器实例启动，因此可能比典型请求花费更长时间并使用更多CPU。</em>这3次测试的平均值就是冷启动值。3可能看起来很少，但实际上，<strong class="io hj">云运行性能相当稳定</strong>，因此足以对冷启动有一个充分的了解。</p><p id="404d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<a class="ae jm" href="https://github.com/rakyll/hey" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">嘿</strong> </a>执行负载测试后，获取平均响应时间和内存使用量。为了防止云运行容器的规模扩大，我用以下内容设置了Hey参数:</p><ul class=""><li id="b0f8" class="mv mw hi io b ip iq it iu ix mx jb my jf mz jj na nb nc nd bi translated"><strong class="io hj">并发到1 </strong>避免多个对云的调用同时运行</li><li id="c415" class="mv mw hi io b ip ne it nf ix ng jb nh jf ni jj na nb nc nd bi translated"><strong class="io hj">请求由第二个到第五个</strong>来限制负载，从而限制新实例的创建。</li></ul><p id="2d90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">负载测试<strong class="io hj">执行来自<strong class="io hj">云外壳环境的2500个请求</strong>。</strong> ( <em class="jn">如你所见，全局延迟约为115毫秒。全局是指从云壳到云运行，处理时间，以及返回的方式。除冷启动外，在云运行日志中，</em> <strong class="io hj"> <em class="jn">延迟稳定，约6ms </em> </strong> <em class="jn">。剩下的时间都浪费在网络上了(而且我在欧洲地区)</em>。</p><p id="3aa4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">平均响应时间由Hey提供。并且<strong class="io hj">内存使用由云运行控制台指标</strong>提供。</p><p id="1172" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，<strong class="io hj">容器大小由Google容器注册中心</strong>提供。</p><h2 id="90a1" class="li kg hi bd kh lj lk ll kl lm ln lo kp ix lp lq kt jb lr ls kx jf lt lu lb lv bi translated">观察到的结果</h2><p id="6922" class="pw-post-body-paragraph im in hi io b ip ld ir is it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj hb bi translated">观察到的结果可以在<a class="ae jm" href="https://github.com/guillaumeblaquiere/cloudrun-java-framework#observed-result" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es nj"><img src="../Images/b4252d6a5f002584db2b570e9e780e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GE7hNUEyZt13vVvz0pcAZg.png"/></div></div></figure><p id="27be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">基于这些结果，以下是一些结论:</p><p id="9f6c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">首先</strong>容器在负载测试中使用相同数量的内存，请求延迟也是相同的。</p><p id="3e0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第二个</strong>，除了GraalVM，JIB插件比手工构建的Dockerfile更高效(或者等同于Servlet)。如果你在Dockerfile中没有特殊要求，<strong class="io hj">先用JIB</strong>！</p><blockquote class="nk nl nm"><p id="f67a" class="im in jn io b ip iq ir is it iu iv iw nn iy iz ja no jc jd je np jg jh ji jj hb bi translated">我不是Dockerfiles的专家，我只用了“官方”样本。也许可以通过优化来提高Dockerfiles的性能。</p></blockquote><p id="8dcf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第三，毫无疑问，无框架的使用提高了性能，但是增加了开发的复杂性和所需的技能。有了框架，<strong class="io hj"> Micronaut + GraalVM的性能对任何Java来说都是不可思议的。</strong></p><p id="6b36" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">最后</strong>，我最喜欢的SpringBoot在优化后(启动时间为5秒)还是可以接受的，但这只是一个HelloWorld端点。不知道在真实的app上性能会怎么样，依赖性比较多。不确定这是否适合所有用例以及所有需求。</p><p id="1685" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jn">容器大小仅供参考，不影响任何指标。</em></p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="2080" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我的代码在<a class="ae jm" href="https://github.com/guillaumeblaquiere/cloudrun-java-framework" rel="noopener ugc nofollow" target="_blank"> Github </a>上公开。你也可以把它作为一个快速开始。<code class="du nq nr ns nt b">Dockerfile</code>和<code class="du nq nr ns nt b">cloudbuild.yaml</code>文件用于在<a class="ae jm" href="https://cloud.google.com/cloud-build/" rel="noopener ugc nofollow" target="_blank">云构建</a>上构建项目。你也可以使用<a class="ae jm" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> JIB来构建容器并将其推</a>，默认为<a class="ae jm" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank"> Google容器注册表</a>。</p><p id="e7c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所有的构建和部署指令都在<code class="du nq nr ns nt b">Readme.md</code>文件中。</p><p id="cbed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我想再次感谢雷对我的帮助，以及他在SpringBoot改进中付出的时间。</p></div></div>    
</body>
</html>