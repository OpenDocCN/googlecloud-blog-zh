<html>
<head>
<title>Workload Identity Federation for On-Premise Workloads with SPIFFE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SPIFFE实现本地工作负载的工作负载身份联合</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/workload-identity-federation-for-on-premise-workloads-with-spiffe-24a861b3cf6c?source=collection_archive---------0-----------------------#2022-04-09">https://medium.com/google-cloud/workload-identity-federation-for-on-premise-workloads-with-spiffe-24a861b3cf6c?source=collection_archive---------0-----------------------#2022-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天我想和大家分享一个来自CNCF的非常酷的项目:面向所有人的安全生产身份框架(SPIFFE)是一个用于分布式系统的通用身份控制平台。我强烈推荐你观看两年前凯尔西·海托华在KubeCon上的精彩<a class="ae jd" href="https://www.youtube.com/watch?v=6e4snGCTLOk" rel="noopener ugc nofollow" target="_blank">主题演讲</a>，它对SPIFFE及其用途做了很好的概述。</p><p id="19a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是由于你可能还不想看视频，这里有一个快速的TL；斯皮夫博士想做的是。假设您有一个运行在虚拟机上的应用程序。应用程序如何访问数据库服务器？很简单，您可以配置用户名和密码，也许是作为一个环境变量。我们都知道以这种方式处理秘密是一个很大的痛点。轮换它们并实际上保持它们的秘密可能是一项乏味的任务。所有这些通常是因为我们没有考虑一个简单的问题:我们的应用程序的身份是什么？</p><p id="ef3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在云中，通常有一个<a class="ae jd" href="https://cloud.google.com/iam/docs/service-accounts" rel="noopener ugc nofollow" target="_blank">服务帐户</a>的概念，将身份直接或间接地绑定到工作负载。在传统的数据中心架构中，虚拟机没有明确的身份。当然，他们有一个名字，但他们没有一个身份来验证和授权其他服务。一些组织为此使用MTLS，并在每台机器上放置证书。当使用Kubernetes时，有一些像<a class="ae jd" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>这样的便捷工具可以让这个过程变得更容易。但是拥有一个可互操作的方法仍然是难以捉摸的。例如，Google Cloud APIs不接受AuthN和AuthZ的MTLS。SPIFFE试图填补这一空白，CNCF Spire为此提供了一个生产就绪的实施方案。如果您的数据中心正在运行工作负载，您真的应该看看SPIFFE和Spire。</p><p id="4dfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多开发人员发现管理与GCP API通信的本地工作负载非常具有挑战性。我想向您展示SPIFFE如何通过结合SPIFFE和Google Workload Identity来解决互操作性问题。在这些领域中，您可以找到不同的方法来解决这一挑战，其中包含各种陷阱:</p><ul class=""><li id="2db6" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">有些人会导出GCP IAM服务帐户密钥，并将其放在机器上。这是你能做的最糟糕的事情！不要那样做。</li><li id="78e5" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">您可以使用Workload Identity Federation和基于OIDC的身份提供者。工作负载使用客户端凭据授权进行身份验证。这要好得多，但仍然意味着您有一个clientID和clientSecret，您希望对它们进行轮换并保密。</li><li id="1f9f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">您可以查看SPIFFE并设置Spire，然后将其与工作负载身份联邦集成。</li></ul><h1 id="087a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">SPIFFE和工作负载身份联盟</h1><p id="01d2" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">你可以按照伟大的<a class="ae jd" href="https://spiffe.io/docs/latest/try/getting-started-linux-macos-x/" rel="noopener ugc nofollow" target="_blank">入门指南</a>在你自己的本地机器上安装Spire，很容易地尝试这一点。不过，您需要做一点小小的更改，因为我们需要创建一个可发现的OIDC配置。我发现运行这个小型POC最简单的方法如下:</p><ol class=""><li id="0b6d" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kv jk jl jm bi translated">创建一个GCS存储桶。在<code class="du kw kx ky kz b">conf/server/server.conf</code>文件中添加一个条目:<code class="du kw kx ky kz b">jwt_issuer = “https://&lt;bucket_name&gt;.storage.googleapis.com</code>。</li><li id="0dbf" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">在<code class="du kw kx ky kz b">.well-known/openid-configuration</code>下添加下面的openid-configuration(确保替换占位符)。</li><li id="9d7e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">通过调用<code class="du kw kx ky kz b">bin/spire-agent api fetch jwt -audience test</code>从Spire服务器获取JWKS。输出包含一个带有密钥的JSON对象。只需将带有keys关键字的整个key对象放在一个名为<code class="du kw kx ky kz b">keys</code>的文件中，并将其放在bucket的根文件夹中。</li><li id="5571" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">在Google Cloud控制台中，创建一个新的工作负载身份池和提供者，并将发布者设置为<code class="du kw kx ky kz b">https://&lt;bucket_name&gt;.storage.googleapis.com</code>。</li><li id="a310" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">添加一个您希望在本地工作负载中使用的新服务帐户。您需要授予测试工作负载的SPIFFE ID对服务帐户的访问权限:</li></ol><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="79d2" class="li jt hi kz b fi lj lk l ll lm">gcloud iam service-accounts add-iam-policy-binding SERVICE_ACCOUNT_EMAIL \<br/>    --role=roles/iam.workloadIdentityUser \<br/>    --member="principal://iam.googleapis.com/projects/&lt;project_number&gt;/locations/global/workloadIdentityPools/&lt;workload_pool_id&gt;/subject/&lt;SPIFFE_ID&gt;"</span></pre><p id="cfcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenID示例发现文档:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="0dc9" class="li jt hi kz b fi lj lk l ll lm">{<br/>  "issuer": "https://&lt;bucket_name&gt;.storage.googleapis.com",<br/>  "jwks_uri": "https://&lt;bucket_name&gt;.storage.googleapis.com/keys",<br/>  "authorization_endpoint": "",<br/>  "response_types_supported": [<br/>    "id_token",<br/>    "access_token"<br/>  ],<br/>  "subject_types_supported": [],<br/>  "id_token_signing_alg_values_supported": [<br/>    "RS256",<br/>    "ES256",<br/>    "ES384"<br/>  ]<br/>}</span></pre><p id="ef58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以请求一个SPIFFE JWT令牌，根据安全令牌服务API交换它，并使用新令牌来模拟服务帐户(如果您想手动运行这些步骤，这里的<a class="ae jd" href="https://cloud.google.com/iam/docs/using-workload-identity-federation#oidc_2" rel="noopener ugc nofollow" target="_blank">是如何操作的)。</a></p><h1 id="8513" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">斯皮夫·GCP代理</h1><p id="0d10" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">为了使整个过程更加用户友好，并与gcloud SDK和Google云库更好地集成，我创建了一个小型代理工具，您可以在您的机器上与spire-agent和工作负载一起运行，以提供一种GCP元数据服务器兼容的方法来检索访问令牌:</p><div class="ln lo ez fb lp lq"><a href="https://github.com/GoogleCloudPlatform/professional-services/tree/main/tools/spiffe-gcp-proxy" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab dw"><div class="ls ab lt cl cj lu"><h2 class="bd hj fi z dy lv ea eb lw ed ef hh bi translated">主Google cloud platform/professional-services/sp iffe-GCP-proxy</h2><div class="lx l"><h3 class="bd b fi z dy lv ea eb lw ed ef dx translated">这是一个简单的GOLANG应用程序，为希望使用Google Cloud的本地工作负载提供一个身份验证代理…</h3></div><div class="ly l"><p class="bd b fp z dy lv ea eb lw ed ef dx translated">github.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me mf lq"/></div></div></a></div><figure class="la lb lc ld fd mh er es paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="er es mg"><img src="../Images/ccdcb4926ecc4d6232b603b9fd117b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrjYlq8ZZ9TOYjae2yISjQ.png"/></div></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">这里发生了什么</figcaption></figure><p id="7f69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此代理实现的工作流执行以下步骤:</p><ol class=""><li id="d29f" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kv jk jl jm bi translated">工作负载通过<a class="ae jd" href="http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/" rel="noopener ugc nofollow" target="_blank">http://metadata . Google . internal/computeMetadata/v1/instance/service-accounts/</a>&lt;sa&gt;/token请求一个GCP身份验证令牌。</li><li id="c14e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">代理从本地Spire代理请求一个JSON Web令牌(JWT)。</li><li id="e53b" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">Spire代理向Spire服务器请求JWT。</li><li id="10a8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">代理获取SPIFFE JWT，并从安全令牌服务(STS) API请求新令牌。</li><li id="c7a2" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">STS通过检索<code class="du kw kx ky kz b">.well-known/openid-configuration</code>和jwk来验证发行者，从而验证传递的SPIFFE JWT是否有效。(在此POC中，openid配置实际上是从GCS加载的)</li><li id="0ef1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">STS创建并传回一个访问令牌。此令牌只能用于模拟服务帐户。</li><li id="cb59" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">代理使用“模拟令牌”请求服务帐户访问令牌。</li><li id="c6ac" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">代理使用服务帐户的GCP IAM访问令牌来响应工作负载。</li><li id="ea8a" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kv jk jl jm bi translated">工作负载可以使用访问令牌针对Google Cloud APIs进行认证和授权。</li></ol><p id="f032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将您需要在机器上做的步骤减少到简单地调用<code class="du kw kx ky kz b">gcloud compute instances list</code>。代理将负责检索和交换各种令牌，您可以只使用谷歌工具中现有的automagic。</p><p id="cb4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">spiffe-gcp-proxy方法适用于运行单一工作负载/需要单一身份的虚拟机。如果您考虑在本地Kubernetes集群上运行您的工作负载，您仍然可以使用基本的方法，但是可能会稍微扩展该机制，以处理在系统上运行具有潜在不同身份的多个工作负载。</p><p id="fbec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来，如果您在内部运行工作负载，SPIFFE绝对是您应该了解的。这绝对是一项你应该关注的技术，因为我相信它在未来会变得更加普遍。</p></div></div>    
</body>
</html>