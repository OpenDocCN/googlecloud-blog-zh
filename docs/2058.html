<html>
<head>
<title>An Agile Architecture for Analytics and AI on Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云上分析和人工智能的敏捷架构</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/an-agile-architecture-for-analytics-and-ai-on-google-cloud-6415e692591f?source=collection_archive---------0-----------------------#2022-01-14">https://medium.com/google-cloud/an-agile-architecture-for-analytics-and-ai-on-google-cloud-6415e692591f?source=collection_archive---------0-----------------------#2022-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b945" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">押注于低代码/无代码和无服务器</h2></div><p id="a054" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">敏捷架构能够为您提供:</p><ul class=""><li id="4a9e" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated"><strong class="iz hj">发展速度。</strong>你应该能够尽可能快地从想法到部署</li><li id="fa21" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="iz hj">灵活性</strong>快速实施新功能。有时速度是以灵活性为代价的——架构可能会把你硬塞进一组非常有限的用例中。你不想那样。</li><li id="80c9" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="iz hj">低维护</strong>这样你就不用花时间管理基础设施了。</li><li id="14ab" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated"><strong class="iz hj">自动扩展和弹性</strong>让您不必花费时间监控基础设施</li></ul><p id="6efe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当涉及到数据分析和人工智能时，这样的架构在谷歌云上看起来是什么样的？它将使用低代码和无代码服务(预建的连接器、自动复制、ELT、AutoML ),以便您获得开发速度。就灵活性而言，该架构将允许您在任何需要的时候使用对开发人员友好的强大代码(Apache Beam、SQL、TensorFlow)。这些将运行在无服务器的基础设施上(Pub/Sub、Dataflow、BigQuery、Vertex AI ),这样你就可以获得低维护、自动伸缩和弹性。</p><h2 id="69cc" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">无代码、低代码分析和人工智能堆栈</h2><p id="91d3" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">说到架构，选择无代码而不是低代码，选择低代码而不是编写定制代码。在将数据放入BigQuery之前，不要编写ETL管道来转换数据，而是使用预建的连接器(在数据融合、数据流、数据传输服务、数据流模板、FiveTran等中)。)将原始数据直接放入BigQuery。然后，直接在数据仓库中使用SQL视图将数据转换成您需要的形式。如果您选择ELT方法而不是ETL方法，您将会更加敏捷。</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lh"><img src="../Images/8363efcb15e78eaa6bf678926b58b5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hgTr-lTNVvOqutu4"/></div></div></figure><p id="e0ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个地方是当你选择你的ML建模框架的时候。不要从定制TensorFlow模型开始。从AutoML开始。这是无代码。您可以直接从BigQuery调用AutoML，避免构建复杂的数据和ML管道。如有必要，从TensorFlow Hub、HuggingFace等处转移到预建模型。以及Vertex AI上的预建容器。那是低代码。只有在万不得已的情况下，才构建自己的定制ML模型。</p><h2 id="b247" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">使用托管服务</h2><p id="c96d" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">如果低级代码的方法限制太多，您将希望能够直接使用代码。幸运的是，上面的无代码架构是这个完整架构的子集，它为您提供了所需的所有灵活性:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lt"><img src="../Images/02234f1693f2b5290d682d3df6adfd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BdvluggQrXwEMPOf"/></div></div></figure><p id="2793" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当用例允许时，您将拥有Apache Beam、SQL和TensorFlow的全部灵活性。这一点至关重要——对于ELT+AutoML方法限制性太强的用例，您可以使用ETL/数据流+ Keras/Vertex方法。</p><p id="5981" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最重要的是，架构是统一的，所以您不用维护两个堆栈。因为第一个架构是第二个架构的子集，所以您可以用统一的方式完成简单和困难的用例。</p><p id="be91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽情享受吧！</p></div></div>    
</body>
</html>