<html>
<head>
<title>Kubernetes Engine from scratch 1/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes发动机从零开始1/2</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-engine-from-scratch-2c2369c46841?source=collection_archive---------0-----------------------#2018-08-15">https://medium.com/google-cloud/kubernetes-engine-from-scratch-2c2369c46841?source=collection_archive---------0-----------------------#2018-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="49c6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">库伯内特斯历险记</h2></div><p id="1315" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">带着一个新谷歌人(New-Googler)踏上了从零到Kubernetes的旅程，运行了一吨的东西，并认为为了你的利益公开记录这些东西是有用的。</p><p id="266f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用的是<a class="ae jt" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> Kubernetes引擎</a>和<a class="ae jt" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank"> Google容器注册表</a>，但是，如果您跳过集群配置步骤，您将能够在部署步骤中获得一些东西，并且它将在您运行Kubernetes的任何地方工作。我还将包括使用Docker Hub的指导，因为它是Docker引擎的默认注册表。</p><h2 id="39fb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">谷歌云平台(GCP)</h2><p id="c342" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">你需要一个谷歌账户(例如Gmail)和(可能！)1张信用卡来设置账单。Kubernetes引擎依赖于计算引擎，而计算引擎要求启用计费。</p><p id="fc31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请为以下环境变量提供值(替换<code class="du ku kv kw kx b">[[...]]</code>):</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="101e" class="ju jv hi kx b fi lg lh l li lj">PROJECT=[[YOUR-PROJECT]]<br/>BILLING=[[YOUR-BILLING]]<br/>CLUSTER=[[YOUR-CLUSTER]]<br/>REGION=[[YOUR-REGION]]</span></pre><p id="41bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后创建GCP项目，将您的计费帐户与其相关联，启用Kubernetes引擎(以前称为“容器引擎”)服务，并提供一个区域性(3个区域)集群:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="e643" class="ju jv hi kx b fi lg lh l li lj">LATEST=1.10.5-gke.4</span><span id="bad2" class="ju jv hi kx b fi lk lh l li lj">gcloud beta container clusters create $CLUSTER \<br/>--username="" \<br/>--cluster-version=${LATEST} \<br/>--machine-type=custom-2-8192 \<br/>--image-type=COS \<br/>--num-nodes=1 \<br/>--enable-autorepair \<br/>--enable-autoscaling \<br/>--enable-autoupgrade \<br/>--enable-stackdriver-kubernetes \<br/>--min-nodes=1 \<br/>--max-nodes=2 \<br/>--region=${REGION} \<br/>--project=${PROJECT} \<br/>--preemptible \<br/>--scopes="<a class="ae jt" href="https://www.googleapis.com/auth/cloud-platform" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/cloud-platform</a>"</span></pre><blockquote class="ll lm ln"><p id="239d" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>参见我之前关于确保使用最新的<code class="du ku kv kw kx b">${LATEST}</code> ( <a class="ae jt" rel="noopener" href="/google-cloud/kubernetes-engine-master-node-versions-b5ecd9ed0b35">链接</a>)值的故事。</p></blockquote><p id="1ef9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个命令(不正确地说是IMO)用刚刚创建的集群的凭证来配置<code class="du ku kv kw kx b">kubectl</code>。据推测，它这样做是为了简化集群的使用，因为您应该能够:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="37d6" class="ju jv hi kx b fi lg lh l li lj">kubectl get nodes<br/>NAME                                                  STATUS    ROLES     AGE       VERSION<br/>gke-...-1b9910a9-wrb0   Ready     &lt;none&gt;    10m       v1.10.5-gke.4<br/>gke-...-999f7527-plps   Ready     &lt;none&gt;    7m        v1.10.5-gke.4<br/>gke-...-ab2d8494-6ksz   Ready     &lt;none&gt;    10m       v1.10.5-gke.4</span></pre><blockquote class="ll lm ln"><p id="6745" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>为了与Kubernetes(不仅仅是Kubernetes引擎)进行交互，我们将使用Kubernetes CLI ( <code class="du ku kv kw kx b">kubectl</code>)和Google的Kubernetes引擎控制台。你可以使用<code class="du ku kv kw kx b">kubectl</code>做任何事情(甚至更多)。谷歌的Kubernetes引擎控制台仅限于Kubernetes引擎集群。</p></blockquote><p id="79f9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，我认为这是不好的做法。我请求了一个集群，但没有明确要求向它进行身份验证。如果它不执行身份验证步骤，您需要:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="4928" class="ju jv hi kx b fi lg lh l li lj">gcloud container clusters get-credentials ${CLUSTER} \<br/>--project=${PROJECT} \<br/>--region=${REGION}</span></pre><p id="24e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论哪种方式，凭证都是在<code class="du ku kv kw kx b">kubeconfig</code>文件中配置的，对于Linux用户来说，这个文件就是<code class="du ku kv kw kx b">${HOME}/.kube/config</code>。</p><p id="adc5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes引擎的控制台可通过谷歌云控制台获得，您可以访问它:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="1633" class="ju jv hi kx b fi lg lh l li lj">google-chrome \<br/>console.cloud.google.com/kubernetes/list?project=${PROJECT}</span></pre><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ls"><img src="../Images/69ad2fd6ddcd6225380de5dcc7c6be8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKG5xKXZHUIsKCtLec9GCg.png"/></div></div></figure><p id="069d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以查看节点:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="e369" class="ju jv hi kx b fi lg lh l li lj">google-chrome \<br/><a class="ae jt" href="https://pantheon.corp.google.com/kubernetes/clusters/details/us-west1/dazwilkin-180814-cluster-01?project=dazwilkin-180814-abhishelat&amp;tab=nodes&amp;persistent_volumes_tablesize=50&amp;storage_class_tablesize=50&amp;nodes_tablesize=50" rel="noopener ugc nofollow" target="_blank">console.cloud.google.com/kubernetes/clusters/details/${REGION}/${CLUSTER}?${PROJECT}&amp;tab=nodes</a></span></pre><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ma"><img src="../Images/40c6d6dbecfa6eddb25cf28d72e15549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3E5-KXQ9pGxKiaZngcnFA.png"/></div></div></figure><h2 id="3f4d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">库伯内特斯</h2><p id="db6a" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我将使用Joe Beda的“Kubernetes Up and Running”图像(又名<code class="du ku kv kw kx b">kuard</code>)，因为它提供了对Kubernetes环境的一些内省，并且包括就绪性和活性探测。</p><p id="4cb0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然像我将要做的那样动态地将更改应用到您的集群不是一个好的实践，但是我们都已经这样做了；-)</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="9919" class="ju jv hi kx b fi lg lh l li lj">kubectl run kuard \<br/>--image=gcr.io/kuar-demo/kuard-amd64:1 \<br/><strong class="kx hj">--restart=Never</strong></span></pre><p id="5bb1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是来自kuard GitHub <a class="ae jt" href="https://github.com/kubernetes-up-and-running/kuard" rel="noopener ugc nofollow" target="_blank"> repo </a>的命令。对库本内特斯鹅有益的东西对库本内特斯鹅也有益；不管在哪里，库伯内特都是库伯内特。</p><p id="2500" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">控制台的视觉细节有助于解释一些东西，我将包括控制台的等价物。但是，我将主要使用CLI显示命令:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="1875" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods<br/>NAME      READY     STATUS    RESTARTS   AGE<br/>kuard     1/1       Running   0          13s</span></pre><p id="040e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，从GitHub repo中，我们将从本地机器向集群上运行的<code class="du ku kv kw kx b">kuard</code> Pod转发:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="4d01" class="ju jv hi kx b fi lg lh l li lj">kubectl port-forward kuard 8080:8080</span></pre><blockquote class="ll lm ln"><p id="b32f" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>为了能够浏览Pod的服务，您需要让该进程保持运行。当你浏览完了，你可以杀了它。</p></blockquote><p id="1960" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="0966" class="ju jv hi kx b fi lg lh l li lj">google-chrome http://localhost:8080</span></pre><p id="3f81" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该会看到:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mb"><img src="../Images/5b1adce5055ad2fa85d485923f4ebc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQuh7tXcNapY1H-OVX6_5A.png"/></div></div></figure><p id="d9c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你<code class="du ku kv kw kx b">kubectl run</code>一个图像时，命令应用<code class="du ku kv kw kx b">[NAME]</code>的值作为窗格上标签<code class="du ku kv kw kx b">run</code>的值。Kubernetes的一个好习惯是通过标签而不是名称来引用事物，因此，对于前面的命令，一个更好的替代方法是:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="df4a" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods <strong class="kx hj">--selector=run=kuard</strong><br/>NAME      READY     STATUS    RESTARTS   AGE<br/>kuard     1/1       Running   0          5m</span></pre><p id="2a94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以检查Pod的日志:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="3761" class="ju jv hi kx b fi lg lh l li lj">kubectl logs kuard<br/>2018/08/14 17:53:20 Starting kuard version: v0.7.2-1<br/>2018/08/14 17:53:20 ********************************************************************<br/>2018/08/14 17:53:20 * WARNING: This server may expose sensitive<br/>2018/08/14 17:53:20 * and secret information. Be careful.<br/>2018/08/14 17:53:20 ********************************************************************<br/>2018/08/14 17:53:20 Config: <br/>{<br/>  "address": ":8080",<br/>  "debug": false,<br/>  "debug-sitedata-dir": "./sitedata",<br/>  "keygen": {<br/>    "enable": false,<br/>    "exit-code": 0,<br/>    "exit-on-complete": false,<br/>    "memq-queue": "",<br/>    "memq-server": "",<br/>    "num-to-gen": 0,<br/>    "time-to-run": 0<br/>  },<br/>  "liveness": {<br/>    "fail-next": 0<br/>  },<br/>  "readiness": {<br/>    "fail-next": 0<br/>  },<br/>  "tls-address": ":8443",<br/>  "tls-dir": "/tls"<br/>}<br/>2018/08/14 17:53:20 Could not find certificates to serve TLS<br/>2018/08/14 17:53:20 Serving on HTTP on :8080<br/>2018/08/14 17:55:42 127.0.0.1:55808 GET /<br/>2018/08/14 17:55:42 Loading template for index.html<br/>...</span></pre><p id="8132" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个豆荚，嘘！这一次，我们将移除<code class="du ku kv kw kx b">--restart</code>标志并添加一个<code class="du ku kv kw kx b">--replicas</code>标志。我用3，你可以用任何你想要的值。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="5e7d" class="ju jv hi kx b fi lg lh l li lj">kubectl run kuard  \<br/>--image=gcr.io/kuar-demo/kuard-amd64:1 \<br/><strong class="kx hj">--replicas=3</strong></span></pre><p id="a038" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，Kubernetes将豆荚包装在一个部署中。Deployment是Kubernetes的一个资源，不出所料，它管理Pod的部署(1个或更多，我们也可以用它来管理单个Pod)。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="3b2b" class="ju jv hi kx b fi lg lh l li lj">kubectl get deployments --selector=run=kuard<br/>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>kuard     3         3         3            3           6m</span><span id="0ede" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods --selector=run=kuard<br/>NAME                    READY     STATUS    RESTARTS   AGE<br/>kuard-b75468d67-kmbt5   1/1       Running   0          6m<br/>kuard-b75468d67-lnl4v   1/1       Running   0          6m<br/>kuard-b75468d67-s5m86   1/1       Running   0          6m</span></pre><blockquote class="ll lm ln"><p id="a9e4" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">我选择基于标签的资源，因为这是一个好习惯，也因为Kubernetes的名字并不总是显而易见的。在上面的内容中，可以看到Kubernetes是如何被要求动态命名<code class="du ku kv kw kx b">kuard</code>pod的，因为当有多个pod时，它们必须被唯一地命名。通过标签选择窗格可以继续正常工作。</p></blockquote><p id="b675" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署有很多好处。您应该将它们视为默认的Kubernetes资源类型。现在我们有了一个部署，我们可以很容易地将这组资源公开为Kubernetes服务:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="d67e" class="ju jv hi kx b fi lg lh l li lj">kubectl expose deployment/kuard --type=LoadBalancer --port=8080</span></pre><p id="60b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将使用部署(称为<code class="du ku kv kw kx b">kuard</code>)作为基础创建一个服务(也称为<code class="du ku kv kw kx b">kuard</code>)。事实上，它将自己加入部署的pod，而不是部署，并且它通过基于它们的标签选择pod来做到这一点！</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ma"><img src="../Images/9d2b454f9c40fa25576983fe2a4ff08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5x13M10FOuvbYn-71Upy-g.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">服务被创建</figcaption></figure><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mg"><img src="../Images/7d35cecec117b5bde025ce31a356fb9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0UHoTReEwEv3Vmgbx76FQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">我们的服务绑定到3个pod</figcaption></figure><h2 id="4227" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">旁白:部署与服务</h2><p id="fc03" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">如果您熟悉这些(Kubernetes)概念，请随意跳过。</p><p id="aae6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署(大于但是)类似于自动缩放器。部署部分负责确保预定数量的pod正在运行。如果您删除了一个Pod，部署将为它创建一个替代品。如果您重新调整部署，将会创建或销毁正确数量的单元。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="bf31" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods --selector=run=kuard<br/>NAME                    READY     STATUS    RESTARTS   AGE<br/>kuard-b75468d67-kmbt5   1/1       Running   0          6m<br/><strong class="kx hj">kuard-b75468d67-lnl4v</strong>   1/1       Running   0          6m<br/>kuard-b75468d67-s5m86   1/1       Running   0          6m</span><span id="5d9c" class="ju jv hi kx b fi lk lh l li lj">kubectl delete pod/<strong class="kx hj">kuard-b75468d67-lnl4v</strong><br/>pod "kuard-b75468d67-lnl4v" deleted</span><span id="f2cf" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods --selector=run=kuard<br/>NAME                    READY     STATUS    RESTARTS   AGE<br/>kuard-b75468d67-kmbt5   1/1       Running   0          13m<br/>kuard-b75468d67-s5m86   1/1       Running   0          13m<br/>kuard-b75468d67-vmqc7   1/1       Running   0          20s</span></pre><p id="cdbf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务(大于但是)类似于负载平衡器。服务将流量路由到一组Pod中最合适的Pod。服务与部署是正交的。服务绑定到pod，而不是部署。服务如何绑定到pod？你能猜到吗？通过标签选择豆荚。这有什么意想不到但令人敬畏的后果？任何标签与服务选择器匹配的Pod都将被服务捕获:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="bbe8" class="ju jv hi kx b fi lg lh l li lj">kubectl run kuard-2  \<br/>--image=gcr.io/kuar-demo/kuard-amd64:1 \<br/>--replicas=1</span></pre><p id="3b8e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建一个新的部署(称为<code class="du ku kv kw kx b">kuard-2</code>)来管理(当前)一个<code class="du ku kv kw kx b">kuard</code> Pod。这个舱会有一个标签<code class="du ku kv kw kx b">run=kuard<strong class="iz hj">-2</strong></code>。让我们改变这个吊舱的<code class="du ku kv kw kx b">run</code>标签，使其成为<code class="du ku kv kw kx b">kuard</code>。你能猜出结果吗？</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="dc4a" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods<br/>NAME                       READY     STATUS    RESTARTS   AGE<br/>kuard-2-6c8ddd8fb5-qwlk8   1/1       Running   0          8s<br/>kuard-b75468d67-kmbt5      1/1       Running   0          16m<br/>kuard-b75468d67-s5m86      1/1       Running   0          16m<br/>kuard-b75468d67-vmqc7      1/1       Running   0          3m</span><span id="659b" class="ju jv hi kx b fi lk lh l li lj">kubectl get deployments<br/>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>kuard     3         3         3            3           16m<br/>kuard-2   1         1         1            1           14s</span><span id="a5ca" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods <strong class="kx hj">--selector=run=kuard</strong><br/>NAME                    READY     STATUS    RESTARTS   AGE<br/>kuard-b75468d67-kmbt5   1/1       Running   0          17m<br/>kuard-b75468d67-s5m86   1/1       Running   0          17m<br/>kuard-b75468d67-vmqc7   1/1       Running   0          3m</span><span id="457c" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods <strong class="kx hj">--selector=run=kuard-2</strong><br/>NAME                       READY     STATUS    RESTARTS   AGE<br/>kuard-2-6c8ddd8fb5-qwlk8   1/1       Running   0          30s</span><span id="6d03" class="ju jv hi kx b fi lk lh l li lj">kubectl label --overwrite pod/kuard-2-6c8ddd8fb5-qwlk8 run=kuard<br/>pod/kuard-2-6c8ddd8fb5-qwlk8 labeled</span><span id="e707" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods <strong class="kx hj">--selector=run=kuard</strong><br/>NAME                       READY     STATUS    RESTARTS   AGE<br/>kuard-2-6c8ddd8fb5-qwlk8   1/1       Running   0          1m<br/>kuard-b75468d67-kmbt5      1/1       Running   0          18m<br/>kuard-b75468d67-s5m86      1/1       Running   0          18m<br/>kuard-b75468d67-vmqc7      1/1       Running   0          4m</span></pre><p id="ac36" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如所料，我们有4个Pods个来自我们的初始部署，1个来自第二次部署)。然而，这4个pod中只有3个具有值为<code class="du ku kv kw kx b">kuard</code>的<code class="du ku kv kw kx b">run</code>标签。第二次展开的吊舱在展开后贴上标签，并有一个值为<code class="du ku kv kw kx b">kuard-2</code>的<code class="du ku kv kw kx b">run</code>标签。我们将它的<code class="du ku kv kw kx b">run</code>标签值也改写为<code class="du ku kv kw kx b">kuard</code>。然后，当我们查询值为<code class="du ku kv kw kx b">kuard</code>的<code class="du ku kv kw kx b">run</code>标签时，我们返回4个pod。但是(！)我们的服务现在也绑定到4个pod。它选择豆荚不是基于它有多爱它们，而是基于它们标签的价值:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mh"><img src="../Images/9aee8cdbd04ab758adb011fa4218342e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCa8SceilWvr347669uWhA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">该服务现在绑定到所有4个pod</figcaption></figure><p id="5c91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重要的是要理解Kubernetes资源可能有多个标签，也可以跨多个标签选择作品。这是Kubernetes中最强大的功能之一。</p><h2 id="f2db" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">旁白:负载平衡器和负载平衡器</h2><p id="ec74" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">当我们创建一个— type=LoadBalancer的服务时，我们创建了一个负载平衡器，一个网络(或TCP)负载平衡器。我们没有创建HTTP/S负载平衡器。这是服务的一个无意中令人困惑的方面。为了创建一个HTTP/S负载均衡器，我们通常会定义一个Kubernetes入口。我们以后可能会这样做。</p><p id="e98e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes引擎请求时的网络负载平衡器(仅限GCP！)产生了谷歌云平台(计算引擎)负载平衡器:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mi"><img src="../Images/0b24d57eeff3bce74c2d0e51d00d291d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtniFjb_hXBzYzznsxUevQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">Kubernetes提供了一个网络负载平衡器(LB)</figcaption></figure><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mj"><img src="../Images/6a8f9575c45879dec3d9bd18f5f5fb56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFcY9TD6TbLci234ouUdZg.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">LBs 3实例对应于集群的3个节点</figcaption></figure><p id="6291" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，我可以从这个负载均衡器提供给我的公共IP地址浏览<code class="du ku kv kw kx b">kuard</code>服务。因为它…你知道…负载平衡，如果我点击刷新，我可能会得到不同的荚(！)每次都有回应。</p><h2 id="a8d5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">表明</h2><p id="8b0a" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我之前提到过，像我一直做的那样，通过发出<code class="du ku kv kw kx b">kubectl</code>命令对集群进行更改被认为是不好的做法。一个很大的原因是，我很难重现我们刚刚做过的事情。例如，这样做的结果是，我很难将它从我们的测试环境转移到生产环境中。另一个原因是命令行公开了Kubernetes API的一部分功能。</p><p id="e6bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更好的做法是使用Kubernetes清单文件。这些配置文件描述了您对Kubernetes的意图。它们可能是用YAML或JSON编写的。如果有工具可以方便我们创建和管理这些清单文件，那就太好了。有人试图减轻痛苦(见Jsonnet，Helm等)。).但是，我们今天大部分时间都被YAML所困。</p><p id="3f2f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们创建了2个部署、1个服务和4个pod，所以我们能够让集群为我们提供等效的YAML清单来表示(重新创建)这些资源。这是一个有用的引导工具。你可以尝试<code class="du ku kv kw kx b">kubectl</code>命令，然后用它们创建YAML文件。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="a45b" class="ju jv hi kx b fi lg lh l li lj">kubectl get deployment/kuard --output=yaml</span></pre><p id="2ded" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">产量(为清晰起见进行了编辑):</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="efca" class="ju jv hi kx b fi lg lh l li lj">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    run: kuard<br/>  name: kuard<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      run: kuard<br/>  template:<br/>    metadata:<br/>      labels:<br/>        run: kuard<br/>    spec:<br/>      containers:<br/>      - image: gcr.io/kuar-demo/kuard-amd64:1<br/>        imagePullPolicy: IfNotPresent<br/>        name: kuard</span></pre><p id="5d4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是由Kubernetes <code class="du ku kv kw kx b">extensions/v1beta</code> API提供的部署资源(<code class="du ku kv kw kx b">kind</code>)。实际上，这已经过时了，部署已经升级到<code class="du ku kv kw kx b">apps/v1</code>。部署有标签。嗯，一个名为<code class="du ku kv kw kx b">run</code>的标签，值为<code class="du ku kv kw kx b">kuard</code>。部署总是描述pod(尽管这不是显式的)。将有3个pod，部署将选择标签名为<code class="du ku kv kw kx b">run</code>且值为<code class="du ku kv kw kx b">kuard</code>的任何pod。Pod模板定义了Pod的标签(是的，我们再次定义了标签)以及包含Pod及其配置的图像。</p><p id="e494" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>我没有在这里展示，但是pod包括一个<strong class="iz hj">或多个</strong>容器。“或更多”用例比您想象的要常见得多。它通常与所谓的边卡模式一起使用，在这种模式下，集装箱的功能由其边车提供的功能来补充。通常边车的功能包括代理流量，记录和监控。</p><p id="3596" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们以这种方式从集群中YAML时，配置包括特定于运行实例的运行时细节。为了概括配置，我们需要削减这些信息。我在上面包含的编辑版本包含了部署的最少细节。</p><p id="0293" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了证明这一点，将上面的部署清单保存为一个文件，<code class="du ku kv kw kx b">deployment.yaml</code>。然后删除现有的<code class="du ku kv kw kx b">kuard</code>部署并重新创建它:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="d097" class="ju jv hi kx b fi lg lh l li lj">kubectl delete deployment/kuard<br/>kubectl apply --filename=deployment.yaml</span></pre><p id="b81d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多。我们忘记了服务</p><p id="e791" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们没有。服务受到上述变更的影响，但并未因此而中断。当我们删除部署时，我们删除了pod。当我们删除pod时，服务将不再找到4个与其选择器标准匹配的pod。它应该和我们第二次部署的1号分离舱匹配。当我们创建新的<code class="du ku kv kw kx b">kuard</code>部署时，它会为我们创建3个标签与服务相匹配的新pod。</p><p id="d874" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以…..一切正常，我们的服务应该仍然有4个吊舱，其中一个将是来自第二次部署的吊舱(命名:<code class="du ku kv kw kx b">kuard-2–6c8ddd8fb5-qwlk8</code>)，并且将有3个新吊舱:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div class="er es mk"><img src="../Images/87b3d2a26032ea1c0074a9e458556dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*P91qmryN_POPzzF-4xC10Q.png"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">标签的魔力</figcaption></figure><p id="abca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的服务将继续可用(因为总是有≥1个Pod支持它)，但单个Pod可能无法支持我们服务的所有流量。</p><p id="3f3f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，您不能通过删除部署来部署对Kubernetes的更改。您可以通过修订部署清单并将清单重新应用到群集来部署更改。当您这样做时，Kubernetes将至少维护最小数量的pod，并在删除旧版本的Pod之前部署新版本的Pod。还有其他方法可以指示Kubernetes提供这样的滚动更新，但结果是您的服务仍然可用。那很容易！</p><h2 id="e6f0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">守护集、状态集和作业</h2><p id="449a" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">老实说，我只在实践中使用过Jobs，我在教程中使用过一次StatefulSets，这将是我的第一个DaemonSet。</p><p id="56b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我说你应该总是默认部署。你应该。更准确的说法是，您应该默认使用其中一个控制器。我们应该不再使用的一种控制器是复制控制器；该控制器被复制集取代，部署为您创建复制集。</p><p id="831c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不想重写优秀的Kubernetes文档。所以，请去那里阅读所有关于控制器<a class="ae jt" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="2cf6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个控制器执行特定的功能:DaemonSets在每个节点上运行您的Pod作业运行pod直到完成(然后终止)；状态集为您的pod维护“粘性”身份。StatefulSets的关键区别在于名称，它们帮助Kubernetes(否则通常是关于群体而不是个人)，或者用一个经常引用的比喻来说，帮助管理“宠物”(你把你的pod当作个体，你给它们命名)和“牛”(你想把它们当作一个群体/牛群)。</p><p id="93ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们将<code class="du ku kv kw kx b">kuard</code>部署转换成DaemonSet:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="d428" class="ju jv hi kx b fi lg lh l li lj">apiVersion: apps/v1<br/>kind: <strong class="kx hj">DaemonSet</strong><br/>metadata:<br/>  labels:<br/>    run: kuard<br/>  name: kuard<br/>spec:<br/>  <strong class="kx hj">#replicas: 3</strong><br/>  selector:<br/>    matchLabels:<br/>      run: kuard<strong class="kx hj">d</strong><br/>  template:<br/>    metadata:<br/>      labels:<br/>        run: kuard<strong class="kx hj">d</strong><br/>    spec:<br/>      containers:<br/>      - image: gcr.io/kuar-demo/kuard-amd64:1<br/>        imagePullPolicy: IfNotPresent<br/>        name: kuard</span></pre><p id="2d80" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要将<code class="du ku kv kw kx b">kind</code>修改为<code class="du ku kv kw kx b">DaemonSet</code>。记住DaemonSets是独特的，因为它们在每个节点上运行我们的Pod，我们需要(并且必须)不提供副本的数量。您可以删除<code class="du ku kv kw kx b">replicas: 3</code>行。让我们也为Pod的(！idspnonenote)使用不同的值。)<code class="du ku kv kw kx b">run</code>标签。我们希望将DaemonSet管理的pod与Deployment管理的pod区分开来，以便它们不会被现有服务捕获。惯例是用以“-d”结尾的名字来命名守护进程，所以让我们只使用<code class="du ku kv kw kx b">kuardd</code>。就是不要试着发音！</p><blockquote class="ll lm ln"><p id="3b0e" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong> Kubernetes资源只需要在资源的名称空间上是唯一的。因为这是一个DaemonSet，所以将其命名为<code class="du ku kv kw kx b">kuard</code>与我们给部署命名的方式没有冲突。</p></blockquote><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ls"><img src="../Images/0a67c680c51f876d6bb29bea6b65c676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2R87-_M-dFlhJPO7N1JhjQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">3个“工作负载”,包括部署和一个守护集</figcaption></figure><p id="ef70" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与部署一样，我们可以在由DaemonSet管理的pod前面加入一个服务(facade ),但是服务将pod视为牛，我们的守护进程是唯一的(不是有状态的，而是唯一的),因为它们与集群的节点1:1相关。因为它们与集群的节点1:1相关，所以我们可以在守护进程的上下文中使用节点的独特功能，例如主机的IP和主机的一个端口(参见<code class="du ku kv kw kx b"><a class="ae jt" href="https://kubernetes.io/docs/concepts/configuration/overview/" rel="noopener ugc nofollow" target="_blank">hostPort</a></code>)。不使用<code class="du ku kv kw kx b">hostPort</code>，使用<code class="du ku kv kw kx b">NodePorts</code>可能更好，但是<code class="du ku kv kw kx b">NodePorts</code>要求为DaemonSet的pod创建一个服务。</p><h2 id="8570" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">万圣节:无头服务和恶魔集</h2><p id="a6d9" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">一个常规的Kubernetes服务是为“牛”服务的，我们关心这个群体，希望把这个群体作为一个单一的实体来对待。Kubernetes服务有一个DNS名称和一个虚拟IP (VIP)地址。无头服务是给“宠物”的，我们关心的是个体。该服务有一个DNS名称，但这会为它的每个pod产生一组IP。</p><p id="02e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们称为<code class="du ku kv kw kx b">uard</code>的无头服务的YAML(明白吗？；-)):</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="57af" class="ju jv hi kx b fi lg lh l li lj">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    run: kuard<br/>  name: uard<br/>spec:<br/>  clusterIP: None<br/>  ports:<br/>  - port: 8080<br/>    protocol: TCP<br/>    targetPort: 8080<br/>  selector:<br/>    run: kuardd</span></pre><p id="9c4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，它选择我们的DaemonSet创建的pod，这些pod的标签值为<code class="du ku kv kw kx b">kuardd</code>。应用文件后:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ma"><img src="../Images/b93434b291a51d96ea48c3df05f68af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rE2LntB5DrVwi8c64q4O4A.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">不应该是‘无头服务’吗？</figcaption></figure><p id="ddc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:在应用了<code class="du ku kv kw kx b">uard</code>无头服务之后，我们现在有两个服务了。<code class="du ku kv kw kx b">uard</code>属于<code class="du ku kv kw kx b">Cluster IP</code>类型，它没有IP端点。我们仍然可以使用值为kuard的运行标签来查询两个服务(因为我们对服务使用了相同的标签):</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="84a0" class="ju jv hi kx b fi lg lh l li lj">kubectl get services <strong class="kx hj">--selector=run=kuard</strong><br/>NAME      TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)<br/>kuard     LoadBalancer   10.7.255.247   35.230.1.145   8080:30741<br/>uard      ClusterIP      None           &lt;none&gt;         8080</span></pre><p id="bb5b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果我们使用(我今天才发现这个资源！)<code class="du ku kv kw kx b">endpoints</code>资源:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="4d9d" class="ju jv hi kx b fi lg lh l li lj">kubectl get endpoints --selector=run=kuard<br/>NAME      ENDPOINTS                                      AGE<br/>kuard     10.4.0.13:8080,10.4.1.14:8080,10.4.2.12:8080   2h<br/>uard      10.4.0.14:8080,10.4.1.15:8080,10.4.2.13:8080   4m</span></pre><p id="8050" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到一些有趣的事情，Kubernetes定期重新计算哪些服务选择了哪些pod，并使用IPs填充这个端点资源。这些IP对应于Pods的IP，你会注意到它们如我们所料发布了端口<code class="du ku kv kw kx b">8080</code>。</p><p id="b769" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了与集群内DNS服务交互，我们需要进入集群，下面的<code class="du ku kv kw kx b">kubectl</code>命令运行一个<code class="du ku kv kw kx b">busyboxplus</code>容器，该容器除了<code class="du ku kv kw kx b">nslookup</code>之外，还包括<code class="du ku kv kw kx b">curl</code>命令(而<code class="du ku kv kw kx b">busybox</code>没有):</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="8a15" class="ju jv hi kx b fi lg lh l li lj">kubectl run debug \<br/>--image=radial/busyboxplus:curl \<br/>--stdin \<br/>--tty<br/>If you don't see a command prompt, try pressing enter.<br/>[ root@debug-85f447cc59-fsq9l:/ ]$</span></pre><p id="fab5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太好了！让我们查找<code class="du ku kv kw kx b">kuard</code>和<code class="du ku kv kw kx b">uard</code>服务:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="d4d5" class="ju jv hi kx b fi lg lh l li lj">nslookup kuard.default.svc.cluster.local<br/>Server:    10.7.240.10<br/>Address 1: 10.7.240.10 kube-dns.kube-system.svc.cluster.local</span><span id="c438" class="ju jv hi kx b fi lk lh l li lj">Name:      kuard.default.svc.cluster.local<br/>Address 1: 10.7.255.247 kuard.default.svc.cluster.local</span><span id="535a" class="ju jv hi kx b fi lk lh l li lj">nslookup uard.default.svc.cluster.local<br/>Server:    10.7.240.10<br/>Address 1: 10.7.240.10 kube-dns.kube-system.svc.cluster.local</span><span id="dd84" class="ju jv hi kx b fi lk lh l li lj">Name:      uard.default.svc.cluster.local<br/>Address 1: 10.4.0.14<br/>Address 2: 10.4.1.15<br/>Address 3: 10.4.2.13</span></pre><p id="3243" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看出区别。我们的常规服务<code class="du ku kv kw kx b">kuard</code>有一个DNS名称(<code class="du ku kv kw kx b">kuard.default.svc.cluster.local</code>)，这解析为一个VIP ( <code class="du ku kv kw kx b">10.7.240.10</code>)，VIP本身形成了一个DNS名称！</p><p id="9de0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无头服务<code class="du ku kv kw kx b">uard</code>有一个DNS名称(<code class="du ku kv kw kx b">uard.default.svc.cluster.local</code>)，但是它解析为4个IP地址，每个IP地址对应一个(DaemonSet创建的)pod。我们现在有了一种方法，可以在一个已知的端口上单独访问我们的每个守护进程。如果我们想要访问这些集群外的服务，我们只需要在服务定义中添加一个<code class="du ku kv kw kx b">HostPort</code>或<code class="du ku kv kw kx b">NodePort</code>。</p><h2 id="7ff3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><a class="ae jt" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">状态集</a></h2><p id="4475" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">好吧，让我们从清单开始:</p><figure class="ky kz la lb fd lt"><div class="bz dy l di"><div class="ml mm l"/></div></figure><p id="ab95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个文件合并了2个清单！我只见过Kubernetes开发者使用这个，但这是YAML的一个特色。你的编辑可能会抱怨！有时你会看到<code class="du ku kv kw kx b"> — —</code> (3个破折号)用于分隔YAML文件，尽管形式上，三个句点应该结束(<code class="du ku kv kw kx b">…</code>)，三个破折号应该开始(<code class="du ku kv kw kx b">— -</code>)。</p><p id="046d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">状态集需要(并引用)一个服务。其他类型的控制器不需要维修。StatefulSets使用该服务作为一种方式来为豆荚域名。这里使用的服务类似于我们用于DaemonSet的Headless服务。这个服务被称为<code class="du ku kv kw kx b">skuard</code> (Stateful Kuard，在我内心的声音中，我把它发音为“skewered”)，在StatefulSet maninfest中，我也使用<code class="du ku kv kw kx b">skuard</code>作为<code class="du ku kv kw kx b">run</code>标签的值。因此，服务也必须选择<code class="du ku kv kw kx b">skuard</code>。</p><p id="398e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们必须告诉群集我们需要多少个副本，所以这又回来了。我们必须告诉集群哪个服务描述了域名(<code class="du ku kv kw kx b">serviceName</code>)。除此之外，StatefulSet与其他的非常相似。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="978e" class="ju jv hi kx b fi lg lh l li lj">kubectl apply --filename=statefulset.yaml<br/>service/skuard created<br/>statefulset.apps/kuard created</span></pre><p id="2d55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了完整起见:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mn"><img src="../Images/3f904cc3bac752eca0aeb4d9ba80ab5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGVQK11f4xm6grPVZ9alkA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">三个朋友:kuard，skuard和uard</figcaption></figure><p id="8f99" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我没有公正地评价本例中StatefulSets的值，但是，如果我们列举集群中的pod:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div class="er es mo"><img src="../Images/94c26355da2afc4efd888a49384b0df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*_jVxlWlbouWJs_zfGQx31g.png"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">陈述集合“宠物”</figcaption></figure><p id="9ce0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你会看到每个豆荚是由一个计数器区分的。</p><p id="335b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们打掉一个，它会被重新创建:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="678b" class="ju jv hi kx b fi lg lh l li lj">kubectl get pods <strong class="kx hj">--selector=run=skuard</strong><br/>NAME                       READY     STATUS             RESTARTS<br/>kuard-0                    1/1       Running            0<br/>kuard-1                    1/1       Running            0<br/><strong class="kx hj">kuard-2</strong>                    1/1       Running            0</span><span id="1ac4" class="ju jv hi kx b fi lk lh l li lj">kubectl delete pod <strong class="kx hj">kuard-2</strong><br/>pod "kuard-2" deleted</span><span id="30d9" class="ju jv hi kx b fi lk lh l li lj">kubectl get pods <strong class="kx hj">--selector=run=skuard</strong><br/>NAME                       READY     STATUS              RESTARTS<br/>kuard-0                    1/1       Running             0<br/>kuard-1                    1/1       Running             0<br/><strong class="kx hj">kuard-2</strong>                    0/1       ContainerCreating   0</span></pre><p id="ebd5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果它使用某种形式的持久存储，它将被反弹到相同的存储。</p><p id="1285" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与其他pod不同，StatefulSets的pod有DNS名称。让我们回到busyboxplus容器:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="59dc" class="ju jv hi kx b fi lg lh l li lj">nslookup <strong class="kx hj">kuard-0</strong>.skuard<br/>Server:    10.7.240.10<br/>Address 1: 10.7.240.10 kube-dns.kube-system.svc.cluster.local</span><span id="78d4" class="ju jv hi kx b fi lk lh l li lj">Name:      kuard-0.skuard<br/>Address 1: 10.4.2.15 kuard-0.skuard.default.svc.cluster.local</span><span id="509d" class="ju jv hi kx b fi lk lh l li lj">nslookup <strong class="kx hj">kuard-1</strong>.skuard<br/>Server:    10.7.240.10<br/>Address 1: 10.7.240.10 kube-dns.kube-system.svc.cluster.local</span><span id="80eb" class="ju jv hi kx b fi lk lh l li lj">Name:      kuard-1.skuard<br/>Address 1: 10.4.1.16 kuard-1.skuard.default.svc.cluster.local</span><span id="a113" class="ju jv hi kx b fi lk lh l li lj">nslookup <strong class="kx hj">kuard-2</strong>.skuard<br/>Server:    10.7.240.10<br/>Address 1: 10.7.240.10 kube-dns.kube-system.svc.cluster.local</span><span id="5c3f" class="ju jv hi kx b fi lk lh l li lj">Name:      kuard-2.skuard<br/>Address 1: 10.4.0.16 kuard-2.skuard.default.svc.cluster.local</span></pre><p id="c1d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用了一个短名称<code class="du ku kv kw kx b">[StatefulSet]-[Counter].[Service]</code>进行欺骗，但是完全限定的名称也在那里(你可以在DNS服务器的回复中看到这些，例如<code class="du ku kv kw kx b">kuard-2.skuard.default.svc.cluster.local</code>)。</p><p id="b5ac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与服务DNS名称一样，这些Pod DNS名称是可预测的。这是有用的。例如，依赖于有状态服务的集群上的另一个部署可以总是寻找该服务的分片实例，可能是<code class="du ku kv kw kx b">kuard-2</code>并通过其DNS名称访问它。</p><h2 id="b5a0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论:Kubernetes</h2><p id="7787" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">希望这个例子能让你在一个小时内从零开始。Kubernetes可能令人生畏，但是一旦你开始使用它，你可以根据需要学习高级的东西，你需要的80%需要花10%的时间来学习。祝你好运！</p><h2 id="0c11" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">托管实例组(MIG)</h2><p id="9802" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">Google Kubernetes工程团队每次在我关于Kubernetes的故事中看到这个副标题时一定会抱怨，但是，我没有讨论提供不同功能但可能适用于不同情况的替代解决方案，这会对您、Google和Kubernetes造成伤害。</p><p id="6d6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想要创建x-百个容器的基本功能，那么<a class="ae jt" href="https://cloud.google.com/compute/docs/instance-groups/#managed_instance_groups" rel="noopener ugc nofollow" target="_blank">托管实例组</a>和<a class="ae jt" href="https://cloud.google.com/container-optimized-os/" rel="noopener ugc nofollow" target="_blank">容器优化操作系统</a>(也是支持Kubernetes引擎节点的默认操作系统)可能正合适。</p><p id="396e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在四月份写了关于<a class="ae jt" rel="noopener" href="/google-cloud/container-optimized-os-d32ea15c9ef4">容器优化操作系统</a>的文章，下面将主要是这个故事的总结。</p><p id="eb0e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您是从零开始，请创建项目并像Kubernetes设置那样分配账单。这一次，您可以仅启用计算引擎，而不是计算和Kubernetes引擎:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="a628" class="ju jv hi kx b fi lg lh l li lj">gcloud services enable compute.googleapis.com --project=${PROJECT}</span></pre><p id="01c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下命令将为我们将要创建的每个克隆创建模板:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="401e" class="ju jv hi kx b fi lg lh l li lj">PROJECT=[[YOUR-PROJECT]]<br/>TEMPLATE=[[YOUR-TEMPLATE]] # Perhaps 'kuard'<br/>REGION=[[YOUR-REGION]]</span><span id="b8a5" class="ju jv hi kx b fi lk lh l li lj">gcloud beta compute instance-templates create-with-container ${TEMPLATE} \<br/>--machine-type=custom-1-4096 \<br/>--image-family=cos-stable \<br/>--image-project=cos-cloud \<br/>--container-image=gcr.io/kuar-demo/kuard-amd64:1 \<br/>--container-restart-policy=always \<br/>--preemptible \<br/>--region=${REGION} \<br/>--project=${PROJECT}</span></pre><blockquote class="ll lm ln"><p id="41cd" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>我又在使用可抢占实例了。我使用比Kubernetes更小的机器类型(1个CPU和4GB RAM)。这种方法不能打包容器:每个VM一个容器。</p></blockquote><p id="0ec9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果是:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="b656" class="ju jv hi kx b fi lg lh l li lj">Created.<br/>NAME   MACHINE_TYPE               PREEMPTIBLE  CREATION_TIMESTAMP<br/>kuard  custom (1 vCPU, 4.00 GiB)  true         2018-08-14T14:37:57</span></pre><p id="0a69" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以使用以下方法创建一个包含N个克隆的托管实例组:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="8fd8" class="ju jv hi kx b fi lg lh l li lj">CLONES=[[HOWEVER-MANY-YOUD-LIKE]]</span><span id="bae5" class="ju jv hi kx b fi lk lh l li lj">gcloud compute instance-groups managed create ${TEMPLATE} \<br/>--base-instance-name=${TEMPLATE} \<br/>--template=${TEMPLATE} \<br/>--size=${CLONES} \<br/>--region=${REGION} \<br/>--project=${PROJECT}</span></pre><p id="a7c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，为了确保我没有超出我的项目配额，我创建了3个克隆:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mp"><img src="../Images/707db97658a8249998989f5b7dfec717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezSDvdW7V6xlVNsUTHe6kw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">托管实例组</figcaption></figure><p id="328f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">托管实例组提供自动伸缩(在这种情况下，我没有自动伸缩)，因此这对应于我们的Kubernetes部署。Kubernetes服务的模拟是一个负载平衡器。这一次，我们将手动创建网络(或TCP)负载平衡器(因为我们没有Kubernetes来帮助我们),但这很简单，只是指向托管实例组:</p><figure class="ky kz la lb fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mq"><img src="../Images/1234533ee797dd874b84074ba1acfb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cg23NvtbP6NTsJ4LuNzNHA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">为MIG手动创建网络负载平衡器</figcaption></figure><h2 id="42ea" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论-结论</h2><p id="6934" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">希望这篇文章能帮助你更好地理解或者——更好的是——让你继续使用Kubernetes。在介绍了集群之后，我们浏览了控制器和构建部署、DaemonSets和StatefulSets。为什么这些不同的控制器存在，为什么你可能希望选择每一个。</p><p id="0f20" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，为了完整起见，我们将Kubernetes从项目中剥离出来，使用一些底层结构来构建更简单的东西——尽管是可扩展的东西——使用容器优化的操作系统、托管实例组和网络负载平衡器。</p><p id="b99f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">坦白地说，我很懒，直接使用HTTP负载平衡器而不是网络负载平衡器。而且，使用一点LetsEncrypt，添加TLS很容易。</p><h2 id="0077" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">拆毁</h2><p id="e62a" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">如果您愿意不可撤销地删除所有内容，您可以:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="7719" class="ju jv hi kx b fi lg lh l li lj">gcloud projects delete ${PROJECT}</span></pre><p id="a945" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您只想删除Kubernetes集群，您可以:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="2355" class="ju jv hi kx b fi lg lh l li lj">gcloud container clusters delete ${CLUSTER} \<br/>--project=${PROJECT}\<br/>--region=${REGION}</span></pre><blockquote class="ll lm ln"><p id="f063" class="ix iy lo iz b ja jb ij jc jd je im jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated"><strong class="iz hj">注意</strong>如果你攻击集群，它已经提供了负载均衡器，这些可能不会自动删除，你应该手动删除它们。</p></blockquote><p id="c875" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您希望删除特定的Kubernetes资源，您可以:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="2676" class="ju jv hi kx b fi lg lh l li lj">kubectl delete deployment/kuard</span></pre><p id="bd19" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想删除MIG，那么模板:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="e6c5" class="ju jv hi kx b fi lg lh l li lj">gcloud compute instance-groups managed delete kuard \<br/>--region=${REGION} \<br/>--project=$PROJECT</span><span id="92db" class="ju jv hi kx b fi lk lh l li lj">gcloud compute instance-templates delete kuard \<br/>--project=$PROJECT</span></pre><p id="c756" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！</p></div></div>    
</body>
</html>