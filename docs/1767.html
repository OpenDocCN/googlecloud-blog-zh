<html>
<head>
<title>GCLB, App Engine Cron and Cloud Scheduler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCLB、应用引擎Cron和云调度器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/gclb-app-engine-cron-and-cloud-scheduler-1df59a7963f?source=collection_archive---------0-----------------------#2021-01-21">https://medium.com/google-cloud/gclb-app-engine-cron-and-cloud-scheduler-1df59a7963f?source=collection_archive---------0-----------------------#2021-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/4d0a677b15917b99f3e23a666c51a036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etsxcgkSb9LrJs5YyKf84w.png"/></div></div></figure><div class=""/><p id="d12a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="jo"> TLDR:应用引擎Cron无法使用全局负载平衡器的建议入口设置！我们可以使用云调度程序实现类似的安全行为吗？</em>T3】</strong></p><p id="b55d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最近和一个客户一起工作，他正在创建一个新的web应用程序。该客户需要快速移动，并且想要一个具有高可扩展性和内置服务的无服务器解决方案。AppEngine standard正好符合这个要求。客户之前已经使用过Java 8 <a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/runtimes" rel="noopener ugc nofollow" target="_blank">第一代应用引擎运行时</a>，所以他们决定继续使用。</p><p id="063d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">App Engine已经存在很长时间了，但它仍然是许多应用程序的热门选择，并且还在继续发展和改进。去年年中推出的一项显著改进是集成了全局HTTP(S)负载平衡和应用程序引擎。这种集成使App Engine(以及其他无服务器选项，如Cloud Run和Cloud Functions)能够利用全球负载平衡器功能，如anycast IP、Cloud CDN、Cloud Armor、统一证书管理等。阅读<a class="ae jp" href="https://cloud.google.com/blog/products/networking/better-load-balancing-for-app-engine-cloud-run-and-functions" rel="noopener ugc nofollow" target="_blank">博客文章</a>了解更多背景知识，然后查看<a class="ae jp" href="https://cloud.google.com/load-balancing/docs/negs/serverless-neg-concepts" rel="noopener ugc nofollow" target="_blank">无服务器NEG </a>文档了解所有技术细节。</p><p id="2d97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">客户的需求和实现非常标准。他们使用App Engine提供网页，使用Cloud Firestore存储数据，并使用内置的<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/java/config/cron-yaml" rel="noopener ugc nofollow" target="_blank"> App Engine Cron服务</a>运行计划的作业。该客户还希望使用云CDN和全球HTTPS负载平衡器提供的其他功能，因此他们开始着手进行设置…</p><h2 id="4abc" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">应用程序引擎入口控制</h2><p id="0be7" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">默认情况下，App Engine应用程序<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/java/how-requests-are-routed" rel="noopener ugc nofollow" target="_blank">在一个URL上以<em class="jo">的形式【https://$ PROJECT _ id . appspot . com</em>为请求</a>提供服务。当您创建App Engine应用程序时，会自动分配此URL。然而，当你使用全局负载均衡器时，建议<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/java/application-security#ingress_controls" rel="noopener ugc nofollow" target="_blank">禁用这个appspot url，这样所有的用户流量都会通过负载均衡器。否则，用户可以使用appspot URL绕过负载平衡器，包括负载平衡器中配置的任何访问控制(Cloud Armor，IAP)。</a></p><p id="f2ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以使用App Engine的网络<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/java/application-security#ingress_controls" rel="noopener ugc nofollow" target="_blank">入口控件</a>来限制流量，以便您的应用程序只接收来自特定来源的HTTP请求。下面的命令更新默认的App Engine服务，以便它只接收通过负载平衡器路由的请求，或者从同一项目中的VPC网络发送的请求。这样，appspot URL就被有效地禁用了。太好了！</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="a2b2" class="jq jr ht kv b fi kz la l lb lc">gcloud app services update default --ingress internal-and-cloud-load-balancing</span></pre><h2 id="ee15" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">Cron作业失败！</h2><p id="5c17" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">客户设置了负载平衡器和云CDN，并应用了推荐的入口控制。该应用程序通过负载平衡器IP正确地处理请求，而不是通过appspot URL。一切都很好。然而，客户很快注意到他们的cron作业失败了！怎么回事？</p><p id="d9fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实证明，应用推荐的入口控制也会阻止来自App Engine Cron服务的请求。在某些方面，这是有意义的——入口控制只允许来自负载平衡器或VPC内部的请求。Cron服务不满足这些要求，因此被阻塞。然而，有人肯定会说，您不希望来自App Engine生态圈中其他服务的请求被阻止。此外，文件中没有提到这种限制，所以不清楚这是否是有意的行为。简而言之，这看起来像是应用引擎的错误，我们已经联系了应用引擎团队来强调这个问题。</p><h2 id="2d69" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">一些背景</h2><p id="63ff" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">如前所述，App Engine由来已久。第一代<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/runtimes" rel="noopener ugc nofollow" target="_blank">运行时</a>附带了很多捆绑特性，比如Memcache API、Images API、任务队列等等。这些特性中的许多都与App Engine紧密结合，并具有特定于App Engine的API。随着谷歌云的发展，这些功能已经从应用引擎中分离出来，成为独立的谷歌云服务。例如:</p><ul class=""><li id="fdd6" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated">任务队列应用引擎API →云任务</li><li id="4359" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">Memcache应用引擎API →云内存商店</li><li id="25ba" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">App Engine Cron服务→云调度器</li></ul><p id="935c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二代应用引擎运行时不支持这些旧的捆绑API。相反，建议使用独立的服务——就像从云功能或GKE集群中一样。第二代运行时代表了App Engine的未来方向。</p><p id="7889" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，第一代App Engine运行时将继续得到支持——因此这个<em class="jo">应该能够工作(或者至少被明确指定为不支持)。如前所述，我们强调了应用引擎团队，但同时我们需要解决它…</em></p><h2 id="9d8e" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">解决方法1:应用引擎本机防火墙</h2><p id="13ca" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">首先，我们尝试使用内置的<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/runtimes" rel="noopener ugc nofollow" target="_blank">应用引擎防火墙</a>来完成与入口控制相同的事情。这样，我们可以在不引入任何额外组件的情况下保持App Engine中的所有内容。因此，我们移除了应用引擎入口控制，并应用了以下防火墙规则:</p><figure class="kq kr ks kt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lr"><img src="../Images/3bfce2a1270c6d4aff28fec58a14e0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoJPHAunkBvxuyiUuH4Qpg.png"/></div></div></figure><ul class=""><li id="77be" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated">将默认规则设置为“拒绝”。只允许来自明确配置的IP地址/范围的请求。</li><li id="9390" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">为全局负载平衡器<a class="ae jp" href="https://cloud.google.com/load-balancing/docs/https#source_ip_addresses_for_client_packets" rel="noopener ugc nofollow" target="_blank"> IP范围</a>添加“允许”规则(就像您为常规VPC防火墙规则所做的那样)</li><li id="ea59" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">为应用引擎Cron服务的<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/java/config/cron-yaml#securing_urls_for_cron" rel="noopener ugc nofollow" target="_blank">源IP地址</a>添加“允许”规则</li></ul><p id="448a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据上面的规则，对appspot url的请求会被阻止，而来自Cron服务的请求会成功。但是，通过负载平衡器的请求会失败。不好。</p><p id="035d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(有趣的是，对负载平衡器的请求以403失败，这表明是应用引擎防火墙阻止了请求。因此，出于某种原因，允许标准负载平衡器IP范围是不够的。需要深入了解这一点，但继续前进…)</p><h2 id="4aef" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">解决方法2:作为应用引擎“管理员”用户的云调度程序</h2><p id="2afa" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">接下来，我们尝试使用云调度程序，而不是内置的应用引擎Cron服务。我们删除了防火墙规则，并重新应用了入口控制，以防止用户绕过负载平衡器。我们删除了应用引擎cron作业，并创建了相应的调度程序作业。我们配置了调度程序作业，通过负载平衡器IP向期望的端点发出HTTP请求。</p><figure class="kq kr ks kt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/00498ffd9f8bc824da7e98e6d4a3ce1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttGBpwDoaaA3Fxuku9BvNQ.png"/></div></div></figure><p id="0824" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">成功！appspot URL不可访问，用户通过负载均衡器的请求成功，并且我们通过云调度器有一个正常工作的cron作业。</p><p id="5aac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是,“crontest”端点可以在互联网上公开访问。任何人都可以向这个端点发出请求并触发我们的作业。我们如何保护它？</p><p id="9e07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">cron 文档的<a class="ae jp" href="https://cloud.google.com/appengine/docs/standard/java/config/cron-yaml#securing_urls_for_cron" rel="noopener ugc nofollow" target="_blank">安全URL描述了这个过程。本质上，您使端点只能由“管理员”用户访问。此设置拒绝来自外部用户的请求，但允许来自Cron服务和标记为“admin”的用户的请求。我们能让这种方法与调度程序一起工作吗？</a></p><p id="dd78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将所需的安全约束添加到web.xml文件中，只允许管理员用户访问crontest端点。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="83a7" class="jq jr ht kv b fi kz la l lb lc">&lt;security-constraint&gt;<br/>  &lt;web-resource-collection&gt;<br/>    &lt;web-resource-name&gt;crontest&lt;/web-resource-name&gt;<br/>    &lt;url-pattern&gt;/crontest&lt;/url-pattern&gt;<br/>  &lt;/web-resource-collection&gt;<br/>  &lt;auth-constraint&gt;<br/>    &lt;role-name&gt;admin&lt;/role-name&gt;<br/>  &lt;/auth-constraint&gt;<br/>&lt;/security-constraint&gt;</span></pre><p id="dc3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们创建了一个新的服务帐户，并授予它“应用引擎管理员”角色。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="7df5" class="jq jr ht kv b fi kz la l lb lc">gcloud iam service-accounts create scheduler-appengine</span><span id="11fe" class="jq jr ht kv b fi lt la l lb lc">gcloud projects add-iam-policy-binding $PROJECT_ID \<br/>  --role=roles/appengine.appAdmin \<br/>  --member=serviceAccount:<a class="ae jp" href="mailto:scheduler-appengine@jtg-gae-lb.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">scheduler-appengine@$PROJECT_ID.iam.gserviceaccount.com</a></span></pre><p id="d421" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们遵循云调度器文档为HTTP目标添加认证<a class="ae jp" href="https://cloud.google.com/scheduler/docs/http-target-auth" rel="noopener ugc nofollow" target="_blank">。这样，当调度程序作业执行时，它会为指定的服务帐户创建一个新的OIDC令牌，并将其添加到“Authorization”标头中的HTTP请求中。(请注意，您需要将作业类型设置为HTTPS，因此如果尚未为您的负载平衡器设置证书，您需要设置一个证书)。</a></p><figure class="kq kr ks kt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/125add53342cdcb2f37e6257d7fb3008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vuw1C8_1dtRksdFGBUB94A.png"/></div></div></figure><p id="37ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">成功了吗？<strong class="is hu">可惜</strong> <strong class="is hu">不是</strong>！应用程序引擎“admin”安全约束验证发出请求的用户是否注册为应用程序的管理员用户。但是，这与IAM权限是分开的。虽然调度程序作业确实具有正确的IAM权限，并且提供了有效的OIDC令牌，但这不满足应用程序引擎安全约束。令人沮丧！</p><h2 id="a713" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">解决方法3:自定义身份验证</h2><p id="23a2" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">我们能想到的最后一个选择是扩展以前的云调度程序方法，但是添加自定义逻辑来验证OIDC令牌和检查IAM权限。我们对此有点犹豫，但是Google Cloud提供了库和示例，所以我们决定尝试一下…</p><p id="dcd4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(注意，这种方法正是云运行和云函数所做的。它们有内置的逻辑来验证请求令牌并检查相关的“invoker”IAM权限。)</p><p id="e4fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们删除了“admin”安全约束。然后，我们在/crontest端点向servlet添加了定制逻辑。我们需要做两件事</p><ol class=""><li id="772e" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn lv lj lk ll bi translated">验证请求中的OIDC令牌</li><li id="ec5a" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn lv lj lk ll bi translated">验证经过身份验证的用户是否拥有正确的权限，即是否拥有应用程序引擎管理IAM角色</li></ol><p id="11f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jp" href="https://developers.google.com/identity/sign-in/web/backend-auth#verify-the-integrity-of-the-id-token" rel="noopener ugc nofollow" target="_blank">验证ID令牌的完整性</a>文档描述了验证OIDC令牌的过程，并包括一个代码示例。我们基本上是复制的。请参见下面的示例片段。<em class="jo">令牌</em>参数是来自HTTP请求的“Authorization”头的值。</p><figure class="kq kr ks kt fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="85a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ly lz ma kv b">GoogleIdTokenVerifier.verify()</code>方法验证JWT签名、<code class="du ly lz ma kv b">aud</code>声明、<code class="du ly lz ma kv b">iss</code>声明和<code class="du ly lz ma kv b">exp</code>声明。因此，如果该方法返回一个有效的负载，我们就知道请求来自一个经过正确身份验证的用户。</p><p id="1f74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们需要验证发出请求的用户是否拥有适当的IAM权限。<a class="ae jp" href="https://cloud.google.com/iam/docs/quickstart-client-libraries" rel="noopener ugc nofollow" target="_blank">资源管理器客户端库</a>的快速入门文档演示了如何检查IAM权限——同样，我们大量复制了它。参见下面的片段。</p><figure class="kq kr ks kt fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="d9e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而且… <strong class="is hu">管用</strong>！万岁！工作量相当大——这不是一个完美的解决方案，但肯定是一个有趣的练习。总结几点:</p><ul class=""><li id="6616" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll bi translated">上面的代码明确检查“roles/appengine.appAdmin”角色。呼叫者必须具有此角色。它不检查遗留角色，如所有者、编辑等。(当然你可以加上这个)</li><li id="9044" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll bi translated">如果想自己打/crontest端点，可以像下面这样做。同样，这假设您的gcloud用户拥有正确的角色</li></ul><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="ea0c" class="jq jr ht kv b fi kz la l lb lc">curl -H "Authorization: Bearer $(gcloud auth print-identity-token)" <a class="ae jp" href="https://testing.bagbert.com/authed" rel="noopener ugc nofollow" target="_blank">https://testing.mydomain.com/c</a>rontest</span></pre><h2 id="c7f3" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">结论</h2><p id="23e9" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">好吧，这变成了一个怪物帖子！如果你能走到这一步，恭喜你！这是一次教育练习，试图让一切都起作用。完全有可能我遗漏了一些本可以让事情变得简单得多的东西——如果是这样，请随意评论！</p><p id="d7ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我很快会发布一个带有完整端到端代码的回购链接。</p><p id="4d27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！:)</p></div></div>    
</body>
</html>