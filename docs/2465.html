<html>
<head>
<title>BigQuery: Basics &amp; Internals: Part # 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery:基础和内部:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/bigquery-basics-internals-part-2-7769f59d01e4?source=collection_archive---------1-----------------------#2022-10-31">https://medium.com/google-cloud/bigquery-basics-internals-part-2-7769f59d01e4?source=collection_archive---------1-----------------------#2022-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dff9ec4785b8dbf495c84e89c7cee0cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3-7A05tiZKTGG8o4ODC6Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">大查询(谷歌云平台)</figcaption></figure><h1 id="2c4f" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="bcc0" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在这一系列文章的第一篇文章中，我们已经看到了BigQuery的基础知识，以及它如何“适合”我们所有客户的谷歌云平台的数据分析和数据科学生态系统，它是一个在谷歌数据规模上具有分析和机器学习功能的数据仓库，可供我们所有的谷歌云平台客户使用！</p><p id="fa5b" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">在这篇博客文章中，我们将讨论并了解BigQuery的后端是如何设计存储的，特别是<a class="ae kq" href="https://cloud.google.com/blog/products/storage-data-transfer/a-peek-behind-colossus-googles-file-system" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj">巨像</strong> </a> <strong class="ju hj"> </strong>文件系统，它在内部是如何工作的，以及我们如何通过使用<strong class="ju hj">分区</strong>和<strong class="ju hj">集群</strong>的方法来充分利用存储，以及其他技巧！</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="5821" class="iu iv hi bd iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr bi translated">引擎盖下的储物！</h1><p id="252c" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在幕后，BigQuery使用Colossus来存储数据。然而在巨像的内部，它使用了电容器！让我们先了解一下传统数据库系统是如何处理数据存储的，从而理解电容器到底是什么。</p><p id="e00f" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">传统的关系数据库，如Postgres或MySQL，按照设计是逐行存储数据的(也称为面向记录的存储)。这使得它们对于在线事务性更新或OLTP用例来说非常高效！在谷歌云平台(GCP)上，我们利用云SQL(我们的托管数据库解决方案)进行大量的事务更新。总的来说，数据的组织如下所示:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es li"><img src="../Images/8a46c28d990e6b44f103a8a08ee2a010.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*pR7DG6Xsra8ZjL2VRYsFEQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">OLTP系统存储概念</figcaption></figure><p id="51cf" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">另一方面，BigQuery使用<strong class="ju hj">列</strong>存储，其中每一列都存储在驻留磁盘上的一个单独区域中。存储在磁盘上的数据块被亲切地称为<strong class="ju hj">电容器</strong>。简单来说，capacitor是Colossus系统上存储BigQuery数据的文件格式。稍后将详细介绍如何加载数据！</p><p id="455d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">同时，如果我们考虑开发人员和分析师针对OLTP(事务性)数据库(如Oracle和MySQL)编写和执行的查询，逐行存储数据更明智，不仅因为数据库需要遵守ACID原则，还因为它通常更多地用于行级别的批量写入和选择性读取，尽管我们看到客户使用OLTP数据库的方式有所不同。例如，世界上确实有一些大公司通过对数据进行适当的索引以及为报告和分析用例创建聚合层，将Oracle数据库有效地用于他们所有的OLTP和OLAP用例。</p><p id="f0b5" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">然而，如果我们有分析用例，(比如)其中，我们想要计算我们在脸书上的追随者的平均年龄，处理这个用例的数据工程师或分析师，将需要读取每个人的所有信息！！如果我们的数据是以行存储格式存储的，那么整个操作将会非常低效，因为我们最终将会读取几乎所有的行！</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/3b70b6c41811f60dae4bf8ae39f7f9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*-wNaGVbHhE_xgpLxLrv5mg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">BigQuery的列存储(适合OLAP)</figcaption></figure><p id="3d56" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">相反，使用面向列的存储，就像我们在BigQuery中使用的电容器一样，我们可以只读取特定的“年龄”列！</p><p id="e85e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">重要提示:</strong>记住，这是一个<strong class="ju hj"> SELECT * </strong>是BigQuery中最危险的操作的基本原因。在大型查询数据集上操作时，不仅性能不友好，而且会导致巨大的开销。稍后会有更多关于数据集的内容！</p><p id="401a" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">现在，让我们更深入地了解<strong class="ju hj">电容器</strong>及其设计/工作原理！</p><h1 id="40f2" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">电容器先生！</h1><p id="83f7" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">总的来说，下面的图表提供了如何使用电容器文件格式在Colossus的列级存储中存储数据块的概述。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/284693a60082964a24bdd02e536d45ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebZVkD_ko1oHqR8cy31E2A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">电容格式— BigQuery数据存储</figcaption></figure><p id="4550" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">正如所定义的，<strong class="ju hj">电容器</strong>是一种面向列的格式——这意味着，每个字段的值都是单独存储的，因此总体I/O开销(在任何或所有读写操作期间)与您实际读取的字段数成比例！然而，这并不一定表示每一列都在自己的文件中；它只是指定每一列都存储在一个文件块中，该文件块被独立地进一步压缩。</p><p id="debe" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">电容器也是自描述的，因此文件本身的信息总是足以完全解码和读取它。这是通过名为<strong class="ju hj">文件头</strong>的组件实现的，如上图所示。</p><p id="5c25" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">所谓的<strong class="ju hj">文件头</strong>包含所有与文件中出现的列相关的<strong class="ju hj">元数据</strong>细节。这包括但显然不限于每一列的列名、数据类型和其他元数据细节。每一列都有min/max，BigQuery查询执行引擎有时会使用它来拒绝整个文件。关于BigQuery中查询执行的更多内容将在后面的文章中介绍！</p><p id="18c7" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">此外，每一列还有<strong class="ju hj">压缩信息</strong>——本质上，BigQuery使用不同的编码来优化存储。当相关的业务过滤条件在读操作期间被应用到列的顶部时，这是一个巨大的性能捐助者！</p><p id="dfbd" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">现在，让我们快速地看一些例子，看看BigQuery是如何完成数据编码的，全部由它自己完成！接下来的内容绝不是所有可能的编码方法的确定列表，而只是出于示例目的的一小部分。</p><h1 id="bbd1" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">列数据的编码</h1><p id="67c4" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">BigQuery使用的对列数据进行编码的一种常见方式是基于<strong class="ju hj">字典的编码</strong>，其示例如下所示:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/ef3ba93c0cf67883aff57a72c740345c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4unqFSA7tegFnC0S6fQSiQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">编码:字典</figcaption></figure><p id="cd90" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">实际上发生的是原始数据的存储方式，如上图左侧所示，就像字典一样有组织地存储在内部，如图右侧所示！</p><p id="4736" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">也被称为<strong class="ju hj">游程编码</strong>方法，这允许BigQuery有效地存储重复的值，因此BigQuery将只记录它重复了三次，而不是说*1三次。</p><p id="618f" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">另一个可以考虑的非常常见的方法是<strong class="ju hj">记录重新排序</strong>，这也是BigQuery如何在内部组织数据以加快分析操作的另一种方式。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/62e60b6a4d731ceb3cc54d46761cbd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6OcJScF-TXMhbwV6YIi6g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">记录重新排序</figcaption></figure><p id="1679" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">本质上，这里发生的是，电容器是内部重新排序记录，能够尝试和分组重复的字段，从而使运行长度编码(RLE)方法更成功！</p><p id="e788" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">在我们转到BigQuery中基于最佳实践的设计模式之前，让我们以简单的术语最终理解实际的物理存储布局来总结BigQuery的存储方面。</p><h1 id="151e" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">巨像:物理存储模式</h1><p id="1376" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">总的来说，Colossus文件系统如下图所示:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/ae7c463b385ad8c1f675e6b60a150f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tz6NHkm_kQ-aSGIRJkQMZA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">巨像文件系统—整体设计</figcaption></figure><p id="b583" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">总的来说，如上所述，BigQuery存储是一个区域性和/或多区域性的服务，这是在创建“数据集”时选择的(即，与OLTP数据库中的模式同义，稍后将详细介绍！).GCP的一个地区被细分为多个区域，因此每个“表”(BigQuery中的一个数据逻辑实体，就像任何其他数据库一样！)跨多个区域复制，以用于故障转移场景，此时表所属的数据集是使用区域选项创建的。</p><p id="f934" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">根据设计，在巨像中，</p><ul class=""><li id="795d" class="ls lt hi ju b jv kr jz ks kd lu kh lv kl lw kp lx ly lz ma bi translated">所有数据都被自动压缩、加密、复制和分发。</li><li id="6db4" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">正如我们所知，在谷歌云平台中有许多级别的防御措施来防止未经授权的访问，其中之一就是100%的数据在静态时都是加密的。</li><li id="137e" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">Colossus使用<strong class="ju hj">擦除编码</strong>在多个物理磁盘上存储冗余数据块，从而确保耐用性。</li></ul><p id="0510" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">将数据写入Colossus后，BigQuery立即启动地理复制过程，将所有数据镜像到指定区域周围的不同数据中心，以防表所属的数据集是区域性的。</p><p id="2b7d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">需要考虑的一些关键点如下:</p><ul class=""><li id="c0cd" class="ls lt hi ju b jv kr jz ks kd lu kh lv kl lw kp lx ly lz ma bi translated">在单个区域中，数据仅存储在该区域中。<strong class="ju hj">注意:</strong>在这种情况下，没有Google Cloud提供的备份或复制到另一个地区。</li><li id="a56a" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">如果出现机器级别的故障，BigQuery将继续运行，延迟不超过几毫秒。根据设计，所有查询都应该成功。如果发生分区故障，预计不会丢失数据。</li><li id="97d7" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">软区域故障，例如由停电、变压器损坏或网络分区导致的故障，已经是久经考验的路径，是BigQuery所有灾难恢复场景的一部分，由我们的工程和/或SRE团队定期进行全面检查。</li><li id="040c" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">不幸的是，如果由于任何原因发生硬区域故障，例如，如果任何自然或非自然的灾难破坏了该区域，那么如果数据集是作为区域数据集创建的，则该区域中的数据可能会丢失。</li><li id="2913" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">另一方面，软区域故障将导致可用性损失，直到该区域重新联机，但不会导致数据丢失。</li></ul><p id="4259" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">多区域位置(就Google云平台而言)是一个很大的地理区域，例如美国(US)或欧洲(EU)，它包含两个或更多地理位置。</p><ul class=""><li id="f337" class="ls lt hi ju b jv kr jz ks kd lu kh lv kl lw kp lx ly lz ma bi translated">在BigQuery的多区域类型的数据集中，数据存储在单个区域中，但在地理上分离的区域中进行备份，以提供对区域性灾难的恢复能力。</li><li id="92fc" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">BigQuery完全高效地自动管理恢复和故障转移过程。</li></ul><p id="9958" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">注意:</strong>许多客户将其数据存储在多区域数据集中，以确保自动备份和更好的灾难恢复，但有时，即使从法律或数据隐私的角度来看，为BigQuery中的数据集选择单个区域也是更好的选择，其目的是接近本地或GCP应用程序工作负载；这样做是为了最小化应用程序和BigQuery实例/工作者之间的延迟！</p><p id="030a" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">现在，让我们继续讨论BigQuery中的一些重要设计模式，它也用于提高分析工作负载的性能。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="9a16" class="iu iv hi bd iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr bi translated">设计模式——分区和集群！</h1><p id="0ca4" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">BigQuery的第一个也是最重要的设计模式是<strong class="ju hj">分区</strong>。当我们(数据工程师)设计数据仓库解决方案时，在我们的OLAP数据库系统之上，根据预期查询的访问模式来划分我们的数据通常是一个最佳实践。这提高了系统的性能和可伸缩性，也有助于减少长期的维护开销！</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/52192a402a5aecf5fd348560ade12c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fy-HAkeJummp5nblcN8hfg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">BigQuery —分区示例！</figcaption></figure><p id="b0e5" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">在BigQuery中，也鼓励数据工程师和分析师依赖于对存储在表中的数据进行分区，以获得适当的性能水平；这确保了根据过滤条件，只查询数据的选定分区，而不是全部，因此减少了查询执行时间和成本。</p><p id="f654" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">但是，分区(或修剪)实际上是如何工作的呢？</p><p id="335e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">对于读取操作:</p><ul class=""><li id="d368" class="ls lt hi ju b jv kr jz ks kd lu kh lv kl lw kp lx ly lz ma bi translated">dremel(big query查询执行引擎)向元数据服务器发送请求，元数据服务器根据PartitionKey列(如WHERE子句中所述)过滤查询存储集表(只是Colossus上存储对象的另一个名称)，最后以PartitionKey在请求范围内的存储集列表作为响应。这不是实际的数据读取阶段，而只是我们所说的数据识别阶段。</li><li id="69aa" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">接下来，Dremel打开存储集内的电容器文件，检查文件中每一列的最小和最大值(可在电容器文件头中找到，记住！).</li><li id="cee4" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">如果[min，max]超出相关范围，它将跳过文件的其余部分，否则将从该文件中读取数据！</li></ul><p id="ce84" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">对于写操作:</p><ul class=""><li id="84df" class="ls lt hi ju b jv kr jz ks kd lu kh lv kl lw kp lx ly lz ma bi translated">来自这些存储文件的元数据将用于确定哪些片段将是相关的。</li><li id="fdbc" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">其余的更新操作几乎完全类似于读取操作！</li></ul><p id="34b8" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">任何BigQuery表上可能有两种分区类型:</p><ul class=""><li id="6d8d" class="ls lt hi ju b jv kr jz ks kd lu kh lv kl lw kp lx ly lz ma bi translated"><strong class="ju hj">摄取日期/时间划分:</strong>基于数据加载的日期/时间。为此，我们使用伪列过滤表中的数据:<strong class="ju hj"> _PARTITIONDATE </strong>，<strong class="ju hj"> _PARTITIONTIME。</strong>一个示例查询可以是:SELECT col FROM d . t WHERE<strong class="ju hj">_ partition date</strong>&gt;“2018–05–01”</li><li id="a407" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated"><strong class="ju hj">列分区:</strong>基于以下任何列类型对表进行分区:时间戳、日期、日期时间(小时、天、月或年粒度)、INT64(您可以定义范围:开始、结束和间隔)。这里，我们再次使用列名进行过滤，减少扫描的数据。示例:SELECT COUNT(*)FROM d . t WHERE datecol&gt;" 2018–05–01 "</li></ul><p id="ea1d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">与分区类似，BigQuery中另一个非常重要的设计模式是<strong class="ju hj">集群</strong>，其中基于多达4列的内容，任何给定BigQuery表中的数据都可以自动排序，或者由数据工程师选择排序！</p><p id="35bc" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">但是，以下是关于集群的几点注意事项:</p><ul class=""><li id="834b" class="ls lt hi ju b jv kr jz ks kd lu kh lv kl lw kp lx ly lz ma bi translated">集群表不需要分区！如果表分区大小小于1 GB，我们应该避免分区。</li><li id="369e" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">是—群集确实可以提高查询速度，因为只扫描相关的数据块(以群集的形式)而不是整个表，可以扫描非常少的数据。</li><li id="ec9e" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">某些查询利用集群实现更快的连接。</li><li id="3025" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">对于BigQuery来说，聚集是一种开销非常小的操作，因为适当的数据过滤(基于聚集的列)可以在提高性能的同时降低成本。</li><li id="9134" class="ls lt hi ju b jv mb jz mc kd md kh me kl mf kp lx ly lz ma bi translated">最后，集群还可以防止由于用户意外查询非常大的整个表而导致的成本激增</li></ul><p id="cf7e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">注意:</strong>我们的许多读者会惊讶地知道，BigQuery还会不时地在后台执行表的自动重新聚类，以固有地对表中的数据进行排序。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="62fb" class="iu iv hi bd iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr bi translated">自适应文件大小</h1><p id="b189" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">BigQuery的一个鲜为人知但非常有益的设计特性是，它提供了自适应的文件大小调整功能！</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/d2e40f69e75ac5c5aa4c953a0e1a0600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crEYBdZWCRrXZtEeaYxdHQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">自适应文件大小</figcaption></figure><p id="3d1e" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">注意:</strong>在撰写本文时，只有集群表被支持或选择用于自动调整文件大小，而我们的BigQuery安装中的其余非集群表/数据将默认为512MB的块大小。</p><p id="31e7" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">但是，对于聚集表，BigQuery会根据表的大小自动调整数据的块大小，以便对较小的数据集进行高效的查询！</p><p id="2de8" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated"><strong class="ju hj">记住:</strong>根据设计，BigQuery是针对吞吐量而不是延迟进行调优的！</p><h1 id="53b4" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结尾注释</h1><p id="1e41" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在这篇文章中，我们学到了很多相关深度的东西。</p><p id="6adc" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">作为结束语，值得一提的是，通常情况下，如果我们的查询的访问模式应该首先受益于底层数据的分组和排序，那么分区和集群(一起使用)的适当和良好设计的组合可以极大地提高查询的性能。</p><p id="aa4d" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">因此，最好地利用分区和/或集群的决定不应该是强制性的，而是应该由打算在我们的BigQuery设置上运行的查询来决定，以用于分析用例。</p><p id="14b1" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">在接下来的文章中，我们将进一步详细介绍如何为任何客户项目组织BigQuery安装(通常情况下),或者，我们稍后将介绍BigQuery迁移主题的一些用例。</p><p id="ddb3" class="pw-post-body-paragraph js jt hi ju b jv kr jx jy jz ks kb kc kd kt kf kg kh ku kj kk kl kv kn ko kp hb bi translated">快乐学习！！！</p></div></div>    
</body>
</html>