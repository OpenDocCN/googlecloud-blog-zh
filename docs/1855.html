<html>
<head>
<title>Cloud Spanner’s Table Interleaving: A Query Optimization Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云扳手的表交错:一个查询优化特性</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/cloud-spanners-table-interleaving-a-query-optimization-feature-b8a87059da16?source=collection_archive---------0-----------------------#2021-04-16">https://medium.com/google-cloud/cloud-spanners-table-interleaving-a-query-optimization-feature-b8a87059da16?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="83c6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">克里斯托弗·巴斯勒和阿南德·贾恩</h2></div><p id="d0a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇博客从开发人员的角度讨论了<a class="ae jt" href="https://cloud.google.com/spanner/docs/schema-and-data-model#creating-interleaved-tables" rel="noopener ugc nofollow" target="_blank">云扳手表交叉</a>:什么是交叉表，何时使用这种模式设计概念，一些边缘案例和陷阱。</p><p id="7f98" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TL；dr:交叉表是针对特定连接查询模式的查询性能优化工具。交叉表不是一个数据建模概念，尽管在模式设计过程中初看起来是这样。<a class="ae jt" href="https://cloud.google.com/spanner/docs/secondary-indexes" rel="noopener ugc nofollow" target="_blank">交叉索引</a>也属于性能优化的范畴。</p><h1 id="c2be" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">云扳手在分布式持久数据管理中的应用</h1><p id="9902" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated"><a class="ae jt" href="https://cloud.google.com/spanner" rel="noopener ugc nofollow" target="_blank"> Cloud Spanner </a>是Google Cloud的“完全托管的关系数据库，规模不限，一致性强，可用性高达99.999%。”</p><p id="5d33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为关系数据库实现无限规模的一个基本设计决策是Cloud Spanner对分布式持久数据存储和分布式查询处理的依赖:查询在访问分布式持久存储的分布式处理节点上执行。</p><p id="70f8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于Cloud Spanner的存储可以“永远”扩展，因为它允许增加容量，而不受架构或实施的限制。可以添加(或删除)的容量单位是2 TB，这是通过向<a class="ae jt" href="https://cloud.google.com/spanner/docs/instances" rel="noopener ugc nofollow" target="_blank">云扳手实例</a>添加(或删除)<a class="ae jt" href="https://cloud.google.com/spanner/docs/instances#node_count" rel="noopener ugc nofollow" target="_blank">云扳手节点</a>来实现的。为了说明可能的规模，这个<a class="ae jt" href="https://www.youtube.com/watch?v=zy-rcR4MoN4" rel="noopener ugc nofollow" target="_blank">演示</a>描述了一个具有PBs关系数据的云扳手实例。数据存储在数据库中，一个Cloud Spanner实例可以管理多个数据库(目前多达<a class="ae jt" href="https://cloud.google.com/spanner/quotas#database_limits" rel="noopener ugc nofollow" target="_blank"> 100个数据库</a>)。</p><p id="2e43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">存储的分布式特性以及表的大小和可能的热点导致按主键对表进行自动水平分区。一个表必须有一个主键，并且表中的行在存储时按主键顺序排序。水平分区称为拆分，拆分是表中行的子集。<a class="ae jt" href="https://cloud.google.com/spanner/docs/schema-and-data-model#load-based_splitting" rel="noopener ugc nofollow" target="_blank">基于负载的拆分</a>是Cloud Spanner在后台执行的进程之一。</p><p id="295b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个表的拆分可能存储在同一个存储区域，也可能存储在不同的存储区域。当表增长时，拆分将位于不同的存储位置，如果增加容量，数据库将有更多的存储位置来存储拆分。安全的假设是，在一般情况下，表的拆分存储在不同的位置。</p><p id="fa4a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果从位于不同拆分中的单个表中查询数据，查询执行将必须找到并访问存储相关拆分的存储位置并返回数据。数据可能在同一拆分中，也可能在不同的拆分中，还可能在相同或不同的存储位置。如果数据位于不同的存储位置，则进行分布式存储访问。</p><p id="b055" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于两个表之间的连接也是如此:可能涉及到每个表的多个拆分和多个存储位置。由于它们的分布，访问不同的存储位置比访问单个存储位置引起更多的等待时间。</p><p id="aeec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当不同表的某些行总是基于应用程序的查询模式一起被查询时，有一种方法强制数据搭配不是很好吗？例如，在父子1:n关系中，父行可能总是或大部分时间与其子行相联接。在这种情况下，将两者都放在相同的拆分和相同的存储位置将是最佳的存储布局，因为结果数据集不必从分布式存储位置收集。</p><p id="8966" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种优化，配置父子表的行，在Cloud Spanner中可用，称为<a class="ae jt" href="https://cloud.google.com/spanner/docs/schema-and-data-model#parent-child_table_relationships" rel="noopener ugc nofollow" target="_blank">表交错</a>。</p><p id="6e19" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇博客的其余部分讨论了这个运行时优化特性、它与模式设计的关系、一些最佳实践、警告和反模式。</p><h1 id="72bf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">模式功能:表交错</h1><p id="c65c" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">当指定表时，表交错的概念被表示为语法终端<code class="du kr ks kt ku b"><a class="ae jt" href="https://cloud.google.com/spanner/docs/schema-and-data-model#creating-interleaved-tables" rel="noopener ugc nofollow" target="_blank">INTERLEAVE IN PARENT</a></code>。举个例子，</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="d761" class="ld jv hi ku b fi le lf l lg lh">CREATE TABLE Singers (<br/>  SingerId INT64 NOT NULL,<br/>  FirstName STRING(1024),<br/>  LastName STRING(1024),<br/>  SingerInfo BYTES(MAX),<br/>  ) PRIMARY KEY (SingerId);</span><span id="0aca" class="ld jv hi ku b fi li lf l lg lh">CREATE TABLE Albums (<br/>  SingerId INT64 NOT NULL,<br/>  AlbumId INT64 NOT NULL,<br/>  AlbumTitle STRING(MAX),<br/>  ) PRIMARY KEY (SingerId, AlbumId),<br/>    INTERLEAVE IN PARENT Singers ON DELETE CASCADE;</span></pre><p id="62a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，表<code class="du kr ks kt ku b">Albums</code>在表<code class="du kr ks kt ku b">Singers</code>中交错。</p><p id="43f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是什么意思？在详细说明之前，请注意<code class="du kr ks kt ku b">Singers</code>的主键是<code class="du kr ks kt ku b">Albums</code>主键的前导部分。这在父表(这里是<code class="du kr ks kt ku b">Singers)</code>)与子表(这里是<code class="du kr ks kt ku b">Albums</code>)之间建立了1:n的关系。</p><p id="2070" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于该规范和主键的值的云扳手知道哪些子行(可能是零个、一个或多个)属于1:n关系中的哪个父行。这现在指示存储管理子系统将父行的子行并置到相同的拆分中，并因此到相同的存储位置中。父行及其子行存储在同一位置，没有任何分布。两个不同的父行及其各自的子行可能位于不同的拆分和不同的存储位置；但是父节点和它的子节点将在同一个分割中。</p><p id="e19d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一张<a class="ae jt" href="https://cloud.google.com/spanner/docs/schema-and-data-model#creating-interleaved-tables" rel="noopener ugc nofollow" target="_blank">图</a>展示了这种布局:</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div class="er es lj"><img src="../Images/4622cd09f0a37f0dc66c64049f54467e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/0*KzsezHgUKCsKy_2w"/></div></figure><p id="6816" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的示例中，检索每个父代的子行的查询如下所示</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="30f6" class="ld jv hi ku b fi le lf l lg lh">SELECT s.FirstName,<br/>       s.LastName,<br/>       a.AlbumTitle<br/>FROM Singers s JOIN Albums a ON s.SingerId = a.SingerId;</span></pre><p id="e5a9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该查询为父行的每个子行返回一行。</p><p id="d9c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，表是交错的这一事实在查询本身中是不可见的。如果这两个表没有在模式级别上声明为交错的，而是独立的表，那么查询看起来会完全一样。这个观察在以后会很重要。</p><p id="83ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当上面的查询执行时，它查找与父项并置的父项的所有子行，并且查询执行将不必访问不同的分布式存储位置。这就是性能优势:在一个存储位置上并置数据的连接。</p><p id="aa2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种好处不仅适用于一个级别的关系，还适用于多达7个级别的关系，也就是说，每个子行都可以是另一个表中的下一个子行(孙-子)的父行。</p><p id="e946" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检索父行的子行的另一个查询涉及数据类型<code class="du kr ks kt ku b">ARRAY</code>,如下所示</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="2fed" class="ld jv hi ku b fi le lf l lg lh">SELECT s.FirstName,<br/>       s.LastName,<br/>       ARRAY(SELECT AS STRUCT a1.AlbumTitle <br/>             FROM Singers s1 <br/>                  JOIN Albums a1 ON s1.SingerId = a1.SingerId <br/>             WHERE s.SingerId = s1.SingerId) Albums<br/>FROM Singers s<br/>WHERE EXISTS(SELECT a2.AlbumTitle<br/>             FROM Albums a2<br/>             WHERE a2.SingerId = s.SingerId);</span></pre><p id="d82c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该查询为数组中的每个歌手和该歌手的所有专辑返回一行。exists子句确保只返回那些有专辑的歌手。它演示了可以查询1:n关系，并且如果这对客户端应用程序有利的话，可以将子表条目表示为数组。</p><h2 id="c741" class="ld jv hi bd jw ln lo lp ka lq lr ls ke jg lt lu kg jk lv lw ki jo lx ly kk lz bi translated">表格交错的替代方案</h2><p id="bf8d" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">表交错强制将父行及其子行并置到同一存储位置。另一种设计是使用数组。子代存储在父行内的列中，而不是表交错。举个例子，</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="c782" class="ld jv hi ku b fi le lf l lg lh">CREATE TABLE SingersAndAlbums (<br/>  SingerId INT64 NOT NULL,<br/>  FirstName STRING(1024),<br/>  LastName STRING(1024),<br/>  SingerInfo BYTES(MAX),<br/>  Albums ARRAY&lt;STRING(MAX)&gt;,<br/>  ) PRIMARY KEY (SingerId);</span></pre><p id="d7e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从存储角度来看，这种设计实现了几乎相同的目标，但是，不仅有优点，也有缺点:</p><p id="4807" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些优点是</p><ul class=""><li id="abb3" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mf mg mh mi bi translated"><strong class="iz hj">收纳搭配</strong>。由于专辑以数组的形式存储在一个列中，所以它们会自动与歌手的数据一起存储。</li><li id="a5c4" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="iz hj">方便查询</strong>。选择歌手的专辑是一个非连接select语句。</li></ul><p id="a5ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些缺点是</p><ul class=""><li id="ad44" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mf mg mh mi bi translated"><strong class="iz hj">数组元素是标量。</strong>数组元素只能是标量类型。对于上面的用例，相册的id和标题必须存储在一个字符串中(用一些分隔符或作为一个JSON对象)。</li><li id="cd88" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="iz hj">阵列操纵</strong>。数组操作有特定的函数和SQL语法，如这里<a class="ae jt" href="https://cloud.google.com/spanner/docs/arrays" rel="noopener ugc nofollow" target="_blank">所解释的</a>。</li><li id="6032" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="iz hj">列值大小限制10 MB </strong>。列值大小的限制是10 MB。如果数组中的数据超过这个数，就会出现错误，必须寻找替代设计。</li><li id="a477" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="iz hj">读访问的完整数组单元</strong>。与可以单独选择的交错行相比，阵列总是被完整地读取。</li></ul><p id="9270" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然使用array作为列数据类型通常不是一个缺点，但是对于上面的用例，它会使管理歌手专辑的应用程序逻辑变得复杂。</p><h2 id="6bd0" class="ld jv hi bd jw ln lo lp ka lq lr ls ke jg lt lu kg jk lv lw ki jo lx ly kk lz bi translated">表交错的其他好处</h2><p id="c344" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">表交错还有下面没有进一步讨论的其他好处。一个好处是在删除父行的上下文中。可以指定父行的子行随父行一起自动删除。此处描述了<code class="du kr ks kt ku b">ON CASCADE DELETE</code>构造<a class="ae jt" href="https://cloud.google.com/spanner/docs/data-definition-language#create_table" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c37b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当在同一个事务中插入父母和他们的孩子时，实现了一个隐含的好处。如果父节点及其子节点都被插入到同一个事务中，那么在大多数情况下，插入发生在同一个拆分中。与父行和子行作为单独的表管理的情况相比，这需要较少的协调。在这种情况下，如果行存储在不同的拆分中，则可能需要跨存储区域的分布式协调。</p><h1 id="8750" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">性能优化</h1><p id="b97b" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">上一节已经展示了1:n关系可以建模为单独的表以及交叉表，在这两种情况下，通过连接选择父子关系的查询是完全相同的。表交错强制父行和子行并置，与非交错表相比，父表和子表之间的连接性能更好，因为数据是在交错表的情况下并置的。</p><p id="d4a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，为什么不在开始表设计时，从一开始就尽可能简单地使用交错呢？</p><p id="91e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设计模式的表及其外键关系是一项基于数据语义的概念性活动。在模式设计过程中需要回答的问题有:表(实体)是否适合我感兴趣的领域？列是否恰当地表示了实体的属性？主键唯一标识实体吗？外键关系是否正确地表示了依赖关系？</p><p id="503b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然某些查询模式在模式设计期间是已知的，但是查询的规范并不是最重要的。然而，在某种程度上，查询规范在设计中占据了中心位置，在这一点上，优化步骤正在发生，例如:定义索引、非规范化表或者用基于整数的枚举替换字符串数据类型。</p><p id="16d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">后来，考虑查询执行频率，因为某些性能优化对所有查询的子集有意义，而不是对其中的每一个都有意义。在这一点上，表交错变成了一种性能改进工具:表交错是否有助于通过引起数据的搭配来改进性能？</p><p id="eede" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果在模式设计期间解决了表交错问题，那么它将扮演概念模式建模概念的角色(1:n，可能是关系的一部分)。配置数据的结果可能会转移到后台，并且在测试时可能会导致性能障碍。</p><p id="6e01" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，建议不要基于预期过早优化，而是基于概念验证和测量。因此，使用表交错作为性能改进工具，而不是作为模式设计技术。</p><h1 id="b0ce" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">最佳实践设计流程</h1><p id="80f1" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">以下过程是表交错的一般最佳实践(警告和边缘情况随后介绍):</p><ol class=""><li id="51fa" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mo mg mh mi bi translated">在初始模式设计阶段设计没有交叉表的数据库模式</li><li id="21e9" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mo mg mh mi bi translated">在模式设计阶段，请记住，出于性能原因，以后可能必须将表示1:n关系的表更改为交叉表。如果可能，适当地设计主键，使潜在父表的主键成为潜在子表的复合主键的主要部分</li><li id="adc8" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mo mg mh mi bi translated">设计将在模式上操作的所有查询(尽可能)</li><li id="81a2" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mo mg mh mi bi translated">检查所有连接并评估其性质。出于表交叉的目的，调用查询1:n关系的连接。测量它们的执行性能，并观察那些查询1:n关系的连接的执行频率</li><li id="39e2" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mo mg mh mi bi translated">如果两个表之间有80%以上的时间存在1:n连接，请考虑将这两个表放入交错关系中。测量两种模式中的查询执行性能(有交叉表和没有交叉表),并确定表交叉是否提供了性能优势</li></ol><p id="95de" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个最佳实践设计过程适用于那些对应用程序的核心业务逻辑至关重要并且经常执行的查询。对于每天、每周或每月执行一次的查询，考虑这样的优化过程可能并不重要。</p><h1 id="0e5a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">警告和边缘案例</h1><p id="6be3" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">在Cloud Spanner中使用表交错时，需要记住一些警告和边缘情况:</p><ul class=""><li id="ebb6" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mf mg mh mi bi translated">交叉存取表时，所有子行的大小总和有一个大约8GB的软限制。至此，所有子行都与父行在同一个拆分中并置在一起。任何额外的子行被单独存储<a class="ae jt" href="https://cloud.google.com/spanner/docs/schema-design#limit_row_size" rel="noopener ugc nofollow" target="_blank">用于另一个分割中的下一个8GB。</a></li><li id="46ce" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">将父行的历史数据保存为子行是很诱人的。例如，父级的每次更改都作为单独的子行添加。这种设计确保子行的数量不断增长，并且在某个时间点会达到8GB的软限制，这可能会降低查询性能。历史数据通常最好存储在单独的表中。</li><li id="130e" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">在不访问父表的情况下访问交叉表不会获得存储并置的好处。相反，只访问子行的查询可能会导致性能下降，因为该查询可能必须访问保存子行的许多不同拆分，否则这些子行可能会被连续存储。</li><li id="594b" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">如果只访问父行而不同时连接子表，并且查询的谓词不是主键，那么交错的好处可能也不会实现，因为查询将不得不访问“跳过”子行的许多拆分。</li><li id="b4ef" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">如果在模式设计阶段之后使用了交叉表，并且在最坏的情况下，所有的表都以某种形式相互交叉，那么后退一步，重新评估这是否真的是最好的设计，因为此时查询是未知的或者可能是完全未知的。</li></ul><h1 id="3710" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">数据大小很重要</h1><p id="eec0" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">数据量也很重要，下面的使用案例展示了这种情况。假设一个父表有许多列，每列存储大量数据。为了强调用例，我们假设有100列，每列存储1 MB的数据。因此，一行存储大约100 MB。</p><p id="33e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于子行，让我们假设在正常情况下每个父代大约有25个子代，每个子代有几列，总共有1 MB。</p><p id="33cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检索所有列(select *)的父行及其所有子行之间的联接将导致结果集大小为101 MB * 25，也就是大约2.5 GB。除了结果集中有大量数据之外，大部分数据都是冗余的。在这种情况下，分别检索父项及其子项将导致两次查询，结果集总大小约为125 MB。当使用两个查询时，返回的数据量比执行一个连接少得多，并且没有冗余数据。</p><p id="07a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这只是一个特殊情况的例子，在这种情况下，表交叉是一种完美的设计，但是从性能的角度来看，通过连接查询数据可能不是最佳策略。</p><h1 id="bd56" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">摘要</h1><p id="811b" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">总之，将表交错作为一种性能改进工具，根据应用程序设计中最关键查询的测量和实际性能数字来使用。避免使用表交错作为模式设计概念的诱惑，因为如果不基于性能度量来使用它，它可能会干扰查询性能。</p><h1 id="7756" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">后续步骤</h1><p id="d7bb" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">作为后续步骤，在下一个机会遵循最佳实践设计流程。同时，查看产品文档<a class="ae jt" href="https://cloud.google.com/spanner/docs/schema-and-data-model#creating-interleaved-tables" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae jt" href="https://cloud.google.com/spanner/docs/whitepapers/optimizing-schema-design#tradeoffs_of_locality" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="b1f0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">承认</h1><p id="d349" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">我要感谢Neha Deodhar，Vlad Lifliand和Yuki Furuyama的全面审查和许多评论，以提高这一内容的准确性。</p><h1 id="23f7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">放弃</h1><p id="e366" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">Christoph Bussler是谷歌公司(Google Cloud)的解决方案架构师，Anand Jain是数据和分析云工程师。这里陈述的观点是我们自己的，而不是谷歌公司的。</p></div></div>    
</body>
</html>