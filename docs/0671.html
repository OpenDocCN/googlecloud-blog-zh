<html>
<head>
<title>Kubernetes Deployment Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes部署依赖项</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-deployment-dependencies-ef703e563956?source=collection_archive---------0-----------------------#2018-07-02">https://medium.com/google-cloud/kubernetes-deployment-dependencies-ef703e563956?source=collection_archive---------0-----------------------#2018-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="da29" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个渴望抓挠的痒处！</h2></div><p id="094d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在做一个区块链平台的掌舵图。Helm有助于模板化部署，尽管我发现自己复制了许多样板文件。一个更大的问题是试图在部署期间反映资源之间的依赖性。</p><p id="6f44" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经写了一个小的概念验证，我认为有帮助，并对反馈感兴趣。我意识到我不仅想要一个(分布式)锁服务(etcd？胖乎乎的？)，而且还有更透明的Kubernetes资源来编排这些依赖关系。</p><h2 id="beb6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">问题是</h2><p id="f7f4" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我有2个吊舱:<code class="du kt ku kv kw b">first</code>、<code class="du kt ku kv kw b">second</code>。我希望<code class="du kt ku kv kw b">second</code>阻塞，直到<code class="du kt ku kv kw b">first</code>是“可用的”。这是数据库及其客户端通常需要的，但我认为这是一个普遍的问题。</p><p id="368a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我遇到的解决方案是在pod之间共享一个卷，并将文件系统用作锁定数据库。某种形式的东西:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="94bb" class="jt ju hi kw b fi lf lg l lh li">kind: Pod<br/>metadata:<br/>  name: pod-a<br/>spec:<br/>  volumes:<br/>  - name: shared-pvc<br/>  initContainers:<br/>  - name: await<br/>    command:<br/>    - sh<br/>    - -c<br/>    - |<br/>      while [ ! -f /shared/created ]; do<br/>        echo Waiting for something to be created<br/>        sleep 5s<br/>      done<br/>      echo created<br/>    volumeMounts:<br/>    - mountPath: /shared<br/>      name: shared-pvc</span></pre><p id="601b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这有几个优点:</p><ul class=""><li id="d119" class="lj lk hi iz b ja jb jd je jg ll jk lm jo ln js lo lp lq lr bi translated">它利用了Linux中的“一切都是文件”;随处可得</li><li id="5bb1" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">这很容易理解</li></ul><p id="5cf4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是它有几个缺点</p><ul class=""><li id="5699" class="lj lk hi iz b ja jb jd je jg ll jk lm jo ln js lo lp lq lr bi translated">它对Kubernetes和其他容器来说是不透明的</li><li id="ab1d" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">它甚至需要一个外壳来包装一个二进制文件</li><li id="6d7d" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">它需要读写多个卷</li><li id="c4bb" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">它不是可插拔的</li></ul><p id="eaa4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个替代方法的概念验证，我怀疑这是etcd，Chubby，Zookeeper和其他人会提供的。如果我能说服自己这种方法的优点，我计划尝试使用etcd或者可能将Google的运行时配置服务呈现给Kubernetes。</p><h1 id="1a72" class="lx ju hi bd jv ly lz ma jz mb mc md kd io me ip kg ir mf is kj iu mg iv km mh bi translated">概念验证</h1><p id="2dfd" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我编写了一个简单的Golang httpd服务，它接受get来检索“变量”并发布创建它们的消息。服务本身是根据全局配置值创建的。</p><blockquote class="mi mj mk"><p id="8bf2" class="ix iy ml iz b ja jb ij jc jd je im jf mm jh ji jj mn jl jm jn mo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>当我写这篇文章时，我意识到一个直接的改进是使全局配置值动态化而不是静态化。然后，这将与每个GET和POST一起提供，以划分到名称空间中。</p></blockquote><p id="bc4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果变量<code class="du kt ku kv kw b">a/path/my/variable</code>已经被创建，则返回200:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="544e" class="jt ju hi kw b fi lf lg l lh li">curl \<br/>--request GET \\<br/><a class="ae mp" href="http://service:9999/?variable=a/path/my/variable" rel="noopener ugc nofollow" target="_blank">http://simple-config:9999/?variable=a/path/my/variable</a><br/>[200]</span></pre><p id="2c47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下命令创建上述变量:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="3633" class="jt ju hi kw b fi lf lg l lh li">curl \<br/>--request POST<br/>--header "Accept: application/json" \<br/>--data '{"variable":"a/path/my/variable"}' \<br/>http://simple-config:9999</span></pre><p id="28df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这有什么好处呢？</p><p id="5a51" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不确定。</p><p id="8f2f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是<code class="du kt ku kv kw b">first</code>的一个实现示例:</p><figure class="kx ky kz la fd mq"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="179e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将修改<code class="du kt ku kv kw b">initContainer</code>(第12-29行)。它使用<code class="du kt ku kv kw b">busybox</code>(有<code class="du kt ku kv kw b">wget</code>没有<code class="du kt ku kv kw b">curl</code>)。它从向下的API(例如<code class="du kt ku kv kw b">first</code>)获取容器的名称，将其连接到<code class="du kt ku kv kw b">init</code>并在服务的卷<code class="du kt ku kv kw b">first/init</code>中创建一个文件。</p><p id="bda4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检查服务的数量，我们发现:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="5434" class="jt ju hi kw b fi lf lg l lh li">.<br/>└── first<br/>    └── init</span></pre><p id="4460" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主容器(称为<code class="du kt ku kv kw b">container</code>)在其<code class="du kt ku kv kw b">initContainers</code>完成时阻塞。当容器开始的时候，我们可以确信<code class="du kt ku kv kw b">first/init</code>文件已经被创建了。容器然后创建第二个名为<code class="du kt ku kv kw b">first/container</code>的文件:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="1426" class="jt ju hi kw b fi lf lg l lh li">.<br/>├── first<br/>    ├── container<br/>    └── init</span></pre><p id="453d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一切都好！</p><p id="3ce2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们可以部署<code class="du kt ku kv kw b">Second</code>:</p><figure class="kx ky kz la fd mq"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="2e21" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该Pod ( <code class="du kt ku kv kw b">Second</code>)必须锁定，直到<code class="du kt ku kv kw b">first</code>准备就绪。我们的协议是<code class="du kt ku kv kw b">first</code>在准备好的时候会创建一个变量<code class="du kt ku kv kw b">first/container</code>。因此，Second有一个<code class="du kt ku kv kw b">initContainer</code>，它等待这个变量的端点准备就绪(200)。这段代码出现在第16–27行。</p><p id="0ea9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可惜(！)这需要一个shell(这是我希望避免的一个需求)*，但是*我建议用一个简单的Golang二进制程序来代替它，轮询给定的端点。这类似于我之前写的健康检查替代方案(<a class="ae mp" rel="noopener" href="/google-cloud/dockerfile-go-healthchecks-k8s-9a87d5c5b4cb">链接</a>)。</p><p id="11ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和前面一样，主容器(container)使用busybox的wget创建另一个变量，记录该容器的成功完成(<code class="du kt ku kv kw b">second/dependent</code>)。</p><p id="3f66" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成<code class="du kt ku kv kw b">first</code>和<code class="du kt ku kv kw b">second</code>后，我们有:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="d2d3" class="jt ju hi kw b fi lf lg l lh li">.<br/>├── first<br/>│   ├── container<br/>│   └── init<br/>└── second<br/>    └── dependent</span></pre><p id="c1d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些树显示了这种方法的一个副作用，即尽管实现当前使用文件系统，但是文件系统对于创建/读取变量的客户端是不透明的。可以在不重写容器清单的情况下应用替代实现(etcd，运行时配置)。</p><p id="6397" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是谷歌的控制台，显示了部署的服务和完成的<code class="du kt ku kv kw b">first</code>和<code class="du kt ku kv kw b">second</code>:</p><figure class="kx ky kz la fd mq er es paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="er es mt"><img src="../Images/64a04112928949e0f9fd72d46dfc8560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GPTrqZ9INgZMFeMbrImMw.png"/></div></div></figure><p id="d24f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">深入了解每一项:</p><figure class="kx ky kz la fd mq er es paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="er es na"><img src="../Images/5c8799c690d205c3d0c72b2dc8323df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkB4gacL0vXiUIPLwdwc5A.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">第一</figcaption></figure><p id="41f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且:</p><figure class="kx ky kz la fd mq er es paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="er es nf"><img src="../Images/8012f4b89c23f314b2ad1f554a9531f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohe-8fqvImqlTsdg92vE6A.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">第二</figcaption></figure><p id="4e74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和<code class="du kt ku kv kw b">wait</code>容器的日志:</p><figure class="kx ky kz la fd mq er es paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="er es ng"><img src="../Images/9a44526893af2ed7276e477384b0fff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-U_a3--yKmnNtZNi00URwA.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">等待</figcaption></figure><p id="4e93" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，您可以从命令行查看等待容器的日志:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="9691" class="jt ju hi kw b fi lf lg l lh li">kubectl logs pod/second \<br/>--container=wait \<br/>--namespace=${NAMESPACE} \<br/>--context=${CONTEXT}</span><span id="15d7" class="jt ju hi kw b fi nh lg l lh li">fetch <a class="ae mp" href="http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">http://dl-cdn.alpinelinux.org/alpine/v3.7/.</a>..<br/>fetch <a class="ae mp" href="http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz" rel="noopener ugc nofollow" target="_blank">http://dl-cdn.alpinelinux.org/alpine/v3.7/.</a>..<br/>(1/4) Installing ca-certificates (20171114-r0)<br/>(2/4) Installing libssh2 (1.8.0-r2)<br/>(3/4) Installing libcurl (7.60.0-r1)<br/>(4/4) Installing curl (7.60.0-r1)<br/>Executing busybox-1.27.2-r7.trigger<br/>Executing ca-certificates-20171114-r0.trigger<br/>OK: 6 MiB in 15 packages<br/><strong class="kw hj">Checking: </strong><a class="ae mp" href="http://simple-config:9999/?variable=first/container" rel="noopener ugc nofollow" target="_blank"><strong class="kw hj">http://simple-config:9999/?variable=first/container</strong></a><br/>Ready</span></pre><p id="0db6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里你可以看到<code class="du kt ku kv kw b">initContainer</code>阻塞了<code class="du kt ku kv kw b">second</code>容器的开始，直到变量变得可用，在这种情况下，这种情况会很快发生。</p><p id="7711" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经展示了使用<code class="du kt ku kv kw b">tree</code>来查看支持<code class="du kt ku kv kw b">simple-config</code>服务的目录的内容。要访问与简单配置服务相关联的调试容器(debug )(参见第39–44行下面的<code class="du kt ku kv kw b">deployment.yaml</code>),我们必须首先确定pod的名称。因为容器有一个与之关联的标签(<code class="du kt ku kv kw b">component: debug</code>)，所以我们可以快速选择它。然后，我们使用JSONPath获取(假设是第一个也是唯一的)pod的名称:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="d9db" class="jt ju hi kw b fi lf lg l lh li">kubectl get pods \<br/>--selector=component-debug \<br/>--output=jsonpath="{.items[0].metadata.name}" \<br/>--namespace=${DEFAULT} \<br/>--context=${CONTEXT}</span></pre><p id="ba10" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以将这个命令与一个<code class="du kt ku kv kw b">kubectl exec</code>结合起来，以访问调试容器中的<code class="du kt ku kv kw b">ash</code>外壳:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="ea53" class="jt ju hi kw b fi lf lg l lh li">kubectl exec \<br/>--stdin \<br/>--tty<br/>$(\<br/>  kubectl get pods \<br/>  --selector=component-debug \<br/>  --output=jsonpath="{.items[0].metadata.name}" \<br/>  --namespace=${NAMESPACE} \<br/>  --context=${CONTEXT}) \<br/>--namespace=${NAMESPACE} \<br/>--context=${CONTEXT} \<br/>-- ash</span></pre><blockquote class="mi mj mk"><p id="2677" class="ix iy ml iz b ja jb ij jc jd je im jf mm jh ji jj mn jl jm jn mo jp jq jr js hb bi translated">注意:如果你使用默认设置，你可以同时丢弃两组标志<code class="du kt ku kv kw b"> — namespace</code>和<code class="du kt ku kv kw b">— context</code>。</p><p id="88c0" class="ix iy ml iz b ja jb ij jc jd je im jf mm jh ji jj mn jl jm jn mo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>第一次执行到容器中，你可能希望安装<code class="du kt ku kv kw b">tree</code>(你需要先更新:<code class="du kt ku kv kw b">apk update &amp;&amp; apk install tree</code>)。</p></blockquote><p id="9da2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，您可以检查<code class="du kt ku kv kw b">/config</code>目录的内容:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="4f73" class="jt ju hi kw b fi lf lg l lh li">tree /config</span><span id="cc8e" class="jt ju hi kw b fi nh lg l lh li">/config<br/>├── first<br/>│   ├── container<br/>│   └── init<br/>└── second<br/>    └── dependent</span></pre><p id="3329" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kt ku kv kw b">simple-config</code>配置在3个地方。</p><p id="6e08" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，流程(<code class="du kt ku kv kw b">main.go</code>)可以由环境配置。变量<code class="du kt ku kv kw b">SIMPLE_CONFIG_PATH</code>用于定义变量存储的绝对路径。默认为当前目录(<code class="du kt ku kv kw b">.</code>)。变量<code class="du kt ku kv kw b">SIMPLE_CONFIG_PORT </code>用于定义监听端口。默认为<code class="du kt ku kv kw b">8080</code>。</p><p id="8629" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后通过在第32–35行的<code class="du kt ku kv kw b">deployment.yaml</code>中定义<code class="du kt ku kv kw b">env</code>键:值对，将<code class="du kt ku kv kw b">simple-config</code>服务配置为使用<code class="du kt ku kv kw b"> /config</code>目录和端口<code class="du kt ku kv kw b">9999</code>(任意)。这些包括对容器的<code class="du kt ku kv kw b">/config</code>的引用。这实际上是一个名为<code class="du kt ku kv kw b">config</code>卷的卷装载(第33–34行)。在第24–25行中，卷本身被定义为一个<code class="du kt ku kv kw b">EmptyDir</code>。</p><p id="9b65" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了方便和/或比较，本地运行容器的等效Docker命令应该是:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="c936" class="jt ju hi kw b fi lf lg l lh li">HOST_PATH=...<br/>HOST_PORT=...<br/>CONT_PATH=...<br/>CONT_PORT=...</span><span id="126a" class="jt ju hi kw b fi nh lg l lh li">docker run \<br/>--interactive \<br/>--tty \<br/>--volume=$PWD/${HOST_PATH}:${CONT_PATH} \<br/>--env=SIMPLE_CONFIG_PATH=${CONT_PATH} \<br/>--env=SIMPLE_CONFIG_PORT=${CONT_PORT} \<br/>--publish=${HOST_PORT}:${CONT_PORT} \<br/>dazwilkin/simple-config:v1</span></pre><h2 id="5800" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">Golang:服务器</h2><p id="bcce" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">下面是<code class="du kt ku kv kw b">simple-config</code>服务器实现的代码:</p><figure class="kx ky kz la fd mq"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="29ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是它的文档:</p><figure class="kx ky kz la fd mq"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="ef37" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是它的部署清单:</p><figure class="kx ky kz la fd mq"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h2 id="23b2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">客户</h2><p id="54db" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">下面是<code class="du kt ku kv kw b">simple-config</code>服务的一个客户端实现:</p><figure class="kx ky kz la fd mq"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="b8f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个带有调整过的<code class="du kt ku kv kw b">entrypoint</code>的Dockerfile文件也能捕获Golang二进制文件:</p><p id="f1e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae mp" href="https://gist.github.com/DazWilkin/b9044de454691eef93dc69900c340b72" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/daz wilkin/b 9044 de 454691 eef 93 DC 69900 c 340 b 72</a></p><p id="c99a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和一份货舱清单:</p><figure class="kx ky kz la fd mq"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="b922" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，我们没有外壳，不是因为对外壳有任何厌恶，而是为了更明确地表明意图。<code class="du kt ku kv kw b">initContainer</code>引用客户端(<code class="du kt ku kv kw b">dazwilkin/simple-config/client</code>)并调用<code class="du kt ku kv kw b">exists $(VARIABLE)</code>来检查变量(<code class="du kt ku kv kw b">plus/container</code>)是否存在。</p><p id="d475" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随后，<code class="du kt ku kv kw b">container</code>容器调用<code class="du kt ku kv kw b">create $(VARIABLE)</code>来标记其完成。</p><h2 id="3dbe" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结论</h2><p id="eb84" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我还不确定这种方法的优点。它解决了我的一些问题，但不是全部，并且增加了一些复杂性。我仍然相信Kubernetes应该有一种机制来自动化这种类型的部署复杂性。</p><p id="e708" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">存在哪些替代方案？</p></div></div>    
</body>
</html>