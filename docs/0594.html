<html>
<head>
<title>Stateful Services on Preemptible Nodes with Google Kubernetes Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google Kubernetes引擎在可抢占节点上提供有状态服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/stateful-services-on-preemptible-nodes-with-google-kubernetes-engine-c73ac10b8253?source=collection_archive---------0-----------------------#2018-05-04">https://medium.com/google-cloud/stateful-services-on-preemptible-nodes-with-google-kubernetes-engine-c73ac10b8253?source=collection_archive---------0-----------------------#2018-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="82c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在谷歌Kubernetes引擎(GKE)上运行Kubernetes 工作负载有很多<a class="ae jd" href="https://sadasystems.com/blog/google-microservices-gcp" rel="noopener ugc nofollow" target="_blank">的好处。由于Google对Kubernetes开源项目的重大贡献，以及在Google内部(通过Borg)大量使用Google版本的Kubernetes，Google总体上处于运行和编排容器的前沿，尤其是在公共云中。</a></p><p id="f3fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过GKE运行Kubernetes工作负载的一些优势包括在GKE上运行的微服务和通过<a class="ae jd" href="https://sadasystems.com/cloud-solutions/google-cloud/google-cloud-platform" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a> (GCP)提供的其他服务之间的集成。通过GKE利用谷歌的数据仓库技术(如BigQuery)相对简单，无需担心数据吞吐量或身份验证的细节，因为其中大部分完全由谷歌管理。只需点击几下鼠标，即可轻松使用GPU和TPUs构建集群。</p><p id="2ffd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于允许Kubernetes，更具体地说是GKE，管理容器及其底层节点的编排的好处，使用谷歌的可抢占节点的吸引力变得更加明显。尽管可抢占的节点可能在任何时候死亡(一旦谷歌通过<code class="du je jf jg jh b">SIGTERM</code>通知)，但它们可以比传统的长期运行的节点节省大约70%的成本。由于Google管理容器<em class="ji">和</em>节点的扩展，节点的死亡不会对我们的微服务或应用程序整体产生影响。</p><p id="57bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这对大多数微服务来说是很棒的，但是在某些情况下，微服务需要维护状态。即使有状态是暂时的，并且状态最终被卸载，这对于具有可抢占实例的工作负载来说也是麻烦的。</p><p id="78fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于GKE和可抢占节点的性质，一旦一个节点被安排删除，一个节点接收一个<code class="du je jf jg jh b">SIGTERM</code>，但是底层的pod永远不知道它将要死亡，直到它实际上被终止。同样，对于无状态服务，这不会引起任何问题，因为GKE只是旋转新的节点，pods可以在这些节点上进行调度。</p><p id="f5a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在有状态服务的情况下，我们需要考虑节点的终止，并以优雅的方式管理它们的关闭。</p><p id="5690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们需要考虑一些需求。</p><ul class=""><li id="b74a" class="jj jk hi ih b ii ij im in iq jl iu jm iy jn jc jo jp jq jr bi translated">一个节点必须通知在其上运行的pods，它将有足够的时间来保存或卸载状态</li><li id="4dc2" class="jj jk hi ih b ii js im jt iq ju iu jv iy jw jc jo jp jq jr bi translated">我们希望遵循最小特权的原则，以确保一个节点只有能力去做，而没有任何其他不希望发生的事情，如果我们授予太多的权限给T1</li><li id="5eb4" class="jj jk hi ih b ii js im jt iq ju iu jv iy jw jc jo jp jq jr bi translated">必须在启动时将<code class="du je jf jg jh b">kubectl</code>代理与GKE主节点通信所需的权限授予每个GKE节点(以便它可以运行<code class="du je jf jg jh b">kubectl drain `hostname`</code></li><li id="c168" class="jj jk hi ih b ii js im jt iq ju iu jv iy jw jc jo jp jq jr bi translated">这些节点配有安全的CoreOS操作系统。因此，<code class="du je jf jg jh b">gcloud</code>没有被安装，也不可能被安装。事实上，出于安全原因，几乎没有任何东西可以安装在节点上。</li><li id="7f25" class="jj jk hi ih b ii js im jt iq ju iu jv iy jw jc jo jp jq jr bi translated">我们希望尽可能保持集中管理和简单</li></ul><p id="86c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们认为最好的方法是开发一个解决方案，通过Google Compute Engine (GCE)启动脚本管理所需配置文件向每个GKE节点的交付。我们还将通过GCE关闭脚本在每个GKE节点上包含<code class="du je jf jg jh b">kubectl drain `hostname`</code>来确保pod正常关闭。</p><p id="75e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使这个解决方案起作用，需要做一些准备工作。我们首先必须创建一个Kubernetes角色，该角色拥有清空节点所需的权限，没有其他权限。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="60b6" class="kf kg hi jh b fi kh ki l kj kk">vim drain-role.yaml</span><span id="0a1e" class="kf kg hi jh b fi kl ki l kj kk">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRole<br/>metadata:<br/> name: <strong class="jh hj">system:node-drainer</strong><br/>rules:<br/>- apiGroups:<br/> - ""<br/> resources:<br/> - pods/eviction<br/> verbs:<br/> - create</span><span id="1d22" class="kf kg hi jh b fi kl ki l kj kk">- apiGroups:<br/> - apps<br/> resources:<br/> - statefulsets<br/> verbs:<br/> - get</span><span id="df06" class="kf kg hi jh b fi kl ki l kj kk">- apiGroups:<br/> - extensions<br/> resources:<br/> - daemonsets<br/> - replicasets<br/> verbs:<br/> - get</span><span id="b9d8" class="kf kg hi jh b fi kl ki l kj kk">- apiGroups:<br/> - batch<br/> resources:<br/> - jobs<br/> verbs:<br/> - get</span><span id="9964" class="kf kg hi jh b fi kl ki l kj kk">- apiGroups:<br/> - ""<br/> resources:<br/> - nodes<br/> verbs:<br/> - get<br/> - patch</span><span id="3a28" class="kf kg hi jh b fi kl ki l kj kk">- apiGroups:<br/> - ""<br/> resources:<br/> - pods<br/> verbs:<br/> - list</span></pre><p id="5fd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要在<code class="du je jf jg jh b">drain-user.yaml</code>中建立一个Kubernetes服务帐户用户</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="f675" class="kf kg hi jh b fi kh ki l kj kk">apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/> name: <strong class="jh hj">drain-user</strong><br/> namespace: default</span></pre><p id="6972" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们需要确保通过<code class="du je jf jg jh b">drain-binding.yaml</code>将这个角色绑定到这个用户</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="7683" class="kf kg hi jh b fi kh ki l kj kk">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRoleBinding<br/>metadata:<br/> name: <strong class="jh hj">drain-user</strong><br/>roleRef:<br/> apiGroup: rbac.authorization.k8s.io<br/> kind: ClusterRole<br/> name: <strong class="jh hj">system:node-drainer</strong><br/>subjects:<br/>- kind: ServiceAccount<br/> name: <strong class="jh hj">drain-user</strong><br/> namespace: default</span></pre><p id="6743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要创建我们的GKE集群，并获得对它的访问凭据。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="1a79" class="kf kg hi jh b fi kh ki l kj kk">gcloud container clusters create [CLUSTER_NAME]<br/>gcloud container clusters get-credentials [CLUSTER_NAME]</span></pre><p id="7c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在<code class="du je jf jg jh b">~/.kube/config</code>创建一个配置文件，我们可以用它来使用<code class="du je jf jg jh b">kubectl</code>。我们应该注意，这个配置应该受到保护，因为它包含作为管理员与GKE通信的凭证。</p><p id="3371" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经获得了对GKE主服务器执行任何操作的权限，我们将应用之前创建的YAMLs，并建立和配置新的服务帐户用户。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="99df" class="kf kg hi jh b fi kh ki l kj kk">kubectl create -f drain-role.yaml<br/>kubectl create -f drain-user.yaml<br/>kubectl create -f drain-binding.yaml</span></pre><p id="32ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要为我们的新服务帐户“drain-user”获取令牌。</p><p id="0bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">kubectl describe serviceAccounts <strong class="ih hj">drain-user</strong></code></p><p id="d5cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这产生了:</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="4395" class="kf kg hi jh b fi kh ki l kj kk">Name:         <strong class="jh hj">drain-user</strong><br/>Namespace:    default<br/>Labels:       &lt;none&gt;<br/>Annotations:  kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","kind":"ServiceAccount","metadata":{"annotations":{},"name":"drain-user","namespace":"default"}}</span><span id="9ca9" class="kf kg hi jh b fi kl ki l kj kk">Image pull secrets:  &lt;none&gt;</span><span id="2363" class="kf kg hi jh b fi kl ki l kj kk">Mountable secrets:   drain-user-token-z9kr6</span><span id="5cb1" class="kf kg hi jh b fi kl ki l kj kk">Tokens:              <strong class="jh hj">drain-user-token-z9kr6</strong></span><span id="c871" class="kf kg hi jh b fi kl ki l kj kk">Events:  &lt;none&gt;</span></pre><p id="c1e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在标记名中添加粗体以示强调。我们需要它用于下一个命令，该命令实际上获取令牌本身。同样，必须注意的是，这个令牌是向您的服务帐户授予权限的。你要确保它的安全。</p><p id="bdce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">kubectl describe secrets <strong class="ih hj">drain-user-token-z9kr6</strong></code></p><p id="429a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要看看由<code class="du je jf jg jh b">gcloud</code>在<code class="du je jf jg jh b">~/.kube/config</code>下创建的文件。我们应该从制作一个副本开始(因为我们不想损坏这个文件并冒失去访问GKE母版的风险)。然后，我们希望删除users部分，并用新获得的服务帐户用户令牌替换它。</p><p id="c739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们最终的<code class="du je jf jg jh b">config</code>文件应该如下所示(秘密编辑):</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="f4e4" class="kf kg hi jh b fi kh ki l kj kk">apiVersion: v1<br/>clusters:<br/>- cluster:<br/>   certificate-authority-data: <strong class="jh hj">REDACTED</strong> # from the original config file<br/>   server: https://<strong class="jh hj">REDACTED</strong> # from the original config file<br/> name: <strong class="jh hj">CLUSTER_NAME</strong> # from the original config file<br/>contexts:<br/>- context:<br/>   cluster: <strong class="jh hj">CLUSTER_NAME</strong> # from the original config file<br/>   user: <strong class="jh hj">CLUSTER_NAME</strong> # from the original config file<br/> name: <strong class="jh hj">CLUSTER_NAME</strong> # from the original config file<br/>current-context: <strong class="jh hj">CLUSTER_NAME</strong> # from the original config file<br/>kind: Config<br/>preferences: {}<br/>users:<br/>- name: <strong class="jh hj">CLUSTER_NAME</strong> # from the original config file<br/> user:<br/>   token: <strong class="jh hj">REDACTED</strong> # from our previous command</span></pre><p id="a6dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保这个文件放在<code class="du je jf jg jh b">~/.kube/config</code>中，这里的主目录是运行<code class="du je jf jg jh b">kubectl</code>的用户的目录。</p><p id="b3d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要基于GKE创建的初始集群创建一个新的GCE实例组，并确保修改启动脚本，以便在启动时也将这个配置文件放置到位。</p><p id="1619" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要获得GKE集群正在使用的实例模板。</p><p id="1531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">gcloud container clusters describe [CLUSTER_NAME] -z [CLUSTER_ZONE]</code></p><p id="16f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要从这个输出中提取实例模板名称(为了强调，添加了粗体)，并在下面的命令中使用它来获取启动和关闭脚本的内容。复制这些脚本至关重要，因为它们为节点与其GKE主机对话奠定了基础。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="5c7b" class="kf kg hi jh b fi kh ki l kj kk">...<br/>  instanceGroupUrls:<br/>    - https://www.googleapis.com/compute/v1/projects/my-gcp-project/zones/us-central1-a/instanceGroupManagers/<strong class="jh hj">my-gke-cluster-group</strong><br/>...</span></pre><p id="f7d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">gcloud compute instance-groups managed describe <strong class="ih hj">my-gke-cluster-group</strong></code></p><p id="1f12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们得到了用于该组的实例模板。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="48e2" class="kf kg hi jh b fi kh ki l kj kk">...<br/>instanceGroup: https://www.googleapis.com/compute/v1/projects/my-gcp-project/zones/us-central1-a/instanceGroups/<strong class="jh hj">my-gke-cluster-group</strong><br/>instanceTemplate: https://www.googleapis.com/compute/v1/projects/my-gcp-project/global/instanceTemplates/<strong class="jh hj">my-gke-cluster-instance-template</strong><br/>kind: compute#instanceGroupManager<br/>...</span></pre><p id="1511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们终于有了实例模板，我们可以获取元数据，包括启动和关闭脚本，以及其他重要的数据。同样，值得注意的是，这些脚本中有许多非常有价值的秘密，因此，它们必须作为密码或任何其他敏感数据来处理。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="fe9d" class="kf kg hi jh b fi kh ki l kj kk">gcloud compute instance-templates describe <strong class="jh hj">my-gke-cluster-instance-template</strong></span></pre><p id="b0ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了我们:</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="e05c" class="kf kg hi jh b fi kh ki l kj kk">...<br/>  metadata:<br/>    fingerprint: <strong class="jh hj">REDACTED</strong><br/>    items:<br/>    - key: cluster-location<br/>      value: us-central1-a<br/>    - key: kube-env<br/>      value: <strong class="jh hj">REDACTED</strong><br/>    - key: google-compute-enable-pcid<br/>      value: 'true'<br/>    - key: user-data<br/>      value: <strong class="jh hj">REDACTED</strong><br/>    - key: gci-update-strategy<br/>      value: update_disabled<br/>    - key: gci-ensure-gke-docker<br/>      value: 'true'<br/>    - key: configure-sh<br/>      value: <strong class="jh hj">REDACTED</strong><br/>    - key: cluster-name<br/>      value: <strong class="jh hj">REDACTED</strong><br/>    kind: compute#metadata<br/>...</span></pre><p id="851d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经有了所有需要的信息，我们可以创建新的GCE实例组，它将包括可抢占的实例、与GKE主机通信所需的所有配置信息、所有必需的伸缩逻辑(下面举例说明)，以及在<code class="du je jf jg jh b">SIGTERM</code>时从可抢占节点中排出pod的能力。</p><p id="49c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，您也可以将元数据指定为文件，这对于非常大或特殊格式的值(如启动脚本)可能有意义。</p><p id="1617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要从<code class="du je jf jg jh b">configure-sh</code>键获取输出，并创建一个包含内容的新文件<code class="du je jf jg jh b">startup.sh</code>。然后，我们需要将以下内容添加到该文件的末尾。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="fb43" class="kf kg hi jh b fi kh ki l kj kk">mkdir ~/.kube<br/>touch ~/.kube/config<br/>echo “<strong class="jh hj">CONTENTS_OF_KUBE_CONFIG</strong>” &gt; ~/.kube/config # this should be the actual config file</span></pre><p id="7558" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要创建我们的关机脚本，我们将保存为<code class="du je jf jg jh b">shutdown.sh</code>。</p><p id="3cd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">kubectl drain `hostname` --force --ignore-daemonsets</code></p><p id="2064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以将它们放在一个实例模板中。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="849e" class="kf kg hi jh b fi kh ki l kj kk">gcloud compute instance-templates create <strong class="jh hj">new-gke-node-template</strong> \<br/>--machine-type=n1-standard-1 \<br/>--<strong class="jh hj">preemptible</strong> \<br/>--image-project=coreos-cloud \<br/>--image-family=coreos-stable \<br/>--metadata cluster-location=us-central1-a,kube-env=<strong class="jh hj">REDACTED</strong>,google-compute-enable-pcid=’true’,user-data=<strong class="jh hj">REDACTED</strong>,gci-update-strategy=update_disabled,gci-ensure-gke-docker=’true’,cluster-name=<strong class="jh hj">REDACTED</strong><br/>--metadata-from-file=configure-sh=<strong class="jh hj">~/path/to/startup.sh</strong>,shutdown-script=<strong class="jh hj">~/path/to/shutdown.sh</strong></span></pre><p id="6c5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有了一个实例模板，它将创建能够与GKE主机通信的实例，并在被谷歌抢占时自动清空。我们的最后一步是基于这个实例模板创建托管实例组，这样我们就可以获得我们想要的伸缩和自我修复。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="f8f2" class="kf kg hi jh b fi kh ki l kj kk">gcloud compute instance-groups managed create <strong class="jh hj">my-new-gke-instance-group</strong> \<br/>--size 5 \<br/>--zone us-central1-a \<br/>--template <strong class="jh hj">my-gke-cluster-instance-template</strong></span><span id="e83c" class="kf kg hi jh b fi kl ki l kj kk">gcloud compute instance-groups managed set-autoscaling <strong class="jh hj">my-new-gke-instance-group</strong> \<br/>--max-num-replicas 40 \<br/>--zone us-central1-a</span></pre><p id="db60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在已经满足了最初的要求。我们有一个可抢占节点的自动扩展实例组，与我们的Google管理的GKE主机通信。节点在<code class="du je jf jg jh b">SIGTERM</code>(手动或自动)时耗尽自己，每个节点只有耗尽的权限，而没有执行任何其他Kubernetes操作的权限。我们的秘密是安全的，只存储在实例模板中(它受到保护GCP数据其余部分的相同安全措施的保护)，一切都由GCP结构集中管理(尽管通过Terraform之类的东西实现自动化会相对简单)。</p><p id="bb67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在能够利用GKE提供的所有优势，同时仍然允许在可抢占的节点下实现最佳成本优化，而不会牺牲状态性！</p></div></div>    
</body>
</html>