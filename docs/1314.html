<html>
<head>
<title>Minimize Dependency Pain in Java Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最小化Java库中的依赖痛苦</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/minimize-dependency-pain-in-java-libraries-f071de45bdfb?source=collection_archive---------1-----------------------#2020-03-05">https://medium.com/google-cloud/minimize-dependency-pain-in-java-libraries-f071de45bdfb?source=collection_archive---------1-----------------------#2020-03-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="93d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谷歌云平台发布了从云资产到云网络安全的数十种产品的客户端库。这些都建立在很多常见的基础设施之上，包括Guava、gRPC和protobufs，以及许多第三方开源项目，如Netty和Jaxen。GCP邻近的项目，如阿帕奇梁和春云GCP扩大范围和复杂性更进一步。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/eb04e393d5c2f6bc335dc911129f9a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*zSl51o1fjg00NuXz6aQwQQ.png"/></div></figure><p id="e9b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同时区的不同团队和数百名开发人员构建了这些库。确保我们发布的最新版本的库能够无冲突地协同工作是一件大事。</p><p id="9b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过我们从为客户开发和维护我们自己的库中学到的经验，我们已经开发了一组最佳实践，用于避免基于Maven材料清单(BOMs)和语义版本控制的Java库中的不兼容性。这些实践与任何发布其他Java项目所依赖的库的人相关。我们现在发布这些<a class="ae jl" href="https://jlbp.dev/" rel="noopener ugc nofollow" target="_blank">Google Java库最佳实践</a>:</p><ul class=""><li id="28b4" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-1.html" rel="noopener ugc nofollow" target="_blank"> JLBP-1 </a>:最小化依赖性</li><li id="f027" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-2.html" rel="noopener ugc nofollow" target="_blank"> JLBP-2 </a>:最小化API面</li><li id="7b35" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">JLBP-3 :使用语义版本控制</li><li id="e5b1" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-4.html" rel="noopener ugc nofollow" target="_blank"> JLBP-4 </a>:避免依赖不稳定的库和特性</li><li id="f2de" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-5.html" rel="noopener ugc nofollow" target="_blank"> JLBP-5 </a>:避免与其他依赖项的类重叠的依赖项</li><li id="49cd" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-6.html" rel="noopener ugc nofollow" target="_blank"> JLBP-6 </a>:一起重命名工件和包</li><li id="6843" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-7.html" rel="noopener ugc nofollow" target="_blank"> JLBP-7 </a>:让突破过渡变得容易</li><li id="0078" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">JLBP-8:将广泛使用的功能升级到稳定版本</li><li id="f33f" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-9.html" rel="noopener ugc nofollow" target="_blank"> JLBP-9 </a>:支持您的消费者的最低Java版本</li><li id="179b" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-10.html" rel="noopener ugc nofollow" target="_blank"> JLBP-10 </a>:只要消费者需要，就保持API的稳定性</li><li id="f2c3" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated">JLBP 11号:与兼容的依赖项保持同步</li><li id="9083" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-12.html" rel="noopener ugc nofollow" target="_blank"> JLBP-12 </a>:明确支持水平和API稳定性</li><li id="4a85" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-13.html" rel="noopener ugc nofollow" target="_blank"> JLBP-13 </a>:快速删除依赖关系中对已弃用功能的引用</li><li id="1ba4" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-14.html" rel="noopener ugc nofollow" target="_blank"> JLBP-14 </a>:为每个依赖项指定一个单一的、可覆盖的版本</li><li id="2b9b" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-15.html" rel="noopener ugc nofollow" target="_blank"> JLBP-15 </a>:为多模块项目制作BOM</li><li id="d12b" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-16.html" rel="noopener ugc nofollow" target="_blank"> JLBP-16 </a>:确保消费者的依赖关系的高版本一致性</li><li id="0512" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-17.html" rel="noopener ugc nofollow" target="_blank"> JLBP-17 </a>:协调重大变更的首次展示</li><li id="4b6d" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-18.html" rel="noopener ugc nofollow" target="_blank"> JLBP-18 </a>:只有在万不得已的情况下才遮蔽依赖</li><li id="8e04" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-19.html" rel="noopener ugc nofollow" target="_blank"> JLBP-19 </a>:将每个包装放入一个模块中</li><li id="0328" class="jm jn hi ih b ii jv im jw iq jx iu jy iy jz jc jr js jt ju bi translated"><a class="ae jl" href="https://jlbp.dev/JLBP-20.html" rel="noopener ugc nofollow" target="_blank"> JLBP-20 </a>:给每个罐子一个模块名</li></ul><p id="d7a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这20个实践描述了如何组织一个库和它自己的依赖项，这样开发人员可以很容易地在他们自己的项目中采用它们，而没有冲突和链接错误。我将在这里总结三个最重要的实践:</p><h1 id="f0fa" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">最大限度地减少依赖性(<a class="ae jl" href="https://jlbp.dev/JLBP-1.html" rel="noopener ugc nofollow" target="_blank"> JLBP-1 </a></h1><p id="4a55" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">每个库应该尽可能少地添加到它的从属类路径中，理想的情况是除了它自己什么也不添加。为困难和复杂的事情添加依赖项可能是一种可以接受的折衷，但是避免仅仅为了节省几行代码而添加依赖项。库的每个依赖项也是库的消费者的依赖项，增加了版本冲突和安全漏洞的风险。</p><p id="5ad7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他19个最佳实践涵盖了减轻过度依赖影响的技术，但是没有什么比完全消除依赖更有效的了。</p><h1 id="67d8" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">发布和消费物料清单(<a class="ae jl" href="https://jlbp.dev/JLBP-15.html" rel="noopener ugc nofollow" target="_blank"> JLBP-15 </a>)</h1><p id="ed1a" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">有时大型依赖树是不可避免的；例如，当编写一个Kubernetes应用程序来集成多个GCP产品时，比如BigQuery、Cloud Datastore、Cloud Translate和TensorFlow。您的项目需要为其中的每一项及其所有依赖项提供客户端库。</p><p id="7472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要试图挑选这样一个项目所依赖的几十个工件的版本，<a class="ae jl" href="https://github.com/GoogleCloudPlatform/cloud-opensource-java/blob/master/DECLARING_DEPENDENCIES.md" rel="noopener ugc nofollow" target="_blank">导入一个BOM并让它为你挑选版本</a>。例如，<strong class="ih hj">com . Google . Cloud:libraries-BOM</strong>保证了Google Cloud Java orbit中所有工件的一致版本，这些工件协同工作，彼此不冲突。BOM使得更新到新版本更加简单，因为你只需要更新一个工件，而不是几十个独立的和潜在冲突的工件。</p><p id="9b5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您发布自己的复杂、多模块库时，也要发布BOM并建议您的客户导入它。如果产品非常依赖于其他库，您可能也希望将这些库包含在BOM中。让依赖者在类路径中拥有一致的版本变得容易。</p><h1 id="84ba" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">语义版本化是你的朋友(<a class="ae jl" href="https://jlbp.dev/JLBP-3.html" rel="noopener ugc nofollow" target="_blank"> JLBP-3 </a>)</h1><p id="d1e9" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">一旦你发布了(<a class="ae jl" href="https://jlbp.dev/JLBP-8.html" rel="noopener ugc nofollow" target="_blank"> JLBP-8 </a>、<a class="ae jl" href="https://jlbp.dev/JLBP-10.html" rel="noopener ugc nofollow" target="_blank"> JLBP-10 </a>和<a class="ae jl" href="https://jlbp.dev/JLBP-12.html" rel="noopener ugc nofollow" target="_blank"> JLBP-12 </a>)，就要非常非常努力地避免引入不兼容性，但是当没有其他选择时，就增加主要版本。当你引入一个新特性时，删除次要版本。为其他所有东西添加补丁版本。<a class="ae jl" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">SEM ver规范</a>列出了细节。</p><p id="d7f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可供开发者选择的第三方库的广度和深度是Java生态系统的主要优势之一。然而，太多的选择会带来自身的问题。仔细考虑您依赖哪个库以及依赖多少个库。当你发布一个库的时候，注意不要增加消费者的依赖性问题。学习并遵循这20个最佳实践可以让你为你的用户提供一个顺利的、没有问题的途径来采用你的库。</p></div></div>    
</body>
</html>