<html>
<head>
<title>Running a serverless batch workload on GCP with Cloud Scheduler — Adding Docker and Container Registry to the mix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云调度程序在GCP上运行无服务器批处理工作负载——将Docker和容器注册添加到组合中</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/serverless-batch-workload-on-gcp-adding-docker-and-container-registry-to-the-mix-558f925e1de1?source=collection_archive---------0-----------------------#2019-09-11">https://medium.com/google-cloud/serverless-batch-workload-on-gcp-adding-docker-and-container-registry-to-the-mix-558f925e1de1?source=collection_archive---------0-----------------------#2019-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ca78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本快速入门指南是一个系列的一部分，展示了如何利用Google云平台组件以更简单的方式运行批处理工作负载。</p><p id="9ba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在开始之前需要一些背景知识，<a class="ae jd" rel="noopener" href="/google-cloud/running-a-serverless-batch-workload-on-gcp-with-cloud-scheduler-cloud-functions-and-compute-86c2bd573f25">请看看本系列的第一部分</a>，我描述了让批处理工作负载运行的架构。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="6c4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我介绍一下我们这次使用<strong class="ih hj"> GCP </strong>组件来运行批处理工作负载的解决方案:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es jl"><img src="../Images/2ef7565d62528c434aceed4336b75d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*uP9k-kBDzlzawL6Y96q6xQ.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图一。预定批处理体系结构</figcaption></figure><blockquote class="jx jy jz"><p id="4bb3" class="if ig ka ih b ii ij ik il im in io ip kb ir is it kc iv iw ix kd iz ja jb jc hb bi translated">如果你读了第一部分，你会注意到我们有两个新的玩家，容器注册和Docker。</p></blockquote><p id="b804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文的亮点将是容器注册和Docker，它将使我们能够运行更复杂的批处理作业，我们将在后面详细讨论它…</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ke"><img src="../Images/915baf51ed36233b048606dea19f5bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfsBX-a9lfXDZ6XAb833BA.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图二。海绵宝宝盯着一个容器</figcaption></figure><p id="a253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多文章都在讨论使用容器注册表…你为什么要读这篇文章呢？<br/>与其展示命令行和比较方法，我想向您展示一个工作示例，展示如何围绕您的批处理工作负载构建一个持续集成并自动化一切！</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kj"><img src="../Images/35d31cb58f604d5d51ea672de1cd020b.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*ebym7oKt0nMVIXp_nhATVQ.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图3。巴斯光年告诉伍迪自动化一切</figcaption></figure><p id="8b3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本帖涵盖的主题将是:</p><ol class=""><li id="c6ec" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated">批处理工作量</li><li id="0a70" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">连接到源存储库</li><li id="db98" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">设置批处理工作负载入口点</li><li id="1e7d" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">批处理工作量执行说明</li></ol><p id="d8ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事不宜迟，我们走吧！</p><blockquote class="jx jy jz"><p id="bf4c" class="if ig ka ih b ii ij ik il im in io ip kb ir is it kc iv iw ix kd iz ja jb jc hb bi translated">您将获得一个带有工作示例的github存储库。</p></blockquote></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="43a1" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1-批处理工作负荷</h1><p id="2f6f" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">作为更复杂的批处理工作负载的候选，我选择了一个组合<a class="ae jd" href="https://github.com/behave/behave" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">behavior</strong></a>，这是一个用于运行BDD技术的python库，以及<a class="ae jd" href="https://www.alphavantage.co/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> alphavantage </strong> </a>:一组用于股票、外汇(FX)和数字/加密货币的实时和历史数据的免费API。</p><p id="5682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GitHub仓库的代码是:<a class="ae jd" href="https://github.com/mesmacosta/alpha_vantage_bdd" rel="noopener ugc nofollow" target="_blank"> alpha_vantage_bdd </a></p><p id="d3ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，让我们来看看将要执行的场景:</p><div class="jm jn jo jp fd ab cb"><figure class="mb jq mc md me mf mg paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/6f5c2c12aa0185fa753a46c6a0bb0f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*2988zAgSou3jbfksR51TnA.png"/></div></figure><figure class="mb jq mh md me mf mg paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/00fffcd6bc07011e15bb6b3704f53896.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*O2RHgDpe_FVXPmwMlkR0qg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx mi di mj mk translated">图4。具有将被执行的场景的特征文件</figcaption></figure></div><p id="5417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过在目录的根目录下运行命令:</p><p id="66af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ml mm mn mo b">behave features/ --tags=-wip</code></p><p id="05ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该会看到以下输出:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mp"><img src="../Images/c7c24f43c70e44814cc844dd726e5279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUdbXjV1x32nElQy9cawBw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图5。显示行为执行结果的终端</figcaption></figure><p id="f766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这真的很酷，但这是一个本地执行，我们如何将这些代码发送到我们的Google Cloud项目并在那里运行批处理工作负载？</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es mq"><img src="../Images/b7830237a7b488df04abe8190c580c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Zv0hpjbZziG7YsjT9PKaYg.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图6。一个处于守势的人，说代码在他们的机器上工作</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="4d1a" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2-连接到源存储库</h1><p id="3f7c" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">我们将使用源代码库将我们的git工作流扩展到GCP。</p><p id="e963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ka">“云资源存储库是功能齐全的私有Git存储库，托管在Google云平台上。</em> <em class="ka">通过连接到其他GCP工具，包括云构建、应用引擎、Stackdriver和云发布/订阅，扩展您的Git工作流。”</em></p><p id="7aac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到<a class="ae jd" href="https://source.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">该页面</a>启动您的源存储库配置。一旦你选择了你的库名，在这个例子中是alpha_vantage_bdd，从本地Git库中选择Push code，那么将会有3个选项来推送你的代码，我选择了Google Cloud SDK。<br/>按照显示的说明进行操作:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mr"><img src="../Images/e1f3e4f4764c2e33bde30f67cbafb9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l31k24BHRpSc7KciBuBdRw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图7。源Repo UI —将代码添加到存储库中</figcaption></figure><p id="c9c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们所做的是将我们的Github存储库:<a class="ae jd" href="https://github.com/mesmacosta/alpha_vantage_bdd" rel="noopener ugc nofollow" target="_blank"> alpha_vantage_bdd </a>推送到一个云资源存储库，它位于我们的Google Cloud项目中。云源回购作为我们的原始回购的远程回购。</p><p id="3060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您键入了类似下面的命令:<br/> <code class="du ml mm mn mo b">git remote add google https://source.developers.google.com/p/my_project/r/alpha_vantage_bdd<br/>git push google master</code></p><p id="024e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推送至源存储库后，您将能够看到以下内容:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ms"><img src="../Images/cb99b1f6e9f8926f8e3d64da830deec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAsxnSHMWG2-ONyRjbIe8Q.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图8。源存储库UI —显示创建的存储库</figcaption></figure><blockquote class="jx jy jz"><p id="5487" class="if ig ka ih b ii ij ik il im in io ip kb ir is it kc iv iw ix kd iz ja jb jc hb bi translated">按照这个<a class="ae jd" href="https://cloud.google.com/source-repositories/docs/mirroring-a-github-repository#connect_to_github" rel="noopener ugc nofollow" target="_blank">指南</a>，你可以直接镜像你的github，而不是把它作为一个远程存储库，但是我还是更喜欢把它作为一个远程存储库来使用，看看那些公开的问题:<a class="ae jd" href="https://issuetracker.google.com/issues/73122477" rel="noopener ugc nofollow" target="_blank"> 73122477 </a>和<a class="ae jd" href="https://issuetracker.google.com/issues/133100479" rel="noopener ugc nofollow" target="_blank"> 133100479 </a>。</p></blockquote></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="30e1" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3 —设置批处理工作负载入口点</h1><p id="5720" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">现在我们已经有了GCP内部的代码，我们将为它构建一个Docker映像。这是Dockerfile文件:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="12ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重要的文件是将在Docker的入口点执行的脚本:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="f4da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当Docker容器运行时(在我们的例子中是在计算引擎创建时)，这个入口点将执行behave命令，然后将输出发送到Stackdriver Logging。完成后，虚拟机将被删除。</p><blockquote class="jx jy jz"><p id="96f4" class="if ig ka ih b ii ij ik il im in io ip kb ir is it kc iv iw ix kd iz ja jb jc hb bi translated">很有趣…但是自动化，自动化一切的行话呢？我们如何自动构建这个Docker映像？</p></blockquote><p id="a36d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将为此使用云构建，这就是容器注册将加入游戏的地方！</p><p id="1ea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ka">“云构建让你可以快速构建跨所有语言的软件。全面控制自定义工作流的定义，以便在虚拟机、无服务器、Kubernetes或Firebase等多种环境中进行构建、测试和部署。”</em></p><p id="97d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看云构建的构建流程:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mv"><img src="../Images/89a48391a243c6bcfe5e123b9bdf69ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6isONxRUuhJ5_yCzGTgiw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图9。更新批处理代码架构</figcaption></figure><p id="faeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1 —代码被推送到云源代码库。每当对我们之前配置的原始repo执行<code class="du ml mm mn mo b">git push google master</code>时，就会发生这种情况。</p><p id="b6b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2 —云构建由主分支上的提交触发。</p><p id="217f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3 —云构建将docker映像打包并存储在云存储中。</p><p id="2439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4 —图像在<strong class="ih hj">容器注册表</strong>中被标记为最新版本。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="69b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，请转到<a class="ae jd" href="https://console.cloud.google.com/cloud-build/" rel="noopener ugc nofollow" target="_blank">页面</a>开始云构建配置:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es mw"><img src="../Images/d0e44d6160fa34ac089c3022f41daa71.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*pssUKEkKwjMLSHwtG84aIQ.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图10。云构建UI，显示图像名称</figcaption></figure><p id="5e6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择已创建的源存储库，这就很简单了，我们将所有字段保留默认值，但保留图像名称。我们使用Dockerfile作为构建配置，并用<code class="du ml mm mn mo b">:latest</code>标签对其进行标记，因此我们总是可以获得代码的最新图像。</p><blockquote class="jx jy jz"><p id="0be3" class="if ig ka ih b ii ij ik il im in io ip kb ir is it kc iv iw ix kd iz ja jb jc hb bi translated">不要担心，Cloud Build会为您存储以前的映像，以防您需要快速回滚。</p></blockquote><p id="cd23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们按下创建触发器，云构建将连接到我们的源存储库:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mx"><img src="../Images/c459a48f4d55c9e8b82fdaa500581943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmRj8td8jC0ECJ2ax8TOKA.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图11。构建触发器UI，显示成功创建的触发器</figcaption></figure><p id="9d49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过按下Run trigger来测试触发器，一旦完成，我们的Docker图像将显示在容器注册表上:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es my"><img src="../Images/595f917b177f25e070d07ea15b611a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3v1gEarbxDeW4VijS1mjw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图12。容器注册UI，显示创建的Docker图像</figcaption></figure><p id="2638" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，它标有<strong class="ih hj">最新</strong>，这将保证我们在计算引擎虚拟机上始终拥有最新的Docker映像！</p><h1 id="b046" class="ky kz hi bd la lb mz ld le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv bi translated">4 —批处理工作负载执行说明</h1><p id="28a4" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">现在我们已经有了容器注册表中的Docker映像，这是小菜一碟，还记得我们在<a class="ae jd" rel="noopener" href="/google-cloud/running-a-serverless-batch-workload-on-gcp-with-cloud-scheduler-cloud-functions-and-compute-86c2bd573f25">第一篇文章</a>中使用的云函数吗？我们将再次使用它！我们将只更改计算引擎配置，但首先让我向您展示执行流程:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es ne"><img src="../Images/9b83cb3305ce577fef7314793c116351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*j4N6KY-VdsvXI-DX-C0eZQ.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图13。详细执行</figcaption></figure><p id="ef6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1 —云功能由发布/订阅触发，并调用计算引擎API来创建虚拟机</p><p id="cac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2 —计算引擎从容器注册表中检索最新映像，并启动虚拟机</p><p id="fec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3—VM入口点启动批处理进程，运行Alpha Vantage API的自动化测试</p><p id="ae9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦自动化测试完成，输出就被发送到Stackdriver Logging。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="48db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更新上一篇文章中的云功能，让我们改变计算引擎的配置，进入<a class="ae jd" href="https://console.cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank">这一页</a>。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es nf"><img src="../Images/d1cb340f83989844dde51105513ac8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*RlL3BYI-sFjAhEzrgSIjgw.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图14。计算引擎UI，显示配置</figcaption></figure><p id="2ec0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择“将容器映像部署到此虚拟机实例”复选框，如果您有兴趣，可以单击“了解更多信息链接”。<br/>对于容器图像，我们将使用在前面步骤中创建的图像，它存储在容器注册表中。这很重要，记得使用语法<code class="du ml mm mn mo b">:latest</code>以便我们检索最新的图像。</p><p id="ee10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在UI的底部，单击等价的Rest链接，这样我们就可以获得将在我们的云功能中使用的配置。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es ng"><img src="../Images/2cd9534322ff36430a6cfab42d246ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*zGQFttXMOyQZXpzzdyqo9g.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图14。等效的Rest请求弹出窗口，显示虚拟机配置</figcaption></figure><p id="736a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们有了它，转到<a class="ae jd" href="https://console.cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云函数</a> UI，并更新<code class="du ml mm mn mo b">vmConfig</code>变量，用新的<strong class="ih hj">GCE-container-declaration</strong>配置替换启动脚本，这就是我们的代码看起来的样子:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="fb25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，点击部署按钮，我们就准备好了！</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="d78a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们现在回到我们的<a class="ae jd" href="https://console.cloud.google.com/cloudscheduler" rel="noopener ugc nofollow" target="_blank">云调度作业</a>，并手动触发它，我们可以看到一切都在一起工作。</p><blockquote class="jx jy jz"><p id="14f8" class="if ig ka ih b ii ij ik il im in io ip kb ir is it kc iv iw ix kd iz ja jb jc hb bi translated">请记住，这样做将发布到我们的发布/订阅主题，这将启动我们的执行流程。</p></blockquote><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es nh"><img src="../Images/b2b9745dbb71ffe418db36a939824713.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/1*HChDmaUFBcqct2QqcWRb0Q.gif"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图15。引擎运行</figcaption></figure><p id="1b26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按“立即运行”按钮:</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ni"><img src="../Images/5a185c50ac876400fcf801b24a4878f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKx4PUdF9KlxSBfmSBkSrg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图16。云调度程序UI，显示“立即运行”按钮</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="fccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几秒钟后转到计算引擎<a class="ae jd" href="https://console.cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank">页面</a>，您会看到一个新的虚拟机正在运行，前缀为<strong class="ih hj"> batch-job-executor </strong>后跟执行时间，这是一个小技巧，因此我们总是有一个唯一的名称，如果我们需要在以后跟踪问题的话。</p><div class="jm jn jo jp fd ab cb"><figure class="mb jq nj md me mf mg paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/56d3f7e4104b2c48de0ba03f4f76eeb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*87c8nJGy34Z56toDgcXvXg.png"/></div></figure><figure class="mb jq nk md me mf mg paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><img src="../Images/5a2909cbba30ce350219656b2c68cb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*BhuYo5nmaHj41cYKiSmn1w.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx nl di nm mk translated">图17。计算引擎用户界面。在左侧创建了虚拟机。右边的虚拟机逐渐消失</figcaption></figure></div><p id="a6c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几秒钟后，您会看到虚拟机名称前的图标发生了变化，这是因为虚拟机正在被删除，一旦删除完成，虚拟机将从实例页面中消失。</p><p id="8536" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，为了确保它确实做了一些事情，我们将进入Stackdriver Logging <a class="ae jd" href="https://console.cloud.google.com/logs" rel="noopener ugc nofollow" target="_blank">页面</a>，当我们过滤虚拟机名称时，我们可以看到带有<strong class="ih hj">容器注册表</strong>映像的虚拟机的结果！👌🏻</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es nn"><img src="../Images/2dee9367e00b37865a12b2b2f03c87df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5j5cbLhRLvyDBE14vZunw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图18。Stackdriver日志记录UI，显示执行结果</figcaption></figure><p id="0dc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一件事！为了展示我们持续的集成工作，每当我们做一个<code class="du ml mm mn mo b">git push google master</code>，云构建将运行并为我们创建一个新的容器注册表映像，用latest标记它。在下图中，您可以看到只有最新的图像标记为最新，这意味着下次云调度程序运行时，它将获得新版本！</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es no"><img src="../Images/81dab7826e969e6751a7bad8aa1611f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SVOgO-no1oBBWX0i_TkfQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图19。容器注册用户界面，显示3个图像，最近的一个标记为最新的</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="b9dd" class="ky kz hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">今天就到这里吧！</h1><p id="919a" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">这是展示如何使用Google云平台以更简单的方式运行批量工作负载的系列文章的第二篇。</p><p id="701a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们展示了一个更复杂的批处理工作负载来帮助您开始，为了能够轻松地更新批处理工作负载，我们使用了Google Source Repositories、Cloud Build、Container Registry和Docker的组合。</p><p id="bbf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的宝贵时间！请继续关注下一篇文章，我们将再次连接Pub/Sub，以分离我们的批处理工作负载结果，并向您展示如何向Google Chat发送通知！干杯！</p><h1 id="056a" class="ky kz hi bd la lb mz ld le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv bi translated">参考</h1><ul class=""><li id="d087" class="kk kl hi ih b ii lw im lx iq np iu nq iy nr jc ns kq kr ks bi translated"><strong class="ih hj"> Github资源库</strong>:<a class="ae jd" href="https://github.com/mesmacosta/alpha_vantage_bdd" rel="noopener ugc nofollow" target="_blank">https://github.com/mesmacosta/alpha_vantage_bdd</a></li><li id="742b" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc ns kq kr ks bi translated"><strong class="ih hj">谷歌源代码库</strong>:<a class="ae jd" href="https://cloud.google.com/source-repositories/" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/source-repositories/</a></li><li id="b124" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc ns kq kr ks bi translated"><strong class="ih hj">谷歌容器注册表</strong>:<a class="ae jd" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/container-registry/</a></li><li id="fc06" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc ns kq kr ks bi translated"><strong class="ih hj">谷歌云构建</strong>:<a class="ae jd" href="https://cloud.google.com/cloud-build/" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/cloud-build/</a></li><li id="a535" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc ns kq kr ks bi translated"><strong class="ih hj">阿尔法Vantage Python</strong>:<a class="ae jd" href="https://github.com/RomelTorres/alpha_vantage" rel="noopener ugc nofollow" target="_blank">https://github.com/RomelTorres/alpha_vantage</a></li></ul></div></div>    
</body>
</html>