<html>
<head>
<title>What can we learn from million lines of Apache Groovy code on Github?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们能从Github上的数百万行Apache Groovy代码中学到什么？</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/what-can-we-learn-from-million-lines-of-apache-groovy-code-on-github-3151249a17b1?source=collection_archive---------0-----------------------#2017-01-17">https://medium.com/google-cloud/what-can-we-learn-from-million-lines-of-apache-groovy-code-on-github-3151249a17b1?source=collection_archive---------0-----------------------#2017-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4bdc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">最初发布于2016年7月6日<a class="ae ix" href="http://glaforge.appspot.com/article/what-can-we-learn-from-million-lines-of-groovy-code-on-github" rel="noopener ugc nofollow" target="_blank">glaforge.appspot.com</a></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/cf4598f40831bd6ffd6e2bf176b7e2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ab21G7eBVfWLvnaniOvd_Q.png"/></div></div></figure><p id="f047" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Github和Google最近宣布并向BigQuery发布了Github archive，解放了多种编程语言源代码的庞大数据集，并使查询它和发现一些见解变得更加容易。</p><p id="4632" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Github解释说<a class="ae ix" href="https://github.com/blog/2201-making-open-source-data-more-available" rel="noopener ugc nofollow" target="_blank">数据集包含超过3tb的数据</a>，对于280万个存储库，1.45亿个提交超过20亿个文件路径！<a class="ae ix" href="https://cloudplatform.googleblog.com/" rel="noopener ugc nofollow" target="_blank">的谷歌云平台博客</a>给出了一些<a class="ae ix" href="https://cloudplatform.googleblog.com/2016/06/GitHub-on-BigQuery-analyze-all-the-open-source-code.html" rel="noopener ugc nofollow" target="_blank">附加指针</a>来提示BigQuery的查询功能可以做些什么。此外，您可以查看<a class="ae ix" href="https://cloud.google.com/bigquery/public-data/github" rel="noopener ugc nofollow" target="_blank">入门指南</a>，了解使用数据集的步骤。</p><p id="2e43" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我的同事Felipe给出了一些关于顶级编程语言或许可证的有趣统计数据，而Francesc对Go库做了一些有趣的分析。所以我很好奇自己调查这个数据集来运行一些关于Apache Groovy编程语言的查询！</p><p id="c2ab" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">事不宜迟，我们开始吧！</p><p id="e974" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">如果你还没有谷歌云平台的账户，你将能够获得免费试用版，价值300美元的信用点数来发现和享受该平台的所有产品和服务。然后，一定要看看我上面提到的<a class="ae ix" href="https://cloud.google.com/bigquery/public-data/github#github" rel="noopener ugc nofollow" target="_blank"> Github数据集入门指南</a>，它可以给你一些尝试的想法，以及开始修补数据的相关步骤。</p><p id="5d76" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在Google Cloud Platform <a class="ae ix" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">控制台</a>中，我创建了一个空项目(对我来说，称为“github-groovy-files”)，它将托管我的项目和整个数据集的子集，只关注Apache Groovy源文件。</p><p id="8b8d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">接下来可以去BigQuery上的Github公共数据集:<br/><a class="ae ix" href="https://bigquery.cloud.google.com/dataset/bigquery-public-data:github_repos" rel="noopener ugc nofollow" target="_blank">https://big query . cloud . Google . com/dataset/big query-public-data:Github _ repos</a></p><p id="ac76" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我创建了一个名为“github”的新数据集，它的位置在美国(默认)。确保在美国保留默认位置，因为Github数据集已经在那个地区了。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es kg"><img src="../Images/3ac77f070620562d0638f66a7366ae77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7EMQCsOmiqqickBv.png"/></div></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es kh"><img src="../Images/21d1468e7aaf24dc6fd75845eee1eac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EeCv8tg3GNoHYcNk.png"/></div></div></figure><p id="28db" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我启动了以下查询来列出所有Apache Groovy源文件，并将它们保存在一个名为“files”的新表中，以供进一步查询:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="5ee2" class="kn ko hi kj b fi kp kq l kr ks">SELECT * FROM [bigquery-public-data:github_repos.files] <br/>WHERE RIGHT(path, 7) = '.groovy'</span></pre><p id="d649" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在我有了自己的数据集子集，其中只有Apache Groovy文件，我运行了一个count查询来了解可用的Apache Groovy文件的数量:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="593f" class="kn ko hi kj b fi kp kq l kr ks">SELECT COUNT(*) <br/>FROM [github-groovy-files:github.files]</span></pre><p id="4dee" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">还有Apache Groovy源文件的<strong class="jm hj"> 743 070！</strong></p><p id="4a05" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我很好奇是否有一些Apache Groovy脚本和类的通用名称会比其他名称出现得更频繁:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="75a9" class="kn ko hi kj b fi kp kq l kr ks">SELECT TOP(filename, 24), COUNT(*) as n <br/>FROM ( <br/>  SELECT LAST(SPLIT(path, '/')) as filename <br/>  FROM [github.files] <br/>)</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kt"><img src="../Images/1d07aeb3c70a353a160b611ef1e8fde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/0*i2C6KOClWjFSTaAn.png"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ku"><img src="../Images/b1c15a6a4af45ee9629bd5afb991d408.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/0*ASvyKRXI1HxY8cgQ.png"/></div></figure><p id="4c07" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我惊讶地发现. groovy是最常见的文件名！我还没有深入研究，但我很想看看那些A.groovy文件中有什么，以及分别位于第4位和第13位的B.groovy或a.groovy。</p><p id="39db" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Apache Groovy 经常用于各种自动化任务，我发现许多Maven或Jenkins脚本检查某个任务或作业是否正确终止，这要感谢名为verify.groovy的脚本。</p><p id="4f1d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">像BuildConfig.groovy、Config.groovy、UrlMappings.groovy、DataSource.groovy、BootStrap.groovy这样的文件显然来自于在<a class="ae ix" href="https://grails.org/" rel="noopener ugc nofollow" target="_blank"> Grails framework </a> web应用程序中找到的常见文件。</p><p id="ba39" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">还可以看到类似logback.groovy的配置文件来配置logback日志库。</p><p id="cc6e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">您在这里看不到<a class="ae ix" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>构建自动化工具的用法，因为我只选择了扩展名为. groovy的文件，而没有选择扩展名为。格拉德扩展。但是我们一会儿会回到格雷尔。</p><p id="0340" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">到目前为止，我们只看了文件名，没有看它们的内容。这就是我们需要另一个表的地方，它来自数据集的“contents”表，我们将根据保存在“files”表中的文件名对它进行过滤，这要归功于以下查询:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="0a0e" class="kn ko hi kj b fi kp kq l kr ks">SELECT * FROM [bigquery-public-data:github_repos.contents] <br/>WHERE id IN (<br/>    SELECT id FROM [github.files]<br/>)</span></pre><p id="a30d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">由于这是大量的内容，我必须将查询结果保存在一个名为“contents”的新表中，并且我必须选中选项窗格中的“allow large results ”(允许大的结果),由于查询编辑器下方的“Show options”按钮，您可以打开该选项窗格。</p><p id="2983" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">从743 070文件中，你认为其中有多少行Apache Groovy代码？为此，我们需要将文件的原始内容按行分割，如下所示:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="bcfa" class="kn ko hi kj b fi kp kq l kr ks">SELECT COUNT(line) total_lines <br/>FROM ( <br/>  SELECT SPLIT(content, '\n') AS line <br/>  FROM [github-groovy-files:github.contents] <br/>)</span></pre><p id="3ea8" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们在743，070个Apache Groovy文件中有16，464，376行代码。每个文件平均22行，这是相当低的！绘制一些直方图来查看这些代码行的分布会更有趣。我们可以使用<a class="ae ix" href="https://en.wikipedia.org/wiki/Quantile" rel="noopener ugc nofollow" target="_blank">分位数</a>来更好地理解这个具有10个分位数的查询的分布情况:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="236b" class="kn ko hi kj b fi kp kq l kr ks">SELECT QUANTILES(total_lines, 10) AS q <br/>FROM ( <br/>  SELECT COUNT(line) total_lines <br/>  FROM ( <br/>    SELECT SPLIT(content, '\n') AS line, id <br/>    FROM [github-groovy-files:github.contents] <br/>  ) <br/>  GROUP BY id <br/>)</span></pre><p id="b66e" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这给出了这个结果表:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kv"><img src="../Images/78cf9c4f4242c930365589af41d37270.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/0*sy88nwR_kdNRHbJZ.png"/></div></figure><p id="58c2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">有0行代码的文件！而且最大的一个是<strong class="jm hj"> 9506线长</strong>！10%是11行或更少，一半是37行或更少，等等。10%长于149行。</p><p id="c57f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在让我们换换口味，看看包和导入。</p><p id="9b80" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">你知道最常用的包是什么吗？</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="d878" class="kn ko hi kj b fi kp kq l kr ks">SELECT package, COUNT(*) count <br/>FROM ( <br/>  SELECT REGEXP_EXTRACT(line, r' ([a-z0-9\._]*)\.') package, id <br/>  FROM ( <br/>    SELECT SPLIT(content, '\n') line, id <br/>    FROM [github-groovy-files:github.contents] <br/>    WHERE content CONTAINS 'import' <br/>    HAVING LEFT(line, 6)='import' <br/>  ) <br/>  GROUP BY package, id <br/>) <br/>GROUP BY 1 <br/>ORDER BY count DESC <br/>LIMIT 30;</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es kw"><img src="../Images/6dce7449f7a481584367330169792c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zx7cr2Y_M99Qb0MG.png"/></div></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kx"><img src="../Images/258e73f7b3c66e0fae8d233290c37199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/0*vUXwcW1W8NUGqfXk.png"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ky"><img src="../Images/db16737c180ea17b982be31a35590eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*i7A72MqhUuEC3UFa.png"/></div></figure><p id="ea61" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><a class="ae ix" href="http://docs.spockframework.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hj"> Spock </strong> </a> <strong class="jm hj">和JUnit测试框架是使用最广泛的包</strong>，可见Groovy被大量用于测试！我们也看到了很多与Grails相关的包，还有一些日志，一些Spring，Joda-Time，Java util-concurrent或者servlets等等。</p><p id="24c1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们可以放大照片。*包含以下内容的包装:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="ba05" class="kn ko hi kj b fi kp kq l kr ks">SELECT package, COUNT(*) count <br/>FROM ( <br/>  SELECT REGEXP_EXTRACT(line, r' ([a-z0-9\._]*)\.') package, id <br/>  FROM ( <br/>    SELECT SPLIT(content, '\n') line, id <br/>    FROM [github-groovy-files:github.contents] <br/>    WHERE content CONTAINS 'import' <br/>    HAVING LEFT(line, 6)='import' <br/>  ) <br/>  GROUP BY package, id <br/>) <br/>WHERE package LIKE 'groovy.%' <br/>GROUP BY 1 <br/>ORDER BY count DESC <br/>LIMIT 10;</span></pre><p id="04c5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">毫无疑问,' groovy.transform '是赢家，因为它是所有Apache Groovy AST转换所在的地方，提供了有用的代码生成功能，使开发人员不必为常见任务编写乏味的重复代码(@Immutable、@Delegate等)。)在转换之后是用于日志记录的“groovy.util.logging ”,用于处理json文件的“groovy.json ”,用于通过JDBC与数据库交互的“groovy.sql ”,用于解析和生成xml有效负载的“groovy.xml ”,以及用于模板引擎的“groovy.text ”:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kz"><img src="../Images/c35cdf1c2a05b9d79a856f3906688106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/0*nKMCVXAtW9nzpfSg.png"/></div></figure><p id="fbfc" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">由于Apache Groovy AST转换如此突出，我们还可以看看最常用的AST转换:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="8079" class="kn ko hi kj b fi kp kq l kr ks">SELECT TOP(class_name, 10) class_name, COUNT(*) count <br/>FROM ( <br/>  SELECT REGEXP_EXTRACT(line, r' [a-z0-9\._]*\.([a-zA-Z0-9_]*)') class_name, id <br/>  FROM ( <br/>    SELECT SPLIT(content, '\n') line, id <br/>    FROM [github-groovy-files:github.contents] <br/>    WHERE content CONTAINS 'import' <br/>  ) <br/>  WHERE line LIKE '%groovy.transform.%' <br/>  GROUP BY class_name, id <br/>)<br/>WHERE class_name != 'null'</span></pre><p id="9816" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们得到了:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es la"><img src="../Images/3fb2a339d6e1f2781a7c58be2e7d835a.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/0*wer8KNYWAyTsYuSI.png"/></div></figure><p id="acbb" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><strong class="jm hj">@复杂的转化才是王道</strong>！后面是@ToString和@EqualsAndHashCode。但是后来@TypeChecked是第四，说明Apache Groovy的静态类型化和编译支持真的用的很多。其他有趣的转换使用@Canonical、@PackageScope、@InheritConstructors、@Immutable或@TupleConstructor。</p><p id="714f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">在我研究导入时，我还想知道是否经常看到别名导入:</p><pre class="iz ja jb jc fd ki kj kk kl aw km bi"><span id="8b90" class="kn ko hi kj b fi kp kq l kr ks">SELECT aliased, count(aliased) total <br/>FROM (<br/>  SELECT REGEXP_MATCH(line, r'.* (as) .*') aliased<br/>  FROM (<br/>    SELECT SPLIT(content, '\n') AS line <br/>    FROM [github-groovy-files:github.contents] <br/>  ) <br/>  WHERE line CONTAINS 'import ' <br/>) <br/>GROUP BY aliased <br/>LIMIT 100</span></pre><p id="1824" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">有趣的是，有2719个有别名的进口超过了765281个没有别名的进口，这大约是0.36%，所以对于300个正常进口来说，大约是1个“进口…作为…”。</p><p id="8f30" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">至此，我对Github上的Apache Groovy源文件的探索结束了！轮到你玩数据集了，看看有没有有趣的发现要揭开！你发现什么了吗？</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="cc96" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated"><em class="li">最初发表于</em><a class="ae ix" href="http://glaforge.appspot.com/article/what-can-we-learn-from-million-lines-of-groovy-code-on-github" rel="noopener ugc nofollow" target="_blank"><em class="li">【glaforge.appspot.com】</em></a><em class="li">。</em></p></div></div>    
</body>
</html>