<html>
<head>
<title>Scale your kubernetes cluster to (almost) zero with GKE autoscaler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GKE自动缩放器将您的kubernetes集群缩放至(几乎)零</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/scale-your-kubernetes-cluster-to-almost-zero-with-gke-autoscaler-9c78051cbf40?source=collection_archive---------0-----------------------#2019-12-12">https://medium.com/google-cloud/scale-your-kubernetes-cluster-to-almost-zero-with-gke-autoscaler-9c78051cbf40?source=collection_archive---------0-----------------------#2019-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/73e888011f59280d89126ae3297ab5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1l7B8P3hevDL5vvTSiceg.jpeg"/></div></div></figure><h1 id="d524" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="7bf3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">虽然kubernetes最出名的是编排适应需求的永久工作负载(部署)(水平pod自动缩放),但它正越来越多地用于短暂的批处理过程。在某些情况下，这些过程需要昂贵或稀有的专用硬件。机器学习训练工作就是这种情况，通常需要使用GPU的大型实例类型。在这种情况下，您需要确保作业完成后，您的集群立即释放所有这些资源。</p><p id="c538" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">考虑一个具有以下要求的机器学习培训工作(真实故事):</p><ul class=""><li id="4dc6" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">该作业必须在4个节点上并行运行。</li><li id="9c62" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">每个节点都是n1-highmem-96机器，8个NVIDIA Tesla V100 GPUs(共32个)。</li><li id="91f3" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">完成培训工作大约需要12个小时。</li></ul><p id="a4d8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">按照目前的价格，在没有特别折扣的情况下，这种设置每小时要花费100多美元。我们想在工作结束后尽快释放这些节点，以节省一些资金。</p><h1 id="6eff" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">集群自动缩放功能助您一臂之力</h1><p id="6057" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">使用GKE时，最有趣的特性之一是集群自动缩放功能。如<a class="ae lf" href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank"> GKE文档</a>中所述，集群自动缩放允许:</p><blockquote class="lg lh li"><p id="ec22" class="jo jp lj jq b jr km jt ju jv kn jx jy lk ko kb kc ll kp kf kg lm kq kj kk kl hb bi translated">根据工作负载的需求，自动调整GKE集群节点池的大小。当需求较高时，cluster autoscaler会向节点池中添加节点。当需求较低时，集群自动缩放会缩小到您指定的最小大小。这可以在您需要时提高工作负载的可用性，同时控制成本。</p></blockquote><p id="a4f4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">但是，集群自动缩放无法将整个集群完全缩小到零。群集中必须至少有一个节点始终可用，才能运行系统窗格。所以你至少需要保留一个节点。但这并不意味着你需要保持一个<em class="lj">昂贵的</em>节点空闲运行。</p><p id="c093" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">GKE的另一个非常有趣的特性是节点池。节点池是群集中具有相同配置的一组节点。每个集群至少有一个<em class="lj">默认</em>节点池，但是您可以根据需要添加其他节点池。</p><p id="ea56" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，为了满足我们的ML培训需求，我们将创建一个包含两个节点池的集群:</p><ol class=""><li id="a155" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl ln kx ky kz bi translated">一个固定大小的缺省节点池，其中一个节点具有较小的实例大小(例如<code class="du lo lp lq lr b">g1-small</code>)。</li><li id="cb5a" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl ln kx ky kz bi translated">第二个节点池(我们称之为突发池)包含我们的ML训练作业所需的实例类型(<code class="du lo lp lq lr b">n1-highmem-96</code>机器，带有8个<em class="lj">NVIDIA Tesla V100</em>GPU)。我们将在该节点池上设置群集自动扩展，以允许最多4个节点，最少0个节点。</li></ol><h1 id="2dda" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">确保您的pod在突发节点池中运行</h1><p id="1e15" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在我们已经配置了一个GKE集群来满足我们的自动扩展需求，我们需要确保我们的ML训练工作负载在突发池上运行。我们需要确保以下几点:</p><ol class=""><li id="9626" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl ln kx ky kz bi translated">我们希望我们的ML训练作业在突发节点池上运行，因为这里将创建带有GPU的<em class="lj"> highmem </em>实例。</li><li id="7cb4" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl ln kx ky kz bi translated">我们的ML训练作业被设计成在一个节点中获取所有可用的资源，并且期望在每个节点中运行一个单独的训练pod。</li><li id="6fbb" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl ln kx ky kz bi translated">突发节点池必须专用于ML训练作业。我们不希望让任何其他工作负载在这些节点上运行，因为我们希望在工作完成后立即释放它们。</li></ol><p id="e33c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们不需要任何特殊的GKE功能来满足这些要求。以下标准kubernetes特性将帮助我们实现工作负载分配要求:</p><ol class=""><li id="9dae" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl ln kx ky kz bi translated">我们将在pod中使用一个<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector" rel="noopener ugc nofollow" target="_blank">节点选择器</a>来确保它们在bust节点池中运行。为此，我们将向该池中的节点添加一个标签。</li><li id="8b94" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl ln kx ky kz bi translated">我们将使用一个<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank">反关联性</a>规则来确保您的两个培训单元不能被安排在同一个节点上。</li><li id="4a1c" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl ln kx ky kz bi translated">我们将向我们的猝发池节点添加一个<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank">污点</a>，以防止其他工作负载在猝发节点池中运行。我们需要给我们的ML训练舱增加适当的容错能力，让它们在这些节点上运行。</li></ol><h1 id="3858" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">把所有的放在一起</h1><p id="6b66" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在实践中，我们将从创建一个具有默认节点池的群集开始，该节点池仅包含一个小节点:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="15dc" class="ma ir hi lr b fi mb mc l md me">PROJECT_ID="apszaz-kube-playground"<br/>GCP_ZONE="europe-west1-b"<br/>GKE_CLUSTER_NAME="burstable-cluster"<br/>GKE_BURST_POOL="burst-zone"<br/><br/>gcloud container clusters create <strong class="lr hj">${</strong>GKE_CLUSTER_NAME<strong class="lr hj">}</strong> <strong class="lr hj">\</strong><br/>       --machine-type=g1-small <strong class="lr hj">\</strong><br/>       --num-nodes=1 <strong class="lr hj">\</strong><br/>       --zone=<strong class="lr hj">${</strong>GCP_ZONE<strong class="lr hj">}</strong> <strong class="lr hj">\</strong><br/>       --project=<strong class="lr hj">${</strong>PROJECT_ID<strong class="lr hj">}</strong></span></pre><p id="4937" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们将使用以下参数添加拆分节点池:</p><ul class=""><li id="ca9b" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">这是我们希望用于ML培训工作的实例类型。与默认节点相反，默认节点只包含一个类型为<code class="du lo lp lq lr b">g1-small</code>的实例。</li><li id="737c" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><code class="du lo lp lq lr b">--accelerator=nvidia-tesla-v100,8</code>:我们希望每个节点有8个<em class="lj">NVIDIA TESLA V100</em>GPU。这些GPU并非在所有地区和区域都可用，因此我们需要找到一个具有足够容量的区域。</li><li id="237a" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><code class="du lo lp lq lr b">--node-labels=gpu=tesla-v100</code>:我们向突发池中的节点添加一个标签，以允许使用<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector" rel="noopener ugc nofollow" target="_blank">节点选择器</a>在我们的ML训练工作负载中选择它们。</li><li id="d1cb" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><code class="du lo lp lq lr b">--node-taints=reserved-pool=true:NoSchedule</code>:我们向节点添加了一个<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank">污点</a>，以防止任何其他工作负载意外地被调度到这个节点池中。</li></ul><p id="f08d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">其余选项指的是自动缩放，不言自明。完整的命令如下所示:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="fa7a" class="ma ir hi lr b fi mb mc l md me">gcloud container node-pools create <strong class="lr hj">${</strong>GKE_BURST_POOL<strong class="lr hj">}</strong> <strong class="lr hj">\</strong><br/>       --cluster=<strong class="lr hj">${</strong>GKE_CLUSTER_NAME<strong class="lr hj">}</strong> <strong class="lr hj">\</strong><br/>       --machine-type=n1-highmem-96 <strong class="lr hj">\</strong><br/>       --accelerator=nvidia-tesla-v100,8 <strong class="lr hj">\</strong><br/>       --node-labels=gpu=tesla-v100 <strong class="lr hj">\</strong><br/>       --node-taints=reserved-pool=true:NoSchedule  <strong class="lr hj">\</strong><br/>       --enable-autoscaling <strong class="lr hj">\</strong><br/>       --min-nodes=0 <strong class="lr hj">\</strong><br/>       --max-nodes=4 <strong class="lr hj">\</strong><br/>       --zone=<strong class="lr hj">${</strong>GCP_ZONE<strong class="lr hj">}</strong> <strong class="lr hj">\</strong><br/>       --project=<strong class="lr hj">${</strong>PROJECT_ID<strong class="lr hj">}</strong></span></pre><p id="f038" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了测试配置，我们将创建一个作业，该作业将在10分钟内创建4个并行运行的pod。我们的工作负载中的单元需要具有以下元素:</p><ul class=""><li id="a8f7" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">与我们添加到突发节点池的标签相匹配的一个<code class="du lo lp lq lr b">nodeSelector</code>:<code class="du lo lp lq lr b">gpu=tesla-v100</code>。</li><li id="9c38" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">一个<code class="du lo lp lq lr b">podAntiAffinity</code>规则表明我们不希望两个带有相同标签<code class="du lo lp lq lr b">app=greedy-job</code>的pod在同一个节点上运行。为此，我们将为我们的pod添加适当的标签，并在<code class="du lo lp lq lr b">topologyKey</code>中指出它适用于<code class="du lo lp lq lr b">hostname</code>级别(同一节点中没有两个这样的pod)。</li><li id="f13f" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">最后，我们需要为附加到节点上的污点添加一个容差，这样就允许在这些节点上调度这些podes。</li></ul><p id="e55f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">完整的作业YAML文件(姑且称之为<code class="du lo lp lq lr b">greedy_job.yaml</code>)如下所示:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="1b96" class="ma ir hi lr b fi mb mc l md me">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: greedy-job<br/>spec:<br/>  parallelism: 4<br/>  template:<br/>    metadata:<br/>      name: greedy-job<br/>      <strong class="lr hj">labels:<br/>        </strong>app: greedy-app<br/>    spec:<br/>      containers:<br/>      - name: busybox<br/>        image: busybox<br/>        args:<br/>        - sleep<br/>        - "300"<br/>      <strong class="lr hj">nodeSelector:<br/>        </strong>gpu: tesla-v100<br/>      <strong class="lr hj">affinity:</strong><br/>        podAntiAffinity:<br/>          requiredDuringSchedulingIgnoredDuringExecution:<br/>          - labelSelector:<br/>              matchExpressions:<br/>              - key: app<br/>                operator: In<br/>                values:<br/>                - greedy-app<br/>            topologyKey: "kubernetes.io/hostname"<br/>      <strong class="lr hj">tolerations:</strong><br/>      - key: reserved-pool<br/>        operator: Equal<br/>        value: "true"<br/>        effect: NoSchedule<br/>      restartPolicy: OnFailure</span></pre><h1 id="5a52" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">验证它是否有效</h1><p id="92ad" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，您需要获得集群凭证，以便能够在这个集群上运行kubectl命令:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="98ad" class="ma ir hi lr b fi mb mc l md me">gcloud container clusters get-credentials ${GKE_CLUSTER_NAME} \<br/>       --zone=${GCP_ZONE} \<br/>       --project=${PROJECT_ID}</span></pre><p id="4783" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们看到，最初，GKE启动群集时，突发池中有3个节点，默认池中有1个节点:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="7c19" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl get nodes<br/>NAME                                               STATUS   ROLES    AGE     VERSION<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-2vw9     Ready    &lt;none&gt;   9m7s    v1.13.11-gke.14<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-jkzt     Ready    &lt;none&gt;   9m10s   v1.13.11-gke.14<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-p2w8     Ready    &lt;none&gt;   9m7s    v1.13.11-gke.14<br/>gke-burstable-cluster-<strong class="lr hj">default-pool</strong>-794fe9e9-jdk3   Ready    &lt;none&gt;   12m     v1.13.11-gke.14</span></pre><p id="3294" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们等待集群冷却下来，并删除突发池中的节点。几分钟后，我们看到所有突发池节点都已删除:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="a6a6" class="ma ir hi lr b fi mb mc l md me">NAME                                               STATUS   ROLES    AGE   VERSION<br/>gke-burstable-cluster-<strong class="lr hj">default-pool</strong>-794fe9e9-jdk3   Ready    &lt;none&gt;   24m   v1.13.11-gke.14</span></pre><p id="7daf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">既然我们的集群已经处于待机模式(突发池中没有节点)，我们就可以开始运行测试了。我们将使用我们在上一节中定义的作业(我们称之为<code class="du lo lp lq lr b">greedy_job.yaml</code>)。该作业将运行四个并行运行的进程，并将在10分钟后完成。</p><p id="0548" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最初，我们没有在默认名称空间中运行的pods:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="4ccf" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl get pods<br/>No resources found.</span></pre><p id="9d21" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如我们前面看到的，只有默认节点池中的虚拟节点:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="bf6a" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl get nodes<br/>NAME                                               STATUS   ROLES    AGE   VERSION<br/>gke-burstable-cluster-<strong class="lr hj">default-pool</strong>-794fe9e9-jdk3   Ready    &lt;none&gt;   26m   v1.13.11-gke.14</span></pre><p id="b519" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们申请我们的工作:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="8f86" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl apply -f greedy_job.yaml<br/>job.batch/greedy-job created</span></pre><p id="2c25" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们看到pod已创建，但还需要等待一段时间:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="fede" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl get pod<br/>NAME               READY   STATUS    RESTARTS   AGE<br/>greedy-job-9wlb8   0/1     Pending   0          8s<br/>greedy-job-hr2tc   0/1     Pending   0          8s<br/>greedy-job-lqshk   0/1     Pending   0          8s<br/>greedy-job-mcbmm   0/1     Pending   0          8s</span></pre><p id="59e3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果查看其中一个窗格中的事件，您会看到它触发了一个集群纵向扩展事件:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="ad1b" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl describe pod greedy-job-9wlb8 <br/>Name:           greedy-job-9wlb8<br/>Namespace:      default<br/>...<br/>Events:<br/>  Type     Reason            Age   From                Message<br/>  ----     ------            ----  ----                -------<br/>  Warning  FailedScheduling  26s   default-scheduler   0/1 nodes are available: 1 node(s) didn't match node selector.<br/>  Normal   TriggeredScaleUp  20s   <strong class="lr hj">cluster-autoscaler</strong>  pod triggered <strong class="lr hj">scale-up</strong>: [{<a class="ae lf" href="https://content.googleapis.com/" rel="noopener ugc nofollow" target="_blank">https://content.googleapis.com/</a>... 0-&gt;1 (max: 4)}]</span></pre><p id="ca94" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们看到豆荚逐渐开始运行:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="bd7e" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl get pod -o wide<br/>NAME               READY   STATUS              RESTARTS   AGE     IP          NODE                                             NOMINATED NODE   READINESS GATES<br/>greedy-job-9wlb8   1/1     <strong class="lr hj">Running</strong>             0          2m47s   10.16.1.2   gke-burstable-cluster-burst-zone-183c2d4b-n1f3   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-hr2tc   1/1     <strong class="lr hj">Running</strong>             0          2m47s   10.16.2.2   gke-burstable-cluster-burst-zone-183c2d4b-sf5r   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-lqshk   0/1     Pending             0          2m47s   &lt;none&gt;      &lt;none&gt;                                           &lt;none&gt;           &lt;none&gt;<br/>greedy-job-mcbmm   0/1     ContainerCreating   0          2m47s   &lt;none&gt;      gke-burstable-cluster-burst-zone-183c2d4b-jm49   &lt;none&gt;           &lt;none&gt;</span></pre><p id="095a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">几秒钟后再次检查:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="0ca4" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl get pod -o wide<br/>NAME               READY   STATUS    RESTARTS   AGE     IP          NODE                                             NOMINATED NODE   READINESS GATES<br/>greedy-job-9wlb8   1/1     <strong class="lr hj">Running</strong>   0          4m27s   10.16.1.2   gke-burstable-cluster-burst-zone-183c2d4b-n1f3   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-hr2tc   1/1     <strong class="lr hj">Running</strong>   0          4m27s   10.16.2.2   gke-burstable-cluster-burst-zone-183c2d4b-sf5r   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-lqshk   1/1     <strong class="lr hj">Running</strong>   0          4m27s   10.16.4.2   gke-burstable-cluster-burst-zone-183c2d4b-kbw2   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-mcbmm   1/1     <strong class="lr hj">Running</strong>   0          4m27s   10.16.3.2   gke-burstable-cluster-burst-zone-183c2d4b-jm49   &lt;none&gt;           &lt;none&gt;</span></pre><p id="025f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一旦10分钟过去，吊舱就会终止:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="7f1c" class="ma ir hi lr b fi mb mc l md me">~ $ kubectl get pod -o wide<br/>NAME               READY   STATUS      RESTARTS   AGE     IP          NODE                                             NOMINATED NODE   READINESS GATES<br/>greedy-job-9wlb8   0/1     Completed   0          7m58s   10.16.1.2   gke-burstable-cluster-burst-zone-183c2d4b-n1f3   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-hr2tc   0/1     Completed   0          7m58s   10.16.2.2   gke-burstable-cluster-burst-zone-183c2d4b-sf5r   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-lqshk   1/1     Running     0          7m58s   10.16.4.2   gke-burstable-cluster-burst-zone-183c2d4b-kbw2   &lt;none&gt;           &lt;none&gt;<br/>greedy-job-mcbmm   0/1     Completed   0          7m58s   10.16.3.2   gke-burstable-cluster-burst-zone-183c2d4b-jm49   &lt;none&gt;           &lt;none&gt;</span></pre><p id="bb58" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们继续观察我们的节点，我们会看到，在第一批作业完成大约10分钟后，它们的状态变为<code class="du lo lp lq lr b">NotReady</code>(它们正在被耗尽)，最后消失。您可以使用此命令每60秒查看一次节点列表:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="fa5d" class="ma ir hi lr b fi mb mc l md me">while true; do kubectl get nodes ; sleep 60; done</span></pre><p id="d952" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">输出如下所示:</p><pre class="ls lt lu lv fd lw lr lx ly aw lz bi"><span id="8f4a" class="ma ir hi lr b fi mb mc l md me">NAME                                               STATUS   ROLES    AGE   VERSION<br/>gke-burstable-cluster-burst-zone-183c2d4b-jm49     Ready    &lt;none&gt;   14m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-kbw2     Ready    &lt;none&gt;   13m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-n1f3     Ready    &lt;none&gt;   16m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-sf5r     Ready    &lt;none&gt;   15m   v1.13.11-gke.14<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready    &lt;none&gt;   45m   v1.13.11-gke.14<br/>NAME                                               STATUS     ROLES    AGE   VERSION<br/>gke-burstable-cluster-burst-zone-183c2d4b-jm49     Ready      &lt;none&gt;   15m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-kbw2     Ready      &lt;none&gt;   14m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-n1f3     Ready      &lt;none&gt;   17m   v1.13.11-gke.14<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-sf5r     <strong class="lr hj">NotReady</strong>   &lt;none&gt;   16m   v1.13.11-gke.14<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready      &lt;none&gt;   46m   v1.13.11-gke.14<br/>NAME                                               STATUS     ROLES    AGE   VERSION<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-jm49     <strong class="lr hj">NotReady</strong>   &lt;none&gt;   16m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-kbw2     Ready      &lt;none&gt;   15m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-n1f3     Ready      &lt;none&gt;   18m   v1.13.11-gke.14<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-sf5r     <strong class="lr hj">NotReady</strong>   &lt;none&gt;   17m   v1.13.11-gke.14<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready      &lt;none&gt;   47m   v1.13.11-gke.14<br/>NAME                                               STATUS     ROLES    AGE   VERSION<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-kbw2     <strong class="lr hj">NotReady</strong>   &lt;none&gt;   16m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-n1f3     Ready      &lt;none&gt;   19m   v1.13.11-gke.14<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready      &lt;none&gt;   48m   v1.13.11-gke.14<br/>NAME                                               STATUS     ROLES    AGE   VERSION<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-kbw2     <strong class="lr hj">NotReady</strong>   &lt;none&gt;   17m   v1.13.11-gke.14<br/>gke-burstable-cluster-burst-zone-183c2d4b-n1f3     Ready      &lt;none&gt;   20m   v1.13.11-gke.14<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready      &lt;none&gt;   49m   v1.13.11-gke.14<br/>NAME                                               STATUS     ROLES    AGE   VERSION<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-n1f3     <strong class="lr hj">NotReady</strong>   &lt;none&gt;   21m   v1.13.11-gke.14<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready      &lt;none&gt;   50m   v1.13.11-gke.14<br/>NAME                                               STATUS     ROLES    AGE   VERSION<br/>gke-burstable-cluster-<strong class="lr hj">burst-zone</strong>-183c2d4b-n1f3     <strong class="lr hj">NotReady</strong>   &lt;none&gt;   22m   v1.13.11-gke.14<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready      &lt;none&gt;   51m   v1.13.11-gke.14<br/>NAME                                               STATUS   ROLES    AGE   VERSION<br/>gke-burstable-cluster-default-pool-794fe9e9-jdk3   Ready    &lt;none&gt;   52m   v1.13.11-gke.14</span></pre><p id="b787" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">几分钟后，所有拆分节点都已删除，只剩下默认池中的<code class="du lo lp lq lr b">g1-small</code>节点。</p><h1 id="bb96" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="f59d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们成功地创建了一个集群，它可以扩展到一个非常小(而且便宜)的节点，只需使用:</p><ul class=""><li id="a255" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">GKE的<a class="ae lf" href="https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank">集群自动缩放</a>。</li><li id="703b" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">kubernetes的特点是<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector" rel="noopener ugc nofollow" target="_blank">节点选择器</a>、<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity" rel="noopener ugc nofollow" target="_blank">反亲和规则</a>和<a class="ae lf" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank">污染和容忍</a>。</li></ul><p id="32d4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您不太关心实际的节点规格，也可以使用<a class="ae lf" href="https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning" rel="noopener ugc nofollow" target="_blank">节点自动配置</a>。通过节点自动配置，可以根据不可调度的pod的<a class="ae lf" href="https://cloud.google.com/kubernetes-engine/docs/concepts/pod#pod-templates" rel="noopener ugc nofollow" target="_blank">规范</a>自动创建和删除新的节点池。</p></div></div>    
</body>
</html>