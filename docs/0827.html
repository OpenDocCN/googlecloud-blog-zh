<html>
<head>
<title>Build a blog application on Google App Engine: the App Context (part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Google App Engine上构建一个博客应用程序:应用程序上下文(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-the-app-context-part-3-8a0f15c35166?source=collection_archive---------3-----------------------#2018-11-27">https://medium.com/google-cloud/build-a-blog-application-on-google-app-engine-the-app-context-part-3-8a0f15c35166?source=collection_archive---------3-----------------------#2018-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6ffecb3a48ca7822ebc1ab2eaed05501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7sYTrl_cFBCl44EdMWsDg.jpeg"/></div></div></figure><p id="ae7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是关于如何使用<strong class="is hj"> Google Datastore </strong>在Node.js中构建博客应用程序并将其部署到<strong class="is hj"> Google App Engine </strong>的多部分教程的第三部分。如果你错过了开头，<a class="ae jo" rel="noopener" href="/@sebelga/build-a-blog-application-on-google-app-engine-setup-part-1-38dab981b779">跳到第一部分</a>，在那里我解释了如何建立这个项目，在那里你可以找到其他部分的链接。</p><p id="c5c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将创建<strong class="is hj">应用程序上下文。</strong>一个对象，它将包含我们的<strong class="is hj">数据库访问</strong>(<code class="du jp jq jr js b">gstore-node</code>实例)、<strong class="is hj">谷歌存储</strong>实例、我们的<strong class="is hj">应用配置</strong>和一个<strong class="is hj">日志记录器</strong>实例。然后这个上下文对象将被<strong class="is hj">提供给需要它的每个层和模块</strong>。让我们开始吧！</p><h1 id="1ff1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">上下文类型</h1><p id="9b83" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">让我们首先创建我们的上下文<em class="kw">类型</em>，并声明将定义它的4个属性。打开根目录下的"<em class="kw"> models.ts" </em>文件，添加以下内容:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="277b" class="lf ju hi js b fi lg lh l li lj">// models.ts</span><span id="1fec" class="lf ju hi js b fi lk lh l li lj">import Storage from '<a class="ae jo" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/storage';<br/>import { Gstore } from 'gstore-node';<br/>import { Logger } from 'winston';<br/>import { Config } from './config/index';<br/>import { BlogModule } from './modules/blog';</span><span id="9a6d" class="lf ju hi js b fi lk lh l li lj">...</span><span id="b73c" class="lf ju hi js b fi lk lh l li lj">export type Context = {<br/>  gstore: Gstore;<br/>  storage: Storage;<br/>  logger: Logger;<br/>  config: Config;<br/>};</span><span id="a9b9" class="lf ju hi js b fi lk lh l li lj">export type AppModules = {<br/>...</span></pre><h1 id="986f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">记录器</h1><p id="f25e" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">现在让我们创建上下文的第一个属性:<strong class="is hj">一个logger实例</strong>。日志是应用程序非常重要的一部分，为此，我们将使用<a class="ae jo" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> winston </strong> </a>日志库。它非常强大，我邀请您阅读它的文档以了解更高级的场景。在根目录下创建一个<em class="kw"> logger.ts </em>文件，并添加以下内容:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="aecc" class="lf ju hi js b fi lg lh l li lj">// logger.ts</span><span id="47f3" class="lf ju hi js b fi lk lh l li lj">import { createLogger, format, transports, Logger } from "winston";<br/>import { LoggerConfig } from "./config/logger";</span><span id="9eb7" class="lf ju hi js b fi lk lh l li lj">const { combine, timestamp, printf } = format;</span><span id="ccf8" class="lf ju hi js b fi lk lh l li lj">export default ({ config }: { config: LoggerConfig }): Logger =&gt; {<br/>  const myFormat = printf(info =&gt; {<br/>    return `${info.timestamp} ${info.level}: ${info.message}`;<br/>  });</span><span id="0d9c" class="lf ju hi js b fi lk lh l li lj">  const logger = createLogger({<br/>    level: config.level,<br/>    format: combine(timestamp(), myFormat),<br/>    transports: [<br/>      new transports.Console({ format: format.simple() })<br/>    ]<br/>  });</span><span id="140b" class="lf ju hi js b fi lk lh l li lj">  return logger;<br/>};</span></pre><p id="84b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您所看到的，要创建一个logger实例，我们需要提供一个<code class="du jp jq jr js b">LoggerConfig</code>对象。然后，我们为日志创建一个<strong class="is hj">定制格式函数</strong>，然后将它提供给<code class="du jp jq jr js b">createLogger()</code>方法。最后，我们返回logger实例。<br/>现在，让我们在根("<em class="kw"> src/server </em>")文件夹下的"<em class="kw"> index.ts" </em>"文件中创建实例。</p><p id="2137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先需要导入我们的<strong class="is hj">应用配置</strong>对象，然后通过传递它的配置来启动记录器。</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="fd53" class="lf ju hi js b fi lg lh l li lj">// index.ts</span><span id="eded" class="lf ju hi js b fi lk lh l li lj">process.env.NODE_ENV = process.env.NODE_ENV || "development";</span><span id="d2cf" class="lf ju hi js b fi lk lh l li lj">import config from "./config"; // add this line<br/>import initLogger from "./logger"; // add this line<br/>import initApp from "./app";</span><span id="8785" class="lf ju hi js b fi lk lh l li lj">// Create logger instance, providing its configuration<br/>const logger = initLogger({ config: config.logger }); <br/>...</span></pre><p id="311e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经导入了我们的应用程序配置并拥有了一个logger实例，让我们将文件末尾以<code class="du jp jq jr js b">app.listen(3000, () =&gt; { ... }</code>开头的块替换为:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="b27c" class="lf ju hi js b fi lg lh l li lj">/**<br/> * Start the server<br/> */<br/>logger.info("Starting server...");<br/>logger.info(`Environment: "${config.common.env}"`);</span><span id="1185" class="lf ju hi js b fi lk lh l li lj">app.listen(config.server.port, (error: any) =&gt; {<br/>  if (error) {<br/>    logger.error("Unable to listen for connection", error);<br/>    process.exit(10);<br/>  }</span><span id="4aed" class="lf ju hi js b fi lk lh l li lj">  logger.info(<br/>    `Server started and listening on port ${config.server.port}`<br/>  );<br/>});</span></pre><h1 id="ae3d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">数据库(gstore-node)</h1><p id="3ad5" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">现在让我们实例化<code class="du jp jq jr js b">gstore</code>。在根目录下创建一个"<em class="kw"> db.ts" </em>文件，并添加以下内容:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="98c8" class="lf ju hi js b fi lg lh l li lj">// db.ts</span><span id="06d0" class="lf ju hi js b fi lk lh l li lj">import Datastore from "<a class="ae jo" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/datastore";<br/>import GstoreNode, { Gstore } from "gstore-node";<br/>import { Logger } from "winston";<br/>import { GcloudConfig } from "./config/gcloud";</span><span id="6e08" class="lf ju hi js b fi lk lh l li lj">export default ({<br/>  config,<br/>  logger<br/>}: {<br/>  config: GcloudConfig,<br/>  logger: Logger<br/>}): Gstore =&gt; {<br/>  logger.info(<br/>    `Instantiating Datastore instance for project "${<br/>      config.projectId<br/>    }"`<br/>  );</span><span id="ffcb" class="lf ju hi js b fi lk lh l li lj">  /**<br/>   * Create a Datastore client instance<br/>   */<br/>  const datastore = new Datastore({<br/>    projectId: config.projectId,<br/>    namespace: config.datastore.namespace<br/>  });</span><span id="2113" class="lf ju hi js b fi lk lh l li lj">  /**<br/>   * Create gstore instance<br/>   */<br/>  const gstore = GstoreNode({ cache: true });</span><span id="64f4" class="lf ju hi js b fi lk lh l li lj">  /**<br/>   * Connect gstore to the Google Datastore instance<br/>   */<br/>  logger.info("Connecting gstore-node to Datastore");<br/>  gstore.connect(datastore);</span><span id="3fae" class="lf ju hi js b fi lk lh l li lj">  return gstore;<br/>};</span></pre><p id="76e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，为了<strong class="is hj">创建gstore实例</strong>，我们需要提供一个具有<code class="du jp jq jr js b">GcloudConfig</code>和<code class="du jp jq jr js b">Logger</code>实例的对象。代码是不言自明的，然后我们从<code class="du jp jq jr js b">@google-cloud/datastore</code>库中创建一个<strong class="is hj"> Google Datastore实例</strong>，并将gstore连接到它。您可能已经注意到，在实例化gstore时，我们激活了缓存。这将通过使用LRU内存缓存来获取<em class="kw">键</em>和<em class="kw">查询</em>来增加一个不错的性能提升。<a class="ae jo" href="https://sebloix.gitbook.io/gstore-node/cache-dataloader/cache" rel="noopener ugc nofollow" target="_blank">查看文档</a>了解不同的设置，或者<a class="ae jo" rel="noopener" href="/google-cloud/how-to-add-a-cache-layer-to-the-google-datastore-in-node-js-ffb402cd0e1c">阅读我写的关于它的帖子</a>了解更多信息。</p><p id="63b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像我们的记录器一样，让我们将它导入到我们的"<em class="kw"> index.ts </em>"文件中:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="ac65" class="lf ju hi js b fi lg lh l li lj">// index.ts</span><span id="0350" class="lf ju hi js b fi lk lh l li lj">...<br/>import initLogger from "./logger";<br/>import initDB from "./db"; // add this line<br/>import initApp from "./app";</span><span id="0686" class="lf ju hi js b fi lk lh l li lj">const logger = initLogger({ config: config.logger });<br/>const gstore = initDB({ config: config.gcloud, logger });</span></pre><h1 id="794b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">谷歌存储</h1><p id="9572" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">让我们遵循相同的模式来创建我们的<code class="du jp jq jr js b">@google-cloud/storage</code>实例。在根目录下创建一个“<em class="kw">storage . ts”</em>文件，并在其中添加以下内容:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="79b2" class="lf ju hi js b fi lg lh l li lj">// storage.ts</span><span id="8a46" class="lf ju hi js b fi lk lh l li lj">import Storage from "<a class="ae jo" href="http://twitter.com/google" rel="noopener ugc nofollow" target="_blank">@google</a>-cloud/storage";<br/>import { GcloudConfig } from "./config/gcloud";</span><span id="703a" class="lf ju hi js b fi lk lh l li lj">export default ({ config }: { config: GcloudConfig }) =&gt; {<br/>  const storage = new (Storage as any)({<br/>    projectId: config.projectId<br/>  });<br/>  return storage;<br/>};</span></pre><p id="15ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里也没什么特别的。为了生成我们的存储实例，我们需要提供<code class="du jp jq jr js b">GcloudConfig</code>对象。让我们这样做，打开我们的根文件"<em class="kw"> index.ts </em>"并添加以下内容:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="bdef" class="lf ju hi js b fi lg lh l li lj">// index.ts<br/>...<br/>import initDB from "./db";<br/>import initStorage from "./storage"; // add this line<br/>...</span><span id="1bf6" class="lf ju hi js b fi lk lh l li lj">const logger = initLogger({ config: config.logger });<br/>const gstore = initDB({ config: config.gcloud, logger });<br/>const storage = initStorage({ config: config.gcloud }); add this<br/>...</span></pre><p id="dbbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们现在已经拥有了创建<strong class="is hj">应用程序上下文对象</strong>所需的所有东西。我们现在就开始吧。在存储初始化下方添加以下内容:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="8360" class="lf ju hi js b fi lg lh l li lj">// index.ts<br/>...<br/>const storage = initStorage({ config: config.gcloud });</span><span id="a249" class="lf ju hi js b fi lk lh l li lj">/**<br/> * Create App Context object<br/> */<br/>const context = { gstore, storage, logger, config };<br/>...</span></pre><p id="ae18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以<strong class="is hj">向我们的应用&amp;模块初始化</strong>提供这个上下文。这将允许我们稍后将它提供给我们的每个模块。打开根目录下的"<em class="kw"> modules.ts" </em>文件，进行如下修改:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="a42c" class="lf ju hi js b fi lg lh l li lj">// modules.ts</span><span id="7686" class="lf ju hi js b fi lk lh l li lj">...</span><span id="902e" class="lf ju hi js b fi lk lh l li lj">import initUtilsModule from "./modules/utils";<br/>import { Context, AppModules } from "./models"; // edit this line</span><span id="3dd7" class="lf ju hi js b fi lk lh l li lj">export default (context: Context): AppModules =&gt; { // edit this line<br/>    const utils = initUtilsModule();<br/>    ...</span></pre><p id="50f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们对我们的应用程序初始化做同样的事情:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="942e" class="lf ju hi js b fi lg lh l li lj">// app.ts</span><span id="7b6b" class="lf ju hi js b fi lk lh l li lj">import express from "express";</span><span id="c768" class="lf ju hi js b fi lk lh l li lj">import { Context, AppModules } from "./models"; // add this line</span><span id="91fb" class="lf ju hi js b fi lk lh l li lj">export default (context: Context, modules: AppModules) =&gt; { // edit<br/>  const app = express();<br/>  ...</span></pre><p id="25d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们实例化我们的模块和应用程序，提供新的<strong class="is hj">上下文对象</strong>。返回到根"<em class="kw"> index.ts" </em>文件，进行以下修改:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="a613" class="lf ju hi js b fi lg lh l li lj">// index.ts<br/>...<br/>import initDB from "./db";<br/>import initStorage from "./storage";<br/>import initModules from "./modules"; // add this line<br/>...</span><span id="c123" class="lf ju hi js b fi lk lh l li lj">/**<br/> * Create App Context object<br/> */<br/>const context = { gstore, storage, logger, config };</span><span id="cc9e" class="lf ju hi js b fi lk lh l li lj">/**<br/> * Instantiate the modules providing our context object<br/> */<br/>const modules = initModules(context); // add this line</span><span id="a105" class="lf ju hi js b fi lk lh l li lj">/**<br/> * Instantiate the Express App<br/> */<br/>const app = initApp(context, modules); // edit this line<br/>...</span></pre><h1 id="fc13" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">快速应用程序配置</h1><p id="3586" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们几乎完成了应用程序的框架。但是缺少了一个重要的部分:<strong class="is hj">路由</strong>。我们一会儿会研究一下，但是首先，让我们<strong class="is hj">用一些设置来配置我们的Express app </strong>。打开根目录下的"<em class="kw"> app.ts" </em>文件，进行如下修改:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="ee0e" class="lf ju hi js b fi lg lh l li lj">// app.ts</span><span id="9924" class="lf ju hi js b fi lk lh l li lj">import express from "express";<br/>import compression from "compression"; // add this line<br/>import path from "path"; // add this line</span><span id="f76a" class="lf ju hi js b fi lk lh l li lj">import { Context, AppModules } from "./models";</span><span id="e723" class="lf ju hi js b fi lk lh l li lj">export default (context: Context, modules: AppModules) =&gt; {<br/>  const app = express();</span><span id="a324" class="lf ju hi js b fi lk lh l li lj">  /**<br/>   * Configure views template, static files, gzip<br/>   */<br/>  app.use(compression());<br/>  app.set("views", "./views");<br/>  app.set("view engine", "pug");<br/>  app.use(<br/>    "/public",<br/>    express.static(path.join(__dirname, "..", "public"), {<br/>      maxAge: "1 year"<br/>    })<br/>  );<br/>  app.disable("x-powered-by");</span><span id="910a" class="lf ju hi js b fi lk lh l li lj">  app.use("/", (_, res) =&gt; {<br/>    res.send("Hello!");<br/>  });</span><span id="a85f" class="lf ju hi js b fi lk lh l li lj">  return app;<br/>};</span></pre><p id="e5d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里不多说了。我们已经启用了<strong class="is hj">压缩</strong> (gzip)来服务我们的应用程序请求，定义了我们的“<strong class="is hj">视图</strong>文件夹和<strong class="is hj">模板引擎</strong>(“<em class="kw">pug</em>”)。然后，我们定义了服务器的<strong class="is hj">静态文件夹</strong>，并禁用了<strong class="is hj"><em class="kw"/>X-Powered-By</strong>Http头。</p><h1 id="59a1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">按指定路线发送</h1><p id="09ac" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">现在是<strong class="is hj">处理我们的应用程序</strong>的时候了。在“<em class="kw"> src/server </em>”文件夹中，创建一个“<em class="kw">routes . ts”</em>文件，并添加以下内容:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="d73a" class="lf ju hi js b fi lg lh l li lj">// routes.ts</span><span id="873d" class="lf ju hi js b fi lk lh l li lj">import path from "path";<br/>import { Request, Response, NextFunction, Express } from "express";<br/>import { Context, AppModules } from "./models";</span><span id="8fe8" class="lf ju hi js b fi lk lh l li lj">export default (<br/>  { logger, config }: Context,<br/>  {<br/>    app,<br/>    modules: { blog, admin }<br/>  }: { app: Express, modules: AppModules }<br/>) =&gt; {<br/>  /**<br/>   * Web Routes<br/>   */<br/>  app.use("/blog", (_, res) =&gt; {<br/>    res.send("Hello!");<br/>  });</span><span id="a6ca" class="lf ju hi js b fi lk lh l li lj">  /**<br/>   * 404 Page Not found<br/>   */<br/>  app.get("/404", (_, res) =&gt; {<br/>    res.render(path.join(__dirname, "views", "404"));<br/>  });</span><span id="6915" class="lf ju hi js b fi lk lh l li lj">  /**<br/>   * Default route "/blog"<br/>   */<br/>  app.get("*", (_, res) =&gt; res.redirect("/blog"));</span><span id="e544" class="lf ju hi js b fi lk lh l li lj">  /**<br/>   * Error handling<br/>   */<br/>  app.use(<br/>    (err: any, _: Request, res: Response, next: NextFunction) =&gt; {<br/>      const payload = (err.output &amp;&amp; err.output.payload) || err;<br/>      const statusCode =<br/>        (err.output &amp;&amp; err.output.statusCode) || 500;</span><span id="8dd1" class="lf ju hi js b fi lk lh l li lj">      logger.error(payload);</span><span id="8b79" class="lf ju hi js b fi lk lh l li lj">      return res.status(statusCode).json(payload);<br/>    }<br/>  );<br/>};</span></pre><p id="ae58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这里发生了什么。首先，我们为这一层声明<strong class="is hj"> 2个输入</strong>。第一个是我们的<em class="kw">上下文</em>对象(我们将其解构以提取<code class="du jp jq jr js b">logger</code>和<code class="du jp jq jr js b">config</code>)。第二个是层依赖:一个<strong class="is hj"> Express实例</strong> ( <code class="du jp jq jr js b">app</code>)和<strong class="is hj"> AppModules </strong> ( <code class="du jp jq jr js b">modules</code>)。</p><p id="725e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们定义第一条路线，“/blog”，并像以前一样返回<code class="du jp jq jr js b">Hello!</code>。我们将在这里的<em class="kw">模块</em>路径中添加。</p><p id="4755" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们创建一个“/404”路由，以备找不到页面时使用。</p><p id="4c3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们创建一条<em class="kw">默认</em>路线。这将把“/”重定向到“/blog”。</p><p id="fcb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们处理了Express错误。因为我们将使用<a class="ae jo" href="https://www.npmjs.com/package/boom" rel="noopener ugc nofollow" target="_blank"> Boom </a>来处理HTTP请求错误，我们检查<em class="kw"> err </em>对象是否有一个<code class="du jp jq jr js b">output</code>属性并检索<code class="du jp jq jr js b">statusCode</code>。然后我们记录并返回错误。</p><p id="8059" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了，我们现在只需要<strong class="is hj">将我们的快速应用程序附加到这个路由层</strong>上，我们就有了我们应用程序的框架！打开"<em class="kw"> app.ts" </em>文件，导入我们的routes图层:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="a2a9" class="lf ju hi js b fi lg lh l li lj">// app.ts</span><span id="d746" class="lf ju hi js b fi lk lh l li lj">import express from 'express';<br/>import compression from 'compression';<br/>import initRoutes from './routes'; // add this line</span></pre><p id="097b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后将从<code class="du jp jq jr js b">app.use('/', (_, res) =&gt; { ... }</code>开始的模块替换为:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="07e4" class="lf ju hi js b fi lg lh l li lj">initRoutes(context, { app, modules });</span></pre><p id="5490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您现在在浏览器中刷新页面，您应该会看到它重定向到“/blog”URL。</p><p id="3be4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！我们已经完成了应用程序的框架。我们定义了我们的<strong class="is hj">模块</strong>，添加了<strong class="is hj">应用上下文</strong> <strong class="is hj">和</strong> <strong class="is hj">配置</strong>，以及一些<strong class="is hj"> Express配置</strong>。我们最终<strong class="is hj">创建了一个路由层</strong>并将我们的应用程序连接到它。这将是一个很好的时机来制作这个样板文件的副本，以创建基于相同架构的其他Node.js应用程序，我把它留给你！:)</p><p id="595d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一如既往，如果你有任何问题或疑问，或者如果你发现一个错误，请在下面的评论中联系我们。我们都会从中吸取教训:)</p><p id="dfb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程的下一部分，我们将最终接触一些业务逻辑，并<strong class="is hj">构建第一个模块</strong>:T2博客模块。<br/> <a class="ae jo" rel="noopener" href="/@sebelga/build-a-blog-application-on-google-app-engine-blogpost-module-part-4-b929e212c899">让我们马上开始吧！</a></p></div></div>    
</body>
</html>