<html>
<head>
<title>Google Cloud Deployment Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌云部署管理器</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/google-cloud-deployment-manager-865931dd6880?source=collection_archive---------0-----------------------#2017-09-27">https://medium.com/google-cloud/google-cloud-deployment-manager-865931dd6880?source=collection_archive---------0-----------------------#2017-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8ed0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">“缺失教程”系列</h2></div><p id="50f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">决定重温一篇早先的帖子<a class="ae jt" rel="noopener" href="/@DazWilkin/deploy-docker-engine-in-swarm-mode-to-google-cloud-platform-8b88a5a43be8">以群集模式将Docker引擎部署到GCP </a>以尝试利用谷歌的运行时配置。我希望通过让多个workers从运行时配置变量中获取swarm join-token来协调它们的生成。</p><p id="fd71" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这使我有机会扩展我的部署管理器知识，因为我需要使用服务管理服务来启用API，IAM为docker节点虚拟机生成服务帐户(具有增强的范围)，云资源管理器修改项目的策略，当然，还有运行时配置来创建和管理令牌。</p><p id="1aa7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章将是我在遇到问题和解决问题时学到的一系列写作经验。</p><h2 id="d60a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">巨蟒不是姬娜</h2><p id="e49d" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">部署管理器服务支持Python脚本和JINJA模板，并且支持两者的混合和匹配。我不鼓励你使用JINJA模板。很可能您需要接受Python提供的功能超集，最好将所有东西都放在Python中。</p><h2 id="991a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">支持的资源类型</h2><p id="cd35" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">部署管理器(DM)脚本定义了GCP资源的预期状态。当您需要对不熟悉的资源使用DM时，可以从支持的资源类型页面开始:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a1c2" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://cloud.google.com/deployment-manager/docs/configuration/supported-resource-types" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/deployment-manager/docs/configuration/supported-resource-types</a></span></pre><p id="c339" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，您可以从命令行枚举该列表:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7976" class="ju jv hi kz b fi ld le l lf lg">gcloud deployment-manager types list</span></pre><p id="8c2c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务、服务端点和它们的资源(类型)之间存在1:1的映射关系，但这种映射并不总是显而易见的。它也不是双射的:不是所有的服务资源类型都映射到部署管理器资源类型；服务资源类型是一个超集。因此，您不能使用部署管理器来管理GCP的所有资源。</p><p id="23c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">计算(引擎)v1 <a class="ae jt" href="https://pantheon.corp.google.com/apis/library/compute.googleapis.com" rel="noopener ugc nofollow" target="_blank">服务</a>全面且一致地映射到部署管理器类型:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1940" class="ju jv hi kz b fi ld le l lf lg">gcloud deployment-manager types list \<br/>--filter="name ~ ^compute\.v1\."</span><span id="2aab" class="ju jv hi kz b fi lh le l lf lg">NAME<br/>compute.v1.regionInstanceGroupManager<br/>compute.v1.firewall<br/>compute.v1.router<br/>compute.v1.regionBackendService<br/>compute.v1.instanceGroupManager<br/>compute.v1.sslCertificate<br/>compute.v1.disk<br/>compute.v1.image<br/>compute.v1.targetInstance<br/>compute.v1.healthCheck<br/>compute.v1.subnetwork<br/>compute.v1.autoscaler<br/>compute.v1.targetSslProxy<br/>compute.v1.route<br/>compute.v1.httpHealthCheck<br/>compute.v1.vpnTunnel<br/>compute.v1.instanceGroup<br/>compute.v1.urlMap<br/>compute.v1.regionAutoscaler<br/>compute.v1.httpsHealthCheck<br/>compute.v1.forwardingRule<br/>compute.v1.regionInstanceGroup<br/>compute.v1.targetPool<br/>compute.v1.targetHttpProxy<br/>compute.v1.address<br/>compute.v1.globalAddress<br/>compute.v1.targetHttpsProxy<br/>compute.v1.globalForwardingRule<br/>compute.v1.instanceTemplate<br/>compute.v1.backendService<br/>compute.v1.network<br/>compute.v1.targetVpnGateway<br/>compute.v1.instance</span></pre><p id="0aa7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署管理器v2 <a class="ae jt" href="https://console.cloud.google.com/apis/api/deploymentmanager.googleapis.com/overview" rel="noopener ugc nofollow" target="_blank">服务</a>有一个资源类型<a class="ae jt" href="https://cloud.google.com/deployment-manager/docs/reference/latest/#Manifests" rel="noopener ugc nofollow" target="_blank">清单</a>，但这不能作为受支持的部署管理器资源类型进行访问:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="91f7" class="ju jv hi kz b fi ld le l lf lg">gcloud deployment-manager types list --filter="name ~ ^deploymentmanager\.v2\."</span><span id="943e" class="ju jv hi kz b fi lh le l lf lg">No types were found for your project!</span></pre><p id="3f1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署管理器v2端点是:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="bd65" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://www.googleapis.com/deploymentmanager/v2/projects" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/deploymentmanager/v2/projects</a></span></pre><p id="fed9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，IAM <a class="ae jt" href="https://console.cloud.google.com/apis/api/iam.googleapis.com/overview" rel="noopener ugc nofollow" target="_blank">服务</a>端点是:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="bac2" class="ju jv hi kz b fi ld le l lf lg">https://iam.googleapis.com</span></pre><p id="b268" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且该服务用项目或组织前缀定义它的一些资源类型，例如projects.serviceAccounts和projects.serviceAccounts.keys:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="f158" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://cloud.google.com/iam/reference/rest/#collection-v1projectsserviceaccounts" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/iam/reference/rest/#collection-v1projectsserviceaccounts</a><br/><a class="ae jt" href="https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts.keys" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts.keys</a></span></pre><p id="63d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是这些映射到没有“项目”前缀的部署管理器资源类型:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="276f" class="ju jv hi kz b fi ld le l lf lg">gcloud deployment-manager types list --filter="name ~ ^iam\.v1\."</span><span id="54e1" class="ju jv hi kz b fi lh le l lf lg">iam.v1.serviceAccounts.key<br/>iam.v1.serviceAccount</span></pre><h2 id="26d6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">创建服务帐户</h2><p id="1947" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">部署管理器GitHub示例<a class="ae jt" href="https://github.com/GoogleCloudPlatform/deploymentmanager-samples/blob/master/examples/v2/project_creation/service-accounts.py" rel="noopener ugc nofollow" target="_blank">包括</a>服务帐户(类型)的表示，但这在其他地方没有记录，我将使用它作为遇到新资源类型的示例。在这种情况下，我们可以创建一个没有附带密钥的服务帐户，因为计算引擎虚拟机将使用该服务帐户。</p><p id="811e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Cloud SDK命令行，等效的命令将是:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="65c5" class="ju jv hi kz b fi ld le l lf lg">PROJECT=[[YOUR-PROJECT-ID]]<br/>INSTANCE=[[YOUR-INSTANCE]]<br/>NAME=[[YOUR-SERVICE_ACCOUNT_NAME]]</span><span id="e69d" class="ju jv hi kz b fi lh le l lf lg">SERVICE_ACCOUNT=${NAME}@${PROJECT}.iam.gserviceaccount.com</span><span id="257b" class="ju jv hi kz b fi lh le l lf lg">gcloud iam service-accounts create $NAME --project=$PROJECT</span><span id="dff5" class="ju jv hi kz b fi lh le l lf lg">gcloud compute instances set-service-account $INSTANCE \<br/>--<a class="ae jt" href="mailto:service-account=dazwilkin-170925-sa@dazwilkin-170828-medium.iam.gserviceaccount.com" rel="noopener ugc nofollow" target="_blank">service-account=${SERVICE_ACCOUNT</a>} \<br/>--scopes=...<br/>--project=$PROJECT \<br/>--zone=$ZONE</span></pre><p id="7cfd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts" rel="noopener ugc nofollow" target="_blank">项目的文档。]serviceAccounts </a>总结了与该资源相关的(一些)属性。这些属性表示实例化的资源:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="eb0c" class="ju jv hi kz b fi ld le l lf lg">{<br/>  "name": string,<br/>  "projectId": string,<br/>  "uniqueId": string,<br/>  "email": string,<br/>  "displayName": string,<br/>  "etag": string,<br/>  "oauth2ClientId": string,<br/>}</span></pre><p id="d86d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，要创建服务帐户，必须提供accoundId和displayName。我怎么知道这个？创建方法记录了这一点:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="18e6" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/create" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/create</a></span></pre><p id="5300" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得信赖的API Explorer证明了这一点:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9235" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://developers.google.com/apis-explorer/#search/iam/iam/v1/iam.projects.serviceAccounts.create" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/apis-explorer/#search/iam/iam/v1/iam.projects.serviceAccounts.create</a></span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/4040e2827dcf0cc0fb4bd20b3ff92ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHjhfGT3Pu6-IB1bOVxQLQ.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">iam . projects . service accounts . create</figcaption></figure><p id="ba8d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署管理器(似乎)使用一组简单的属性，因此API方法的层次结构没有保留:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="bd79" class="ju jv hi kz b fi ld le l lf lg">{<br/>  accountId,<br/>  serviceAccount: {<br/>    displayName<br/>  }<br/>}</span></pre><p id="f623" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">变成了:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="6a56" class="ju jv hi kz b fi ld le l lf lg">{<br/>  'name': $NAME,<br/>  'type': 'iam.v1.serviceAccount',<br/>  'metadata': {<br/>    'dependsOn': [<br/>      'cloudresourcemanager',<br/>      'iam'<br/>    ]<br/>  },<br/>  'properties':{<br/>    'accountId': $NAME,<br/>    'displayName': $NAME<br/>  }<br/>}</span></pre><h2 id="9d0b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">支持服务</h2><p id="35a6" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">默认情况下，在项目中不启用IAM服务。如果您尝试如上所述创建一个服务帐户，DM很可能会遇到一个错误:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="4e61" class="ju jv hi kz b fi ld le l lf lg">'{"ResourceType":"iam.v1.serviceAccount","ResourceErrorCode":"403","ResourceErrorMessage":{"code":403,"message":"Google Identity and Access Management (IAM) API has not been used in project ... before or it is disabled. Enable it by visiting <a class="ae jt" href="https://console.developers.google.com/apis/api/iam.googleapis.com/overview?project=dazwilkin-170925-deleteme-01" rel="noopener ugc nofollow" target="_blank">https://console.developers.google.com/apis/api/iam.googleapis.com/overview?project=.</a>.. then retry. If you enabled this API recently, wait a few minutes for the action to propagate to our systems and retry.","status":"PERMISSION_DENIED","details":...</span></pre><p id="a1e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要使用服务管理服务来启用IAM API，然后我们需要从部署管理器serviceAccount类型添加一个依赖项，这是我们之前创建的，以依赖于正在启用的IAM。</p><p id="09e0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您不会找到服务管理<a class="ae jt" href="https://console.cloud.google.com/apis/api/servicemanagement.googleapis.com/overview" rel="noopener ugc nofollow" target="_blank">服务</a>的部署管理器类型:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="4f96" class="ju jv hi kz b fi ld le l lf lg">gcloud deployment-manager types list \<br/>--filter="name ~ ^servicemanagement"</span><span id="f2a2" class="ju jv hi kz b fi lh le l lf lg">No types were found for your project!</span></pre><p id="5cae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GitHub示例再次提供了<a class="ae jt" href="https://github.com/GoogleCloudPlatform/deploymentmanager-samples/blob/master/examples/v2/project_creation/apis.py" rel="noopener ugc nofollow" target="_blank">解决方案</a>。我在搜索创建服务帐户的方法时无意中发现了这一点。虽然这并不明显，但这种方法有一个独特的结果:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a2dc" class="ju jv hi kz b fi ld le l lf lg">{<br/>  'name': ...,<br/>  'type': 'deploymentmanager.v2.virtual.enableService',<br/>  'metadata': {<br/>    'dependsOn': ...<br/>  },<br/>  'properties': {<br/>    'consumerId': 'project:' + project_id,<br/>    'serviceName': ...<br/>  }<br/>}</span></pre><p id="39da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个代码有效！我不知道它为什么会起作用，但它确实起作用了。我不理解对deploymentmanager.v2.virtual.X的引用，但我能够理解其属性。同样，API Explorer有助于:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c9b0" class="ju jv hi kz b fi ld le l lf lg"><a class="ae jt" href="https://developers.google.com/apis-explorer/#search/servicemanagement/servicemanagement/v1/servicemanagement.services.enable" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/apis-explorer/#search/servicemanagement/servicemanagement/v1/servicemanagement.services.enable</a></span></pre><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lu"><img src="../Images/aab168de90429d93a1ee6ec6a554886b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvK3MG0FU8KfUq5rlIU4iQ.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">服务管理.服务.启用</figcaption></figure><p id="9cac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">展平API方法的必需属性(serviceName，consumerId)会产生Google示例中提供的代码。注意，我还使用context.env从运行时环境中获取“项目”(== GCP项目Id)，因为这是消费ID的值所必需的。我将代码转换成一个函数，在本例中，我调用该函数并传递$API == "iam "来启用iam.googleapis.com</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c61b" class="ju jv hi kz b fi ld le l lf lg">{<br/>    'name': $API,<br/>    'type': 'deploymentmanager.v2.virtual.enableService',<br/>    'properties': {<br/>      'consumerId': 'project:' + context.env['project'],<br/>      'serviceName': $API + '.googleapis.com'<br/>    }</span></pre><p id="431c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这相当于以下Cloud SDK命令:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1434" class="ju jv hi kz b fi ld le l lf lg">gcloud service-management enable iam[.googleapis.com] \<br/>--project=$PROJECT</span></pre><h2 id="0bea" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">变异(IAM)策略</h2><p id="5900" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">好吧，“改变政策”，“更新政策”，但“变异”只是听起来更有趣！我正在GitHub网站上等待一些示例代码来展示如何执行这一操作。这项服务的运作方式很复杂。</p><p id="2bbe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，改变IAM策略的方法是:</p><ul class=""><li id="a6da" class="lv lw hi iz b ja jb jd je jg lx jk ly jo lz js ma mb mc md bi translated">获取当前策略</li><li id="e233" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">变异它</li><li id="fa90" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">将修改后的策略放回服务中</li></ul><p id="6b55" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">策略文档不仅包括例如项目的当前策略绑定列表，还包括用作并发机制的etag。这实际上是政策的混乱。如果当您将策略放回服务时，服务的存储策略的散列与您放入服务的文档中的etag不同，则服务知道该策略已被修订，并且您的更改未被应用并将被拒绝。</p><p id="4e37" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个在部署管理器中表示的具有挑战性的机制，GitHub示例包括一个将服务帐户合并到策略中的<a class="ae jt" href="https://github.com/GoogleCloudPlatform/deploymentmanager-samples/blob/master/examples/v2/project_creation/project.py" rel="noopener ugc nofollow" target="_blank">助手函数</a>。我从部署经理团队那里了解到，一个替代的解决方案应该很快就会出现。</p><p id="fdce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cloud SDK包括一个方便的方法add-iam-policy，它在后台执行工作:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="61a4" class="ju jv hi kz b fi ld le l lf lg">gcloud projects add-iam-policy-binding $PROJECT \<br/>--member=serviceAccount:${SERVICE_ACCOUNT} \<br/>--role=roles/editor</span></pre><p id="29b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署管理器团队告诉我，这一功能即将推出，并以一种叫做“动作”的新功能的形式出现。当功能发布时，我会更新这些内容。</p><h2 id="ff5a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">运行时配置(urator)</h2><p id="315f" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">部署管理器包括一个名为<a class="ae jt" href="https://cloud.google.com/deployment-manager/runtime-configurator/" rel="noopener ugc nofollow" target="_blank">运行时配置(urator) </a>的特性。它提供了与部署管理器特别相关的功能，但事实上，它是一个独立的服务。我<a class="ae jt" rel="noopener" href="/@DazWilkin/cloud-functions-global-scope-7450a5f08038">描述了</a>一种结合使用运行时配置和全局作用域的方法，这是一种将配置数据传递给云函数的方法。</p><p id="ca64" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时配置为部署Docker swarm提供了一个关键的改进。当一个群被初始化时，第一个(Docker引擎)节点生成一个管理者令牌和一个工作者令牌，当加入集群时，其他节点必须提供这两个令牌来证明它们自己。</p><p id="192c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个(源)节点:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="afad" class="ju jv hi kz b fi ld le l lf lg">sudo docker swarm init</span><span id="7b95" class="ju jv hi kz b fi lh le l lf lg">Swarm initialized: current node (73gqde43chycmq9s7f93klmmf) is now a manager.<br/><br/>To add a worker to this swarm, run the following command:<br/><br/>    docker swarm join --token SWMTKN-1-243cu5kol7pfie85svs8cnvsmbypm2gp8mhe29b12izyj5cr92-e2r75b6yxdx8mk3rrwjf4kfzi 10.138.0.2:2377<br/><br/>To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</span></pre><p id="218d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从这个genesis节点获取令牌最简单的方法是重新查询它，并为一个环境变量赋值，作为我们如何继续的提示:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8bad" class="ju jv hi kz b fi ld le l lf lg">WORKER_TOKEN=$(sudo docker swarm join-token worker --quiet)<br/>MANAGER_TOKEN=$(sudo docker swarm join-token manager --quiet)</span></pre><p id="0432" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些命令仅返回令牌。</p><p id="341f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这些令牌，从其他(Docker引擎)节点(在其他虚拟机上)，我们可以:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="bb60" class="ju jv hi kz b fi ld le l lf lg">sudo docker swarm join --token ${WORKER_TOKEN} swarm-master:2377</span><span id="2bb4" class="ju jv hi kz b fi lh le l lf lg">sudo docker swarm join --token ${MANAGER_TOKEN} swarm-master:2377</span></pre><p id="ac75" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，两个突出的问题是，我们如何:</p><ul class=""><li id="58bd" class="lv lw hi iz b ja jb jd je jg lx jk ly jo lz js ma mb mc md bi translated">使令牌对其他节点可用？</li><li id="872f" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">其他群节点对令牌可用性的阻塞创建？</li></ul><p id="2e0f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是运行时配置为我们提供的。运行时配置的范围是单个项目，并允许通过namspaces进一步确定范围。让我们首先为Docker swarm模式令牌创建一个名为“swarm”的名称空间:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b008" class="ju jv hi kz b fi ld le l lf lg">gcloud beta runtime-config configs create swarm</span></pre><p id="6399" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以在这个“群体”名称空间内任意创建变量。我选择创建一个名为“worker”的变量和一个名为“manager”的变量，但将它们放在“token”下的层次结构中。“令牌”前缀是多余的，但是..</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5851" class="ju jv hi kz b fi ld le l lf lg">gcloud beta runtime-config configs \<br/>variables set /token/worker ${WORKER_TOKEN} \<br/>--config-name swarm \<br/>--is-text</span><span id="2e4b" class="ju jv hi kz b fi lh le l lf lg">gcloud beta runtime-config configs \<br/>variables set /token/manager ${MANAGER_TOKEN} \<br/>--config-name swarm \<br/>--is-text</span></pre><p id="b61f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用“— is-text”标志。这些标记是明文(字母数字),这样就不必在检索时对值进行base64解码。</p><p id="b21d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时配置提供了监视和等待变量的机制，但我并不清楚这两者是否提供了这里需要的功能。相反——有点不高兴——我决定“破解”一个解决方案(请给我评论改进)。</p><p id="5d73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署管理器脚本在创建任何虚拟机(显然包括源节点)之前，使用DUMMY设置创建令牌/管理器和令牌/工作器变量。虚拟机都知道，如果变量if $DUMMY的值为空，则源节点尚未就绪，它们会阻塞并在一分钟后重试。</p><p id="25aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="mj">【优势】</em> </strong></p><ul class=""><li id="1e72" class="lv lw hi iz b ja jb jd je jg lx jk ly jo lz js ma mb mc md bi translated">简单的</li></ul><p id="4535" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">T5】缺点T7】</strong></p><ul class=""><li id="511a" class="lv lw hi iz b ja jb jd je jg lx jk ly jo lz js ma mb mc md bi translated">不太优雅</li><li id="23e1" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">潜在无限阻塞</li><li id="aa50" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">需要共享$DUMMY值的知识</li></ul><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a52e" class="ju jv hi kz b fi ld le l lf lg">def GenerateRuntimeConfigConfig(context, name):<br/>  """Generate a Runtime-Config Config 'name'"""<br/>  return {<br/>    'name': 'config-name-' + name,<br/>    'type': 'runtimeconfig.v1beta1.config',<br/>    'metadata': {<br/>      'dependsOn': [<br/>        'runtimeconfig',<br/>      ],<br/>    },<br/>    'properties': {<br/>      'config': name,<br/>    }<br/>  }</span><span id="c2ed" class="ju jv hi kz b fi lh le l lf lg">def GenerateRuntimeConfigVariable(context, name, variable, default):<br/>  """Generate Runtime-Config 'variable' with 'default' text value"""<br/>  project_id = context.env['project']<br/>  config_name = 'config-name-' + name<br/>  return {<br/>    'name': 'variable-' + variable,<br/>    'type': 'runtimeconfig.v1beta1.variable',<br/>    'metadata': {<br/>      'dependsOn': [<br/>        config_name,<br/>      ]<br/>    },<br/>    'properties': {<br/>      'parent': '$(ref.'+ config_name +'.name)',<br/>      'variable': variable,<br/>      'text': default,<br/>    },<br/>  }</span></pre><p id="d706" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> NB </strong>必须启用运行时配置服务，这是创建配置时在dependsOn中检查的内容。</p><p id="a57c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，在第一个(genesis)节点的启动脚本中，在swarm init之后，请求worker和manager令牌并用于替换$DUMMY值:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="979b" class="ju jv hi kz b fi ld le l lf lg">sudo docker swarm init</span><span id="1397" class="ju jv hi kz b fi lh le l lf lg">WORKER_TOKEN=$(sudo docker swarm join-token worker --quiet)<br/>MANAGER_TOKEN=$(sudo docker swarm join-token manager --quiet)</span><span id="535c" class="ju jv hi kz b fi lh le l lf lg">gcloud beta runtime-config configs variables set \<br/>  /token/worker ${WORKER_TOKEN} \<br/>  --config-name=swarm \<br/>  --is-text</span><span id="8372" class="ju jv hi kz b fi lh le l lf lg">gcloud beta runtime-config configs variables set \<br/>  /token/manager ${MANAGER_TOKEN} \<br/>  --config-name=swarm \<br/>  --is-text</span></pre><p id="1e22" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以便工作线程的启动脚本可以从令牌的运行时配置变量中提取值。它可能是$DUMMY，但如果不是，它将是正确的工作令牌值:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0b56" class="ju jv hi kz b fi ld le l lf lg">WORKER_TOKEN=$(gcloud beta runtime-config configs variables get-value /token/worker --config-name=swarm)</span><span id="3136" class="ju jv hi kz b fi lh le l lf lg">while [ "${WORKER_TOKEN}" == "DUMMY" ]<br/>do<br/>  sleep 60s<br/>done</span><span id="fbde" class="ju jv hi kz b fi lh le l lf lg">sudo docker swarm join --token ${WORKER_TOKEN} swarm-master:2377</span></pre><p id="6e59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，经理的启动脚本会翻转变量:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ac57" class="ju jv hi kz b fi ld le l lf lg">MANAGER_TOKEN=$(gcloud beta runtime-config configs variables get-value /token/manager --config-name=swarm)</span><span id="c936" class="ju jv hi kz b fi lh le l lf lg">while [ "${MANAGER_TOKEN}" == "DUMMY" ]<br/>do<br/>  sleep 60s<br/>done<br/>sudo docker swarm join --token ${MANAGER_TOKEN} swarm-master:2377</span></pre><p id="39ce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来测试一下:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d0c9" class="ju jv hi kz b fi ld le l lf lg">gcloud deployment-manager deployments create docker-swarm \<br/>--config=docker_swarm.yaml \<br/>--project=$PROJECT</span><span id="92e4" class="ju jv hi kz b fi lh le l lf lg">The fingerprint of the deployment is ...<br/>Waiting for update [operation-...]...done.<br/>Update operation operation-... completed successfully.</span><span id="6ca3" class="ju jv hi kz b fi lh le l lf lg">cloudresourcemanager    deploymentmanager.v2...          COMPLETED<br/>$PROJECT                cloudresourcemanager.v1.project  COMPLETED<br/>iam                     deploymentmanager.v2...          COMPLETED<br/>runtimeconfig           deploymentmanager.v2...          COMPLETED<br/>swarm                   runtimeconfig.v1beta1.config     COMPLETED<br/>swarm-manager-mig       compute.v1.instanceGroupManager  COMPLETED<br/>swarm-manager-template  compute.v1.instanceTemplate      COMPLETED<br/>swarm-master            compute.v1.instance              COMPLETED<br/>swarm-robot             iam.v1.serviceAccount            COMPLETED<br/>swarm-worker-mig        compute.v1.instanceGroupManagers COMPLETED<br/>swarm-worker-template   compute.v1.instanceTemplate      COMPLETED<br/>variable-manager        runtimeconfig.v1beta1.variable   COMPLETED<br/>variable-worker         runtimeconfig.v1beta1.variable   COMPLETED</span></pre><p id="7d8d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，进入swarm-master:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e4ca" class="ju jv hi kz b fi ld le l lf lg">sudo docker node ls</span><span id="d585" class="ju jv hi kz b fi lh le l lf lg">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS<br/>jt7vcsgb2jnst0z33aolmzs0t *   swarm-master        Ready       Active<br/>s3su15bvothaswr17l6fugbml     swarm-master-0pj9   Ready       Active<br/>jsi7dsfbp9zjcreihrzhr5g7q     swarm-master-lb6q   Ready       Active<br/>ftsrgxyfqeiu1l9o5b9nhs45q     swarm-master-tjpm   Ready       Active<br/>w5mq06h0gvirfldd0ezm1s1j7     swarm-worker-4p1p   Ready       Active<br/>b9279nr43pjhog2d4pl9crjt4     swarm-worker-r1mx   Ready       Active<br/>krik9fnw8p4w0jrca3qcicw46     swarm-worker-znmt   Ready       Active</span></pre><p id="5cb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我对输出进行了修改，使它在这里看起来更像:虫群主人被标注为“首领”，三个主人都被标记为“可到达”</p><h2 id="a771" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">结论</h2><p id="f64f" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">部署管理器很强大，但是对于像我这样的新手来说，更全面的文档会更有帮助。该服务设计良好，但并不总是直观的(一致的)。</p></div></div>    
</body>
</html>