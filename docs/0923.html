<html>
<head>
<title>Back to Microservices with Istio (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Istio回到微服务(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/back-to-microservices-with-istio-p1-827c872daa53?source=collection_archive---------0-----------------------#2019-02-19">https://medium.com/google-cloud/back-to-microservices-with-istio-p1-827c872daa53?source=collection_archive---------0-----------------------#2019-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d2a4a56609692af41e4c9b1162e65f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PP6I7VYPqqzwfovHrr8DLw.jpeg"/></div></div></figure><blockquote class="iq ir is"><p id="78a9" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">注:</strong>此文已过时。我的最新文章“<a class="ae js" href="https://www.freecodecamp.org/news/learn-istio-manage-microservices/" rel="noopener ugc nofollow" target="_blank">学习Istio——如何管理、保护和监控您的服务</a>”适用于最新版本的Istio。</p></blockquote><p id="cec1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj"> Istio </strong>是一个开源项目，由谷歌、IBM和Lyft的团队合作开发，它为基于微服务的应用的复杂性提供了一个解决方案，仅举几个例子:</p><ul class=""><li id="7336" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr kb kc kd ke bi translated"><strong class="iw hj">流量管理</strong>:超时、重试、负载平衡、</li><li id="e6a1" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">安全性:</strong>最终用户认证和授权，</li><li id="821b" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">可观察性:</strong>跟踪、监控和记录。</li></ul><p id="0615" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">所有这些都可以在应用层解决，但您的服务不会再如此“微观”，实现这些服务的所有额外工作会给公司的资源带来压力，而这些资源可用于交付业务价值。让我们举个例子:</p><blockquote class="iq ir is"><p id="ed2d" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">PM:添加反馈功能需要多长时间？</p><p id="ec19" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">戴夫:两次冲刺。</p><p id="d835" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">PM:什么…？那只是一堆垃圾！</p><p id="cf8a" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Dev:创建CRUD是容易的部分，但是我们需要对用户和服务进行认证和授权。由于网络不可靠，我们需要在客户端实施重试和断路器，为了确保我们不会让整个系统瘫痪，我们需要超时和隔离，此外还需要检测我们需要监控和跟踪的问题[…]</p><p id="8aaa" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">PM:那我们就把它放在产品服务里吧。呀！</p></blockquote><p id="b438" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">你应该知道，对于我们来说，增加一项服务所需要的所有仪式和努力是巨大的。在本文中，我们将展示Istio如何从我们的服务中消除所有上述跨领域问题。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/5b7aa7bae53cd3d84f70fa4e45fb03c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*Z9G1wbqPf1MhpDwJUKz1ZQ.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图一。微服仪式</figcaption></figure><p id="08e1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">注意:</strong>本文假设您对Kubernetes有一定的了解。如果不是这样，我推荐你阅读<a class="ae js" href="https://medium.freecodecamp.org/learn-kubernetes-in-under-3-hours-a-detailed-guide-to-orchestrating-containers-114ff420e882" rel="noopener ugc nofollow" target="_blank">我对Kubernetes的介绍</a>，然后继续这篇文章。</p><h1 id="a40d" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Istio的想法</h1><p id="4912" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">在没有Istio的世界里，一个服务直接向另一个服务发出请求，在失败的情况下，服务需要通过重试、超时、打开断路器等方式来处理请求。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/795e27e95c62f96a175a36b2d9959ffd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NZLDRzdLh4WgP8E9t08QBQ.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图二。Kubernetes的网络流量</figcaption></figure><p id="9965" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">为了解决这个问题，Istio提供了一个巧妙的解决方案，它与服务完全分离，只拦截所有网络通信。这样做可以实现:</p><ul class=""><li id="9c38" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr kb kc kd ke bi translated"><strong class="iw hj">容错</strong> —使用响应状态代码，它了解请求何时失败并重试。</li><li id="714a" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj"> Canary Rollouts </strong> —只将指定百分比的请求转发给新版本的服务。</li><li id="226a" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">监控和度量</strong> —服务响应所需的时间。</li><li id="9d7f" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">跟踪和可观察性</strong> —它在每个请求中添加特殊的报头，并在集群中跟踪它们。</li><li id="75e9" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">安全</strong> —提取JWT令牌，对用户进行认证和授权。</li></ul><p id="be8a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">举几个例子(真的只是几个)让你感兴趣！让我们进入技术细节！</p><h1 id="5f68" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">伊斯迪奥的建筑</h1><p id="0fa2" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">Istio拦截所有网络流量，并通过在每个pod中注入一个智能代理来应用一组规则。启用所有功能的代理包括<strong class="iw hj">数据平面</strong>和那些可由<strong class="iw hj">控制平面动态配置的功能。</strong></p><h1 id="5918" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数据平面</h1><p id="676b" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">注入的代理使Istio能够轻松实现我们的需求。举个例子，让我们看看重试和断路功能。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/44dd940a64736d86c255d17e0a26ada1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tHn9Gv_6UlfB0jQzlX2BSw.gif"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图3。特使如何实施重试和断路</figcaption></figure><p id="f1d1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">总结一下:</p><ol class=""><li id="36fa" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">Envoy将请求发送到服务B的第一个实例，但它失败了。</li><li id="a012" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">特使边车重试。(1)</li><li id="4586" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">向调用代理返回失败的请求。</li><li id="8da5" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">这将打开断路器并根据后续请求调用下一个服务。(2)</li></ol><p id="1584" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这意味着您不必使用另一个重试库，也不必用编程语言X、Y或z开发自己的电路断开和服务发现实现。所有这些以及更多功能都由Istio和<strong class="iw hj">提供，不需要</strong>代码更改。</p><p id="f98a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">太好了！现在你想和Istio一起航行，但是你仍然有一些疑问，一些未解决的问题。这是一个适合所有人的解决方案吗？你对此表示怀疑，因为它最终总是没有一个适合所有人的解决方案！</p><p id="f19a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">你最后喃喃地问:“这是可配置的吗？”</p><p id="997b" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">欢迎乘坐游轮，我的朋友，让我们认识一下控制飞机。</p><h1 id="0616" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">控制平面</h1><p id="5484" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">由三个组件组成:导频器<strong class="iw hj">、混合器<strong class="iw hj">、堡垒</strong>和堡垒<strong class="iw hj">，它们组合起来配置特使来路由流量、执行策略和收集遥测数据。直观地呈现在下图中。</strong></strong></p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/5e8a8376339903e43184dcf81f362e08.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8gH0GAnncEE6VUIbwnGUww.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图4。相对于数据平面的控制平面</figcaption></figure><p id="7df6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">使用Istio定义的<a class="ae js" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"> Kubernetes自定义资源定义</a>配置代理(即数据平面),并专门用于此目的。这意味着对您来说，它只是另一个具有熟悉语法的Kubernetes资源。在被创建之后，它将被<strong class="iw hj">控制平面</strong>拾取，并将其应用于特使。</p><h1 id="d85b" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">服务与Istio的关系</h1><p id="034b" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">我们描述了Istio与我们服务的关系，而不是反过来，我们的服务与Istio的关系是什么？</p><p id="686e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">坦率地说，我们的服务对Istio的存在有很多了解，就像鱼对水一样，他们会问自己“水到底是什么？”。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/a9003fed46703aa73c75d181503fc1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PaPk2TSvDlGJdXPubvXQ1g.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">维多利亚·迪米特拉科普洛斯绘制</figcaption></figure><p id="0b68" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这意味着您可以选择一个工作集群，在部署Istio的组件后，其中的服务将继续工作，同样，您可以删除组件，一切都会好起来。可以理解，您会失去Istio提供的功能。</p><p id="d7a8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我们已经受够了理论，让我们把这些知识付诸实践吧！</p><h1 id="eec8" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实践中的Istio</h1><p id="04c7" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">Istio要求Kubernetes集群至少有4个vCPU和8 GB RAM。为了快速建立集群并跟进本文，我推荐使用Google云平台，它为新用户提供了300美元的免费试用。</p><p id="836d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">创建集群并使用Kubernetes命令行工具配置访问后，我们就可以使用Helm Package manager安装Istio了。</p><h1 id="48fe" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">安装舵</h1><p id="778a" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">按照<a class="ae js" href="https://docs.helm.sh/using_helm/#installing-the-helm-client" rel="noopener ugc nofollow" target="_blank">官方文档</a>中的说明，在您的计算机上安装Helm客户端。我们将在下一节中使用它来生成Istio安装模板。</p><h1 id="440e" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">安装Istio</h1><p id="8921" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">从<a class="ae js" href="https://github.com/istio/istio/releases/tag/1.0.5" rel="noopener ugc nofollow" target="_blank">最新版本</a>下载Istio的资源，将内容提取到一个目录中，我们称之为<code class="du ma mb mc md b">[istio-resources]</code>。</p><p id="a252" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">要轻松识别Istio资源，请在Kubernetes集群中创建一个名称空间<code class="du ma mb mc md b">istio-system</code>:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="0bd9" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl create namespace istio-system</strong></span></pre><p id="878c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">导航到<code class="du ma mb mc md b">[istio-resources]</code>目录并执行以下命令，完成安装:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="e567" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ helm template install/kubernetes/helm/istio \<br/>  --set global.mtls.enabled=false \<br/>  --set tracing.enabled=true \<br/>  --set kiali.enabled=true \<br/>  --set grafana.enabled=true \<br/>  --namespace istio-system &gt; istio.yaml</strong></span></pre><p id="1064" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">上面的命令将Istio的核心组件打印到文件<code class="du ma mb mc md b">istio.yaml</code>中。我们使用以下参数定制了模板:</p><ul class=""><li id="51fb" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr kb kc kd ke bi translated"><strong class="iw hj"> global.mtls.enabled </strong>设置为false以保持简介的焦点。</li><li id="b366" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj"> tracing.enabled </strong>使用jaeger启用请求跟踪。</li><li id="29eb" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj"> kiali.enabled </strong>在我们的集群中安装kiali，用于可视化服务和流量</li><li id="fa1e" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj"> grafana.enabled </strong>安装grafana以可视化收集的指标。</li></ul><p id="40a3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">通过执行以下命令来应用生成的资源:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="f98f" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f istio.yaml</strong></span></pre><p id="957d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这标志着我们集群中Istio安装的完成！通过执行以下命令，等到<code class="du ma mb mc md b">istio-system</code>名称空间中的所有窗格都处于运行或完成状态:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="21a2" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl get pods -n istio-system</strong></span></pre><p id="0476" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">现在我们已经准备好继续下一部分，我们将启动并运行示例应用程序。</p><h1 id="33f3" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">情感分析应用架构</h1><p id="54ab" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">我们将使用在<a class="ae js" href="https://medium.freecodecamp.org/learn-kubernetes-in-under-3-hours-a-detailed-guide-to-orchestrating-containers-114ff420e882" rel="noopener ugc nofollow" target="_blank"> Kubernetes介绍文章</a>中使用的相同微服务应用程序，它足够复杂，可以在实践中展示Istio的功能。</p><p id="0710" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">该应用由四个微服务组成:</p><ul class=""><li id="a334" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr kb kc kd ke bi translated"><strong class="iw hj">SA-前端服务</strong>:服务于前端Reactjs应用。</li><li id="cd68" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj"> SA-WebApp服务</strong>:处理情感分析请求。</li><li id="a983" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj"> SA逻辑服务</strong>:执行情感分析。</li><li id="da2b" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">SA-反馈服务</strong>:接收用户对分析准确性的反馈。</li></ul><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/d6891a60cb90336b8f715facbccea46e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*AcfdupyEsbdgTtKV6obx7A.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图6情绪分析微服务</figcaption></figure><p id="2448" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在图6中，除了服务之外，我们还看到了入口控制器，它在Kubernetes中将传入的请求路由到适当的服务，Istio使用了一个类似的概念，称为入口网关，这将在本文的后续部分介绍。</p><h1 id="02d2" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用Istio代理运行应用程序</h1><p id="543f" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">为了跟进本文，克隆存储库<a class="ae js" href="https://github.com/rinormaloku/istio-mastery" rel="noopener ugc nofollow" target="_blank"> istio-mastery </a>，其中包含Kubernetes和istio的应用程序和清单。</p><h2 id="401a" class="mi ku hi bd kv mn mo mp kz mq mr ms ld jt mt mu lh ju mv mw ll jv mx my lp mz bi translated">边车喷射</h2><p id="7057" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">注射由自动<strong class="iw hj">或手动</strong>或<strong class="iw hj">完成。要启用自动边车注入，我们需要通过执行下面的命令，用<code class="du ma mb mc md b">istio-injection=enabled</code>标记名称空间:</strong></p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="eef3" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl label namespace default istio-injection=enabled<br/></strong>namespace/default labeled</span></pre><p id="50b3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">从现在开始，每个部署到默认名称空间的pod都将被注入sidecar。为了验证这一点，让我们通过导航到<code class="du ma mb mc md b">[istio-mastery]</code>存储库的根文件夹并执行以下命令来部署示例应用程序:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="558f" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/kube<br/></strong>persistentvolumeclaim/sqlite-pvc created<br/>deployment.extensions/sa-feedback created<br/>service/sa-feedback created<br/>deployment.extensions/sa-frontend created<br/>service/sa-frontend created<br/>deployment.extensions/sa-logic created<br/>service/sa-logic created<br/>deployment.extensions/sa-web-app created<br/>service/sa-web-app created</span></pre><p id="58e3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">部署好服务后，通过执行命令<code class="du ma mb mc md b"><strong class="iw hj">kubectl get pods</strong></code> <strong class="iw hj"> </strong>来验证pod有两个容器(服务和边车)，并确保在ready列下，我们看到值“<strong class="iw hj"> 2/2 </strong>”表示两个容器都在运行。如下图所示:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="53d2" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl get pods</strong><br/>NAME                           READY     STATUS    RESTARTS   AGE<br/>sa-feedback-55f5dc4d9c-c9wfv   2/2       Running   0          12m<br/>sa-frontend-558f8986-hhkj9     2/2       Running   0          12m<br/>sa-logic-568498cb4d-2sjwj      2/2       Running   0          12m<br/>sa-logic-568498cb4d-p4f8c      2/2       Running   0          12m<br/>sa-web-app-599cf47c7c-s7cvd    2/2       Running   0          12m</span></pre><p id="b5aa" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">如图7所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es na"><img src="../Images/1470ac5cde69b887005233f92bbfb481.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*GeTGpCf5vAdPHzPznKYhdg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图7。特使代理在其中一个豆荚里</figcaption></figure><p id="d766" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">随着应用程序的启动和运行，我们现在需要允许传入的流量到达我们的应用程序。</p><h1 id="b93c" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">入口网关</h1><p id="7aa6" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">允许流量进入集群的最佳实践是通过Istio的<strong class="iw hj">入口网关</strong>，它将自己定位在集群的边缘，并在传入流量上启用Istio的功能，如路由、负载平衡、安全和监控。</p><p id="abbd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在Istio的安装过程中，<code class="du ma mb mc md b">Ingress Gateway</code>组件和对外公开它的服务被安装到集群中。要获取服务外部IP，请执行以下命令:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="e9a2" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl get svc -n istio-system -l istio=ingressgateway</strong><br/>NAME                   TYPE           CLUSTER-IP     EXTERNAL-IP<br/>istio-ingressgateway   LoadBalancer   10.0.132.127   13.93.30.120</span></pre><p id="7b4a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在本文的后续部分，我们将访问这个IP(称为EXTERNAL-IP)上的应用程序，为了方便起见，通过执行下面的命令将它保存在一个变量中:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="b82e" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ EXTERNAL_IP=$(kubectl get svc -n istio-system \<br/>  -l app=istio-ingressgateway \<br/>  -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')</strong></span></pre><p id="f2d2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">如果你在你的浏览器中到达这个IP，你会得到一个服务不可用的错误，因为默认情况下，Istio会阻止任何进入的流量，直到我们定义一个网关。</p><h1 id="dd6a" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">网关资源</h1><p id="6b58" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">网关是Kubernetes在我们的集群中安装Istio时定义的自定义资源定义，它使我们能够指定我们希望允许传入流量的端口、协议和主机。</p><p id="6eff" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在我们的场景中，我们希望所有主机都允许端口80上的HTTP流量。通过以下定义实现:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="285e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">除了选择器<code class="du ma mb mc md b">istio: ingressgateway</code>之外，所有配置都一目了然。使用这个选择器，我们可以指定将配置应用到哪个入口网关，在我们的例子中，它是安装在Istio设置上的默认入口网关控制器。</p><p id="85ed" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">通过执行以下命令来应用配置:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="bd98" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/istio/http-gateway.yaml </strong>gateway.networking.istio.io/http-gateway created</span></pre><p id="6414" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">网关现在允许在端口80访问，但是它不知道将请求路由到哪里。这是使用<strong class="iw hj">虚拟服务</strong>实现的。</p><h1 id="8d4c" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">虚拟服务资源</h1><p id="1d48" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">VirtualService指示入口网关如何路由允许进入集群的请求。</p><p id="eb38" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">对于我们的应用程序，通过<strong class="iw hj"> http-gateway </strong>发出的请求必须被路由到<code class="du ma mb mc md b"><strong class="iw hj">sa-frontend</strong></code> <strong class="iw hj">、</strong> <code class="du ma mb mc md b"><strong class="iw hj">sa-web-app</strong></code>和<strong class="iw hj"> </strong> <code class="du ma mb mc md b"><strong class="iw hj">sa-feedback</strong></code> <strong class="iw hj"> </strong>服务(如图8所示)。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/c822c0be79678d909a93570fffa3fcbf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*anirEAIId7_cg_obeYW4Zw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图8。要用虚拟服务配置的路由</figcaption></figure><p id="ec64" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">让我们来分解应该路由到SA前端的请求:</p><ul class=""><li id="ade2" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr kb kc kd ke bi translated"><strong class="iw hj">确切的路径</strong>T5应该被路由到SA前端以获得Index.html</li><li id="ad96" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">前缀路径</strong> <code class="du ma mb mc md b"><strong class="iw hj">/static/*</strong></code>应该路由到SA-Frontend，以获取前端所需的任何静态文件，如级联样式表和JavaScript文件。</li><li id="99d3" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">匹配正则表达式</strong> <code class="du ma mb mc md b"><strong class="iw hj">'^.*\.(ico|png|jpg)$'</strong></code>的路径应该被路由到SA-Frontend，因为它是一个页面需要显示的图像。</li></ul><p id="f3ca" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是通过以下配置实现的:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="7082" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这里的要点是:</p><ol class=""><li id="b690" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">这个虚拟服务适用于来自<strong class="iw hj"> http网关的请求。</strong></li><li id="bee3" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">目的地定义了请求被路由到的服务。</li></ol><p id="7653" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">注意:</strong>上面的配置在文件<code class="du ma mb mc md b">sa-virtualservice-external.yaml</code>中，它也包含路由到SA-WebApp和SA-Feedback的配置，但为了简洁起见被缩短了。</p><p id="feb8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">通过执行以下命令来应用虚拟服务:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="42a8" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/istio/sa-virtualservice-external.yaml<br/></strong>virtualservice.networking.istio.io/sa-external-services created</span></pre><p id="41c0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">注意:</strong>当我们应用Istio资源时，Kubernetes API服务器创建一个由Istio的控制平面接收的事件，然后该控制平面将新配置应用到每个pod的特使代理。入口网关控制器是由控制平面配置的另一个代理，如图9所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/59989837c49369263d3333b3d9164ee5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0XHfOTn7svQ8nvChkKmE5Q.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图9。配置<strong class="bd kv">Istio-Ingres gateway</strong>以路由请求</figcaption></figure><p id="c2a8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">情绪分析应用程序现已在<code class="du ma mb mc md b">http://{EXTERNAL-IP}/</code>上线。如果您得到一个未找到的状态，不要担心<em class="iv">有时配置生效和更新特使缓存需要一点时间</em>。</p><p id="3d86" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在进入下一部分之前，使用应用程序产生一些流量。</p><h1 id="b588" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Kiali —可观察性</h1><p id="6354" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">要访问Kiali的管理用户界面，请执行以下命令:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="a4f1" class="mi ku hi md b fi mj mk l ml mm">$ kubectl port-forward \<br/>    $(kubectl get pod -n istio-system -l app=kiali \<br/>    -o jsonpath='{.items[0].metadata.name}') \<br/>    -n istio-system 20001</span></pre><p id="a916" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">使用用户名和密码“admin”(不带引号)打开<code class="du ma mb mc md b"><a class="ae js" href="http://localhost:20001/" rel="noopener ugc nofollow" target="_blank">http://localhost:20001/</a></code>登录。有大量有用的功能，例如检查Istio组件的配置，根据通过拦截网络请求收集的信息可视化服务，以及回答“谁在呼叫谁？”，“哪个版本的服务有故障？”等等。在进入下一个好东西之前，花些时间检查一下Kiali，用Grafana可视化指标！</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/88037a37a357767a372f694256af58b0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*5s-LAV-rWNMWkWkkRfH8jg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图10。Kiali —服务可观察性</figcaption></figure><h1 id="3615" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Grafana —指标可视化</h1><p id="3bd7" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">Istio收集的指标被收集到Prometheus中，并使用Grafana可视化。要访问Grafana的管理用户界面，执行下面的命令并打开<a class="ae js" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000。</a></p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="03af" class="mi ku hi md b fi mj mk l ml mm">$ kubectl -n istio-system port-forward \<br/>    $(kubectl -n istio-system get pod -l app=grafana \<br/>    -o jsonpath={.items[0].metadata.name}) 3000</span></pre><p id="8ea0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在左上角单击菜单<strong class="iw hj">主页</strong>和<strong class="iw hj"> </strong>选择<strong class="iw hj"> Istio服务仪表板</strong>，在左上角选择以<strong class="iw hj"> sa-web-app、</strong>开始的服务，您将看到收集的指标，如下图所示:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/fa0f86cb82e88de09f2106b35490de96.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2dfPTHXZnFZ2attoax7GKQ.png"/></div></figure><p id="a006" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是一个空洞的、完全没有意思的观点，管理层永远不会同意的。让我们通过执行下面的命令来增加一些负载:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="8f68" class="mi ku hi md b fi mj mk l ml mm">$ while true; do \<br/>    curl -i <a class="ae js" rel="noopener ugc nofollow" target="_blank" href="/$EXTERNAL_IP/sentiment">http://$EXTERNAL_IP/sentiment</a> \<br/>    -H “Content-type: application/json” \<br/>    -d ‘{“sentence”: “I love yogobella”}’; \<br/>    sleep .8; done</span></pre><p id="b2f9" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">现在我们有了更漂亮的图表😊此外，我们还有Prometheus的监控工具和Grafana的可视化工具，使我们能够随时了解服务的性能、运行状况、改进或退化情况！</p><p id="0b73" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">最后，我们将调查整个服务中的跟踪请求。</p><h1 id="62a5" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">耶格——追踪</h1><p id="39e6" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">我们需要跟踪，因为我们拥有的服务越多，就越难查明失败的原因。让我们以下图中的简单案例为例:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/09c5ee3dda720f1dd331df128b910299.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8jBrTp5SF4ONfWUnJ2ux3Q.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图12。通常随机失败的请求</figcaption></figure><p id="5c0c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">请求进入，失败退出，<em class="iv">原因是什么？</em> <em class="iv">第一服？</em> <em class="iv">还是第二？</em>两者都有例外，让我们来看看每个例外的日志。你发现自己这样做了多少次？我们的工作感觉更像软件侦探，而不是开发人员。</p><p id="e28b" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是微服务中普遍存在的问题，使用分布式跟踪系统可以解决这一问题，在分布式跟踪系统中，服务相互传递唯一的报头，然后将该信息转发给分布式跟踪系统，在分布式跟踪系统中将请求跟踪放在一起。图13显示了一个例子。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/8f14f7397251315b0b6948167f942a21.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9355tU9NGsRR04GwwVbl8w.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图13。用于标识请求范围的TraceId</figcaption></figure><p id="b655" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">Istio使用Jaeger Tracer实现OpenTracing API，这是一个厂商中立的框架。要访问Jaegers UI，请执行以下命令:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="0816" class="mi ku hi md b fi mj mk l ml mm">$ kubectl port-forward -n istio-system \<br/>    $(kubectl get pod -n istio-system -l app=jaeger \<br/>    -o jsonpath='{.items[0].metadata.name}') 16686</span></pre><p id="2fff" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">然后在<a class="ae js" href="http://localhost:16686/" rel="noopener ugc nofollow" target="_blank"> http://localhost:16686 </a>中打开UI，选择<strong class="iw hj"> sa-web-app </strong>服务，<em class="iv">如果下拉列表中没有显示该服务，则在页面上生成一些活动并点击刷新</em>。之后点击<strong class="iw hj">查找轨迹</strong>按钮，其中<strong class="iw hj"> </strong>显示最近的轨迹，选择任意，将显示所有轨迹的明细<strong class="iw hj">，</strong>，如图14所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/95ffe19423487bf115fa62bcf241eb79.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mMKj2ld0zeTYVF1F4FmTBw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图14。Jaeger —请求跟踪</figcaption></figure><p id="facb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">跟踪显示:</p><ol class=""><li id="ce04" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">请求到达<strong class="iw hj">istio-Ingres gateway</strong>(这是与其中一个服务的第一次联系，因此为请求生成跟踪ID)，然后网关将请求转发给<code class="du ma mb mc md b"><strong class="iw hj">sa-web-app</strong></code>服务。</li><li id="fb34" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">在<code class="du ma mb mc md b"><strong class="iw hj">sa-web-app</strong></code>服务中，请求被Envoy sidecar接收，一个span子节点被创建(这就是为什么我们在跟踪中看到它)并被转发到<code class="du ma mb mc md b"><strong class="iw hj">sa-web-app</strong></code>容器实例。</li><li id="c3ce" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">这里，方法<strong class="iw hj">sensitive analysis</strong>处理请求。这些跟踪是由应用程序生成的，这意味着需要更改代码)。</li><li id="c8af" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">从开始POST请求的地方到<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code> <strong class="iw hj">。</strong>跟踪ID需要由<code class="du ma mb mc md b"><strong class="iw hj">sa-web-app</strong></code>传播。</li></ol><p id="c97e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi">5. …</p><p id="4a21" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">注意:</strong>在第四点，我们的应用程序需要获取Istio生成的头，并在下一个请求中传递它们，如下图所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/c33e771ea779f7e83f93adb85222a2ab.png" data-original-src="https://miro.medium.com/v2/format:webp/1*YDMLGTWmx3l9QmUXT7TwZQ.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图15。(A) Istio传播报头，<strong class="bd kv"> (B)服务传播报头</strong></figcaption></figure><p id="bb7e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">Istio完成了主要的繁重工作，因为它在传入的请求上生成头，在每个边车上创建新的跨度，传播它们，但是如果没有我们的服务也传播头，我们将丢失请求的完整跟踪。</p><p id="b2e9" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">要传播的头是:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="034d" class="mi ku hi md b fi mj mk l ml mm">x-request-id<br/>x-b3-traceid<br/>x-b3-spanid<br/>x-b3-parentspanid<br/>x-b3-sampled<br/>x-b3-flags<br/>x-ot-span-context</span></pre><p id="1ac6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">尽管这是一项简单的任务，但已经有许多库<a class="ae js" href="https://github.com/opentracing-contrib" rel="noopener ugc nofollow" target="_blank">简化了这个过程，例如在<code class="du ma mb mc md b"><strong class="iw hj">sa-web-app</strong></code>服务中，<strong class="iw hj"> RestTemplate </strong>客户端通过简单地在</a><a class="ae js" href="https://github.com/rinormaloku/istio-mastery/blob/master/sa-webapp/pom.xml#L36-L47" rel="noopener ugc nofollow" target="_blank">依赖项</a>中添加Jaeger和OpenTracing库来传播头文件。</p><p id="bc44" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><em class="iv">注意:情绪分析应用展示了Flask、Spring和ASP.NET核心的实现。</em></p><p id="e791" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">现在，在研究了我们开箱即用(或部分开箱即用)后😜)这里进入主要话题，细粒度路由，管理网络流量，安全等等！</p><h1 id="ea00" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">交通管理</h1><p id="fd0d" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">使用Envoy的Istio可为您的集群提供大量新功能，从而实现:</p><ul class=""><li id="70a3" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr kb kc kd ke bi translated"><strong class="iw hj">动态请求路由</strong> : Canary部署，A/B测试，</li><li id="ba22" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">负载均衡:</strong>简单<strong class="iw hj"> </strong>和一致哈希均衡，</li><li id="651d" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">故障恢复</strong>:超时、重试、断路器、</li><li id="9637" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated"><strong class="iw hj">故障注入</strong>:延迟、中止请求等。</li></ul><p id="2bab" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在本文的序列中，我们将展示我们的应用程序中的这些功能，并一路介绍新概念。我们将深入研究的第一个概念是DestinationRules，并使用它们来启用A/B测试。</p><h1 id="e2b1" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">A/B测试—实践中的目的地规则</h1><p id="8365" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">当我们有一个应用程序的两个版本(通常版本在视觉上不同)并且我们不能100%确定哪个会增加用户交互时，就使用A/B测试，所以我们同时测试两个版本并收集指标。</p><p id="d391" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">执行以下命令来部署演示A/B测试所需的第二个版本的前端:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="dfce" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/kube/ab-testing/sa-frontend-green-deployment.yaml<br/></strong>deployment.extensions/sa-frontend-green created</span></pre><p id="7539" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">绿色版本的部署清单有两点不同:</p><ol class=""><li id="498b" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">该图像基于不同的标签:<code class="du ma mb mc md b"><strong class="iw hj">istio-green</strong></code>和</li><li id="561f" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">豆荚上贴有<code class="du ma mb mc md b"><strong class="iw hj">version: green</strong></code>的标签。</li></ol><p id="f638" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">由于两个部署都有标签<code class="du ma mb mc md b"><strong class="iw hj">app: sa-frontend</strong></code>，由虚拟服务<code class="du ma mb mc md b"><strong class="iw hj">sa-external-services</strong></code> <strong class="iw hj"> </strong>路由到服务<code class="du ma mb mc md b"><strong class="iw hj">sa-frontend</strong></code>的请求将被转发到其所有实例，并将使用循环算法进行负载平衡，这导致了图16所示的问题。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/a832db1c94c55c51ccf4c82e269a7417.png" data-original-src="https://miro.medium.com/v2/format:webp/1*JD0GTy4FbRP9EHIFK80ZLA.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图16。找不到请求的文件</figcaption></figure><p id="95fa" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">找不到这些文件，因为它们在不同版本的应用程序中的名称不同。让我们验证一下:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="6c9b" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ curl --silent </strong><a class="ae js" href="http://$EXTERNAL_IP/" rel="noopener ugc nofollow" target="_blank"><strong class="md hj">http://$EXTERNAL_IP/</strong></a><strong class="md hj"> | tr '"' '\n' | grep main<br/></strong>/static/css/main.c7071b22.css<br/>/static/js/main.059f8e9c.js<br/><strong class="md hj">$ curl --silent </strong><a class="ae js" href="http://$EXTERNAL_IP/" rel="noopener ugc nofollow" target="_blank"><strong class="md hj">http://$EXTERNAL_IP/</strong></a><strong class="md hj"> | tr '"' '\n' | grep main<br/></strong>/static/css/main.f87cd8c9.css<br/>/static/js/main.f7659dbb.js</span></pre><p id="4242" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这意味着请求静态文件的一个版本的<code class="du ma mb mc md b">index.html</code>可能被负载平衡到交付另一个版本的pod，可以理解的是其他文件不存在。</p><p id="9b84" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这意味着，为了让我们的应用程序工作，我们需要引入一个限制条件，即<strong class="iw hj">“服务于index.html的应用程序版本必须服务于后续请求”</strong>。</p><p id="ca26" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我们将使用一致的哈希负载平衡来实现这一点，这个过程<strong class="iw hj">使用预定义的属性将请求从同一个客户端转发到同一个后端实例</strong>，例如HTTP头<strong class="iw hj">。</strong>因<strong class="iw hj">和</strong>的目的规则而成为可能。</p><h1 id="2514" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">目的地规则</h1><p id="7999" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">在一个请求被<strong class="iw hj"> VirtualService </strong>路由到正确的服务之后，使用<strong class="iw hj"> DestinationRules </strong>我们可以指定应用于该服务实例的流量的策略，如图17所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/636328b57cce679ffedfd75d16958f6d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jBqAaJnlk_XIKZ8unokfrg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图17。利用Istio资源进行交通管理</figcaption></figure><p id="dc97" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">注:</strong>图17以一种易于理解的方式直观地展示了Istio资源如何影响网络流量。但是，准确地说，将请求转发到哪个实例的决定是在由CRDs配置的入口网关的特使中做出的。</p><p id="2ce0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">使用目的地规则，我们可以配置负载平衡，以获得一致的哈希，并确保相同的用户由相同的服务实例响应。通过以下配置实现:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><ol class=""><li id="a04f" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">根据“版本”头的内容生成一致的哈希。</li></ol><p id="fc5d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">通过执行下面的命令来应用配置，并尝试一下！</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="25a7" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/istio/ab-testing/destinationrule-sa-frontend.yaml<br/></strong>destinationrule.networking.istio.io/sa-frontend created</span></pre><p id="bdc0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">执行以下命令，并验证在指定版本头时是否获得了相同的文件:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="73d6" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ curl --silent -H "version: yogo" </strong><a class="ae js" href="http://$EXTERNAL_IP/" rel="noopener ugc nofollow" target="_blank"><strong class="md hj">http://$EXTERNAL_IP/</strong></a><strong class="md hj"> | tr '"' '\n' | grep main</strong></span></pre><p id="d550" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">注意:</strong>你可以用这个<a class="ae js" href="https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj" rel="noopener ugc nofollow" target="_blank"> chrome扩展</a>给版本头添加不同的值，在你的浏览器中测试。</p><p id="61c6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">DestinationRules有更多的负载平衡能力，详情请查看<a class="ae js" href="https://preliminary.istio.io/docs/reference/config/istio.networking.v1alpha3.html#LoadBalancerSettings" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="d534" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在更详细地了解VirtualService之前，通过执行以下命令删除绿色版本的应用程序和目标规则:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="a183" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl delete -f resource-manifests/kube/ab-testing/sa-frontend-green-deployment.yaml<br/></strong>deployment.extensions “sa-frontend-green” deleted<br/><strong class="md hj">$ kubectl delete -f resource-manifests/istio/ab-testing/destinationrule-sa-frontend.yaml<br/></strong>destinationrule.networking.istio.io “sa-frontend” deleted</span></pre><h1 id="f048" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">影子——实践中的虚拟服务</h1><p id="49ee" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">当我们想要测试生产中的变更但不影响最终用户时，就使用影子或镜像，因此我们将请求镜像到有变更的第二个实例中并评估它。更简单地说，就是你的一个同事挑出最关键的问题，提出一个没有人能真正审查的大难题。</p><p id="1dc6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">为了测试这个特性，让我们通过执行下面的命令创建SA-Logic的第二个实例(<em class="iv">有问题</em>):</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="970a" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/kube/shadowing/sa-logic-service-buggy.yaml<br/></strong>deployment.extensions/sa-logic-buggy created</span></pre><p id="ab91" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">执行以下命令，并验证所有实例都标有各自的版本和<code class="du ma mb mc md b"><strong class="iw hj">app=sa-logic</strong></code>:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="3ed9" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl get pods -l app=sa-logic --show-labels</strong><br/>NAME                              READY   LABELS<br/>sa-logic-568498cb4d-2sjwj         2/2     app=sa-logic,<strong class="md hj">version=v1</strong><br/>sa-logic-568498cb4d-p4f8c         2/2     app=sa-logic,<strong class="md hj">version=v1</strong><br/>sa-logic-buggy-76dff55847-2fl66   2/2     app=sa-logic,<strong class="md hj">version=v2</strong><br/>sa-logic-buggy-76dff55847-kx8zz   2/2     app=sa-logic,<strong class="md hj">version=v2</strong></span></pre><p id="fcd3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">由于服务<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code>以标有<code class="du ma mb mc md b"><strong class="iw hj">app=sa-logic</strong></code>的pod为目标，任何传入的请求都将在所有实例之间进行负载平衡，如图18所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/5bb3035c382d2e13225e7ed8e838e45f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*K0L5SspnCi2uI1Wjhl8d8Q.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图18。循环负载平衡</figcaption></figure><p id="6455" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">但是我们希望将请求路由到版本为v1的实例，并镜像到版本为v2的实例，如图19所示。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/1009efa6f3489128765d07e7099f2ca1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8uf4iKo1yI3FtbcGBfR2bg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图19。路由到v1并镜像到v2</figcaption></figure><p id="3900" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是通过将VirtualService与DestinationRule结合使用来实现的，其中destination rule指定子集和到特定子集的VirtualService路由。</p><h1 id="dd8f" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用目标规则指定子集</h1><p id="f8de" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">我们使用以下配置定义子集:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><ol class=""><li id="8ff6" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">主机定义该规则仅在向<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code>服务进行路由时适用</li><li id="937b" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">路由到子集实例时使用的子集名称。</li><li id="3f38" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">Label定义了需要匹配的键值对，以使实例成为子集的一部分。</li></ol><p id="fce7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">执行以下命令，应用配置:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="d7b4" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/istio/shadowing/sa-logic-subsets-destinationrule.yaml<br/></strong>destinationrule.networking.istio.io/sa-logic created</span></pre><p id="9737" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">定义了子集后，我们可以继续并配置虚拟服务，以应用于向<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code>发出的请求，这些请求是:</p><ol class=""><li id="36a3" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">路由到名为v1的子集，</li><li id="010b" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">镜像到名为v2的子集。</li></ol><p id="eee7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是通过下面的清单实现的:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="87bb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">因为一切都是不言自明的，所以让我们看看它的实际应用:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="2310" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/istio/shadowing/sa-logic-subsets-shadowing-vs.yaml<br/></strong>virtualservice.networking.istio.io/sa-logic created</span></pre><p id="e992" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">通过执行以下命令增加一些负载:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="f99a" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ while true; do curl -v </strong><a class="ae js" rel="noopener ugc nofollow" target="_blank" href="/$EXTERNAL_IP/sentiment"><strong class="md hj">http://$EXTERNAL_IP/sentiment</strong></a><strong class="md hj"> \<br/>    -H “Content-type: application/json” \<br/>    -d ‘{“sentence”: “I love yogobella”}’; \<br/>    sleep .8; done</strong></span></pre><p id="aa32" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">检查Grafana中的结果，我们可以看到有问题的版本使大约60%的请求失败，但是没有一个失败影响最终用户，因为他们由当前活动的服务响应。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/7f199fab587318f39154fc17863a565e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hgANZ4AinrNZZsZ6jjbVCA.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图20。sa逻辑服务版本的成功率</figcaption></figure><p id="3ce8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在本节中，我们第一次看到了应用于我们服务的代理的VirtualService，当<code class="du ma mb mc md b"><strong class="iw hj">sa-web-app</strong> </code>向<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code> <strong class="iw hj"> </strong>发出请求时，该请求会通过sidecar envoy，它通过VirtualService被配置为路由到服务的子集v1并镜像到服务的子集v2。</p><p id="c711" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我可以看到你在想“该死的虚拟服务很简单！”，在下一节中，我们将把这个句子扩展为“简直太棒了！”。</p><h1 id="cae0" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">金丝雀部署</h1><p id="c572" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">Canary部署是向一小组用户推出新版本应用程序的过程，作为验证不存在问题的一个步骤，然后以更高的质量保证向更广泛的受众发布。</p><p id="a522" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我们将继续使用同样有问题的<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code>子集来演示金丝雀部署。</p><p id="302a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">让我们大胆地开始，通过应用下面的VirtualService，将20%的用户发送到错误版本(这代表canary部署),将80%的用户发送到健康服务:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><ol class=""><li id="5564" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">Weight指定转发到目标或目标子集的请求的百分比。</li></ol><p id="cbce" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">使用以下命令更新先前的<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code>虚拟服务配置:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="e679" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/istio/canary/sa-logic-subsets-canary-vs.yaml<br/></strong>virtualservice.networking.istio.io/sa-logic configured</span></pre><p id="5d5a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我们立即发现我们的一些请求失败了:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="b550" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ while true; do \<br/>   curl -i </strong><a class="ae js" rel="noopener ugc nofollow" target="_blank" href="/$EXTERNAL_IP/sentiment"><strong class="md hj">http://$EXTERNAL_IP/sentiment</strong></a><strong class="md hj"> \<br/>   -H “Content-type: application/json” \<br/>   -d ‘{“sentence”: “I love yogobella”}’ \<br/>   --silent -w “Time: %{time_total}s \t Status: %{http_code}\n” \<br/>   -o /dev/null; sleep .1; done<br/></strong>Time: 0.153075s Status: 200<br/>Time: 0.137581s Status: 200<br/>Time: 0.139345s Status: 200<br/>Time: 30.291806s Status: 500</span></pre><p id="894c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">虚拟服务支持Canary部署，通过这种方法，我们将潜在的损害减少到了20%的用户群。漂亮！现在，每当我们对代码不安全时，换句话说，总是可以使用阴影和金丝雀部署。😜</p><h1 id="c8f7" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">超时和重试次数</h1><p id="691f" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">代码并不总是有问题。在“<a class="ae js" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing#The_fallacies" rel="noopener ugc nofollow" target="_blank">分布式计算的8个谬误</a>列表中，第一个谬误是“网络是可靠的”。网络不可靠，这就是为什么我们需要超时和重试。</p><p id="0831" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">出于演示目的，我们将继续使用<code class="du ma mb mc md b"><strong class="iw hj">sa-logic</strong></code>的错误版本，其中随机故障模拟网络的不可靠性。</p><p id="b47a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">有缺陷的服务有三分之一的机会花费太长时间来响应，三分之一的机会以内部服务器错误结束，其余的成功完成。</p><p id="79c0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">为了缓解这些问题并改善用户体验，我们可以:</p><ol class=""><li id="da3a" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">如果服务时间超过8秒，则超时</li><li id="99f7" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">对失败的请求重试。</li></ol><p id="7834" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是通过以下资源定义实现的:</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="nb nc l"/></div></figure><ol class=""><li id="ef10" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr ly kc kd ke bi translated">该请求的超时时间为8秒，</li><li id="46b6" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">它尝试3次，</li><li id="9c37" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr ly kc kd ke bi translated">如果尝试时间超过3秒，将被标记为失败。</li></ol><p id="5147" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这是一种优化，因为用户等待的时间不会超过8秒，如果失败，我们会重试三次，从而增加成功响应的机会。</p><p id="ce63" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">使用以下命令应用更新的配置:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="e036" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl apply -f resource-manifests/istio/retries/sa-logic-retries-timeouts-vs.yaml<br/></strong>virtualservice.networking.istio.io/sa-logic configured</span></pre><p id="367f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">并查看成功率提高的Grafana图(如图21所示)。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="ab fe cl lw"><img src="../Images/3267816285b7ce2fafb7f925725b00af.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_b94m4BSkeBnBQg_nUUsrA.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">图21。使用超时和重试后的改进</figcaption></figure><p id="d532" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在进入下一部分之前，通过执行以下命令删除<code class="du ma mb mc md b"><strong class="iw hj">sa-logic-buggy</strong></code>和虚拟服务:</p><pre class="kl km kn ko fd me md mf mg aw mh bi"><span id="e23c" class="mi ku hi md b fi mj mk l ml mm"><strong class="md hj">$ kubectl delete deployment sa-logic-buggy<br/></strong>deployment.extensions “sa-logic-buggy” deleted<br/><strong class="md hj">$ kubectl delete virtualservice sa-logic<br/></strong>virtualservice.networking.istio.io “sa-logic” deleted</span></pre><h1 id="1e1c" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">断路器和隔板模式</h1><p id="9e9d" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">微服务架构中支持服务自我修复的两种重要模式。</p><p id="40cf" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">断路器</strong>用于阻止发送到被认为不健康的服务实例的请求，并使其能够恢复，同时客户端的请求被转发到该服务的健康实例(提高成功率)。</p><p id="ce8e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated"><strong class="iw hj">隔板模式</strong>隔离故障，防止整个系统停机，例如，服务B处于损坏状态，另一个服务(服务B的客户端)向服务B发出请求。这将导致客户端耗尽自己的线程池，无法为其他请求提供服务(即使这些请求与服务B无关)。</p><p id="8a8f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我将跳过这些模式的实现，因为您可以在<a class="ae js" href="https://istio.io/docs/tasks/traffic-management/circuit-breaking/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中查看实现，我对展示认证和授权太兴奋了，这将是下一篇文章的主题。</p><h1 id="5efa" class="kt ku hi bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">第一部分——总结</h1><p id="affe" class="pw-post-body-paragraph it iu hi iw b ix lr iz ja jb ls jd je jt lt jh ji ju lu jl jm jv lv jp jq jr hb bi translated">在本文中，我们在Kubernetes集群中部署了Istio，并使用其定制资源定义，如<strong class="iw hj">网关</strong>、<strong class="iw hj">虚拟服务</strong>、<strong class="iw hj">目的地规则</strong>及其组件，它实现了以下特性:</p><ul class=""><li id="5071" class="jw jx hi iw b ix iy jb jc jt jy ju jz jv ka jr kb kc kd ke bi translated">通过使用<strong class="iw hj"> Kiali </strong>回答哪些服务正在运行、它们的性能如何以及它们之间的关系，来观察我们的服务。</li><li id="56f2" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated">使用<strong class="iw hj"> Prometheus </strong>和<strong class="iw hj"> Grafana </strong>进行度量收集和可视化。</li><li id="2685" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated">用<strong class="iw hj"> Jaeger </strong>请求追踪(德语为猎人)。</li><li id="4ec9" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated">对网络流量进行全面精细的控制，支持<strong class="iw hj">金丝雀部署</strong>、<strong class="iw hj"> A/B测试和阴影</strong>。</li><li id="d336" class="jw jx hi iw b ix kf jb kg jt kh ju ki jv kj jr kb kc kd ke bi translated">轻松实现<strong class="iw hj">重试、超时和断路器</strong>。</li></ul><p id="0a76" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">所有这一切都是可能的，无需代码更改或任何额外的依赖，保持您的服务小，易于操作和维护。</p><p id="dc3a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">对于您的开发团队来说，移除这些横切关注点并将它们集中到Istio的控制平面中，意味着新服务易于引入，它们不会占用大量资源，因为开发人员可以专注于解决业务问题。而且到目前为止，没有一个开发者抱怨“必须解决有趣的业务问题！”。</p><p id="46e2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我很乐意在下面的评论中听到你的想法，也可以随时通过推特或我的主页rinormaloku.com T2联系我。</p></div><div class="ab cl nd ne gp nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hb hc hd he hf"><p id="0884" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">事不宜迟，让我们进入第二部分<a class="ae js" rel="noopener" href="/google-cloud/back-to-microservices-with-istio-part-2-authentication-authorization-b079f77358ac">回到使用Istio(第2部分)</a>的微服务，让我们处理认证和授权！</p></div></div>    
</body>
</html>