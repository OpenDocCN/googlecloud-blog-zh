<html>
<head>
<title>Hybrid Integration with Apache Camel and Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Apache Camel和Google云平台的混合集成</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/deploying-apache-camel-to-google-kubernetes-engine-a2b8290b070f?source=collection_archive---------0-----------------------#2017-12-03">https://medium.com/google-cloud/deploying-apache-camel-to-google-kubernetes-engine-a2b8290b070f?source=collection_archive---------0-----------------------#2017-12-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d5ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章来源于我在过去几个月中的一些讨论，涉及我们的云集成堆栈——Apache Camel部署到Google Kubernetes引擎。所以我决定把思路总结在一个地方，需要的时候可以参考。</p><p id="5659" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将简要概述<em class="jd">为什么</em>以及<em class="jd">如何</em>的关键方面。</p><p id="ae61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里引用的例子是完全可操作的。我的<a class="ae je" href="https://github.com/evmin/camel-kubernetes-demo" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中提供了示例代码，包括获取<a class="ae je" href="https://github.com/evmin/camel-kubernetes-demo/blob/master/reference/02_toolstack_required.md" rel="noopener ugc nofollow" target="_blank">所需工具栈</a>、<a class="ae je" href="https://github.com/evmin/camel-kubernetes-demo/blob/master/reference/03_gcp_setup.md" rel="noopener ugc nofollow" target="_blank">设置Google云基础设施</a>、<a class="ae je" href="https://github.com/evmin/camel-kubernetes-demo/blob/master/reference/04_build_deploy.md" rel="noopener ugc nofollow" target="_blank">构建和部署</a>过程的详细演练。</p><h1 id="2a68" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">为什么是骆驼？</h1><p id="70f2" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated"><a class="ae je" href="http://camel.apache.org" rel="noopener ugc nofollow" target="_blank"> Apache Camel </a>是一个路由和中介引擎，可以被认为是Gregor Hohpe和Bobby Woolf定义的大多数<a class="ae je" href="http://www.enterpriseintegrationpatterns.com" rel="noopener ugc nofollow" target="_blank">企业集成模式</a>的参考实现。</p><p id="682a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个顶级的Apache项目，它得到了很好的支持，并带有一个慷慨的<a class="ae je" href="http://www.apache.org/licenses/LICENSE-2.0.html" rel="noopener ugc nofollow" target="_blank"> Apache2.0 </a>许可，这是企业友好的。</p><p id="2e91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它很容易扩展，提供了一个符合马丁·福勒描述的流畅接口原则(T21)的配置DSL(包括大量的组件和适配器)。</p><p id="f194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看更详细的评论，请查看Jonathan Anstey <a class="ae je" href="https://dzone.com/articles/open-source-integration-apache" rel="noopener ugc nofollow" target="_blank">的一篇非常精彩的摘要，该摘要介绍了与Apache Camel </a>的开源集成。</p><h1 id="d15f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">为什么选择Kubernetes发动机？</h1><p id="9a2d" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">为什么在无服务器计算越来越流行的世界里做容器和Kubernetes呢？</p><p id="0b7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管我很喜欢无服务器架构，但基于容器的部署仍然被认为更加灵活。这种灵活性对于集成任务非常重要，在集成任务中，需求在依赖性、延迟和执行时间方面可能有些特殊。例如，无服务器部署对于长时间运行的流程不是特别友好。</p><p id="2084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，Docker容器在无状态、易于定制和很好地处理异常任务之间取得了平衡。Kubernetes作为新兴的事实上的标准的普遍采用，预先定义了管弦乐队的选择。这太棒了——看看为什么只需跟随一个典型的DevOps团队一天，并检查Kubernetes解决他们的挑战的方式。</p><h1 id="130a" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">为什么是谷歌？</h1><p id="8268" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">谷歌是Kuberenetes的发源地。它源于谷歌大规模运行容器化应用的经验。因此，虽然市场上有一些Kubernetes PAAS，但新功能通常会首先在谷歌云平台上发布。在我看来，出色的支持和优惠的价格使它成为最好的产品之一。</p><p id="622a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是GCP不仅仅是库伯内特人。这是所有的附加功能——日志记录、监控、持久性、发布/订阅、分析等——所有这些都让开发人员易于使用。</p><p id="fd2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google Cloud Platform提供了一种设计方法，架构师只需选择一组PAAS功能，就可以组成一个业务解决方案。然而，基础架构是由其他人运营的，对于同等的性能、功能和支持质量而言，这是一个更便宜的选择。</p><h1 id="35a9" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">为什么骆驼在谷歌云平台？</h1><p id="6564" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">但在已经丰富的谷歌云平台生态系统中，阿帕奇骆驼还有一席之地吗？是否真的需要它的能力？例如，为什么不使用Spark或Apache Beam？两者都是可管理的基础设施——分别是Dataproc和Dataflow。为什么不是后者？</p><p id="7656" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，数据流是一个神奇的产品。对于必须进行动态会话计算的大规模运营来说，它是不可替代的，并且它与GCP技术的其余部分的预集成非常棒。</p><p id="5160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，让我们考虑更简单的场景，在这种场景中，重点更多地放在消息处理和编排上，而不是数据处理，在这种场景中，每天只有几百万次交换需要处理，在这种场景中，需要集成大量外部系统。数据流会变得有点沉重和昂贵。</p><p id="2804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据流的最低部署实体是虚拟机。半打纯数据流解决方案最终会花费相当大的成本。</p><p id="5449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，目前还没有太多的第三方系统适配器可用于数据流，因此集成需要努力和一些定制的低级代码。</p><p id="db82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是库伯内特斯骆驼的用武之地。最底层的部署实体是容器——即使配置了少量的适配器和组件，多个部署也可以放入一个虚拟机中。</p><p id="4ce4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现成可用的Apache Camel组件的数量使得集成和编排任务变得简单，并且Google生态系统也得以实现——有针对Google PubSub和BigQuery的预打包适配器。</p><p id="6187" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从我的角度来看，Apache Camel为遗留应用程序和复杂集成解决方案解锁了Google云平台，补充了现有的Google功能，如Dataflow。</p><p id="bcc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是够了<em class="jd">“为什么？”</em>，让我们继续<em class="jd">“如何？”</em>。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="ce74" class="jf jg hi bd jh ji kp jk jl jm kq jo jp jq kr js jt ju ks jw jx jy kt ka kb kc bi translated">怎么会？</h1><p id="4cc2" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">本节涵盖了在Google云平台上解锁Apache Camel的关键实现方面:</p><ul class=""><li id="caa3" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">配置和参数</li><li id="222d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">记录</li><li id="76d6" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">指标收集和监控</li><li id="c254" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">使用Hawtio控制台进行实时自省</li></ul><h1 id="21e2" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">示例场景</h1><p id="dbaa" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">示例解决方案基于一个广为认可的<a class="ae je" href="https://egkatzioura.com/2017/11/20/spring-boot-and-apache-camel" rel="noopener ugc nofollow" target="_blank">骆驼/ Spring Boot组合</a>，实现了以下集成场景:</p><ul class=""><li id="30af" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">Camel使用了来自Google PubSub订阅的一条消息</li><li id="ef4e" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">转换数据</li><li id="08ce" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">更新标头以定义BigQuery表分区</li><li id="58d9" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">写入BigQuery表</li></ul><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es li"><img src="../Images/fc58e91ca66a7e0f1d3e82329e5d43a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s2FAe5LJPCWso5yh.png"/></div></div></figure><p id="8193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者它在代码中的样子</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="d315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM和Camel的操作指标由StackDriver Monitoring收集，日志输出被定向到Stackdriver Logging。</p><p id="d23c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案被打包为Docker映像，存储在GCP容器注册中心，并部署到GCP Kubernetes引擎。</p><h1 id="bbe1" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">因素</h1><p id="759b" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">Kubernetes提供了两种现成的机制来将配置设置传递到容器中:配置映射或秘密。一旦在集群中定义了这些变量，它们的值就可以作为文件或环境变量供应用程序使用。</p><p id="32ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该演示依赖于<a class="ae je" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html" rel="noopener ugc nofollow" target="_blank"> Spring Boot的外部化配置功能</a>来接收这两种类型，这提供了在CI/CD生命周期的任何阶段覆盖它们的灵活性。</p><p id="b51f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蓝图规定有四个地方可以配置Spring Boot属性:</p><ol class=""><li id="22d4" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc lw la lb lc bi translated">Spring Boot <code class="du lx ly lz ma b">application.properties</code>。不能覆盖此处定义的值。通常用于Spring Boot配置和不可修改的设置。</li><li id="a55b" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc lw la lb lc bi translated">自定义<code class="du lx ly lz ma b">default.properties</code>。开发人员通常在这里定义应用程序的默认设置。</li><li id="755e" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc lw la lb lc bi translated">由<code class="du lx ly lz ma b">${external.config}</code> java属性指向的可选文件。该文件通常供选择使用外部文件而不是环境变量的系统管理员使用。</li><li id="56e4" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc lw la lb lc bi translated">在Docker映像中或通过Kubernetes部署定义的环境变量。这些被Spring Boot捕获并转换成Java属性。</li></ol><p id="2e67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请注意</strong> —后三者的关系很重要。</p><p id="1c5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选项2和3在<code class="du lx ly lz ma b">ApplicationMain.java</code>中明确配置:</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="9128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且它们的列表顺序定义了偏好:</p><ul class=""><li id="986e" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">在<code class="du lx ly lz ma b">default.properties</code>(选项2)中定义的属性将被外部文件<code class="du lx ly lz ma b">${external.config}</code>(选项3)中定义的值<strong class="ih hj">覆盖</strong>-如果在两者中定义了相同的关键字。</li><li id="b3ed" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">通过环境变量定义的值—选项4 — <strong class="ih hj">取代了来自任一属性文件的值。</strong></li></ul><p id="6a9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，开发人员可以选择使用一些定义良好的缺省值，提供他们自己的配置，并且允许管理员通过外部配置文件或环境变量来覆盖这些配置。</p><p id="bf9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种灵活性虽然很少需要，但在一些不常见的情况下非常有用。</p><h1 id="cd81" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">记录</h1><p id="2a10" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">从表面上看，日志记录非常容易——Kubernetes引擎自动将容器标准输出流发送给Stackdriver日志记录。不需要配置。简单！</p><p id="8560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，有几个问题。第一个——收集的每一行都成为一个单独的日志条目。这有什么不好？嗯，java异常通常是多行堆栈跟踪——在多个日志条目中读取这些异常可能会有点混乱。</p><p id="6356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个有趣的地方是，这些条目将被记录为INFO。Google Kubernetes日志代理FluentD不知道如何解析它们以获得正确的严重性。有许多不同的格式，所以一个尺寸适合所有自动解决方案确实是一个难题。</p><p id="4ab1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，应用程序可以以FluentD能够理解的格式提供输出。格式是在<code class="du lx ly lz ma b">logback.xml</code>中定义的——一个JSON字符串，其中的字段名按照FluentD解析器的要求进行配置。感谢<a class="ae je" href="https://www.elastic.co/products/logstash" rel="noopener ugc nofollow" target="_blank">Elastic.co</a>团队，他们提供了一个非常棒的Logstash组件，将多行堆栈跟踪封装到一个条目中！</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="d4d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查输出:</p><pre class="lj lk ll lm fd mb ma mc md aw me bi"><span id="34bb" class="mf jg hi ma b fi mg mh l mi mj">kubectl logs -f deploy/gke-camel-template</span></pre><p id="6520" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="lj lk ll lm fd mb ma mc md aw me bi"><span id="826d" class="mf jg hi ma b fi mg mh l mi mj">{"severity":"INFO","message":"org.foo.ApplicationMain | Starting ApplicationMain v1.0.0-SNAPSHOT on gke-camel-template-7b4bd9ccdb-dns4l with PID 1 (/u00/lib/gke-camel-template-1.0.0-SNAPSHOT.jar started by root in /u00)"}</span></pre><p id="adc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，严重性已经明确设置。让我们检查一下<a class="ae je" href="https://console.cloud.google.com/logs/viewer" rel="noopener ugc nofollow" target="_blank">堆栈驱动程序日志UI </a>以确认它已经被正确解析:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mk"><img src="../Images/6d75f6bf3ad540a10e439b821ce2f868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SrP0ZV3jXs1zGCq6.jpg"/></div></div></figure><p id="12d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切都好。</p><p id="6ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也允许一个很好的和容易的过滤，它甚至在流模式下工作，在流模式下，日志条目在[实时]到达时显示:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ml"><img src="../Images/31dfb0fef5631f46fc518cf9182bb784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0gFLEi6qSK0LYCia.jpg"/></div></div></figure><p id="9787" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意异常是如何包含在单个条目中的:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mm"><img src="../Images/e169b9c36b2443a3903fcef2fcd99625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9y5fk5TqQ0k8offH.jpg"/></div></div></figure><p id="a5fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个有趣的地方是，Google Stackdriver日志允许基于日志的度量，并且将严重性作为选择条件可以使这个过程更快一些。</p><p id="a000" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看运行容器的内部。</p><h1 id="b78c" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">指标收集和监控</h1><p id="af00" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">引用开尔文勋爵的话:</p><blockquote class="mn mo mp"><p id="a1e6" class="if ig jd ih b ii ij ik il im in io ip mq ir is it mr iv iw ix ms iz ja jb jc hb bi translated">如果你不能衡量它，你就不能改进它。</p></blockquote><p id="3352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抛开围绕这一表达本质的哲学争论，我希望大家都同意跟踪应用程序性能指标是至关重要的。</p><p id="9b75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">围绕从容器化应用程序中捕获指标，有两种通用方法——外部收集爬虫(sidecar容器、节点服务等)或应用程序本身报告。</p><p id="e7b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里提出的选择可以被认为是两者之间的中间道路。</p><p id="4d8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管它是“报告”模式，但它是由JVM代理实现的，与应用程序相隔离。</p><p id="af75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例包括<a class="ae je" href="https://github.com/jmxtrans/jmxtrans-agent" rel="noopener ugc nofollow" target="_blank"> Jmxtrans代理</a>——一个java代理，它通过JMX定期检查应用程序，并通过特定的编写器向收集点报告指标，而Goggle云平台由<a class="ae je" href="https://github.com/jmxtrans/jmxtrans-agent/tree/master/src/main/java/org/jmxtrans/agent/google" rel="noopener ugc nofollow" target="_blank"> Google Stackdriver编写器</a>支持。</p><p id="8eb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">java代理是完全独立的，虽然它是在应用程序之前加载的，但它不会干扰应用程序库。它是一个通用的java代理——只要支持JMX，就可以与任何基于JVM的应用程序一起使用。</p><p id="7ccf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然出于演示的目的，度量收集器和配置文件包含在项目本身中，但更好的方法是将它们放入基本Docker映像中。</p><p id="7729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，虽然为收集JVM和Apache Camel指标提供了一个合理的默认配置，但如果开发人员或管理员需要更细粒度的自省，它仍然可以被不同的配置文件所取代。</p><p id="803a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dockerfile示例:</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="671d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及metrics.xml中的几个示例:</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="4837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的Camel度量配置是一个模板，它指示代理捕获JVM中所有Camel上下文中所有路由的已完成交换的计数。</p><p id="ad2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以这种方式收集的指标被归类为自定义指标，可通过<a class="ae je" href="https://app.google.stackdriver.com" rel="noopener ugc nofollow" target="_blank"> Stackdriver监控仪表板</a>获得。</p><p id="e627" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请查看<a class="ae je" href="https://github.com/jmxtrans/jmxtrans-agent" rel="noopener ugc nofollow" target="_blank"> Jmxtrans代理文档</a>以了解关于占位符和一般配置的更多信息。关于规格与累积类型以及配置自定义指标的具体信息，请参考<a class="ae je" href="https://cloud.google.com/monitoring/docs/" rel="noopener ugc nofollow" target="_blank">Google stack driver Metrics API doco</a>。</p><p id="5901" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序唯一需要明确提供的是APM_META_NAME环境变量——在原始部署的保护伞下对指标进行分组，类似于日志记录的方式。目前，Kubernetes容器无法推断创建它的实体——是部署、作业还是cron Job——因此它是一个强制配置选项。</p><p id="d882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该参数通常作为环境变量包含在Kubernetes部署YAML中:</p><figure class="lj lk ll lm fd ln"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="cbe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意属性和元名称如何允许粒度度量选择:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mt"><img src="../Images/63aebfe6c0bca90403b74d777935ad5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*luOTnLCJBnUBR8Cv.jpg"/></div></div></figure><p id="0b27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还可以在自定义指标名称前添加前缀。在这种情况下，它是“foo ”,并且已在metrics.xml配置文件中明确定义:</p><pre class="lj lk ll lm fd mb ma mc md aw me bi"><span id="f10c" class="mf jg hi ma b fi mg mh l mi mj">&lt;namePrefix&gt;foo.&lt;/namePrefix&gt;</span></pre><p id="6743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重要！</strong></p><p id="7d68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GOOGLE_APPLICATION_CREDENTIALS是一个环境变量，它通常为GOOGLE云平台驱动程序定义身份密钥的位置。</p><p id="7073" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而在这个例子中，即使GOOGLE_APPLICATION_CREDENTIALS环境变量被显式配置，Jmxtrans代理Google Stackdriver Writer <strong class="ih hj">在Google Kubernetes引擎中执行时将忽略</strong>它。Kubernetes引擎集群通过内部API向pods提供服务帐户。Jmxtrans代理Stackdriver Writer检查API在启动时是否可用。如果是这样，Kubernetes集群服务帐户将被优先考虑。</p><p id="56cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，日志记录和监控操作都由同一个身份——集群服务帐户授权，而GOOGLE_APPLICATION_CREDENTIALS密钥只由应用程序使用。为了说明这一点，授予GOOGLE_APPLICATION_CREDENTIALS引用的键的唯一访问权限是PubSub和BigQuery。</p><p id="bdb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，当代理在Kubernetes集群之外运行时(即没有可用的内部API)，它将退回到通过GOOGLE_APPLICATION_CREDENTIALS配置的身份。</p><h1 id="2af8" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">Hawtio控制台</h1><p id="f3b6" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在生产中访问Camel上下文可能是快速解决问题的关键。Hawtio UI 通过其Camel插件提供了这种可能性(甚至允许修改路线！).</p><p id="c611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，将Hawtio组件与每个部署一起打包是不切实际的，因为这会增加相当大的内存开销，有时会使内存占用加倍。即使RAM很便宜，也应该避免用于微服务风格的部署。</p><p id="928a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，Hawtio也可以作为独立的应用程序运行——它只需要访问Jolokia JMX端点。这已经被Spring Boot实现了！</p><p id="8be2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">build.grade摘录:</p><pre class="lj lk ll lm fd mb ma mc md aw me bi"><span id="3c32" class="mf jg hi ma b fi mg mh l mi mj">// Logging and Monitoring <br/>compile "org.jolokia:jolokia-core:1.3.7" <br/>compile "net.logstash.logback:logstash-logback-encoder:4.9"</span></pre><p id="53d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spring Boot应用程序.属性:</p><pre class="lj lk ll lm fd mb ma mc md aw me bi"><span id="013d" class="mf jg hi ma b fi mg mh l mi mj">server.port = 8091 <br/>camel.springboot.jmxEnabled=true </span><span id="73ad" class="mf jg hi ma b fi mu mh l mi mj">endpoints.jolokia.sensitive=false <br/>endpoints.health.sensitive=false</span></pre><p id="f60d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于安全原因，Jolokia港口没有暴露在集装箱之外，进入港口的唯一途径是通过隧道。Kubernetes用它的<code class="du lx ly lz ma b">port-forward</code>命令提供了这样的隧道:</p><pre class="lj lk ll lm fd mb ma mc md aw me bi"><span id="baef" class="mf jg hi ma b fi mg mh l mi mj">kubectl port-forward &lt;pod_name&gt; &lt;port&gt; </span><span id="446d" class="mf jg hi ma b fi mu mh l mi mj"># Executable example <br/>kubectl port-forward $(kubectl get po | grep gke-camel | cut -d" " -f1) 8091</span></pre><p id="ffef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将有效地将本地机器上的端口8091映射到容器中的端口。</p><p id="d0f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在独立模式下启动Hawtio并选择“连接”选项卡。将端口更改为<strong class="ih hj"> 8091 </strong>并点击连接:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mv"><img src="../Images/8597f8f414e9ac84ea62914b601140a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5OsxYDgZC1TXV5LO.jpg"/></div></div></figure><p id="6f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这为我们提供了远程Camel上下文的Hawtio控制台:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mw"><img src="../Images/7d839c4a5b102b1bda8871d01e23e9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CxXTAX6Br_H4V_JQ.jpg"/></div></div></figure><p id="8f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">环顾四周——调试、跟踪、路由更新——它非常强大。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="2a4c" class="jf jg hi bd jh ji kp jk jl jm kq jo jp jq kr js jt ju ks jw jx jy kt ka kb kc bi translated">结论</h1><p id="3d84" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">这个演示展示了如何为Google Kubernetes引擎、PubSub、BigQuery和Stackdriver配置Camel应用程序。</p><p id="c934" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该蓝图提供了一种灵活、有弹性且可扩展的方法，经过了数十个生产集成部署的实战测试。</p><p id="13ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而蓝图的基础是多方面的。任何基于JVM的应用程序都可以以这种方式部署——我们自己已经在基于Apache Camel和Clojure的解决方案中使用了这种方式。</p><p id="ba57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于Kubernetes是容器化部署的事实上的标准，这样的设置可以在任何地方复制——Azure、AWS、IBM、RedHat。</p><p id="28cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该代码不提供任何形式的担保，因此任何真正的使用风险自负。</p><h1 id="c36c" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">支持</h1><p id="2b11" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">然而，对于这个想法，我建议考虑通过<a class="ae je" href="https://www.redhat.com/en/technologies/jboss-middleware/fuse" rel="noopener ugc nofollow" target="_blank"> RedHat </a>订阅Apache Camel support。</p><p id="5f34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">能够接触到澳大利亚、英国和丹麦的优秀团队是无价的。他们的深刻理解和实践经验在很多情况下被证明是非常宝贵的。</p></div></div>    
</body>
</html>