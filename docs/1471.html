<html>
<head>
<title>Reading NUMERIC fields with BigQueryIO in Apache Beam</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用BigQueryIO读取Apache Beam中的数值字段</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/reading-numeric-fields-with-bigqueryio-in-apache-beam-23273a9d0c99?source=collection_archive---------0-----------------------#2020-06-15">https://medium.com/google-cloud/reading-numeric-fields-with-bigqueryio-in-apache-beam-23273a9d0c99?source=collection_archive---------0-----------------------#2020-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cb7c3d5f3de1e8020e2032c11fb13d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrihxRwdUMgOz9oZE5WLOg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用Apache Beam的BigQueryIO从BigQuery读取数值字段</figcaption></figure><p id="39e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在BigQuery的所有数字类型中，<a class="ae js" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#numeric_type" rel="noopener ugc nofollow" target="_blank"> NUMERIC </a>提供了最长的精度(38位)和小数位数(9位)，这使得它成为需要很长精度的应用程序的首选。在BigQuery中处理数值很简单，但是在从BigQuery中读取数据的Apache Beam管道中就不那么简单了。在本文中，我们将看到如何使用BigQueryIO从BigQuery读取这个数值类型，这样我们就可以在管道中使用精度尽可能长的十进制值。</p><p id="bc34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当使用<a class="ae js" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Beam </a>和<a class="ae js" href="https://beam.apache.org/releases/javadoc/2.22.0/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIO.html" rel="noopener ugc nofollow" target="_blank"> BigQueryIO </a>从<a class="ae js" href="https://cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>读取数据时，从BigQuery读取记录有两种主要方式:使用<code class="du jt ju jv jw b">read(SerializableFunction)</code>(将Avro <code class="du jt ju jv jw b">GenericRecord</code>转换为自定义类)或<code class="du jt ju jv jw b">readTableRows</code>(更容易使用，但性能较低)。</p><p id="f20c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此<code class="du jt ju jv jw b">read</code>提供了最佳的性能，但是它以开发人员的成本为代价:您需要将每个字段解析成正确的Java类型。</p><p id="240c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">没什么大不了的，是吧？好吧，让我们看看BigQueryIO 的<a class="ae js" href="https://beam.apache.org/releases/javadoc/2.22.0/org/apache/beam/sdk/io/gcp/bigquery/BigQueryIO.html" rel="noopener ugc nofollow" target="_blank">文档中的转换表:</a></p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es jx"><img src="../Images/7c4143f45e16b098df82dced4a650a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*bMn8qtP3f5jzqhlLJCPAwQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">从BigQuery读取Avro记录时的类型转换</figcaption></figure><p id="5f0a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所有类型看起来都很简单(boolean映射到BOOLEAN，FLOAT64映射到double，等等。).</p><p id="9e5f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，等一下，NUMERIC的Java类型是什么？这是一个字节缓冲器…</p><p id="b2a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们如何在Java中将它转化成一个数字呢？</p><p id="2cf0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看如何在Beam中解析Avro字段并将它们映射到Java类型。</p><p id="d276" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设我们正在从BigQuery中读取数据，我们希望将表中的一行映射到我们的自定义类<code class="du jt ju jv jw b">SomeCustomObject</code>。我们可以在BigQueryIO中这样做，如下所示:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div></figure><p id="aada" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们在<code class="du jt ju jv jw b">GenericRecord</code>中获得行值，现在我们需要将内容解析成正确的类型。使用上表，对于大多数基本类型来说，这是一个微不足道的任务。例如，对于字符串、长或双数:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div></figure><p id="f794" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码假设<code class="du jt ju jv jw b">fieldName1</code>是包含字符串的列名，<code class="du jt ju jv jw b">fieldName2</code>是包含长整型的列，<code class="du jt ju jv jw b">fieldName3</code>是包含双精度型的列。在生产环境中，实际检查字段的类型是明智的。我们在下面看到如何检查类型。</p><p id="caa2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果BigQuery中的列包含数字，我们如何进行转换呢？</p><p id="69b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种转变更加复杂。总之，我们需要将字节数组映射到一个<code class="du jt ju jv jw b">java.math.BigDecimal</code>，因为其他数字类型没有足够的精度来保存一个数字。但是对<code class="du jt ju jv jw b">BigDecimal</code>进行这样的映射需要几个步骤。</p><p id="0925" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们从一开始就把事情做对。让我们首先检查一下类型是否为BYTES。当使用GenericRecords时，我实际上总是试图编写一个函数，该函数使用一个<code class="du jt ju jv jw b">switch</code>来尝试为每种Avro类型找到正确的解析代码。在下面的代码中，我们只包含了数字对象的代码。在这篇文章的后面，我会在同一个<code class="du jt ju jv jw b">switch</code>中包含更多类型的完整代码的链接。</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div></figure><p id="c5c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们<a class="ae js" href="https://gist.github.com/iht/e848365e8f3a4c06fefba8c2967100cd#file-readnumeric-java-L8" rel="noopener ugc nofollow" target="_blank">确定类型是BYTES </a>(第8行)之后，我们检查是否有逻辑类型。那是什么？BYTES实际上用于两种大查询类型:BYTES和NUMERIC。NUMERIC类型有一个额外的<em class="ke">逻辑类型</em>，它包含Avro GenericRecord中编码的数字的精度和小数位数。</p><p id="145e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要找出<strong class="iw hj">的小数位数</strong>，以便能够将字节数组解析为一个数字。这是在上面代码片段的第16行和第17行中完成的；标度实际上是Avro GenericRecord模式的一部分。</p><p id="6b95" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GenericRecord中的值被编码为ByteBuffer ( <a class="ae js" href="https://gist.github.com/iht/e848365e8f3a4c06fefba8c2967100cd#file-readnumeric-java-L19" rel="noopener ugc nofollow" target="_blank">第19行</a>)。然后，我们获取ByteBuffer并将其解析为BigDecimal，使用我们刚刚恢复的scale值(<a class="ae js" href="https://gist.github.com/iht/e848365e8f3a4c06fefba8c2967100cd#file-readnumeric-java-L20-L22" rel="noopener ugc nofollow" target="_blank">第20–22行</a>)。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="8c8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Beam中，我们如何将上述所有内容结合起来从BigQuery中读取数据？<a class="ae js" href="https://gist.github.com/iht/7f8a8f4984a7640fd05220096b098f64" rel="noopener ugc nofollow" target="_blank">我添加了一个要点和一个完整的管道示例</a>。在这个例子中，输入是一个只有两个字段的表:<em class="ke"> key </em>是STRING类型的列，而<em class="ke"> value </em>是NUMERIC类型的列。该示例包含一个通用函数<a class="ae js" href="https://gist.github.com/iht/7f8a8f4984a7640fd05220096b098f64#file-readnumericinbeam-java-L40-L94" rel="noopener ugc nofollow" target="_blank">，用于从通用记录</a>中解析不同类型的数据。我们需要知道我们正在读取的字段的类型以使用该函数(参见如何使用该函数读取<em class="ke">键</em>和<em class="ke">值</em>列的<a class="ae js" href="https://gist.github.com/iht/7f8a8f4984a7640fd05220096b098f64#file-readnumericinbeam-java-L113-L114" rel="noopener ugc nofollow" target="_blank">示例)。该函数比其余代码片段中显示的代码稍微复杂一些，因为在Avro中，可空的BigQuery列实际上被表示为一个<em class="ke"> union </em>。但是可空字段将是另一篇文章的主题！—注意:</a><a class="ae js" rel="noopener" href="/@iht/reading-nullable-fields-with-bigqueryio-in-apache-beam-f0e36e1f6c7">发布可空字段的帖子！</a></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="cbe1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，如果您有一个NUMERIC类型的列，不要因为试图从Apache Beam管道中读取它而感到沮丧。您仍然可以使用<code class="du jt ju jv jw b">GenericRecord</code>并比使用<code class="du jt ju jv jw b">TableRows</code>获得更多的性能，您只需要从模式中提取数字的比例，并使用它来构造一个<code class="du jt ju jv jw b">BigDecimal</code>对象。</p></div></div>    
</body>
</html>