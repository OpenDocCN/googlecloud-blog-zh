<html>
<head>
<title>Kubernetes: Running Background Tasks With Batch-Jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:使用批处理作业运行后台任务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-running-background-tasks-with-batch-jobs-56482fbc853?source=collection_archive---------0-----------------------#2018-08-07">https://medium.com/google-cloud/kubernetes-running-background-tasks-with-batch-jobs-56482fbc853?source=collection_archive---------0-----------------------#2018-08-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7e4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在构建令人惊叹的应用程序时，有时您可能希望处理用户请求/响应生命周期之外的动作。如果你想对基于时间的事件做出反应，那么你会想看看cron jobs 。如果您想在用户的请求/响应生命周期之外启动一个流程，但不是基于时间，那么您会看到批处理作业。批处理作业可以由任意数量的触发器启动，并且可以运行复杂的任务，而不会影响用户的响应时间。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/d0d0bbf5703b0c4826d3e56066fc4b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OT5fYILOQj15WLY4"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">乔纳森·法伯在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9605" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将看看如何以几种不同的方式运行批处理作业:<strong class="ih hj">一次性</strong>、<strong class="ih hj">顺序</strong>和<strong class="ih hj">并行</strong>。</p><p id="77c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">如果你没有通读甚至没有读过本系列的第一部分</em><a class="ae jd" rel="noopener" href="/@jonbcampos/kubernetes-day-one-30a80b5dcb29"><em class="ju"/></a><em class="ju">你可能会感到困惑，对代码在哪里或者之前做了什么有疑问。记住这里假设你正在使用</em><a class="ae jd" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"><em class="ju"/></a><em class="ju">和</em><a class="ae jd" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"><em class="ju"/></a><em class="ju">。我将始终提供代码和如何测试代码是按预期工作。</em></p><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-day-one-30a80b5dcb29"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:第一天</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ki l kj kk kl kh km jo jy"/></div></div></a></div><h1 id="2e45" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">设置您的Kubernetes集群</h1><p id="f677" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">与本系列中的其他文章不同，本文将让我们运行更多的脚本来查看我们的批处理作业。因此，我们需要从设置一次Kubernetes集群开始，并在集群上继续运行作业。下面是使用Google Kubernetes引擎在Google Cloud中设置Kubernetes集群的脚本。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="391e" class="lv ko hi lr b fi lw lx l ly lz">$ git clone <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series.git" rel="noopener ugc nofollow" target="_blank">https://github.com/jonbcampos/kubernetes-series.git</a><br/>$ cd <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/tree/master/batch-job/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/batch-job/scripts</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/scripts/startup.sh" rel="noopener ugc nofollow" target="_blank">startup.sh</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/scripts/deploy.sh" rel="noopener ugc nofollow" target="_blank">deploy.sh</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/scripts/check-endpoint.sh" rel="noopener ugc nofollow" target="_blank">check-endpoint.sh</a> endpoints</span></pre><p id="c9ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着这些脚本的运行，您将有一个Kubernetes集群在您的Google Cloud项目中运行。此外，请注意由<code class="du ma mb mc lr b"><a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/scripts/check-endpoint.sh" rel="noopener ugc nofollow" target="_blank">check-endpoint.sh</a></code>命令透露的IP地址。这将是我们稍后用来查看批处理作业输出的IP地址。</p><blockquote class="md me mf"><p id="5677" class="if ig ju ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">注意:您可以在<code class="du ma mb mc lr b">http://[IP_Address]/data</code>查看批处理文件的结果。当我们通过各种方式运行您的批处理作业时，您会看到数据被记录到此位置。</p></blockquote><h1 id="796c" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建一次性Kubernetes工作</h1><p id="fa99" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">有时你可能有一些只需要运行一次的脚本。也许是迁移脚本。也许是一个脚本来修复一些丢失的数据。不管是什么原因，你都需要运行一次。对于本例，我们假设您已经准备好了要运行的代码，如我为您设置的简单容器/脚本所示。</p><p id="0bd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备好您想要运行的容器后，我们只需要创建我们的<a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/k8s/single-job.yaml#L1-L29" rel="noopener ugc nofollow" target="_blank"> yaml文件</a>。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="1b51" class="lv ko hi lr b fi lw lx l ly lz"><strong class="lr hj">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: single-job<br/>spec:<br/>  backoffLimit: 6</strong> # number of retries before throwing error<br/>  <strong class="lr hj">activeDeadlineSeconds: 10</strong> # time to allow job to run<br/>  <strong class="lr hj">template:<br/>    metadata:<br/>      labels:<br/>        app: kubernetes-series<br/>        tier: job<br/>    spec:<br/>      restartPolicy: OnFailure<br/>      containers:<br/>        - name: job<br/>          image: gcr.io/PROJECT_NAME/batchjob-container-job:latest</strong><br/>          # environment variables for the Pod<br/>          <strong class="lr hj">env:<br/>          - name: GCLOUD_PROJECT<br/>            value: PROJECT_NAME<br/>          - name: MESSAGE<br/>            value: I am a single run job<br/>          - name: FOREIGN_SERVICE<br/>            value: http://endpoints.default.svc.cluster.local/single<br/>          - name: NODE_ENV<br/>            value: production<br/>          ports:<br/>          - containerPort: 80</strong></span></pre><p id="b93c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准备好容器和Kubernetes集群后，您唯一需要做的事情就是用下面的脚本运行yaml文件。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="4888" class="lv ko hi lr b fi lw lx l ly lz">kubectl apply -f ../k8s/single-job.yaml</span></pre><p id="7ad7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见下一节运行脚本并查看输出。</p><h2 id="37b7" class="lv ko hi bd kp mj mk ml kt mm mn mo kx iq mp mq lb iu mr ms lf iy mt mu lj mv bi translated">一次性Kubernetes工作在行动</h2><p id="f4df" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">随着Kubernetes集群的运行，我们只需进入Google Cloud Shell并运行以下脚本来运行一次性批处理作业。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="6dcc" class="lv ko hi lr b fi lw lx l ly lz">$ cd <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/tree/master/batch-job/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/batch-job/scripts</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/scripts/run-single-job.sh" rel="noopener ugc nofollow" target="_blank">run_single_job.sh</a></span></pre><p id="186f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你按下回车键时，很多事情会立即发生。如果您运行到您的<code class="du ma mb mc lr b">Kubernetes Engine &gt; Workloads</code>视图，您将看到您的工作负载中新的<code class="du ma mb mc lr b">single-job</code> Pod和活动的<code class="du ma mb mc lr b">0/1</code>Pod。那是因为<code class="du ma mb mc lr b">single-job</code>在完成时运行并终止了分离舱。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mw"><img src="../Images/07ded650533cb65a7eb6048ba1a61b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpmEFyEmEAfhuEbGIMfuDg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><code class="du ma mb mc lr b">single-job</code> Pod完成</figcaption></figure><p id="cbbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您查看<code class="du ma mb mc lr b">single-job</code>事件的详细信息，您还可以看到在Pod创建后记录的<code class="du ma mb mc lr b">SuccessfulCreate</code>事件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mx"><img src="../Images/c5646321036e1a34cbabaffd34c54407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNK8XcfBUZPc8j656srD8A.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">单一作业Pod事件</figcaption></figure><p id="d34a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，要查看<code class="du ma mb mc lr b">single-job</code> Pod的结果，您可以返回到<code class="du ma mb mc lr b">http://[IP_Address]/data</code>并查看批处理作业的结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es my"><img src="../Images/f56dfd6a0f74c0598c2ea23cffa9de43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxT5dthfcONyF13vCGKskA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">单一作业批处理作业结果</figcaption></figure><p id="48e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇！这么多事情发生得太快了！对于一项简单的工作来说，这一切都很好。但是，如果您需要一次移动大量数据，该怎么办呢？运行一个作业可能还不够。在下一个示例中，我们将了解如何按顺序创建批处理作业。</p><h1 id="9644" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建连续的Kubernetes作业</h1><p id="d3f4" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">在这种情况下，您希望按顺序运行成批的作业，而不是有一个很长的作业。如果您担心作业可能会失败并需要重新启动，如果某个作业正在消耗大量内存/资源并需要限制，或者如果您只是不想让后台作业运行太长时间，这就特别好。</p><blockquote class="md me mf"><p id="6fc5" class="if ig ju ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">示例:假设您有100个资源要消耗和转换。您可能有一个作业需要一个小时才能运行，并且可能会失败，需要启动多次才能完全完成。或者您可以有10个批处理作业，一次运行10个资源。即使批处理作业失败，您最终也只是重新启动特定的10人组，而不是整个100人组。</p></blockquote><p id="5695" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在Kubernetes能够理解的yaml文件中看到这一点，请看下面的代码。除了增加了一个<code class="du ma mb mc lr b">.spec.completions</code>之外，yaml文件的大部分与单次运行批处理作业极其相似(下面以粗体显示)。<a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/k8s/sequential-jobs.yaml" rel="noopener ugc nofollow" target="_blank">这将设置批处理作业运行3次，一个接一个。</a></p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="7402" class="lv ko hi lr b fi lw lx l ly lz">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: sequential-job<br/>spec:<br/>  <strong class="lr hj">completions: 3 # number of times to run</strong><br/>  backoffLimit: 6 # number of retries before throwing error<br/>  activeDeadlineSeconds: 10 # time to allow job to run<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: kubernetes-series<br/>        tier: job<br/>    spec:<br/>      restartPolicy: OnFailure<br/>      containers:<br/>        - name: job<br/>          image: gcr.io/PROJECT_NAME/batchjob-container-job:latest<br/>          # environment variables for the Pod<br/>          env:<br/>          - name: GCLOUD_PROJECT<br/>            value: PROJECT_NAME<br/>          - name: MESSAGE<br/>            value: I am a sequential run job<br/>          - name: FOREIGN_SERVICE<br/>            value: http://endpoints.default.svc.cluster.local/sequential<br/>          - name: NODE_ENV<br/>            value: production<br/>          ports:<br/>          - containerPort: 80</span></pre><p id="7c7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变化超级小，超级有效。接下来让我们来看看它的实际应用。</p><h2 id="57f5" class="lv ko hi bd kp mj mk ml kt mm mn mo kx iq mp mq lb iu mr ms lf iy mt mu lj mv bi translated">连续Kubernetes工作在行动</h2><p id="1299" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">随着Kubernetes集群的运行，我们只需要进入Google Cloud Shell并运行以下脚本来运行一个连续的批处理作业。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="0e13" class="lv ko hi lr b fi lw lx l ly lz">$ cd <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/tree/master/batch-job/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/batch-job/scripts</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/scripts/run-sequential-job.sh" rel="noopener ugc nofollow" target="_blank">run-sequential-job.sh</a></span></pre><p id="f5da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你按下回车键时，很多事情会立即发生。如果您运行到您的<code class="du ma mb mc lr b">Kubernetes Engine &gt; Workloads</code>视图，您将看到您的工作负载中新的<code class="du ma mb mc lr b">sequential-job</code> Pod和活动的<code class="du ma mb mc lr b">0/3</code>Pod。那是因为<code class="du ma mb mc lr b">sequential-job</code>在完成时运行并终止了分离舱。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mz"><img src="../Images/2cae2e50f9efe3772f80e03a30dd259e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4u882hPLFe6ssq_01MWA_g.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">顺序作业完成</figcaption></figure><p id="207e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您查看<code class="du ma mb mc lr b">sequential-job</code>事件的详细信息，您还可以看到在Pod创建后记录的<code class="du ma mb mc lr b">SuccessfulCreate</code>事件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mx"><img src="../Images/8a8976dbff66748db672db6b853ce4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGEdZm0vSVyPZ1sTOc-0Cw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">顺序作业事件视图</figcaption></figure><p id="b06c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，要查看<code class="du ma mb mc lr b">sequential-job</code> Pod的结果，您可以返回到<code class="du ma mb mc lr b">http://[IP_Address]/data</code>并查看批处理作业的结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es na"><img src="../Images/388e4ef99517e994e54177220108f8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwO9j9wcJYq_eXr8yVSy2Q.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">顺序作业批处理作业结果添加到输出</figcaption></figure><p id="6e7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像<code class="du ma mb mc lr b">single-job</code>一样，<code class="du ma mb mc lr b">sequential-job</code>这么快就做了这么多！如果您需要将一个运行任务分解为多个任务，这是一个非常有效的解决方案。如果你想更进一步，会发生什么呢？如果您想分解作业并同时运行多个作业，该怎么办？是时候谈谈平行作业了。</p><h1 id="d56f" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建并行Kubernetes作业</h1><p id="b008" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">现在，您可以按顺序运行作业，将长时间运行的作业分解成小块。如果您想使用Google云和Kubernetes集群的能力，并行而不是顺序地运行这些作业——有效地将几个小时的处理变成在更多节点上几分钟的处理，该怎么办？并行作业会帮你做到这一点。</p><p id="15f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您已经将作业设置为<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-cron-jobs-455fdc32e81a#a86e">等幂运行</a>，那么这就不是问题。在您的<a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/k8s/parallel-jobs.yaml" rel="noopener ugc nofollow" target="_blank"> yaml文件</a>中添加一个新的行将赋予您这种能力。</p><blockquote class="md me mf"><p id="d7b6" class="if ig ju ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">如果你对这个术语感到困惑，请务必查看我的<a class="ae jd" rel="noopener" href="/google-cloud/kubernetes-cron-jobs-455fdc32e81a#a86e">幂等工作的快速解释</a>。</p></blockquote><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="a2b4" class="lv ko hi lr b fi lw lx l ly lz">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: parallel-job<br/>spec:<br/>  completions: 6 # number of times to run<br/>  <strong class="lr hj">parallelism: 2 # number of pods that can run in parallel</strong><br/>  backoffLimit: 6 # number of retries before throwing error<br/>  activeDeadlineSeconds: 10 # time to allow job to run<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: kubernetes-series<br/>        tier: job<br/>    spec:<br/>      restartPolicy: OnFailure<br/>      containers:<br/>        - name: job<br/>          image: gcr.io/PROJECT_NAME/batchjob-container-job:latest<br/>          # environment variables for the Pod<br/>          env:<br/>          - name: GCLOUD_PROJECT<br/>            value: PROJECT_NAME<br/>          - name: MESSAGE<br/>            value: I am a parallel run job<br/>          - name: FOREIGN_SERVICE<br/>            value: http://endpoints.default.svc.cluster.local/parallel<br/>          - name: NODE_ENV<br/>            value: production<br/>          ports:<br/>          - containerPort: 80</span></pre><p id="10f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在,<code class="du ma mb mc lr b">.spec.parallelism</code>行告诉Kubernetes可以同时运行这么多的pod。如果我将完成数设置为6，并行度设置为6，那么我的所有批处理作业将同时运行。在这个例子中，我希望每批运行3个Kubernetes Pods，所以我将并行度设置为2，将完成度设置为6。</p><h2 id="d7c9" class="lv ko hi bd kp mj mk ml kt mm mn mo kx iq mp mq lb iu mr ms lf iy mt mu lj mv bi translated">并行Kubernetes工作在行动</h2><p id="c301" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">随着您的Kubernetes集群的运行，我们只需要进入Google Cloud Shell并运行以下脚本来运行并行批处理作业。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="3849" class="lv ko hi lr b fi lw lx l ly lz">$ cd <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/tree/master/batch-job/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/batch-job/scripts</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/batch-job/scripts/run-sequential-job.sh" rel="noopener ugc nofollow" target="_blank">run-sequential-job.sh</a></span></pre><p id="19cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你按下回车键时，很多事情会立即发生。如果您运行到您的<code class="du ma mb mc lr b">Kubernetes Engine &gt; Workloads</code>视图，您将看到您的工作负载中新的<code class="du ma mb mc lr b">parallel-job</code> Pod和活动的<code class="du ma mb mc lr b">0/6</code>Pod。那是因为<code class="du ma mb mc lr b">parallel-job</code>在完成时运行并终止了分离舱。<em class="ju">注意:在截图中，我看到一个豆荚还在旋转。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nb"><img src="../Images/da52012fa822263dc6c18fe4330be303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uX81TWkSnY4HlFNK1Vm4Ew.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">并行作业单元正在旋转</figcaption></figure><p id="0cf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您查看<code class="du ma mb mc lr b">parallel-job</code>事件的详细信息，您还可以看到在Pod创建后记录的<code class="du ma mb mc lr b">SuccessfulCreate</code>事件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nc"><img src="../Images/7eb1f0c738510afddb6e13ee37139e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfWrvFsHUViUSsKoSMu_Hw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">并行作业事件视图</figcaption></figure><p id="f383" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，要查看<code class="du ma mb mc lr b">parallel-job</code> Pod的结果，您可以返回到<code class="du ma mb mc lr b">http://[IP_Address]/data</code>并查看批处理作业的结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nd"><img src="../Images/ed07b53a1749249c843b55e0cb80c280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4MbpfSdFXH8TLI95BzTgQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">并行作业批处理作业结果添加到输出</figcaption></figure><p id="3f66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘣！批处理作业，按顺序并行运行。加快您的处理速度，让您不再等待。它是如此简单，以至于你几乎会觉得你错过了什么。</p><h1 id="43e8" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="62a3" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">如果你做到了这一步，并且运行了所有的代码，你现在一定是最快乐的程序员了——我知道我是。运行批处理作业并让它们按照您想要的方式运行是多么容易。Kubernetes是job中的一股新鲜空气，它通常充满了令人畏缩的配置文件和脚本。</p><h1 id="491a" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">拆卸</h1><p id="3a77" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">在您离开之前，请确保清理您的项目，这样您就不会为您用来运行群集的虚拟机付费。返回到云Shell并运行teardown脚本来清理您的项目。这将删除您的集群和我们构建的容器。</p><pre class="jf jg jh ji fd lq lr ls lt aw lu bi"><span id="8f29" class="lv ko hi lr b fi lw lx l ly lz">$ cd <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/tree/master/daemon/scripts" rel="noopener ugc nofollow" target="_blank">~/kubernetes-series/daemon/scripts</a><br/>$ sh <a class="ae jd" href="https://github.com/jonbcampos/kubernetes-series/blob/master/daemon/scripts/teardown.sh" rel="noopener ugc nofollow" target="_blank">teardown.sh</a></span></pre></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><h1 id="be0a" class="kn ko hi bd kp kq nl ks kt ku nm kw kx ky nn la lb lc no le lf lg np li lj lk bi translated">本系列的其他文章</h1><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/@jonbcampos/kubernetes-run-a-pod-per-node-with-daemon-sets-f77ce3f36bf1"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:用守护进程集在每个节点上运行一个Pod</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">我最初给这篇文章起的标题只是“守护进程集”,并假设它足以抓住要点…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="nq l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-cron-jobs-455fdc32e81a"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">库伯内特:克朗·乔布斯</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">有时候你的工作不是事务性的。我们不再等待用户点击按钮让系统亮起来…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="nr l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-dns-proxy-with-services-d7d9e800c329"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:带服务的DNS代理</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">构建应用程序时，通常需要与外部服务进行交互来完成业务…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ns l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-routing-internal-services-through-fqdn-d98db92b79d3"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:通过FQDN路由内部服务</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">我记得当我第一次进入Kubernetes时。一切都是崭新的、闪亮的、有规模的。当我继续的时候…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="nt l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-liveness-checks-4e73c631661f"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:活性检查</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">最近，我整理了一篇关于Kubernetes就绪性调查以及它对您的集群有多重要的文章…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="nu l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a href="https://itnext.io/kubernetes-readiness-probe-83f8a06d33d3" rel="noopener  ugc nofollow" target="_blank"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:就绪探测</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">如果对这个特性有任何疑问，我写这篇文章是为了说明这不是一个…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">itnext.io</p></div></div><div class="kh l"><div class="nv l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-horizontal-pod-scaling-190e95c258f5"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:水平Pod缩放</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">通过Pod自动扩展，您的Kubernetes集群可以监控现有Pod的负载，并确定我们是否需要更多…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="nw l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-cluster-autoscaler-f1948a0f686d"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:集群自动缩放</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">自动缩放是Kubernetes的一个巨大的(并且已经上市的)特性。当你的网站/应用程序/应用程序接口/项目变得越来越大时，洪水…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="nx l kj kk kl kh km jo jy"/></div></div></a></div><div class="jv jw ez fb jx jy"><a rel="noopener follow" target="_blank" href="/google-cloud/kubernetes-day-one-30a80b5dcb29"><div class="jz ab dw"><div class="ka ab kb cl cj kc"><h2 class="bd hj fi z dy kd ea eb ke ed ef hh bi translated">Kubernetes:第一天</h2><div class="kf l"><h3 class="bd b fi z dy kd ea eb ke ed ef dx translated">这是Kubernetes帖子的必选步骤之一。如果你对Kubernetes感兴趣，你可能已经读过100本了…</h3></div><div class="kg l"><p class="bd b fp z dy kd ea eb ke ed ef dx translated">medium.com</p></div></div><div class="kh l"><div class="ki l kj kk kl kh km jo jy"/></div></div></a></div></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="3dd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jonathan Campos 是一个狂热的开发者，也是学习新事物的爱好者。我相信我们应该不断学习、成长和失败。我总是开发社区的支持者，并且总是愿意提供帮助。因此，如果你对这个故事有任何问题或意见，请在下面提出。在<a class="ae jd" href="https://www.linkedin.com/in/jonbcampos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae jd" href="https://twitter.com/jonbcampos" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，并提及这个故事。</p></div></div>    
</body>
</html>