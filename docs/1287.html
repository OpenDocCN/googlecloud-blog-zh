<html>
<head>
<title>Kubernetes 1.16 API deprecations and changed defaults</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 1.16 API弃用和更改默认值</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/kubernetes-1-16-api-deprecations-and-changed-defaults-e53ccc5c73d5?source=collection_archive---------1-----------------------#2020-02-13">https://medium.com/google-cloud/kubernetes-1-16-api-deprecations-and-changed-defaults-e53ccc5c73d5?source=collection_archive---------1-----------------------#2020-02-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5896" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；dr </strong> : Kubernetes 1.16正在<a class="ae jd" href="https://kubernetes.io/blog/2019/07/18/api-deprecations-in-1-16/" rel="noopener ugc nofollow" target="_blank">移除对一些仍在广泛使用的废弃API的支持</a>。解决方案理论上很简单:只需使用例如<em class="je">版本:apps/v1 </em>而不是<em class="je">版本:extensions/v1beta1 </em>。然而，有一个副作用:默认值可能会改变。</p><p id="bb64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubernetes做得很好的一点是处理API的不断变化和改进，同时避免破坏向后兼容性。其工作方式是，每个API都声明了一个特定的版本，如果您继续使用该版本，那么在升级Kubernetes时，API应该继续做与以前相同的事情。</p><p id="2827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当Kubernetes开发人员想要更改API中某些参数的默认值时，可以使用相同的向后兼容性概念。当API的新版本发布时，可以引入新的默认值。如果您使用旧版本的API，您将获得旧的默认值，如果您使用新版本，您将获得新的默认值。这是一个美丽的概念，但也可能让用户感到惊讶，当他们只是改变版本，如果他们的资源定义。</p><p id="77f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，一些API版本将被删除，您应该知道在使用这些API的新版本时会发生什么变化。</p><h1 id="1eef" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">1.16中删除了什么</h1><p id="3c41" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">Kubernetes正在移除对一些beta APIs的支持，这些API已经被GA APIs取代很久了(在Kubernetes 1.9中)。其中大部分是核心工作负载API的一部分，这些API通常用于定义Kubernetes中的应用程序。以下是摘自Kubernetes 1.16 的<a class="ae jd" href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.16.md#deprecations-and-removals" rel="noopener ugc nofollow" target="_blank">发行说明的核心工作负载API列表，这些API仅受版本<strong class="ih hj"> apps/v1 </strong>支持:</a></p><ul class=""><li id="8358" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated">达蒙塞特</li><li id="0baa" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">部署</li><li id="c9ac" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">状态集</li><li id="230b" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">复制集</li></ul><p id="35cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他被删除的API(作为参考，我们将在本文的其余部分重点关注上面的):</p><ul class=""><li id="c88b" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated">网络策略(扩展/v1beta1，改为使用networking.k8s.io/v1)</li><li id="1ffb" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">PodSecurityPolicy(扩展/v1beta1，请改用policy/v1beta1)</li></ul><h1 id="4e87" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">如何解决您的工作负载</h1><p id="e2e5" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">修复非常简单:只需更改您的资源定义以使用新的API版本。例如，如果你有:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f9dc" class="lf jg hi lb b fi lg lh l li lj">apiVersion: <strong class="lb hj">extensions/v1beta1</strong><br/>kind: Deployment<br/>metadata:<br/>  name: mydeployment</span></pre><p id="e03e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需更改第一行:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="241c" class="lf jg hi lb b fi lg lh l li lj">apiVersion: <strong class="lb hj">apps/v1</strong><br/>kind: Deployment<br/>metadata:<br/>  name: mydeployment</span></pre><p id="d263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这些吗？几乎…如上所述，您应该考虑到更改您的资源定义的API版本会对用于您没有定义的参数的默认值产生影响。下一节包含核心工作负载API中已更改的默认值列表。</p><h1 id="9fa9" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">更改默认值</h1><h2 id="1446" class="lf jg hi bd jh lk ll lm jl ln lo lp jp iq lq lr jt iu ls lt jx iy lu lv kb lw bi translated">达蒙塞特</h2><p id="3f1a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">DaemonSets用于部署需要出现在每个节点上的pod。这些默认值从<strong class="ih hj"> v1 </strong>开始改变:</p><ul class=""><li id="0a3e" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">spec . update strategy . type</strong></a>:on delete-&gt;RollingUpdate<br/>用“rolling update”，当DaemonSet定义改变时，会自动重新创建pod。与OnDelete相比，这是一个很大的变化，在on delete中，您必须手动删除pod才能推出新版本。</li></ul><h2 id="c970" class="lf jg hi bd jh lk ll lm jl ln lo lp jp iq lq lr jt iu ls lt jx iy lu lv kb lw bi translated">部署</h2><p id="2419" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">部署可能是定义工作负载最常用的方式。这些默认值从<strong class="ih hj">v1β2</strong>开始更改:</p><ul class=""><li id="3c25" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">spec . progressDeadlineSeconds</strong></a><strong class="ih hj">:</strong>2147483647→600<br/>progressDeadlineSeconds确定部署在被宣布为失败(例如由于准备就绪检查失败)之前将保持“进行中”的时间。</li><li id="5c5a" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">spec . revisionHistoryLimit</strong></a><strong class="ih hj">:</strong>2147483647→10<br/>revisionHistoryLimit限制在被部署控制器删除之前将保留的ReplicaSet对象的数量。</li><li id="ecc9" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">spec . strategy . rolling update . max surge</strong></a><strong class="ih hj">:</strong>1→25%<br/>max surge定义滚动更新可以创建的超过spec.replicas中指定的所需pod数量的最大pod数量</li><li id="025c" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">spec . strategy . rolling update . max unavailable</strong></a><strong class="ih hj">:</strong>1→25%<br/>仅当不可用(未就绪)pod的数量低于此数量时，滚动更新才会继续。如果是百分比，就是规格复制品的百分比</li></ul><h2 id="06a3" class="lf jg hi bd jh lk ll lm jl ln lo lp jp iq lq lr jt iu ls lt jx iy lu lv kb lw bi translated">复制集</h2><p id="9610" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">副本集很少被直接使用，通常被视为部署所拥有的子对象。extensions/v1beta1和apps/v1之间的副本集默认值没有改变。</p><h2 id="183c" class="lf jg hi bd jh lk ll lm jl ln lo lp jp iq lq lr jt iu ls lt jx iy lu lv kb lw bi translated">状态集</h2><p id="e4b5" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">StatefulSets类似于Deployment，但是更适合需要存储、可寻址实例、创建顺序控制等的有状态应用程序。与DaemonSet相同的参数从<strong class="ih hj"> v1beta2 </strong>开始改变:</p><ul class=""><li id="2945" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">spec . update strategy . type</strong></a>:on delete→RollingUpdate<br/>用“rolling update”，当StatefulSet定义改变时，会自动重新创建pod。与OnDelete相比，这是一个很大的变化，在on delete中，您必须手动删除pod才能推出新版本。</li></ul><h1 id="263c" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">删除默认选择器和选择器不变性</h1><p id="78f9" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">当转移到非beta核心工作负载API时，您可能会注意到其他一些东西。如果您有未定义pod选择器(<em class="je"> spec.selector </em>)的Deployments或StatefuSet，您现在将得到一个该字段丢失的错误。在beta APIs中，您可以省略<em class="je"> spec.selector </em>，它将从pod模板中的标签推断出来。</p><p id="176c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一件不再被允许的事情是改变现有资源中的选择器。<em class="je">规格选择器</em>字段现在被认为是不可变的。</p><p id="4b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在核心工作负载API <a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"> GA公告</a>中找到关于这些变化原因的更多详细信息。</p><h1 id="c156" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">关于您从kubectl get获得的版本的说明</h1><p id="c813" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">为了准备在Kubernetes 1.16中删除这些资源，您应该在升级之前更改资源定义中的版本。当您开始使用新版本(例如apps/v1)时，您可能会注意到一些奇怪的事情:该版本显然没有注册:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="aa4f" class="lf jg hi lb b fi lg lh l li lj">$ cat test-deployment.yaml<br/>apiVersion: <strong class="lb hj">apps/v1</strong><br/>kind: Deployment<br/>metadata:<br/>  name: test<br/>...</span><span id="2b85" class="lf jg hi lb b fi lx lh l li lj">$ kubectl apply -f test-deployment.yaml<br/>$ kubectl get deployment test -o yaml<br/>apiVersion: <strong class="lb hj">extensions/v1beta1<br/></strong>kind: Deployment</span></pre><p id="38eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发生什么事了？正如这里的<a class="ae jd" href="https://github.com/kubernetes/kubernetes/issues/58131#issuecomment-356823588" rel="noopener ugc nofollow" target="_blank">所解释的那样</a>，原因是“kubectl get deployment”在您想要使用哪个API版本进行部署的问题上不明确。可以使用不同版本的可用API来检索相同的资源，Kubernetes &lt; 1.16仍然为所有这些旧API版本的部署提供服务。为了向后兼容，当版本不明确时，使用API的最老版本。</p><p id="9085" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下语法检索特定的API版本:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="357b" class="lf jg hi lb b fi lg lh l li lj">$ kubectl get deployment.v1.apps test -o yaml<br/>apiVersion: apps/v1<br/>kind: Deployment</span></pre><p id="b0c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p><p id="a6a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">感谢Balazs Pinter和Janet Kuo帮助撰写本文。</em></p></div></div>    
</body>
</html>