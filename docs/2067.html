<html>
<head>
<title>Docker Swarm services in GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GCP的码头工人群体服务</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/docker-swarm-services-in-gcp-edcaa14913f8?source=collection_archive---------1-----------------------#2022-01-24">https://medium.com/google-cloud/docker-swarm-services-in-gcp-edcaa14913f8?source=collection_archive---------1-----------------------#2022-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/dba002658e009876d63355baab6adcb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*gDyetMfzObOMZTDiu9N8uA.png"/></div></figure><p id="d266" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这篇文章中，我描述了如何在GCP运行时公开Docker集群中的服务。我还分析了Docker Swarm和GKE在这方面的一些差异。</p><h1 id="7cda" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">背景</h1><p id="9ea8" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Docker Swarm是一个容器编排系统，用于管理部署在多个主机上的多个容器。很可能，这个定义让读者想起了非常流行的Kubernetes。Swarm和Kubernetes之间有一场战争，Swarm <a class="ae kn" href="https://www.mirantis.com/cloud-native-concepts/understanding-docker-swarm/what-is-docker-swarm/#section-3" rel="noopener ugc nofollow" target="_blank">声称使用起来更简单</a>而Kubernetes更强大，但我不会卷入这场战争。</p><p id="21c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如今Kubernetes或其任何风格(像<a class="ae kn" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> <em class="ko">谷歌Kubernetes引擎</em> </a> <em class="ko"> - </em> GKE -在GCP)似乎主导了云，但事实是Docker Swarm仍被许多公司使用。当将工作负载迁移到云时，并不是每个人都从他们选择的流程编排平台迁移。所以我认为了解如何在GCP运营Docker Swarm服务是很有用的。</p><p id="5087" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将主要关注网络部分。当我在Swarm中查看如何到达容器时，我意识到它的网络使用了一种不同于我更习惯的GKE的方法。GKE集群是GCP的一等公民，因此集装箱和服务整合得非常好。正如你将看到的，Docker Swarm需要做更多的工作。不要担心，我不会进入所有的细节，只需要最少的。</p><p id="ef49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是在继续之前，先说一下术语“<em class="ko">服务</em>”。一个<em class="ko"> Kubernetes服务</em>指的是抽象和公开一组pods容器的网络结构。例如，<em class="ko">负载平衡器</em>就是一种服务。这就是我通常所指的意思。相比之下，Docker Swarm <em class="ko">服务</em>是一个容器，它的所有配置都以运行它的副本数量来表示。我希望从上下文中可以清楚我指的是什么。</p><h1 id="250d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">遮掩</h1><p id="9190" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Docker有三种基本的网络类型:<strong class="io hj"> <em class="ko">桥</em> </strong>，<strong class="io hj"> <em class="ko">主机</em> </strong>和<em class="ko">无</em> 。我只描述第一个。基本上，<em class="ko">桥</em>网络是主机上的私有内部网络，容器通常在这里运行。如果容器需要从外部访问，其端口可以在Docker主机上<em class="ko">发布</em> ( <code class="du kp kq kr ks b">--publish</code>标志)。</p><p id="fbe6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">桥接网络是在Linux中实现的，带有一个虚拟桥接设备、<em class="ko"> docker0 </em>和一对用于容器的<em class="ko"> veth </em>(虚拟以太网)设备。一般来说，这类似于Kubernetes所做的，尽管实现可能有所不同。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/09338a07c1efeba4e2f62cd8f709e824.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*_Wc6EejCI_Kh1_gB_ONMzA.png"/></div></figure><p id="fbc4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种设置中，主机中的容器可以相互通信。然而，当您有一个由多个主机组成的集群时，跨主机的容器没有办法通信，这时您可能需要使用Docker Swarm。它使用<strong class="io hj"> <em class="ko">覆盖网络</em> </strong>实现跨工作节点的Docker服务(记住，Docker服务=容器)之间的通信。覆盖网络是建立在另一个网络之上的网络，它允许系统在没有直接连接时就像直接连接一样。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/eeef756f2f970fe7bfc61a42a7b2831a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtMdojsd7uEDde3gc77oiA.png"/></div></div></figure><p id="e313" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当你初始化swarm时，一个名为<em class="ko">入口</em>(以及其他组件)的覆盖网络就为你创建了。它跨越所有工作节点，允许容器之间的通信，如果您发布了它们，就可以从外部访问它们，还提供了内部负载平衡机制。这种负载平衡的工作方式是，可以在集群的任何节点上接收请求，并将其转发给在任何节点上运行的任何容器实例。</p><p id="6595" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个负载均衡部分听起来类似于Kubernetes的<a class="ae kn" href="https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> NodePort服务</em> </a>。作为Kubernetes的一部分，你可能希望它也适用于GKE。嗯，有一些差异，但肯定是这样，但是GKE有更好的方法来做负载平衡，特别是公开HTTP服务。这就是差异成为关键的地方。我将在这里强调与我们的目的更相关的两个问题。</p><p id="2813" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，正如我提到的，Swarm使用一个覆盖层，特别是一个VXLAN网络。这意味着由容器发送的以太网帧在被发送出Docker主机之前被封装在UDP包中。因此，在主机外部看不到容器IP，只能在内部覆盖网络中看到。相比之下，GKE可以使用<a class="ae kn" href="https://cloud.google.com/blog/products/networking/understanding-native-container-routing-with-alias-ips" rel="noopener ugc nofollow" target="_blank"> <em class="ko">别名IP</em></a><em class="ko"/>，这允许在运行容器的虚拟机上配置辅助IP，并以本机方式将流量路由到它们。这实现了更有效的负载平衡，其中外部负载平衡器可以不针对节点，而是针对提供服务的特定容器(pod)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ld"><img src="../Images/272ab1bbac4b8a318690bb7ef77ae376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81_qUS61Mk2o-36KZPUpUA.png"/></div></div></figure><p id="160d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上图显示了两个配置不同的GKE集群:</p><ul class=""><li id="88b9" class="le lf hi io b ip iq it iu ix lg jb lh jf li jj lj lk ll lm bi translated">在左侧，在典型的Kubernetes部署中，pod使用NodePort服务，因此负载平衡器将流量分配给节点，第二层负载平衡将流量转发给容器，该容器可能在同一节点中，也可能不在同一节点中。通常不会，这会增加延迟，尤其是因为节点可能位于不同的云区域。</li><li id="1d80" class="le lf hi io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated">在右侧，有一个使用别名IPs和<a class="ae kn" href="https://cloud.google.com/load-balancing/docs/negs" rel="noopener ugc nofollow" target="_blank"> <em class="ko">网络端点组</em> </a> <em class="ko">的GKE集群。</em>负载均衡器直接以pod端点而不是节点为目标，避免了多次跳跃。</li></ul><p id="ae1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第二个区别是，即使Docker Swarm想要使用路由网络模型而不是封装网络模型，IP到容器的分配也是随容器的部署而定，而不是随节点。别名IP和路由网络模型需要知道哪些IP子范围将被分配给节点。</p><p id="7981" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">简而言之，对于Docker Swarm，我们将需要使用与左边类似的设置，其中后端是节点。</p><h1 id="909a" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">实际案例</h1><p id="e3fc" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">让我们部署一个场景来付诸实践。这个场景将由一些运行在Docker群服务/容器上的HTTP服务组成。</p><h2 id="ff0a" class="ls jl hi bd jm lt lu lv jq lw lx ly ju ix lz ma jy jb mb mc kc jf md me kg mf bi translated">一大群</h2><p id="c35d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我将使用三个码头主机，一个经理和两个工人。你可以按照像<a class="ae kn" href="https://docs.docker.com/engine/install/debian/" rel="noopener ugc nofollow" target="_blank">这些</a>这样的安装说明在你的Linux机器上安装Docker，或者简单地输入:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="c8f7" class="ls jl hi ks b fi mk ml l mm mn">$ curl -fsSL https://get.docker.com -o get-docker.sh<br/>$ sudo sh get-docker.sh</span></pre><p id="3f0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在管理器主机上，初始化swarm:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="b0c0" class="ls jl hi ks b fi mk ml l mm mn">manager:~$ sudo docker swarm init<br/>...<br/>    docker swarm join --token &lt;xxxxx&gt; 10.132.0.2:2377<br/>...</span></pre><p id="8aa0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该命令的输出告诉您如何使用安全令牌并指向管理器的IP地址和用于集群管理的端口2377，向集群添加一个worker。将该行内容一字不差地粘贴到其他主机上，使其成为工作主机:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="d8ff" class="ls jl hi ks b fi mk ml l mm mn">worker1:~$ sudo docker swarm join --token &lt;xxxxx&gt; 10.132.0.2:2377</span><span id="49d1" class="ls jl hi ks b fi mo ml l mm mn">worker2:~$ sudo docker swarm join --token &lt;xxxxx&gt; 10.132.0.2:2377</span></pre><h2 id="46b9" class="ls jl hi bd jm lt lu lv jq lw lx ly ju ix lz ma jy jb mb mc kc jf md me kg mf bi translated">一些服务</h2><p id="1f0e" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我将在端口8080上部署一个简单web服务器应用程序的几个副本:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="1610" class="ls jl hi ks b fi mk ml l mm mn">manager:~$ sudo docker service create --name my-web --replicas 3 -p 8080:8080 gcr.io/google-samples/hello-app:1.0</span></pre><p id="7a6c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以在同一个网络中部署一个客户端虚拟机来测试对该web服务器的访问。我的节点具有从10.132.0.2到. 4的IP，因此这些节点现在都应该在端口8080上响应:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="db9a" class="ls jl hi ks b fi mk ml l mm mn">client:~$ watch -tn1 curl -s 10.132.0.3:8080</span></pre><p id="bbbc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您观察几秒钟，您会看到不同的容器在响应，您可以从主机名看出这一点:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="2b70" class="ls jl hi ks b fi mk ml l mm mn">Hello, world!<br/>Version: 1.0.0<br/>Hostname: 78f61208d8c3</span></pre><p id="cae4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我将部署另一个类似的web服务器，版本2。容器也将在端口8080上侦听，但是由于我们现在不能再映射到节点上的那个端口，所以我将使用8081:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="f8d9" class="ls jl hi ks b fi mk ml l mm mn">manager:~$ sudo docker service create --name my-web-v2 --replicas 3 -p 8081:8080 gcr.io/google-samples/hello-app:2.0</span><span id="2f4a" class="ls jl hi ks b fi mo ml l mm mn">client:~$ watch -tn1 curl -s 10.132.0.2:8081<br/>Hello, world!<br/>Version: 2.0.0<br/>Hostname: 1ba54c792d62</span></pre><p id="288d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们已经部署了几个容器，如果您查看入口覆盖网络的详细信息，您可以看到分配给它们的IP。遗憾的是，看起来你需要一个节点一个节点地进行，因为每个节点只会显示运行在其上的容器(或者至少我不知道更好的方法):</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="b5ec" class="ls jl hi ks b fi mk ml l mm mn">manager:~$ sudo docker network inspect ingress<br/>...<br/>  "Containers": {<br/>    "1ba54c...": {<br/>      "Name": "my-web-v2.3.ngz...",<br/>      "IPv4Address": "10.0.0.29/24",<br/>    },<br/>    "a8cbe5...": {<br/>      "Name": "my-web.3.5x2...",<br/>      "IPv4Address": "10.0.0.25/24",</span><span id="31c1" class="ls jl hi ks b fi mo ml l mm mn">worker1:~$ sudo docker network inspect ingress<br/>...<br/>      "IPv4Address": "10.0.0.27/24",<br/>      ...<br/>      "IPv4Address": "10.0.0.23/24",</span><span id="63a8" class="ls jl hi ks b fi mo ml l mm mn">worker2:~$ sudo docker network inspect ingress<br/>...<br/>      "IPv4Address": "10.0.0.28/24",<br/>      ...<br/>      "IPv4Address": "10.0.0.24/24",</span></pre><p id="029a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我提到的，Docker Swarm不会为节点中的容器预先分配IP子范围，因此IP分配不是连续的。</p><h2 id="1710" class="ls jl hi bd jm lt lu lv jq lw lx ly ju ix lz ma jy jb mb mc kc jf md me kg mf bi translated">一个统治他们所有人的要人</h2><p id="24d2" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">访问节点IPs不太方便，也不能在请求中指定服务发布在哪个端口上。让我们部署一个<a class="ae kn" href="https://cloud.google.com/load-balancing/docs/l7-internal" rel="noopener ugc nofollow" target="_blank"> <em class="ko">内部HTTP(S)负载平衡器</em> </a>来提供一个<em class="ko"> VIP:port </em>来访问服务。我将在这里画出架构，让读者自己去做。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/55fc5bda04e28a59e6df4a865b725647.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*DankULzzG28bF2BKYFhUpw.png"/></div></figure><p id="15f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将Docker虚拟机作为一个<a class="ae kn" href="https://cloud.google.com/compute/docs/instance-groups" rel="noopener ugc nofollow" target="_blank"> <em class="ko">非托管实例组</em> </a>的成员，并将这个组作为两个后端服务的后端。成员通过他们的虚拟机名称来识别，而不是通过IP，因此<em class="ko">在GCP部署集群不需要您跟踪您的工作IP！</em></p><p id="7a7d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实例组有两个<a class="ae kn" href="https://cloud.google.com/load-balancing/docs/backend-service#named_ports" rel="noopener ugc nofollow" target="_blank"> <em class="ko">命名端口</em> </a>、‘<em class="ko">web v1:8080’</em>和’<em class="ko">web v2:8081’</em>，LB的URL映射将请求路由到到后端服务的“<em class="ko">SVC 1 . example . com’</em>和“<em class="ko">SVC 2 . example . com’</em>。我们已经对用户隐藏了端口！</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mq"><img src="../Images/2af77d66ad0e0b1593223bfab0be5fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svlfqMHKLLWW0BwlAlxorA.png"/></div></div></figure><p id="66d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我配置了云DNS来将这些域指向LB VIP。我们可以从客户端虚拟机测试它的工作情况:</p><pre class="ku kv kw kx fd mg ks mh mi aw mj bi"><span id="4cee" class="ls jl hi ks b fi mk ml l mm mn">client:~$ watch -tn1 curl -s svc1.example.com<br/>Hello, world!<br/>Version: 1.0.0<br/>Hostname: a8cbe5510a9c<br/>...<br/>client:~$ watch -tn1 curl -s svc2.example.com<br/>Hello, world!<br/>Version: 2.0.0<br/>Hostname: 399d05d4d0ef</span></pre><p id="3a0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">万岁！</p><h1 id="f1e6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">最终注释</h1><p id="4969" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">有些事情我还没有提到，但我想提一下，哪怕只是简单地提一下:</p><ul class=""><li id="6cf8" class="le lf hi io b ip iq it iu ix lg jb lh jf li jj lj lk ll lm bi translated"><strong class="io hj">运行状况检查:</strong>运行状况检查机制在此部署上不是最佳的。由于涉及到双重负载平衡，健康检查探测器通常不会检查实例上服务的健康状况。我建议在每个节点上部署一个简单的守护进程来检查实例的健康状况。</li><li id="550f" class="le lf hi io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated"><strong class="io hj"> TCP/UDP服务:</strong>您可以使用同一个实例组作为多个后端服务的后端，包括TCP/UDP负载平衡器的后端。</li><li id="5134" class="le lf hi io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated"><strong class="io hj">添加新服务:</strong>如果在第一次部署后出现了一个新服务，您可以创建所有需要的部分，如果需要的话<em class="ko">更新实例组的命名端口</em>。请注意，更新将替换内容，因此您的命名端口列表应该包括现有的和新的端口。</li><li id="1f16" class="le lf hi io b ip ln it lo ix lp jb lq jf lr jj lj lk ll lm bi translated"><strong class="io hj">节点自动伸缩:</strong> Docker Swarm不支持开箱即用的自动伸缩。您可以利用<em class="ko">托管实例组</em>根据CPU利用率等参数自动创建新的工作节点，并在引导时使用<code class="du kp kq kr ks b">docker swarm join</code>将它们加入集群。在这种情况下，您应该更加关注健康检查主题，因为被认为不健康的实例将被重新创建。</li></ul><h1 id="84a5" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="617b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在GCP运行Docker Swarm带来了一些非常好的优势。它不像运行GKE那样流畅，但也没有那么复杂，这是一个快速将docker工作负载转移到云的机会。当然，我建议你看一看GKE，看看它是否更适合你的用例；)</p></div></div>    
</body>
</html>