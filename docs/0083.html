<html>
<head>
<title>Android Push Notifications — GCM and RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android推送通知— GCM和RxJava</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/android-push-notifications-gcm-and-rxjava-bc3356e91ea5?source=collection_archive---------0-----------------------#2016-04-04">https://medium.com/google-cloud/android-push-notifications-gcm-and-rxjava-bc3356e91ea5?source=collection_archive---------0-----------------------#2016-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="15a8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">介绍</h2></div><p id="7c15" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GCM似乎是利用RxJava的一个很好的例子。遵循将GCM与Android集成的文档，创建了一个<a class="ae jt" href="http://developer.android.com/training/run-background-service/create-service.html" rel="noopener ugc nofollow" target="_blank"> <em class="ju"> IntentService </em> </a>，它处理获取GCM令牌并将其发送到第三方服务器的过程，以便发送推送通知。</p><p id="42d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些步骤中的每一个都需要最后一个步骤，以便完全完成注册过程，从而为推送通知完全注册用户。这个过程可以被认为是一个功能流，因此非常适合RxJava。在失败的情况下，如重试，使用RxJava的<a class="ae jt" href="https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators" rel="noopener ugc nofollow" target="_blank">错误处理操作符</a>操作符会有很大的好处。</p><p id="3f93" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文的其余部分将假设您对Android的GCM有所了解，已经阅读了文档，并且已经了解RxJava的基础知识。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="9e92" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">入门指南</h2><p id="7ade" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">您应该已经从Google获得了API密钥和发送者ID。如果您还没有这样做，那么在继续下一步之前先这样做。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h2 id="3d56" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">创建IntentService</h2><p id="eede" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">首先；创建GCM注册IntentService类，并在清单中注册它。奇怪的是，我把我的称为GcmRegistrationIntentService。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5923" class="kc kd hi lh b fi ll lm l ln lo">&lt;service<br/>    android:name=".GcmRegistrationIntentService"<br/>    android:enabled="true" /&gt;</span></pre><p id="b432" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请确保您覆盖了onHandleIntent 上的<em class="ju">，因为这是我们将设置所需资源并通过RxJava启动注册流程的地方。</em></p><p id="c1f8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我有一个<em class="ju">PushNotificationManager</em>类来包装我存储在<em class="ju"> SharedPreferences </em>中的状态，并在应用程序收到它时保存GCM令牌。</p><p id="7fbf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我有一个<em class="ju"> GcmRequestManager </em>类。这个类的目的是协调与我发送GCM令牌的API的网络通信。这个用的是<em class="ju">改型2 (Beta) </em>，已经集成了RxJava，可以返回<em class="ju">可观测量</em>。我不打算详细说明这是如何工作的，但是我要说我返回了一个<em class="ju">可观察值</em>，任何抛出的<em class="ju">异常</em>都将以与其他示例相同的方式处理。</p><p id="b0c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我引用了与GCM相关的类<em class="ju"> InstanceID </em>。这个类只是这个过程的一个需求，因为它是从Google获取GCM令牌的过程的抽象。</p><h2 id="a03a" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">从GCM方法创建可观测量</h2><p id="18ab" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">GCM提供的类不使用RxJava，因此我们需要以这样一种方式包装它们，当它们的任务完成时，它们将发出一个项目。</p><figure class="lc ld le lf fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="c540" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码检索GCM令牌。下面您可以看到将它包装在Observable.defer()中如何让我们创建一个Observable，在方法完成时发出一个字符串(令牌)。</p><figure class="lc ld le lf fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="24e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法<em class="ju"> getToken() </em>可以导致<em class="ju"> IOException </em>。因此，我们可以在异常发生时捕捉它，然后发出一个内部有错误的<em class="ju">可观察信号</em>。RxJava的一个好处是，我们可以处理下一步将要设置的<em class="ju">订户</em>的<em class="ju"> onError() </em>中的所有异常。</p><p id="90e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，当订阅<em class="ju">主题</em>时，我们可以遵循类似的过程。</p><figure class="lc ld le lf fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="6f3f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成为</p><figure class="lc ld le lf fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><blockquote class="ls lt lu"><p id="af8f" class="ix iy ju iz b ja jb ij jc jd je im jf lv jh ji jj lw jl jm jn lx jp jq jr js hb bi translated">但它为什么会发出空洞的可观测信号呢？</p></blockquote><p id="3ff9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将是该过程的最后一步，我们不会在<em class="ju"> OnNext() </em>中做任何事情，但是当调用<em class="ju"> onComplete() </em>时，我们将认为该过程成功完成。如果出现任何错误，那么将调用<em class="ju"> onError() </em>。</p><h2 id="8f70" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">创建订户</h2><p id="0167" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们需要创建一个<em class="ju">订阅者</em>来订阅<em class="ju"> getToken()。当getToken() </em>完成时，它将调用<em class="ju">sendregradationtoserver()</em>，后者将通过使用<em class="ju"> FlatMap() </em>操作符<em class="ju">调用<em class="ju"> registerTopics() </em>。</em></p><figure class="lc ld le lf fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="9fa0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，你可能想要做不同的事情，这取决于最终的目标，但是在这个设置中，如果<strong class="iz hj">任何</strong>异常被抛出，那么整个过程必须再次完成。</p><p id="9b42" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用额外的标志来表示流程的哪一部分已经完成，并从那里继续，这只是进一步简化的一种方式。</p><h2 id="77ff" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">将所有这些放在一起…</h2><p id="f715" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">最后一步是从<em class="ju"> getToken() </em>开始将我们的可观察对象链接在一起，这是在<em class="ju"> onHandleIntent()中调用的。</em></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2931" class="kc kd hi lh b fi ll lm l ln lo">getToken().observeOn(Schedulers.<em class="ju">io</em>())<br/>                .flatMap(this::sendRegistrationToServer)<br/>                .subscribe(new GcmRegistrationSubscriber());</span></pre><p id="0946" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码将调用<em class="ju">sendrestrationtoserver()</em>，将收到的令牌传递给该方法。注意到</p><blockquote class="ls lt lu"><p id="3190" class="ix iy ju iz b ja jb ij jc jd je im jf lv jh ji jj lw jl jm jn lx jp jq jr js hb bi translated"><em class="hi">this::sendgregistrationtoserver</em></p></blockquote><p id="698f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">等同于</p><blockquote class="ls lt lu"><p id="9de2" class="ix iy ju iz b ja jb ij jc jd je im jf lv jh ji jj lw jl jm jn lx jp jq jr js hb bi translated"><em class="hi"> () - &gt;发送注册到服务器(令牌)</em>)</p></blockquote><p id="7c68" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它将通过<em class="ju"> Schedulers.io() </em>使用一个新线程来完成工作，因为我们不希望在主线程上运行这么长时间。</p><p id="942f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了将<em class="ju">sendregradationtoserver()</em>链接到<em class="ju"> registerTopics() </em>上，flatMap()操作符用于最后一次调用<em class="ju"> registerTopics() </em>方法。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7318" class="kc kd hi lh b fi ll lm l ln lo">private Observable&lt;Object&gt; sendRegistrationToServer(String token) {<br/><br/>    pushNotificationManager.setGcmPushToken(token);<br/>    return GcmRequestManager.<em class="ju">getInstance</em>(getApplicationContext())<br/>            .register()<br/>            .flatMap(this::registerTopics);<br/>}</span></pre><h2 id="6db6" class="kc kd hi bd ke kf kg kh ki kj kk kl km jg kn ko kp jk kq kr ks jo kt ku kv kw bi translated">最终代码</h2><figure class="lc ld le lf fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>