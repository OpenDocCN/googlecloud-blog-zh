<html>
<head>
<title>Google Kubernetes Engine read-only volumes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌Kubernetes引擎只读卷</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/how-to-configure-read-only-volumes-in-google-kubernetes-engine-gke-clusters-9c32c1c6b238?source=collection_archive---------0-----------------------#2021-06-23">https://medium.com/google-cloud/how-to-configure-read-only-volumes-in-google-kubernetes-engine-gke-clusters-9c32c1c6b238?source=collection_archive---------0-----------------------#2021-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7b70" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">至少可以说，在Kubernetes中将外部卷附加到容器上不是一个简单的过程。当处理运行在多个Kubernetes worker节点上的多个容器时，这变得更加复杂，这是一个非常常见的用例。这篇文章的目标是试图理解这一切。</h2></div><p id="2688" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">TL；博士</strong>:见最后的流程图。</p><p id="d6b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章和下面的Google官方文档一起使用，这些文档是关于如何使用来自多个阅读器的持久磁盘的，最近已经被修改了。</p><div class="jt ju ez fb jv jw"><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/readonlymany-disks" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">对多个读取器使用永久磁盘</h2><div class="kd l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">cloud.google.com</p></div></div><div class="ke l"><div class="kf l kg kh ki ke kj kk jw"/></div></div></a></div><p id="fe58" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Kubernetes中，无论外部卷的访问模式是读写还是只读，都有两个步骤可以使外部卷对容器可用。</p><ol class=""><li id="238b" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js kq kr ks kt bi translated">该卷被装入一个或多个Kubernetes工作节点</li><li id="60a6" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js kq kr ks kt bi translated">这个卷被装入一个或多个运行在这些Kubernetes worker节点上的容器中</li></ol><p id="adcf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Google Kubernetes引擎(GKE)集群中，GCP持久磁盘支持外部卷。</p><p id="7a16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在被Kubernetes中的容器使用之前，必须创建一个支持只读卷的持久性磁盘并填充数据。</p><h1 id="ec5d" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated"><strong class="ak">如何创建GCP持久盘？</strong></h1><p id="c947" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">从现在开始，我们将把GCP持久磁盘简称为磁盘。</p><p id="c278" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，有3种主要的方法来创建磁盘。</p><p id="0bbd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> #1无Kubernetes </strong></p><p id="2d8e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您希望完全控制磁盘创建并将数据从GKE集群外部写入磁盘时，可以使用这种方法，它也不需要太多Kubernetes知识。</p><p id="6ea1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应该手动创建一个新的持久磁盘，并将其连接到Google Cloud Engine虚拟机(VM)。</p><p id="9b30" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据磁盘(也称为不可引导磁盘)是除可引导操作系统磁盘(默认情况下存在于每个虚拟机和其他潜在数据磁盘上)之外的磁盘。</p><p id="e37e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在创建虚拟机时执行此操作，或者将新磁盘连接到现有虚拟机。</p><ul class=""><li id="7a9b" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated"><strong class="iz hj"> GUI </strong></li></ul><p id="c374" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lx" href="https://cloud.google.com/compute/docs/instances/create-start-instance#create_a_vm_instance_with_additional_non-boot_disks" rel="noopener ugc nofollow" target="_blank">使用数据磁盘创建新的虚拟机</a></p><p id="1a50" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运筹学</p><p id="6e3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lx" href="https://cloud.google.com/compute/docs/disks/add-persistent-disk" rel="noopener ugc nofollow" target="_blank">创建磁盘并将其连接到现有虚拟机</a></p><ul class=""><li id="63aa" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated"><strong class="iz hj">谷歌云SDK (gcloud CLI) </strong></li></ul><p id="de0e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lx" href="https://cloud.google.com/compute/docs/instances/create-start-instance#create_a_vm_instance_with_additional_non-boot_disks" rel="noopener ugc nofollow" target="_blank">使用数据磁盘创建新的虚拟机</a></p><p id="8d89" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运筹学</p><p id="e5e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建磁盘并将其连接到现有虚拟机(2步)</p><ol class=""><li id="2dfb" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js kq kr ks kt bi translated"><a class="ae lx" href="https://cloud.google.com/sdk/gcloud/reference/compute/disks/create" rel="noopener ugc nofollow" target="_blank">创建磁盘</a></li><li id="548c" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js kq kr ks kt bi translated"><a class="ae lx" href="https://cloud.google.com/sdk/gcloud/reference/compute/instances/attach-disk?hl=fr" rel="noopener ugc nofollow" target="_blank">将磁盘连接到现有虚拟机</a></li></ol><p id="0860" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦您将应用程序所需的所有文件复制到磁盘中，您需要<a class="ae lx" href="https://cloud.google.com/sdk/gcloud/reference/compute/instances/detach-disk" rel="noopener ugc nofollow" target="_blank">将其</a>从虚拟机(gcloud CLI)中分离出来。</p><p id="8361" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> #2与库伯内特</strong></p><p id="e429" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数人都使用这种方法，因为它的优点是不需要Kubernetes之外的额外权限，但对于不熟悉存储类和回收策略Kubernetes概念的人来说，这是不必要的。</p><p id="38c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过这种方法，您可以让Kubernetes使用PersistentVolumeClaim和StorageClass对象动态地为您创建磁盘，并将其装入容器。</p><div class="jt ju ez fb jv jw"><a href="https://cloud.google.com/kubernetes-engine/docs/concepts/persistent-volumes" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">持久卷和动态预配置</h2><div class="ly l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">该页面概述了Kubernetes中的持久卷和声明，以及它们在Google Kubernetes中的使用…</h3></div><div class="kd l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">cloud.google.com</p></div></div><div class="ke l"><div class="lz l kg kh ki ke kj kk jw"/></div></div></a></div><p id="c937" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将应用程序所需的所有文件复制到磁盘后，删除引用磁盘卷的Pod，等待它终止，然后等待磁盘自动从节点分离。</p><p id="1d0a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> #3混动</strong></p><p id="93dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法是#1和#2的混合，像#1一样创建磁盘，但像#2一样将数据填充到磁盘中。</p><p id="fd54" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">手动创建一个没有Kubernetes的磁盘，并通过Kubernetes以读写模式将其装入容器。</p><div class="jt ju ez fb jv jw"><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/preexisting-pd#create_pv_pvc" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">将预先存在的持久性磁盘用作持久性卷</h2><div class="ly l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">本页解释了如何使用填充了数据的现有持久性磁盘创建持久性卷，以及如何使用…</h3></div><div class="kd l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">cloud.google.com</p></div></div><div class="ke l"><div class="ma l kg kh ki ke kj kk jw"/></div></div></a></div><p id="6d78" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将应用程序所需的所有文件复制到磁盘后，删除引用磁盘卷的Pod，等待它终止，然后等待磁盘自动从节点分离。</p><h1 id="21af" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated"><strong class="ak">如何在Kubernetes中从多个阅读器中将一个卷设为只读？</strong></h1><p id="cfc9" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">JsonPath表达式用于指示子字段，对于眼睛来说，这可能不是更舒适的阅读格式，但是它有避免混淆的优点。</p><p id="98ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> Pod </strong></p><p id="6aa7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">pod . spec . volumes . persistentvolumeclaim . readonly</strong></p><ul class=""><li id="870e" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated">默认为false的布尔值，将被设置为true</li><li id="661f" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">在pod的所有容器的所有挂载点上强制只读</li></ul><p id="d817" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">pod . spec . containers . volume mounts . readonly</strong></p><ul class=""><li id="7005" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated">默认为false的布尔值，为清楚起见，建议在查看Pod定义时将其设置为true，即使它是由Pod . spec . volumes . persistentvolumeclaim . readonly强制执行的</li><li id="72dc" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">每个容器的每个挂载点只读设置(比上面的子字段更细粒度)</li></ul><p id="184c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">部署比pod更容易使用，因此要知道等效的部署子字段分别是Deployment . spec . template . spec . volumes . persistentvolumeclaim . readonly和Deployment . spec . template . spec . containers . volume mounts . readonly。</p><p id="3831" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">持续卷</strong></p><p id="9ebd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下配置适用于树内和CSI存储驱动程序。</p><p id="d60e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">persistent volume . spec . access modes</strong></p><ul class=""><li id="1667" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated">[]字符串，必须将子字段设置为ReadOnlyMany</li><li id="48ac" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">选项有ReadOnlyMany、ReadWriteOne或ReadWriteMany，截至本文撰写之时，尚不支持这些选项</li><li id="7e5c" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">建议不要设置一个以上的访问模式，即使您可以这样做，否则如果访问模式不兼容，在创建容器时会出现错误</li><li id="99c5" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">访问模式不会触发Kubernetes上的任何操作，它们被用作控制检查，例如防止Kubernetes将一个“标记”为ReadWriteOnce的PersistentDisk挂载到多个worker节点中</li></ul><p id="27f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅适用于CSI驾驶员:</p><p id="cb8c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">persistent volume . spec . CSI . readonly</strong></p><ul class=""><li id="2659" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated">默认为false的布尔值，将被设置为true</li></ul><p id="2525" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">持续量声明</strong></p><p id="67c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">persistentvolumeclaim . spec . access modes</strong></p><ul class=""><li id="2c83" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated">与上述persistent volume . spec . accessModes的配置相同+将access modes设置为等于PersistentVolume accessModes(或至少一个子网以获得创建边界</li></ul><h1 id="88cb" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated"><strong class="ak">描述Kubernetes如何将GCP持久性磁盘装入容器的流程图</strong></h1><p id="7205" class="pw-post-body-paragraph ix iy hi iz b ja lr ij jc jd ls im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">流程图左侧的绿色路径是使卷成为只读卷的步骤(ROX)。</p><p id="5c97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">右手边的绿色路径，是读写一次(RWO)的步骤。</p><p id="b6f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不支持或不建议使用橙色路径。</p><p id="b9fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在所有情况下，这对Kubernetes都没有意义，因为它向它提供了相互矛盾的信息。</p><p id="71c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为清晰起见，以下流程图中使用了缩写:</p><ul class=""><li id="5655" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lw kr ks kt bi translated">PD =&gt; GCP持久磁盘</li><li id="bdf3" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">PV =&gt; Kubernetes持久卷定义</li><li id="e5c4" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">ROX = &gt; readonly many(PV access modes值)</li><li id="d427" class="kl km hi iz b ja ku jd kv jg kw jk kx jo ky js lw kr ks kt bi translated">RWO = &gt;读写一次(PV访问模式值)</li></ul><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mb"><img src="../Images/38894910de4325bf41d9b78f41ba8c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cYBuXbjRdZ0FUYAY"/></div></div></figure><p id="bf87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">推特@ouissamebekada</p></div></div>    
</body>
</html>