<html>
<head>
<title>A Journey into BigQuery Fuzzy Matching — 2 of [1, ∞) — More Soundex and Levenshtein Distance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery模糊匹配之旅-[ 1，∞)之二-更多Soundex和Levenshtein距离</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/a-journey-into-bigquery-fuzzy-matching-2-of-1-more-soundex-and-levenshtein-distance-e64b25ea4ec7?source=collection_archive---------0-----------------------#2019-08-13">https://medium.com/google-cloud/a-journey-into-bigquery-fuzzy-matching-2-of-1-more-soundex-and-levenshtein-distance-e64b25ea4ec7?source=collection_archive---------0-----------------------#2019-08-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="acd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在关于这个主题的第一篇帖子中，我们讨论了如何构建一系列<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions" rel="noopener ugc nofollow" target="_blank">用户定义函数</a> (UDF)来实现<a class="ae jd" href="https://en.wikipedia.org/wiki/Soundex" rel="noopener ugc nofollow" target="_blank"> Soundex算法</a>。概括地说，这里的想法是构建一个工具箱，可用于解决模糊匹配和主数据管理方面的挑战。现在Soundex是我们拥有的第一个！</p><p id="b5e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自从我写了那篇文章后，我就被一封邮件淹没了，询问它的性能方面。Soundex的一个好处是它相当快。当您添加BigQuery的大规模并行处理能力时，您最终会发现Soundex并不是很重。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="132f" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">必须听起来更快</h1><p id="ceeb" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">以前，我们使用一些名字对算法本身进行抽查。让我们在名单上再加几个名字，看看会发生什么。我们去取一些数据！</p><p id="0e6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搜索一些姓名数据将我带到了美国人口普查局的家谱数据网站。根据最近两次人口普查(2010年和2000年)汇编了一份经常出现的姓氏清单。1990年的人口普查给了我们男性和女性的名字和姓氏。我将所有公开发布的数据放入一个BigQuery表中。总之，我们能够收集近400，000个姓氏来运行我们的查询。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/d49da0f16535e9637db22220c5cbef0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*otD5fa79Vm0q5tIl5xiBbA.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">按年份和姓名类型分列的姓名细目。</figcaption></figure><p id="0ffa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这些中的一些将被重复，所以模糊匹配算法本身的真实世界适用性有点有限。但在这里，我们试图看看它有多快。40万比20万多一点。戴上我的内部数据集成/数据质量软件帽一秒钟，我通常认为这可能需要一个小时？几十分钟？不过，这是个大问题，所以肯定至少要几分钟吧？</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es la"><img src="../Images/c1e1c3391ac6b5618f560e3cc0a57bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*lYD3W86LmQS4ETcUSwTYpg.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">比“几分钟”快一点。</figcaption></figure><p id="3ea5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当处理近50万个名字时，5秒钟是相当快的。将这个数字增加一倍，达到100万个名字，似乎对总的处理时间没有太大的影响。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lb"><img src="../Images/3b6f5ad49c59168a83c9ceb8d94b921c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*gzcg9PuvTN-bDh--lfjEYg.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">数据加倍并不一定意味着处理时间加倍。</figcaption></figure><p id="54ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的要点是，将已经相当大的名字列表的大小加倍所导致的处理时间增加是微不足道的，这可能只是由于计算预热而不是所处理数据的增加。利用数据库能力来执行这样的操作的想法并不新鲜，但是能够在没有基础设施和工具的情况下如此快速地获得这些结果是非常棒的，如果我自己这么说的话。</p><p id="7fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果您想自己运行这些，我已经将合并到单个表中的人口普查数据作为<a class="ae jd" href="https://storage.cloud.google.com/happy-little-buckets-external/medium-posts/census_name_data/census_names.csv" rel="noopener ugc nofollow" target="_blank"> CSV导出</a>提供。</p><p id="17c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经有了一些基本的语音分类，接下来呢？我们应该很好，对吗？不完全是。让我们来讨论为我们的工具箱构建另一个工具。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="ce0a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">介绍弗拉基米尔·莱文斯坦</h1><p id="2ecf" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Vladimir_Levenshtein" rel="noopener ugc nofollow" target="_blank"> Vladimir Levenshtein </a>是一位俄罗斯科学家，他专攻信息理论。这是一种叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/Edit_distance" rel="noopener ugc nofollow" target="_blank">编辑距离</a>的距离度量形式，它在较高层次上是关于比较将一个字符串变成另一个字符串所需的变化数量。Levenshtein距离产生于1965年，用来衡量一个字符串与另一个字符串之间有多少插入、替换和删除。这里有几个这样的例子:</p><ul class=""><li id="3312" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated">“威士忌”——威士忌:Levenshtein距离，1。增加了一个e。</li><li id="4077" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated">“drin js”——饮料:Levenshtein距离:1。“k”被替换为“j”。</li><li id="6e07" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated"><a class="ae jd" href="https://www.imdb.com/title/tt0583600/characters/nm0000098" rel="noopener ugc nofollow" target="_blank">《钱德勒·宾》——《钱德勒·邦小姐》</a>:莱文斯坦距离，8。加“小姐”(5)，加“安”(2)，用“我”代替“o”(1)。</li></ul><p id="ca7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，这是对插入、替换和删除赋予同等权重的基本算法。对于不同的操作有不同的权重，这取决于您的使用情况(例如，在OCR使用情况下，您可能希望对“l”/“1”和“O”/“0”替换赋予较低的权重)。如果你对算法是如何工作的很好奇，有一篇极好的<a class="ae jd" rel="noopener" href="/@ethannam/understanding-the-levenshtein-distance-equation-for-beginners-c4285a5604f0">中篇文章会带你通过矩阵运算得到正确的距离</a>。绝对值得一读！当通过算法运行两个字符串时，计算的输出是一个数字，它给出了编辑的净次数。</p><p id="004d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们如何让它工作呢？另一个<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions" rel="noopener ugc nofollow" target="_blank"> UDF </a>！在Soundex函数中，我们能够将一系列SQL语句串在一起，但是现在我们正在寻找循环，所以我们将不得不使用一些JavaScript。如果你不喜欢阅读之前链接的详尽解释，匹兹堡<a class="ae jd" href="https://people.cs.pitt.edu/~kirk/cs1501/Pruhs/Spring2006/assignments/editdistance/Levenshtein%20Distance.htm" rel="noopener ugc nofollow" target="_blank">大学的人们将其归结为以下步骤</a>:</p><blockquote class="lq lr ls"><p id="d15f" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">1 —将<em class="hi"> n </em>设置为<em class="hi"> s </em>的长度。将<em class="hi"> m设定为</em> t <em class="hi">的长度。</em></p><p id="dc02" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">如果<em class="hi"> n = 0 </em>，返回<em class="hi"> m </em>并退出。<br/>如果<em class="hi"> m = 0 </em>，返回<em class="hi"> n </em>并退出。<br/>构造一个包含<em class="hi"> 0的矩阵..m </em>行和<em class="hi"> 0行..n </em>列。</p><p id="515e" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">2 —将第一行初始化为<em class="hi"> 0..n </em>。将第一列初始化为0..m 。</p><p id="3e12" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">3 —检查<em class="hi"> s </em>的各个字符(从<em class="hi"> i </em>到<em class="hi"> 1到n </em>)。</p><p id="01e9" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">4 —检查<em class="hi"> t </em> ( <em class="hi"> j </em>从<em class="hi"> 1到m </em>)的每个字符。</p><p id="cfd8" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">5 —如果<em class="hi"> s[i] </em>等于<em class="hi"> t[j] </em>，则成本为0。如果<em class="hi"> s[i] </em>不等于<em class="hi"> t[j] </em>，则成本为1。</p><p id="16f1" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">6-将矩阵的单元<em class="hi"> d[i，j] </em>设置为等于以下最小值:</p><p id="23d4" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">a.正上方的单元格加1: <em class="hi"> d[i-1，j] + 1 </em>。<br/> b .紧邻左侧的单元格加1: <em class="hi"> d[i，j-1] + 1 </em>。<br/> c .左上角的单元格加上代价:<em class="hi"> d[i-1，j-1] +代价</em>。</p><p id="6649" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">7-迭代步骤(3，4，5，6)完成后，在单元格<em class="hi"> d[n，m] </em>中找到距离。</p></blockquote><p id="f528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解释算法如何工作的前一个链接也有一步一步的矩阵图来显示它如何遍历数据，并且<a class="ae jd" href="https://gist.github.com/andrei-m/982927" rel="noopener ugc nofollow" target="_blank">也有在线代码用JavaScript </a>实现了该算法。因为它是在麻省理工学院OSI许可下发布的，所以让我们把它放到一个大查询UDF中！</p><pre class="kp kq kr ks fd lx ly lz ma aw mb bi"><span id="91e6" class="mc jm hi ly b fi md me l mf mg">CREATE OR REPLACE FUNCTION<br/>  dq.dq_fm_LevenshteinDistance(in_a string,<br/>    in_b string)<br/>  RETURNS INT64<br/>  LANGUAGE js AS <br/>"""/*<br/> * Data Quality Function - Fuzzy Matching<br/> * dq_fm_LevenshteinDistance<br/> * Based off of <a class="ae jd" href="https://gist.github.com/andrei-m/982927" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/andrei-m/982927</a><br/> * input: Two strings to compare the edit distance of.<br/> * returns: Integer of the edit distance.<br/> */<br/>var a = in_a.toLowerCase();<br/>var b = in_b.toLowerCase();<br/>  <br/>if(a.length == 0) return b.length; <br/>if(b.length == 0) return a.length;<br/>var matrix = [];</span><span id="2371" class="mc jm hi ly b fi mh me l mf mg">// increment along the first column of each row<br/>var i;<br/>for(i = 0; i &lt;= b.length; i++){<br/>  matrix[i] = [i];<br/>}</span><span id="77be" class="mc jm hi ly b fi mh me l mf mg">// increment each column in the first row<br/>var j;<br/>for(j = 0; j &lt;= a.length; j++){<br/>  matrix[0][j] = j;<br/>}</span><span id="4122" class="mc jm hi ly b fi mh me l mf mg">// Fill in the rest of the matrix<br/>for(i = 1; i &lt;= b.length; i++){<br/>  for(j = 1; j &lt;= a.length; j++){<br/>    if(b.charAt(i-1) == a.charAt(j-1)){<br/>      matrix[i][j] = matrix[i-1][j-1];<br/>    } else {<br/>      matrix[i][j] = <br/>        Math.min(matrix[i-1][j-1] + 1, // substitution<br/>        Math.min(matrix[i][j-1] + 1, // insertion<br/>        matrix[i-1][j] + 1)); // deletion<br/>    }<br/>  }<br/>}</span><span id="e9fc" class="mc jm hi ly b fi mh me l mf mg">return matrix[b.length][a.length];<br/>"""</span></pre><p id="2a57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试一试吧！</p><pre class="kp kq kr ks fd lx ly lz ma aw mb bi"><span id="b199" class="mc jm hi ly b fi md me l mf mg">WITH<br/>  data AS (<br/>  SELECT<br/>    'Whiskey' a,<br/>    'whisky' b<br/>  UNION ALL<br/>  SELECT<br/>    'drinjs' a,<br/>    'Drinks' b<br/>  UNION ALL<br/>  SELECT<br/>    'Chandler Bing' a,<br/>    'Miss Chanandler Bong' b)<br/>SELECT<br/>  a,<br/>  b,<br/>  `dq.dq_fm_LevenshteinDistance`(a, b) as ldistance<br/>FROM<br/>  data</span></pre><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mi"><img src="../Images/8c6f0628aed1b4dff20ef18b3bf07d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*vCAubCsmxtJHPr5OkIWQKg.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">看起来很管用！</figcaption></figure><p id="67fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们做几件事来看看这两者是如何协同工作的。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="2a0e" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">一起更好！</h1><p id="e8fd" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">使用Soundex，我们本质上是将元数据附加到现有的数据元素上，所以这非常简单。对于编辑距离，我们正在进行逐个比较。将原始数据集中的全部380，000个姓名与新数据集中的全部379，999个(ish)姓名进行比较，将会比我们想要或需要做的要多得多。这就是将Soundex和编辑距离结合起来使事情变得更简单的地方。获取每个元素并将编辑距离与同一Soundex代码中的所有其他元素进行比较，这大大减少了需要进行比较的次数。它可能看起来有点像这样:</p><pre class="kp kq kr ks fd lx ly lz ma aw mb bi"><span id="990c" class="mc jm hi ly b fi md me l mf mg">WITH<br/>  # Create base table of last names with Soundex codes<br/>  name_data AS (<br/>  SELECT<br/>    lname,<br/>    `dq.dq_fm_Soundex`(lname) soundex_code<br/>  FROM<br/>    `dq.name_data`<br/>  WHERE<br/>    lname IS NOT NULL),<br/>  # Create table that's joined with itself on the Soundex code<br/>  joined_data AS (<br/>  SELECT<br/>    p.lname AS p_lname,<br/>    c.lname c_lname,<br/>    p.soundex_code<br/>  FROM<br/>    name_data p,<br/>    name_data c<br/>  WHERE<br/>    p.soundex_code = c.soundex_code<br/>    AND p.lname != c.lname)<br/># Apply Levenshtein Distance to each pair<br/>SELECT<br/>  *,<br/>  `dq.dq_fm_LevenshteinDistance`(p_lname, c_lname) AS ldistance<br/>FROM<br/>  joined_data<br/>ORDER BY<br/>  soundex_code,<br/>  p_lname ASC</span></pre><p id="0f35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来成功了！我想指出查询执行细节中的一些内容。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/d0591786c6843036a0fe31e232114a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgSzQiVzoQTfBzP84fOgzw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">我们的查询执行详情！</figcaption></figure><p id="bba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一件事是Join+阶段产生的行数。这告诉我们，我们必须从包含所有要进行的比较的数据集中运行超过1 . 11亿行的计算。说到这里，接下来我想指出的是经过的时间。8分43秒。很快，如果你问我的话。</p><p id="b9d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看看“职务信息”选项卡。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mo"><img src="../Images/5b9e8ab0ea0521342aa06da29d7b2c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*s4umgsBN8nhESDNxqQ8XSQ.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">基于消费的最佳定价。</figcaption></figure><p id="f782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是BigQuery 的<a class="ae jd" href="https://cloud.google.com/bigquery/pricing#on_demand_pricing" rel="noopener ugc nofollow" target="_blank">按需定价指标，仅供参考。</a></p><p id="9b1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到数据，让我们将前面查询的结果保存到另一个表中，以便我们更容易使用！我们将看看一个示例Soundex代码，看看它是什么样子的。选择distinct以消除普查年度中“常用名”重叠的重复项。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mp"><img src="../Images/581e6a09c60b3d75c396163c966358a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kFBJi8Db4X6FlRvjIIsfA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">这是一个相当高的编辑距离。</figcaption></figure><p id="8b1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当在这里查看结果数据时，我们看到它得到了所有可能的<em class="lt">距离</em>值的结果。如此处所示，它撒的网太广，没有多大用处。例如，很明显“Garcy”和“Grohowski”是不同的。让我们稍微调整一下，看看Levenshtein距离小于4的元素。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mq"><img src="../Images/5b49258c0d2969f7f67a59b8de10f9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qz8oQhQ9sIq1M7QdX_49Iw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">啊，这些近多了。</figcaption></figure><p id="f45c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会立即注意到，通过减少编辑距离的范围，你开始得到更接近的东西。通过缩小语音匹配组的比较范围，我们也提高了性能。“乔治乌”的例子显示的结果更有可能是相同的。</p><p id="bba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，这不是一个完整的模糊匹配方法，但它显示了我们可以多快地开始组装所需的部件，以提出一个可靠的匹配策略。这是两个可能的元素，您可以将其用作多标准匹配策略的一部分。</p><p id="44fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再一次，去下一个…</p></div></div>    
</body>
</html>