<html>
<head>
<title>Serverless Eventing: Modernizing Legacy Streaming with Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器事件:用Kafka实现传统流媒体的现代化</h1>
<blockquote>原文：<a href="https://medium.com/google-cloud/serverless-eventing-modernizing-legacy-streaming-with-kafka-cf07b82067b2?source=collection_archive---------0-----------------------#2020-05-01">https://medium.com/google-cloud/serverless-eventing-modernizing-legacy-streaming-with-kafka-cf07b82067b2?source=collection_archive---------0-----------------------#2020-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/acfbdcf5ee2e6c66bb0ac4cf063bf9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yjRIDdE8NI9jTvjVhgjZYA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">无服务器事件</figcaption></figure><p id="1fb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://knative.dev/docs/eventing/" rel="noopener ugc nofollow" target="_blank"> Knative Eventing </a>提供了多种事件源，用于构建无服务器事件平台。在我的<a class="ae jo" href="https://thejaysmith.com/titles/blogroll/serverless-eventing-sinkbinding-101/" rel="noopener ugc nofollow" target="_blank">上一篇博文</a>中，我谈到了<a class="ae jo" href="https://github.com/TheJaySmith/serverless-eventing/tree/master/tutorials/twitter-sink-binding" rel="noopener ugc nofollow" target="_blank"> SinkBinding </a>，我们用这个概念创建了一个事件源来获取Twitter数据。</p><p id="b1f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，当您有一个遗留系统时会发生什么呢？仅仅为了用“最新最棒的”来替代一个正常运行的系统，通常是没有实际意义的。此外，软件解决方案很少适合“一刀切”的方法。你也可能会发现自己处于“混合”或“棕色地带”的情况。</p><p id="ba35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，您可能有一个遗留消息总线，它不仅用于您的无服务器应用程序，还用于物联网设备。这是一个关于何时拥有“混合环境”的完美例子。仅仅为了改进后端而拆除一个工作系统是没有意义的。我们仍然可以用无服务器事件更新我们的应用程序。</p><p id="d279" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我是<a class="ae jo" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a>的粉丝。诚然，我在谷歌工作之前对卡夫卡了解不多。通过我的互动，我认识了<a class="ae jo" href="https://www.confluent.io/" rel="noopener ugc nofollow" target="_blank">汇合</a>的人，他们教会了我卡夫卡的来龙去脉。Scalyr有一篇令人惊叹的博文<a class="ae jo" href="https://www.scalyr.com/blog/kafka-use-cases-message-brokering/" rel="noopener ugc nofollow" target="_blank">深入探讨了卡夫卡的好处。Confluent也有一些关于Kafka的企业用例的信息。</a></p><p id="608b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的TL；DR认为Kafka是一个开源的流处理平台，具有高吞吐量、低延迟和可靠的发送。对于那些希望确保消息按照接收顺序实时可靠发送的人来说，这是非常理想的。这可能就是为什么很多财富100强公司使用它们的原因。</p><p id="a7c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个演示中，我们将使用<a class="ae jo" href="https://docs.confluent.io/current/tutorials/examples/kubernetes/gke-base/docs/index.html" rel="noopener ugc nofollow" target="_blank">融合云操作符</a>。还有许多其他的操作符，比如Strimzi，但是我选择合流操作符有几个原因。</p><p id="4e9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1)更成熟一点。Strimzi仍然被视为一个CNCF沙盒项目，而Confluent操作符目前被用于生产开发。<br/> 2)更大的社区<br/> 3)附带一些有趣的工具，如<a class="ae jo" href="https://www.confluent.io/confluent-control-center/" rel="noopener ugc nofollow" target="_blank">控制中心</a> <br/> 4)我玩它已经很久了</p><p id="f87e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们来看看我的<a class="ae jo" href="https://github.com/TheJaySmith/serverless-eventing/tree/master/tutorials/kafka" rel="noopener ugc nofollow" target="_blank">教程在这里</a>。我会等你完成</p><p id="ff70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">做实验室</strong></p><p id="6f62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">回来</strong></p><p id="00cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那很有趣，不是吗？我们基本上创建了一个应用程序，它将提取货币兑换信息，并将其发送给Kafka生产者。虽然这个简单的例子看起来不太像，但想象一下，有100个微服务，它们都使用货币进行自己的处理，并且需要将它们发送到Kafka。让开发人员将连接器硬编码到每个微服务中，让Kafka管理员诊断许多故障点，这有意义吗？支持多个库怎么样，因为有些服务是用NodeJS写的，有些是用Go写的，有些是用Python写的？</p><p id="2666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以创建一个服务，简单地将数据输出到容器之外，并让SinkBinding决定这些消息应该去往何处。然后，您可以使用通道、代理和触发器连接到事件接收器，事件接收器可以是一个服务或多个服务。你可以想象有一个代码库来处理Kakfa事件生产，同时支持多个微服务。</p><p id="6ee0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一次，我们将学习如何使用无服务器事件。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="83d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jw">原载于2020年5月1日https://thejaysmith.com</em><a class="ae jo" href="https://thejaysmith.com/titles/serverlessjay/serverless-eventing-modernizing-legacy-streaming-with-kafka/" rel="noopener ugc nofollow" target="_blank"><em class="jw"/></a><em class="jw">。</em></p></div></div>    
</body>
</html>